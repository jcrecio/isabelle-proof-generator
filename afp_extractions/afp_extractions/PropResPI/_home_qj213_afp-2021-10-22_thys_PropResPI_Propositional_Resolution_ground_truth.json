{"file_name": "/home/qj213/afp-2021-10-22/thys/PropResPI/Propositional_Resolution.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PropResPI", "problem_names": ["lemma atom_property : \"A = (atom L) \\<Longrightarrow> (L = (Pos A) \\<or> L = (Neg A))\"", "lemma atoms_formula_subset: \"S1 \\<subseteq> S2 \\<Longrightarrow> atoms_formula S1 \\<subseteq> atoms_formula S2\"", "lemma atoms_formula_union: \"atoms_formula (S1 \\<union> S2) = atoms_formula S1 \\<union> atoms_formula S2\"", "lemma literal_ordering_trans : \n  assumes \"literal_ordering A B\"\n  assumes \"literal_ordering B C\"\n  shows \"literal_ordering A C\"", "lemma entails_member:\n  assumes \"C \\<in> S\"\n  shows \"entails S C\"", "lemma equivalent_symmetric: \"equivalent S1 S2 \\<Longrightarrow> equivalent S2 S1\"", "lemma entailment_implies_validity:\n  assumes \"entails_formula S1 S2\"\n  assumes \"validate_formula I S1\"\n  shows \"validate_formula I S2\"", "lemma validity_implies_entailment:\n  assumes \"\\<forall>I. validate_formula I S1 \\<longrightarrow> validate_formula I S2\"\n  shows \"entails_formula S1 S2\"", "lemma entails_transitive:\n  assumes \"entails_formula S1 S2\"\n  assumes \"entails_formula S2 S3\"\n  shows \"entails_formula S1 S3\"", "lemma equivalent_transitive:\n  assumes \"equivalent S1 S2\"\n  assumes \"equivalent S2 S3\"\n  shows \"equivalent S1 S3\"", "lemma entailment_subset :\n  assumes \"S2 \\<subseteq> S1\"\n  shows \"entails_formula S1 S2\"", "lemma entailed_formula_entails_implicates:\n  assumes \"entails_formula S1 S2\"\n  assumes \"entails S2 C\"\n  shows \"entails S1 C\"", "lemma less_restrictive_and_finite :\n  assumes \"less_restrictive R1 R2\"\n  assumes \"derived_clauses_are_finite R1\"\n  shows \"derived_clauses_are_finite R2\"", "lemma resolvent_upon_is_resolvent : \n  assumes \"Pos A \\<in> P1\"\n  assumes \"Neg A \\<in> P2\"\n  shows \"resolvent P1 P2 (resolvent_upon P1 P2 A)\"", "lemma resolvent_is_resolvent_upon : \n  assumes \"resolvent P1 P2 C\"\n  shows \"\\<exists>A. C = resolvent_upon P1 P2 A\"", "lemma resolvent_is_finite :\n  shows \"derived_clauses_are_finite resolvent\"", "lemma resolution_and_max_literal : \n  assumes \"R = resolvent_upon P1 P2 A\"\n  assumes \"strictly_maximal_literal P1 (Pos A)\"\n  assumes \"strictly_maximal_literal P2 (Neg A)\"\n  assumes \"strictly_maximal_literal R M\"\n  shows \"(atom M, A) \\<in> atom_ordering\"", "lemma ordered_resolvent_is_resolvent : \"less_restrictive resolvent ordered_resolvent\"", "lemma ordered_sel_resolvent_is_ordered_resolvent : \n assumes \"ordered_resolvent P1 P2 C\"\n assumes \"selected_part Sel P1 = {}\"\n assumes \"selected_part Sel P2 = {}\"\n shows \"ordered_sel_resolvent Sel P1 P2 C\"", "lemma ordered_resolvent_upon_is_resolvent : \n  assumes \"strictly_maximal_literal P1 (Pos A)\"\n  assumes \"strictly_maximal_literal P2 (Neg A)\"\n  shows \"ordered_resolvent P1 P2 (resolvent_upon P1 P2 A)\"", "lemma ordered_model_resolvent_is_resolvent : \"less_restrictive resolvent (ordered_model_resolvent I)\"", "lemma unit_resolvent_is_resolvent : \"less_restrictive resolvent unit_resolvent\"", "lemma decomposition_clause_pos_neg :\n  \"C = (negative_part C) \\<union> (positive_part C)\"", "lemma positive_resolvent_is_resolvent : \"less_restrictive resolvent ordered_positive_resolvent\"", "lemma negative_resolvent_is_resolvent : \"less_restrictive resolvent ordered_negative_resolvent\"", "lemma tautology_monotonous : \"(tautology C) \\<Longrightarrow> (C \\<subseteq> D) \\<Longrightarrow> (tautology D)\"", "lemma simplify_involutive:\n  shows \"simplify (simplify S) = (simplify S)\"", "lemma simplify_finite:\n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (simplify S)\"", "lemma atoms_formula_simplify:\n  shows \"atoms_formula (simplify S) \\<subseteq> atoms_formula S\"", "lemma subsumption_preserves_redundancy :\n  assumes \"redundant C S\"\n  assumes \"subsumes C D\" \n  shows \"redundant D S\"", "lemma subsumption_and_max_literal : \n  assumes \"subsumes C1 C2\"\n  assumes \"strictly_maximal_literal C1 L1\"\n  assumes \"strictly_maximal_literal C2 L2\"\n  assumes \"A1 = atom L1\"\n  assumes \"A2 = atom L2\"\n  shows \"(A1 = A2) \\<or> (A1,A2) \\<in> atom_ordering\"", "lemma superset_preserves_redundancy: \n  assumes \"redundant C S\"\n  assumes \"S \\<subseteq> S'\"\n  shows \"redundant C S'\"", "lemma superset_preserves_strict_redundancy: \n  assumes \"strictly_redundant C S\"\n  assumes \"S \\<subseteq> SS\"\n  shows \"strictly_redundant C SS\"", "lemma tautologies_are_valid : \n  assumes \"tautology C\"\n  shows \"validate_clause I C\"", "lemma subsumption_and_semantics : \n  assumes \"subsumes C D\"\n  assumes \"validate_clause I C\"\n  shows \"validate_clause I D\"", "lemma redundancy_and_semantics : \n  assumes \"redundant C S\"\n  assumes \"validate_formula I S\"\n  shows \"validate_clause I C\"", "lemma redundancy_implies_entailment:\n  assumes \"redundant C S\"\n  shows \"entails S C\"", "lemma simplify_and_membership :\n  assumes \"all_fulfill finite S\"\n  assumes \"T = simplify S\"\n  assumes \"C \\<in> S\"\n  shows \"redundant C T\"", "lemma simplify_preserves_redundancy: \n  assumes \"all_fulfill finite S\"\n  assumes \"redundant C S\"\n  shows \"redundant C (simplify S)\"", "lemma simplify_preserves_strict_redundancy: \n  assumes \"all_fulfill finite S\"\n  assumes \"strictly_redundant C S\"\n  shows \"strictly_redundant C (simplify S)\"", "lemma simplify_preserves_semantic : \n  assumes \"T = simplify S\"\n  assumes \"all_fulfill finite S\"\n  shows \"validate_formula I S \\<longleftrightarrow> validate_formula I T\"", "lemma simplify_preserves_equivalence : \n  assumes \"T = simplify S\"\n  assumes \"all_fulfill finite S\"\n  shows \"equivalent S T\"", "lemma simplify_non_redundant:\n  shows \"non_redundant (simplify S)\"", "lemma deducible_clause_preserve_redundancy:\n  assumes \"redundant C S\"\n  shows \"redundant C (add_all_deducible_clauses R S)\"", "lemma inverse_renaming : \"(rename_literal A (rename_literal A L)) = L\"", "lemma inverse_clause_renaming : \"(rename_clause A (rename_clause A L)) = L\"", "lemma inverse_formula_renaming : \"rename_formula A (rename_formula A L) = L\"", "lemma renaming_preserves_cardinality :\n  \"card (rename_clause A C) = card C\"", "lemma renaming_preserves_literal_order :\n  assumes \"literal_ordering L1 L2\"\n  shows \"literal_ordering (rename_literal A L1) (rename_literal A L2)\"", "lemma inverse_renaming_preserves_literal_order :\n  assumes  \"literal_ordering (rename_literal A L1) (rename_literal A L2)\"\n  shows \"literal_ordering L1 L2\"", "lemma renaming_is_injective:\n  assumes \"rename_literal A L1 = rename_literal A L2\"\n  shows \"L1 = L2\"", "lemma renaming_preserves_strictly_maximal_literal :\n  assumes \"strictly_maximal_literal C L\"\n  shows \"strictly_maximal_literal (rename_clause A C) (rename_literal A L)\"", "lemma renaming_and_selected_part :\n  \"selected_part UNIV C = rename_clause Sel (validated_part Sel (rename_clause Sel C))\"", "lemma renaming_preserves_tautology:\n  assumes \"tautology C\"\n  shows \"tautology (rename_clause Sel C)\"", "lemma rename_union : \"rename_clause Sel (C \\<union> D) = rename_clause Sel C \\<union> rename_clause Sel D\"", "lemma renaming_set_minus_subset : \n  \"rename_clause Sel (C - { L }) \\<subseteq> rename_clause Sel C - {rename_literal Sel L }\"", "lemma renaming_set_minus : \"rename_clause Sel (C - { L }) \n  = (rename_clause Sel C) - {rename_literal Sel L }\"", "lemma renaming_preserves_semantic :\n  assumes \"validate_literal I L\"\n  shows \"validate_literal (rename_interpretation Sel I) (rename_literal Sel L)\"", "lemma renaming_preserves_satisfiability:\n  assumes \"satisfiable S\"\n  shows \"satisfiable (rename_formula Sel S)\"", "lemma renaming_preserves_subsumption:\n  assumes \"subsumes C D\"\n  shows \"subsumes (rename_clause Sel C) (rename_clause Sel D)\"", "lemma soundness_and_entailment :\n  assumes \"Sound Rule\"\n  assumes \"Rule P1 P2 C\"\n  assumes \"P1 \\<in> S\"\n  assumes \"P2 \\<in> S\"\n  shows \"entails S C\"", "lemma all_deducible_sound:\n  assumes \"Sound R\"\n  shows \"entails_formula S (all_deducible_clauses R S)\"", "lemma add_all_deducible_sound:\n  assumes \"Sound R\"\n  shows \"entails_formula S (add_all_deducible_clauses R S)\"", "lemma less_restrictive_correct:\n  assumes \"less_restrictive R1 R2\"\n  assumes \"Sound R1\"\n  shows \"Sound R2\"", "theorem resolution_is_correct: \n  \"(Sound resolvent)\"", "theorem ordered_resolution_correct : \"Sound ordered_resolvent\"", "theorem ordered_model_resolution_correct : \"Sound (ordered_model_resolvent I)\"", "theorem ordered_positive_resolution_correct : \"Sound ordered_positive_resolvent\"", "theorem ordered_negative_resolution_correct : \"Sound ordered_negative_resolvent\"", "theorem unit_resolvent_correct : \"Sound unit_resolvent\"", "lemma less_restrictive_saturated:\n  assumes \"less_restrictive R1 R2\"\n  assumes \"saturated_binary_rule R1 S\"\n  shows \"saturated_binary_rule R2 S\"", "lemma less_restrictive_complete:\n  assumes \"less_restrictive R1 R2\"\n  assumes \"Complete R2\"\n  shows \"Complete R1\"", "lemma int_validate_cl_with_pos_max : \n  assumes \"strictly_maximal_literal C (Pos A)\"\n  assumes \"C \\<in> S\"\n  shows \"validate_clause (canonic_int_ordered S) C\"", "lemma strictly_maximal_literal_exists : \n\n  \"\\<forall>C. (((finite C) \\<and> (card C) = n \\<and> n \\<noteq> 0 \\<and> (\\<not> (tautology C)))) \n    \\<longrightarrow> (\\<exists>A. (strictly_maximal_literal C A))\" (is \"?P n\")", "lemma canonic_int_validates_all_clauses : \n  assumes \"saturated_binary_rule ordered_resolvent S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"{} \\<notin> S\"\n  assumes \"C \\<in> S\"\n  shows \"validate_clause (canonic_int_ordered S) C\"", "theorem ordered_resolution_is_complete :\n  \"Complete ordered_resolvent\"", "lemma saturated_ordered_sel_res_empty_sel : \n  assumes \"saturated_binary_rule (ordered_sel_resolvent Sel) S\"\n  shows \"saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\"", "lemma ordered_sel_resolvent_upon_is_resolvent:\n  assumes \"ordered_sel_resolvent_upon Sel P1 P2 C A\"\n  shows \"ordered_sel_resolvent Sel P1 P2 C\"", "lemma resolution_decreases_selected_part:\n  assumes \"ordered_sel_resolvent_upon Sel P1 P2 C A\"\n  assumes \"Neg A \\<in> P2\"\n  assumes \"finite P1\"\n  assumes \"finite P2\"\n  assumes \"card (selected_part Sel P2) = Suc n\"\n  shows \"card (selected_part Sel C) = n\"", "lemma canonic_int_validates_all_clauses_sel : \n  assumes \"saturated_binary_rule (ordered_sel_resolvent Sel) S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"{} \\<notin> S\"\n  assumes \"C \\<in> S\"\n  shows \"validate_clause (canonic_int_ordered (empty_selected_part Sel S)) C\"", "theorem ordered_resolution_is_complete_ordered_sel : \n  \"Complete (ordered_sel_resolvent Sel)\"", "lemma ordered_res_with_selection_is_model_res :\n  assumes \"ordered_sel_resolvent UNIV P1 P2 C\"\n  shows \"ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2) \n            (rename_clause Sel C)\"", "theorem ordered_resolution_is_complete_model_resolution:\n  \"Complete (ordered_model_resolvent Sel)\"", "lemma empty_interpretation_validate :\n  \"validate_literal {} L = (\\<exists>A. (L = Neg A))\"", "lemma universal_interpretation_validate :\n  \"validate_literal UNIV L = (\\<exists>A. (L = Pos A))\"", "lemma negative_part_lemma:\n  \"(negative_part C) = (validated_part {} C)\"", "lemma positive_part_lemma:\n  \"(positive_part C) = (validated_part UNIV C)\"", "lemma negative_resolvent_is_model_res:\n  \"less_restrictive ordered_negative_resolvent (ordered_model_resolvent UNIV)\"", "lemma positive_resolvent_is_model_res:\n  \"less_restrictive ordered_positive_resolvent (ordered_model_resolvent {})\"", "theorem ordered_positive_resolvent_is_complete : \"Complete ordered_positive_resolvent\"", "theorem ordered_negative_resolvent_is_complete: \"Complete ordered_negative_resolvent\"", "theorem unit_resolvent_complete_for_Horn_renamable_set:\n  assumes \"saturated_binary_rule unit_resolvent S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"{} \\<notin> S\" \n  assumes \"Horn_renamable_formula S\"\n  shows \"satisfiable S\"", "theorem ordered_resolvent_is_finite : \"derived_clauses_are_finite ordered_resolvent\"", "theorem model_resolvent_is_finite : \"derived_clauses_are_finite (ordered_model_resolvent I)\"", "theorem positive_resolvent_is_finite : \"derived_clauses_are_finite ordered_positive_resolvent\"", "theorem negative_resolvent_is_finite : \"derived_clauses_are_finite ordered_negative_resolvent\"", "theorem unit_resolvent_is_finite : \"derived_clauses_are_finite unit_resolvent\"", "lemma all_deducible_clauses_are_finite:\n  assumes \"derived_clauses_are_finite R\"\n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (all_deducible_clauses R S)\"", "lemma all_inferred_clause_sets_are_finite: \n  assumes \"derived_clauses_are_finite R\" \n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (inferred_clause_sets R S N)\"", "lemma add_all_deducible_clauses_finite: \n  assumes \"derived_clauses_are_finite R\" \n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (add_all_deducible_clauses R (inferred_clause_sets R S N))\"", "lemma sequence_of_inferred_clause_sets_is_monotonous: \n assumes \"derived_clauses_are_finite R\"\n assumes \"all_fulfill finite S\"\n shows \"\\<forall>C. redundant C (inferred_clause_sets R S N) \n  \\<longrightarrow> redundant C (inferred_clause_sets R S (N+M::nat))\"", "lemma non_persistent_clauses_are_redundant:\n  assumes \"D \\<in> inferred_clause_sets R S N\"\n  assumes \"D \\<notin> saturation R S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"derived_clauses_are_finite R\"\n  shows \"\\<exists>M. strictly_redundant D (inferred_clause_sets R S M)\"", "lemma persistent_clauses_subsume_redundant_clauses:\n  assumes \"redundant C (inferred_clause_sets R S N)\"\n  assumes \"all_fulfill finite S\"\n  assumes \"derived_clauses_are_finite R\"\n  assumes \"finite C\"\n  shows \"redundant C (saturation R S)\"", "theorem persistent_clauses_are_saturated:\n assumes \"derived_clauses_are_finite R\"\n assumes \"all_fulfill finite S\"\n  shows \"saturated_binary_rule R (saturation R S)\"", "theorem saturation_is_correct: \n  assumes \"Sound R\"\n  assumes \"derived_clauses_are_finite R\"\n  assumes \"all_fulfill finite S\"\n  shows \"equivalent S (saturation R S)\""], "translations": [["", "lemma atom_property : \"A = (atom L) \\<Longrightarrow> (L = (Pos A) \\<or> L = (Neg A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = atom L \\<Longrightarrow> L = Pos A \\<or> L = Neg A", "by (metis atom.elims)"], ["", "fun positive :: \"'at Literal \\<Rightarrow> bool\"\nwhere\n  \"(positive (Pos A)) = True\" |\n  \"(positive (Neg A)) = False\""], ["", "fun negative :: \"'at Literal \\<Rightarrow> bool\"\nwhere\n  \"(negative (Pos A)) = False\" |\n  \"(negative (Neg A)) = True\""], ["", "type_synonym 'a Clause = \"'a Literal set\""], ["", "type_synonym 'a Formula = \"'a Clause set\""], ["", "text \\<open>Note that the clauses are not assumed to be finite (some of the properties below\nhold for infinite clauses).\\<close>"], ["", "text \\<open>The following functions return the set of atoms occurring in a clause or formula.\\<close>"], ["", "fun atoms_clause :: \"'at Clause \\<Rightarrow> 'at set\"\n  where \"atoms_clause C = { A. \\<exists>L. L \\<in> C \\<and> A = atom(L) }\""], ["", "fun atoms_formula :: \"'at Formula \\<Rightarrow> 'at set\"\n  where \"atoms_formula S = { A. \\<exists>C. C \\<in> S \\<and> A \\<in> atoms_clause(C) }\""], ["", "lemma atoms_formula_subset: \"S1 \\<subseteq> S2 \\<Longrightarrow> atoms_formula S1 \\<subseteq> atoms_formula S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S1 \\<subseteq> S2 \\<Longrightarrow>\n    atoms_formula S1 \\<subseteq> atoms_formula S2", "by auto"], ["", "lemma atoms_formula_union: \"atoms_formula (S1 \\<union> S2) = atoms_formula S1 \\<union> atoms_formula S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms_formula (S1 \\<union> S2) =\n    atoms_formula S1 \\<union> atoms_formula S2", "by auto"], ["", "text \\<open>The following predicate is useful to state that every clause in a set fulfills \nsome property.\\<close>"], ["", "definition all_fulfill :: \"('at Clause \\<Rightarrow> bool) \\<Rightarrow> 'at Formula \\<Rightarrow> bool\"\n  where \"all_fulfill P S = (\\<forall>C. (C \\<in> S \\<longrightarrow> (P C)))\""], ["", "text \\<open>The order on atoms induces a (non total) order among literals:\\<close>"], ["", "fun literal_ordering :: \"'at Literal \\<Rightarrow> 'at Literal \\<Rightarrow> bool\"\nwhere\n    \"(literal_ordering L1 L2) = ((atom L1,atom L2) \\<in> atom_ordering)\""], ["", "lemma literal_ordering_trans : \n  assumes \"literal_ordering A B\"\n  assumes \"literal_ordering B C\"\n  shows \"literal_ordering A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal_ordering A C", "using assms(1) assms(2) atom_ordering_trans literal_ordering.simps"], ["proof (prove)\nusing this:\n  literal_ordering A B\n  literal_ordering B C\n  \\<forall>x y z.\n     (x, y) \\<in> atom_ordering \\<longrightarrow>\n     (y, z) \\<in> atom_ordering \\<longrightarrow> (x, z) \\<in> atom_ordering\n  literal_ordering ?L1.0 ?L2.0 =\n  ((atom ?L1.0, atom ?L2.0) \\<in> atom_ordering)\n\ngoal (1 subgoal):\n 1. literal_ordering A C", "by blast"], ["", "definition strictly_maximal_literal :: \"'at Clause \\<Rightarrow> 'at Literal \\<Rightarrow> bool\"\nwhere\n  \"(strictly_maximal_literal S A) \\<equiv> (A \\<in> S) \\<and> (\\<forall>B. ( B \\<in> S \\<and> A \\<noteq> B)  \\<longrightarrow> (literal_ordering B A))\""], ["", "section \\<open>Semantics\\<close>"], ["", "text \\<open>We define the notions of interpretation, satisfiability and entailment and establish  \nsome basic properties.\\<close>"], ["", "type_synonym 'a Interpretation  = \"'a set\""], ["", "fun validate_literal :: \"'at Interpretation \\<Rightarrow> 'at Literal \\<Rightarrow> bool\" (infix \"\\<Turnstile>\" 65)\n  where\n    \"(validate_literal I (Pos A)) = (A \\<in> I)\" |\n    \"(validate_literal I (Neg A)) = (A \\<notin> I)\""], ["", "fun validate_clause :: \"'at Interpretation \\<Rightarrow> 'at Clause \\<Rightarrow> bool\" (infix \"\\<Turnstile>\" 65)\n  where\n    \"(validate_clause I C) = (\\<exists>L. (L \\<in>  C) \\<and> (validate_literal I L))\""], ["", "fun validate_formula :: \"'at Interpretation \\<Rightarrow> 'at Formula \\<Rightarrow> bool\" (infix \"\\<Turnstile>\" 65)\n  where\n    \"(validate_formula I S) = (\\<forall>C. (C \\<in> S \\<longrightarrow> (validate_clause I C)))\""], ["", "definition satisfiable :: \"'at Formula \\<Rightarrow> bool\"\nwhere\n  \"(satisfiable S) \\<equiv> (\\<exists>I. (validate_formula I S))\""], ["", "text \\<open>We define the usual notions of entailment between clauses and formulas.\\<close>"], ["", "definition entails :: \"'at Formula \\<Rightarrow> 'at Clause \\<Rightarrow> bool\"\nwhere\n  \"(entails S C) \\<equiv> (\\<forall>I. (validate_formula I S) \\<longrightarrow> (validate_clause I C))\""], ["", "lemma entails_member:\n  assumes \"C \\<in> S\"\n  shows \"entails S C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails S C", "using assms"], ["proof (prove)\nusing this:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. entails S C", "unfolding entails_def"], ["proof (prove)\nusing this:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>I. I \\<Turnstile> S \\<longrightarrow> I \\<Turnstile> C", "by simp"], ["", "definition entails_formula :: \"'at Formula \\<Rightarrow> 'at Formula \\<Rightarrow> bool\"\n  where \"(entails_formula S1 S2) = (\\<forall>C \\<in> S2. (entails S1 C))\""], ["", "definition equivalent :: \"'at Formula \\<Rightarrow> 'at Formula \\<Rightarrow> bool\"\n  where \"(equivalent S1 S2) = (entails_formula S1 S2 \\<and> entails_formula S2 S1)\""], ["", "lemma equivalent_symmetric: \"equivalent S1 S2 \\<Longrightarrow> equivalent S2 S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent S1 S2 \\<Longrightarrow> equivalent S2 S1", "by (simp add: equivalent_def)"], ["", "lemma entailment_implies_validity:\n  assumes \"entails_formula S1 S2\"\n  assumes \"validate_formula I S1\"\n  shows \"validate_formula I S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> S2", "using assms entails_def entails_formula_def"], ["proof (prove)\nusing this:\n  entails_formula S1 S2\n  I \\<Turnstile> S1\n  entails ?S ?C \\<equiv>\n  \\<forall>I. I \\<Turnstile> ?S \\<longrightarrow> I \\<Turnstile> ?C\n  entails_formula ?S1.0 ?S2.0 = (\\<forall>C\\<in>?S2.0. entails ?S1.0 C)\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> S2", "by auto"], ["", "lemma validity_implies_entailment:\n  assumes \"\\<forall>I. validate_formula I S1 \\<longrightarrow> validate_formula I S2\"\n  shows \"entails_formula S1 S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula S1 S2", "by (meson assms entails_def entails_formula_def validate_formula.elims(2))"], ["", "lemma entails_transitive:\n  assumes \"entails_formula S1 S2\"\n  assumes \"entails_formula S2 S3\"\n  shows \"entails_formula S1 S3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula S1 S3", "by (meson assms entailment_implies_validity validity_implies_entailment)"], ["", "lemma equivalent_transitive:\n  assumes \"equivalent S1 S2\"\n  assumes \"equivalent S2 S3\"\n  shows \"equivalent S1 S3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent S1 S3", "using assms entails_transitive equivalent_def"], ["proof (prove)\nusing this:\n  equivalent S1 S2\n  equivalent S2 S3\n  \\<lbrakk>entails_formula ?S1.0 ?S2.0; entails_formula ?S2.0 ?S3.0\\<rbrakk>\n  \\<Longrightarrow> entails_formula ?S1.0 ?S3.0\n  equivalent ?S1.0 ?S2.0 =\n  (entails_formula ?S1.0 ?S2.0 \\<and> entails_formula ?S2.0 ?S1.0)\n\ngoal (1 subgoal):\n 1. equivalent S1 S3", "by auto"], ["", "lemma entailment_subset :\n  assumes \"S2 \\<subseteq> S1\"\n  shows \"entails_formula S1 S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula S1 S2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. entails_formula S1 S2", "have \"\\<forall>L La. L \\<notin> La \\<or> entails La L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L La. L \\<notin> La \\<or> entails La L", "by (meson entails_member)"], ["proof (state)\nthis:\n  \\<forall>L La. L \\<notin> La \\<or> entails La L\n\ngoal (1 subgoal):\n 1. entails_formula S1 S2", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>L La. L \\<notin> La \\<or> entails La L\n\ngoal (1 subgoal):\n 1. entails_formula S1 S2", "by (meson assms entails_formula_def rev_subsetD)"], ["proof (state)\nthis:\n  entails_formula S1 S2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma entailed_formula_entails_implicates:\n  assumes \"entails_formula S1 S2\"\n  assumes \"entails S2 C\"\n  shows \"entails S1 C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails S1 C", "using assms entailment_implies_validity entails_def"], ["proof (prove)\nusing this:\n  entails_formula S1 S2\n  entails S2 C\n  \\<lbrakk>entails_formula ?S1.0 ?S2.0; ?I \\<Turnstile> ?S1.0\\<rbrakk>\n  \\<Longrightarrow> ?I \\<Turnstile> ?S2.0\n  entails ?S ?C \\<equiv>\n  \\<forall>I. I \\<Turnstile> ?S \\<longrightarrow> I \\<Turnstile> ?C\n\ngoal (1 subgoal):\n 1. entails S1 C", "by blast"], ["", "section \\<open>Inference Rules\\<close>"], ["", "text \\<open>We first define an abstract notion of a binary inference rule.\\<close>"], ["", "type_synonym 'a BinaryRule = \"'a Clause \\<Rightarrow> 'a Clause \\<Rightarrow> 'a Clause \\<Rightarrow> bool\""], ["", "definition less_restrictive :: \"'at BinaryRule \\<Rightarrow> 'at BinaryRule \\<Rightarrow> bool\"\nwhere\n  \"(less_restrictive R1 R2) = (\\<forall>P1 P2 C. (R2 P1 P2 C) \\<longrightarrow> ((R1 P1 P2 C) \\<or> (R1 P2 P1 C)))\""], ["", "text \\<open>The following functions allow to generate all the clauses that are deducible\nfrom a given clause set (in one step).\\<close>"], ["", "fun all_deducible_clauses:: \"'at BinaryRule \\<Rightarrow> 'at Formula \\<Rightarrow> 'at Formula\"\n  where \"all_deducible_clauses R S = { C. \\<exists>P1 P2. P1 \\<in> S \\<and> P2 \\<in> S \\<and> (R P1 P2 C) }\""], ["", "fun add_all_deducible_clauses:: \"'at BinaryRule \\<Rightarrow> 'at Formula \\<Rightarrow> 'at Formula\"\n  where \"add_all_deducible_clauses R S = (S \\<union> all_deducible_clauses R S)\""], ["", "definition derived_clauses_are_finite :: \"'at BinaryRule \\<Rightarrow> bool\"\n  where \"derived_clauses_are_finite R = \n    (\\<forall>P1 P2 C. (finite P1 \\<longrightarrow> finite P2 \\<longrightarrow> (R P1 P2 C) \\<longrightarrow> finite C))\""], ["", "lemma less_restrictive_and_finite :\n  assumes \"less_restrictive R1 R2\"\n  assumes \"derived_clauses_are_finite R1\"\n  shows \"derived_clauses_are_finite R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derived_clauses_are_finite R2", "by (metis assms derived_clauses_are_finite_def less_restrictive_def)"], ["", "(* takes a few seconds *)"], ["", "text \\<open>We then define the unrestricted resolution rule and usual resolution refinements.\\<close>"], ["", "subsection \\<open>Unrestricted Resolution\\<close>"], ["", "definition resolvent :: \"'at BinaryRule\"\n  where\n  \"(resolvent P1 P2 C) \\<equiv> \n    (\\<exists>A. ((Pos A) \\<in> P1 \\<and> (Neg A) \\<in> P2 \\<and> (C = ( (P1 - { Pos A}) \\<union> ( P2 - { Neg A })))))\""], ["", "text \\<open>For technical convience, we now introduce a slightly extended definition in which resolution \nupon a literal  not occurring in the premises is allowed (the obtained resolvent is then redundant \nwith the premises). If the atom is fixed then this version of the resolution rule can be turned into \na total function.\\<close>"], ["", "fun resolvent_upon :: \"'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> 'at \\<Rightarrow> 'at Clause\"\nwhere\n  \"(resolvent_upon P1 P2 A) =\n      ( (P1 - { Pos A}) \\<union> ( P2 - { Neg A }))\""], ["", "lemma resolvent_upon_is_resolvent : \n  assumes \"Pos A \\<in> P1\"\n  assumes \"Neg A \\<in> P2\"\n  shows \"resolvent P1 P2 (resolvent_upon P1 P2 A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolvent P1 P2 (resolvent_upon P1 P2 A)", "using assms"], ["proof (prove)\nusing this:\n  Pos A \\<in> P1\n  Neg A \\<in> P2\n\ngoal (1 subgoal):\n 1. resolvent P1 P2 (resolvent_upon P1 P2 A)", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  Pos A \\<in> P1\n  Neg A \\<in> P2\n\ngoal (1 subgoal):\n 1. \\<exists>Aa.\n       Pos Aa \\<in> P1 \\<and>\n       Neg Aa \\<in> P2 \\<and>\n       resolvent_upon P1 P2 A = P1 - {Pos Aa} \\<union> (P2 - {Neg Aa})", "by auto"], ["", "lemma resolvent_is_resolvent_upon : \n  assumes \"resolvent P1 P2 C\"\n  shows \"\\<exists>A. C = resolvent_upon P1 P2 A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. C = resolvent_upon P1 P2 A", "using assms"], ["proof (prove)\nusing this:\n  resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. \\<exists>A. C = resolvent_upon P1 P2 A", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     Pos A \\<in> P1 \\<and>\n     Neg A \\<in> P2 \\<and> C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. \\<exists>A. C = resolvent_upon P1 P2 A", "by auto"], ["", "lemma resolvent_is_finite :\n  shows \"derived_clauses_are_finite resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derived_clauses_are_finite resolvent", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> derived_clauses_are_finite resolvent \\<Longrightarrow> False", "assume \"\\<not>derived_clauses_are_finite resolvent\""], ["proof (state)\nthis:\n  \\<not> derived_clauses_are_finite resolvent\n\ngoal (1 subgoal):\n 1. \\<not> derived_clauses_are_finite resolvent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> derived_clauses_are_finite resolvent", "have \"\\<exists>P1 P2 C. \\<not>(resolvent P1 P2 C \\<longrightarrow> finite P1 \\<longrightarrow> finite P2 \\<longrightarrow> finite C)\""], ["proof (prove)\nusing this:\n  \\<not> derived_clauses_are_finite resolvent\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2 C.\n       \\<not> (resolvent P1 P2 C \\<longrightarrow>\n               finite P1 \\<longrightarrow>\n               finite P2 \\<longrightarrow> finite C)", "unfolding derived_clauses_are_finite_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             finite P1 \\<longrightarrow>\n             finite P2 \\<longrightarrow>\n             resolvent P1 P2 C \\<longrightarrow> finite C)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2 C.\n       \\<not> (resolvent P1 P2 C \\<longrightarrow>\n               finite P1 \\<longrightarrow>\n               finite P2 \\<longrightarrow> finite C)", "by blast"], ["proof (state)\nthis:\n  \\<exists>P1 P2 C.\n     \\<not> (resolvent P1 P2 C \\<longrightarrow>\n             finite P1 \\<longrightarrow>\n             finite P2 \\<longrightarrow> finite C)\n\ngoal (1 subgoal):\n 1. \\<not> derived_clauses_are_finite resolvent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1 P2 C.\n     \\<not> (resolvent P1 P2 C \\<longrightarrow>\n             finite P1 \\<longrightarrow>\n             finite P2 \\<longrightarrow> finite C)", "obtain P1 P2 C where \"resolvent P1 P2 C\" \"finite P1\" \"finite P2\" and \"\\<not>finite C\""], ["proof (prove)\nusing this:\n  \\<exists>P1 P2 C.\n     \\<not> (resolvent P1 P2 C \\<longrightarrow>\n             finite P1 \\<longrightarrow>\n             finite P2 \\<longrightarrow> finite C)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>resolvent P1 P2 C; finite P1; finite P2;\n         infinite C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  resolvent P1 P2 C\n  finite P1\n  finite P2\n  infinite C\n\ngoal (1 subgoal):\n 1. \\<not> derived_clauses_are_finite resolvent \\<Longrightarrow> False", "from \\<open>resolvent P1 P2 C\\<close> \\<open>finite P1\\<close> \\<open>finite P2\\<close> and \\<open>\\<not>finite C\\<close>"], ["proof (chain)\npicking this:\n  resolvent P1 P2 C\n  finite P1\n  finite P2\n  infinite C", "show \"False\""], ["proof (prove)\nusing this:\n  resolvent P1 P2 C\n  finite P1\n  finite P2\n  infinite C\n\ngoal (1 subgoal):\n 1. False", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     Pos A \\<in> P1 \\<and>\n     Neg A \\<in> P2 \\<and> C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  finite P1\n  finite P2\n  infinite C\n\ngoal (1 subgoal):\n 1. False", "using finite_Diff and finite_Union"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     Pos A \\<in> P1 \\<and>\n     Neg A \\<in> P2 \\<and> C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  finite P1\n  finite P2\n  infinite C\n  finite ?A \\<Longrightarrow> finite (?A - ?B)\n  \\<lbrakk>finite ?A;\n   \\<And>M. M \\<in> ?A \\<Longrightarrow> finite M\\<rbrakk>\n  \\<Longrightarrow> finite (\\<Union> ?A)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the next subsections we introduce various resolution refinements and show that they are \nmore restrictive than unrestricted resolution.\\<close>"], ["", "subsection \\<open>Ordered Resolution\\<close>"], ["", "text \\<open>In the first refinement, resolution is only allowed on maximal literals.\\<close>"], ["", "definition ordered_resolvent :: \"'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> bool\" \n  where\n  \"(ordered_resolvent P1 P2 C) \\<equiv> \n    (\\<exists>A. ((C = ( (P1 - { Pos A}) \\<union> ( P2 - { Neg A })))\n      \\<and> (strictly_maximal_literal P1 (Pos A)) \\<and> (strictly_maximal_literal P2 (Neg A))))\""], ["", "text \\<open>We now show that the maximal literal of the resolvent is always smaller than those of \nthe premises.\\<close>"], ["", "lemma resolution_and_max_literal : \n  assumes \"R = resolvent_upon P1 P2 A\"\n  assumes \"strictly_maximal_literal P1 (Pos A)\"\n  assumes \"strictly_maximal_literal P2 (Neg A)\"\n  assumes \"strictly_maximal_literal R M\"\n  shows \"(atom M, A) \\<in> atom_ordering\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom M, A) \\<in> atom_ordering", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (atom M, A) \\<in> atom_ordering", "obtain MA where \"M = (Pos MA) \\<or> M = (Neg MA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>MA.\n        M = Pos MA \\<or> M = Neg MA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of M]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. M = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. M = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>MA.\n        M = Pos MA \\<or> M = Neg MA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M = Pos MA \\<or> M = Neg MA\n\ngoal (1 subgoal):\n 1. (atom M, A) \\<in> atom_ordering", "hence \"MA = (atom M)\""], ["proof (prove)\nusing this:\n  M = Pos MA \\<or> M = Neg MA\n\ngoal (1 subgoal):\n 1. MA = atom M", "by auto"], ["proof (state)\nthis:\n  MA = atom M\n\ngoal (1 subgoal):\n 1. (atom M, A) \\<in> atom_ordering", "from \\<open>strictly_maximal_literal R M\\<close> and \\<open>R = resolvent_upon P1 P2 A\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal R M\n  R = resolvent_upon P1 P2 A", "have \"M \\<in> P1 - { Pos A } \\<or> M \\<in> P2 - { Neg A }\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal R M\n  R = resolvent_upon P1 P2 A\n\ngoal (1 subgoal):\n 1. M \\<in> P1 - {Pos A} \\<or> M \\<in> P2 - {Neg A}", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  M \\<in> R \\<and>\n  (\\<forall>B.\n      B \\<in> R \\<and> M \\<noteq> B \\<longrightarrow> literal_ordering B M)\n  R = resolvent_upon P1 P2 A\n\ngoal (1 subgoal):\n 1. M \\<in> P1 - {Pos A} \\<or> M \\<in> P2 - {Neg A}", "by auto"], ["proof (state)\nthis:\n  M \\<in> P1 - {Pos A} \\<or> M \\<in> P2 - {Neg A}\n\ngoal (1 subgoal):\n 1. (atom M, A) \\<in> atom_ordering", "hence \"(MA,A) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  M \\<in> P1 - {Pos A} \\<or> M \\<in> P2 - {Neg A}\n\ngoal (1 subgoal):\n 1. (MA, A) \\<in> atom_ordering", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M \\<in> P1 - {Pos A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering\n 2. M \\<in> P2 - {Neg A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering", "assume \"M \\<in> P1 - { Pos A }\""], ["proof (state)\nthis:\n  M \\<in> P1 - {Pos A}\n\ngoal (2 subgoals):\n 1. M \\<in> P1 - {Pos A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering\n 2. M \\<in> P2 - {Neg A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering", "from \\<open>M \\<in> P1 - { Pos A }\\<close> and \\<open>strictly_maximal_literal P1 (Pos A)\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> P1 - {Pos A}\n  strictly_maximal_literal P1 (Pos A)", "have \"literal_ordering M (Pos A)\""], ["proof (prove)\nusing this:\n  M \\<in> P1 - {Pos A}\n  strictly_maximal_literal P1 (Pos A)\n\ngoal (1 subgoal):\n 1. literal_ordering M (Pos A)", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  M \\<in> P1 - {Pos A}\n  Pos A \\<in> P1 \\<and>\n  (\\<forall>B.\n      B \\<in> P1 \\<and> Pos A \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos A))\n\ngoal (1 subgoal):\n 1. literal_ordering M (Pos A)", "by auto"], ["proof (state)\nthis:\n  literal_ordering M (Pos A)\n\ngoal (2 subgoals):\n 1. M \\<in> P1 - {Pos A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering\n 2. M \\<in> P2 - {Neg A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering", "from \\<open>M = Pos MA \\<or> M = Neg MA\\<close> and \\<open>literal_ordering M (Pos A)\\<close>"], ["proof (chain)\npicking this:\n  M = Pos MA \\<or> M = Neg MA\n  literal_ordering M (Pos A)", "show \"(MA,A) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  M = Pos MA \\<or> M = Neg MA\n  literal_ordering M (Pos A)\n\ngoal (1 subgoal):\n 1. (MA, A) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (MA, A) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. M \\<in> P2 - {Neg A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<in> P2 - {Neg A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering", "assume \"M \\<in> P2 - { Neg A }\""], ["proof (state)\nthis:\n  M \\<in> P2 - {Neg A}\n\ngoal (1 subgoal):\n 1. M \\<in> P2 - {Neg A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering", "from \\<open>M \\<in> P2 - { Neg A }\\<close> and \\<open>strictly_maximal_literal P2 (Neg A)\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> P2 - {Neg A}\n  strictly_maximal_literal P2 (Neg A)", "have \"literal_ordering M (Neg A)\""], ["proof (prove)\nusing this:\n  M \\<in> P2 - {Neg A}\n  strictly_maximal_literal P2 (Neg A)\n\ngoal (1 subgoal):\n 1. literal_ordering M (Neg A)", "by (auto simp only: strictly_maximal_literal_def)"], ["proof (state)\nthis:\n  literal_ordering M (Neg A)\n\ngoal (1 subgoal):\n 1. M \\<in> P2 - {Neg A} \\<Longrightarrow> (MA, A) \\<in> atom_ordering", "from \\<open>M = Pos MA \\<or> M = Neg MA\\<close> and \\<open>literal_ordering M (Neg A)\\<close>"], ["proof (chain)\npicking this:\n  M = Pos MA \\<or> M = Neg MA\n  literal_ordering M (Neg A)", "show \"(MA,A) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  M = Pos MA \\<or> M = Neg MA\n  literal_ordering M (Neg A)\n\ngoal (1 subgoal):\n 1. (MA, A) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (MA, A) \\<in> atom_ordering\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (MA, A) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. (atom M, A) \\<in> atom_ordering", "from this and \\<open>MA = atom M\\<close>"], ["proof (chain)\npicking this:\n  (MA, A) \\<in> atom_ordering\n  MA = atom M", "show ?thesis"], ["proof (prove)\nusing this:\n  (MA, A) \\<in> atom_ordering\n  MA = atom M\n\ngoal (1 subgoal):\n 1. (atom M, A) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (atom M, A) \\<in> atom_ordering\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Ordered Resolution with Selection\\<close>"], ["", "text \\<open>In the next restriction strategy, some negative literals are selected with highest priority \nfor applying the resolution rule, regardless of the ordering. Relaxed ordering restrictions also \napply.\\<close>"], ["", "definition \"(selected_part Sel C) = { L. L \\<in> C \\<and> (\\<exists>A \\<in> Sel. L = (Neg A)) }\""], ["", "definition ordered_sel_resolvent :: \"'at set \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> bool\" \n  where\n  \"(ordered_sel_resolvent Sel P1 P2 C) \\<equiv> \n    (\\<exists>A. ((C = ( (P1 - { Pos A}) \\<union> ( P2 - { Neg A })))\n      \\<and> (strictly_maximal_literal P1 (Pos A)) \\<and> ((selected_part Sel P1) = {}) \\<and> \n          ( ((strictly_maximal_literal P2 (Neg A)) \\<and> (selected_part Sel P2) = {}) \n          \\<or> (strictly_maximal_literal (selected_part Sel P2) (Neg A)))))\""], ["", "lemma ordered_resolvent_is_resolvent : \"less_restrictive resolvent ordered_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_restrictive resolvent ordered_resolvent", "using less_restrictive_def ordered_resolvent_def resolvent_upon_is_resolvent strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  less_restrictive ?R1.0 ?R2.0 =\n  (\\<forall>P1 P2 C.\n      ?R2.0 P1 P2 C \\<longrightarrow> ?R1.0 P1 P2 C \\<or> ?R1.0 P2 P1 C)\n  ordered_resolvent ?P1.0 ?P2.0 ?C \\<equiv>\n  \\<exists>A.\n     ?C = ?P1.0 - {Pos A} \\<union> (?P2.0 - {Neg A}) \\<and>\n     strictly_maximal_literal ?P1.0 (Pos A) \\<and>\n     strictly_maximal_literal ?P2.0 (Neg A)\n  \\<lbrakk>Pos ?A \\<in> ?P1.0; Neg ?A \\<in> ?P2.0\\<rbrakk>\n  \\<Longrightarrow> resolvent ?P1.0 ?P2.0 (resolvent_upon ?P1.0 ?P2.0 ?A)\n  strictly_maximal_literal ?S ?A \\<equiv>\n  ?A \\<in> ?S \\<and>\n  (\\<forall>B.\n      B \\<in> ?S \\<and> ?A \\<noteq> B \\<longrightarrow>\n      literal_ordering B ?A)\n\ngoal (1 subgoal):\n 1. less_restrictive resolvent ordered_resolvent", "by auto"], ["", "text \\<open>The next lemma states that ordered resolution with selection coincides with ordered \nresolution if the selected part is empty.\\<close>"], ["", "lemma ordered_sel_resolvent_is_ordered_resolvent : \n assumes \"ordered_resolvent P1 P2 C\"\n assumes \"selected_part Sel P1 = {}\"\n assumes \"selected_part Sel P2 = {}\"\n shows \"ordered_sel_resolvent Sel P1 P2 C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_sel_resolvent Sel P1 P2 C", "using assms ordered_resolvent_def ordered_sel_resolvent_def"], ["proof (prove)\nusing this:\n  ordered_resolvent P1 P2 C\n  selected_part Sel P1 = {}\n  selected_part Sel P2 = {}\n  ordered_resolvent ?P1.0 ?P2.0 ?C \\<equiv>\n  \\<exists>A.\n     ?C = ?P1.0 - {Pos A} \\<union> (?P2.0 - {Neg A}) \\<and>\n     strictly_maximal_literal ?P1.0 (Pos A) \\<and>\n     strictly_maximal_literal ?P2.0 (Neg A)\n  ordered_sel_resolvent ?Sel ?P1.0 ?P2.0 ?C \\<equiv>\n  \\<exists>A.\n     ?C = ?P1.0 - {Pos A} \\<union> (?P2.0 - {Neg A}) \\<and>\n     strictly_maximal_literal ?P1.0 (Pos A) \\<and>\n     selected_part ?Sel ?P1.0 = {} \\<and>\n     (strictly_maximal_literal ?P2.0 (Neg A) \\<and>\n      selected_part ?Sel ?P2.0 = {} \\<or>\n      strictly_maximal_literal (selected_part ?Sel ?P2.0) (Neg A))\n\ngoal (1 subgoal):\n 1. ordered_sel_resolvent Sel P1 P2 C", "by auto"], ["", "lemma ordered_resolvent_upon_is_resolvent : \n  assumes \"strictly_maximal_literal P1 (Pos A)\"\n  assumes \"strictly_maximal_literal P2 (Neg A)\"\n  shows \"ordered_resolvent P1 P2 (resolvent_upon P1 P2 A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_resolvent P1 P2 (resolvent_upon P1 P2 A)", "using assms ordered_resolvent_def"], ["proof (prove)\nusing this:\n  strictly_maximal_literal P1 (Pos A)\n  strictly_maximal_literal P2 (Neg A)\n  ordered_resolvent ?P1.0 ?P2.0 ?C \\<equiv>\n  \\<exists>A.\n     ?C = ?P1.0 - {Pos A} \\<union> (?P2.0 - {Neg A}) \\<and>\n     strictly_maximal_literal ?P1.0 (Pos A) \\<and>\n     strictly_maximal_literal ?P2.0 (Neg A)\n\ngoal (1 subgoal):\n 1. ordered_resolvent P1 P2 (resolvent_upon P1 P2 A)", "by auto"], ["", "subsection \\<open>Semantic Resolution\\<close>"], ["", "text \\<open>In this strategy, resolution is applied only if one parent is false in some (fixed) \ninterpretation. Note that ordering restrictions still apply, although they are relaxed.\\<close>"], ["", "definition validated_part :: \"'at set \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause\"\nwhere \"(validated_part I C) = { L. L \\<in> C \\<and> (validate_literal I L) }\""], ["", "definition ordered_model_resolvent :: \n  \"'at Interpretation \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> bool\"\nwhere \n  \"(ordered_model_resolvent I P1 P2 C) = \n    (\\<exists>L. (C = (P1 - { L } \\<union> (P2 - { complement L }))) \\<and>\n      ((validated_part I P1) = {}  \\<and> (strictly_maximal_literal P1 L))\n      \\<and> (strictly_maximal_literal (validated_part I P2) (complement L)))\""], ["", "lemma ordered_model_resolvent_is_resolvent : \"less_restrictive resolvent (ordered_model_resolvent I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_restrictive resolvent (ordered_model_resolvent I)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            (ordered_model_resolvent I) \\<Longrightarrow>\n    False", "assume \"\\<not> less_restrictive resolvent (ordered_model_resolvent I)\""], ["proof (state)\nthis:\n  \\<not> less_restrictive resolvent (ordered_model_resolvent I)\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            (ordered_model_resolvent I) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> less_restrictive resolvent (ordered_model_resolvent I)", "obtain P1 P2 C where \"ordered_model_resolvent I P1 P2 C\" and \"\\<not>resolvent P1 P2 C\" \n    and \"\\<not>resolvent P2 P1 C\""], ["proof (prove)\nusing this:\n  \\<not> less_restrictive resolvent (ordered_model_resolvent I)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>ordered_model_resolvent I P1 P2 C;\n         \\<not> resolvent P1 P2 C; \\<not> resolvent P2 P1 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding less_restrictive_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             ordered_model_resolvent I P1 P2 C \\<longrightarrow>\n             resolvent P1 P2 C \\<or> resolvent P2 P1 C)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>ordered_model_resolvent I P1 P2 C;\n         \\<not> resolvent P1 P2 C; \\<not> resolvent P2 P1 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ordered_model_resolvent I P1 P2 C\n  \\<not> resolvent P1 P2 C\n  \\<not> resolvent P2 P1 C\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            (ordered_model_resolvent I) \\<Longrightarrow>\n    False", "from \\<open>ordered_model_resolvent I P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  ordered_model_resolvent I P1 P2 C", "obtain L \n    where \"strictly_maximal_literal P1 L\" \n    and \"strictly_maximal_literal (validated_part I P2) (complement L)\" \n    and \"C = (P1 - { L }) \\<union> (P2 - { complement L })\""], ["proof (prove)\nusing this:\n  ordered_model_resolvent I P1 P2 C\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>strictly_maximal_literal P1 L;\n         strictly_maximal_literal (validated_part I P2) (complement L);\n         C = P1 - {L} \\<union> (P2 - {complement L})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ordered_model_resolvent_def [of I P1 P2 C]"], ["proof (prove)\nusing this:\n  ordered_model_resolvent I P1 P2 C\n  ordered_model_resolvent I P1 P2 C =\n  (\\<exists>L.\n      C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n      (validated_part I P1 = {} \\<and> strictly_maximal_literal P1 L) \\<and>\n      strictly_maximal_literal (validated_part I P2) (complement L))\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>strictly_maximal_literal P1 L;\n         strictly_maximal_literal (validated_part I P2) (complement L);\n         C = P1 - {L} \\<union> (P2 - {complement L})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal P1 L\n  strictly_maximal_literal (validated_part I P2) (complement L)\n  C = P1 - {L} \\<union> (P2 - {complement L})\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            (ordered_model_resolvent I) \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal P1 L\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal P1 L", "have \"L \\<in> P1\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal P1 L\n\ngoal (1 subgoal):\n 1. L \\<in> P1", "by (simp only: strictly_maximal_literal_def)"], ["proof (state)\nthis:\n  L \\<in> P1\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            (ordered_model_resolvent I) \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal (validated_part I P2) (complement L)\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal (validated_part I P2) (complement L)", "have \"(complement L) \\<in> P2\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal (validated_part I P2) (complement L)\n\ngoal (1 subgoal):\n 1. complement L \\<in> P2", "by (auto simp only: strictly_maximal_literal_def validated_part_def)"], ["proof (state)\nthis:\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            (ordered_model_resolvent I) \\<Longrightarrow>\n    False", "obtain A where \"L = Pos A \\<or> L = Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            (ordered_model_resolvent I) \\<Longrightarrow>\n    False", "from this and \\<open>C = (P1 - { L }) \\<union> (P2 - { complement L })\\<close> and \\<open>L \\<in> P1\\<close> and \\<open>(complement L) \\<in> P2\\<close>"], ["proof (chain)\npicking this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2", "have \"resolvent P1 P2 C \\<or> resolvent P2 P1 C\""], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. resolvent P1 P2 C \\<or> resolvent P2 P1 C", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. (\\<exists>A.\n        Pos A \\<in> P1 \\<and>\n        Neg A \\<in> P2 \\<and>\n        C = P1 - {Pos A} \\<union> (P2 - {Neg A})) \\<or>\n    (\\<exists>A.\n        Pos A \\<in> P2 \\<and>\n        Neg A \\<in> P1 \\<and> C = P2 - {Pos A} \\<union> (P1 - {Neg A}))", "by auto"], ["proof (state)\nthis:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            (ordered_model_resolvent I) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not>resolvent P2 P1 C\\<close> and \\<open>\\<not>resolvent P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n  \\<not> resolvent P2 P1 C\n  \\<not> resolvent P1 P2 C", "show \"False\""], ["proof (prove)\nusing this:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n  \\<not> resolvent P2 P1 C\n  \\<not> resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Unit Resolution\\<close>"], ["", "text \\<open>Resolution is applied only if one parent is unit (this restriction is incomplete).\\<close>"], ["", "definition Unit :: \"'at Clause \\<Rightarrow> bool\"\n  where \"(Unit C) = ((card C) = 1)\""], ["", "definition unit_resolvent :: \"'at BinaryRule\"\n  where \"(unit_resolvent P1 P2 C) =  ((\\<exists>L. (C = ( (P1 - { L}) \\<union> ( P2 - { complement L })))\n      \\<and> L \\<in> P1 \\<and> (complement L) \\<in> P2) \\<and> Unit P1)\""], ["", "lemma unit_resolvent_is_resolvent : \"less_restrictive resolvent unit_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_restrictive resolvent unit_resolvent", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent unit_resolvent \\<Longrightarrow> False", "assume \"\\<not> less_restrictive resolvent unit_resolvent\""], ["proof (state)\nthis:\n  \\<not> less_restrictive resolvent unit_resolvent\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent unit_resolvent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> less_restrictive resolvent unit_resolvent", "obtain P1 P2 C where \"unit_resolvent P1 P2 C\" and \"\\<not>resolvent P1 P2 C\" \n    and \"\\<not>resolvent P2 P1 C\""], ["proof (prove)\nusing this:\n  \\<not> less_restrictive resolvent unit_resolvent\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>unit_resolvent P1 P2 C; \\<not> resolvent P1 P2 C;\n         \\<not> resolvent P2 P1 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding less_restrictive_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             unit_resolvent P1 P2 C \\<longrightarrow>\n             resolvent P1 P2 C \\<or> resolvent P2 P1 C)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>unit_resolvent P1 P2 C; \\<not> resolvent P1 P2 C;\n         \\<not> resolvent P2 P1 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unit_resolvent P1 P2 C\n  \\<not> resolvent P1 P2 C\n  \\<not> resolvent P2 P1 C\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent unit_resolvent \\<Longrightarrow> False", "from \\<open>unit_resolvent P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  unit_resolvent P1 P2 C", "obtain L where \"L \\<in> P1\" and \"complement L \\<in> P2\" \n    and \"C = (P1 - { L }) \\<union> (P2 - { complement L })\""], ["proof (prove)\nusing this:\n  unit_resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> P1; complement L \\<in> P2;\n         C = P1 - {L} \\<union> (P2 - {complement L})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using unit_resolvent_def [of P1 P2 C]"], ["proof (prove)\nusing this:\n  unit_resolvent P1 P2 C\n  unit_resolvent P1 P2 C =\n  ((\\<exists>L.\n       C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n       L \\<in> P1 \\<and> complement L \\<in> P2) \\<and>\n   Unit P1)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> P1; complement L \\<in> P2;\n         C = P1 - {L} \\<union> (P2 - {complement L})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> P1\n  complement L \\<in> P2\n  C = P1 - {L} \\<union> (P2 - {complement L})\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent unit_resolvent \\<Longrightarrow> False", "obtain A where \"L = Pos A \\<or> L = Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent unit_resolvent \\<Longrightarrow> False", "from this and \\<open>C = (P1 - { L }) \\<union> (P2 - { complement L })\\<close> and \\<open>L \\<in> P1\\<close> and \\<open>complement L \\<in> P2\\<close>"], ["proof (chain)\npicking this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2", "have \"resolvent P1 P2 C \\<or> resolvent P2 P1 C\""], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. resolvent P1 P2 C \\<or> resolvent P2 P1 C", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. (\\<exists>A.\n        Pos A \\<in> P1 \\<and>\n        Neg A \\<in> P2 \\<and>\n        C = P1 - {Pos A} \\<union> (P2 - {Neg A})) \\<or>\n    (\\<exists>A.\n        Pos A \\<in> P2 \\<and>\n        Neg A \\<in> P1 \\<and> C = P2 - {Pos A} \\<union> (P1 - {Neg A}))", "by auto"], ["proof (state)\nthis:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent unit_resolvent \\<Longrightarrow> False", "from this and \\<open>\\<not>resolvent P2 P1 C\\<close> and \\<open>\\<not>resolvent P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n  \\<not> resolvent P2 P1 C\n  \\<not> resolvent P1 P2 C", "show \"False\""], ["proof (prove)\nusing this:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n  \\<not> resolvent P2 P1 C\n  \\<not> resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Positive and Negative Resolution\\<close>"], ["", "text \\<open>Resolution is applied only if one parent is positive (resp. negative). Again, relaxed\nordering restrictions apply.\\<close>"], ["", "definition positive_part :: \"'at Clause \\<Rightarrow> 'at Clause\"\nwhere \n  \"(positive_part C) = { L. (\\<exists>A. L = Pos A) \\<and> L \\<in> C }\""], ["", "definition negative_part :: \"'at Clause \\<Rightarrow> 'at Clause\"\nwhere \n  \"(negative_part C) = { L. (\\<exists>A. L = Neg A) \\<and> L \\<in> C }\""], ["", "lemma decomposition_clause_pos_neg :\n  \"C = (negative_part C) \\<union> (positive_part C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = negative_part C \\<union> positive_part C", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<subseteq> negative_part C \\<union> positive_part C\n 2. negative_part C \\<union> positive_part C \\<subseteq> C", "show \"C \\<subseteq> (negative_part C) \\<union> (positive_part C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq> negative_part C \\<union> positive_part C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       x \\<in> negative_part C \\<union> positive_part C", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       x \\<in> negative_part C \\<union> positive_part C", "assume \"x \\<in> C\""], ["proof (state)\nthis:\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       x \\<in> negative_part C \\<union> positive_part C", "obtain A where \"x = Pos A \\<or> x = Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = Pos A \\<or> x = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. x = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. x = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = Pos A \\<or> x = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = Pos A \\<or> x = Neg A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       x \\<in> negative_part C \\<union> positive_part C", "show \"x \\<in> (negative_part C) \\<union> (positive_part C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> negative_part C \\<union> positive_part C", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x \\<in> negative_part C \\<union> positive_part C\n 2. \\<not> ?P \\<Longrightarrow>\n    x \\<in> negative_part C \\<union> positive_part C", "assume \"x = Pos A\""], ["proof (state)\nthis:\n  x = Pos A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x \\<in> negative_part C \\<union> positive_part C\n 2. \\<not> ?P \\<Longrightarrow>\n    x \\<in> negative_part C \\<union> positive_part C", "from this and \\<open>x \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  x = Pos A\n  x \\<in> C", "have \"x \\<in> positive_part C\""], ["proof (prove)\nusing this:\n  x = Pos A\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. x \\<in> positive_part C", "unfolding positive_part_def"], ["proof (prove)\nusing this:\n  x = Pos A\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. x \\<in> {L. (\\<exists>A. L = Pos A) \\<and> L \\<in> C}", "by auto"], ["proof (state)\nthis:\n  x \\<in> positive_part C\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x \\<in> negative_part C \\<union> positive_part C\n 2. \\<not> ?P \\<Longrightarrow>\n    x \\<in> negative_part C \\<union> positive_part C", "then"], ["proof (chain)\npicking this:\n  x \\<in> positive_part C", "show \"x \\<in> (negative_part C) \\<union> (positive_part C)\""], ["proof (prove)\nusing this:\n  x \\<in> positive_part C\n\ngoal (1 subgoal):\n 1. x \\<in> negative_part C \\<union> positive_part C", "by auto"], ["proof (state)\nthis:\n  x \\<in> negative_part C \\<union> positive_part C\n\ngoal (1 subgoal):\n 1. x \\<noteq> Pos A \\<Longrightarrow>\n    x \\<in> negative_part C \\<union> positive_part C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> Pos A \\<Longrightarrow>\n    x \\<in> negative_part C \\<union> positive_part C", "assume \"x \\<noteq> Pos A\""], ["proof (state)\nthis:\n  x \\<noteq> Pos A\n\ngoal (1 subgoal):\n 1. x \\<noteq> Pos A \\<Longrightarrow>\n    x \\<in> negative_part C \\<union> positive_part C", "from this and \\<open>x = Pos A \\<or> x = Neg A\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> Pos A\n  x = Pos A \\<or> x = Neg A", "have \"x = Neg A\""], ["proof (prove)\nusing this:\n  x \\<noteq> Pos A\n  x = Pos A \\<or> x = Neg A\n\ngoal (1 subgoal):\n 1. x = Neg A", "by auto"], ["proof (state)\nthis:\n  x = Neg A\n\ngoal (1 subgoal):\n 1. x \\<noteq> Pos A \\<Longrightarrow>\n    x \\<in> negative_part C \\<union> positive_part C", "from this and \\<open>x \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  x = Neg A\n  x \\<in> C", "have \"x \\<in> negative_part C\""], ["proof (prove)\nusing this:\n  x = Neg A\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. x \\<in> negative_part C", "unfolding negative_part_def"], ["proof (prove)\nusing this:\n  x = Neg A\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. x \\<in> {L. (\\<exists>A. L = Neg A) \\<and> L \\<in> C}", "by auto"], ["proof (state)\nthis:\n  x \\<in> negative_part C\n\ngoal (1 subgoal):\n 1. x \\<noteq> Pos A \\<Longrightarrow>\n    x \\<in> negative_part C \\<union> positive_part C", "then"], ["proof (chain)\npicking this:\n  x \\<in> negative_part C", "show \"x \\<in> (negative_part C) \\<union> (positive_part C)\""], ["proof (prove)\nusing this:\n  x \\<in> negative_part C\n\ngoal (1 subgoal):\n 1. x \\<in> negative_part C \\<union> positive_part C", "by auto"], ["proof (state)\nthis:\n  x \\<in> negative_part C \\<union> positive_part C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> negative_part C \\<union> positive_part C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C \\<subseteq> negative_part C \\<union> positive_part C\n\ngoal (1 subgoal):\n 1. negative_part C \\<union> positive_part C \\<subseteq> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. negative_part C \\<union> positive_part C \\<subseteq> C", "show \"(negative_part C) \\<union> (positive_part C) \\<subseteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negative_part C \\<union> positive_part C \\<subseteq> C", "unfolding negative_part_def\n  and positive_part_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {L. (\\<exists>A. L = Neg A) \\<and> L \\<in> C} \\<union>\n    {L. (\\<exists>A. L = Pos A) \\<and> L \\<in> C}\n    \\<subseteq> C", "by auto"], ["proof (state)\nthis:\n  negative_part C \\<union> positive_part C \\<subseteq> C\n\ngoal:\nNo subgoals!", "qed"], ["", "definition ordered_positive_resolvent :: \"'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> bool\"\nwhere \n  \"(ordered_positive_resolvent P1 P2 C) = \n    (\\<exists>L. (C = (P1 - { L } \\<union> (P2 - { complement L }))) \\<and>\n      ((negative_part P1) = {}  \\<and> (strictly_maximal_literal P1 L))\n      \\<and> (strictly_maximal_literal (negative_part P2) (complement L)))\""], ["", "definition ordered_negative_resolvent :: \"'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> bool\"\nwhere \n  \"(ordered_negative_resolvent P1 P2 C) = \n    (\\<exists>L. (C = (P1 - { L } \\<union> (P2 - { complement L }))) \\<and>\n      ((positive_part P1) = {}  \\<and> (strictly_maximal_literal P1 L))\n      \\<and> (strictly_maximal_literal (positive_part P2) (complement L)))\""], ["", "lemma positive_resolvent_is_resolvent : \"less_restrictive resolvent ordered_positive_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_restrictive resolvent ordered_positive_resolvent", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_positive_resolvent \\<Longrightarrow>\n    False", "assume \"\\<not> less_restrictive resolvent ordered_positive_resolvent\""], ["proof (state)\nthis:\n  \\<not> less_restrictive resolvent ordered_positive_resolvent\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_positive_resolvent \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> less_restrictive resolvent ordered_positive_resolvent", "obtain P1 P2 C where \"ordered_positive_resolvent P1 P2 C\" and \"\\<not>resolvent P1 P2 C\" \n    and \"\\<not>resolvent P2 P1 C\""], ["proof (prove)\nusing this:\n  \\<not> less_restrictive resolvent ordered_positive_resolvent\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>ordered_positive_resolvent P1 P2 C;\n         \\<not> resolvent P1 P2 C; \\<not> resolvent P2 P1 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding less_restrictive_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             ordered_positive_resolvent P1 P2 C \\<longrightarrow>\n             resolvent P1 P2 C \\<or> resolvent P2 P1 C)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>ordered_positive_resolvent P1 P2 C;\n         \\<not> resolvent P1 P2 C; \\<not> resolvent P2 P1 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ordered_positive_resolvent P1 P2 C\n  \\<not> resolvent P1 P2 C\n  \\<not> resolvent P2 P1 C\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_positive_resolvent \\<Longrightarrow>\n    False", "from \\<open>ordered_positive_resolvent P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  ordered_positive_resolvent P1 P2 C", "obtain L \n    where \"strictly_maximal_literal P1 L\" \n    and \"strictly_maximal_literal (negative_part P2)(complement L)\" \n    and \"C = (P1 - { L }) \\<union> (P2 - { complement L })\""], ["proof (prove)\nusing this:\n  ordered_positive_resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>strictly_maximal_literal P1 L;\n         strictly_maximal_literal (negative_part P2) (complement L);\n         C = P1 - {L} \\<union> (P2 - {complement L})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ordered_positive_resolvent_def [of P1 P2 C]"], ["proof (prove)\nusing this:\n  ordered_positive_resolvent P1 P2 C\n  ordered_positive_resolvent P1 P2 C =\n  (\\<exists>L.\n      C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n      (negative_part P1 = {} \\<and> strictly_maximal_literal P1 L) \\<and>\n      strictly_maximal_literal (negative_part P2) (complement L))\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>strictly_maximal_literal P1 L;\n         strictly_maximal_literal (negative_part P2) (complement L);\n         C = P1 - {L} \\<union> (P2 - {complement L})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal P1 L\n  strictly_maximal_literal (negative_part P2) (complement L)\n  C = P1 - {L} \\<union> (P2 - {complement L})\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_positive_resolvent \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal P1 L\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal P1 L", "have \"L \\<in> P1\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal P1 L\n\ngoal (1 subgoal):\n 1. L \\<in> P1", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> P1 \\<and>\n  (\\<forall>B.\n      B \\<in> P1 \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n\ngoal (1 subgoal):\n 1. L \\<in> P1", "by auto"], ["proof (state)\nthis:\n  L \\<in> P1\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_positive_resolvent \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal (negative_part P2) (complement L)\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal (negative_part P2) (complement L)", "have \"(complement L) \\<in> P2\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal (negative_part P2) (complement L)\n\ngoal (1 subgoal):\n 1. complement L \\<in> P2", "unfolding strictly_maximal_literal_def negative_part_def"], ["proof (prove)\nusing this:\n  complement L \\<in> {L. (\\<exists>A. L = Neg A) \\<and> L \\<in> P2} \\<and>\n  (\\<forall>B.\n      B \\<in> {L. (\\<exists>A. L = Neg A) \\<and> L \\<in> P2} \\<and>\n      complement L \\<noteq> B \\<longrightarrow>\n      literal_ordering B (complement L))\n\ngoal (1 subgoal):\n 1. complement L \\<in> P2", "by auto"], ["proof (state)\nthis:\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_positive_resolvent \\<Longrightarrow>\n    False", "obtain A where \"L = Pos A \\<or> L = Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_positive_resolvent \\<Longrightarrow>\n    False", "from this and \\<open>C = (P1 - { L }) \\<union> (P2 - { complement L })\\<close> and \\<open>L \\<in> P1\\<close> and \\<open>(complement L) \\<in> P2\\<close>"], ["proof (chain)\npicking this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2", "have \"resolvent P1 P2 C \\<or> resolvent P2 P1 C\""], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. resolvent P1 P2 C \\<or> resolvent P2 P1 C", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. (\\<exists>A.\n        Pos A \\<in> P1 \\<and>\n        Neg A \\<in> P2 \\<and>\n        C = P1 - {Pos A} \\<union> (P2 - {Neg A})) \\<or>\n    (\\<exists>A.\n        Pos A \\<in> P2 \\<and>\n        Neg A \\<in> P1 \\<and> C = P2 - {Pos A} \\<union> (P1 - {Neg A}))", "by auto"], ["proof (state)\nthis:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_positive_resolvent \\<Longrightarrow>\n    False", "from this and \\<open>\\<not>(resolvent P2 P1 C)\\<close> and \\<open>\\<not>(resolvent P1 P2 C)\\<close>"], ["proof (chain)\npicking this:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n  \\<not> resolvent P2 P1 C\n  \\<not> resolvent P1 P2 C", "show \"False\""], ["proof (prove)\nusing this:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n  \\<not> resolvent P2 P1 C\n  \\<not> resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma negative_resolvent_is_resolvent : \"less_restrictive resolvent ordered_negative_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_restrictive resolvent ordered_negative_resolvent", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_negative_resolvent \\<Longrightarrow>\n    False", "assume \"\\<not> less_restrictive resolvent ordered_negative_resolvent\""], ["proof (state)\nthis:\n  \\<not> less_restrictive resolvent ordered_negative_resolvent\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_negative_resolvent \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> less_restrictive resolvent ordered_negative_resolvent", "obtain P1 P2 C where \"(ordered_negative_resolvent P1 P2 C)\" and \"\\<not>(resolvent P1 P2 C)\" \n    and \"\\<not>(resolvent P2 P1 C)\""], ["proof (prove)\nusing this:\n  \\<not> less_restrictive resolvent ordered_negative_resolvent\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>ordered_negative_resolvent P1 P2 C;\n         \\<not> resolvent P1 P2 C; \\<not> resolvent P2 P1 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding less_restrictive_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             ordered_negative_resolvent P1 P2 C \\<longrightarrow>\n             resolvent P1 P2 C \\<or> resolvent P2 P1 C)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>ordered_negative_resolvent P1 P2 C;\n         \\<not> resolvent P1 P2 C; \\<not> resolvent P2 P1 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ordered_negative_resolvent P1 P2 C\n  \\<not> resolvent P1 P2 C\n  \\<not> resolvent P2 P1 C\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_negative_resolvent \\<Longrightarrow>\n    False", "from \\<open>ordered_negative_resolvent P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  ordered_negative_resolvent P1 P2 C", "obtain L where \"strictly_maximal_literal P1 L\" \n    and \"strictly_maximal_literal (positive_part P2)(complement L)\" \n    and \"C = (P1 - { L }) \\<union> (P2 - { complement L })\""], ["proof (prove)\nusing this:\n  ordered_negative_resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>strictly_maximal_literal P1 L;\n         strictly_maximal_literal (positive_part P2) (complement L);\n         C = P1 - {L} \\<union> (P2 - {complement L})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ordered_negative_resolvent_def [of P1 P2 C]"], ["proof (prove)\nusing this:\n  ordered_negative_resolvent P1 P2 C\n  ordered_negative_resolvent P1 P2 C =\n  (\\<exists>L.\n      C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n      (positive_part P1 = {} \\<and> strictly_maximal_literal P1 L) \\<and>\n      strictly_maximal_literal (positive_part P2) (complement L))\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>strictly_maximal_literal P1 L;\n         strictly_maximal_literal (positive_part P2) (complement L);\n         C = P1 - {L} \\<union> (P2 - {complement L})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal P1 L\n  strictly_maximal_literal (positive_part P2) (complement L)\n  C = P1 - {L} \\<union> (P2 - {complement L})\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_negative_resolvent \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal P1 L\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal P1 L", "have \"L \\<in> P1\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal P1 L\n\ngoal (1 subgoal):\n 1. L \\<in> P1", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> P1 \\<and>\n  (\\<forall>B.\n      B \\<in> P1 \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n\ngoal (1 subgoal):\n 1. L \\<in> P1", "by auto"], ["proof (state)\nthis:\n  L \\<in> P1\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_negative_resolvent \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal (positive_part P2) (complement L)\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal (positive_part P2) (complement L)", "have \"(complement L) \\<in> P2\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal (positive_part P2) (complement L)\n\ngoal (1 subgoal):\n 1. complement L \\<in> P2", "unfolding strictly_maximal_literal_def positive_part_def"], ["proof (prove)\nusing this:\n  complement L \\<in> {L. (\\<exists>A. L = Pos A) \\<and> L \\<in> P2} \\<and>\n  (\\<forall>B.\n      B \\<in> {L. (\\<exists>A. L = Pos A) \\<and> L \\<in> P2} \\<and>\n      complement L \\<noteq> B \\<longrightarrow>\n      literal_ordering B (complement L))\n\ngoal (1 subgoal):\n 1. complement L \\<in> P2", "by auto"], ["proof (state)\nthis:\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_negative_resolvent \\<Longrightarrow>\n    False", "obtain A where \"L = Pos A \\<or> L = Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_negative_resolvent \\<Longrightarrow>\n    False", "from this and \\<open>C = (P1 - { L }) \\<union> (P2 - { complement L })\\<close> and \\<open>L \\<in> P1\\<close> and \\<open>(complement L) \\<in> P2\\<close>"], ["proof (chain)\npicking this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2", "have \"resolvent P1 P2 C \\<or> resolvent P2 P1 C\""], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. resolvent P1 P2 C \\<or> resolvent P2 P1 C", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  L \\<in> P1\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. (\\<exists>A.\n        Pos A \\<in> P1 \\<and>\n        Neg A \\<in> P2 \\<and>\n        C = P1 - {Pos A} \\<union> (P2 - {Neg A})) \\<or>\n    (\\<exists>A.\n        Pos A \\<in> P2 \\<and>\n        Neg A \\<in> P1 \\<and> C = P2 - {Pos A} \\<union> (P1 - {Neg A}))", "by auto"], ["proof (state)\nthis:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n\ngoal (1 subgoal):\n 1. \\<not> less_restrictive resolvent\n            ordered_negative_resolvent \\<Longrightarrow>\n    False", "from this and \\<open>\\<not>resolvent P2 P1 C\\<close> and \\<open>\\<not>resolvent P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n  \\<not> resolvent P2 P1 C\n  \\<not> resolvent P1 P2 C", "show \"False\""], ["proof (prove)\nusing this:\n  resolvent P1 P2 C \\<or> resolvent P2 P1 C\n  \\<not> resolvent P2 P1 C\n  \\<not> resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Redundancy Elimination Rules\\<close>"], ["", "text \\<open>We define the usual redundancy elimination rules.\\<close>"], ["", "definition tautology :: \"'a Clause \\<Rightarrow> bool\"\nwhere\n  \"(tautology C) \\<equiv> (\\<exists> A. (Pos A \\<in> C \\<and> Neg A \\<in> C))\""], ["", "definition subsumes :: \"'a Clause \\<Rightarrow> 'a Clause \\<Rightarrow> bool\"\nwhere\n  \"(subsumes C D)  \\<equiv> (C \\<subseteq> D)\""], ["", "definition redundant :: \"'a Clause \\<Rightarrow> 'a Formula \\<Rightarrow> bool\"\nwhere \n  \"redundant C S = ((tautology C) \\<or> (\\<exists>D. (D \\<in> S \\<and> subsumes D C)))\""], ["", "definition strictly_redundant :: \"'a Clause \\<Rightarrow> 'a Formula \\<Rightarrow> bool\"\nwhere \n  \"strictly_redundant C S = ((tautology C) \\<or> (\\<exists>D. (D \\<in> S \\<and> (D \\<subset> C))))\""], ["", "definition simplify :: \"'at Formula \\<Rightarrow> 'at Formula\"\nwhere \n  \"simplify S = { C. C \\<in> S \\<and> \\<not>strictly_redundant C S }\""], ["", "text \\<open>We first establish some basic syntactic properties.\\<close>"], ["", "lemma tautology_monotonous : \"(tautology C) \\<Longrightarrow> (C \\<subseteq> D) \\<Longrightarrow> (tautology D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tautology C; C \\<subseteq> D\\<rbrakk>\n    \\<Longrightarrow> tautology D", "unfolding tautology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>A. Pos A \\<in> C \\<and> Neg A \\<in> C;\n     C \\<subseteq> D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. Pos A \\<in> D \\<and> Neg A \\<in> D", "by auto"], ["", "lemma simplify_involutive:\n  shows \"simplify (simplify S) = (simplify S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simplify (simplify S) = simplify S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simplify (simplify S) = simplify S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. simplify (simplify S) = simplify S", "unfolding simplify_def strictly_redundant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {C \\<in> {C \\<in> S.\n              \\<not> (tautology C \\<or>\n                      (\\<exists>D. D \\<in> S \\<and> D \\<subset> C))}.\n     \\<not> (tautology C \\<or>\n             (\\<exists>D.\n                 D \\<in> {C \\<in> S.\n                          \\<not> (tautology C \\<or>\n                                  (\\<exists>D.\nD \\<in> S \\<and> D \\<subset> C))} \\<and>\n                 D \\<subset> C))} =\n    {C \\<in> S.\n     \\<not> (tautology C \\<or>\n             (\\<exists>D. D \\<in> S \\<and> D \\<subset> C))}", "by auto"], ["proof (state)\nthis:\n  simplify (simplify S) = simplify S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simplify_finite:\n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (simplify S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill finite (simplify S)", "using assms all_fulfill_def simplify_def"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n  simplify ?S = {C \\<in> ?S. \\<not> strictly_redundant C ?S}\n\ngoal (1 subgoal):\n 1. all_fulfill finite (simplify S)", "by auto"], ["", "lemma atoms_formula_simplify:\n  shows \"atoms_formula (simplify S) \\<subseteq> atoms_formula S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms_formula (simplify S) \\<subseteq> atoms_formula S", "unfolding simplify_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms_formula {C \\<in> S. \\<not> strictly_redundant C S}\n    \\<subseteq> atoms_formula S", "using atoms_formula_subset"], ["proof (prove)\nusing this:\n  ?S1.0 \\<subseteq> ?S2.0 \\<Longrightarrow>\n  atoms_formula ?S1.0 \\<subseteq> atoms_formula ?S2.0\n\ngoal (1 subgoal):\n 1. atoms_formula {C \\<in> S. \\<not> strictly_redundant C S}\n    \\<subseteq> atoms_formula S", "by auto"], ["", "lemma subsumption_preserves_redundancy :\n  assumes \"redundant C S\"\n  assumes \"subsumes C D\" \n  shows \"redundant D S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant D S", "using assms tautology_monotonous"], ["proof (prove)\nusing this:\n  redundant C S\n  subsumes C D\n  \\<lbrakk>tautology ?C; ?C \\<subseteq> ?D\\<rbrakk>\n  \\<Longrightarrow> tautology ?D\n\ngoal (1 subgoal):\n 1. redundant D S", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subseteq> C)\n  C \\<subseteq> D\n  \\<lbrakk>tautology ?C; ?C \\<subseteq> ?D\\<rbrakk>\n  \\<Longrightarrow> tautology ?D\n\ngoal (1 subgoal):\n 1. tautology D \\<or> (\\<exists>Da. Da \\<in> S \\<and> Da \\<subseteq> D)", "by blast"], ["", "lemma subsumption_and_max_literal : \n  assumes \"subsumes C1 C2\"\n  assumes \"strictly_maximal_literal C1 L1\"\n  assumes \"strictly_maximal_literal C2 L2\"\n  assumes \"A1 = atom L1\"\n  assumes \"A2 = atom L2\"\n  shows \"(A1 = A2) \\<or> (A1,A2) \\<in> atom_ordering\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "from \\<open>A1 = atom L1\\<close>"], ["proof (chain)\npicking this:\n  A1 = atom L1", "have \"L1 = (Pos A1) \\<or> L1 = (Neg A1)\""], ["proof (prove)\nusing this:\n  A1 = atom L1\n\ngoal (1 subgoal):\n 1. L1 = Pos A1 \\<or> L1 = Neg A1", "by (rule atom_property)"], ["proof (state)\nthis:\n  L1 = Pos A1 \\<or> L1 = Neg A1\n\ngoal (1 subgoal):\n 1. A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "from \\<open>A2 = atom L2\\<close>"], ["proof (chain)\npicking this:\n  A2 = atom L2", "have \"L2 = (Pos A2) \\<or> L2 = (Neg A2)\""], ["proof (prove)\nusing this:\n  A2 = atom L2\n\ngoal (1 subgoal):\n 1. L2 = Pos A2 \\<or> L2 = Neg A2", "by (rule atom_property)"], ["proof (state)\nthis:\n  L2 = Pos A2 \\<or> L2 = Neg A2\n\ngoal (1 subgoal):\n 1. A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "from \\<open>subsumes C1 C2\\<close> and \\<open>strictly_maximal_literal C1 L1\\<close>"], ["proof (chain)\npicking this:\n  subsumes C1 C2\n  strictly_maximal_literal C1 L1", "have \"L1 \\<in> C2\""], ["proof (prove)\nusing this:\n  subsumes C1 C2\n  strictly_maximal_literal C1 L1\n\ngoal (1 subgoal):\n 1. L1 \\<in> C2", "unfolding strictly_maximal_literal_def subsumes_def"], ["proof (prove)\nusing this:\n  C1 \\<subseteq> C2\n  L1 \\<in> C1 \\<and>\n  (\\<forall>B.\n      B \\<in> C1 \\<and> L1 \\<noteq> B \\<longrightarrow>\n      literal_ordering B L1)\n\ngoal (1 subgoal):\n 1. L1 \\<in> C2", "by auto"], ["proof (state)\nthis:\n  L1 \\<in> C2\n\ngoal (1 subgoal):\n 1. A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "from \\<open>strictly_maximal_literal C2 L2\\<close> and \\<open>L1 \\<in> C2\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal C2 L2\n  L1 \\<in> C2", "have \"L1 = L2 \\<or> literal_ordering L1 L2\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal C2 L2\n  L1 \\<in> C2\n\ngoal (1 subgoal):\n 1. L1 = L2 \\<or> literal_ordering L1 L2", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  L2 \\<in> C2 \\<and>\n  (\\<forall>B.\n      B \\<in> C2 \\<and> L2 \\<noteq> B \\<longrightarrow>\n      literal_ordering B L2)\n  L1 \\<in> C2\n\ngoal (1 subgoal):\n 1. L1 = L2 \\<or> literal_ordering L1 L2", "by auto"], ["proof (state)\nthis:\n  L1 = L2 \\<or> literal_ordering L1 L2\n\ngoal (1 subgoal):\n 1. A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "thus ?thesis"], ["proof (prove)\nusing this:\n  L1 = L2 \\<or> literal_ordering L1 L2\n\ngoal (1 subgoal):\n 1. A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L1 = L2 \\<Longrightarrow> A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering\n 2. literal_ordering L1 L2 \\<Longrightarrow>\n    A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "assume \"L1 = L2\""], ["proof (state)\nthis:\n  L1 = L2\n\ngoal (2 subgoals):\n 1. L1 = L2 \\<Longrightarrow> A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering\n 2. literal_ordering L1 L2 \\<Longrightarrow>\n    A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "from \\<open>L1 = L2\\<close> and \\<open>A1 = atom L1\\<close> and \\<open>A2 = atom L2\\<close>"], ["proof (chain)\npicking this:\n  L1 = L2\n  A1 = atom L1\n  A2 = atom L2", "show ?thesis"], ["proof (prove)\nusing this:\n  L1 = L2\n  A1 = atom L1\n  A2 = atom L2\n\ngoal (1 subgoal):\n 1. A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. literal_ordering L1 L2 \\<Longrightarrow>\n    A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. literal_ordering L1 L2 \\<Longrightarrow>\n    A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "assume \"literal_ordering L1 L2\""], ["proof (state)\nthis:\n  literal_ordering L1 L2\n\ngoal (1 subgoal):\n 1. literal_ordering L1 L2 \\<Longrightarrow>\n    A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "from \\<open>literal_ordering L1 L2\\<close> and \\<open>L1 = (Pos A1) \\<or> L1 = (Neg A1)\\<close>   \n      and \\<open>L2 = (Pos A2) \\<or> L2 = (Neg A2)\\<close>"], ["proof (chain)\npicking this:\n  literal_ordering L1 L2\n  L1 = Pos A1 \\<or> L1 = Neg A1\n  L2 = Pos A2 \\<or> L2 = Neg A2", "show ?thesis"], ["proof (prove)\nusing this:\n  literal_ordering L1 L2\n  L1 = Pos A1 \\<or> L1 = Neg A1\n  L2 = Pos A2 \\<or> L2 = Neg A2\n\ngoal (1 subgoal):\n 1. A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A1 = A2 \\<or> (A1, A2) \\<in> atom_ordering\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma superset_preserves_redundancy: \n  assumes \"redundant C S\"\n  assumes \"S \\<subseteq> S'\"\n  shows \"redundant C S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C S'", "using assms"], ["proof (prove)\nusing this:\n  redundant C S\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. redundant C S'", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> S' \\<and> subsumes D C)", "by blast"], ["", "lemma superset_preserves_strict_redundancy: \n  assumes \"strictly_redundant C S\"\n  assumes \"S \\<subseteq> SS\"\n  shows \"strictly_redundant C SS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_redundant C SS", "using assms"], ["proof (prove)\nusing this:\n  strictly_redundant C S\n  S \\<subseteq> SS\n\ngoal (1 subgoal):\n 1. strictly_redundant C SS", "unfolding strictly_redundant_def"], ["proof (prove)\nusing this:\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subset> C)\n  S \\<subseteq> SS\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> SS \\<and> D \\<subset> C)", "by blast"], ["", "text \\<open>The following lemmas relate the above notions with that of semantic entailment and thus \nestablish the soundness of redundancy elimination rules.\\<close>"], ["", "lemma tautologies_are_valid : \n  assumes \"tautology C\"\n  shows \"validate_clause I C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> C", "by (meson assms tautology_def validate_clause.simps validate_literal.simps(1) \n    validate_literal.simps(2))"], ["", "lemma subsumption_and_semantics : \n  assumes \"subsumes C D\"\n  assumes \"validate_clause I C\"\n  shows \"validate_clause I D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> D", "using assms"], ["proof (prove)\nusing this:\n  subsumes C D\n  I \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> D", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  C \\<subseteq> D\n  I \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> D", "by auto"], ["", "lemma redundancy_and_semantics : \n  assumes \"redundant C S\"\n  assumes \"validate_formula I S\"\n  shows \"validate_clause I C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> C", "by \n(meson assms redundant_def subsumption_and_semantics tautologies_are_valid validate_formula.elims)"], ["", "lemma redundancy_implies_entailment:\n  assumes \"redundant C S\"\n  shows \"entails S C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails S C", "using assms entails_def redundancy_and_semantics"], ["proof (prove)\nusing this:\n  redundant C S\n  entails ?S ?C \\<equiv>\n  \\<forall>I. I \\<Turnstile> ?S \\<longrightarrow> I \\<Turnstile> ?C\n  \\<lbrakk>redundant ?C ?S; ?I \\<Turnstile> ?S\\<rbrakk>\n  \\<Longrightarrow> ?I \\<Turnstile> ?C\n\ngoal (1 subgoal):\n 1. entails S C", "by auto"], ["", "lemma simplify_and_membership :\n  assumes \"all_fulfill finite S\"\n  assumes \"T = simplify S\"\n  assumes \"C \\<in> S\"\n  shows \"redundant C T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant C T", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant C T", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant C T", "have \"\\<forall>C. card C \\<le> n \\<longrightarrow> C \\<in> S \\<longrightarrow> redundant C T\" (is \"?P n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       card C \\<le> n \\<longrightarrow>\n       C \\<in> S \\<longrightarrow> redundant C T", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>C.\n       card C \\<le> 0 \\<longrightarrow>\n       C \\<in> S \\<longrightarrow> redundant C T\n 2. \\<And>n.\n       \\<forall>C.\n          card C \\<le> n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T \\<Longrightarrow>\n       \\<forall>C.\n          card C \\<le> Suc n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T", "show \"?P 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       card C \\<le> 0 \\<longrightarrow>\n       C \\<in> S \\<longrightarrow> redundant C T", "proof ((rule allI),(rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card C \\<le> 0; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> redundant C T", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card C \\<le> 0; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> redundant C T", "assume \"card C \\<le> 0\" and \"C \\<in> S\""], ["proof (state)\nthis:\n  card C \\<le> 0\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card C \\<le> 0; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> redundant C T", "from \\<open>card C \\<le> 0\\<close> and \\<open>C \\<in> S\\<close> and \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  card C \\<le> 0\n  C \\<in> S\n  all_fulfill finite S", "have \"C = {}\""], ["proof (prove)\nusing this:\n  card C \\<le> 0\n  C \\<in> S\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. C = {}", "using card_0_eq"], ["proof (prove)\nusing this:\n  card C \\<le> 0\n  C \\<in> S\n  all_fulfill finite S\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. C = {}", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  card C \\<le> 0\n  C \\<in> S\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. C = {}", "by auto"], ["proof (state)\nthis:\n  C = {}\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card C \\<le> 0; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> redundant C T", "then"], ["proof (chain)\npicking this:\n  C = {}", "have \"\\<not> strictly_redundant C S\""], ["proof (prove)\nusing this:\n  C = {}\n\ngoal (1 subgoal):\n 1. \\<not> strictly_redundant C S", "unfolding strictly_redundant_def tautology_def"], ["proof (prove)\nusing this:\n  C = {}\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>A. Pos A \\<in> C \\<and> Neg A \\<in> C) \\<or>\n            (\\<exists>D. D \\<in> S \\<and> D \\<subset> C))", "by auto"], ["proof (state)\nthis:\n  \\<not> strictly_redundant C S\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card C \\<le> 0; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> redundant C T", "from this and \\<open>C \\<in> S\\<close> and \\<open>T = simplify S\\<close>"], ["proof (chain)\npicking this:\n  \\<not> strictly_redundant C S\n  C \\<in> S\n  T = simplify S", "have \"C \\<in> T\""], ["proof (prove)\nusing this:\n  \\<not> strictly_redundant C S\n  C \\<in> S\n  T = simplify S\n\ngoal (1 subgoal):\n 1. C \\<in> T", "using simplify_def"], ["proof (prove)\nusing this:\n  \\<not> strictly_redundant C S\n  C \\<in> S\n  T = simplify S\n  simplify ?S = {C \\<in> ?S. \\<not> strictly_redundant C ?S}\n\ngoal (1 subgoal):\n 1. C \\<in> T", "by auto"], ["proof (state)\nthis:\n  C \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card C \\<le> 0; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> redundant C T", "from this"], ["proof (chain)\npicking this:\n  C \\<in> T", "show \"redundant C T\""], ["proof (prove)\nusing this:\n  C \\<in> T\n\ngoal (1 subgoal):\n 1. redundant C T", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  C \\<in> T\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> T \\<and> D \\<subseteq> C)", "by auto"], ["proof (state)\nthis:\n  redundant C T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C.\n     card C \\<le> 0 \\<longrightarrow>\n     C \\<in> S \\<longrightarrow> redundant C T\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>C.\n          card C \\<le> n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T \\<Longrightarrow>\n       \\<forall>C.\n          card C \\<le> Suc n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>C.\n          card C \\<le> n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T \\<Longrightarrow>\n       \\<forall>C.\n          card C \\<le> Suc n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>C.\n          card C \\<le> n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T \\<Longrightarrow>\n       \\<forall>C.\n          card C \\<le> Suc n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T", "assume \"?P n\""], ["proof (state)\nthis:\n  \\<forall>C.\n     card C \\<le> n \\<longrightarrow>\n     C \\<in> S \\<longrightarrow> redundant C T\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>C.\n          card C \\<le> n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T \\<Longrightarrow>\n       \\<forall>C.\n          card C \\<le> Suc n \\<longrightarrow>\n          C \\<in> S \\<longrightarrow> redundant C T", "show \"?P (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       card C \\<le> Suc n \\<longrightarrow>\n       C \\<in> S \\<longrightarrow> redundant C T", "proof ((rule allI),(rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card C \\<le> Suc n; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> redundant C T", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card C \\<le> Suc n; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> redundant C T", "assume \"card C \\<le> (Suc n)\" and \"C \\<in> S\""], ["proof (state)\nthis:\n  card C \\<le> Suc n\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card C \\<le> Suc n; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> redundant C T", "show \"redundant C T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C T", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> redundant C T \\<Longrightarrow> False", "assume \"\\<not>redundant C T\""], ["proof (state)\nthis:\n  \\<not> redundant C T\n\ngoal (1 subgoal):\n 1. \\<not> redundant C T \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> redundant C T", "have \"C \\<notin> T\""], ["proof (prove)\nusing this:\n  \\<not> redundant C T\n\ngoal (1 subgoal):\n 1. C \\<notin> T", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  \\<not> (tautology C \\<or> (\\<exists>D. D \\<in> T \\<and> D \\<subseteq> C))\n\ngoal (1 subgoal):\n 1. C \\<notin> T", "by auto"], ["proof (state)\nthis:\n  C \\<notin> T\n\ngoal (1 subgoal):\n 1. \\<not> redundant C T \\<Longrightarrow> False", "from this and \\<open>T = simplify S\\<close> and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  C \\<notin> T\n  T = simplify S\n  C \\<in> S", "have \"strictly_redundant C S\""], ["proof (prove)\nusing this:\n  C \\<notin> T\n  T = simplify S\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. strictly_redundant C S", "unfolding simplify_def strictly_redundant_def"], ["proof (prove)\nusing this:\n  C \\<notin> T\n  T =\n  {C \\<in> S.\n   \\<not> (tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subset> C))}\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subset> C)", "by auto"], ["proof (state)\nthis:\n  strictly_redundant C S\n\ngoal (1 subgoal):\n 1. \\<not> redundant C T \\<Longrightarrow> False", "from this and \\<open>\\<not>redundant C T\\<close>"], ["proof (chain)\npicking this:\n  strictly_redundant C S\n  \\<not> redundant C T", "obtain D where \"D \\<in> S\" and \"D \\<subset> C\""], ["proof (prove)\nusing this:\n  strictly_redundant C S\n  \\<not> redundant C T\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> S; D \\<subset> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def strictly_redundant_def"], ["proof (prove)\nusing this:\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subset> C)\n  \\<not> (tautology C \\<or> (\\<exists>D. D \\<in> T \\<and> subsumes D C))\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> S; D \\<subset> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D \\<in> S\n  D \\<subset> C\n\ngoal (1 subgoal):\n 1. \\<not> redundant C T \\<Longrightarrow> False", "from \\<open>D \\<subset> C\\<close> and \\<open>C \\<in> S\\<close> and \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  D \\<subset> C\n  C \\<in> S\n  all_fulfill finite S", "have \"card D < card C\""], ["proof (prove)\nusing this:\n  D \\<subset> C\n  C \\<in> S\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. card D < card C", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  D \\<subset> C\n  C \\<in> S\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. card D < card C", "using psubset_card_mono"], ["proof (prove)\nusing this:\n  D \\<subset> C\n  C \\<in> S\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n  \\<lbrakk>finite ?B; ?A \\<subset> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A < card ?B\n\ngoal (1 subgoal):\n 1. card D < card C", "by auto"], ["proof (state)\nthis:\n  card D < card C\n\ngoal (1 subgoal):\n 1. \\<not> redundant C T \\<Longrightarrow> False", "from this and \\<open>card C \\<le> (Suc n)\\<close>"], ["proof (chain)\npicking this:\n  card D < card C\n  card C \\<le> Suc n", "have \"card D \\<le> n\""], ["proof (prove)\nusing this:\n  card D < card C\n  card C \\<le> Suc n\n\ngoal (1 subgoal):\n 1. card D \\<le> n", "by auto"], ["proof (state)\nthis:\n  card D \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> redundant C T \\<Longrightarrow> False", "from this and  \\<open>?P n\\<close> and \\<open>D \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  card D \\<le> n\n  \\<forall>C.\n     card C \\<le> n \\<longrightarrow>\n     C \\<in> S \\<longrightarrow> redundant C T\n  D \\<in> S", "have \"redundant D T\""], ["proof (prove)\nusing this:\n  card D \\<le> n\n  \\<forall>C.\n     card C \\<le> n \\<longrightarrow>\n     C \\<in> S \\<longrightarrow> redundant C T\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. redundant D T", "by auto"], ["proof (state)\nthis:\n  redundant D T\n\ngoal (1 subgoal):\n 1. \\<not> redundant C T \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"tautology D\""], ["proof (state)\nthis:\n  tautology D\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this and  \\<open>D \\<subset> C\\<close>"], ["proof (chain)\npicking this:\n  tautology D\n  D \\<subset> C", "have \"tautology C\""], ["proof (prove)\nusing this:\n  tautology D\n  D \\<subset> C\n\ngoal (1 subgoal):\n 1. tautology C", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  \\<exists>A. Pos A \\<in> D \\<and> Neg A \\<in> D\n  D \\<subset> C\n\ngoal (1 subgoal):\n 1. \\<exists>A. Pos A \\<in> C \\<and> Neg A \\<in> C", "by auto"], ["proof (state)\nthis:\n  tautology C\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tautology C", "have \"redundant C T\""], ["proof (prove)\nusing this:\n  tautology C\n\ngoal (1 subgoal):\n 1. redundant C T", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  tautology C\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> T \\<and> subsumes D C)", "by auto"], ["proof (state)\nthis:\n  redundant C T\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this and \\<open>\\<not>redundant C T\\<close>"], ["proof (chain)\npicking this:\n  redundant C T\n  \\<not> redundant C T", "show \"False\""], ["proof (prove)\nusing this:\n  redundant C T\n  \\<not> redundant C T\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> tautology D \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tautology D \\<Longrightarrow> False", "assume \"\\<not>tautology D\""], ["proof (state)\nthis:\n  \\<not> tautology D\n\ngoal (1 subgoal):\n 1. \\<not> tautology D \\<Longrightarrow> False", "from this and \\<open>redundant D T\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology D\n  redundant D T", "obtain E where \"E \\<in> T\" and \"E \\<subseteq> D\""], ["proof (prove)\nusing this:\n  \\<not> tautology D\n  redundant D T\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<in> T; E \\<subseteq> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  \\<not> tautology D\n  tautology D \\<or> (\\<exists>Da. Da \\<in> T \\<and> Da \\<subseteq> D)\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<in> T; E \\<subseteq> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E \\<in> T\n  E \\<subseteq> D\n\ngoal (1 subgoal):\n 1. \\<not> tautology D \\<Longrightarrow> False", "from this and  \\<open>D \\<subset> C\\<close>"], ["proof (chain)\npicking this:\n  E \\<in> T\n  E \\<subseteq> D\n  D \\<subset> C", "have \"E \\<subseteq> C\""], ["proof (prove)\nusing this:\n  E \\<in> T\n  E \\<subseteq> D\n  D \\<subset> C\n\ngoal (1 subgoal):\n 1. E \\<subseteq> C", "by auto"], ["proof (state)\nthis:\n  E \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<not> tautology D \\<Longrightarrow> False", "from this and \\<open>E \\<in> T\\<close> and  \\<open>\\<not>redundant C T\\<close>"], ["proof (chain)\npicking this:\n  E \\<subseteq> C\n  E \\<in> T\n  \\<not> redundant C T", "show False"], ["proof (prove)\nusing this:\n  E \\<subseteq> C\n  E \\<in> T\n  \\<not> redundant C T\n\ngoal (1 subgoal):\n 1. False", "unfolding redundant_def and subsumes_def"], ["proof (prove)\nusing this:\n  E \\<subseteq> C\n  E \\<in> T\n  \\<not> (tautology C \\<or> (\\<exists>D. D \\<in> T \\<and> D \\<subseteq> C))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  redundant C T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C.\n     card C \\<le> Suc n \\<longrightarrow>\n     C \\<in> S \\<longrightarrow> redundant C T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C.\n     card C \\<le> n \\<longrightarrow>\n     C \\<in> S \\<longrightarrow> redundant C T\n\ngoal (1 subgoal):\n 1. redundant C T", "}"], ["proof (state)\nthis:\n  \\<forall>C.\n     card C \\<le> ?n2 \\<longrightarrow>\n     C \\<in> S \\<longrightarrow> redundant C T\n\ngoal (1 subgoal):\n 1. redundant C T", "from this and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>C.\n     card C \\<le> ?n2 \\<longrightarrow>\n     C \\<in> S \\<longrightarrow> redundant C T\n  C \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>C.\n     card C \\<le> ?n2 \\<longrightarrow>\n     C \\<in> S \\<longrightarrow> redundant C T\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. redundant C T", "by auto"], ["proof (state)\nthis:\n  redundant C T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simplify_preserves_redundancy: \n  assumes \"all_fulfill finite S\"\n  assumes \"redundant C S\"\n  shows \"redundant C (simplify S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C (simplify S)", "by (meson assms redundant_def simplify_and_membership subsumption_preserves_redundancy)"], ["", "lemma simplify_preserves_strict_redundancy: \n  assumes \"all_fulfill finite S\"\n  assumes \"strictly_redundant C S\"\n  shows \"strictly_redundant C (simplify S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_redundant C (simplify S)", "proof ((cases \"tautology C\"),(auto simp add: strictly_redundant_def)[1])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> strictly_redundant C (simplify S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> strictly_redundant C (simplify S)", "assume \"\\<not>tautology C\""], ["proof (state)\nthis:\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> strictly_redundant C (simplify S)", "from this and assms(2)"], ["proof (chain)\npicking this:\n  \\<not> tautology C\n  strictly_redundant C S", "obtain D where \"D \\<subset> C\" and \"D \\<in> S\""], ["proof (prove)\nusing this:\n  \\<not> tautology C\n  strictly_redundant C S\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<subset> C; D \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding strictly_redundant_def"], ["proof (prove)\nusing this:\n  \\<not> tautology C\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subset> C)\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<subset> C; D \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D \\<subset> C\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> strictly_redundant C (simplify S)", "from \\<open>D \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  D \\<in> S", "have \"redundant D S\""], ["proof (prove)\nusing this:\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. redundant D S", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. tautology D \\<or> (\\<exists>Da. Da \\<in> S \\<and> Da \\<subseteq> D)", "by auto"], ["proof (state)\nthis:\n  redundant D S\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> strictly_redundant C (simplify S)", "from assms(1) this"], ["proof (chain)\npicking this:\n  all_fulfill finite S\n  redundant D S", "have \"redundant D (simplify S)\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  redundant D S\n\ngoal (1 subgoal):\n 1. redundant D (simplify S)", "using simplify_preserves_redundancy"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  redundant D S\n  \\<lbrakk>all_fulfill finite ?S; redundant ?C ?S\\<rbrakk>\n  \\<Longrightarrow> redundant ?C (simplify ?S)\n\ngoal (1 subgoal):\n 1. redundant D (simplify S)", "by auto"], ["proof (state)\nthis:\n  redundant D (simplify S)\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> strictly_redundant C (simplify S)", "from \\<open>\\<not>tautology C\\<close> and \\<open>D \\<subset> C\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology C\n  D \\<subset> C", "have \"\\<not>tautology D\""], ["proof (prove)\nusing this:\n  \\<not> tautology C\n  D \\<subset> C\n\ngoal (1 subgoal):\n 1. \\<not> tautology D", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  \\<nexists>A. Pos A \\<in> C \\<and> Neg A \\<in> C\n  D \\<subset> C\n\ngoal (1 subgoal):\n 1. \\<nexists>A. Pos A \\<in> D \\<and> Neg A \\<in> D", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology D\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> strictly_redundant C (simplify S)", "from this and \\<open>redundant D (simplify S)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology D\n  redundant D (simplify S)", "obtain E where \"E \\<in> simplify S\" \n    and \"subsumes E D\""], ["proof (prove)\nusing this:\n  \\<not> tautology D\n  redundant D (simplify S)\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<in> simplify S; subsumes E D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  \\<not> tautology D\n  tautology D \\<or> (\\<exists>Da. Da \\<in> simplify S \\<and> subsumes Da D)\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<in> simplify S; subsumes E D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E \\<in> simplify S\n  subsumes E D\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> strictly_redundant C (simplify S)", "from \\<open>subsumes E D\\<close> and \\<open>D \\<subset> C\\<close>"], ["proof (chain)\npicking this:\n  subsumes E D\n  D \\<subset> C", "have \"E \\<subset> C\""], ["proof (prove)\nusing this:\n  subsumes E D\n  D \\<subset> C\n\ngoal (1 subgoal):\n 1. E \\<subset> C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  E \\<subseteq> D\n  D \\<subset> C\n\ngoal (1 subgoal):\n 1. E \\<subset> C", "by auto"], ["proof (state)\nthis:\n  E \\<subset> C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> strictly_redundant C (simplify S)", "from this and \\<open>E \\<in> simplify S\\<close>"], ["proof (chain)\npicking this:\n  E \\<subset> C\n  E \\<in> simplify S", "show \"strictly_redundant C (simplify S)\""], ["proof (prove)\nusing this:\n  E \\<subset> C\n  E \\<in> simplify S\n\ngoal (1 subgoal):\n 1. strictly_redundant C (simplify S)", "unfolding strictly_redundant_def"], ["proof (prove)\nusing this:\n  E \\<subset> C\n  E \\<in> simplify S\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> simplify S \\<and> D \\<subset> C)", "by auto"], ["proof (state)\nthis:\n  strictly_redundant C (simplify S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simplify_preserves_semantic : \n  assumes \"T = simplify S\"\n  assumes \"all_fulfill finite S\"\n  shows \"validate_formula I S \\<longleftrightarrow> validate_formula I T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> S = I \\<Turnstile> T", "by (metis (mono_tags, lifting) assms mem_Collect_eq redundancy_and_semantics simplify_and_membership \n    simplify_def validate_formula.simps)"], ["", "lemma simplify_preserves_equivalence : \n  assumes \"T = simplify S\"\n  assumes \"all_fulfill finite S\"\n  shows \"equivalent S T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent S T", "using assms equivalent_def simplify_preserves_semantic validity_implies_entailment"], ["proof (prove)\nusing this:\n  T = simplify S\n  all_fulfill finite S\n  equivalent ?S1.0 ?S2.0 =\n  (entails_formula ?S1.0 ?S2.0 \\<and> entails_formula ?S2.0 ?S1.0)\n  \\<lbrakk>?T = simplify ?S; all_fulfill finite ?S\\<rbrakk>\n  \\<Longrightarrow> ?I \\<Turnstile> ?S = ?I \\<Turnstile> ?T\n  \\<forall>I.\n     I \\<Turnstile> ?S1.0 \\<longrightarrow>\n     I \\<Turnstile> ?S2.0 \\<Longrightarrow>\n  entails_formula ?S1.0 ?S2.0\n\ngoal (1 subgoal):\n 1. equivalent S T", "by auto"], ["", "text \\<open>After simplification, the formula contains no strictly redundant clause:\\<close>"], ["", "definition non_redundant :: \"'at Formula \\<Rightarrow> bool\"\n  where \"non_redundant S = (\\<forall>C. (C \\<in> S \\<longrightarrow> \\<not>strictly_redundant C S))\""], ["", "lemma simplify_non_redundant:\n  shows \"non_redundant (simplify S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_redundant (simplify S)", "by (simp add: non_redundant_def simplify_def strictly_redundant_def)"], ["", "lemma deducible_clause_preserve_redundancy:\n  assumes \"redundant C S\"\n  shows \"redundant C (add_all_deducible_clauses R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C (add_all_deducible_clauses R S)", "using assms superset_preserves_redundancy"], ["proof (prove)\nusing this:\n  redundant C S\n  \\<lbrakk>redundant ?C ?S; ?S \\<subseteq> ?S'\\<rbrakk>\n  \\<Longrightarrow> redundant ?C ?S'\n\ngoal (1 subgoal):\n 1. redundant C (add_all_deducible_clauses R S)", "by fastforce"], ["", "section \\<open>Renaming\\<close>"], ["", "text \\<open>A renaming is a function changing the sign of some literals. We show that this operation preserves \n most of the previous syntactic and semantic notions.\\<close>"], ["", "definition rename_literal :: \"'at set \\<Rightarrow> 'at Literal \\<Rightarrow> 'at Literal\" \nwhere \"rename_literal A L = (if ((atom L) \\<in> A) then (complement L) else L)\""], ["", "definition rename_clause :: \"'at set \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause\"\n where \"rename_clause A C = {L. \\<exists>LL. LL \\<in> C \\<and> L = (rename_literal A LL)}\""], ["", "definition rename_formula :: \"'at set \\<Rightarrow> 'at Formula \\<Rightarrow> 'at Formula\"\nwhere \"rename_formula A S = {C. \\<exists>CC. CC \\<in> S \\<and> C = (rename_clause A CC)}\""], ["", "lemma inverse_renaming : \"(rename_literal A (rename_literal A L)) = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_literal A (rename_literal A L) = L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rename_literal A (rename_literal A L) = L", "obtain A where at: \"L = (Pos A) \\<or> L = (Neg A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. rename_literal A (rename_literal A L) = L", "from at"], ["proof (chain)\npicking this:\n  L = Pos A \\<or> L = Neg A", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. rename_literal A (rename_literal A L) = L", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. (if atom (if atom L \\<in> A then complement L else L) \\<in> A\n     then complement (if atom L \\<in> A then complement L else L)\n     else if atom L \\<in> A then complement L else L) =\n    L", "by auto"], ["proof (state)\nthis:\n  rename_literal A (rename_literal A L) = L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_clause_renaming : \"(rename_clause A (rename_clause A L)) = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause A (rename_clause A L) = L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rename_clause A (rename_clause A L) = L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause A (rename_clause A L) = L", "using inverse_renaming"], ["proof (prove)\nusing this:\n  rename_literal ?A (rename_literal ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. rename_clause A (rename_clause A L) = L", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  rename_literal ?A (rename_literal ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. {La.\n     \\<exists>LL.\n        LL \\<in> {La.\n                  \\<exists>LL.\n                     LL \\<in> L \\<and> La = rename_literal A LL} \\<and>\n        La = rename_literal A LL} =\n    L", "by auto"], ["proof (state)\nthis:\n  rename_clause A (rename_clause A L) = L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_formula_renaming : \"rename_formula A (rename_formula A L) = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_formula A (rename_formula A L) = L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rename_formula A (rename_formula A L) = L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_formula A (rename_formula A L) = L", "using inverse_clause_renaming"], ["proof (prove)\nusing this:\n  rename_clause ?A (rename_clause ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. rename_formula A (rename_formula A L) = L", "unfolding rename_formula_def"], ["proof (prove)\nusing this:\n  rename_clause ?A (rename_clause ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. {C. \\<exists>CC.\n           CC \\<in> {C. \\<exists>CC.\n                           CC \\<in> L \\<and> C = rename_clause A CC} \\<and>\n           C = rename_clause A CC} =\n    L", "by auto"], ["proof (state)\nthis:\n  rename_formula A (rename_formula A L) = L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma renaming_preserves_cardinality :\n  \"card (rename_clause A C) = card C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (rename_clause A C) = card C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (rename_clause A C) = card C", "have im: \"rename_clause A C = (rename_literal A) ` C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause A C = rename_literal A ` C", "unfolding rename_clause_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal A LL} =\n    rename_literal A ` C", "by auto"], ["proof (state)\nthis:\n  rename_clause A C = rename_literal A ` C\n\ngoal (1 subgoal):\n 1. card (rename_clause A C) = card C", "have \"inj_on (rename_literal A) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (rename_literal A) C", "by (metis inj_onI inverse_renaming)"], ["proof (state)\nthis:\n  inj_on (rename_literal A) C\n\ngoal (1 subgoal):\n 1. card (rename_clause A C) = card C", "from this and im"], ["proof (chain)\npicking this:\n  inj_on (rename_literal A) C\n  rename_clause A C = rename_literal A ` C", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on (rename_literal A) C\n  rename_clause A C = rename_literal A ` C\n\ngoal (1 subgoal):\n 1. card (rename_clause A C) = card C", "using card_image"], ["proof (prove)\nusing this:\n  inj_on (rename_literal A) C\n  rename_clause A C = rename_literal A ` C\n  inj_on ?f ?A \\<Longrightarrow> card (?f ` ?A) = card ?A\n\ngoal (1 subgoal):\n 1. card (rename_clause A C) = card C", "by auto"], ["proof (state)\nthis:\n  card (rename_clause A C) = card C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma renaming_preserves_literal_order :\n  assumes \"literal_ordering L1 L2\"\n  shows \"literal_ordering (rename_literal A L1) (rename_literal A L2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal_ordering (rename_literal A L1) (rename_literal A L2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. literal_ordering (rename_literal A L1) (rename_literal A L2)", "obtain A1 where at1: \"L1 = (Pos A1) \\<or> L1 = (Neg A1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A1.\n        L1 = Pos A1 \\<or> L1 = Neg A1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L1 ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L1 = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L1 = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A1.\n        L1 = Pos A1 \\<or> L1 = Neg A1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L1 = Pos A1 \\<or> L1 = Neg A1\n\ngoal (1 subgoal):\n 1. literal_ordering (rename_literal A L1) (rename_literal A L2)", "obtain A2 where at2: \"L2 = (Pos A2) \\<or> L2 = (Neg A2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A2.\n        L2 = Pos A2 \\<or> L2 = Neg A2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L2 ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L2 = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L2 = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A2.\n        L2 = Pos A2 \\<or> L2 = Neg A2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L2 = Pos A2 \\<or> L2 = Neg A2\n\ngoal (1 subgoal):\n 1. literal_ordering (rename_literal A L1) (rename_literal A L2)", "from assms and at1 and at2"], ["proof (chain)\npicking this:\n  literal_ordering L1 L2\n  L1 = Pos A1 \\<or> L1 = Neg A1\n  L2 = Pos A2 \\<or> L2 = Neg A2", "show ?thesis"], ["proof (prove)\nusing this:\n  literal_ordering L1 L2\n  L1 = Pos A1 \\<or> L1 = Neg A1\n  L2 = Pos A2 \\<or> L2 = Neg A2\n\ngoal (1 subgoal):\n 1. literal_ordering (rename_literal A L1) (rename_literal A L2)", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  literal_ordering L1 L2\n  L1 = Pos A1 \\<or> L1 = Neg A1\n  L2 = Pos A2 \\<or> L2 = Neg A2\n\ngoal (1 subgoal):\n 1. literal_ordering (if atom L1 \\<in> A then complement L1 else L1)\n     (if atom L2 \\<in> A then complement L2 else L2)", "by auto"], ["proof (state)\nthis:\n  literal_ordering (rename_literal A L1) (rename_literal A L2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_renaming_preserves_literal_order :\n  assumes  \"literal_ordering (rename_literal A L1) (rename_literal A L2)\"\n  shows \"literal_ordering L1 L2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal_ordering L1 L2", "by (metis assms inverse_renaming renaming_preserves_literal_order)"], ["", "lemma renaming_is_injective:\n  assumes \"rename_literal A L1 = rename_literal A L2\"\n  shows \"L1 = L2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L1 = L2", "by (metis (no_types) assms inverse_renaming)"], ["", "lemma renaming_preserves_strictly_maximal_literal :\n  assumes \"strictly_maximal_literal C L\"\n  shows \"strictly_maximal_literal (rename_clause A C) (rename_literal A L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_maximal_literal (rename_clause A C) (rename_literal A L)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. strictly_maximal_literal (rename_clause A C) (rename_literal A L)", "from assms"], ["proof (chain)\npicking this:\n  strictly_maximal_literal C L", "have \"(L \\<in> C)\" and Lismax: \"(\\<forall>B. (B \\<in> C \\<and> L \\<noteq> B)  \\<longrightarrow> (literal_ordering B L))\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal C L\n\ngoal (1 subgoal):\n 1. L \\<in> C &&&\n    \\<forall>B.\n       B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> C \\<and>\n  (\\<forall>B.\n      B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n\ngoal (1 subgoal):\n 1. L \\<in> C &&&\n    \\<forall>B.\n       B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L", "by auto"], ["proof (state)\nthis:\n  L \\<in> C\n  \\<forall>B.\n     B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal (rename_clause A C) (rename_literal A L)", "from \\<open>L \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> C", "have \"(rename_literal A L) \\<in> (rename_clause A C)\""], ["proof (prove)\nusing this:\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. rename_literal A L \\<in> rename_clause A C", "unfolding rename_literal_def and rename_clause_def"], ["proof (prove)\nusing this:\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. (if atom L \\<in> A then complement L else L)\n    \\<in> {L. \\<exists>LL.\n                 LL \\<in> C \\<and>\n                 L = (if atom LL \\<in> A then complement LL else LL)}", "by auto"], ["proof (state)\nthis:\n  rename_literal A L \\<in> rename_clause A C\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal (rename_clause A C) (rename_literal A L)", "have \n    \"\\<forall>B. (B \\<in> rename_clause A C \\<longrightarrow> rename_literal A L \\<noteq> B  \n      \\<longrightarrow> literal_ordering B (rename_literal A L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B.\n       B \\<in> rename_clause A C \\<longrightarrow>\n       rename_literal A L \\<noteq> B \\<longrightarrow>\n       literal_ordering B (rename_literal A L)", "proof (rule)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<in> rename_clause A C;\n        rename_literal A L \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> literal_ordering B (rename_literal A L)", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<in> rename_clause A C;\n        rename_literal A L \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> literal_ordering B (rename_literal A L)", "assume \"B \\<in> rename_clause A C\" and \"rename_literal A L \\<noteq> B\""], ["proof (state)\nthis:\n  B \\<in> rename_clause A C\n  rename_literal A L \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<in> rename_clause A C;\n        rename_literal A L \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> literal_ordering B (rename_literal A L)", "from \\<open>B \\<in> rename_clause A C\\<close>"], ["proof (chain)\npicking this:\n  B \\<in> rename_clause A C", "obtain B' where \"B' \\<in> C\" and \"B = rename_literal A B'\""], ["proof (prove)\nusing this:\n  B \\<in> rename_clause A C\n\ngoal (1 subgoal):\n 1. (\\<And>B'.\n        \\<lbrakk>B' \\<in> C; B = rename_literal A B'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  B \\<in> {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal A LL}\n\ngoal (1 subgoal):\n 1. (\\<And>B'.\n        \\<lbrakk>B' \\<in> C; B = rename_literal A B'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B' \\<in> C\n  B = rename_literal A B'\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<in> rename_clause A C;\n        rename_literal A L \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> literal_ordering B (rename_literal A L)", "from \\<open>rename_literal A L \\<noteq> B\\<close> and \\<open>B = rename_literal A B'\\<close>"], ["proof (chain)\npicking this:\n  rename_literal A L \\<noteq> B\n  B = rename_literal A B'", "have \"rename_literal A L \\<noteq> rename_literal A B'\""], ["proof (prove)\nusing this:\n  rename_literal A L \\<noteq> B\n  B = rename_literal A B'\n\ngoal (1 subgoal):\n 1. rename_literal A L \\<noteq> rename_literal A B'", "by auto"], ["proof (state)\nthis:\n  rename_literal A L \\<noteq> rename_literal A B'\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<in> rename_clause A C;\n        rename_literal A L \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> literal_ordering B (rename_literal A L)", "hence \"L \\<noteq> B'\""], ["proof (prove)\nusing this:\n  rename_literal A L \\<noteq> rename_literal A B'\n\ngoal (1 subgoal):\n 1. L \\<noteq> B'", "by auto"], ["proof (state)\nthis:\n  L \\<noteq> B'\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<in> rename_clause A C;\n        rename_literal A L \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> literal_ordering B (rename_literal A L)", "from this and \\<open>B' \\<in> C\\<close> and Lismax"], ["proof (chain)\npicking this:\n  L \\<noteq> B'\n  B' \\<in> C\n  \\<forall>B.\n     B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L", "have \"literal_ordering B' L\""], ["proof (prove)\nusing this:\n  L \\<noteq> B'\n  B' \\<in> C\n  \\<forall>B.\n     B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L\n\ngoal (1 subgoal):\n 1. literal_ordering B' L", "by auto"], ["proof (state)\nthis:\n  literal_ordering B' L\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<in> rename_clause A C;\n        rename_literal A L \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> literal_ordering B (rename_literal A L)", "from this and \\<open>B = (rename_literal A B')\\<close>"], ["proof (chain)\npicking this:\n  literal_ordering B' L\n  B = rename_literal A B'", "show \"literal_ordering B (rename_literal A L)\""], ["proof (prove)\nusing this:\n  literal_ordering B' L\n  B = rename_literal A B'\n\ngoal (1 subgoal):\n 1. literal_ordering B (rename_literal A L)", "using renaming_preserves_literal_order"], ["proof (prove)\nusing this:\n  literal_ordering B' L\n  B = rename_literal A B'\n  literal_ordering ?L1.0 ?L2.0 \\<Longrightarrow>\n  literal_ordering (rename_literal ?A ?L1.0) (rename_literal ?A ?L2.0)\n\ngoal (1 subgoal):\n 1. literal_ordering B (rename_literal A L)", "by auto"], ["proof (state)\nthis:\n  literal_ordering B (rename_literal A L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>B.\n     B \\<in> rename_clause A C \\<longrightarrow>\n     rename_literal A L \\<noteq> B \\<longrightarrow>\n     literal_ordering B (rename_literal A L)\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal (rename_clause A C) (rename_literal A L)", "from this and \\<open>(rename_literal A L) \\<in> (rename_clause A C)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>B.\n     B \\<in> rename_clause A C \\<longrightarrow>\n     rename_literal A L \\<noteq> B \\<longrightarrow>\n     literal_ordering B (rename_literal A L)\n  rename_literal A L \\<in> rename_clause A C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>B.\n     B \\<in> rename_clause A C \\<longrightarrow>\n     rename_literal A L \\<noteq> B \\<longrightarrow>\n     literal_ordering B (rename_literal A L)\n  rename_literal A L \\<in> rename_clause A C\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal (rename_clause A C) (rename_literal A L)", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  \\<forall>B.\n     B \\<in> rename_clause A C \\<longrightarrow>\n     rename_literal A L \\<noteq> B \\<longrightarrow>\n     literal_ordering B (rename_literal A L)\n  rename_literal A L \\<in> rename_clause A C\n\ngoal (1 subgoal):\n 1. rename_literal A L \\<in> rename_clause A C \\<and>\n    (\\<forall>B.\n        B \\<in> rename_clause A C \\<and>\n        rename_literal A L \\<noteq> B \\<longrightarrow>\n        literal_ordering B (rename_literal A L))", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal (rename_clause A C) (rename_literal A L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma renaming_and_selected_part :\n  \"selected_part UNIV C = rename_clause Sel (validated_part Sel (rename_clause Sel C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selected_part UNIV C =\n    rename_clause Sel (validated_part Sel (rename_clause Sel C))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. selected_part UNIV C\n    \\<subseteq> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n 2. rename_clause Sel (validated_part Sel (rename_clause Sel C))\n    \\<subseteq> selected_part UNIV C", "show \"selected_part UNIV C \\<subseteq> rename_clause Sel (validated_part Sel (rename_clause Sel C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selected_part UNIV C\n    \\<subseteq> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> selected_part UNIV C \\<Longrightarrow>\n       x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> selected_part UNIV C \\<Longrightarrow>\n       x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "assume \"x \\<in> selected_part UNIV C\""], ["proof (state)\nthis:\n  x \\<in> selected_part UNIV C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> selected_part UNIV C \\<Longrightarrow>\n       x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "show \"x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "from \\<open>x \\<in> selected_part UNIV C\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> selected_part UNIV C", "obtain A where \"x = Neg A\" and \"x \\<in> C\""], ["proof (prove)\nusing this:\n  x \\<in> selected_part UNIV C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = Neg A; x \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  x \\<in> {L \\<in> C. \\<exists>A\\<in>UNIV. L = Neg A}\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = Neg A; x \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = Neg A\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "from \\<open>x \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> C", "have \"rename_literal Sel x \\<in> rename_clause Sel C\""], ["proof (prove)\nusing this:\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. rename_literal Sel x \\<in> rename_clause Sel C", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. rename_literal Sel x\n    \\<in> {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal Sel LL}", "by blast"], ["proof (state)\nthis:\n  rename_literal Sel x \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "show \"x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n 2. \\<not> ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "assume \"A \\<in> Sel\""], ["proof (state)\nthis:\n  A \\<in> Sel\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n 2. \\<not> ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "from this and \\<open>x = Neg A\\<close>"], ["proof (chain)\npicking this:\n  A \\<in> Sel\n  x = Neg A", "have \"rename_literal Sel x = Pos A\""], ["proof (prove)\nusing this:\n  A \\<in> Sel\n  x = Neg A\n\ngoal (1 subgoal):\n 1. rename_literal Sel x = Pos A", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  A \\<in> Sel\n  x = Neg A\n\ngoal (1 subgoal):\n 1. (if atom x \\<in> Sel then complement x else x) = Pos A", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel x = Pos A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n 2. \\<not> ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "from this and \\<open>A \\<in> Sel\\<close>"], ["proof (chain)\npicking this:\n  rename_literal Sel x = Pos A\n  A \\<in> Sel", "have \"validate_literal Sel (rename_literal Sel x)\""], ["proof (prove)\nusing this:\n  rename_literal Sel x = Pos A\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. Sel \\<Turnstile> rename_literal Sel x", "by auto"], ["proof (state)\nthis:\n  Sel \\<Turnstile> rename_literal Sel x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n 2. \\<not> ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "from this and \\<open>rename_literal Sel x \\<in> rename_clause Sel C\\<close>"], ["proof (chain)\npicking this:\n  Sel \\<Turnstile> rename_literal Sel x\n  rename_literal Sel x \\<in> rename_clause Sel C", "have \"rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)\""], ["proof (prove)\nusing this:\n  Sel \\<Turnstile> rename_literal Sel x\n  rename_literal Sel x \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)", "unfolding validated_part_def"], ["proof (prove)\nusing this:\n  Sel \\<Turnstile> rename_literal Sel x\n  rename_literal Sel x \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. rename_literal Sel x\n    \\<in> {L \\<in> rename_clause Sel C. Sel \\<Turnstile> L}", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n 2. \\<not> ?P \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "thus \"x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\""], ["proof (prove)\nusing this:\n  rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)\n\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "using inverse_renaming rename_clause_def"], ["proof (prove)\nusing this:\n  rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)\n  rename_literal ?A (rename_literal ?A ?L) = ?L\n  rename_clause ?A ?C =\n  {L. \\<exists>LL. LL \\<in> ?C \\<and> L = rename_literal ?A LL}\n\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "by auto"], ["proof (state)\nthis:\n  x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "assume \"A \\<notin> Sel\""], ["proof (state)\nthis:\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "from this and \\<open>x = Neg A\\<close>"], ["proof (chain)\npicking this:\n  A \\<notin> Sel\n  x = Neg A", "have \"rename_literal Sel x = Neg A\""], ["proof (prove)\nusing this:\n  A \\<notin> Sel\n  x = Neg A\n\ngoal (1 subgoal):\n 1. rename_literal Sel x = Neg A", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  A \\<notin> Sel\n  x = Neg A\n\ngoal (1 subgoal):\n 1. (if atom x \\<in> Sel then complement x else x) = Neg A", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel x = Neg A\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "from this and \\<open>A \\<notin> Sel\\<close>"], ["proof (chain)\npicking this:\n  rename_literal Sel x = Neg A\n  A \\<notin> Sel", "have \"validate_literal Sel (rename_literal Sel x)\""], ["proof (prove)\nusing this:\n  rename_literal Sel x = Neg A\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. Sel \\<Turnstile> rename_literal Sel x", "by auto"], ["proof (state)\nthis:\n  Sel \\<Turnstile> rename_literal Sel x\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "from this and \\<open>rename_literal Sel x \\<in> rename_clause Sel C\\<close>"], ["proof (chain)\npicking this:\n  Sel \\<Turnstile> rename_literal Sel x\n  rename_literal Sel x \\<in> rename_clause Sel C", "have \"rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)\""], ["proof (prove)\nusing this:\n  Sel \\<Turnstile> rename_literal Sel x\n  rename_literal Sel x \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)", "unfolding  validated_part_def"], ["proof (prove)\nusing this:\n  Sel \\<Turnstile> rename_literal Sel x\n  rename_literal Sel x \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. rename_literal Sel x\n    \\<in> {L \\<in> rename_clause Sel C. Sel \\<Turnstile> L}", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "thus \"x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\""], ["proof (prove)\nusing this:\n  rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)\n\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "using inverse_renaming rename_clause_def"], ["proof (prove)\nusing this:\n  rename_literal Sel x \\<in> validated_part Sel (rename_clause Sel C)\n  rename_literal ?A (rename_literal ?A ?L) = ?L\n  rename_clause ?A ?C =\n  {L. \\<exists>LL. LL \\<in> ?C \\<and> L = rename_literal ?A LL}\n\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "by auto"], ["proof (state)\nthis:\n  x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  selected_part UNIV C\n  \\<subseteq> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n\ngoal (1 subgoal):\n 1. rename_clause Sel (validated_part Sel (rename_clause Sel C))\n    \\<subseteq> selected_part UNIV C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rename_clause Sel (validated_part Sel (rename_clause Sel C))\n    \\<subseteq> selected_part UNIV C", "show \"rename_clause Sel (validated_part Sel (rename_clause Sel C)) \\<subseteq> (selected_part UNIV C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel (validated_part Sel (rename_clause Sel C))\n    \\<subseteq> selected_part UNIV C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel\n                (validated_part Sel (rename_clause Sel C)) \\<Longrightarrow>\n       x \\<in> selected_part UNIV C", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel\n                (validated_part Sel (rename_clause Sel C)) \\<Longrightarrow>\n       x \\<in> selected_part UNIV C", "assume \"x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\""], ["proof (state)\nthis:\n  x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel\n                (validated_part Sel (rename_clause Sel C)) \\<Longrightarrow>\n       x \\<in> selected_part UNIV C", "from this"], ["proof (chain)\npicking this:\n  x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))", "obtain y where \"y \\<in> validated_part Sel (rename_clause Sel C)\" \n      and \"x = rename_literal Sel y\""], ["proof (prove)\nusing this:\n  x \\<in> rename_clause Sel (validated_part Sel (rename_clause Sel C))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> validated_part Sel (rename_clause Sel C);\n         x = rename_literal Sel y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rename_clause_def validated_part_def"], ["proof (prove)\nusing this:\n  x \\<in> {L. \\<exists>LL.\n                 LL \\<in> {L \\<in> {L. \\<exists>LL.\n    LL \\<in> C \\<and> L = rename_literal Sel LL}.\n                           Sel \\<Turnstile> L} \\<and>\n                 L = rename_literal Sel LL}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> {L \\<in> {L. \\<exists>LL.\n   LL \\<in> C \\<and> L = rename_literal Sel LL}.\n                          Sel \\<Turnstile> L};\n         x = rename_literal Sel y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> validated_part Sel (rename_clause Sel C)\n  x = rename_literal Sel y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel\n                (validated_part Sel (rename_clause Sel C)) \\<Longrightarrow>\n       x \\<in> selected_part UNIV C", "from \\<open>y \\<in> validated_part Sel (rename_clause Sel C)\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> validated_part Sel (rename_clause Sel C)", "have\n      \"y \\<in> rename_clause Sel C\" and \"validate_literal Sel y\""], ["proof (prove)\nusing this:\n  y \\<in> validated_part Sel (rename_clause Sel C)\n\ngoal (1 subgoal):\n 1. y \\<in> rename_clause Sel C &&& Sel \\<Turnstile> y", "unfolding validated_part_def"], ["proof (prove)\nusing this:\n  y \\<in> {L \\<in> rename_clause Sel C. Sel \\<Turnstile> L}\n\ngoal (1 subgoal):\n 1. y \\<in> rename_clause Sel C &&& Sel \\<Turnstile> y", "by auto"], ["proof (state)\nthis:\n  y \\<in> rename_clause Sel C\n  Sel \\<Turnstile> y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel\n                (validated_part Sel (rename_clause Sel C)) \\<Longrightarrow>\n       x \\<in> selected_part UNIV C", "from \\<open>y \\<in> rename_clause Sel C\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> rename_clause Sel C", "obtain z where \"z \\<in> C\" and \"y = rename_literal Sel z\""], ["proof (prove)\nusing this:\n  y \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> C; y = rename_literal Sel z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  y \\<in> {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal Sel LL}\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> C; y = rename_literal Sel z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> C\n  y = rename_literal Sel z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel\n                (validated_part Sel (rename_clause Sel C)) \\<Longrightarrow>\n       x \\<in> selected_part UNIV C", "obtain A where zA: \"z = Pos A \\<or> z = Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        z = Pos A \\<or> z = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. z = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. z = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        z = Pos A \\<or> z = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = Pos A \\<or> z = Neg A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel\n                (validated_part Sel (rename_clause Sel C)) \\<Longrightarrow>\n       x \\<in> selected_part UNIV C", "show \"x \\<in> selected_part UNIV C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> selected_part UNIV C", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x \\<in> selected_part UNIV C\n 2. \\<not> ?P \\<Longrightarrow> x \\<in> selected_part UNIV C", "assume \"A \\<in> Sel\""], ["proof (state)\nthis:\n  A \\<in> Sel\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x \\<in> selected_part UNIV C\n 2. \\<not> ?P \\<Longrightarrow> x \\<in> selected_part UNIV C", "from this and zA and \\<open>y = rename_literal Sel z\\<close>"], ["proof (chain)\npicking this:\n  A \\<in> Sel\n  z = Pos A \\<or> z = Neg A\n  y = rename_literal Sel z", "have \"y = complement z\""], ["proof (prove)\nusing this:\n  A \\<in> Sel\n  z = Pos A \\<or> z = Neg A\n  y = rename_literal Sel z\n\ngoal (1 subgoal):\n 1. y = complement z", "using rename_literal_def"], ["proof (prove)\nusing this:\n  A \\<in> Sel\n  z = Pos A \\<or> z = Neg A\n  y = rename_literal Sel z\n  rename_literal ?A ?L = (if atom ?L \\<in> ?A then complement ?L else ?L)\n\ngoal (1 subgoal):\n 1. y = complement z", "by auto"], ["proof (state)\nthis:\n  y = complement z\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x \\<in> selected_part UNIV C\n 2. \\<not> ?P \\<Longrightarrow> x \\<in> selected_part UNIV C", "from this and \\<open>A \\<in> Sel\\<close> and zA and \\<open>validate_literal Sel y\\<close>"], ["proof (chain)\npicking this:\n  y = complement z\n  A \\<in> Sel\n  z = Pos A \\<or> z = Neg A\n  Sel \\<Turnstile> y", "have \"y = Pos A\" \n          and \"z = Neg A\""], ["proof (prove)\nusing this:\n  y = complement z\n  A \\<in> Sel\n  z = Pos A \\<or> z = Neg A\n  Sel \\<Turnstile> y\n\ngoal (1 subgoal):\n 1. y = Pos A &&& z = Neg A", "by auto"], ["proof (state)\nthis:\n  y = Pos A\n  z = Neg A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x \\<in> selected_part UNIV C\n 2. \\<not> ?P \\<Longrightarrow> x \\<in> selected_part UNIV C", "from this and  \\<open>A \\<in> Sel\\<close> and \\<open>x = rename_literal Sel y\\<close>"], ["proof (chain)\npicking this:\n  y = Pos A\n  z = Neg A\n  A \\<in> Sel\n  x = rename_literal Sel y", "have \"x = Neg A\""], ["proof (prove)\nusing this:\n  y = Pos A\n  z = Neg A\n  A \\<in> Sel\n  x = rename_literal Sel y\n\ngoal (1 subgoal):\n 1. x = Neg A", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  y = Pos A\n  z = Neg A\n  A \\<in> Sel\n  x = (if atom y \\<in> Sel then complement y else y)\n\ngoal (1 subgoal):\n 1. x = Neg A", "by auto"], ["proof (state)\nthis:\n  x = Neg A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x \\<in> selected_part UNIV C\n 2. \\<not> ?P \\<Longrightarrow> x \\<in> selected_part UNIV C", "from this and \\<open>z \\<in> C\\<close> and \\<open>z = Neg A\\<close>"], ["proof (chain)\npicking this:\n  x = Neg A\n  z \\<in> C\n  z = Neg A", "show \"x \\<in> selected_part UNIV C\""], ["proof (prove)\nusing this:\n  x = Neg A\n  z \\<in> C\n  z = Neg A\n\ngoal (1 subgoal):\n 1. x \\<in> selected_part UNIV C", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  x = Neg A\n  z \\<in> C\n  z = Neg A\n\ngoal (1 subgoal):\n 1. x \\<in> {L \\<in> C. \\<exists>A\\<in>UNIV. L = Neg A}", "by auto"], ["proof (state)\nthis:\n  x \\<in> selected_part UNIV C\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> x \\<in> selected_part UNIV C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> x \\<in> selected_part UNIV C", "assume \"A \\<notin> Sel\""], ["proof (state)\nthis:\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> x \\<in> selected_part UNIV C", "from this and zA and \\<open>y = rename_literal Sel z\\<close>"], ["proof (chain)\npicking this:\n  A \\<notin> Sel\n  z = Pos A \\<or> z = Neg A\n  y = rename_literal Sel z", "have \"y = z\""], ["proof (prove)\nusing this:\n  A \\<notin> Sel\n  z = Pos A \\<or> z = Neg A\n  y = rename_literal Sel z\n\ngoal (1 subgoal):\n 1. y = z", "using rename_literal_def"], ["proof (prove)\nusing this:\n  A \\<notin> Sel\n  z = Pos A \\<or> z = Neg A\n  y = rename_literal Sel z\n  rename_literal ?A ?L = (if atom ?L \\<in> ?A then complement ?L else ?L)\n\ngoal (1 subgoal):\n 1. y = z", "by auto"], ["proof (state)\nthis:\n  y = z\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> x \\<in> selected_part UNIV C", "from this and \\<open>A \\<notin> Sel\\<close> and zA and \\<open>validate_literal Sel y\\<close>"], ["proof (chain)\npicking this:\n  y = z\n  A \\<notin> Sel\n  z = Pos A \\<or> z = Neg A\n  Sel \\<Turnstile> y", "have \"y = Neg A\" \n          and \"z = Neg A\""], ["proof (prove)\nusing this:\n  y = z\n  A \\<notin> Sel\n  z = Pos A \\<or> z = Neg A\n  Sel \\<Turnstile> y\n\ngoal (1 subgoal):\n 1. y = Neg A &&& z = Neg A", "by auto"], ["proof (state)\nthis:\n  y = Neg A\n  z = Neg A\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> x \\<in> selected_part UNIV C", "from this and  \\<open>A \\<notin> Sel\\<close> and \\<open>x = rename_literal Sel y\\<close>"], ["proof (chain)\npicking this:\n  y = Neg A\n  z = Neg A\n  A \\<notin> Sel\n  x = rename_literal Sel y", "have \"x = Neg A\""], ["proof (prove)\nusing this:\n  y = Neg A\n  z = Neg A\n  A \\<notin> Sel\n  x = rename_literal Sel y\n\ngoal (1 subgoal):\n 1. x = Neg A", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  y = Neg A\n  z = Neg A\n  A \\<notin> Sel\n  x = (if atom y \\<in> Sel then complement y else y)\n\ngoal (1 subgoal):\n 1. x = Neg A", "by auto"], ["proof (state)\nthis:\n  x = Neg A\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> x \\<in> selected_part UNIV C", "from this and \\<open>z \\<in> C\\<close> and \\<open>z = Neg A\\<close>"], ["proof (chain)\npicking this:\n  x = Neg A\n  z \\<in> C\n  z = Neg A", "show \"x \\<in> selected_part UNIV C\""], ["proof (prove)\nusing this:\n  x = Neg A\n  z \\<in> C\n  z = Neg A\n\ngoal (1 subgoal):\n 1. x \\<in> selected_part UNIV C", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  x = Neg A\n  z \\<in> C\n  z = Neg A\n\ngoal (1 subgoal):\n 1. x \\<in> {L \\<in> C. \\<exists>A\\<in>UNIV. L = Neg A}", "by auto"], ["proof (state)\nthis:\n  x \\<in> selected_part UNIV C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> selected_part UNIV C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rename_clause Sel (validated_part Sel (rename_clause Sel C))\n  \\<subseteq> selected_part UNIV C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma renaming_preserves_tautology:\n  assumes \"tautology C\"\n  shows \"tautology (rename_clause Sel C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tautology (rename_clause Sel C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tautology (rename_clause Sel C)", "from assms"], ["proof (chain)\npicking this:\n  tautology C", "obtain A where \"Pos A \\<in> C\" and \"Neg A \\<in> C\""], ["proof (prove)\nusing this:\n  tautology C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>Pos A \\<in> C; Neg A \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  \\<exists>A. Pos A \\<in> C \\<and> Neg A \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>Pos A \\<in> C; Neg A \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Pos A \\<in> C\n  Neg A \\<in> C\n\ngoal (1 subgoal):\n 1. tautology (rename_clause Sel C)", "from \\<open>Pos A \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  Pos A \\<in> C", "have \"rename_literal Sel (Pos A) \\<in>  rename_clause Sel C\""], ["proof (prove)\nusing this:\n  Pos A \\<in> C\n\ngoal (1 subgoal):\n 1. rename_literal Sel (Pos A) \\<in> rename_clause Sel C", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  Pos A \\<in> C\n\ngoal (1 subgoal):\n 1. rename_literal Sel (Pos A)\n    \\<in> {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal Sel LL}", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel (Pos A) \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. tautology (rename_clause Sel C)", "from \\<open>Neg A \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  Neg A \\<in> C", "have \"rename_literal Sel (Neg A) \\<in>  rename_clause Sel C\""], ["proof (prove)\nusing this:\n  Neg A \\<in> C\n\ngoal (1 subgoal):\n 1. rename_literal Sel (Neg A) \\<in> rename_clause Sel C", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  Neg A \\<in> C\n\ngoal (1 subgoal):\n 1. rename_literal Sel (Neg A)\n    \\<in> {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal Sel LL}", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel (Neg A) \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. tautology (rename_clause Sel C)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tautology (rename_clause Sel C)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> tautology (rename_clause Sel C)\n 2. \\<not> ?P \\<Longrightarrow> tautology (rename_clause Sel C)", "assume \"A \\<in> Sel\""], ["proof (state)\nthis:\n  A \\<in> Sel\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> tautology (rename_clause Sel C)\n 2. \\<not> ?P \\<Longrightarrow> tautology (rename_clause Sel C)", "from this"], ["proof (chain)\npicking this:\n  A \\<in> Sel", "have \"rename_literal Sel (Pos A) = Neg A\" \n      and \"rename_literal Sel (Neg A) = (Pos A)\""], ["proof (prove)\nusing this:\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. rename_literal Sel (Pos A) = Neg A &&&\n    rename_literal Sel (Neg A) = Pos A", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. (if atom (Pos A) \\<in> Sel then complement (Pos A) else Pos A) =\n    Neg A &&&\n    (if atom (Neg A) \\<in> Sel then complement (Neg A) else Neg A) = Pos A", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel (Pos A) = Neg A\n  rename_literal Sel (Neg A) = Pos A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> tautology (rename_clause Sel C)\n 2. \\<not> ?P \\<Longrightarrow> tautology (rename_clause Sel C)", "from \\<open>rename_literal Sel (Pos A) = (Neg A)\\<close> and  \\<open>rename_literal Sel (Neg A) = (Pos A)\\<close> \n      and \\<open>rename_literal Sel (Pos A) \\<in>  (rename_clause Sel C)\\<close> \n      and  \\<open>rename_literal Sel (Neg A) \\<in>  (rename_clause Sel C)\\<close>"], ["proof (chain)\npicking this:\n  rename_literal Sel (Pos A) = Neg A\n  rename_literal Sel (Neg A) = Pos A\n  rename_literal Sel (Pos A) \\<in> rename_clause Sel C\n  rename_literal Sel (Neg A) \\<in> rename_clause Sel C", "show \"tautology (rename_clause Sel C)\""], ["proof (prove)\nusing this:\n  rename_literal Sel (Pos A) = Neg A\n  rename_literal Sel (Neg A) = Pos A\n  rename_literal Sel (Pos A) \\<in> rename_clause Sel C\n  rename_literal Sel (Neg A) \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. tautology (rename_clause Sel C)", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  rename_literal Sel (Pos A) = Neg A\n  rename_literal Sel (Neg A) = Pos A\n  rename_literal Sel (Pos A) \\<in> rename_clause Sel C\n  rename_literal Sel (Neg A) \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       Pos A \\<in> rename_clause Sel C \\<and>\n       Neg A \\<in> rename_clause Sel C", "by auto"], ["proof (state)\nthis:\n  tautology (rename_clause Sel C)\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> tautology (rename_clause Sel C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> tautology (rename_clause Sel C)", "assume \"A \\<notin> Sel\""], ["proof (state)\nthis:\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> tautology (rename_clause Sel C)", "from this"], ["proof (chain)\npicking this:\n  A \\<notin> Sel", "have \"rename_literal Sel (Pos A) = Pos A\" and \"rename_literal Sel (Neg A) = (Neg A)\""], ["proof (prove)\nusing this:\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. rename_literal Sel (Pos A) = Pos A &&&\n    rename_literal Sel (Neg A) = Neg A", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. (if atom (Pos A) \\<in> Sel then complement (Pos A) else Pos A) =\n    Pos A &&&\n    (if atom (Neg A) \\<in> Sel then complement (Neg A) else Neg A) = Neg A", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel (Pos A) = Pos A\n  rename_literal Sel (Neg A) = Neg A\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow> tautology (rename_clause Sel C)", "from \\<open>rename_literal Sel (Pos A) = Pos A\\<close> and \\<open>rename_literal Sel (Neg A) = (Neg A)\\<close> \n      and \\<open>rename_literal Sel (Pos A) \\<in>  rename_clause Sel C\\<close> \n      and  \\<open>rename_literal Sel (Neg A) \\<in>  rename_clause Sel C\\<close>"], ["proof (chain)\npicking this:\n  rename_literal Sel (Pos A) = Pos A\n  rename_literal Sel (Neg A) = Neg A\n  rename_literal Sel (Pos A) \\<in> rename_clause Sel C\n  rename_literal Sel (Neg A) \\<in> rename_clause Sel C", "show \"tautology (rename_clause Sel C)\""], ["proof (prove)\nusing this:\n  rename_literal Sel (Pos A) = Pos A\n  rename_literal Sel (Neg A) = Neg A\n  rename_literal Sel (Pos A) \\<in> rename_clause Sel C\n  rename_literal Sel (Neg A) \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. tautology (rename_clause Sel C)", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  rename_literal Sel (Pos A) = Pos A\n  rename_literal Sel (Neg A) = Neg A\n  rename_literal Sel (Pos A) \\<in> rename_clause Sel C\n  rename_literal Sel (Neg A) \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       Pos A \\<in> rename_clause Sel C \\<and>\n       Neg A \\<in> rename_clause Sel C", "by auto"], ["proof (state)\nthis:\n  tautology (rename_clause Sel C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tautology (rename_clause Sel C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rename_union : \"rename_clause Sel (C \\<union> D) = rename_clause Sel C \\<union> rename_clause Sel D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel (C \\<union> D) =\n    rename_clause Sel C \\<union> rename_clause Sel D", "unfolding rename_clause_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {L. \\<exists>LL.\n           LL \\<in> C \\<union> D \\<and> L = rename_literal Sel LL} =\n    {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal Sel LL} \\<union>\n    {L. \\<exists>LL. LL \\<in> D \\<and> L = rename_literal Sel LL}", "by auto"], ["", "lemma renaming_set_minus_subset : \n  \"rename_clause Sel (C - { L }) \\<subseteq> rename_clause Sel C - {rename_literal Sel L }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel (C - {L})\n    \\<subseteq> rename_clause Sel C - {rename_literal Sel L}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel (C - {L}) \\<Longrightarrow>\n       x \\<in> rename_clause Sel C - {rename_literal Sel L}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel (C - {L}) \\<Longrightarrow>\n       x \\<in> rename_clause Sel C - {rename_literal Sel L}", "assume \"x \\<in> rename_clause Sel (C - { L })\""], ["proof (state)\nthis:\n  x \\<in> rename_clause Sel (C - {L})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel (C - {L}) \\<Longrightarrow>\n       x \\<in> rename_clause Sel C - {rename_literal Sel L}", "then"], ["proof (chain)\npicking this:\n  x \\<in> rename_clause Sel (C - {L})", "obtain y where \"y \\<in> C - { L }\" and \"x = rename_literal Sel y\""], ["proof (prove)\nusing this:\n  x \\<in> rename_clause Sel (C - {L})\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C - {L}; x = rename_literal Sel y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  x \\<in> {La.\n           \\<exists>LL. LL \\<in> C - {L} \\<and> La = rename_literal Sel LL}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C - {L}; x = rename_literal Sel y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> C - {L}\n  x = rename_literal Sel y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel (C - {L}) \\<Longrightarrow>\n       x \\<in> rename_clause Sel C - {rename_literal Sel L}", "from \\<open>y \\<in> C - { L }\\<close> and \\<open>x = rename_literal Sel y\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> C - {L}\n  x = rename_literal Sel y", "have \"x \\<in> rename_clause Sel C\""], ["proof (prove)\nusing this:\n  y \\<in> C - {L}\n  x = rename_literal Sel y\n\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel C", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  y \\<in> C - {L}\n  x = rename_literal Sel y\n\ngoal (1 subgoal):\n 1. x \\<in> {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal Sel LL}", "by auto"], ["proof (state)\nthis:\n  x \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel (C - {L}) \\<Longrightarrow>\n       x \\<in> rename_clause Sel C - {rename_literal Sel L}", "have \"x \\<noteq> rename_literal Sel L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> rename_literal Sel L", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x = rename_literal Sel L \\<Longrightarrow> False", "assume \"x = rename_literal Sel L\""], ["proof (state)\nthis:\n  x = rename_literal Sel L\n\ngoal (1 subgoal):\n 1. x = rename_literal Sel L \\<Longrightarrow> False", "hence \"rename_literal Sel x = L\""], ["proof (prove)\nusing this:\n  x = rename_literal Sel L\n\ngoal (1 subgoal):\n 1. rename_literal Sel x = L", "using inverse_renaming"], ["proof (prove)\nusing this:\n  x = rename_literal Sel L\n  rename_literal ?A (rename_literal ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. rename_literal Sel x = L", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel x = L\n\ngoal (1 subgoal):\n 1. x = rename_literal Sel L \\<Longrightarrow> False", "from this and \\<open>x = rename_literal Sel y\\<close>"], ["proof (chain)\npicking this:\n  rename_literal Sel x = L\n  x = rename_literal Sel y", "have \"y = L\""], ["proof (prove)\nusing this:\n  rename_literal Sel x = L\n  x = rename_literal Sel y\n\ngoal (1 subgoal):\n 1. y = L", "using inverse_renaming"], ["proof (prove)\nusing this:\n  rename_literal Sel x = L\n  x = rename_literal Sel y\n  rename_literal ?A (rename_literal ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. y = L", "by auto"], ["proof (state)\nthis:\n  y = L\n\ngoal (1 subgoal):\n 1. x = rename_literal Sel L \\<Longrightarrow> False", "from this and \\<open>y \\<in> C - { L }\\<close>"], ["proof (chain)\npicking this:\n  y = L\n  y \\<in> C - {L}", "show \"False\""], ["proof (prove)\nusing this:\n  y = L\n  y \\<in> C - {L}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> rename_literal Sel L\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rename_clause Sel (C - {L}) \\<Longrightarrow>\n       x \\<in> rename_clause Sel C - {rename_literal Sel L}", "from \\<open>x \\<noteq> rename_literal Sel L\\<close> and \\<open>x \\<in> rename_clause Sel C\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> rename_literal Sel L\n  x \\<in> rename_clause Sel C", "show \"x \\<in> (rename_clause Sel C) - {rename_literal Sel L }\""], ["proof (prove)\nusing this:\n  x \\<noteq> rename_literal Sel L\n  x \\<in> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. x \\<in> rename_clause Sel C - {rename_literal Sel L}", "by auto"], ["proof (state)\nthis:\n  x \\<in> rename_clause Sel C - {rename_literal Sel L}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma renaming_set_minus : \"rename_clause Sel (C - { L }) \n  = (rename_clause Sel C) - {rename_literal Sel L }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel (C - {L}) =\n    rename_clause Sel C - {rename_literal Sel L}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rename_clause Sel (C - {L})\n    \\<subseteq> rename_clause Sel C - {rename_literal Sel L}\n 2. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "show \"rename_clause Sel (C - { L }) \\<subseteq>  (rename_clause Sel C) - {rename_literal Sel L }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel (C - {L})\n    \\<subseteq> rename_clause Sel C - {rename_literal Sel L}", "using renaming_set_minus_subset"], ["proof (prove)\nusing this:\n  rename_clause ?Sel (?C - {?L})\n  \\<subseteq> rename_clause ?Sel ?C - {rename_literal ?Sel ?L}\n\ngoal (1 subgoal):\n 1. rename_clause Sel (C - {L})\n    \\<subseteq> rename_clause Sel C - {rename_literal Sel L}", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel (C - {L})\n  \\<subseteq> rename_clause Sel C - {rename_literal Sel L}\n\ngoal (1 subgoal):\n 1. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "show \"(rename_clause Sel C) - {rename_literal Sel L } \\<subseteq> rename_clause Sel (C - { L })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "have \"rename_clause Sel ( (rename_clause Sel C) - { (rename_literal Sel L) }) \n      \\<subseteq>  (rename_clause Sel (rename_clause Sel C)) - {rename_literal Sel (rename_literal Sel L) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n    \\<subseteq> rename_clause Sel (rename_clause Sel C) -\n                {rename_literal Sel (rename_literal Sel L)}", "using renaming_set_minus_subset"], ["proof (prove)\nusing this:\n  rename_clause ?Sel (?C - {?L})\n  \\<subseteq> rename_clause ?Sel ?C - {rename_literal ?Sel ?L}\n\ngoal (1 subgoal):\n 1. rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n    \\<subseteq> rename_clause Sel (rename_clause Sel C) -\n                {rename_literal Sel (rename_literal Sel L)}", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n  \\<subseteq> rename_clause Sel (rename_clause Sel C) -\n              {rename_literal Sel (rename_literal Sel L)}\n\ngoal (1 subgoal):\n 1. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "from this"], ["proof (chain)\npicking this:\n  rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n  \\<subseteq> rename_clause Sel (rename_clause Sel C) -\n              {rename_literal Sel (rename_literal Sel L)}", "have \"rename_clause Sel ( (rename_clause Sel C) - { (rename_literal Sel L) }) \\<subseteq>  (C - {L })\""], ["proof (prove)\nusing this:\n  rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n  \\<subseteq> rename_clause Sel (rename_clause Sel C) -\n              {rename_literal Sel (rename_literal Sel L)}\n\ngoal (1 subgoal):\n 1. rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n    \\<subseteq> C - {L}", "using inverse_renaming inverse_clause_renaming"], ["proof (prove)\nusing this:\n  rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n  \\<subseteq> rename_clause Sel (rename_clause Sel C) -\n              {rename_literal Sel (rename_literal Sel L)}\n  rename_literal ?A (rename_literal ?A ?L) = ?L\n  rename_clause ?A (rename_clause ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n    \\<subseteq> C - {L}", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n  \\<subseteq> C - {L}\n\ngoal (1 subgoal):\n 1. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "from this"], ["proof (chain)\npicking this:\n  rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n  \\<subseteq> C - {L}", "have \"rename_clause Sel (rename_clause Sel ( (rename_clause Sel C) - { (rename_literal Sel L) })) \n            \\<subseteq>  (rename_clause Sel (C - {L }))\""], ["proof (prove)\nusing this:\n  rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n  \\<subseteq> C - {L}\n\ngoal (1 subgoal):\n 1. rename_clause Sel\n     (rename_clause Sel (rename_clause Sel C - {rename_literal Sel L}))\n    \\<subseteq> rename_clause Sel (C - {L})", "using rename_clause_def"], ["proof (prove)\nusing this:\n  rename_clause Sel (rename_clause Sel C - {rename_literal Sel L})\n  \\<subseteq> C - {L}\n  rename_clause ?A ?C =\n  {L. \\<exists>LL. LL \\<in> ?C \\<and> L = rename_literal ?A LL}\n\ngoal (1 subgoal):\n 1. rename_clause Sel\n     (rename_clause Sel (rename_clause Sel C - {rename_literal Sel L}))\n    \\<subseteq> rename_clause Sel (C - {L})", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel\n   (rename_clause Sel (rename_clause Sel C - {rename_literal Sel L}))\n  \\<subseteq> rename_clause Sel (C - {L})\n\ngoal (1 subgoal):\n 1. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "from this"], ["proof (chain)\npicking this:\n  rename_clause Sel\n   (rename_clause Sel (rename_clause Sel C - {rename_literal Sel L}))\n  \\<subseteq> rename_clause Sel (C - {L})", "show \"(rename_clause Sel C) - { (rename_literal Sel L) } \\<subseteq>  rename_clause Sel (C - {L })\""], ["proof (prove)\nusing this:\n  rename_clause Sel\n   (rename_clause Sel (rename_clause Sel C - {rename_literal Sel L}))\n  \\<subseteq> rename_clause Sel (C - {L})\n\ngoal (1 subgoal):\n 1. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "using inverse_renaming inverse_clause_renaming"], ["proof (prove)\nusing this:\n  rename_clause Sel\n   (rename_clause Sel (rename_clause Sel C - {rename_literal Sel L}))\n  \\<subseteq> rename_clause Sel (C - {L})\n  rename_literal ?A (rename_literal ?A ?L) = ?L\n  rename_clause ?A (rename_clause ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. rename_clause Sel C - {rename_literal Sel L}\n    \\<subseteq> rename_clause Sel (C - {L})", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel C - {rename_literal Sel L}\n  \\<subseteq> rename_clause Sel (C - {L})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rename_clause Sel C - {rename_literal Sel L}\n  \\<subseteq> rename_clause Sel (C - {L})\n\ngoal:\nNo subgoals!", "qed"], ["", "definition rename_interpretation :: \"'at set \\<Rightarrow> 'at Interpretation \\<Rightarrow> 'at Interpretation\"\nwhere \n  \"rename_interpretation Sel I = { A. (A \\<in> I \\<and> A \\<notin> Sel) } \\<union> { A. (A \\<notin> I \\<and> A \\<in> Sel) }\""], ["", "lemma renaming_preserves_semantic :\n  assumes \"validate_literal I L\"\n  shows \"validate_literal (rename_interpretation Sel I) (rename_literal Sel L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "let ?J = \"rename_interpretation Sel I\""], ["proof (state)\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "obtain A where \"L = Pos A \\<or> L = Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        L = Pos A \\<or> L = Neg A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from \\<open>L = Pos A \\<or> L = Neg A\\<close>"], ["proof (chain)\npicking this:\n  L = Pos A \\<or> L = Neg A", "have \"atom L = A\""], ["proof (prove)\nusing this:\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. atom L = A", "by auto"], ["proof (state)\nthis:\n  atom L = A\n\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "assume \"A \\<in> Sel\""], ["proof (state)\nthis:\n  A \\<in> Sel\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>atom L = A\\<close>"], ["proof (chain)\npicking this:\n  A \\<in> Sel\n  atom L = A", "have \"rename_literal Sel L = complement L\""], ["proof (prove)\nusing this:\n  A \\<in> Sel\n  atom L = A\n\ngoal (1 subgoal):\n 1. rename_literal Sel L = complement L", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  A \\<in> Sel\n  atom L = A\n\ngoal (1 subgoal):\n 1. (if atom L \\<in> Sel then complement L else L) = complement L", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel L = complement L\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "assume \"L = Pos A\""], ["proof (state)\nthis:\n  L = Pos A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>validate_literal I L\\<close>"], ["proof (chain)\npicking this:\n  L = Pos A\n  I \\<Turnstile> L", "have \"A \\<in> I\""], ["proof (prove)\nusing this:\n  L = Pos A\n  I \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. A \\<in> I", "by auto"], ["proof (state)\nthis:\n  A \\<in> I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>A \\<in> Sel\\<close>"], ["proof (chain)\npicking this:\n  A \\<in> I\n  A \\<in> Sel", "have \"A \\<notin> ?J\""], ["proof (prove)\nusing this:\n  A \\<in> I\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. A \\<notin> rename_interpretation Sel I", "unfolding rename_interpretation_def"], ["proof (prove)\nusing this:\n  A \\<in> I\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. A \\<notin> {A \\<in> I. A \\<notin> Sel} \\<union>\n               {A. A \\<notin> I \\<and> A \\<in> Sel}", "by blast"], ["proof (state)\nthis:\n  A \\<notin> rename_interpretation Sel I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>L = Pos A\\<close> and \\<open>rename_literal Sel L = complement L\\<close>"], ["proof (chain)\npicking this:\n  A \\<notin> rename_interpretation Sel I\n  L = Pos A\n  rename_literal Sel L = complement L", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<notin> rename_interpretation Sel I\n  L = Pos A\n  rename_literal Sel L = complement L\n\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "by auto"], ["proof (state)\nthis:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "assume \"L \\<noteq> Pos A\""], ["proof (state)\nthis:\n  L \\<noteq> Pos A\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>L = Pos A \\<or> L = Neg A\\<close>"], ["proof (chain)\npicking this:\n  L \\<noteq> Pos A\n  L = Pos A \\<or> L = Neg A", "have \"L = Neg A\""], ["proof (prove)\nusing this:\n  L \\<noteq> Pos A\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. L = Neg A", "by auto"], ["proof (state)\nthis:\n  L = Neg A\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>validate_literal I L\\<close>"], ["proof (chain)\npicking this:\n  L = Neg A\n  I \\<Turnstile> L", "have \"A \\<notin> I\""], ["proof (prove)\nusing this:\n  L = Neg A\n  I \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. A \\<notin> I", "by auto"], ["proof (state)\nthis:\n  A \\<notin> I\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>A \\<in> Sel\\<close>"], ["proof (chain)\npicking this:\n  A \\<notin> I\n  A \\<in> Sel", "have \"A \\<in> ?J\""], ["proof (prove)\nusing this:\n  A \\<notin> I\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. A \\<in> rename_interpretation Sel I", "unfolding rename_interpretation_def"], ["proof (prove)\nusing this:\n  A \\<notin> I\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. A \\<in> {A \\<in> I. A \\<notin> Sel} \\<union>\n            {A. A \\<notin> I \\<and> A \\<in> Sel}", "by blast"], ["proof (state)\nthis:\n  A \\<in> rename_interpretation Sel I\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>L = Neg A\\<close> and \\<open>rename_literal Sel L = complement L\\<close>"], ["proof (chain)\npicking this:\n  A \\<in> rename_interpretation Sel I\n  L = Neg A\n  rename_literal Sel L = complement L", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<in> rename_interpretation Sel I\n  L = Neg A\n  rename_literal Sel L = complement L\n\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "by auto"], ["proof (state)\nthis:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "assume \"A \\<notin> Sel\""], ["proof (state)\nthis:\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>atom L = A\\<close>"], ["proof (chain)\npicking this:\n  A \\<notin> Sel\n  atom L = A", "have \"rename_literal Sel L = L\""], ["proof (prove)\nusing this:\n  A \\<notin> Sel\n  atom L = A\n\ngoal (1 subgoal):\n 1. rename_literal Sel L = L", "unfolding rename_literal_def"], ["proof (prove)\nusing this:\n  A \\<notin> Sel\n  atom L = A\n\ngoal (1 subgoal):\n 1. (if atom L \\<in> Sel then complement L else L) = L", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel L = L\n\ngoal (1 subgoal):\n 1. A \\<notin> Sel \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "assume \"L = Pos A\""], ["proof (state)\nthis:\n  L = Pos A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>validate_literal I L\\<close>"], ["proof (chain)\npicking this:\n  L = Pos A\n  I \\<Turnstile> L", "have \"A \\<in> I\""], ["proof (prove)\nusing this:\n  L = Pos A\n  I \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. A \\<in> I", "by auto"], ["proof (state)\nthis:\n  A \\<in> I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>A \\<notin> Sel\\<close>"], ["proof (chain)\npicking this:\n  A \\<in> I\n  A \\<notin> Sel", "have \"A \\<in> ?J\""], ["proof (prove)\nusing this:\n  A \\<in> I\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. A \\<in> rename_interpretation Sel I", "unfolding rename_interpretation_def"], ["proof (prove)\nusing this:\n  A \\<in> I\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. A \\<in> {A \\<in> I. A \\<notin> Sel} \\<union>\n            {A. A \\<notin> I \\<and> A \\<in> Sel}", "by blast"], ["proof (state)\nthis:\n  A \\<in> rename_interpretation Sel I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n 2. \\<not> ?P \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>L = Pos A\\<close> and \\<open>rename_literal Sel L = L\\<close>"], ["proof (chain)\npicking this:\n  A \\<in> rename_interpretation Sel I\n  L = Pos A\n  rename_literal Sel L = L", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<in> rename_interpretation Sel I\n  L = Pos A\n  rename_literal Sel L = L\n\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "by auto"], ["proof (state)\nthis:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "assume \"L \\<noteq> Pos A\""], ["proof (state)\nthis:\n  L \\<noteq> Pos A\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>L = Pos A \\<or> L = Neg A\\<close>"], ["proof (chain)\npicking this:\n  L \\<noteq> Pos A\n  L = Pos A \\<or> L = Neg A", "have \"L = Neg A\""], ["proof (prove)\nusing this:\n  L \\<noteq> Pos A\n  L = Pos A \\<or> L = Neg A\n\ngoal (1 subgoal):\n 1. L = Neg A", "by auto"], ["proof (state)\nthis:\n  L = Neg A\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>validate_literal I L\\<close>"], ["proof (chain)\npicking this:\n  L = Neg A\n  I \\<Turnstile> L", "have \"A \\<notin> I\""], ["proof (prove)\nusing this:\n  L = Neg A\n  I \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. A \\<notin> I", "by auto"], ["proof (state)\nthis:\n  A \\<notin> I\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>A \\<notin> Sel\\<close>"], ["proof (chain)\npicking this:\n  A \\<notin> I\n  A \\<notin> Sel", "have \"A \\<notin> ?J\""], ["proof (prove)\nusing this:\n  A \\<notin> I\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. A \\<notin> rename_interpretation Sel I", "unfolding rename_interpretation_def"], ["proof (prove)\nusing this:\n  A \\<notin> I\n  A \\<notin> Sel\n\ngoal (1 subgoal):\n 1. A \\<notin> {A \\<in> I. A \\<notin> Sel} \\<union>\n               {A. A \\<notin> I \\<and> A \\<in> Sel}", "by blast"], ["proof (state)\nthis:\n  A \\<notin> rename_interpretation Sel I\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos A \\<Longrightarrow>\n    rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "from this and \\<open>L = Neg A\\<close> and \\<open>rename_literal Sel L = L\\<close>"], ["proof (chain)\npicking this:\n  A \\<notin> rename_interpretation Sel I\n  L = Neg A\n  rename_literal Sel L = L", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<notin> rename_interpretation Sel I\n  L = Neg A\n  rename_literal Sel L = L\n\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "by auto"], ["proof (state)\nthis:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma renaming_preserves_satisfiability:\n  assumes \"satisfiable S\"\n  shows \"satisfiable (rename_formula Sel S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel S)", "from assms"], ["proof (chain)\npicking this:\n  satisfiable S", "obtain I where \"validate_formula I S\""], ["proof (prove)\nusing this:\n  satisfiable S\n\ngoal (1 subgoal):\n 1. (\\<And>I. I \\<Turnstile> S \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<exists>I. I \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. (\\<And>I. I \\<Turnstile> S \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  I \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel S)", "let ?J = \"rename_interpretation Sel I\""], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel S)", "have \"validate_formula ?J (rename_formula Sel S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_formula Sel S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rename_interpretation Sel I \\<Turnstile>\n           rename_formula Sel S \\<Longrightarrow>\n    False", "assume \"\\<not>validate_formula ?J (rename_formula Sel S)\""], ["proof (state)\nthis:\n  \\<not> rename_interpretation Sel I \\<Turnstile> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. \\<not> rename_interpretation Sel I \\<Turnstile>\n           rename_formula Sel S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> rename_interpretation Sel I \\<Turnstile> rename_formula Sel S", "obtain C where \"C \\<in> S\" and \"\\<not>(validate_clause ?J (rename_clause Sel C))\""], ["proof (prove)\nusing this:\n  \\<not> rename_interpretation Sel I \\<Turnstile> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> S;\n         \\<not> rename_interpretation Sel I \\<Turnstile>\n                rename_clause Sel C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rename_formula_def"], ["proof (prove)\nusing this:\n  \\<not> rename_interpretation Sel I \\<Turnstile>\n         {C. \\<exists>CC. CC \\<in> S \\<and> C = rename_clause Sel CC}\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> S;\n         \\<not> rename_interpretation Sel I \\<Turnstile>\n                rename_clause Sel C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> S\n  \\<not> rename_interpretation Sel I \\<Turnstile> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. \\<not> rename_interpretation Sel I \\<Turnstile>\n           rename_formula Sel S \\<Longrightarrow>\n    False", "from \\<open>C \\<in> S\\<close> and \\<open>validate_formula I S\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> S\n  I \\<Turnstile> S", "obtain L where \"L \\<in> C\" \n      and \"validate_literal I L\""], ["proof (prove)\nusing this:\n  C \\<in> S\n  I \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> C; I \\<Turnstile> L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> C\n  I \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. \\<not> rename_interpretation Sel I \\<Turnstile>\n           rename_formula Sel S \\<Longrightarrow>\n    False", "from \\<open>validate_literal I L\\<close>"], ["proof (chain)\npicking this:\n  I \\<Turnstile> L", "have \"validate_literal ?J (rename_literal Sel L)\""], ["proof (prove)\nusing this:\n  I \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "using renaming_preserves_semantic"], ["proof (prove)\nusing this:\n  I \\<Turnstile> L\n  ?I \\<Turnstile> ?L \\<Longrightarrow>\n  rename_interpretation ?Sel ?I \\<Turnstile> rename_literal ?Sel ?L\n\ngoal (1 subgoal):\n 1. rename_interpretation Sel I \\<Turnstile> rename_literal Sel L", "by auto"], ["proof (state)\nthis:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n\ngoal (1 subgoal):\n 1. \\<not> rename_interpretation Sel I \\<Turnstile>\n           rename_formula Sel S \\<Longrightarrow>\n    False", "from this and \\<open>L \\<in> C\\<close> and \\<open>\\<not>validate_clause ?J (rename_clause Sel C)\\<close>"], ["proof (chain)\npicking this:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n  L \\<in> C\n  \\<not> rename_interpretation Sel I \\<Turnstile> rename_clause Sel C", "show \"False\""], ["proof (prove)\nusing this:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n  L \\<in> C\n  \\<not> rename_interpretation Sel I \\<Turnstile> rename_clause Sel C\n\ngoal (1 subgoal):\n 1. False", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  rename_interpretation Sel I \\<Turnstile> rename_literal Sel L\n  L \\<in> C\n  \\<not> rename_interpretation Sel I \\<Turnstile>\n         {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal Sel LL}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rename_interpretation Sel I \\<Turnstile> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel S)", "from this"], ["proof (chain)\npicking this:\n  rename_interpretation Sel I \\<Turnstile> rename_formula Sel S", "show ?thesis"], ["proof (prove)\nusing this:\n  rename_interpretation Sel I \\<Turnstile> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel S)", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  rename_interpretation Sel I \\<Turnstile> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. \\<exists>I. I \\<Turnstile> rename_formula Sel S", "by auto"], ["proof (state)\nthis:\n  satisfiable (rename_formula Sel S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma renaming_preserves_subsumption:\n  assumes \"subsumes C D\"\n  shows \"subsumes (rename_clause Sel C) (rename_clause Sel D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes (rename_clause Sel C) (rename_clause Sel D)", "using assms"], ["proof (prove)\nusing this:\n  subsumes C D\n\ngoal (1 subgoal):\n 1. subsumes (rename_clause Sel C) (rename_clause Sel D)", "unfolding subsumes_def rename_clause_def"], ["proof (prove)\nusing this:\n  C \\<subseteq> D\n\ngoal (1 subgoal):\n 1. {L. \\<exists>LL. LL \\<in> C \\<and> L = rename_literal Sel LL}\n    \\<subseteq> {L. \\<exists>LL.\n                       LL \\<in> D \\<and> L = rename_literal Sel LL}", "by auto"], ["", "section \\<open>Soundness\\<close>"], ["", "text \\<open>In this section we prove that all the rules introduced in the previous section are sound. \nWe first introduce an abstract notion of soundness.\\<close>"], ["", "definition Sound :: \"'at BinaryRule \\<Rightarrow> bool\"\nwhere \n  \"(Sound Rule) \\<equiv> \\<forall>I P1 P2 C. (Rule P1 P2 C \\<longrightarrow> (validate_clause I P1) \\<longrightarrow> (validate_clause I P2) \n    \\<longrightarrow> (validate_clause I C))\""], ["", "lemma soundness_and_entailment :\n  assumes \"Sound Rule\"\n  assumes \"Rule P1 P2 C\"\n  assumes \"P1 \\<in> S\"\n  assumes \"P2 \\<in> S\"\n  shows \"entails S C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails S C", "using Sound_def assms entails_def"], ["proof (prove)\nusing this:\n  Sound ?Rule \\<equiv>\n  \\<forall>I P1 P2 C.\n     ?Rule P1 P2 C \\<longrightarrow>\n     I \\<Turnstile> P1 \\<longrightarrow>\n     I \\<Turnstile> P2 \\<longrightarrow> I \\<Turnstile> C\n  Sound Rule\n  Rule P1 P2 C\n  P1 \\<in> S\n  P2 \\<in> S\n  entails ?S ?C \\<equiv>\n  \\<forall>I. I \\<Turnstile> ?S \\<longrightarrow> I \\<Turnstile> ?C\n\ngoal (1 subgoal):\n 1. entails S C", "by auto"], ["", "lemma all_deducible_sound:\n  assumes \"Sound R\"\n  shows \"entails_formula S (all_deducible_clauses R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula S (all_deducible_clauses R S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "assume \"\\<not>entails_formula S (all_deducible_clauses R S)\""], ["proof (state)\nthis:\n  \\<not> entails_formula S (all_deducible_clauses R S)\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> entails_formula S (all_deducible_clauses R S)", "obtain C where \"C \\<in> all_deducible_clauses R S\" and \"\\<not> entails S C\""], ["proof (prove)\nusing this:\n  \\<not> entails_formula S (all_deducible_clauses R S)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> all_deducible_clauses R S;\n         \\<not> entails S C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding entails_formula_def"], ["proof (prove)\nusing this:\n  \\<not> Ball (all_deducible_clauses R S) (entails S)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> all_deducible_clauses R S;\n         \\<not> entails S C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> all_deducible_clauses R S\n  \\<not> entails S C\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> all_deducible_clauses R S\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> all_deducible_clauses R S", "obtain P1 P2 where \"R P1 P2 C\" and \"P1 \\<in> S\" and \"P2 \\<in> S\""], ["proof (prove)\nusing this:\n  C \\<in> all_deducible_clauses R S\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>R P1 P2 C; P1 \\<in> S; P2 \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R P1 P2 C\n  P1 \\<in> S\n  P2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "from \\<open>R P1 P2 C\\<close>and assms(1) and \\<open>P1 \\<in> S\\<close> and \\<open>P2 \\<in> S\\<close> and \\<open>\\<not> entails S C\\<close>"], ["proof (chain)\npicking this:\n  R P1 P2 C\n  Sound R\n  P1 \\<in> S\n  P2 \\<in> S\n  \\<not> entails S C", "show \"False\""], ["proof (prove)\nusing this:\n  R P1 P2 C\n  Sound R\n  P1 \\<in> S\n  P2 \\<in> S\n  \\<not> entails S C\n\ngoal (1 subgoal):\n 1. False", "using soundness_and_entailment"], ["proof (prove)\nusing this:\n  R P1 P2 C\n  Sound R\n  P1 \\<in> S\n  P2 \\<in> S\n  \\<not> entails S C\n  \\<lbrakk>Sound ?Rule; ?Rule ?P1.0 ?P2.0 ?C; ?P1.0 \\<in> ?S;\n   ?P2.0 \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> entails ?S ?C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_all_deducible_sound:\n  assumes \"Sound R\"\n  shows \"entails_formula S (add_all_deducible_clauses R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula S (add_all_deducible_clauses R S)", "by (metis UnE add_all_deducible_clauses.simps all_deducible_sound assms \n      entails_formula_def entails_member)"], ["", "text \\<open>If a rule is more restrictive than a sound rule then it is necessarily sound.\\<close>"], ["", "lemma less_restrictive_correct:\n  assumes \"less_restrictive R1 R2\"\n  assumes \"Sound R1\"\n  shows \"Sound R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sound R2", "using assms"], ["proof (prove)\nusing this:\n  less_restrictive R1 R2\n  Sound R1\n\ngoal (1 subgoal):\n 1. Sound R2", "unfolding less_restrictive_def Sound_def"], ["proof (prove)\nusing this:\n  \\<forall>P1 P2 C. R2 P1 P2 C \\<longrightarrow> R1 P1 P2 C \\<or> R1 P2 P1 C\n  \\<forall>I P1 P2 C.\n     R1 P1 P2 C \\<longrightarrow>\n     I \\<Turnstile> P1 \\<longrightarrow>\n     I \\<Turnstile> P2 \\<longrightarrow> I \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<forall>I P1 P2 C.\n       R2 P1 P2 C \\<longrightarrow>\n       I \\<Turnstile> P1 \\<longrightarrow>\n       I \\<Turnstile> P2 \\<longrightarrow> I \\<Turnstile> C", "by blast"], ["", "text \\<open>We finally establish usual concrete soundness results.\\<close>"], ["", "theorem resolution_is_correct: \n  \"(Sound resolvent)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sound resolvent", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Sound resolvent \\<Longrightarrow> False", "assume \"\\<not> (Sound resolvent)\""], ["proof (state)\nthis:\n  \\<not> Sound resolvent\n\ngoal (1 subgoal):\n 1. \\<not> Sound resolvent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Sound resolvent", "obtain I P1 P2 C where  \n    \"resolvent P1 P2 C\" \"validate_clause I P1\" \"validate_clause I P2\" and \"\\<not>validate_clause I C\""], ["proof (prove)\nusing this:\n  \\<not> Sound resolvent\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C I.\n        \\<lbrakk>resolvent P1 P2 C; I \\<Turnstile> P1; I \\<Turnstile> P2;\n         \\<not> I \\<Turnstile> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding  Sound_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>I P1 P2 C.\n             resolvent P1 P2 C \\<longrightarrow>\n             I \\<Turnstile> P1 \\<longrightarrow>\n             I \\<Turnstile> P2 \\<longrightarrow> I \\<Turnstile> C)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C I.\n        \\<lbrakk>resolvent P1 P2 C; I \\<Turnstile> P1; I \\<Turnstile> P2;\n         \\<not> I \\<Turnstile> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  resolvent P1 P2 C\n  I \\<Turnstile> P1\n  I \\<Turnstile> P2\n  \\<not> I \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> Sound resolvent \\<Longrightarrow> False", "from \\<open>resolvent P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  resolvent P1 P2 C", "obtain A where\n      \"(Pos A) \\<in> P1\" and \"(Neg A) \\<in> P2\" and \"C = ( (P1 - { Pos A}) \\<union> (P2 - { Neg A }))\""], ["proof (prove)\nusing this:\n  resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>Pos A \\<in> P1; Neg A \\<in> P2;\n         C = P1 - {Pos A} \\<union> (P2 - {Neg A})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     Pos A \\<in> P1 \\<and>\n     Neg A \\<in> P2 \\<and> C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>Pos A \\<in> P1; Neg A \\<in> P2;\n         C = P1 - {Pos A} \\<union> (P2 - {Neg A})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Pos A \\<in> P1\n  Neg A \\<in> P2\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. \\<not> Sound resolvent \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"A \\<in> I\""], ["proof (state)\nthis:\n  A \\<in> I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "hence \"\\<not>validate_literal I (Neg A)\""], ["proof (prove)\nusing this:\n  A \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile> Neg A", "by auto"], ["proof (state)\nthis:\n  \\<not> I \\<Turnstile> Neg A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from \\<open>\\<not>validate_literal I (Neg A)\\<close> and \\<open>validate_clause I P2\\<close>"], ["proof (chain)\npicking this:\n  \\<not> I \\<Turnstile> Neg A\n  I \\<Turnstile> P2", "have \"validate_clause I (P2 - { Neg A })\""], ["proof (prove)\nusing this:\n  \\<not> I \\<Turnstile> Neg A\n  I \\<Turnstile> P2\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> (P2 - {Neg A})", "by auto"], ["proof (state)\nthis:\n  I \\<Turnstile> (P2 - {Neg A})\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from \\<open>validate_clause I (P2 - { Neg A })\\<close> and \\<open>C = ( (P1 - { Pos A}) \\<union> (P2 - { Neg A }))\\<close> \n          and \\<open>\\<not>validate_clause I C\\<close>"], ["proof (chain)\npicking this:\n  I \\<Turnstile> (P2 - {Neg A})\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  \\<not> I \\<Turnstile> C", "show \"False\""], ["proof (prove)\nusing this:\n  I \\<Turnstile> (P2 - {Neg A})\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  \\<not> I \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. A \\<notin> I \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> I \\<Longrightarrow> False", "assume \"A \\<notin> I\""], ["proof (state)\nthis:\n  A \\<notin> I\n\ngoal (1 subgoal):\n 1. A \\<notin> I \\<Longrightarrow> False", "hence \"\\<not>validate_literal I (Pos A)\""], ["proof (prove)\nusing this:\n  A \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile> Pos A", "by auto"], ["proof (state)\nthis:\n  \\<not> I \\<Turnstile> Pos A\n\ngoal (1 subgoal):\n 1. A \\<notin> I \\<Longrightarrow> False", "from \\<open>\\<not>validate_literal I (Pos A)\\<close> and \\<open>validate_clause I P1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> I \\<Turnstile> Pos A\n  I \\<Turnstile> P1", "have \"validate_clause I (P1 - { Pos A })\""], ["proof (prove)\nusing this:\n  \\<not> I \\<Turnstile> Pos A\n  I \\<Turnstile> P1\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> (P1 - {Pos A})", "by auto"], ["proof (state)\nthis:\n  I \\<Turnstile> (P1 - {Pos A})\n\ngoal (1 subgoal):\n 1. A \\<notin> I \\<Longrightarrow> False", "from \\<open>validate_clause I (P1 - { Pos A })\\<close> and \\<open>C = ( (P1 - { Pos A}) \\<union> (P2 - { Neg A }))\\<close> \n          and \\<open>\\<not>validate_clause I C\\<close>"], ["proof (chain)\npicking this:\n  I \\<Turnstile> (P1 - {Pos A})\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  \\<not> I \\<Turnstile> C", "show \"False\""], ["proof (prove)\nusing this:\n  I \\<Turnstile> (P1 - {Pos A})\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  \\<not> I \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ordered_resolution_correct : \"Sound ordered_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sound ordered_resolvent", "using resolution_is_correct and ordered_resolvent_is_resolvent  less_restrictive_correct"], ["proof (prove)\nusing this:\n  Sound resolvent\n  less_restrictive resolvent ordered_resolvent\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0; Sound ?R1.0\\<rbrakk>\n  \\<Longrightarrow> Sound ?R2.0\n\ngoal (1 subgoal):\n 1. Sound ordered_resolvent", "by auto"], ["", "theorem ordered_model_resolution_correct : \"Sound (ordered_model_resolvent I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sound (ordered_model_resolvent I)", "using resolution_is_correct ordered_model_resolvent_is_resolvent less_restrictive_correct"], ["proof (prove)\nusing this:\n  Sound resolvent\n  less_restrictive resolvent (ordered_model_resolvent ?I)\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0; Sound ?R1.0\\<rbrakk>\n  \\<Longrightarrow> Sound ?R2.0\n\ngoal (1 subgoal):\n 1. Sound (ordered_model_resolvent I)", "by auto"], ["", "theorem ordered_positive_resolution_correct : \"Sound ordered_positive_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sound ordered_positive_resolvent", "using less_restrictive_correct positive_resolvent_is_resolvent resolution_is_correct"], ["proof (prove)\nusing this:\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0; Sound ?R1.0\\<rbrakk>\n  \\<Longrightarrow> Sound ?R2.0\n  less_restrictive resolvent ordered_positive_resolvent\n  Sound resolvent\n\ngoal (1 subgoal):\n 1. Sound ordered_positive_resolvent", "by auto"], ["", "theorem ordered_negative_resolution_correct : \"Sound ordered_negative_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sound ordered_negative_resolvent", "using less_restrictive_correct negative_resolvent_is_resolvent resolution_is_correct"], ["proof (prove)\nusing this:\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0; Sound ?R1.0\\<rbrakk>\n  \\<Longrightarrow> Sound ?R2.0\n  less_restrictive resolvent ordered_negative_resolvent\n  Sound resolvent\n\ngoal (1 subgoal):\n 1. Sound ordered_negative_resolvent", "by auto"], ["", "theorem unit_resolvent_correct : \"Sound unit_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sound unit_resolvent", "using less_restrictive_correct resolution_is_correct unit_resolvent_is_resolvent"], ["proof (prove)\nusing this:\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0; Sound ?R1.0\\<rbrakk>\n  \\<Longrightarrow> Sound ?R2.0\n  Sound resolvent\n  less_restrictive resolvent unit_resolvent\n\ngoal (1 subgoal):\n 1. Sound unit_resolvent", "by auto"], ["", "section \\<open>Refutational Completeness\\<close>"], ["", "text \\<open>In this section we establish the refutational completeness of the previous inference \nrules (under adequate restrictions for the unit resolution rule). Completeness is proven\nw.r.t.\\ redundancy elimination rules, i.e., we show that every saturated unsatisfiable clause set\ncontains the empty clause.\\<close>"], ["", "text \\<open>We first introduce an abstract notion of saturation.\\<close>"], ["", "definition saturated_binary_rule :: \"'a BinaryRule \\<Rightarrow> 'a Formula \\<Rightarrow> bool\"\nwhere\n  \"(saturated_binary_rule Rule S) \\<equiv> (\\<forall> P1 P2 C. (((P1 \\<in> S) \\<and> (P2 \\<in> S) \\<and> (Rule P1 P2 C)))\n    \\<longrightarrow> redundant C S)\""], ["", "definition Complete :: \"'at BinaryRule \\<Rightarrow> bool\"\nwhere \n  \"(Complete Rule) = (\\<forall>S. ((saturated_binary_rule Rule S) \\<longrightarrow> (all_fulfill finite S) \n    \\<longrightarrow> ({} \\<notin> S) \\<longrightarrow> satisfiable S))\""], ["", "text \\<open>If a set of clauses is saturated under some rule then it is necessarily saturated \nunder more restrictive rules, which entails that if a rule is less restrictive than a complete rule \nthen it is also complete.\\<close>"], ["", "lemma less_restrictive_saturated:\n  assumes \"less_restrictive R1 R2\"\n  assumes \"saturated_binary_rule R1 S\"\n  shows \"saturated_binary_rule R2 S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_binary_rule R2 S", "using assms"], ["proof (prove)\nusing this:\n  less_restrictive R1 R2\n  saturated_binary_rule R1 S\n\ngoal (1 subgoal):\n 1. saturated_binary_rule R2 S", "unfolding less_restrictive_def Complete_def saturated_binary_rule_def"], ["proof (prove)\nusing this:\n  \\<forall>P1 P2 C. R2 P1 P2 C \\<longrightarrow> R1 P1 P2 C \\<or> R1 P2 P1 C\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> R1 P1 P2 C \\<longrightarrow>\n     redundant C S\n\ngoal (1 subgoal):\n 1. \\<forall>P1 P2 C.\n       P1 \\<in> S \\<and> P2 \\<in> S \\<and> R2 P1 P2 C \\<longrightarrow>\n       redundant C S", "by blast"], ["", "lemma less_restrictive_complete:\n  assumes \"less_restrictive R1 R2\"\n  assumes \"Complete R2\"\n  shows \"Complete R1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete R1", "using assms less_restrictive_saturated Complete_def"], ["proof (prove)\nusing this:\n  less_restrictive R1 R2\n  Complete R2\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0;\n   saturated_binary_rule ?R1.0 ?S\\<rbrakk>\n  \\<Longrightarrow> saturated_binary_rule ?R2.0 ?S\n  Complete ?Rule =\n  (\\<forall>S.\n      saturated_binary_rule ?Rule S \\<longrightarrow>\n      all_fulfill finite S \\<longrightarrow>\n      {} \\<notin> S \\<longrightarrow> satisfiable S)\n\ngoal (1 subgoal):\n 1. Complete R1", "by auto"], ["", "subsection \\<open>Ordered Resolution\\<close>"], ["", "text \\<open>We define a function associating every set of clauses @{ term S } with a ``canonic'' \ninterpretation constructed from @{ term S }.\nIf @{ term S } is saturated under ordered resolution and does not contain the empty clause\nthen the interpretation is a model of @{ term S }. The interpretation is defined by mean\nof an auxiliary function that maps every atom to a function indicating whether the\natom occurs in the interpretation corresponding to a given clause set.\nThe auxiliary function is defined by induction on the set of atoms.\n\\<close>"], ["", "function canonic_int_fun_ordered :: \"'at \\<Rightarrow> ('at Formula \\<Rightarrow> bool)\"\nwhere\n  \"(canonic_int_fun_ordered A) = \n      (\\<lambda>S. (\\<exists> C. (C \\<in> S) \\<and> (strictly_maximal_literal C (Pos A) ) \n      \\<and> ( \\<forall> B. ( Pos B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \\<longrightarrow> (\\<not>(canonic_int_fun_ordered B) S)))\n      \\<and> ( \\<forall> B. ( Neg B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \\<longrightarrow> ((canonic_int_fun_ordered B) S)))))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>A. x = A \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>A Aa.\n       A = Aa \\<Longrightarrow>\n       (\\<lambda>S.\n           \\<exists>C.\n              C \\<in> S \\<and>\n              strictly_maximal_literal C (Pos A) \\<and>\n              (\\<forall>B.\n                  Pos B \\<in> C \\<longrightarrow>\n                  (B, A) \\<in> atom_ordering \\<longrightarrow>\n                  \\<not> canonic_int_fun_ordered_sumC B S) \\<and>\n              (\\<forall>B.\n                  Neg B \\<in> C \\<longrightarrow>\n                  (B, A) \\<in> atom_ordering \\<longrightarrow>\n                  canonic_int_fun_ordered_sumC B S)) =\n       (\\<lambda>S.\n           \\<exists>C.\n              C \\<in> S \\<and>\n              strictly_maximal_literal C (Pos Aa) \\<and>\n              (\\<forall>B.\n                  Pos B \\<in> C \\<longrightarrow>\n                  (B, Aa) \\<in> atom_ordering \\<longrightarrow>\n                  \\<not> canonic_int_fun_ordered_sumC B S) \\<and>\n              (\\<forall>B.\n                  Neg B \\<in> C \\<longrightarrow>\n                  (B, Aa) \\<in> atom_ordering \\<longrightarrow>\n                  canonic_int_fun_ordered_sumC B S))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All canonic_int_fun_ordered_dom", "apply (relation \"atom_ordering\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf atom_ordering\n 2. \\<And>A x xa xb.\n       \\<lbrakk>Pos xb \\<in> xa; (xb, A) \\<in> atom_ordering\\<rbrakk>\n       \\<Longrightarrow> (xb, A) \\<in> atom_ordering\n 3. \\<And>A x xa xb.\n       \\<lbrakk>Neg xb \\<in> xa; (xb, A) \\<in> atom_ordering\\<rbrakk>\n       \\<Longrightarrow> (xb, A) \\<in> atom_ordering", "by auto (simp add: atom_ordering_wf)"], ["", "definition canonic_int_ordered :: \"'at Formula \\<Rightarrow> 'at Interpretation\"\nwhere\n  \"(canonic_int_ordered S) = { A. ((canonic_int_fun_ordered A) S) }\""], ["", "text \\<open>We first prove that the canonic interpretation validates every clause \nhaving a positive strictly maximal literal\\<close>"], ["", "lemma int_validate_cl_with_pos_max : \n  assumes \"strictly_maximal_literal C (Pos A)\"\n  assumes \"C \\<in> S\"\n  shows \"validate_clause (canonic_int_ordered S) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "assume c1: \"(\\<forall> B. ( Pos B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \n                  \\<longrightarrow> (\\<not>(canonic_int_fun_ordered B) S)))\""], ["proof (state)\nthis:\n  \\<forall>B.\n     Pos B \\<in> C \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     \\<not> canonic_int_fun_ordered B S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "assume c2: \"( \\<forall> B. ( Neg B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \n                    \\<longrightarrow> ((canonic_int_fun_ordered B) S)))\""], ["proof (state)\nthis:\n  \\<forall>B.\n     Neg B \\<in> C \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     canonic_int_fun_ordered B S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "have \"((canonic_int_fun_ordered A) S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_fun_ordered A S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> canonic_int_fun_ordered A S \\<Longrightarrow> False", "assume \"\\<not> ((canonic_int_fun_ordered A) S)\""], ["proof (state)\nthis:\n  \\<not> canonic_int_fun_ordered A S\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_fun_ordered A S \\<Longrightarrow> False", "from \\<open>\\<not> ((canonic_int_fun_ordered A) S)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_fun_ordered A S", "have e: \"\\<not> (\\<exists> C. (C \\<in> S) \\<and> (strictly_maximal_literal C (Pos A) ) \n      \\<and> ( \\<forall> B. ( Pos B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \\<longrightarrow> (\\<not>(canonic_int_fun_ordered B) S)))\n      \\<and> ( \\<forall> B. ( Neg B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \\<longrightarrow> ((canonic_int_fun_ordered B) S))))\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_fun_ordered A S\n\ngoal (1 subgoal):\n 1. \\<nexists>C.\n       C \\<in> S \\<and>\n       strictly_maximal_literal C (Pos A) \\<and>\n       (\\<forall>B.\n           Pos B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           \\<not> canonic_int_fun_ordered B S) \\<and>\n       (\\<forall>B.\n           Neg B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           canonic_int_fun_ordered B S)", "by ((simp only:canonic_int_fun_ordered.simps[of A]), blast)"], ["proof (state)\nthis:\n  \\<nexists>C.\n     C \\<in> S \\<and>\n     strictly_maximal_literal C (Pos A) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B S) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B S)\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_fun_ordered A S \\<Longrightarrow> False", "from e and c1 and c2 and \\<open>(C \\<in> S)\\<close>and \\<open>(strictly_maximal_literal C (Pos A))\\<close>"], ["proof (chain)\npicking this:\n  \\<nexists>C.\n     C \\<in> S \\<and>\n     strictly_maximal_literal C (Pos A) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B S) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B S)\n  \\<forall>B.\n     Pos B \\<in> C \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     \\<not> canonic_int_fun_ordered B S\n  \\<forall>B.\n     Neg B \\<in> C \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     canonic_int_fun_ordered B S\n  C \\<in> S\n  strictly_maximal_literal C (Pos A)", "show \"False\""], ["proof (prove)\nusing this:\n  \\<nexists>C.\n     C \\<in> S \\<and>\n     strictly_maximal_literal C (Pos A) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B S) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B S)\n  \\<forall>B.\n     Pos B \\<in> C \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     \\<not> canonic_int_fun_ordered B S\n  \\<forall>B.\n     Neg B \\<in> C \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     canonic_int_fun_ordered B S\n  C \\<in> S\n  strictly_maximal_literal C (Pos A)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canonic_int_fun_ordered A S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "from \\<open>((canonic_int_fun_ordered A) S)\\<close>"], ["proof (chain)\npicking this:\n  canonic_int_fun_ordered A S", "have \"A \\<in> (canonic_int_ordered S)\""], ["proof (prove)\nusing this:\n  canonic_int_fun_ordered A S\n\ngoal (1 subgoal):\n 1. A \\<in> canonic_int_ordered S", "unfolding canonic_int_ordered_def"], ["proof (prove)\nusing this:\n  canonic_int_fun_ordered A S\n\ngoal (1 subgoal):\n 1. A \\<in> {A. canonic_int_fun_ordered A S}", "by blast"], ["proof (state)\nthis:\n  A \\<in> canonic_int_ordered S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "from \\<open>A \\<in> (canonic_int_ordered S)\\<close> and \\<open>(strictly_maximal_literal C (Pos A))\\<close>"], ["proof (chain)\npicking this:\n  A \\<in> canonic_int_ordered S\n  strictly_maximal_literal C (Pos A)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  A \\<in> canonic_int_ordered S\n  strictly_maximal_literal C (Pos A)\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  A \\<in> canonic_int_ordered S\n  Pos A \\<in> C \\<and>\n  (\\<forall>B.\n      B \\<in> C \\<and> Pos A \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos A))\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Neg B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Neg B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "assume not_c2: \"\\<not>( \\<forall> B. ( Neg B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \n                        \\<longrightarrow> ((canonic_int_fun_ordered B) S)))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>B.\n             Neg B \\<in> C \\<longrightarrow>\n             (B, A) \\<in> atom_ordering \\<longrightarrow>\n             canonic_int_fun_ordered B S)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Neg B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "from not_c2"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>B.\n             Neg B \\<in> C \\<longrightarrow>\n             (B, A) \\<in> atom_ordering \\<longrightarrow>\n             canonic_int_fun_ordered B S)", "obtain B where \"Neg B \\<in> C\" and \"\\<not>((canonic_int_fun_ordered B) S)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>B.\n             Neg B \\<in> C \\<longrightarrow>\n             (B, A) \\<in> atom_ordering \\<longrightarrow>\n             canonic_int_fun_ordered B S)\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>Neg B \\<in> C; \\<not> canonic_int_fun_ordered B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Neg B \\<in> C\n  \\<not> canonic_int_fun_ordered B S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Neg B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "from \\<open>\\<not> ((canonic_int_fun_ordered B) S)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_fun_ordered B S", "have \"B \\<notin> (canonic_int_ordered S)\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_fun_ordered B S\n\ngoal (1 subgoal):\n 1. B \\<notin> canonic_int_ordered S", "unfolding canonic_int_ordered_def"], ["proof (prove)\nusing this:\n  \\<not> canonic_int_fun_ordered B S\n\ngoal (1 subgoal):\n 1. B \\<notin> {A. canonic_int_fun_ordered A S}", "by blast"], ["proof (state)\nthis:\n  B \\<notin> canonic_int_ordered S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Neg B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "with \\<open>Neg B \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  Neg B \\<in> C\n  B \\<notin> canonic_int_ordered S", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Neg B \\<in> C\n  B \\<notin> canonic_int_ordered S\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Pos B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               \\<not> canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Pos B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               \\<not> canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "assume not_c1: \"\\<not>(\\<forall> B. ( Pos B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \n                      \\<longrightarrow> (\\<not>(canonic_int_fun_ordered B) S)))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>B.\n             Pos B \\<in> C \\<longrightarrow>\n             (B, A) \\<in> atom_ordering \\<longrightarrow>\n             \\<not> canonic_int_fun_ordered B S)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Pos B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               \\<not> canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "from not_c1"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>B.\n             Pos B \\<in> C \\<longrightarrow>\n             (B, A) \\<in> atom_ordering \\<longrightarrow>\n             \\<not> canonic_int_fun_ordered B S)", "obtain B where \"Pos B \\<in> C\" and \"((canonic_int_fun_ordered B) S)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>B.\n             Pos B \\<in> C \\<longrightarrow>\n             (B, A) \\<in> atom_ordering \\<longrightarrow>\n             \\<not> canonic_int_fun_ordered B S)\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>Pos B \\<in> C; canonic_int_fun_ordered B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Pos B \\<in> C\n  canonic_int_fun_ordered B S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Pos B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               \\<not> canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "from \\<open>((canonic_int_fun_ordered B) S)\\<close>"], ["proof (chain)\npicking this:\n  canonic_int_fun_ordered B S", "have \"B \\<in> (canonic_int_ordered S)\""], ["proof (prove)\nusing this:\n  canonic_int_fun_ordered B S\n\ngoal (1 subgoal):\n 1. B \\<in> canonic_int_ordered S", "unfolding canonic_int_ordered_def"], ["proof (prove)\nusing this:\n  canonic_int_fun_ordered B S\n\ngoal (1 subgoal):\n 1. B \\<in> {A. canonic_int_fun_ordered A S}", "by blast"], ["proof (state)\nthis:\n  B \\<in> canonic_int_ordered S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B.\n               Pos B \\<in> C \\<longrightarrow>\n               (B, A) \\<in> atom_ordering \\<longrightarrow>\n               \\<not> canonic_int_fun_ordered B S) \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "with \\<open>Pos B \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  Pos B \\<in> C\n  B \\<in> canonic_int_ordered S", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Pos B \\<in> C\n  B \\<in> canonic_int_ordered S\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strictly_maximal_literal_exists : \n\n  \"\\<forall>C. (((finite C) \\<and> (card C) = n \\<and> n \\<noteq> 0 \\<and> (\\<not> (tautology C)))) \n    \\<longrightarrow> (\\<exists>A. (strictly_maximal_literal C A))\" (is \"?P n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       finite C \\<and>\n       card C = n \\<and>\n       n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n       (\\<exists>A. strictly_maximal_literal C A)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>C.\n       finite C \\<and>\n       card C = 0 \\<and>\n       0 \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n       (\\<exists>A. strictly_maximal_literal C A)\n 2. \\<And>n.\n       \\<forall>C.\n          finite C \\<and>\n          card C = n \\<and>\n          n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A) \\<Longrightarrow>\n       \\<forall>C.\n          finite C \\<and>\n          card C = Suc n \\<and>\n          Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A)", "show \"(?P 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       finite C \\<and>\n       card C = 0 \\<and>\n       0 \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n       (\\<exists>A. strictly_maximal_literal C A)", "by auto"], ["proof (state)\nthis:\n  \\<forall>C.\n     finite C \\<and>\n     card C = 0 \\<and>\n     0 \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n     (\\<exists>A. strictly_maximal_literal C A)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>C.\n          finite C \\<and>\n          card C = n \\<and>\n          n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A) \\<Longrightarrow>\n       \\<forall>C.\n          finite C \\<and>\n          card C = Suc n \\<and>\n          Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>C.\n          finite C \\<and>\n          card C = n \\<and>\n          n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A) \\<Longrightarrow>\n       \\<forall>C.\n          finite C \\<and>\n          card C = Suc n \\<and>\n          Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>C.\n          finite C \\<and>\n          card C = n \\<and>\n          n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A) \\<Longrightarrow>\n       \\<forall>C.\n          finite C \\<and>\n          card C = Suc n \\<and>\n          Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A)", "assume \"?P n\""], ["proof (state)\nthis:\n  \\<forall>C.\n     finite C \\<and>\n     card C = n \\<and>\n     n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n     (\\<exists>A. strictly_maximal_literal C A)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>C.\n          finite C \\<and>\n          card C = n \\<and>\n          n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A) \\<Longrightarrow>\n       \\<forall>C.\n          finite C \\<and>\n          card C = Suc n \\<and>\n          Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n          (\\<exists>A. strictly_maximal_literal C A)", "show \"?P (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       finite C \\<and>\n       card C = Suc n \\<and>\n       Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n       (\\<exists>A. strictly_maximal_literal C A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       finite C \\<and>\n       card C = Suc n \\<and>\n       Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n       (\\<exists>A. strictly_maximal_literal C A)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       finite C \\<and>\n       card C = Suc n \\<and>\n       Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n       (\\<exists>A. strictly_maximal_literal C A)", "show \"(finite C \\<and> card C = Suc n \\<and> Suc n \\<noteq> 0 \\<and> \\<not> (tautology C)) \n              \\<longrightarrow> (\\<exists>A. (strictly_maximal_literal C A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C \\<and>\n    card C = Suc n \\<and>\n    Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n    (\\<exists>A. strictly_maximal_literal C A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite C \\<and>\n    card C = Suc n \\<and>\n    Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "assume \"finite C \\<and> card C = Suc n \\<and> Suc n \\<noteq> 0 \\<and> \\<not>(tautology C)\""], ["proof (state)\nthis:\n  finite C \\<and>\n  card C = Suc n \\<and> Suc n \\<noteq> 0 \\<and> \\<not> tautology C\n\ngoal (1 subgoal):\n 1. finite C \\<and>\n    card C = Suc n \\<and>\n    Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "hence \"(finite C)\" and \"(card C) = (Suc n)\" and \"(\\<not> (tautology C))\""], ["proof (prove)\nusing this:\n  finite C \\<and>\n  card C = Suc n \\<and> Suc n \\<noteq> 0 \\<and> \\<not> tautology C\n\ngoal (1 subgoal):\n 1. finite C &&& card C = Suc n &&& \\<not> tautology C", "by auto"], ["proof (state)\nthis:\n  finite C\n  card C = Suc n\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. finite C \\<and>\n    card C = Suc n \\<and>\n    Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "have \"C \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. C = {} \\<Longrightarrow> False", "assume \"C = {}\""], ["proof (state)\nthis:\n  C = {}\n\ngoal (1 subgoal):\n 1. C = {} \\<Longrightarrow> False", "from \\<open>finite C\\<close> and \\<open>C = {}\\<close>"], ["proof (chain)\npicking this:\n  finite C\n  C = {}", "have \"card C = 0\""], ["proof (prove)\nusing this:\n  finite C\n  C = {}\n\ngoal (1 subgoal):\n 1. card C = 0", "using card_0_eq"], ["proof (prove)\nusing this:\n  finite C\n  C = {}\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. card C = 0", "by auto"], ["proof (state)\nthis:\n  card C = 0\n\ngoal (1 subgoal):\n 1. C = {} \\<Longrightarrow> False", "from \\<open>card C = 0\\<close> and \\<open>card C = Suc n\\<close>"], ["proof (chain)\npicking this:\n  card C = 0\n  card C = Suc n", "show \"False\""], ["proof (prove)\nusing this:\n  card C = 0\n  card C = Suc n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite C \\<and>\n    card C = Suc n \\<and>\n    Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> {}", "obtain L where \"L \\<in> C\""], ["proof (prove)\nusing this:\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>L. L \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. finite C \\<and>\n    card C = Suc n \\<and>\n    Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "from \\<open>\\<not>tautology C\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology C", "have \"\\<not>tautology (C - { L })\""], ["proof (prove)\nusing this:\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> tautology (C - {L})", "using tautology_monotonous"], ["proof (prove)\nusing this:\n  \\<not> tautology C\n  \\<lbrakk>tautology ?C; ?C \\<subseteq> ?D\\<rbrakk>\n  \\<Longrightarrow> tautology ?D\n\ngoal (1 subgoal):\n 1. \\<not> tautology (C - {L})", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology (C - {L})\n\ngoal (1 subgoal):\n 1. finite C \\<and>\n    card C = Suc n \\<and>\n    Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "from \\<open>L \\<in> C\\<close> and  \\<open>finite C\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> C\n  finite C", "have \"Suc (card (C - { L })) = card C\""], ["proof (prove)\nusing this:\n  L \\<in> C\n  finite C\n\ngoal (1 subgoal):\n 1. Suc (card (C - {L})) = card C", "using card_Suc_Diff1"], ["proof (prove)\nusing this:\n  L \\<in> C\n  finite C\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> Suc (card (?A - {?x})) = card ?A\n\ngoal (1 subgoal):\n 1. Suc (card (C - {L})) = card C", "by metis"], ["proof (state)\nthis:\n  Suc (card (C - {L})) = card C\n\ngoal (1 subgoal):\n 1. finite C \\<and>\n    card C = Suc n \\<and>\n    Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "with \\<open>card C = Suc n\\<close>"], ["proof (chain)\npicking this:\n  card C = Suc n\n  Suc (card (C - {L})) = card C", "have \"card (C - { L }) = n\""], ["proof (prove)\nusing this:\n  card C = Suc n\n  Suc (card (C - {L})) = card C\n\ngoal (1 subgoal):\n 1. card (C - {L}) = n", "by auto"], ["proof (state)\nthis:\n  card (C - {L}) = n\n\ngoal (1 subgoal):\n 1. finite C \\<and>\n    card C = Suc n \\<and>\n    Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "show \"\\<exists>A. (strictly_maximal_literal C A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. strictly_maximal_literal C A", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>A. strictly_maximal_literal C A\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>A. strictly_maximal_literal C A", "assume \"card C = 1\""], ["proof (state)\nthis:\n  card C = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>A. strictly_maximal_literal C A\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>A. strictly_maximal_literal C A", "from this and  \\<open>card C = Suc n\\<close>"], ["proof (chain)\npicking this:\n  card C = 1\n  card C = Suc n", "have \"n = 0\""], ["proof (prove)\nusing this:\n  card C = 1\n  card C = Suc n\n\ngoal (1 subgoal):\n 1. n = 0", "by auto"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>A. strictly_maximal_literal C A\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>A. strictly_maximal_literal C A", "from this and \\<open>finite C\\<close> and \\<open>card (C - { L }) = n\\<close>"], ["proof (chain)\npicking this:\n  n = 0\n  finite C\n  card (C - {L}) = n", "have \"C - { L } = {}\""], ["proof (prove)\nusing this:\n  n = 0\n  finite C\n  card (C - {L}) = n\n\ngoal (1 subgoal):\n 1. C - {L} = {}", "using card_0_eq"], ["proof (prove)\nusing this:\n  n = 0\n  finite C\n  card (C - {L}) = n\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. C - {L} = {}", "by auto"], ["proof (state)\nthis:\n  C - {L} = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>A. strictly_maximal_literal C A\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>A. strictly_maximal_literal C A", "from this and \\<open>L \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  C - {L} = {}\n  L \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  C - {L} = {}\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>A. strictly_maximal_literal C A", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  C - {L} = {}\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       A \\<in> C \\<and>\n       (\\<forall>B.\n           B \\<in> C \\<and> A \\<noteq> B \\<longrightarrow>\n           literal_ordering B A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>A. strictly_maximal_literal C A\n\ngoal (1 subgoal):\n 1. card C \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card C \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "assume \"card C \\<noteq> 1\""], ["proof (state)\nthis:\n  card C \\<noteq> 1\n\ngoal (1 subgoal):\n 1. card C \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "from \\<open>finite C\\<close>"], ["proof (chain)\npicking this:\n  finite C", "have \"finite (C - { L })\""], ["proof (prove)\nusing this:\n  finite C\n\ngoal (1 subgoal):\n 1. finite (C - {L})", "by auto"], ["proof (state)\nthis:\n  finite (C - {L})\n\ngoal (1 subgoal):\n 1. card C \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "from  \\<open>Suc (card (C - { L })) = card C\\<close> and \\<open>card C \\<noteq> 1\\<close> \n                    and \\<open>(card (C - { L })) = n\\<close>"], ["proof (chain)\npicking this:\n  Suc (card (C - {L})) = card C\n  card C \\<noteq> 1\n  card (C - {L}) = n", "have \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Suc (card (C - {L})) = card C\n  card C \\<noteq> 1\n  card (C - {L}) = n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card C \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "from this and \\<open>finite (C - { L })\\<close> and \\<open>card (C - { L }) = n\\<close> \n                    and \\<open>\\<not>tautology (C - { L })\\<close> and \\<open>?P n\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  finite (C - {L})\n  card (C - {L}) = n\n  \\<not> tautology (C - {L})\n  \\<forall>C.\n     finite C \\<and>\n     card C = n \\<and>\n     n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n     (\\<exists>A. strictly_maximal_literal C A)", "obtain A where \"strictly_maximal_literal (C - { L }) A\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  finite (C - {L})\n  card (C - {L}) = n\n  \\<not> tautology (C - {L})\n  \\<forall>C.\n     finite C \\<and>\n     card C = n \\<and>\n     n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n     (\\<exists>A. strictly_maximal_literal C A)\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        strictly_maximal_literal (C - {L}) A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  strictly_maximal_literal (C - {L}) A\n\ngoal (1 subgoal):\n 1. card C \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>A. strictly_maximal_literal C A", "show \"\\<exists>M. strictly_maximal_literal C M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. strictly_maximal_literal C M", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>M. strictly_maximal_literal C M\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>M. strictly_maximal_literal C M", "assume \"(atom L, atom A) \\<in> atom_ordering\""], ["proof (state)\nthis:\n  (atom L, atom A) \\<in> atom_ordering\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>M. strictly_maximal_literal C M\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>M. strictly_maximal_literal C M", "from this"], ["proof (chain)\npicking this:\n  (atom L, atom A) \\<in> atom_ordering", "have \"literal_ordering L A\""], ["proof (prove)\nusing this:\n  (atom L, atom A) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. literal_ordering L A", "by auto"], ["proof (state)\nthis:\n  literal_ordering L A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>M. strictly_maximal_literal C M\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>M. strictly_maximal_literal C M", "from this and \\<open>strictly_maximal_literal (C - { L }) A\\<close>"], ["proof (chain)\npicking this:\n  literal_ordering L A\n  strictly_maximal_literal (C - {L}) A", "have \"strictly_maximal_literal C A\""], ["proof (prove)\nusing this:\n  literal_ordering L A\n  strictly_maximal_literal (C - {L}) A\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal C A", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  literal_ordering L A\n  A \\<in> C - {L} \\<and>\n  (\\<forall>B.\n      B \\<in> C - {L} \\<and> A \\<noteq> B \\<longrightarrow>\n      literal_ordering B A)\n\ngoal (1 subgoal):\n 1. A \\<in> C \\<and>\n    (\\<forall>B.\n        B \\<in> C \\<and> A \\<noteq> B \\<longrightarrow>\n        literal_ordering B A)", "by blast"], ["proof (state)\nthis:\n  strictly_maximal_literal C A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>M. strictly_maximal_literal C M\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>M. strictly_maximal_literal C M", "thus ?thesis"], ["proof (prove)\nusing this:\n  strictly_maximal_literal C A\n\ngoal (1 subgoal):\n 1. \\<exists>M. strictly_maximal_literal C M", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. strictly_maximal_literal C M\n\ngoal (1 subgoal):\n 1. (atom L, atom A) \\<notin> atom_ordering \\<Longrightarrow>\n    \\<exists>M. strictly_maximal_literal C M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (atom L, atom A) \\<notin> atom_ordering \\<Longrightarrow>\n    \\<exists>M. strictly_maximal_literal C M", "assume \"(atom L, atom A) \\<notin> atom_ordering\""], ["proof (state)\nthis:\n  (atom L, atom A) \\<notin> atom_ordering\n\ngoal (1 subgoal):\n 1. (atom L, atom A) \\<notin> atom_ordering \\<Longrightarrow>\n    \\<exists>M. strictly_maximal_literal C M", "have l_cases: \"L = (Pos (atom L)) \\<or> L = (Neg (atom L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = Pos (atom L) \\<or> L = Neg (atom L)", "by ((rule atom_property [of \"(atom L)\"]), auto)"], ["proof (state)\nthis:\n  L = Pos (atom L) \\<or> L = Neg (atom L)\n\ngoal (1 subgoal):\n 1. (atom L, atom A) \\<notin> atom_ordering \\<Longrightarrow>\n    \\<exists>M. strictly_maximal_literal C M", "have a_cases: \"A = (Pos (atom A)) \\<or> A = (Neg (atom A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Pos (atom A) \\<or> A = Neg (atom A)", "by ((rule atom_property [of \"(atom A)\"]), auto)"], ["proof (state)\nthis:\n  A = Pos (atom A) \\<or> A = Neg (atom A)\n\ngoal (1 subgoal):\n 1. (atom L, atom A) \\<notin> atom_ordering \\<Longrightarrow>\n    \\<exists>M. strictly_maximal_literal C M", "from l_cases and a_cases and\\<open>(strictly_maximal_literal (C - { L }) A)\\<close> \n                        and \\<open>\\<not> (tautology C)\\<close> and \\<open>L \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  L = Pos (atom L) \\<or> L = Neg (atom L)\n  A = Pos (atom A) \\<or> A = Neg (atom A)\n  strictly_maximal_literal (C - {L}) A\n  \\<not> tautology C\n  L \\<in> C", "have \"atom L \\<noteq> atom A\""], ["proof (prove)\nusing this:\n  L = Pos (atom L) \\<or> L = Neg (atom L)\n  A = Pos (atom A) \\<or> A = Neg (atom A)\n  strictly_maximal_literal (C - {L}) A\n  \\<not> tautology C\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. atom L \\<noteq> atom A", "unfolding strictly_maximal_literal_def and tautology_def"], ["proof (prove)\nusing this:\n  L = Pos (atom L) \\<or> L = Neg (atom L)\n  A = Pos (atom A) \\<or> A = Neg (atom A)\n  A \\<in> C - {L} \\<and>\n  (\\<forall>B.\n      B \\<in> C - {L} \\<and> A \\<noteq> B \\<longrightarrow>\n      literal_ordering B A)\n  \\<nexists>A. Pos A \\<in> C \\<and> Neg A \\<in> C\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. atom L \\<noteq> atom A", "by auto"], ["proof (state)\nthis:\n  atom L \\<noteq> atom A\n\ngoal (1 subgoal):\n 1. (atom L, atom A) \\<notin> atom_ordering \\<Longrightarrow>\n    \\<exists>M. strictly_maximal_literal C M", "from this and \\<open>(atom L, atom A) \\<notin> atom_ordering\\<close> and atom_ordering_total"], ["proof (chain)\npicking this:\n  atom L \\<noteq> atom A\n  (atom L, atom A) \\<notin> atom_ordering\n  \\<forall>x y.\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> atom_ordering \\<or> (y, x) \\<in> atom_ordering", "have \"(atom A,atom L) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  atom L \\<noteq> atom A\n  (atom L, atom A) \\<notin> atom_ordering\n  \\<forall>x y.\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> atom_ordering \\<or> (y, x) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. (atom A, atom L) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (atom A, atom L) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. (atom L, atom A) \\<notin> atom_ordering \\<Longrightarrow>\n    \\<exists>M. strictly_maximal_literal C M", "hence \"literal_ordering A L\""], ["proof (prove)\nusing this:\n  (atom A, atom L) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. literal_ordering A L", "by auto"], ["proof (state)\nthis:\n  literal_ordering A L\n\ngoal (1 subgoal):\n 1. (atom L, atom A) \\<notin> atom_ordering \\<Longrightarrow>\n    \\<exists>M. strictly_maximal_literal C M", "from this and \\<open>L \\<in> C\\<close> and \\<open>strictly_maximal_literal (C - { L }) A\\<close> \n                        and literal_ordering_trans"], ["proof (chain)\npicking this:\n  literal_ordering A L\n  L \\<in> C\n  strictly_maximal_literal (C - {L}) A\n  \\<lbrakk>literal_ordering ?A ?B; literal_ordering ?B ?C\\<rbrakk>\n  \\<Longrightarrow> literal_ordering ?A ?C", "have \"strictly_maximal_literal C L\""], ["proof (prove)\nusing this:\n  literal_ordering A L\n  L \\<in> C\n  strictly_maximal_literal (C - {L}) A\n  \\<lbrakk>literal_ordering ?A ?B; literal_ordering ?B ?C\\<rbrakk>\n  \\<Longrightarrow> literal_ordering ?A ?C\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal C L", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  literal_ordering A L\n  L \\<in> C\n  A \\<in> C - {L} \\<and>\n  (\\<forall>B.\n      B \\<in> C - {L} \\<and> A \\<noteq> B \\<longrightarrow>\n      literal_ordering B A)\n  \\<lbrakk>literal_ordering ?A ?B; literal_ordering ?B ?C\\<rbrakk>\n  \\<Longrightarrow> literal_ordering ?A ?C\n\ngoal (1 subgoal):\n 1. L \\<in> C \\<and>\n    (\\<forall>B.\n        B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow>\n        literal_ordering B L)", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  literal_ordering A L\n  L \\<in> C\n  A \\<in> C - {L} \\<and>\n  (\\<forall>B.\n      B \\<in> C - {L} \\<and> A \\<noteq> B \\<longrightarrow>\n      literal_ordering B A)\n  \\<lbrakk>literal_ordering ?A ?B; literal_ordering ?B ?C\\<rbrakk>\n  \\<Longrightarrow> literal_ordering ?A ?C\n\ngoal (1 subgoal):\n 1. L \\<in> C \\<and>\n    (\\<forall>B.\n        B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow>\n        literal_ordering B L)", "by blast"], ["proof (state)\nthis:\n  strictly_maximal_literal C L\n\ngoal (1 subgoal):\n 1. (atom L, atom A) \\<notin> atom_ordering \\<Longrightarrow>\n    \\<exists>M. strictly_maximal_literal C M", "thus ?thesis"], ["proof (prove)\nusing this:\n  strictly_maximal_literal C L\n\ngoal (1 subgoal):\n 1. \\<exists>M. strictly_maximal_literal C M", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. strictly_maximal_literal C M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M. strictly_maximal_literal C M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A. strictly_maximal_literal C A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite C \\<and>\n  card C = Suc n \\<and>\n  Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n  (\\<exists>A. strictly_maximal_literal C A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C.\n     finite C \\<and>\n     card C = Suc n \\<and>\n     Suc n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n     (\\<exists>A. strictly_maximal_literal C A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We then deduce that all clauses are validated.\\<close>"], ["", "lemma canonic_int_validates_all_clauses : \n  assumes \"saturated_binary_rule ordered_resolvent S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"{} \\<notin> S\"\n  assumes \"C \\<in> S\"\n  shows \"validate_clause (canonic_int_ordered S) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "assume \"(tautology C)\""], ["proof (state)\nthis:\n  tautology C\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  tautology C\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "using tautologies_are_valid [of \"C\" \"(canonic_int_ordered S)\"]"], ["proof (prove)\nusing this:\n  tautology C\n  tautology C \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "assume \"\\<not>tautology C\""], ["proof (state)\nthis:\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "from \\<open>all_fulfill finite S\\<close> and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S\n  C \\<in> S", "have \"finite C\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite C", "using all_fulfill_def"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  C \\<in> S\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n\ngoal (1 subgoal):\n 1. finite C", "by auto"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "from \\<open>{} \\<notin> S\\<close> and \\<open>C \\<in> S\\<close> and \\<open>finite C\\<close>"], ["proof (chain)\npicking this:\n  {} \\<notin> S\n  C \\<in> S\n  finite C", "have \"card C \\<noteq> 0\""], ["proof (prove)\nusing this:\n  {} \\<notin> S\n  C \\<in> S\n  finite C\n\ngoal (1 subgoal):\n 1. card C \\<noteq> 0", "using card_0_eq"], ["proof (prove)\nusing this:\n  {} \\<notin> S\n  C \\<in> S\n  finite C\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. card C \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "from \\<open>\\<not>tautology C\\<close> and \\<open>finite C\\<close> and \\<open>card C \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology C\n  finite C\n  card C \\<noteq> 0", "obtain \"L\"\n      where \"strictly_maximal_literal C L\""], ["proof (prove)\nusing this:\n  \\<not> tautology C\n  finite C\n  card C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        strictly_maximal_literal C L \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using strictly_maximal_literal_exists"], ["proof (prove)\nusing this:\n  \\<not> tautology C\n  finite C\n  card C \\<noteq> 0\n  \\<forall>C.\n     finite C \\<and>\n     card C = ?n \\<and>\n     ?n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n     (\\<exists>A. strictly_maximal_literal C A)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        strictly_maximal_literal C L \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strictly_maximal_literal C L\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "obtain A where \"A = atom L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A. A = atom L \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  A = atom L\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "have inductive_lemma: \n    \"\\<forall>C L. ((C \\<in> S) \\<longrightarrow> (strictly_maximal_literal C L) \\<longrightarrow> (A = (atom L))\n      \\<longrightarrow> (validate_clause (canonic_int_ordered S) C))\" (is \"(?Q A)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C L.\n       C \\<in> S \\<longrightarrow>\n       strictly_maximal_literal C L \\<longrightarrow>\n       A = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C", "proof ((rule wf_induct [of \"atom_ordering\" \"?Q\" \"A\"]),(rule atom_ordering_wf))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> atom_ordering \\<longrightarrow>\n          (\\<forall>C L.\n              C \\<in> S \\<longrightarrow>\n              strictly_maximal_literal C L \\<longrightarrow>\n              y = atom L \\<longrightarrow>\n              canonic_int_ordered S \\<Turnstile> C) \\<Longrightarrow>\n       \\<forall>C L.\n          C \\<in> S \\<longrightarrow>\n          strictly_maximal_literal C L \\<longrightarrow>\n          x = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> atom_ordering \\<longrightarrow>\n          (\\<forall>C L.\n              C \\<in> S \\<longrightarrow>\n              strictly_maximal_literal C L \\<longrightarrow>\n              y = atom L \\<longrightarrow>\n              canonic_int_ordered S \\<Turnstile> C) \\<Longrightarrow>\n       \\<forall>C L.\n          C \\<in> S \\<longrightarrow>\n          strictly_maximal_literal C L \\<longrightarrow>\n          x = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> atom_ordering \\<longrightarrow>\n          (\\<forall>C L.\n              C \\<in> S \\<longrightarrow>\n              strictly_maximal_literal C L \\<longrightarrow>\n              y = atom L \\<longrightarrow>\n              canonic_int_ordered S \\<Turnstile> C) \\<Longrightarrow>\n       \\<forall>C L.\n          C \\<in> S \\<longrightarrow>\n          strictly_maximal_literal C L \\<longrightarrow>\n          x = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C", "assume hyp_induct: \"\\<forall>y. (y,x) \\<in> atom_ordering \\<longrightarrow> (?Q y)\""], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, x) \\<in> atom_ordering \\<longrightarrow>\n     (\\<forall>C L.\n         C \\<in> S \\<longrightarrow>\n         strictly_maximal_literal C L \\<longrightarrow>\n         y = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> atom_ordering \\<longrightarrow>\n          (\\<forall>C L.\n              C \\<in> S \\<longrightarrow>\n              strictly_maximal_literal C L \\<longrightarrow>\n              y = atom L \\<longrightarrow>\n              canonic_int_ordered S \\<Turnstile> C) \\<Longrightarrow>\n       \\<forall>C L.\n          C \\<in> S \\<longrightarrow>\n          strictly_maximal_literal C L \\<longrightarrow>\n          x = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C", "show \"?Q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C L.\n       C \\<in> S \\<longrightarrow>\n       strictly_maximal_literal C L \\<longrightarrow>\n       x = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C", "proof (rule)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C L.\n       \\<lbrakk>C \\<in> S; strictly_maximal_literal C L; x = atom L\\<rbrakk>\n       \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "fix C L"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C L.\n       \\<lbrakk>C \\<in> S; strictly_maximal_literal C L; x = atom L\\<rbrakk>\n       \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "assume \"C \\<in> S\" \"strictly_maximal_literal C L\" \"x = (atom L)\""], ["proof (state)\nthis:\n  C \\<in> S\n  strictly_maximal_literal C L\n  x = atom L\n\ngoal (1 subgoal):\n 1. \\<And>C L.\n       \\<lbrakk>C \\<in> S; strictly_maximal_literal C L; x = atom L\\<rbrakk>\n       \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "show \"validate_clause (canonic_int_ordered S) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "assume \"L = Pos x\""], ["proof (state)\nthis:\n  L = Pos x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C\n 2. \\<not> ?P \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "from \\<open>L = Pos x\\<close> and \\<open>strictly_maximal_literal C L\\<close> and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  L = Pos x\n  strictly_maximal_literal C L\n  C \\<in> S", "show \"validate_clause (canonic_int_ordered S) C\""], ["proof (prove)\nusing this:\n  L = Pos x\n  strictly_maximal_literal C L\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "using int_validate_cl_with_pos_max"], ["proof (prove)\nusing this:\n  L = Pos x\n  strictly_maximal_literal C L\n  C \\<in> S\n  \\<lbrakk>strictly_maximal_literal ?C (Pos ?A); ?C \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> canonic_int_ordered ?S \\<Turnstile> ?C\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos x \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> Pos x \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "assume \"L \\<noteq> Pos x\""], ["proof (state)\nthis:\n  L \\<noteq> Pos x\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos x \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "have \"L = (Neg x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = Neg x", "using \\<open>L \\<noteq> Pos x\\<close> \\<open>x = atom L\\<close> atom_property"], ["proof (prove)\nusing this:\n  L \\<noteq> Pos x\n  x = atom L\n  ?A = atom ?L \\<Longrightarrow> ?L = Pos ?A \\<or> ?L = Neg ?A\n\ngoal (1 subgoal):\n 1. L = Neg x", "by fastforce"], ["proof (state)\nthis:\n  L = Neg x\n\ngoal (1 subgoal):\n 1. L \\<noteq> Pos x \\<Longrightarrow> canonic_int_ordered S \\<Turnstile> C", "show \"(validate_clause (canonic_int_ordered S) C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "assume  \"\\<not> (validate_clause(canonic_int_ordered S) C)\""], ["proof (state)\nthis:\n  \\<not> canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>(L = (Neg x))\\<close> and \\<open>(strictly_maximal_literal C L)\\<close> \n              and \\<open>(\\<not> (validate_clause (canonic_int_ordered S) C))\\<close>"], ["proof (chain)\npicking this:\n  L = Neg x\n  strictly_maximal_literal C L\n  \\<not> canonic_int_ordered S \\<Turnstile> C", "have \"x \\<in> canonic_int_ordered S\""], ["proof (prove)\nusing this:\n  L = Neg x\n  strictly_maximal_literal C L\n  \\<not> canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. x \\<in> canonic_int_ordered S", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  L = Neg x\n  L \\<in> C \\<and>\n  (\\<forall>B.\n      B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n  \\<not> canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. x \\<in> canonic_int_ordered S", "by auto"], ["proof (state)\nthis:\n  x \\<in> canonic_int_ordered S\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>x \\<in> canonic_int_ordered S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> canonic_int_ordered S", "have \"(canonic_int_fun_ordered x) S\""], ["proof (prove)\nusing this:\n  x \\<in> canonic_int_ordered S\n\ngoal (1 subgoal):\n 1. canonic_int_fun_ordered x S", "unfolding canonic_int_ordered_def"], ["proof (prove)\nusing this:\n  x \\<in> {A. canonic_int_fun_ordered A S}\n\ngoal (1 subgoal):\n 1. canonic_int_fun_ordered x S", "by blast"], ["proof (state)\nthis:\n  canonic_int_fun_ordered x S\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>(canonic_int_fun_ordered x) S\\<close>"], ["proof (chain)\npicking this:\n  canonic_int_fun_ordered x S", "have \"(\\<exists> C. (C \\<in> S) \\<and> (strictly_maximal_literal C (Pos x) ) \n            \\<and> ( \\<forall> B. ( Pos B \\<in> C \\<longrightarrow> (B, x) \\<in> atom_ordering \\<longrightarrow> (\\<not>(canonic_int_fun_ordered B) S)))\n            \\<and> ( \\<forall> B. ( Neg B \\<in> C \\<longrightarrow> (B, x) \\<in> atom_ordering \\<longrightarrow> ((canonic_int_fun_ordered B) S))))\""], ["proof (prove)\nusing this:\n  canonic_int_fun_ordered x S\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       C \\<in> S \\<and>\n       strictly_maximal_literal C (Pos x) \\<and>\n       (\\<forall>B.\n           Pos B \\<in> C \\<longrightarrow>\n           (B, x) \\<in> atom_ordering \\<longrightarrow>\n           \\<not> canonic_int_fun_ordered B S) \\<and>\n       (\\<forall>B.\n           Neg B \\<in> C \\<longrightarrow>\n           (B, x) \\<in> atom_ordering \\<longrightarrow>\n           canonic_int_fun_ordered B S)", "by (simp only: canonic_int_fun_ordered.simps [of x])"], ["proof (state)\nthis:\n  \\<exists>C.\n     C \\<in> S \\<and>\n     strictly_maximal_literal C (Pos x) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, x) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B S) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, x) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B S)\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     C \\<in> S \\<and>\n     strictly_maximal_literal C (Pos x) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, x) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B S) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, x) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B S)", "obtain D \n            where \"(D \\<in> S)\" and \"(strictly_maximal_literal D (Pos x))\"\n            and a: \"( \\<forall> B. ( Pos B \\<in> D \\<longrightarrow> (B, x) \\<in> atom_ordering \n                  \\<longrightarrow> (\\<not>(canonic_int_fun_ordered B) S)))\"\n            and b: \"( \\<forall> B. ( Neg B \\<in> D \\<longrightarrow> (B, x) \\<in> atom_ordering \n                      \\<longrightarrow> ((canonic_int_fun_ordered B) S)))\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     C \\<in> S \\<and>\n     strictly_maximal_literal C (Pos x) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, x) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B S) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, x) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B S)\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> S; strictly_maximal_literal D (Pos x);\n         \\<forall>B.\n            Pos B \\<in> D \\<longrightarrow>\n            (B, x) \\<in> atom_ordering \\<longrightarrow>\n            \\<not> canonic_int_fun_ordered B S;\n         \\<forall>B.\n            Neg B \\<in> D \\<longrightarrow>\n            (B, x) \\<in> atom_ordering \\<longrightarrow>\n            canonic_int_fun_ordered B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D \\<in> S\n  strictly_maximal_literal D (Pos x)\n  \\<forall>B.\n     Pos B \\<in> D \\<longrightarrow>\n     (B, x) \\<in> atom_ordering \\<longrightarrow>\n     \\<not> canonic_int_fun_ordered B S\n  \\<forall>B.\n     Neg B \\<in> D \\<longrightarrow>\n     (B, x) \\<in> atom_ordering \\<longrightarrow>\n     canonic_int_fun_ordered B S\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "obtain R where \"R = (resolvent_upon D C x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        R = resolvent_upon D C x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R = resolvent_upon D C x\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>R = resolvent_upon D C x\\<close> and \\<open>strictly_maximal_literal D (Pos x)\\<close> \n              and \\<open>strictly_maximal_literal C L\\<close> and \\<open>L = (Neg x)\\<close>"], ["proof (chain)\npicking this:\n  R = resolvent_upon D C x\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x", "have \"resolvent D C R\""], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x\n\ngoal (1 subgoal):\n 1. resolvent D C R", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  Pos x \\<in> D \\<and>\n  (\\<forall>B.\n      B \\<in> D \\<and> Pos x \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos x))\n  L \\<in> C \\<and>\n  (\\<forall>B.\n      B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n  L = Neg x\n\ngoal (1 subgoal):\n 1. resolvent D C R", "using resolvent_upon_is_resolvent"], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  Pos x \\<in> D \\<and>\n  (\\<forall>B.\n      B \\<in> D \\<and> Pos x \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos x))\n  L \\<in> C \\<and>\n  (\\<forall>B.\n      B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n  L = Neg x\n  \\<lbrakk>Pos ?A \\<in> ?P1.0; Neg ?A \\<in> ?P2.0\\<rbrakk>\n  \\<Longrightarrow> resolvent ?P1.0 ?P2.0 (resolvent_upon ?P1.0 ?P2.0 ?A)\n\ngoal (1 subgoal):\n 1. resolvent D C R", "by auto"], ["proof (state)\nthis:\n  resolvent D C R\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>R = resolvent_upon D C x\\<close> and \\<open>strictly_maximal_literal D (Pos x)\\<close> \n              and \\<open>strictly_maximal_literal C L\\<close> and \\<open>L = Neg x\\<close>"], ["proof (chain)\npicking this:\n  R = resolvent_upon D C x\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x", "have \"ordered_resolvent D C R\""], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x\n\ngoal (1 subgoal):\n 1. ordered_resolvent D C R", "using ordered_resolvent_upon_is_resolvent"], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x\n  \\<lbrakk>strictly_maximal_literal ?P1.0 (Pos ?A);\n   strictly_maximal_literal ?P2.0 (Neg ?A)\\<rbrakk>\n  \\<Longrightarrow> ordered_resolvent ?P1.0 ?P2.0\n                     (resolvent_upon ?P1.0 ?P2.0 ?A)\n\ngoal (1 subgoal):\n 1. ordered_resolvent D C R", "by auto"], ["proof (state)\nthis:\n  ordered_resolvent D C R\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "have \"\\<not> validate_clause (canonic_int_ordered S) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> R", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> R \\<Longrightarrow> False", "assume \"validate_clause (canonic_int_ordered S) R\""], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> R \\<Longrightarrow> False", "from \\<open>validate_clause (canonic_int_ordered S) R\\<close>"], ["proof (chain)\npicking this:\n  canonic_int_ordered S \\<Turnstile> R", "obtain M \n                where \"(M \\<in> R)\" and \"validate_literal (canonic_int_ordered S) M\""], ["proof (prove)\nusing this:\n  canonic_int_ordered S \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> R; canonic_int_ordered S \\<Turnstile> M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M \\<in> R\n  canonic_int_ordered S \\<Turnstile> M\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> R \\<Longrightarrow> False", "from \\<open>M \\<in> R\\<close> and \\<open>R = resolvent_upon D C x\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> R\n  R = resolvent_upon D C x", "have \"(M \\<in> (D - { Pos x })) \\<or> (M \\<in> (C - { Neg x }))\""], ["proof (prove)\nusing this:\n  M \\<in> R\n  R = resolvent_upon D C x\n\ngoal (1 subgoal):\n 1. M \\<in> D - {Pos x} \\<or> M \\<in> C - {Neg x}", "by auto"], ["proof (state)\nthis:\n  M \\<in> D - {Pos x} \\<or> M \\<in> C - {Neg x}\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> R \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  M \\<in> D - {Pos x} \\<or> M \\<in> C - {Neg x}\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M \\<in> D - {Pos x} \\<Longrightarrow> False\n 2. M \\<in> C - {Neg x} \\<Longrightarrow> False", "assume \"M \\<in> (D - { Pos x })\""], ["proof (state)\nthis:\n  M \\<in> D - {Pos x}\n\ngoal (2 subgoals):\n 1. M \\<in> D - {Pos x} \\<Longrightarrow> False\n 2. M \\<in> C - {Neg x} \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"\\<exists>AA. M = (Pos AA)\""], ["proof (state)\nthis:\n  \\<exists>AA. M = Pos AA\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>AA. M = Pos AA", "obtain AA where \"M = Pos AA\""], ["proof (prove)\nusing this:\n  \\<exists>AA. M = Pos AA\n\ngoal (1 subgoal):\n 1. (\\<And>AA. M = Pos AA \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  M = Pos AA\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from \\<open>M \\<in> D - { Pos x }\\<close> and \\<open>strictly_maximal_literal D (Pos x)\\<close> \n                    and \\<open>(M = Pos AA)\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> D - {Pos x}\n  strictly_maximal_literal D (Pos x)\n  M = Pos AA", "have \"(AA,x) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  M \\<in> D - {Pos x}\n  strictly_maximal_literal D (Pos x)\n  M = Pos AA\n\ngoal (1 subgoal):\n 1. (AA, x) \\<in> atom_ordering", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  M \\<in> D - {Pos x}\n  Pos x \\<in> D \\<and>\n  (\\<forall>B.\n      B \\<in> D \\<and> Pos x \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos x))\n  M = Pos AA\n\ngoal (1 subgoal):\n 1. (AA, x) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (AA, x) \\<in> atom_ordering\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from a and \\<open>(AA,x) \\<in> atom_ordering\\<close> and \\<open>M = (Pos AA)\\<close> and \\<open>M \\<in> (D - { Pos x })\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>B.\n     Pos B \\<in> D \\<longrightarrow>\n     (B, x) \\<in> atom_ordering \\<longrightarrow>\n     \\<not> canonic_int_fun_ordered B S\n  (AA, x) \\<in> atom_ordering\n  M = Pos AA\n  M \\<in> D - {Pos x}", "have \"\\<not>(canonic_int_fun_ordered AA) S\""], ["proof (prove)\nusing this:\n  \\<forall>B.\n     Pos B \\<in> D \\<longrightarrow>\n     (B, x) \\<in> atom_ordering \\<longrightarrow>\n     \\<not> canonic_int_fun_ordered B S\n  (AA, x) \\<in> atom_ordering\n  M = Pos AA\n  M \\<in> D - {Pos x}\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_fun_ordered AA S", "by blast"], ["proof (state)\nthis:\n  \\<not> canonic_int_fun_ordered AA S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from \\<open>\\<not>(canonic_int_fun_ordered AA) S\\<close>"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_fun_ordered AA S", "have \"AA \\<notin> canonic_int_ordered S\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_fun_ordered AA S\n\ngoal (1 subgoal):\n 1. AA \\<notin> canonic_int_ordered S", "unfolding canonic_int_ordered_def"], ["proof (prove)\nusing this:\n  \\<not> canonic_int_fun_ordered AA S\n\ngoal (1 subgoal):\n 1. AA \\<notin> {A. canonic_int_fun_ordered A S}", "by blast"], ["proof (state)\nthis:\n  AA \\<notin> canonic_int_ordered S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from \\<open>AA \\<notin> canonic_int_ordered S\\<close> and \\<open>M = Pos AA\\<close> \n                    and \\<open>validate_literal (canonic_int_ordered S) M\\<close>"], ["proof (chain)\npicking this:\n  AA \\<notin> canonic_int_ordered S\n  M = Pos AA\n  canonic_int_ordered S \\<Turnstile> M", "show \"False\""], ["proof (prove)\nusing this:\n  AA \\<notin> canonic_int_ordered S\n  M = Pos AA\n  canonic_int_ordered S \\<Turnstile> M\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>AA. M = Pos AA \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>AA. M = Pos AA \\<Longrightarrow> False", "assume \"\\<not>(\\<exists>AA. M = (Pos AA))\""], ["proof (state)\nthis:\n  \\<nexists>AA. M = Pos AA\n\ngoal (1 subgoal):\n 1. \\<nexists>AA. M = Pos AA \\<Longrightarrow> False", "obtain AA where \"M = (Pos AA) \\<or> M = (Neg AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AA.\n        M = Pos AA \\<or> M = Neg AA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of M]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. M = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. M = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>AA.\n        M = Pos AA \\<or> M = Neg AA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M = Pos AA \\<or> M = Neg AA\n\ngoal (1 subgoal):\n 1. \\<nexists>AA. M = Pos AA \\<Longrightarrow> False", "from this and \\<open>\\<not>(\\<exists>AA. M = (Pos AA))\\<close>"], ["proof (chain)\npicking this:\n  M = Pos AA \\<or> M = Neg AA\n  \\<nexists>AA. M = Pos AA", "have \"M = (Neg AA)\""], ["proof (prove)\nusing this:\n  M = Pos AA \\<or> M = Neg AA\n  \\<nexists>AA. M = Pos AA\n\ngoal (1 subgoal):\n 1. M = Neg AA", "by auto"], ["proof (state)\nthis:\n  M = Neg AA\n\ngoal (1 subgoal):\n 1. \\<nexists>AA. M = Pos AA \\<Longrightarrow> False", "from \\<open>M \\<in> (D - { Pos x })\\<close> and \\<open>strictly_maximal_literal D (Pos x)\\<close> \n                    and \\<open>M = (Neg AA)\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> D - {Pos x}\n  strictly_maximal_literal D (Pos x)\n  M = Neg AA", "have \"(AA,x) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  M \\<in> D - {Pos x}\n  strictly_maximal_literal D (Pos x)\n  M = Neg AA\n\ngoal (1 subgoal):\n 1. (AA, x) \\<in> atom_ordering", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  M \\<in> D - {Pos x}\n  Pos x \\<in> D \\<and>\n  (\\<forall>B.\n      B \\<in> D \\<and> Pos x \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos x))\n  M = Neg AA\n\ngoal (1 subgoal):\n 1. (AA, x) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (AA, x) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. \\<nexists>AA. M = Pos AA \\<Longrightarrow> False", "from b and \\<open>(AA,x) \\<in> atom_ordering\\<close> and \\<open>M = (Neg AA)\\<close> and \\<open>M \\<in> (D - { Pos x })\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>B.\n     Neg B \\<in> D \\<longrightarrow>\n     (B, x) \\<in> atom_ordering \\<longrightarrow>\n     canonic_int_fun_ordered B S\n  (AA, x) \\<in> atom_ordering\n  M = Neg AA\n  M \\<in> D - {Pos x}", "have \"(canonic_int_fun_ordered AA) S\""], ["proof (prove)\nusing this:\n  \\<forall>B.\n     Neg B \\<in> D \\<longrightarrow>\n     (B, x) \\<in> atom_ordering \\<longrightarrow>\n     canonic_int_fun_ordered B S\n  (AA, x) \\<in> atom_ordering\n  M = Neg AA\n  M \\<in> D - {Pos x}\n\ngoal (1 subgoal):\n 1. canonic_int_fun_ordered AA S", "by blast"], ["proof (state)\nthis:\n  canonic_int_fun_ordered AA S\n\ngoal (1 subgoal):\n 1. \\<nexists>AA. M = Pos AA \\<Longrightarrow> False", "from \\<open>(canonic_int_fun_ordered AA) S\\<close>"], ["proof (chain)\npicking this:\n  canonic_int_fun_ordered AA S", "have \"AA \\<in> canonic_int_ordered S\""], ["proof (prove)\nusing this:\n  canonic_int_fun_ordered AA S\n\ngoal (1 subgoal):\n 1. AA \\<in> canonic_int_ordered S", "unfolding canonic_int_ordered_def"], ["proof (prove)\nusing this:\n  canonic_int_fun_ordered AA S\n\ngoal (1 subgoal):\n 1. AA \\<in> {A. canonic_int_fun_ordered A S}", "by blast"], ["proof (state)\nthis:\n  AA \\<in> canonic_int_ordered S\n\ngoal (1 subgoal):\n 1. \\<nexists>AA. M = Pos AA \\<Longrightarrow> False", "from \\<open>AA \\<in> canonic_int_ordered S\\<close> and \\<open>M = (Neg AA)\\<close> \n                    and \\<open>validate_literal (canonic_int_ordered S) M\\<close>"], ["proof (chain)\npicking this:\n  AA \\<in> canonic_int_ordered S\n  M = Neg AA\n  canonic_int_ordered S \\<Turnstile> M", "show \"False\""], ["proof (prove)\nusing this:\n  AA \\<in> canonic_int_ordered S\n  M = Neg AA\n  canonic_int_ordered S \\<Turnstile> M\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. M \\<in> C - {Neg x} \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<in> C - {Neg x} \\<Longrightarrow> False", "assume \"M \\<in> (C - { Neg x })\""], ["proof (state)\nthis:\n  M \\<in> C - {Neg x}\n\ngoal (1 subgoal):\n 1. M \\<in> C - {Neg x} \\<Longrightarrow> False", "from \\<open>\\<not>validate_clause(canonic_int_ordered S) C\\<close> and \\<open>M \\<in> (C - { Neg x })\\<close>\n                and \\<open>validate_literal (canonic_int_ordered S) M\\<close>"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_ordered S \\<Turnstile> C\n  M \\<in> C - {Neg x}\n  canonic_int_ordered S \\<Turnstile> M", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_ordered S \\<Turnstile> C\n  M \\<in> C - {Neg x}\n  canonic_int_ordered S \\<Turnstile> M\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> canonic_int_ordered S \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>\\<not>validate_clause (canonic_int_ordered S) R\\<close>"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_ordered S \\<Turnstile> R", "have \"\\<not>tautology R\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_ordered S \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. \\<not> tautology R", "using tautologies_are_valid"], ["proof (prove)\nusing this:\n  \\<not> canonic_int_ordered S \\<Turnstile> R\n  tautology ?C \\<Longrightarrow> ?I \\<Turnstile> ?C\n\ngoal (1 subgoal):\n 1. \\<not> tautology R", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology R\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>ordered_resolvent D C R\\<close> and \\<open>D \\<in> S\\<close> and \\<open>C \\<in> S\\<close> \n              and \\<open>saturated_binary_rule ordered_resolvent S\\<close>"], ["proof (chain)\npicking this:\n  ordered_resolvent D C R\n  D \\<in> S\n  C \\<in> S\n  saturated_binary_rule ordered_resolvent S", "have \"redundant R S\""], ["proof (prove)\nusing this:\n  ordered_resolvent D C R\n  D \\<in> S\n  C \\<in> S\n  saturated_binary_rule ordered_resolvent S\n\ngoal (1 subgoal):\n 1. redundant R S", "unfolding saturated_binary_rule_def"], ["proof (prove)\nusing this:\n  ordered_resolvent D C R\n  D \\<in> S\n  C \\<in> S\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and> ordered_resolvent P1 P2 C \\<longrightarrow>\n     redundant C S\n\ngoal (1 subgoal):\n 1. redundant R S", "by auto"], ["proof (state)\nthis:\n  redundant R S\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from this and \\<open>\\<not>tautology R\\<close>"], ["proof (chain)\npicking this:\n  redundant R S\n  \\<not> tautology R", "obtain R' where \"R' \\<in> S\" and \"subsumes R' R\""], ["proof (prove)\nusing this:\n  redundant R S\n  \\<not> tautology R\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>R' \\<in> S; subsumes R' R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  tautology R \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D R)\n  \\<not> tautology R\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>R' \\<in> S; subsumes R' R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R' \\<in> S\n  subsumes R' R\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>R = resolvent_upon D C x\\<close> and \\<open>strictly_maximal_literal D (Pos x)\\<close> \n              and \\<open>strictly_maximal_literal C L\\<close> and \\<open>L = (Neg x)\\<close>"], ["proof (chain)\npicking this:\n  R = resolvent_upon D C x\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x", "have \"resolvent D C R\""], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x\n\ngoal (1 subgoal):\n 1. resolvent D C R", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  Pos x \\<in> D \\<and>\n  (\\<forall>B.\n      B \\<in> D \\<and> Pos x \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos x))\n  L \\<in> C \\<and>\n  (\\<forall>B.\n      B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n  L = Neg x\n\ngoal (1 subgoal):\n 1. resolvent D C R", "using resolvent_upon_is_resolvent"], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  Pos x \\<in> D \\<and>\n  (\\<forall>B.\n      B \\<in> D \\<and> Pos x \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos x))\n  L \\<in> C \\<and>\n  (\\<forall>B.\n      B \\<in> C \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n  L = Neg x\n  \\<lbrakk>Pos ?A \\<in> ?P1.0; Neg ?A \\<in> ?P2.0\\<rbrakk>\n  \\<Longrightarrow> resolvent ?P1.0 ?P2.0 (resolvent_upon ?P1.0 ?P2.0 ?A)\n\ngoal (1 subgoal):\n 1. resolvent D C R", "by auto"], ["proof (state)\nthis:\n  resolvent D C R\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>all_fulfill finite S\\<close> and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S\n  C \\<in> S", "have \"finite C\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite C", "using all_fulfill_def"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  C \\<in> S\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n\ngoal (1 subgoal):\n 1. finite C", "by auto"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>all_fulfill finite S\\<close> and \\<open>D \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S\n  D \\<in> S", "have \"finite D\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. finite D", "using all_fulfill_def"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  D \\<in> S\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n\ngoal (1 subgoal):\n 1. finite D", "by auto"], ["proof (state)\nthis:\n  finite D\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>finite C\\<close> and \\<open>finite D\\<close> and  \\<open>(resolvent D C R)\\<close>"], ["proof (chain)\npicking this:\n  finite C\n  finite D\n  resolvent D C R", "have \"finite R\""], ["proof (prove)\nusing this:\n  finite C\n  finite D\n  resolvent D C R\n\ngoal (1 subgoal):\n 1. finite R", "using resolvent_is_finite"], ["proof (prove)\nusing this:\n  finite C\n  finite D\n  resolvent D C R\n  derived_clauses_are_finite resolvent\n\ngoal (1 subgoal):\n 1. finite R", "unfolding derived_clauses_are_finite_def"], ["proof (prove)\nusing this:\n  finite C\n  finite D\n  resolvent D C R\n  \\<forall>P1 P2 C.\n     finite P1 \\<longrightarrow>\n     finite P2 \\<longrightarrow>\n     resolvent P1 P2 C \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. finite R", "by blast"], ["proof (state)\nthis:\n  finite R\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>finite R\\<close> and \\<open>subsumes R' R\\<close>"], ["proof (chain)\npicking this:\n  finite R\n  subsumes R' R", "have \"finite R'\""], ["proof (prove)\nusing this:\n  finite R\n  subsumes R' R\n\ngoal (1 subgoal):\n 1. finite R'", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  finite R\n  R' \\<subseteq> R\n\ngoal (1 subgoal):\n 1. finite R'", "using finite_subset"], ["proof (prove)\nusing this:\n  finite R\n  R' \\<subseteq> R\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite R'", "by auto"], ["proof (state)\nthis:\n  finite R'\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>R' \\<in> S\\<close> and \\<open>{} \\<notin> S\\<close> and \\<open>(subsumes R' R)\\<close>"], ["proof (chain)\npicking this:\n  R' \\<in> S\n  {} \\<notin> S\n  subsumes R' R", "have \"R' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  R' \\<in> S\n  {} \\<notin> S\n  subsumes R' R\n\ngoal (1 subgoal):\n 1. R' \\<noteq> {}", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  R' \\<in> S\n  {} \\<notin> S\n  R' \\<subseteq> R\n\ngoal (1 subgoal):\n 1. R' \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  R' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>finite R'\\<close> and \\<open>R' \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  finite R'\n  R' \\<noteq> {}", "have \"card R' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite R'\n  R' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card R' \\<noteq> 0", "using card_0_eq"], ["proof (prove)\nusing this:\n  finite R'\n  R' \\<noteq> {}\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. card R' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card R' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>subsumes R' R\\<close> and \\<open>\\<not>tautology R\\<close>"], ["proof (chain)\npicking this:\n  subsumes R' R\n  \\<not> tautology R", "have \"\\<not>tautology R'\""], ["proof (prove)\nusing this:\n  subsumes R' R\n  \\<not> tautology R\n\ngoal (1 subgoal):\n 1. \\<not> tautology R'", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  R' \\<subseteq> R\n  \\<not> tautology R\n\ngoal (1 subgoal):\n 1. \\<not> tautology R'", "using tautology_monotonous"], ["proof (prove)\nusing this:\n  R' \\<subseteq> R\n  \\<not> tautology R\n  \\<lbrakk>tautology ?C; ?C \\<subseteq> ?D\\<rbrakk>\n  \\<Longrightarrow> tautology ?D\n\ngoal (1 subgoal):\n 1. \\<not> tautology R'", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology R'\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>\\<not>tautology R'\\<close> and \\<open>finite R'\\<close>  and \\<open>card R' \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology R'\n  finite R'\n  card R' \\<noteq> 0", "obtain \"LR'\" \n              where \"strictly_maximal_literal R' LR'\""], ["proof (prove)\nusing this:\n  \\<not> tautology R'\n  finite R'\n  card R' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>LR'.\n        strictly_maximal_literal R' LR' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using strictly_maximal_literal_exists"], ["proof (prove)\nusing this:\n  \\<not> tautology R'\n  finite R'\n  card R' \\<noteq> 0\n  \\<forall>C.\n     finite C \\<and>\n     card C = ?n \\<and>\n     ?n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n     (\\<exists>A. strictly_maximal_literal C A)\n\ngoal (1 subgoal):\n 1. (\\<And>LR'.\n        strictly_maximal_literal R' LR' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strictly_maximal_literal R' LR'\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>finite R\\<close> and \\<open>finite R'\\<close> and \\<open>card R' \\<noteq> 0\\<close> and \\<open>subsumes R' R\\<close>"], ["proof (chain)\npicking this:\n  finite R\n  finite R'\n  card R' \\<noteq> 0\n  subsumes R' R", "have \"card R \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite R\n  finite R'\n  card R' \\<noteq> 0\n  subsumes R' R\n\ngoal (1 subgoal):\n 1. card R \\<noteq> 0", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  finite R\n  finite R'\n  card R' \\<noteq> 0\n  R' \\<subseteq> R\n\ngoal (1 subgoal):\n 1. card R \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card R \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>\\<not>tautology R\\<close> and \\<open>finite R\\<close>  and \\<open>card R \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology R\n  finite R\n  card R \\<noteq> 0", "obtain \"LR\" \n              where \"strictly_maximal_literal R LR\""], ["proof (prove)\nusing this:\n  \\<not> tautology R\n  finite R\n  card R \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>LR.\n        strictly_maximal_literal R LR \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using strictly_maximal_literal_exists"], ["proof (prove)\nusing this:\n  \\<not> tautology R\n  finite R\n  card R \\<noteq> 0\n  \\<forall>C.\n     finite C \\<and>\n     card C = ?n \\<and>\n     ?n \\<noteq> 0 \\<and> \\<not> tautology C \\<longrightarrow>\n     (\\<exists>A. strictly_maximal_literal C A)\n\ngoal (1 subgoal):\n 1. (\\<And>LR.\n        strictly_maximal_literal R LR \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strictly_maximal_literal R LR\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "obtain AR and AR' where \"AR = atom LR\" and \"AR' = atom LR'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AR AR'.\n        \\<lbrakk>AR = atom LR; AR' = atom LR'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  AR = atom LR\n  AR' = atom LR'\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>subsumes R' R\\<close> and \\<open>AR = atom LR\\<close> and \\<open>AR' = atom LR'\\<close> \n              and \\<open>(strictly_maximal_literal R LR)\\<close>\n              and \\<open>(strictly_maximal_literal R' LR')\\<close>"], ["proof (chain)\npicking this:\n  subsumes R' R\n  AR = atom LR\n  AR' = atom LR'\n  strictly_maximal_literal R LR\n  strictly_maximal_literal R' LR'", "have \"(AR' = AR) \\<or> (AR',AR) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  subsumes R' R\n  AR = atom LR\n  AR' = atom LR'\n  strictly_maximal_literal R LR\n  strictly_maximal_literal R' LR'\n\ngoal (1 subgoal):\n 1. AR' = AR \\<or> (AR', AR) \\<in> atom_ordering", "using subsumption_and_max_literal"], ["proof (prove)\nusing this:\n  subsumes R' R\n  AR = atom LR\n  AR' = atom LR'\n  strictly_maximal_literal R LR\n  strictly_maximal_literal R' LR'\n  \\<lbrakk>subsumes ?C1.0 ?C2.0; strictly_maximal_literal ?C1.0 ?L1.0;\n   strictly_maximal_literal ?C2.0 ?L2.0; ?A1.0 = atom ?L1.0;\n   ?A2.0 = atom ?L2.0\\<rbrakk>\n  \\<Longrightarrow> ?A1.0 = ?A2.0 \\<or> (?A1.0, ?A2.0) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. AR' = AR \\<or> (AR', AR) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  AR' = AR \\<or> (AR', AR) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>R = (resolvent_upon D C x)\\<close> and \\<open>AR = atom LR\\<close> \n              and \\<open>strictly_maximal_literal R LR\\<close> \n              and \\<open>strictly_maximal_literal D (Pos x)\\<close> \n              and \\<open>strictly_maximal_literal C L\\<close> and \\<open>L = (Neg x)\\<close>"], ["proof (chain)\npicking this:\n  R = resolvent_upon D C x\n  AR = atom LR\n  strictly_maximal_literal R LR\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x", "have \"(AR,x) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  AR = atom LR\n  strictly_maximal_literal R LR\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x\n\ngoal (1 subgoal):\n 1. (AR, x) \\<in> atom_ordering", "using resolution_and_max_literal"], ["proof (prove)\nusing this:\n  R = resolvent_upon D C x\n  AR = atom LR\n  strictly_maximal_literal R LR\n  strictly_maximal_literal D (Pos x)\n  strictly_maximal_literal C L\n  L = Neg x\n  \\<lbrakk>?R = resolvent_upon ?P1.0 ?P2.0 ?A;\n   strictly_maximal_literal ?P1.0 (Pos ?A);\n   strictly_maximal_literal ?P2.0 (Neg ?A);\n   strictly_maximal_literal ?R ?M\\<rbrakk>\n  \\<Longrightarrow> (atom ?M, ?A) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. (AR, x) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (AR, x) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from \\<open>(AR,x) \\<in> atom_ordering\\<close> and \\<open>(AR' = AR) \\<or> (AR',AR) \\<in> atom_ordering\\<close>"], ["proof (chain)\npicking this:\n  (AR, x) \\<in> atom_ordering\n  AR' = AR \\<or> (AR', AR) \\<in> atom_ordering", "have \"(AR',x) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  (AR, x) \\<in> atom_ordering\n  AR' = AR \\<or> (AR', AR) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. (AR', x) \\<in> atom_ordering", "using atom_ordering_trans"], ["proof (prove)\nusing this:\n  (AR, x) \\<in> atom_ordering\n  AR' = AR \\<or> (AR', AR) \\<in> atom_ordering\n  \\<forall>x y z.\n     (x, y) \\<in> atom_ordering \\<longrightarrow>\n     (y, z) \\<in> atom_ordering \\<longrightarrow> (x, z) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. (AR', x) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (AR', x) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from this and hyp_induct and \\<open>R' \\<in> S\\<close> and \\<open>strictly_maximal_literal R' LR'\\<close> \n              and \\<open>AR' = atom LR'\\<close>"], ["proof (chain)\npicking this:\n  (AR', x) \\<in> atom_ordering\n  \\<forall>y.\n     (y, x) \\<in> atom_ordering \\<longrightarrow>\n     (\\<forall>C L.\n         C \\<in> S \\<longrightarrow>\n         strictly_maximal_literal C L \\<longrightarrow>\n         y = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C)\n  R' \\<in> S\n  strictly_maximal_literal R' LR'\n  AR' = atom LR'", "have \"validate_clause (canonic_int_ordered S) R'\""], ["proof (prove)\nusing this:\n  (AR', x) \\<in> atom_ordering\n  \\<forall>y.\n     (y, x) \\<in> atom_ordering \\<longrightarrow>\n     (\\<forall>C L.\n         C \\<in> S \\<longrightarrow>\n         strictly_maximal_literal C L \\<longrightarrow>\n         y = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C)\n  R' \\<in> S\n  strictly_maximal_literal R' LR'\n  AR' = atom LR'\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> R'", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> R'\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> C \\<Longrightarrow> False", "from this and \\<open>subsumes R' R\\<close> and \\<open>\\<not>validate_clause (canonic_int_ordered S) R\\<close>"], ["proof (chain)\npicking this:\n  canonic_int_ordered S \\<Turnstile> R'\n  subsumes R' R\n  \\<not> canonic_int_ordered S \\<Turnstile> R", "show \"False\""], ["proof (prove)\nusing this:\n  canonic_int_ordered S \\<Turnstile> R'\n  subsumes R' R\n  \\<not> canonic_int_ordered S \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. False", "using subsumption_and_semantics"], ["proof (prove)\nusing this:\n  canonic_int_ordered S \\<Turnstile> R'\n  subsumes R' R\n  \\<not> canonic_int_ordered S \\<Turnstile> R\n  \\<lbrakk>subsumes ?C ?D; ?I \\<Turnstile> ?C\\<rbrakk>\n  \\<Longrightarrow> ?I \\<Turnstile> ?D\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C L.\n     C \\<in> S \\<longrightarrow>\n     strictly_maximal_literal C L \\<longrightarrow>\n     x = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C L.\n     C \\<in> S \\<longrightarrow>\n     strictly_maximal_literal C L \\<longrightarrow>\n     A = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow>\n    canonic_int_ordered S \\<Turnstile> C", "from inductive_lemma and \\<open>C \\<in> S\\<close> and \\<open>strictly_maximal_literal C L\\<close> and \\<open>A = atom L\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>C L.\n     C \\<in> S \\<longrightarrow>\n     strictly_maximal_literal C L \\<longrightarrow>\n     A = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C\n  C \\<in> S\n  strictly_maximal_literal C L\n  A = atom L", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>C L.\n     C \\<in> S \\<longrightarrow>\n     strictly_maximal_literal C L \\<longrightarrow>\n     A = atom L \\<longrightarrow> canonic_int_ordered S \\<Turnstile> C\n  C \\<in> S\n  strictly_maximal_literal C L\n  A = atom L\n\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> C", "by blast"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ordered_resolution_is_complete :\n  \"Complete ordered_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete ordered_resolvent", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Complete ordered_resolvent \\<Longrightarrow> False", "assume \"\\<not> Complete ordered_resolvent\""], ["proof (state)\nthis:\n  \\<not> Complete ordered_resolvent\n\ngoal (1 subgoal):\n 1. \\<not> Complete ordered_resolvent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Complete ordered_resolvent", "obtain S where \"saturated_binary_rule ordered_resolvent S\"\n    and \"all_fulfill finite S\" and \"{} \\<notin> S\" and \"\\<not>satisfiable S\""], ["proof (prove)\nusing this:\n  \\<not> Complete ordered_resolvent\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>saturated_binary_rule ordered_resolvent S;\n         all_fulfill finite S; {} \\<notin> S; \\<not> satisfiable S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Complete_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>S.\n             saturated_binary_rule ordered_resolvent S \\<longrightarrow>\n             all_fulfill finite S \\<longrightarrow>\n             {} \\<notin> S \\<longrightarrow> satisfiable S)\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>saturated_binary_rule ordered_resolvent S;\n         all_fulfill finite S; {} \\<notin> S; \\<not> satisfiable S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  saturated_binary_rule ordered_resolvent S\n  all_fulfill finite S\n  {} \\<notin> S\n  \\<not> satisfiable S\n\ngoal (1 subgoal):\n 1. \\<not> Complete ordered_resolvent \\<Longrightarrow> False", "have \"validate_formula (canonic_int_ordered S) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered S \\<Turnstile> S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> S \\<Longrightarrow> False", "assume \"\\<not>validate_formula (canonic_int_ordered S) S\""], ["proof (state)\nthis:\n  \\<not> canonic_int_ordered S \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> S \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_ordered S \\<Turnstile> S", "obtain C where \"C \\<in> S\" and \"\\<not>validate_clause (canonic_int_ordered S) C\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_ordered S \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> S;\n         \\<not> canonic_int_ordered S \\<Turnstile> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> S\n  \\<not> canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered S \\<Turnstile> S \\<Longrightarrow> False", "from \\<open>saturated_binary_rule ordered_resolvent S\\<close> and \\<open>all_fulfill finite S\\<close> and \\<open>{} \\<notin> S\\<close> \n      and \\<open>C \\<in> S\\<close> and \\<open>\\<not>validate_clause (canonic_int_ordered S) C\\<close>"], ["proof (chain)\npicking this:\n  saturated_binary_rule ordered_resolvent S\n  all_fulfill finite S\n  {} \\<notin> S\n  C \\<in> S\n  \\<not> canonic_int_ordered S \\<Turnstile> C", "show \"False\""], ["proof (prove)\nusing this:\n  saturated_binary_rule ordered_resolvent S\n  all_fulfill finite S\n  {} \\<notin> S\n  C \\<in> S\n  \\<not> canonic_int_ordered S \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. False", "using canonic_int_validates_all_clauses"], ["proof (prove)\nusing this:\n  saturated_binary_rule ordered_resolvent S\n  all_fulfill finite S\n  {} \\<notin> S\n  C \\<in> S\n  \\<not> canonic_int_ordered S \\<Turnstile> C\n  \\<lbrakk>saturated_binary_rule ordered_resolvent ?S;\n   all_fulfill finite ?S; {} \\<notin> ?S; ?C \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> canonic_int_ordered ?S \\<Turnstile> ?C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canonic_int_ordered S \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<not> Complete ordered_resolvent \\<Longrightarrow> False", "from \\<open>validate_formula (canonic_int_ordered S) S\\<close> and \\<open>\\<not>satisfiable S\\<close>"], ["proof (chain)\npicking this:\n  canonic_int_ordered S \\<Turnstile> S\n  \\<not> satisfiable S", "show \"False\""], ["proof (prove)\nusing this:\n  canonic_int_ordered S \\<Turnstile> S\n  \\<not> satisfiable S\n\ngoal (1 subgoal):\n 1. False", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  canonic_int_ordered S \\<Turnstile> S\n  \\<nexists>I. I \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Ordered Resolution with Selection\\<close>"], ["", "text \\<open>We now consider the case where some negative literals are considered with highest priority. \nThe proof reuses the canonic interpretation defined in the previous section. \nThe interpretation is constructed using only clauses with no selected literals. By the previous \nresult, all such clauses must be satisfied. We then show that the property carries over to the \nclauses with non empty selected part.\\<close>"], ["", "definition \"empty_selected_part Sel S = { C. C \\<in> S \\<and> (selected_part Sel C) = {} }\""], ["", "lemma saturated_ordered_sel_res_empty_sel : \n  assumes \"saturated_binary_rule (ordered_sel_resolvent Sel) S\"\n  shows \"saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "assume \"\\<not>saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\""], ["proof (state)\nthis:\n  \\<not> saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)", "obtain P1 and P2 and C\n    where \"P1 \\<in> empty_selected_part Sel S\" and \"P2 \\<in> empty_selected_part Sel S\" \n      and \"ordered_resolvent P1 P2 C\"\n      and \"\\<not>redundant C (empty_selected_part Sel S)\""], ["proof (prove)\nusing this:\n  \\<not> saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> empty_selected_part Sel S;\n         P2 \\<in> empty_selected_part Sel S; ordered_resolvent P1 P2 C;\n         \\<not> redundant C (empty_selected_part Sel S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \"saturated_binary_rule_def\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             P1 \\<in> empty_selected_part Sel S \\<and>\n             P2 \\<in> empty_selected_part Sel S \\<and>\n             ordered_resolvent P1 P2 C \\<longrightarrow>\n             redundant C (empty_selected_part Sel S))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> empty_selected_part Sel S;\n         P2 \\<in> empty_selected_part Sel S; ordered_resolvent P1 P2 C;\n         \\<not> redundant C (empty_selected_part Sel S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> empty_selected_part Sel S\n  P2 \\<in> empty_selected_part Sel S\n  ordered_resolvent P1 P2 C\n  \\<not> redundant C (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from \\<open>ordered_resolvent P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  ordered_resolvent P1 P2 C", "obtain A where \"C = ( (P1 - { Pos A}) \\<union> ( P2 - { Neg A }))\"\n      and \"strictly_maximal_literal P1 (Pos A)\" and  \"strictly_maximal_literal P2 (Neg A)\""], ["proof (prove)\nusing this:\n  ordered_resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>C = P1 - {Pos A} \\<union> (P2 - {Neg A});\n         strictly_maximal_literal P1 (Pos A);\n         strictly_maximal_literal P2 (Neg A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ordered_resolvent_def"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     C = P1 - {Pos A} \\<union> (P2 - {Neg A}) \\<and>\n     strictly_maximal_literal P1 (Pos A) \\<and>\n     strictly_maximal_literal P2 (Neg A)\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>C = P1 - {Pos A} \\<union> (P2 - {Neg A});\n         strictly_maximal_literal P1 (Pos A);\n         strictly_maximal_literal P2 (Neg A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  strictly_maximal_literal P1 (Pos A)\n  strictly_maximal_literal P2 (Neg A)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from  \\<open>P1 \\<in> empty_selected_part Sel S\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> empty_selected_part Sel S", "have \"selected_part Sel P1 = {}\""], ["proof (prove)\nusing this:\n  P1 \\<in> empty_selected_part Sel S\n\ngoal (1 subgoal):\n 1. selected_part Sel P1 = {}", "unfolding empty_selected_part_def"], ["proof (prove)\nusing this:\n  P1 \\<in> {C \\<in> S. selected_part Sel C = {}}\n\ngoal (1 subgoal):\n 1. selected_part Sel P1 = {}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel P1 = {}\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from  \\<open>P2 \\<in> empty_selected_part Sel S\\<close>"], ["proof (chain)\npicking this:\n  P2 \\<in> empty_selected_part Sel S", "have \"selected_part Sel P2 = {}\""], ["proof (prove)\nusing this:\n  P2 \\<in> empty_selected_part Sel S\n\ngoal (1 subgoal):\n 1. selected_part Sel P2 = {}", "unfolding empty_selected_part_def"], ["proof (prove)\nusing this:\n  P2 \\<in> {C \\<in> S. selected_part Sel C = {}}\n\ngoal (1 subgoal):\n 1. selected_part Sel P2 = {}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel P2 = {}\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from \\<open>C = ( (P1 - { Pos A}) \\<union> ( P2 - { Neg A }))\\<close> and \\<open>strictly_maximal_literal P1 (Pos A)\\<close> \n    and \\<open>strictly_maximal_literal P2 (Neg A)\\<close> and \\<open>(selected_part Sel P1) = {}\\<close> \n    and \\<open>selected_part Sel P2 = {}\\<close>"], ["proof (chain)\npicking this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  strictly_maximal_literal P1 (Pos A)\n  strictly_maximal_literal P2 (Neg A)\n  selected_part Sel P1 = {}\n  selected_part Sel P2 = {}", "have \"ordered_sel_resolvent Sel P1 P2 C\""], ["proof (prove)\nusing this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  strictly_maximal_literal P1 (Pos A)\n  strictly_maximal_literal P2 (Neg A)\n  selected_part Sel P1 = {}\n  selected_part Sel P2 = {}\n\ngoal (1 subgoal):\n 1. ordered_sel_resolvent Sel P1 P2 C", "unfolding ordered_sel_resolvent_def"], ["proof (prove)\nusing this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  strictly_maximal_literal P1 (Pos A)\n  strictly_maximal_literal P2 (Neg A)\n  selected_part Sel P1 = {}\n  selected_part Sel P2 = {}\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       C = P1 - {Pos A} \\<union> (P2 - {Neg A}) \\<and>\n       strictly_maximal_literal P1 (Pos A) \\<and>\n       selected_part Sel P1 = {} \\<and>\n       (strictly_maximal_literal P2 (Neg A) \\<and>\n        selected_part Sel P2 = {} \\<or>\n        strictly_maximal_literal (selected_part Sel P2) (Neg A))", "by auto"], ["proof (state)\nthis:\n  ordered_sel_resolvent Sel P1 P2 C\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from \\<open>saturated_binary_rule (ordered_sel_resolvent Sel) S\\<close>"], ["proof (chain)\npicking this:\n  saturated_binary_rule (ordered_sel_resolvent Sel) S", "have \"\\<forall>P1 P2 C. (P1 \\<in> S \\<and> P2 \\<in> S \\<and> (ordered_sel_resolvent Sel P1 P2 C)) \\<longrightarrow> redundant C S\""], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_sel_resolvent Sel) S\n\ngoal (1 subgoal):\n 1. \\<forall>P1 P2 C.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and> ordered_sel_resolvent Sel P1 P2 C \\<longrightarrow>\n       redundant C S", "unfolding saturated_binary_rule_def"], ["proof (prove)\nusing this:\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and> ordered_sel_resolvent Sel P1 P2 C \\<longrightarrow>\n     redundant C S\n\ngoal (1 subgoal):\n 1. \\<forall>P1 P2 C.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and> ordered_sel_resolvent Sel P1 P2 C \\<longrightarrow>\n       redundant C S", "by auto"], ["proof (state)\nthis:\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and> ordered_sel_resolvent Sel P1 P2 C \\<longrightarrow>\n     redundant C S\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from this and \\<open>P1 \\<in> (empty_selected_part Sel S)\\<close> and \\<open>P2 \\<in> (empty_selected_part Sel S)\\<close> \n    and \\<open>ordered_sel_resolvent Sel P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and> ordered_sel_resolvent Sel P1 P2 C \\<longrightarrow>\n     redundant C S\n  P1 \\<in> empty_selected_part Sel S\n  P2 \\<in> empty_selected_part Sel S\n  ordered_sel_resolvent Sel P1 P2 C", "have \"tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\""], ["proof (prove)\nusing this:\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and> ordered_sel_resolvent Sel P1 P2 C \\<longrightarrow>\n     redundant C S\n  P1 \\<in> empty_selected_part Sel S\n  P2 \\<in> empty_selected_part Sel S\n  ordered_sel_resolvent Sel P1 P2 C\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)", "unfolding empty_selected_part_def redundant_def"], ["proof (prove)\nusing this:\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and> ordered_sel_resolvent Sel P1 P2 C \\<longrightarrow>\n     tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  P1 \\<in> {C \\<in> S. selected_part Sel C = {}}\n  P2 \\<in> {C \\<in> S. selected_part Sel C = {}}\n  ordered_sel_resolvent Sel P1 P2 C\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)", "by auto"], ["proof (state)\nthis:\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from this and \\<open>tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\\<close> \n      and \\<open>\\<not>redundant C (empty_selected_part Sel S)\\<close>"], ["proof (chain)\npicking this:\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  \\<not> redundant C (empty_selected_part Sel S)", "obtain D where \"D \\<in> S\" and \"subsumes D C\" and \"D \\<notin> empty_selected_part Sel S\""], ["proof (prove)\nusing this:\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  \\<not> redundant C (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> S; subsumes D C;\n         D \\<notin> empty_selected_part Sel S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  \\<not> (tautology C \\<or>\n          (\\<exists>D.\n              D \\<in> empty_selected_part Sel S \\<and> subsumes D C))\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> S; subsumes D C;\n         D \\<notin> empty_selected_part Sel S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D \\<in> S\n  subsumes D C\n  D \\<notin> empty_selected_part Sel S\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from \\<open>D \\<notin> empty_selected_part Sel S\\<close> and \\<open>D \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  D \\<notin> empty_selected_part Sel S\n  D \\<in> S", "obtain B where \"B \\<in> Sel\" and \"Neg B \\<in> D\""], ["proof (prove)\nusing this:\n  D \\<notin> empty_selected_part Sel S\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<in> Sel; Neg B \\<in> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding empty_selected_part_def selected_part_def"], ["proof (prove)\nusing this:\n  D \\<notin> {C \\<in> S. {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A} = {}}\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<in> Sel; Neg B \\<in> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B \\<in> Sel\n  Neg B \\<in> D\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from \\<open>Neg B \\<in> D\\<close> this and \\<open>subsumes D C\\<close>"], ["proof (chain)\npicking this:\n  Neg B \\<in> D\n  B \\<in> Sel\n  Neg B \\<in> D\n  subsumes D C", "have \"Neg B \\<in> C\""], ["proof (prove)\nusing this:\n  Neg B \\<in> D\n  B \\<in> Sel\n  Neg B \\<in> D\n  subsumes D C\n\ngoal (1 subgoal):\n 1. Neg B \\<in> C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  Neg B \\<in> D\n  B \\<in> Sel\n  Neg B \\<in> D\n  D \\<subseteq> C\n\ngoal (1 subgoal):\n 1. Neg B \\<in> C", "by auto"], ["proof (state)\nthis:\n  Neg B \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from this and \\<open>C = ( (P1 - { Pos A}) \\<union> ( P2 - { Neg A }))\\<close>"], ["proof (chain)\npicking this:\n  Neg B \\<in> C\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})", "have \"Neg B \\<in> (P1 \\<union> P2)\""], ["proof (prove)\nusing this:\n  Neg B \\<in> C\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. Neg B \\<in> P1 \\<union> P2", "by auto"], ["proof (state)\nthis:\n  Neg B \\<in> P1 \\<union> P2\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (empty_selected_part Sel S) \\<Longrightarrow>\n    False", "from \\<open>Neg B \\<in> (P1 \\<union> P2)\\<close> and \\<open>P1 \\<in> empty_selected_part Sel S\\<close> \n      and \\<open>P2 \\<in> empty_selected_part Sel S\\<close> and \\<open>B \\<in> Sel\\<close>"], ["proof (chain)\npicking this:\n  Neg B \\<in> P1 \\<union> P2\n  P1 \\<in> empty_selected_part Sel S\n  P2 \\<in> empty_selected_part Sel S\n  B \\<in> Sel", "show \"False\""], ["proof (prove)\nusing this:\n  Neg B \\<in> P1 \\<union> P2\n  P1 \\<in> empty_selected_part Sel S\n  P2 \\<in> empty_selected_part Sel S\n  B \\<in> Sel\n\ngoal (1 subgoal):\n 1. False", "unfolding empty_selected_part_def selected_part_def"], ["proof (prove)\nusing this:\n  Neg B \\<in> P1 \\<union> P2\n  P1 \\<in> {C \\<in> S. {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A} = {}}\n  P2 \\<in> {C \\<in> S. {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A} = {}}\n  B \\<in> Sel\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition ordered_sel_resolvent_upon :: \"'at set \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> 'at Clause \\<Rightarrow> 'at \\<Rightarrow> bool\" \n  where\n  \"ordered_sel_resolvent_upon Sel P1 P2 C A \\<equiv> \n    (((C = ( (P1 - { Pos A}) \\<union> ( P2 - { Neg A })))\n      \\<and> (strictly_maximal_literal P1 (Pos A)) \\<and> ((selected_part Sel P1) = {}) \n      \\<and> ( ((strictly_maximal_literal P2 (Neg A)) \\<and> (selected_part Sel P2) = {})\n         \\<or> (strictly_maximal_literal (selected_part Sel P2) (Neg A)))))\""], ["", "lemma ordered_sel_resolvent_upon_is_resolvent:\n  assumes \"ordered_sel_resolvent_upon Sel P1 P2 C A\"\n  shows \"ordered_sel_resolvent Sel P1 P2 C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_sel_resolvent Sel P1 P2 C", "using assms"], ["proof (prove)\nusing this:\n  ordered_sel_resolvent_upon Sel P1 P2 C A\n\ngoal (1 subgoal):\n 1. ordered_sel_resolvent Sel P1 P2 C", "unfolding ordered_sel_resolvent_upon_def and ordered_sel_resolvent_def"], ["proof (prove)\nusing this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A}) \\<and>\n  strictly_maximal_literal P1 (Pos A) \\<and>\n  selected_part Sel P1 = {} \\<and>\n  (strictly_maximal_literal P2 (Neg A) \\<and>\n   selected_part Sel P2 = {} \\<or>\n   strictly_maximal_literal (selected_part Sel P2) (Neg A))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       C = P1 - {Pos A} \\<union> (P2 - {Neg A}) \\<and>\n       strictly_maximal_literal P1 (Pos A) \\<and>\n       selected_part Sel P1 = {} \\<and>\n       (strictly_maximal_literal P2 (Neg A) \\<and>\n        selected_part Sel P2 = {} \\<or>\n        strictly_maximal_literal (selected_part Sel P2) (Neg A))", "by auto"], ["", "lemma resolution_decreases_selected_part:\n  assumes \"ordered_sel_resolvent_upon Sel P1 P2 C A\"\n  assumes \"Neg A \\<in> P2\"\n  assumes \"finite P1\"\n  assumes \"finite P2\"\n  assumes \"card (selected_part Sel P2) = Suc n\"\n  shows \"card (selected_part Sel C) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from \\<open>finite P2\\<close>"], ["proof (chain)\npicking this:\n  finite P2", "have \"finite (selected_part Sel P2)\""], ["proof (prove)\nusing this:\n  finite P2\n\ngoal (1 subgoal):\n 1. finite (selected_part Sel P2)", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  finite P2\n\ngoal (1 subgoal):\n 1. finite {L \\<in> P2. \\<exists>A\\<in>Sel. L = Neg A}", "by auto"], ["proof (state)\nthis:\n  finite (selected_part Sel P2)\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from \\<open>card (selected_part Sel P2) = (Suc n)\\<close>"], ["proof (chain)\npicking this:\n  card (selected_part Sel P2) = Suc n", "have \"card (selected_part Sel P2) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  card (selected_part Sel P2) = Suc n\n\ngoal (1 subgoal):\n 1. card (selected_part Sel P2) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (selected_part Sel P2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from this and \\<open>finite (selected_part Sel P2)\\<close>"], ["proof (chain)\npicking this:\n  card (selected_part Sel P2) \\<noteq> 0\n  finite (selected_part Sel P2)", "have \"selected_part Sel P2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  card (selected_part Sel P2) \\<noteq> 0\n  finite (selected_part Sel P2)\n\ngoal (1 subgoal):\n 1. selected_part Sel P2 \\<noteq> {}", "using card_0_eq"], ["proof (prove)\nusing this:\n  card (selected_part Sel P2) \\<noteq> 0\n  finite (selected_part Sel P2)\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. selected_part Sel P2 \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel P2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from this and \\<open>ordered_sel_resolvent_upon Sel P1 P2 C A\\<close>"], ["proof (chain)\npicking this:\n  selected_part Sel P2 \\<noteq> {}\n  ordered_sel_resolvent_upon Sel P1 P2 C A", "have \n    \"C = (P1 - { Pos A}) \\<union> ( P2 - { Neg A })\"\n      and \"selected_part Sel P1 = {}\" and  \"strictly_maximal_literal (selected_part Sel P2) (Neg A)\""], ["proof (prove)\nusing this:\n  selected_part Sel P2 \\<noteq> {}\n  ordered_sel_resolvent_upon Sel P1 P2 C A\n\ngoal (1 subgoal):\n 1. C = P1 - {Pos A} \\<union> (P2 - {Neg A}) &&&\n    selected_part Sel P1 = {} &&&\n    strictly_maximal_literal (selected_part Sel P2) (Neg A)", "unfolding ordered_sel_resolvent_upon_def"], ["proof (prove)\nusing this:\n  selected_part Sel P2 \\<noteq> {}\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A}) \\<and>\n  strictly_maximal_literal P1 (Pos A) \\<and>\n  selected_part Sel P1 = {} \\<and>\n  (strictly_maximal_literal P2 (Neg A) \\<and>\n   selected_part Sel P2 = {} \\<or>\n   strictly_maximal_literal (selected_part Sel P2) (Neg A))\n\ngoal (1 subgoal):\n 1. C = P1 - {Pos A} \\<union> (P2 - {Neg A}) &&&\n    selected_part Sel P1 = {} &&&\n    strictly_maximal_literal (selected_part Sel P2) (Neg A)", "by auto"], ["proof (state)\nthis:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  selected_part Sel P1 = {}\n  strictly_maximal_literal (selected_part Sel P2) (Neg A)\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from \\<open>strictly_maximal_literal (selected_part Sel P2) (Neg A)\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal (selected_part Sel P2) (Neg A)", "have \"Neg A \\<in> selected_part Sel P2\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal (selected_part Sel P2) (Neg A)\n\ngoal (1 subgoal):\n 1. Neg A \\<in> selected_part Sel P2", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  Neg A \\<in> selected_part Sel P2 \\<and>\n  (\\<forall>B.\n      B \\<in> selected_part Sel P2 \\<and> Neg A \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Neg A))\n\ngoal (1 subgoal):\n 1. Neg A \\<in> selected_part Sel P2", "by auto"], ["proof (state)\nthis:\n  Neg A \\<in> selected_part Sel P2\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from this"], ["proof (chain)\npicking this:\n  Neg A \\<in> selected_part Sel P2", "have \"A \\<in> Sel\""], ["proof (prove)\nusing this:\n  Neg A \\<in> selected_part Sel P2\n\ngoal (1 subgoal):\n 1. A \\<in> Sel", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  Neg A \\<in> {L \\<in> P2. \\<exists>A\\<in>Sel. L = Neg A}\n\ngoal (1 subgoal):\n 1. A \\<in> Sel", "by auto"], ["proof (state)\nthis:\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from \\<open>selected_part Sel P1 = {}\\<close>"], ["proof (chain)\npicking this:\n  selected_part Sel P1 = {}", "have \"selected_part Sel (P1 - { Pos A}) = {}\""], ["proof (prove)\nusing this:\n  selected_part Sel P1 = {}\n\ngoal (1 subgoal):\n 1. selected_part Sel (P1 - {Pos A}) = {}", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  {L \\<in> P1. \\<exists>A\\<in>Sel. L = Neg A} = {}\n\ngoal (1 subgoal):\n 1. {L \\<in> P1 - {Pos A}. \\<exists>A\\<in>Sel. L = Neg A} = {}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel (P1 - {Pos A}) = {}\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from \\<open>Neg A \\<in> (selected_part Sel P2)\\<close>"], ["proof (chain)\npicking this:\n  Neg A \\<in> selected_part Sel P2", "have \"selected_part Sel (P2 - { Neg A}) = (selected_part Sel P2) - { Neg A }\""], ["proof (prove)\nusing this:\n  Neg A \\<in> selected_part Sel P2\n\ngoal (1 subgoal):\n 1. selected_part Sel (P2 - {Neg A}) = selected_part Sel P2 - {Neg A}", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  Neg A \\<in> {L \\<in> P2. \\<exists>A\\<in>Sel. L = Neg A}\n\ngoal (1 subgoal):\n 1. {L \\<in> P2 - {Neg A}. \\<exists>A\\<in>Sel. L = Neg A} =\n    {L \\<in> P2. \\<exists>A\\<in>Sel. L = Neg A} - {Neg A}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel (P2 - {Neg A}) = selected_part Sel P2 - {Neg A}\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from \\<open>C = ( (P1 - { Pos A}) \\<union> ( P2 - { Neg A }))\\<close>"], ["proof (chain)\npicking this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})", "have\n  \"selected_part Sel C \n    = (selected_part Sel (P1 - { Pos A})) \\<union> (selected_part Sel (P2 - { Neg A}))\""], ["proof (prove)\nusing this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. selected_part Sel C =\n    selected_part Sel (P1 - {Pos A}) \\<union>\n    selected_part Sel (P2 - {Neg A})", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A} =\n    {L \\<in> P1 - {Pos A}. \\<exists>A\\<in>Sel. L = Neg A} \\<union>\n    {L \\<in> P2 - {Neg A}. \\<exists>A\\<in>Sel. L = Neg A}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel C =\n  selected_part Sel (P1 - {Pos A}) \\<union> selected_part Sel (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from this and \\<open>selected_part Sel (P1 - { Pos A}) = {}\\<close>\n    and \\<open>selected_part Sel (P2 - { Neg A}) = selected_part Sel P2 - { Neg A }\\<close>"], ["proof (chain)\npicking this:\n  selected_part Sel C =\n  selected_part Sel (P1 - {Pos A}) \\<union> selected_part Sel (P2 - {Neg A})\n  selected_part Sel (P1 - {Pos A}) = {}\n  selected_part Sel (P2 - {Neg A}) = selected_part Sel P2 - {Neg A}", "have \"selected_part Sel C = selected_part Sel P2 - { Neg A }\""], ["proof (prove)\nusing this:\n  selected_part Sel C =\n  selected_part Sel (P1 - {Pos A}) \\<union> selected_part Sel (P2 - {Neg A})\n  selected_part Sel (P1 - {Pos A}) = {}\n  selected_part Sel (P2 - {Neg A}) = selected_part Sel P2 - {Neg A}\n\ngoal (1 subgoal):\n 1. selected_part Sel C = selected_part Sel P2 - {Neg A}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel C = selected_part Sel P2 - {Neg A}\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from \\<open>Neg A \\<in> P2\\<close> and \\<open>A \\<in> Sel\\<close>"], ["proof (chain)\npicking this:\n  Neg A \\<in> P2\n  A \\<in> Sel", "have \"Neg A \\<in> selected_part Sel P2\""], ["proof (prove)\nusing this:\n  Neg A \\<in> P2\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. Neg A \\<in> selected_part Sel P2", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  Neg A \\<in> P2\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. Neg A \\<in> {L \\<in> P2. \\<exists>A\\<in>Sel. L = Neg A}", "by auto"], ["proof (state)\nthis:\n  Neg A \\<in> selected_part Sel P2\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from this and \\<open>selected_part Sel C = (selected_part Sel P2) - { Neg A }\\<close> \n    and \\<open>finite (selected_part Sel P2)\\<close>"], ["proof (chain)\npicking this:\n  Neg A \\<in> selected_part Sel P2\n  selected_part Sel C = selected_part Sel P2 - {Neg A}\n  finite (selected_part Sel P2)", "have \"card (selected_part Sel C) = card (selected_part Sel P2) - 1\""], ["proof (prove)\nusing this:\n  Neg A \\<in> selected_part Sel P2\n  selected_part Sel C = selected_part Sel P2 - {Neg A}\n  finite (selected_part Sel P2)\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = card (selected_part Sel P2) - 1", "by auto"], ["proof (state)\nthis:\n  card (selected_part Sel C) = card (selected_part Sel P2) - 1\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "from this and \\<open>card (selected_part Sel P2) = Suc n\\<close>"], ["proof (chain)\npicking this:\n  card (selected_part Sel C) = card (selected_part Sel P2) - 1\n  card (selected_part Sel P2) = Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  card (selected_part Sel C) = card (selected_part Sel P2) - 1\n  card (selected_part Sel P2) = Suc n\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) = n", "by auto"], ["proof (state)\nthis:\n  card (selected_part Sel C) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma canonic_int_validates_all_clauses_sel : \n  assumes \"saturated_binary_rule (ordered_sel_resolvent Sel) S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"{} \\<notin> S\"\n  assumes \"C \\<in> S\"\n  shows \"validate_clause (canonic_int_ordered (empty_selected_part Sel S)) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "let ?nat_order = \"{ (x::nat,y::nat). x < y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "let ?SE = \"empty_selected_part Sel S\""], ["proof (state)\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "let ?I = \"canonic_int_ordered ?SE\""], ["proof (state)\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "obtain n where \"n = card (selected_part Sel C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n = card (selected_part Sel C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = card (selected_part Sel C)\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "have \"\\<forall>C. card (selected_part Sel C) = n \\<longrightarrow> C \\<in> S \\<longrightarrow> validate_clause ?I C\" (is \"?P n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       card (selected_part Sel C) = n \\<longrightarrow>\n       C \\<in> S \\<longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "proof ((rule wf_induct [of ?nat_order ?P n]), (simp add:wf))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> {(x, y). x < y} \\<longrightarrow>\n          (\\<forall>C.\n              card (selected_part Sel C) = y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n              C) \\<Longrightarrow>\n       \\<forall>C.\n          card (selected_part Sel C) = x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> {(x, y). x < y} \\<longrightarrow>\n          (\\<forall>C.\n              card (selected_part Sel C) = y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n              C) \\<Longrightarrow>\n       \\<forall>C.\n          card (selected_part Sel C) = x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> {(x, y). x < y} \\<longrightarrow>\n          (\\<forall>C.\n              card (selected_part Sel C) = y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n              C) \\<Longrightarrow>\n       \\<forall>C.\n          card (selected_part Sel C) = x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "assume ind_hyp: \"\\<forall>m. (m,n) \\<in> ?nat_order \\<longrightarrow> (?P m)\""], ["proof (state)\nthis:\n  \\<forall>m.\n     (m, n) \\<in> {(x, y). x < y} \\<longrightarrow>\n     (\\<forall>C.\n         card (selected_part Sel C) = m \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> {(x, y). x < y} \\<longrightarrow>\n          (\\<forall>C.\n              card (selected_part Sel C) = y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n              C) \\<Longrightarrow>\n       \\<forall>C.\n          card (selected_part Sel C) = x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "show \"(?P n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       card (selected_part Sel C) = n \\<longrightarrow>\n       C \\<in> S \\<longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "proof (rule+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card (selected_part Sel C) = n; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> canonic_int_ordered\n                          (empty_selected_part Sel S) \\<Turnstile>\n                         C", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card (selected_part Sel C) = n; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> canonic_int_ordered\n                          (empty_selected_part Sel S) \\<Turnstile>\n                         C", "assume \"card (selected_part Sel C) = n\" and \"C \\<in> S\""], ["proof (state)\nthis:\n  card (selected_part Sel C) = n\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card (selected_part Sel C) = n; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> canonic_int_ordered\n                          (empty_selected_part Sel S) \\<Turnstile>\n                         C", "from \\<open>all_fulfill finite S\\<close> and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S\n  C \\<in> S", "have \"finite C\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite C", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite C", "by auto"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card (selected_part Sel C) = n; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> canonic_int_ordered\n                          (empty_selected_part Sel S) \\<Turnstile>\n                         C", "from this"], ["proof (chain)\npicking this:\n  finite C", "have \"finite (selected_part Sel C)\""], ["proof (prove)\nusing this:\n  finite C\n\ngoal (1 subgoal):\n 1. finite (selected_part Sel C)", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  finite C\n\ngoal (1 subgoal):\n 1. finite {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A}", "by auto"], ["proof (state)\nthis:\n  finite (selected_part Sel C)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>card (selected_part Sel C) = n; C \\<in> S\\<rbrakk>\n       \\<Longrightarrow> canonic_int_ordered\n                          (empty_selected_part Sel S) \\<Turnstile>\n                         C", "show \"validate_clause ?I  C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "proof (rule nat.exhaust [of \"n\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n 2. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "assume \"n = 0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n 2. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "from this and \\<open>card (selected_part Sel C) = n\\<close> and \\<open>finite (selected_part Sel C)\\<close>"], ["proof (chain)\npicking this:\n  n = 0\n  card (selected_part Sel C) = n\n  finite (selected_part Sel C)", "have \"selected_part Sel C = {}\""], ["proof (prove)\nusing this:\n  n = 0\n  card (selected_part Sel C) = n\n  finite (selected_part Sel C)\n\ngoal (1 subgoal):\n 1. selected_part Sel C = {}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel C = {}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n 2. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "from \\<open>saturated_binary_rule (ordered_sel_resolvent Sel) S\\<close>"], ["proof (chain)\npicking this:\n  saturated_binary_rule (ordered_sel_resolvent Sel) S", "have \"saturated_binary_rule ordered_resolvent ?SE\""], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_sel_resolvent Sel) S\n\ngoal (1 subgoal):\n 1. saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)", "using saturated_ordered_sel_res_empty_sel"], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_sel_resolvent Sel) S\n  saturated_binary_rule (ordered_sel_resolvent ?Sel) ?S \\<Longrightarrow>\n  saturated_binary_rule ordered_resolvent (empty_selected_part ?Sel ?S)\n\ngoal (1 subgoal):\n 1. saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)", "by auto"], ["proof (state)\nthis:\n  saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n 2. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "from \\<open>{} \\<notin> S\\<close>"], ["proof (chain)\npicking this:\n  {} \\<notin> S", "have \"{} \\<notin> ?SE\""], ["proof (prove)\nusing this:\n  {} \\<notin> S\n\ngoal (1 subgoal):\n 1. {} \\<notin> empty_selected_part Sel S", "unfolding empty_selected_part_def"], ["proof (prove)\nusing this:\n  {} \\<notin> S\n\ngoal (1 subgoal):\n 1. {} \\<notin> {C \\<in> S. selected_part Sel C = {}}", "by auto"], ["proof (state)\nthis:\n  {} \\<notin> empty_selected_part Sel S\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n 2. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "from \\<open>selected_part Sel C = {}\\<close> \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  selected_part Sel C = {}\n  C \\<in> S", "have \"C \\<in> ?SE\""], ["proof (prove)\nusing this:\n  selected_part Sel C = {}\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. C \\<in> empty_selected_part Sel S", "unfolding empty_selected_part_def"], ["proof (prove)\nusing this:\n  selected_part Sel C = {}\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. C \\<in> {C \\<in> S. selected_part Sel C = {}}", "by auto"], ["proof (state)\nthis:\n  C \\<in> empty_selected_part Sel S\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n 2. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "from \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S", "have \"all_fulfill finite ?SE\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. all_fulfill finite (empty_selected_part Sel S)", "unfolding empty_selected_part_def all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       C \\<in> {C \\<in> S. selected_part Sel C = {}} \\<longrightarrow>\n       finite C", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite (empty_selected_part Sel S)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n 2. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "from this  and \\<open>saturated_binary_rule ordered_resolvent ?SE\\<close> and \\<open>{} \\<notin> ?SE\\<close> and \\<open>C \\<in> ?SE\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite (empty_selected_part Sel S)\n  saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\n  {} \\<notin> empty_selected_part Sel S\n  C \\<in> empty_selected_part Sel S", "show \"validate_clause ?I C\""], ["proof (prove)\nusing this:\n  all_fulfill finite (empty_selected_part Sel S)\n  saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\n  {} \\<notin> empty_selected_part Sel S\n  C \\<in> empty_selected_part Sel S\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "using canonic_int_validates_all_clauses"], ["proof (prove)\nusing this:\n  all_fulfill finite (empty_selected_part Sel S)\n  saturated_binary_rule ordered_resolvent (empty_selected_part Sel S)\n  {} \\<notin> empty_selected_part Sel S\n  C \\<in> empty_selected_part Sel S\n  \\<lbrakk>saturated_binary_rule ordered_resolvent ?S;\n   all_fulfill finite ?S; {} \\<notin> ?S; ?C \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> canonic_int_ordered ?S \\<Turnstile> ?C\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "assume \"n = Suc m\""], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "from this and \\<open>card (selected_part Sel C) = n\\<close>"], ["proof (chain)\npicking this:\n  n = Suc m\n  card (selected_part Sel C) = n", "have \"selected_part Sel C \\<noteq> {}\""], ["proof (prove)\nusing this:\n  n = Suc m\n  card (selected_part Sel C) = n\n\ngoal (1 subgoal):\n 1. selected_part Sel C \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       n = Suc x2 \\<Longrightarrow>\n       canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "show \"validate_clause ?I C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n           C \\<Longrightarrow>\n    False", "assume \"\\<not>validate_clause ?I C\""], ["proof (state)\nthis:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n           C \\<Longrightarrow>\n    False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"tautology C\""], ["proof (state)\nthis:\n  tautology C\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from \\<open>tautology C\\<close> and \\<open>\\<not>validate_clause ?I C\\<close>"], ["proof (chain)\npicking this:\n  tautology C\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "show \"False\""], ["proof (prove)\nusing this:\n  tautology C\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. False", "using tautologies_are_valid"], ["proof (prove)\nusing this:\n  tautology C\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n  tautology ?C \\<Longrightarrow> ?I \\<Turnstile> ?C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "assume \"\\<not>(tautology C)\""], ["proof (state)\nthis:\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "hence \"\\<not>(tautology (selected_part Sel C))\""], ["proof (prove)\nusing this:\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> tautology (selected_part Sel C)", "unfolding selected_part_def tautology_def"], ["proof (prove)\nusing this:\n  \\<nexists>A. Pos A \\<in> C \\<and> Neg A \\<in> C\n\ngoal (1 subgoal):\n 1. \\<nexists>A.\n       Pos A \\<in> {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A} \\<and>\n       Neg A \\<in> {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A}", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology (selected_part Sel C)\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from \\<open>selected_part Sel C \\<noteq> {}\\<close> and \\<open>finite (selected_part Sel C)\\<close>"], ["proof (chain)\npicking this:\n  selected_part Sel C \\<noteq> {}\n  finite (selected_part Sel C)", "have \"card (selected_part Sel C) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  selected_part Sel C \\<noteq> {}\n  finite (selected_part Sel C)\n\ngoal (1 subgoal):\n 1. card (selected_part Sel C) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (selected_part Sel C) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from this and \\<open>\\<not>(tautology (selected_part Sel C))\\<close> and \\<open>finite (selected_part Sel C)\\<close>"], ["proof (chain)\npicking this:\n  card (selected_part Sel C) \\<noteq> 0\n  \\<not> tautology (selected_part Sel C)\n  finite (selected_part Sel C)", "obtain L where \"strictly_maximal_literal (selected_part Sel C) L\""], ["proof (prove)\nusing this:\n  card (selected_part Sel C) \\<noteq> 0\n  \\<not> tautology (selected_part Sel C)\n  finite (selected_part Sel C)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        strictly_maximal_literal (selected_part Sel C) L \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using strictly_maximal_literal_exists [of \"card (selected_part Sel C)\"]"], ["proof (prove)\nusing this:\n  card (selected_part Sel C) \\<noteq> 0\n  \\<not> tautology (selected_part Sel C)\n  finite (selected_part Sel C)\n  \\<forall>C.\n     finite C \\<and>\n     card C = card (selected_part Sel C) \\<and>\n     card (selected_part Sel C) \\<noteq> 0 \\<and>\n     \\<not> tautology C \\<longrightarrow>\n     (\\<exists>A. strictly_maximal_literal C A)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        strictly_maximal_literal (selected_part Sel C) L \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strictly_maximal_literal (selected_part Sel C) L\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from \\<open>strictly_maximal_literal (selected_part Sel C) L\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal (selected_part Sel C) L", "have \"L \\<in> (selected_part Sel C)\" \n              and \"L \\<in> C\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal (selected_part Sel C) L\n\ngoal (1 subgoal):\n 1. L \\<in> selected_part Sel C &&& L \\<in> C", "unfolding strictly_maximal_literal_def selected_part_def"], ["proof (prove)\nusing this:\n  L \\<in> {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A} \\<and>\n  (\\<forall>B.\n      B \\<in> {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A} \\<and>\n      L \\<noteq> B \\<longrightarrow>\n      literal_ordering B L)\n\ngoal (1 subgoal):\n 1. L \\<in> {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A} &&& L \\<in> C", "by auto"], ["proof (state)\nthis:\n  L \\<in> selected_part Sel C\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from this and \\<open>\\<not>validate_clause ?I C\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> selected_part Sel C\n  L \\<in> C\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "have \"\\<not>(validate_literal ?I L)\""], ["proof (prove)\nusing this:\n  L \\<in> selected_part Sel C\n  L \\<in> C\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L", "by auto"], ["proof (state)\nthis:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from \\<open>L \\<in> (selected_part Sel C)\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> selected_part Sel C", "obtain A where \"L = (Neg A)\" and \"A \\<in> Sel\""], ["proof (prove)\nusing this:\n  L \\<in> selected_part Sel C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>L = Neg A; A \\<in> Sel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  L \\<in> {L \\<in> C. \\<exists>A\\<in>Sel. L = Neg A}\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>L = Neg A; A \\<in> Sel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Neg A\n  A \\<in> Sel\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from \\<open>\\<not>(validate_literal ?I L)\\<close> and \\<open>L = (Neg A)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L\n  L = Neg A", "have \"A \\<in> ?I\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L\n  L = Neg A\n\ngoal (1 subgoal):\n 1. A \\<in> canonic_int_ordered (empty_selected_part Sel S)", "by auto"], ["proof (state)\nthis:\n  A \\<in> canonic_int_ordered (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  A \\<in> canonic_int_ordered (empty_selected_part Sel S)", "have \"((canonic_int_fun_ordered A) ?SE)\""], ["proof (prove)\nusing this:\n  A \\<in> canonic_int_ordered (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. canonic_int_fun_ordered A (empty_selected_part Sel S)", "unfolding canonic_int_ordered_def"], ["proof (prove)\nusing this:\n  A \\<in> {A. canonic_int_fun_ordered A (empty_selected_part Sel S)}\n\ngoal (1 subgoal):\n 1. canonic_int_fun_ordered A (empty_selected_part Sel S)", "by blast"], ["proof (state)\nthis:\n  canonic_int_fun_ordered A (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "have \"((\\<exists> C. (C \\<in> ?SE) \\<and> (strictly_maximal_literal C (Pos A) ) \n                \\<and> ( \\<forall> B. ( Pos B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \n                  \\<longrightarrow> (\\<not>(canonic_int_fun_ordered B) ?SE)))\n                \\<and> ( \\<forall> B. ( Neg B \\<in> C \\<longrightarrow> (B, A) \\<in> atom_ordering \n                  \\<longrightarrow> ((canonic_int_fun_ordered B) ?SE)))))\" (is ?exp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       C \\<in> empty_selected_part Sel S \\<and>\n       strictly_maximal_literal C (Pos A) \\<and>\n       (\\<forall>B.\n           Pos B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           \\<not> canonic_int_fun_ordered B\n                   (empty_selected_part Sel S)) \\<and>\n       (\\<forall>B.\n           Neg B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           canonic_int_fun_ordered B (empty_selected_part Sel S))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>C.\n       C \\<in> empty_selected_part Sel S \\<and>\n       strictly_maximal_literal C (Pos A) \\<and>\n       (\\<forall>B.\n           Pos B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           \\<not> canonic_int_fun_ordered B\n                   (empty_selected_part Sel S)) \\<and>\n       (\\<forall>B.\n           Neg B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           canonic_int_fun_ordered B\n            (empty_selected_part Sel S)) \\<Longrightarrow>\n    False", "assume \"\\<not> ?exp\""], ["proof (state)\nthis:\n  \\<nexists>C.\n     C \\<in> empty_selected_part Sel S \\<and>\n     strictly_maximal_literal C (Pos A) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B\n                 (empty_selected_part Sel S)) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B (empty_selected_part Sel S))\n\ngoal (1 subgoal):\n 1. \\<nexists>C.\n       C \\<in> empty_selected_part Sel S \\<and>\n       strictly_maximal_literal C (Pos A) \\<and>\n       (\\<forall>B.\n           Pos B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           \\<not> canonic_int_fun_ordered B\n                   (empty_selected_part Sel S)) \\<and>\n       (\\<forall>B.\n           Neg B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           canonic_int_fun_ordered B\n            (empty_selected_part Sel S)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<nexists>C.\n     C \\<in> empty_selected_part Sel S \\<and>\n     strictly_maximal_literal C (Pos A) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B\n                 (empty_selected_part Sel S)) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B (empty_selected_part Sel S))", "have \"\\<not>((canonic_int_fun_ordered A) ?SE)\""], ["proof (prove)\nusing this:\n  \\<nexists>C.\n     C \\<in> empty_selected_part Sel S \\<and>\n     strictly_maximal_literal C (Pos A) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B\n                 (empty_selected_part Sel S)) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B (empty_selected_part Sel S))\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_fun_ordered A (empty_selected_part Sel S)", "by ((simp only:canonic_int_fun_ordered.simps [of A]), blast)"], ["proof (state)\nthis:\n  \\<not> canonic_int_fun_ordered A (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. \\<nexists>C.\n       C \\<in> empty_selected_part Sel S \\<and>\n       strictly_maximal_literal C (Pos A) \\<and>\n       (\\<forall>B.\n           Pos B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           \\<not> canonic_int_fun_ordered B\n                   (empty_selected_part Sel S)) \\<and>\n       (\\<forall>B.\n           Neg B \\<in> C \\<longrightarrow>\n           (B, A) \\<in> atom_ordering \\<longrightarrow>\n           canonic_int_fun_ordered B\n            (empty_selected_part Sel S)) \\<Longrightarrow>\n    False", "from this and \\<open>(canonic_int_fun_ordered A) ?SE\\<close>"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_fun_ordered A (empty_selected_part Sel S)\n  canonic_int_fun_ordered A (empty_selected_part Sel S)", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_fun_ordered A (empty_selected_part Sel S)\n  canonic_int_fun_ordered A (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C.\n     C \\<in> empty_selected_part Sel S \\<and>\n     strictly_maximal_literal C (Pos A) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B\n                 (empty_selected_part Sel S)) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B (empty_selected_part Sel S))\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     C \\<in> empty_selected_part Sel S \\<and>\n     strictly_maximal_literal C (Pos A) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B\n                 (empty_selected_part Sel S)) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B (empty_selected_part Sel S))", "obtain D where \n                \"D \\<in> ?SE\" and \"strictly_maximal_literal D (Pos A)\" \n                and c1: \"( \\<forall> B. ( Pos B \\<in> D \\<longrightarrow> (B, A) \\<in> atom_ordering \n                  \\<longrightarrow> (\\<not>(canonic_int_fun_ordered B) ?SE)))\"\n                and c2: \"( \\<forall> B. ( Neg B \\<in> D \\<longrightarrow> (B, A) \\<in> atom_ordering \n                  \\<longrightarrow> ((canonic_int_fun_ordered B) ?SE)))\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     C \\<in> empty_selected_part Sel S \\<and>\n     strictly_maximal_literal C (Pos A) \\<and>\n     (\\<forall>B.\n         Pos B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         \\<not> canonic_int_fun_ordered B\n                 (empty_selected_part Sel S)) \\<and>\n     (\\<forall>B.\n         Neg B \\<in> C \\<longrightarrow>\n         (B, A) \\<in> atom_ordering \\<longrightarrow>\n         canonic_int_fun_ordered B (empty_selected_part Sel S))\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> empty_selected_part Sel S;\n         strictly_maximal_literal D (Pos A);\n         \\<forall>B.\n            Pos B \\<in> D \\<longrightarrow>\n            (B, A) \\<in> atom_ordering \\<longrightarrow>\n            \\<not> canonic_int_fun_ordered B (empty_selected_part Sel S);\n         \\<forall>B.\n            Neg B \\<in> D \\<longrightarrow>\n            (B, A) \\<in> atom_ordering \\<longrightarrow>\n            canonic_int_fun_ordered B (empty_selected_part Sel S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D \\<in> empty_selected_part Sel S\n  strictly_maximal_literal D (Pos A)\n  \\<forall>B.\n     Pos B \\<in> D \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     \\<not> canonic_int_fun_ordered B (empty_selected_part Sel S)\n  \\<forall>B.\n     Neg B \\<in> D \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     canonic_int_fun_ordered B (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from \\<open>D \\<in> ?SE\\<close>"], ["proof (chain)\npicking this:\n  D \\<in> empty_selected_part Sel S", "have \"(selected_part Sel D) = {}\" and \"D \\<in> S\""], ["proof (prove)\nusing this:\n  D \\<in> empty_selected_part Sel S\n\ngoal (1 subgoal):\n 1. selected_part Sel D = {} &&& D \\<in> S", "unfolding empty_selected_part_def"], ["proof (prove)\nusing this:\n  D \\<in> {C \\<in> S. selected_part Sel C = {}}\n\ngoal (1 subgoal):\n 1. selected_part Sel D = {} &&& D \\<in> S", "by auto"], ["proof (state)\nthis:\n  selected_part Sel D = {}\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from \\<open>D \\<in> ?SE\\<close> and \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  D \\<in> empty_selected_part Sel S\n  all_fulfill finite S", "have \"finite D\""], ["proof (prove)\nusing this:\n  D \\<in> empty_selected_part Sel S\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. finite D", "unfolding empty_selected_part_def all_fulfill_def"], ["proof (prove)\nusing this:\n  D \\<in> {C \\<in> S. selected_part Sel C = {}}\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. finite D", "by auto"], ["proof (state)\nthis:\n  finite D\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "let ?R = \"(D - { Pos A }) \\<union> (C - { Neg A })\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from \\<open>strictly_maximal_literal D (Pos A)\\<close> \n                and \\<open>strictly_maximal_literal (selected_part Sel C) L\\<close> \n                and \\<open>L = (Neg A)\\<close> and \\<open>(selected_part Sel D) = {}\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal D (Pos A)\n  strictly_maximal_literal (selected_part Sel C) L\n  L = Neg A\n  selected_part Sel D = {}", "have \"(ordered_sel_resolvent_upon Sel D C ?R A)\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal D (Pos A)\n  strictly_maximal_literal (selected_part Sel C) L\n  L = Neg A\n  selected_part Sel D = {}\n\ngoal (1 subgoal):\n 1. ordered_sel_resolvent_upon Sel D C (D - {Pos A} \\<union> (C - {Neg A}))\n     A", "unfolding ordered_sel_resolvent_upon_def"], ["proof (prove)\nusing this:\n  strictly_maximal_literal D (Pos A)\n  strictly_maximal_literal (selected_part Sel C) L\n  L = Neg A\n  selected_part Sel D = {}\n\ngoal (1 subgoal):\n 1. D - {Pos A} \\<union> (C - {Neg A}) =\n    D - {Pos A} \\<union> (C - {Neg A}) \\<and>\n    strictly_maximal_literal D (Pos A) \\<and>\n    selected_part Sel D = {} \\<and>\n    (strictly_maximal_literal C (Neg A) \\<and>\n     selected_part Sel C = {} \\<or>\n     strictly_maximal_literal (selected_part Sel C) (Neg A))", "by auto"], ["proof (state)\nthis:\n  ordered_sel_resolvent_upon Sel D C (D - {Pos A} \\<union> (C - {Neg A})) A\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  ordered_sel_resolvent_upon Sel D C (D - {Pos A} \\<union> (C - {Neg A})) A", "have \"ordered_sel_resolvent Sel D C ?R\""], ["proof (prove)\nusing this:\n  ordered_sel_resolvent_upon Sel D C (D - {Pos A} \\<union> (C - {Neg A})) A\n\ngoal (1 subgoal):\n 1. ordered_sel_resolvent Sel D C (D - {Pos A} \\<union> (C - {Neg A}))", "by (rule ordered_sel_resolvent_upon_is_resolvent)"], ["proof (state)\nthis:\n  ordered_sel_resolvent Sel D C (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from \\<open>(ordered_sel_resolvent_upon Sel D C ?R A)\\<close> \\<open>(card (selected_part Sel C)) = n\\<close> \n                and \\<open>n = Suc m\\<close> and \\<open>L \\<in> C\\<close> and \\<open>L = (Neg A)\\<close> and \\<open>finite D\\<close> and \\<open>finite C\\<close>"], ["proof (chain)\npicking this:\n  ordered_sel_resolvent_upon Sel D C (D - {Pos A} \\<union> (C - {Neg A})) A\n  card (selected_part Sel C) = n\n  n = Suc m\n  L \\<in> C\n  L = Neg A\n  finite D\n  finite C", "have \"card (selected_part Sel ?R) = m\""], ["proof (prove)\nusing this:\n  ordered_sel_resolvent_upon Sel D C (D - {Pos A} \\<union> (C - {Neg A})) A\n  card (selected_part Sel C) = n\n  n = Suc m\n  L \\<in> C\n  L = Neg A\n  finite D\n  finite C\n\ngoal (1 subgoal):\n 1. card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))) = m", "using resolution_decreases_selected_part"], ["proof (prove)\nusing this:\n  ordered_sel_resolvent_upon Sel D C (D - {Pos A} \\<union> (C - {Neg A})) A\n  card (selected_part Sel C) = n\n  n = Suc m\n  L \\<in> C\n  L = Neg A\n  finite D\n  finite C\n  \\<lbrakk>ordered_sel_resolvent_upon ?Sel ?P1.0 ?P2.0 ?C ?A;\n   Neg ?A \\<in> ?P2.0; finite ?P1.0; finite ?P2.0;\n   card (selected_part ?Sel ?P2.0) = Suc ?n\\<rbrakk>\n  \\<Longrightarrow> card (selected_part ?Sel ?C) = ?n\n\ngoal (1 subgoal):\n 1. card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))) = m", "by auto"], ["proof (state)\nthis:\n  card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))) = m\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from \\<open>ordered_sel_resolvent Sel D C ?R\\<close> and \\<open>D \\<in> S\\<close>and \\<open>C \\<in> S\\<close> \n                and \\<open>saturated_binary_rule (ordered_sel_resolvent Sel) S\\<close>"], ["proof (chain)\npicking this:\n  ordered_sel_resolvent Sel D C (D - {Pos A} \\<union> (C - {Neg A}))\n  D \\<in> S\n  C \\<in> S\n  saturated_binary_rule (ordered_sel_resolvent Sel) S", "have \"redundant ?R S\""], ["proof (prove)\nusing this:\n  ordered_sel_resolvent Sel D C (D - {Pos A} \\<union> (C - {Neg A}))\n  D \\<in> S\n  C \\<in> S\n  saturated_binary_rule (ordered_sel_resolvent Sel) S\n\ngoal (1 subgoal):\n 1. redundant (D - {Pos A} \\<union> (C - {Neg A})) S", "unfolding saturated_binary_rule_def"], ["proof (prove)\nusing this:\n  ordered_sel_resolvent Sel D C (D - {Pos A} \\<union> (C - {Neg A}))\n  D \\<in> S\n  C \\<in> S\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and> ordered_sel_resolvent Sel P1 P2 C \\<longrightarrow>\n     redundant C S\n\ngoal (1 subgoal):\n 1. redundant (D - {Pos A} \\<union> (C - {Neg A})) S", "by auto"], ["proof (state)\nthis:\n  redundant (D - {Pos A} \\<union> (C - {Neg A})) S\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "hence \"tautology ?R \\<or> (\\<exists>RR. (RR \\<in> S \\<and> (subsumes RR ?R)))\""], ["proof (prove)\nusing this:\n  redundant (D - {Pos A} \\<union> (C - {Neg A})) S\n\ngoal (1 subgoal):\n 1. tautology (D - {Pos A} \\<union> (C - {Neg A})) \\<or>\n    (\\<exists>RR.\n        RR \\<in> S \\<and> subsumes RR (D - {Pos A} \\<union> (C - {Neg A})))", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  tautology (D - {Pos A} \\<union> (C - {Neg A})) \\<or>\n  (\\<exists>Da.\n      Da \\<in> S \\<and> subsumes Da (D - {Pos A} \\<union> (C - {Neg A})))\n\ngoal (1 subgoal):\n 1. tautology (D - {Pos A} \\<union> (C - {Neg A})) \\<or>\n    (\\<exists>RR.\n        RR \\<in> S \\<and> subsumes RR (D - {Pos A} \\<union> (C - {Neg A})))", "by auto"], ["proof (state)\nthis:\n  tautology (D - {Pos A} \\<union> (C - {Neg A})) \\<or>\n  (\\<exists>RR.\n      RR \\<in> S \\<and> subsumes RR (D - {Pos A} \\<union> (C - {Neg A})))\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "hence \"validate_clause ?I ?R\""], ["proof (prove)\nusing this:\n  tautology (D - {Pos A} \\<union> (C - {Neg A})) \\<or>\n  (\\<exists>RR.\n      RR \\<in> S \\<and> subsumes RR (D - {Pos A} \\<union> (C - {Neg A})))\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. tautology (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))\n 2. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "assume \"tautology ?R\""], ["proof (state)\nthis:\n  tautology (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (2 subgoals):\n 1. tautology (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))\n 2. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "thus \"validate_clause ?I ?R\""], ["proof (prove)\nusing this:\n  tautology (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "by (rule tautologies_are_valid)"], ["proof (state)\nthis:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n  (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "assume \"\\<exists>R'. R' \\<in> S \\<and> (subsumes R' ?R)\""], ["proof (state)\nthis:\n  \\<exists>R'.\n     R' \\<in> S \\<and> subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "then"], ["proof (chain)\npicking this:\n  \\<exists>R'.\n     R' \\<in> S \\<and> subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))", "obtain R' where \"R' \\<in> S\" and \"subsumes R' ?R\""], ["proof (prove)\nusing this:\n  \\<exists>R'.\n     R' \\<in> S \\<and> subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>R' \\<in> S;\n         subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R' \\<in> S\n  subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "from \\<open>finite C\\<close>and \\<open>finite D\\<close>"], ["proof (chain)\npicking this:\n  finite C\n  finite D", "have \"finite ?R\""], ["proof (prove)\nusing this:\n  finite C\n  finite D\n\ngoal (1 subgoal):\n 1. finite (D - {Pos A} \\<union> (C - {Neg A}))", "by auto"], ["proof (state)\nthis:\n  finite (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "from this"], ["proof (chain)\npicking this:\n  finite (D - {Pos A} \\<union> (C - {Neg A}))", "have \"finite (selected_part Sel ?R)\""], ["proof (prove)\nusing this:\n  finite (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. finite (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  finite (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. finite\n     {L \\<in> D - {Pos A} \\<union> (C - {Neg A}).\n      \\<exists>A\\<in>Sel. L = Neg A}", "by auto"], ["proof (state)\nthis:\n  finite (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))\n\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "from \\<open>subsumes R' ?R\\<close>"], ["proof (chain)\npicking this:\n  subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))", "have \"selected_part Sel R' \\<subseteq> selected_part Sel ?R\""], ["proof (prove)\nusing this:\n  subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. selected_part Sel R'\n    \\<subseteq> selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))", "unfolding selected_part_def and subsumes_def"], ["proof (prove)\nusing this:\n  R' \\<subseteq> D - {Pos A} \\<union> (C - {Neg A})\n\ngoal (1 subgoal):\n 1. {L \\<in> R'. \\<exists>A\\<in>Sel. L = Neg A}\n    \\<subseteq> {L \\<in> D - {Pos A} \\<union> (C - {Neg A}).\n                 \\<exists>A\\<in>Sel. L = Neg A}", "by auto"], ["proof (state)\nthis:\n  selected_part Sel R'\n  \\<subseteq> selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "from this and \\<open>finite (selected_part Sel ?R)\\<close>"], ["proof (chain)\npicking this:\n  selected_part Sel R'\n  \\<subseteq> selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))\n  finite (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))", "have \"card (selected_part Sel R') \\<le> card (selected_part Sel ?R)\""], ["proof (prove)\nusing this:\n  selected_part Sel R'\n  \\<subseteq> selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))\n  finite (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))\n\ngoal (1 subgoal):\n 1. card (selected_part Sel R')\n    \\<le> card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))", "using card_mono"], ["proof (prove)\nusing this:\n  selected_part Sel R'\n  \\<subseteq> selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))\n  finite (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card ?B\n\ngoal (1 subgoal):\n 1. card (selected_part Sel R')\n    \\<le> card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))", "by auto"], ["proof (state)\nthis:\n  card (selected_part Sel R')\n  \\<le> card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))\n\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "from this and \\<open>card (selected_part Sel ?R) = m\\<close> and \\<open>n = Suc m\\<close>"], ["proof (chain)\npicking this:\n  card (selected_part Sel R')\n  \\<le> card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))\n  card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))) = m\n  n = Suc m", "have \"card (selected_part Sel R') < n\""], ["proof (prove)\nusing this:\n  card (selected_part Sel R')\n  \\<le> card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A})))\n  card (selected_part Sel (D - {Pos A} \\<union> (C - {Neg A}))) = m\n  n = Suc m\n\ngoal (1 subgoal):\n 1. card (selected_part Sel R') < n", "by auto"], ["proof (state)\nthis:\n  card (selected_part Sel R') < n\n\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "from this and ind_hyp and \\<open>R' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  card (selected_part Sel R') < n\n  \\<forall>m.\n     (m, n) \\<in> {(x, y). x < y} \\<longrightarrow>\n     (\\<forall>C.\n         card (selected_part Sel C) = m \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C)\n  R' \\<in> S", "have \"validate_clause ?I R'\""], ["proof (prove)\nusing this:\n  card (selected_part Sel R') < n\n  \\<forall>m.\n     (m, n) \\<in> {(x, y). x < y} \\<longrightarrow>\n     (\\<forall>C.\n         card (selected_part Sel C) = m \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C)\n  R' \\<in> S\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> R'", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> R'\n\ngoal (1 subgoal):\n 1. \\<exists>RR.\n       RR \\<in> S \\<and>\n       subsumes RR (D - {Pos A} \\<union> (C - {Neg A})) \\<Longrightarrow>\n    canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "from this and \\<open>subsumes R' ?R\\<close>"], ["proof (chain)\npicking this:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> R'\n  subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))", "show \"validate_clause ?I ?R\""], ["proof (prove)\nusing this:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> R'\n  subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "using subsumption_and_semantics [of R' ?R ?I]"], ["proof (prove)\nusing this:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> R'\n  subsumes R' (D - {Pos A} \\<union> (C - {Neg A}))\n  \\<lbrakk>subsumes R' (D - {Pos A} \\<union> (C - {Neg A}));\n   canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> R'\\<rbrakk>\n  \\<Longrightarrow> canonic_int_ordered\n                     (empty_selected_part Sel S) \\<Turnstile>\n                    (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n    (D - {Pos A} \\<union> (C - {Neg A}))", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n  (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n  (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n  (D - {Pos A} \\<union> (C - {Neg A}))", "obtain L' where \"L' \\<in> ?R\" and \"validate_literal ?I L'\""], ["proof (prove)\nusing this:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n  (D - {Pos A} \\<union> (C - {Neg A}))\n\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        \\<lbrakk>L' \\<in> D - {Pos A} \\<union> (C - {Neg A});\n         canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n         L'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L' \\<in> D - {Pos A} \\<union> (C - {Neg A})\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L'\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "have \"L' \\<notin> D - { Pos A }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L' \\<notin> D - {Pos A}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. L' \\<in> D - {Pos A} \\<Longrightarrow> False", "assume \"L' \\<in> D - { Pos A }\""], ["proof (state)\nthis:\n  L' \\<in> D - {Pos A}\n\ngoal (1 subgoal):\n 1. L' \\<in> D - {Pos A} \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  L' \\<in> D - {Pos A}", "have \"L' \\<in> D\""], ["proof (prove)\nusing this:\n  L' \\<in> D - {Pos A}\n\ngoal (1 subgoal):\n 1. L' \\<in> D", "by auto"], ["proof (state)\nthis:\n  L' \\<in> D\n\ngoal (1 subgoal):\n 1. L' \\<in> D - {Pos A} \\<Longrightarrow> False", "let ?A' = \"atom L'\""], ["proof (state)\ngoal (1 subgoal):\n 1. L' \\<in> D - {Pos A} \\<Longrightarrow> False", "have \"L' = (Pos ?A') \\<or> L' = (Neg ?A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L' = Pos (atom L') \\<or> L' = Neg (atom L')", "using atom_property [of ?A' L']"], ["proof (prove)\nusing this:\n  atom L' = atom L' \\<Longrightarrow>\n  L' = Pos (atom L') \\<or> L' = Neg (atom L')\n\ngoal (1 subgoal):\n 1. L' = Pos (atom L') \\<or> L' = Neg (atom L')", "by auto"], ["proof (state)\nthis:\n  L' = Pos (atom L') \\<or> L' = Neg (atom L')\n\ngoal (1 subgoal):\n 1. L' \\<in> D - {Pos A} \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  L' = Pos (atom L') \\<or> L' = Neg (atom L')\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L' = Pos (atom L') \\<Longrightarrow> False\n 2. L' = Neg (atom L') \\<Longrightarrow> False", "assume \"L' = (Pos ?A')\""], ["proof (state)\nthis:\n  L' = Pos (atom L')\n\ngoal (2 subgoals):\n 1. L' = Pos (atom L') \\<Longrightarrow> False\n 2. L' = Neg (atom L') \\<Longrightarrow> False", "from this and \\<open>strictly_maximal_literal D (Pos A)\\<close> and \\<open>L' \\<in> D - { Pos A }\\<close>"], ["proof (chain)\npicking this:\n  L' = Pos (atom L')\n  strictly_maximal_literal D (Pos A)\n  L' \\<in> D - {Pos A}", "have \"(?A',A) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  L' = Pos (atom L')\n  strictly_maximal_literal D (Pos A)\n  L' \\<in> D - {Pos A}\n\ngoal (1 subgoal):\n 1. (atom L', A) \\<in> atom_ordering", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  L' = Pos (atom L')\n  Pos A \\<in> D \\<and>\n  (\\<forall>B.\n      B \\<in> D \\<and> Pos A \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos A))\n  L' \\<in> D - {Pos A}\n\ngoal (1 subgoal):\n 1. (atom L', A) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (atom L', A) \\<in> atom_ordering\n\ngoal (2 subgoals):\n 1. L' = Pos (atom L') \\<Longrightarrow> False\n 2. L' = Neg (atom L') \\<Longrightarrow> False", "from c1"], ["proof (chain)\npicking this:\n  \\<forall>B.\n     Pos B \\<in> D \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     \\<not> canonic_int_fun_ordered B (empty_selected_part Sel S)", "have c1': \"Pos ?A' \\<in> D \\<longrightarrow> (?A', A) \\<in> atom_ordering \n                                \\<longrightarrow> (\\<not>(canonic_int_fun_ordered ?A') ?SE)\""], ["proof (prove)\nusing this:\n  \\<forall>B.\n     Pos B \\<in> D \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     \\<not> canonic_int_fun_ordered B (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. Pos (atom L') \\<in> D \\<longrightarrow>\n    (atom L', A) \\<in> atom_ordering \\<longrightarrow>\n    \\<not> canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)", "by blast"], ["proof (state)\nthis:\n  Pos (atom L') \\<in> D \\<longrightarrow>\n  (atom L', A) \\<in> atom_ordering \\<longrightarrow>\n  \\<not> canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n\ngoal (2 subgoals):\n 1. L' = Pos (atom L') \\<Longrightarrow> False\n 2. L' = Neg (atom L') \\<Longrightarrow> False", "from \\<open>L' \\<in> D\\<close> and \\<open>L' = Pos ?A'\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> D\n  L' = Pos (atom L')", "have \"Pos ?A' \\<in> D\""], ["proof (prove)\nusing this:\n  L' \\<in> D\n  L' = Pos (atom L')\n\ngoal (1 subgoal):\n 1. Pos (atom L') \\<in> D", "by auto"], ["proof (state)\nthis:\n  Pos (atom L') \\<in> D\n\ngoal (2 subgoals):\n 1. L' = Pos (atom L') \\<Longrightarrow> False\n 2. L' = Neg (atom L') \\<Longrightarrow> False", "from c1' and \\<open>Pos ?A' \\<in> D\\<close> and \\<open>(?A',A) \\<in> atom_ordering\\<close>"], ["proof (chain)\npicking this:\n  Pos (atom L') \\<in> D \\<longrightarrow>\n  (atom L', A) \\<in> atom_ordering \\<longrightarrow>\n  \\<not> canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n  Pos (atom L') \\<in> D\n  (atom L', A) \\<in> atom_ordering", "have \"\\<not>(canonic_int_fun_ordered ?A') ?SE\""], ["proof (prove)\nusing this:\n  Pos (atom L') \\<in> D \\<longrightarrow>\n  (atom L', A) \\<in> atom_ordering \\<longrightarrow>\n  \\<not> canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n  Pos (atom L') \\<in> D\n  (atom L', A) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)", "by blast"], ["proof (state)\nthis:\n  \\<not> canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n\ngoal (2 subgoals):\n 1. L' = Pos (atom L') \\<Longrightarrow> False\n 2. L' = Neg (atom L') \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)", "have \"?A' \\<notin> ?I\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. atom L' \\<notin> canonic_int_ordered (empty_selected_part Sel S)", "unfolding canonic_int_ordered_def"], ["proof (prove)\nusing this:\n  \\<not> canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. atom L'\n    \\<notin> {A. canonic_int_fun_ordered A (empty_selected_part Sel S)}", "by blast"], ["proof (state)\nthis:\n  atom L' \\<notin> canonic_int_ordered (empty_selected_part Sel S)\n\ngoal (2 subgoals):\n 1. L' = Pos (atom L') \\<Longrightarrow> False\n 2. L' = Neg (atom L') \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  atom L' \\<notin> canonic_int_ordered (empty_selected_part Sel S)", "have \"\\<not>(validate_literal ?I (Pos ?A'))\""], ["proof (prove)\nusing this:\n  atom L' \\<notin> canonic_int_ordered (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n           Pos (atom L')", "by auto"], ["proof (state)\nthis:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n         Pos (atom L')\n\ngoal (2 subgoals):\n 1. L' = Pos (atom L') \\<Longrightarrow> False\n 2. L' = Neg (atom L') \\<Longrightarrow> False", "from this and \\<open>L' = Pos ?A'\\<close> and \\<open>validate_literal ?I L'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n         Pos (atom L')\n  L' = Pos (atom L')\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L'", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n         Pos (atom L')\n  L' = Pos (atom L')\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. L' = Neg (atom L') \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L' = Neg (atom L') \\<Longrightarrow> False", "assume \"L' = Neg ?A'\""], ["proof (state)\nthis:\n  L' = Neg (atom L')\n\ngoal (1 subgoal):\n 1. L' = Neg (atom L') \\<Longrightarrow> False", "from this and \\<open>strictly_maximal_literal D (Pos A)\\<close> and \\<open>L' \\<in> D - { Pos A }\\<close>"], ["proof (chain)\npicking this:\n  L' = Neg (atom L')\n  strictly_maximal_literal D (Pos A)\n  L' \\<in> D - {Pos A}", "have \"(?A',A) \\<in> atom_ordering\""], ["proof (prove)\nusing this:\n  L' = Neg (atom L')\n  strictly_maximal_literal D (Pos A)\n  L' \\<in> D - {Pos A}\n\ngoal (1 subgoal):\n 1. (atom L', A) \\<in> atom_ordering", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  L' = Neg (atom L')\n  Pos A \\<in> D \\<and>\n  (\\<forall>B.\n      B \\<in> D \\<and> Pos A \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Pos A))\n  L' \\<in> D - {Pos A}\n\ngoal (1 subgoal):\n 1. (atom L', A) \\<in> atom_ordering", "by auto"], ["proof (state)\nthis:\n  (atom L', A) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. L' = Neg (atom L') \\<Longrightarrow> False", "from c2"], ["proof (chain)\npicking this:\n  \\<forall>B.\n     Neg B \\<in> D \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     canonic_int_fun_ordered B (empty_selected_part Sel S)", "have c2': \"Neg ?A' \\<in> D \\<longrightarrow> (?A', A) \\<in> atom_ordering \n                      \\<longrightarrow> (canonic_int_fun_ordered ?A') ?SE\""], ["proof (prove)\nusing this:\n  \\<forall>B.\n     Neg B \\<in> D \\<longrightarrow>\n     (B, A) \\<in> atom_ordering \\<longrightarrow>\n     canonic_int_fun_ordered B (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. Neg (atom L') \\<in> D \\<longrightarrow>\n    (atom L', A) \\<in> atom_ordering \\<longrightarrow>\n    canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)", "by blast"], ["proof (state)\nthis:\n  Neg (atom L') \\<in> D \\<longrightarrow>\n  (atom L', A) \\<in> atom_ordering \\<longrightarrow>\n  canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. L' = Neg (atom L') \\<Longrightarrow> False", "from \\<open>L' \\<in> D\\<close> and \\<open>L' = (Neg ?A')\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> D\n  L' = Neg (atom L')", "have \"Neg ?A' \\<in> D\""], ["proof (prove)\nusing this:\n  L' \\<in> D\n  L' = Neg (atom L')\n\ngoal (1 subgoal):\n 1. Neg (atom L') \\<in> D", "by auto"], ["proof (state)\nthis:\n  Neg (atom L') \\<in> D\n\ngoal (1 subgoal):\n 1. L' = Neg (atom L') \\<Longrightarrow> False", "from c2' and \\<open>Neg ?A' \\<in> D\\<close> and \\<open>(?A',A) \\<in> atom_ordering\\<close>"], ["proof (chain)\npicking this:\n  Neg (atom L') \\<in> D \\<longrightarrow>\n  (atom L', A) \\<in> atom_ordering \\<longrightarrow>\n  canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n  Neg (atom L') \\<in> D\n  (atom L', A) \\<in> atom_ordering", "have \"(canonic_int_fun_ordered ?A') ?SE\""], ["proof (prove)\nusing this:\n  Neg (atom L') \\<in> D \\<longrightarrow>\n  (atom L', A) \\<in> atom_ordering \\<longrightarrow>\n  canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n  Neg (atom L') \\<in> D\n  (atom L', A) \\<in> atom_ordering\n\ngoal (1 subgoal):\n 1. canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)", "by blast"], ["proof (state)\nthis:\n  canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. L' = Neg (atom L') \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)", "have \"?A' \\<in> ?I\""], ["proof (prove)\nusing this:\n  canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. atom L' \\<in> canonic_int_ordered (empty_selected_part Sel S)", "unfolding canonic_int_ordered_def"], ["proof (prove)\nusing this:\n  canonic_int_fun_ordered (atom L') (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. atom L' \\<in> {A. canonic_int_fun_ordered A (empty_selected_part Sel S)}", "by blast"], ["proof (state)\nthis:\n  atom L' \\<in> canonic_int_ordered (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. L' = Neg (atom L') \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  atom L' \\<in> canonic_int_ordered (empty_selected_part Sel S)", "have \"\\<not>validate_literal ?I (Neg ?A')\""], ["proof (prove)\nusing this:\n  atom L' \\<in> canonic_int_ordered (empty_selected_part Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n           Neg (atom L')", "by auto"], ["proof (state)\nthis:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n         Neg (atom L')\n\ngoal (1 subgoal):\n 1. L' = Neg (atom L') \\<Longrightarrow> False", "from this and \\<open>L' = Neg ?A'\\<close> and \\<open>validate_literal ?I L'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n         Neg (atom L')\n  L' = Neg (atom L')\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L'", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n         Neg (atom L')\n  L' = Neg (atom L')\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L' \\<notin> D - {Pos A}\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from this and \\<open>L' \\<in> ?R\\<close>"], ["proof (chain)\npicking this:\n  L' \\<notin> D - {Pos A}\n  L' \\<in> D - {Pos A} \\<union> (C - {Neg A})", "have \"L' \\<in> C\""], ["proof (prove)\nusing this:\n  L' \\<notin> D - {Pos A}\n  L' \\<in> D - {Pos A} \\<union> (C - {Neg A})\n\ngoal (1 subgoal):\n 1. L' \\<in> C", "by auto"], ["proof (state)\nthis:\n  L' \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> False", "from this and \\<open>validate_literal ?I L'\\<close> and \\<open>\\<not>validate_clause ?I C\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> C\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L'\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "show \"False\""], ["proof (prove)\nusing this:\n  L' \\<in> C\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> L'\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C.\n     card (selected_part Sel C) = n \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C.\n     card (selected_part Sel C) = n \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "from \\<open>?P n\\<close> and \\<open>n = card (selected_part Sel C)\\<close> and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>C.\n     card (selected_part Sel C) = n \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n  n = card (selected_part Sel C)\n  C \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>C.\n     card (selected_part Sel C) = n \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n  n = card (selected_part Sel C)\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "by auto"], ["proof (state)\nthis:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ordered_resolution_is_complete_ordered_sel : \n  \"Complete (ordered_sel_resolvent Sel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete (ordered_sel_resolvent Sel)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_sel_resolvent Sel) \\<Longrightarrow> False", "assume \"\\<not>Complete (ordered_sel_resolvent Sel)\""], ["proof (state)\nthis:\n  \\<not> Complete (ordered_sel_resolvent Sel)\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_sel_resolvent Sel) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Complete (ordered_sel_resolvent Sel)", "obtain S where \"saturated_binary_rule (ordered_sel_resolvent Sel) S\"\n    and \"all_fulfill finite S\"\n    and \"{} \\<notin> S\"\n    and \"\\<not>satisfiable S\""], ["proof (prove)\nusing this:\n  \\<not> Complete (ordered_sel_resolvent Sel)\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>saturated_binary_rule (ordered_sel_resolvent Sel) S;\n         all_fulfill finite S; {} \\<notin> S; \\<not> satisfiable S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Complete_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>S.\n             saturated_binary_rule (ordered_sel_resolvent Sel)\n              S \\<longrightarrow>\n             all_fulfill finite S \\<longrightarrow>\n             {} \\<notin> S \\<longrightarrow> satisfiable S)\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>saturated_binary_rule (ordered_sel_resolvent Sel) S;\n         all_fulfill finite S; {} \\<notin> S; \\<not> satisfiable S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  saturated_binary_rule (ordered_sel_resolvent Sel) S\n  all_fulfill finite S\n  {} \\<notin> S\n  \\<not> satisfiable S\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_sel_resolvent Sel) \\<Longrightarrow> False", "let ?SE = \"empty_selected_part Sel S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_sel_resolvent Sel) \\<Longrightarrow> False", "let ?I = \"canonic_int_ordered ?SE\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_sel_resolvent Sel) \\<Longrightarrow> False", "have \"validate_formula ?I S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n           S \\<Longrightarrow>\n    False", "assume \"\\<not>(validate_formula ?I S)\""], ["proof (state)\nthis:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n           S \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> S", "obtain C where \"C \\<in> S\" and \"\\<not>(validate_clause ?I C)\""], ["proof (prove)\nusing this:\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> S;\n         \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n                C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> S\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile>\n           S \\<Longrightarrow>\n    False", "from \\<open>saturated_binary_rule (ordered_sel_resolvent Sel) S\\<close> and \\<open>all_fulfill finite S\\<close> \n      and \\<open>{} \\<notin> S\\<close> and \\<open>C \\<in> S\\<close> and \\<open>\\<not>(validate_clause ?I C)\\<close>"], ["proof (chain)\npicking this:\n  saturated_binary_rule (ordered_sel_resolvent Sel) S\n  all_fulfill finite S\n  {} \\<notin> S\n  C \\<in> S\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C", "show \"False\""], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_sel_resolvent Sel) S\n  all_fulfill finite S\n  {} \\<notin> S\n  C \\<in> S\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. False", "using canonic_int_validates_all_clauses_sel [of Sel S C]"], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_sel_resolvent Sel) S\n  all_fulfill finite S\n  {} \\<notin> S\n  C \\<in> S\n  \\<not> canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> C\n  \\<lbrakk>saturated_binary_rule (ordered_sel_resolvent Sel) S;\n   all_fulfill finite S; {} \\<notin> S; C \\<in> S\\<rbrakk>\n  \\<Longrightarrow> canonic_int_ordered\n                     (empty_selected_part Sel S) \\<Turnstile>\n                    C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_sel_resolvent Sel) \\<Longrightarrow> False", "from \\<open>(validate_formula ?I S)\\<close> and \\<open>\\<not>(satisfiable S)\\<close>"], ["proof (chain)\npicking this:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> S\n  \\<not> satisfiable S", "show \"False\""], ["proof (prove)\nusing this:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> S\n  \\<not> satisfiable S\n\ngoal (1 subgoal):\n 1. False", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  canonic_int_ordered (empty_selected_part Sel S) \\<Turnstile> S\n  \\<nexists>I. I \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Semantic Resolution\\<close>"], ["", "text \\<open>We show that under some particular renaming, model resolution simulates ordered resolution \nwhere all negative literals are selected, which immediately entails the refutational completeness \nof model resolution.\\<close>"], ["", "lemma ordered_res_with_selection_is_model_res :\n  assumes \"ordered_sel_resolvent UNIV P1 P2 C\"\n  shows \"ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2) \n            (rename_clause Sel C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from assms"], ["proof (chain)\npicking this:\n  ordered_sel_resolvent UNIV P1 P2 C", "obtain A \n  where c_def: \"C = ((P1 - { Pos A }) \\<union> (P2 - { Neg A }))\"\n    and \"selected_part UNIV P1 = {}\" \n    and \"strictly_maximal_literal P1 (Pos A)\"\n    and disj: \"((strictly_maximal_literal P2 (Neg A)) \\<and> (selected_part UNIV P2) = {}) \n      \\<or> strictly_maximal_literal (selected_part UNIV P2) (Neg A)\""], ["proof (prove)\nusing this:\n  ordered_sel_resolvent UNIV P1 P2 C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>C = P1 - {Pos A} \\<union> (P2 - {Neg A});\n         selected_part UNIV P1 = {}; strictly_maximal_literal P1 (Pos A);\n         strictly_maximal_literal P2 (Neg A) \\<and>\n         selected_part UNIV P2 = {} \\<or>\n         strictly_maximal_literal (selected_part UNIV P2) (Neg A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ordered_sel_resolvent_def"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     C = P1 - {Pos A} \\<union> (P2 - {Neg A}) \\<and>\n     strictly_maximal_literal P1 (Pos A) \\<and>\n     selected_part UNIV P1 = {} \\<and>\n     (strictly_maximal_literal P2 (Neg A) \\<and>\n      selected_part UNIV P2 = {} \\<or>\n      strictly_maximal_literal (selected_part UNIV P2) (Neg A))\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>C = P1 - {Pos A} \\<union> (P2 - {Neg A});\n         selected_part UNIV P1 = {}; strictly_maximal_literal P1 (Pos A);\n         strictly_maximal_literal P2 (Neg A) \\<and>\n         selected_part UNIV P2 = {} \\<or>\n         strictly_maximal_literal (selected_part UNIV P2) (Neg A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  selected_part UNIV P1 = {}\n  strictly_maximal_literal P1 (Pos A)\n  strictly_maximal_literal P2 (Neg A) \\<and>\n  selected_part UNIV P2 = {} \\<or>\n  strictly_maximal_literal (selected_part UNIV P2) (Neg A)\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "have \"rename_clause Sel ((P1 - { Pos A }) \\<union> (P2 - { Neg A })) \n    =  (rename_clause Sel (P1 - { Pos A })) \\<union> rename_clause Sel (P2 - { (Neg A) })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel (P1 - {Pos A} \\<union> (P2 - {Neg A})) =\n    rename_clause Sel (P1 - {Pos A}) \\<union>\n    rename_clause Sel (P2 - {Neg A})", "using rename_union [of Sel \"P1 - { Pos A }\" \"P2 - { Neg A }\"]"], ["proof (prove)\nusing this:\n  rename_clause Sel (P1 - {Pos A} \\<union> (P2 - {Neg A})) =\n  rename_clause Sel (P1 - {Pos A}) \\<union> rename_clause Sel (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. rename_clause Sel (P1 - {Pos A} \\<union> (P2 - {Neg A})) =\n    rename_clause Sel (P1 - {Pos A}) \\<union>\n    rename_clause Sel (P2 - {Neg A})", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel (P1 - {Pos A} \\<union> (P2 - {Neg A})) =\n  rename_clause Sel (P1 - {Pos A}) \\<union> rename_clause Sel (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from this and c_def"], ["proof (chain)\npicking this:\n  rename_clause Sel (P1 - {Pos A} \\<union> (P2 - {Neg A})) =\n  rename_clause Sel (P1 - {Pos A}) \\<union> rename_clause Sel (P2 - {Neg A})\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})", "have ren_c: \"(rename_clause Sel C) =\n    (rename_clause Sel (P1 - { Pos A })) \\<union> rename_clause Sel (P2 - { (Neg A) })\""], ["proof (prove)\nusing this:\n  rename_clause Sel (P1 - {Pos A} \\<union> (P2 - {Neg A})) =\n  rename_clause Sel (P1 - {Pos A}) \\<union> rename_clause Sel (P2 - {Neg A})\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. rename_clause Sel C =\n    rename_clause Sel (P1 - {Pos A}) \\<union>\n    rename_clause Sel (P2 - {Neg A})", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel C =\n  rename_clause Sel (P1 - {Pos A}) \\<union> rename_clause Sel (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "have m1: \"(rename_clause Sel (P1 - { Pos A })) = (rename_clause Sel P1) \n              - { rename_literal Sel (Pos A) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel (P1 - {Pos A}) =\n    rename_clause Sel P1 - {rename_literal Sel (Pos A)}", "using renaming_set_minus"], ["proof (prove)\nusing this:\n  rename_clause ?Sel (?C - {?L}) =\n  rename_clause ?Sel ?C - {rename_literal ?Sel ?L}\n\ngoal (1 subgoal):\n 1. rename_clause Sel (P1 - {Pos A}) =\n    rename_clause Sel P1 - {rename_literal Sel (Pos A)}", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel (P1 - {Pos A}) =\n  rename_clause Sel P1 - {rename_literal Sel (Pos A)}\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "have m2: \"rename_clause Sel (P2 - { Neg A }) = (rename_clause Sel P2) \n              - { rename_literal Sel (Neg A) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_clause Sel (P2 - {Neg A}) =\n    rename_clause Sel P2 - {rename_literal Sel (Neg A)}", "using renaming_set_minus"], ["proof (prove)\nusing this:\n  rename_clause ?Sel (?C - {?L}) =\n  rename_clause ?Sel ?C - {rename_literal ?Sel ?L}\n\ngoal (1 subgoal):\n 1. rename_clause Sel (P2 - {Neg A}) =\n    rename_clause Sel P2 - {rename_literal Sel (Neg A)}", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel (P2 - {Neg A}) =\n  rename_clause Sel P2 - {rename_literal Sel (Neg A)}\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from m1 and m2 and ren_c"], ["proof (chain)\npicking this:\n  rename_clause Sel (P1 - {Pos A}) =\n  rename_clause Sel P1 - {rename_literal Sel (Pos A)}\n  rename_clause Sel (P2 - {Neg A}) =\n  rename_clause Sel P2 - {rename_literal Sel (Neg A)}\n  rename_clause Sel C =\n  rename_clause Sel (P1 - {Pos A}) \\<union> rename_clause Sel (P2 - {Neg A})", "have \n  rc_def: \"(rename_clause Sel C) = \n    ((rename_clause Sel P1) - { rename_literal Sel (Pos A) })\n    \\<union> ((rename_clause Sel P2) - { rename_literal Sel (Neg A)  })\""], ["proof (prove)\nusing this:\n  rename_clause Sel (P1 - {Pos A}) =\n  rename_clause Sel P1 - {rename_literal Sel (Pos A)}\n  rename_clause Sel (P2 - {Neg A}) =\n  rename_clause Sel P2 - {rename_literal Sel (Neg A)}\n  rename_clause Sel C =\n  rename_clause Sel (P1 - {Pos A}) \\<union> rename_clause Sel (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. rename_clause Sel C =\n    rename_clause Sel P1 - {rename_literal Sel (Pos A)} \\<union>\n    (rename_clause Sel P2 - {rename_literal Sel (Neg A)})", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel C =\n  rename_clause Sel P1 - {rename_literal Sel (Pos A)} \\<union>\n  (rename_clause Sel P2 - {rename_literal Sel (Neg A)})\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "have \"\\<not>((strictly_maximal_literal P2 (Neg A)) \\<and> (selected_part UNIV P2) = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (strictly_maximal_literal P2 (Neg A) \\<and>\n            selected_part UNIV P2 = {})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. strictly_maximal_literal P2 (Neg A) \\<and>\n    selected_part UNIV P2 = {} \\<Longrightarrow>\n    False", "assume \"(strictly_maximal_literal P2 (Neg A)) \\<and> (selected_part UNIV P2) = {}\""], ["proof (state)\nthis:\n  strictly_maximal_literal P2 (Neg A) \\<and> selected_part UNIV P2 = {}\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal P2 (Neg A) \\<and>\n    selected_part UNIV P2 = {} \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  strictly_maximal_literal P2 (Neg A) \\<and> selected_part UNIV P2 = {}", "have \"strictly_maximal_literal P2 (Neg A)\" and \"selected_part UNIV P2 = {}\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal P2 (Neg A) \\<and> selected_part UNIV P2 = {}\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal P2 (Neg A) &&& selected_part UNIV P2 = {}", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal P2 (Neg A)\n  selected_part UNIV P2 = {}\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal P2 (Neg A) \\<and>\n    selected_part UNIV P2 = {} \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal P2 (Neg A)\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal P2 (Neg A)", "have \"Neg A \\<in> P2\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal P2 (Neg A)\n\ngoal (1 subgoal):\n 1. Neg A \\<in> P2", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  Neg A \\<in> P2 \\<and>\n  (\\<forall>B.\n      B \\<in> P2 \\<and> Neg A \\<noteq> B \\<longrightarrow>\n      literal_ordering B (Neg A))\n\ngoal (1 subgoal):\n 1. Neg A \\<in> P2", "by auto"], ["proof (state)\nthis:\n  Neg A \\<in> P2\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal P2 (Neg A) \\<and>\n    selected_part UNIV P2 = {} \\<Longrightarrow>\n    False", "from this and \\<open>selected_part UNIV P2 = {}\\<close>"], ["proof (chain)\npicking this:\n  Neg A \\<in> P2\n  selected_part UNIV P2 = {}", "show \"False\""], ["proof (prove)\nusing this:\n  Neg A \\<in> P2\n  selected_part UNIV P2 = {}\n\ngoal (1 subgoal):\n 1. False", "unfolding selected_part_def"], ["proof (prove)\nusing this:\n  Neg A \\<in> P2\n  {L \\<in> P2. \\<exists>A\\<in>UNIV. L = Neg A} = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (strictly_maximal_literal P2 (Neg A) \\<and>\n          selected_part UNIV P2 = {})\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from this and disj"], ["proof (chain)\npicking this:\n  \\<not> (strictly_maximal_literal P2 (Neg A) \\<and>\n          selected_part UNIV P2 = {})\n  strictly_maximal_literal P2 (Neg A) \\<and>\n  selected_part UNIV P2 = {} \\<or>\n  strictly_maximal_literal (selected_part UNIV P2) (Neg A)", "have \"strictly_maximal_literal (selected_part UNIV P2) (Neg A)\""], ["proof (prove)\nusing this:\n  \\<not> (strictly_maximal_literal P2 (Neg A) \\<and>\n          selected_part UNIV P2 = {})\n  strictly_maximal_literal P2 (Neg A) \\<and>\n  selected_part UNIV P2 = {} \\<or>\n  strictly_maximal_literal (selected_part UNIV P2) (Neg A)\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal (selected_part UNIV P2) (Neg A)", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal (selected_part UNIV P2) (Neg A)\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from this"], ["proof (chain)\npicking this:\n  strictly_maximal_literal (selected_part UNIV P2) (Neg A)", "have \"strictly_maximal_literal (rename_clause Sel (validated_part Sel (rename_clause Sel P2))) (Neg A)\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal (selected_part UNIV P2) (Neg A)\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal\n     (rename_clause Sel (validated_part Sel (rename_clause Sel P2))) (Neg A)", "using renaming_and_selected_part"], ["proof (prove)\nusing this:\n  strictly_maximal_literal (selected_part UNIV P2) (Neg A)\n  selected_part UNIV ?C =\n  rename_clause ?Sel (validated_part ?Sel (rename_clause ?Sel ?C))\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal\n     (rename_clause Sel (validated_part Sel (rename_clause Sel P2))) (Neg A)", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal\n   (rename_clause Sel (validated_part Sel (rename_clause Sel P2))) (Neg A)\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from this"], ["proof (chain)\npicking this:\n  strictly_maximal_literal\n   (rename_clause Sel (validated_part Sel (rename_clause Sel P2))) (Neg A)", "have \n    \"strictly_maximal_literal (rename_clause Sel (rename_clause Sel (validated_part Sel (rename_clause Sel P2)))) \n        (rename_literal Sel (Neg A))\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal\n   (rename_clause Sel (validated_part Sel (rename_clause Sel P2))) (Neg A)\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal\n     (rename_clause Sel\n       (rename_clause Sel (validated_part Sel (rename_clause Sel P2))))\n     (rename_literal Sel (Neg A))", "using renaming_preserves_strictly_maximal_literal"], ["proof (prove)\nusing this:\n  strictly_maximal_literal\n   (rename_clause Sel (validated_part Sel (rename_clause Sel P2))) (Neg A)\n  strictly_maximal_literal ?C ?L \\<Longrightarrow>\n  strictly_maximal_literal (rename_clause ?A ?C) (rename_literal ?A ?L)\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal\n     (rename_clause Sel\n       (rename_clause Sel (validated_part Sel (rename_clause Sel P2))))\n     (rename_literal Sel (Neg A))", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal\n   (rename_clause Sel\n     (rename_clause Sel (validated_part Sel (rename_clause Sel P2))))\n   (rename_literal Sel (Neg A))\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from this"], ["proof (chain)\npicking this:\n  strictly_maximal_literal\n   (rename_clause Sel\n     (rename_clause Sel (validated_part Sel (rename_clause Sel P2))))\n   (rename_literal Sel (Neg A))", "have \n    p1: \"strictly_maximal_literal (validated_part Sel (rename_clause Sel P2)) \n      (rename_literal Sel (Neg A))\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal\n   (rename_clause Sel\n     (rename_clause Sel (validated_part Sel (rename_clause Sel P2))))\n   (rename_literal Sel (Neg A))\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal (validated_part Sel (rename_clause Sel P2))\n     (rename_literal Sel (Neg A))", "using inverse_clause_renaming"], ["proof (prove)\nusing this:\n  strictly_maximal_literal\n   (rename_clause Sel\n     (rename_clause Sel (validated_part Sel (rename_clause Sel P2))))\n   (rename_literal Sel (Neg A))\n  rename_clause ?A (rename_clause ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal (validated_part Sel (rename_clause Sel P2))\n     (rename_literal Sel (Neg A))", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal (validated_part Sel (rename_clause Sel P2))\n   (rename_literal Sel (Neg A))\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from \\<open>strictly_maximal_literal P1 (Pos A)\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal P1 (Pos A)", "have p2: \"strictly_maximal_literal (rename_clause Sel P1) (rename_literal Sel (Pos A))\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal P1 (Pos A)\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal (rename_clause Sel P1)\n     (rename_literal Sel (Pos A))", "using renaming_preserves_strictly_maximal_literal"], ["proof (prove)\nusing this:\n  strictly_maximal_literal P1 (Pos A)\n  strictly_maximal_literal ?C ?L \\<Longrightarrow>\n  strictly_maximal_literal (rename_clause ?A ?C) (rename_literal ?A ?L)\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal (rename_clause Sel P1)\n     (rename_literal Sel (Pos A))", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_literal (rename_clause Sel P1)\n   (rename_literal Sel (Pos A))\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from \\<open>(selected_part UNIV P1) = {}\\<close>"], ["proof (chain)\npicking this:\n  selected_part UNIV P1 = {}", "have \n    \"rename_clause Sel (validated_part Sel (rename_clause Sel P1)) = {}\""], ["proof (prove)\nusing this:\n  selected_part UNIV P1 = {}\n\ngoal (1 subgoal):\n 1. rename_clause Sel (validated_part Sel (rename_clause Sel P1)) = {}", "using renaming_and_selected_part"], ["proof (prove)\nusing this:\n  selected_part UNIV P1 = {}\n  selected_part UNIV ?C =\n  rename_clause ?Sel (validated_part ?Sel (rename_clause ?Sel ?C))\n\ngoal (1 subgoal):\n 1. rename_clause Sel (validated_part Sel (rename_clause Sel P1)) = {}", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel (validated_part Sel (rename_clause Sel P1)) = {}\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from this"], ["proof (chain)\npicking this:\n  rename_clause Sel (validated_part Sel (rename_clause Sel P1)) = {}", "have q: \"validated_part Sel (rename_clause Sel P1) = {}\""], ["proof (prove)\nusing this:\n  rename_clause Sel (validated_part Sel (rename_clause Sel P1)) = {}\n\ngoal (1 subgoal):\n 1. validated_part Sel (rename_clause Sel P1) = {}", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  {L. \\<exists>LL.\n         LL \\<in> validated_part Sel\n                   {L. \\<exists>LL.\n                          LL \\<in> P1 \\<and>\n                          L = rename_literal Sel LL} \\<and>\n         L = rename_literal Sel LL} =\n  {}\n\ngoal (1 subgoal):\n 1. validated_part Sel\n     {L. \\<exists>LL. LL \\<in> P1 \\<and> L = rename_literal Sel LL} =\n    {}", "by auto"], ["proof (state)\nthis:\n  validated_part Sel (rename_clause Sel P1) = {}\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "have r: \"rename_literal Sel (Neg A) = complement (rename_literal Sel (Pos A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_literal Sel (Neg A) = complement (rename_literal Sel (Pos A))", "unfolding rename_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if atom (Neg A) \\<in> Sel then complement (Neg A) else Neg A) =\n    complement\n     (if atom (Pos A) \\<in> Sel then complement (Pos A) else Pos A)", "by auto"], ["proof (state)\nthis:\n  rename_literal Sel (Neg A) = complement (rename_literal Sel (Pos A))\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "from r and q and p1 and p2 and rc_def"], ["proof (chain)\npicking this:\n  rename_literal Sel (Neg A) = complement (rename_literal Sel (Pos A))\n  validated_part Sel (rename_clause Sel P1) = {}\n  strictly_maximal_literal (validated_part Sel (rename_clause Sel P2))\n   (rename_literal Sel (Neg A))\n  strictly_maximal_literal (rename_clause Sel P1)\n   (rename_literal Sel (Pos A))\n  rename_clause Sel C =\n  rename_clause Sel P1 - {rename_literal Sel (Pos A)} \\<union>\n  (rename_clause Sel P2 - {rename_literal Sel (Neg A)})", "show \n    \"ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2)(rename_clause Sel C)\""], ["proof (prove)\nusing this:\n  rename_literal Sel (Neg A) = complement (rename_literal Sel (Pos A))\n  validated_part Sel (rename_clause Sel P1) = {}\n  strictly_maximal_literal (validated_part Sel (rename_clause Sel P2))\n   (rename_literal Sel (Neg A))\n  strictly_maximal_literal (rename_clause Sel P1)\n   (rename_literal Sel (Pos A))\n  rename_clause Sel C =\n  rename_clause Sel P1 - {rename_literal Sel (Pos A)} \\<union>\n  (rename_clause Sel P2 - {rename_literal Sel (Neg A)})\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "using ordered_model_resolvent_def [of Sel \"rename_clause Sel P1\" \"rename_clause Sel P2\" \n      \"rename_clause Sel C\"]"], ["proof (prove)\nusing this:\n  rename_literal Sel (Neg A) = complement (rename_literal Sel (Pos A))\n  validated_part Sel (rename_clause Sel P1) = {}\n  strictly_maximal_literal (validated_part Sel (rename_clause Sel P2))\n   (rename_literal Sel (Neg A))\n  strictly_maximal_literal (rename_clause Sel P1)\n   (rename_literal Sel (Pos A))\n  rename_clause Sel C =\n  rename_clause Sel P1 - {rename_literal Sel (Pos A)} \\<union>\n  (rename_clause Sel P2 - {rename_literal Sel (Neg A)})\n  ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2)\n   (rename_clause Sel C) =\n  (\\<exists>L.\n      rename_clause Sel C =\n      rename_clause Sel P1 - {L} \\<union>\n      (rename_clause Sel P2 - {complement L}) \\<and>\n      (validated_part Sel (rename_clause Sel P1) = {} \\<and>\n       strictly_maximal_literal (rename_clause Sel P1) L) \\<and>\n      strictly_maximal_literal (validated_part Sel (rename_clause Sel P2))\n       (complement L))\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "by auto"], ["proof (state)\nthis:\n  ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2)\n   (rename_clause Sel C)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ordered_resolution_is_complete_model_resolution:\n  \"Complete (ordered_model_resolvent Sel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete (ordered_model_resolvent Sel)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_model_resolvent Sel) \\<Longrightarrow> False", "assume \"\\<not>Complete (ordered_model_resolvent Sel)\""], ["proof (state)\nthis:\n  \\<not> Complete (ordered_model_resolvent Sel)\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_model_resolvent Sel) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Complete (ordered_model_resolvent Sel)", "obtain S where \"saturated_binary_rule (ordered_model_resolvent Sel) S\"\n    and \"{} \\<notin> S\" and \"all_fulfill finite S\" and \"\\<not>(satisfiable S)\""], ["proof (prove)\nusing this:\n  \\<not> Complete (ordered_model_resolvent Sel)\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>saturated_binary_rule (ordered_model_resolvent Sel) S;\n         {} \\<notin> S; all_fulfill finite S; \\<not> satisfiable S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Complete_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>S.\n             saturated_binary_rule (ordered_model_resolvent Sel)\n              S \\<longrightarrow>\n             all_fulfill finite S \\<longrightarrow>\n             {} \\<notin> S \\<longrightarrow> satisfiable S)\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>saturated_binary_rule (ordered_model_resolvent Sel) S;\n         {} \\<notin> S; all_fulfill finite S; \\<not> satisfiable S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  saturated_binary_rule (ordered_model_resolvent Sel) S\n  {} \\<notin> S\n  all_fulfill finite S\n  \\<not> satisfiable S\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_model_resolvent Sel) \\<Longrightarrow> False", "let ?S' = \"rename_formula Sel S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_model_resolvent Sel) \\<Longrightarrow> False", "have \"{} \\<notin> ?S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<notin> rename_formula Sel S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. {} \\<in> rename_formula Sel S \\<Longrightarrow> False", "assume \"{} \\<in> ?S'\""], ["proof (state)\nthis:\n  {} \\<in> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. {} \\<in> rename_formula Sel S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {} \\<in> rename_formula Sel S", "obtain V where \"V \\<in> S\" and \"rename_clause Sel V = {}\""], ["proof (prove)\nusing this:\n  {} \\<in> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>V \\<in> S; rename_clause Sel V = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rename_formula_def"], ["proof (prove)\nusing this:\n  {} \\<in> {C. \\<exists>CC. CC \\<in> S \\<and> C = rename_clause Sel CC}\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>V \\<in> S; rename_clause Sel V = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V \\<in> S\n  rename_clause Sel V = {}\n\ngoal (1 subgoal):\n 1. {} \\<in> rename_formula Sel S \\<Longrightarrow> False", "from \\<open>rename_clause Sel V = {}\\<close>"], ["proof (chain)\npicking this:\n  rename_clause Sel V = {}", "have \"V = {}\""], ["proof (prove)\nusing this:\n  rename_clause Sel V = {}\n\ngoal (1 subgoal):\n 1. V = {}", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  {L. \\<exists>LL. LL \\<in> V \\<and> L = rename_literal Sel LL} = {}\n\ngoal (1 subgoal):\n 1. V = {}", "by auto"], ["proof (state)\nthis:\n  V = {}\n\ngoal (1 subgoal):\n 1. {} \\<in> rename_formula Sel S \\<Longrightarrow> False", "from this and \\<open>V \\<in> S\\<close>  and \\<open>{} \\<notin> S\\<close>"], ["proof (chain)\npicking this:\n  V = {}\n  V \\<in> S\n  {} \\<notin> S", "show \"False\""], ["proof (prove)\nusing this:\n  V = {}\n  V \\<in> S\n  {} \\<notin> S\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {} \\<notin> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_model_resolvent Sel) \\<Longrightarrow> False", "from \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S", "have \"all_fulfill finite ?S'\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. all_fulfill finite (rename_formula Sel S)", "unfolding all_fulfill_def rename_formula_def rename_clause_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       C \\<in> {C. \\<exists>CC.\n                      CC \\<in> S \\<and>\n                      C =\n                      {L. \\<exists>LL.\n                             LL \\<in> CC \\<and>\n                             L = rename_literal Sel LL}} \\<longrightarrow>\n       finite C", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_model_resolvent Sel) \\<Longrightarrow> False", "have \"saturated_binary_rule (ordered_sel_resolvent UNIV) ?S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_binary_rule (ordered_sel_resolvent UNIV)\n     (rename_formula Sel S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "assume \"\\<not>(saturated_binary_rule (ordered_sel_resolvent UNIV) ?S')\""], ["proof (state)\nthis:\n  \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n          (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n          (rename_formula Sel S)", "obtain P1 and P2 and C where \"P1 \\<in> ?S'\" and \"P2 \\<in> ?S'\" \n      and \"ordered_sel_resolvent UNIV P1 P2 C\" and \"\\<not>tautology C\" \n      and not_subsumed: \"\\<forall>D. (D \\<in> ?S' \\<longrightarrow> \\<not>subsumes D C)\""], ["proof (prove)\nusing this:\n  \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n          (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> rename_formula Sel S;\n         P2 \\<in> rename_formula Sel S; ordered_sel_resolvent UNIV P1 P2 C;\n         \\<not> tautology C;\n         \\<forall>D.\n            D \\<in> rename_formula Sel S \\<longrightarrow>\n            \\<not> subsumes D C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding saturated_binary_rule_def redundant_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             P1 \\<in> rename_formula Sel S \\<and>\n             P2 \\<in> rename_formula Sel S \\<and>\n             ordered_sel_resolvent UNIV P1 P2 C \\<longrightarrow>\n             tautology C \\<or>\n             (\\<exists>D. D \\<in> rename_formula Sel S \\<and> subsumes D C))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> rename_formula Sel S;\n         P2 \\<in> rename_formula Sel S; ordered_sel_resolvent UNIV P1 P2 C;\n         \\<not> tautology C;\n         \\<forall>D.\n            D \\<in> rename_formula Sel S \\<longrightarrow>\n            \\<not> subsumes D C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> rename_formula Sel S\n  P2 \\<in> rename_formula Sel S\n  ordered_sel_resolvent UNIV P1 P2 C\n  \\<not> tautology C\n  \\<forall>D.\n     D \\<in> rename_formula Sel S \\<longrightarrow> \\<not> subsumes D C\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "from \\<open>ordered_sel_resolvent UNIV P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  ordered_sel_resolvent UNIV P1 P2 C", "have ord_ren: \"ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2) \n                        (rename_clause Sel C)\""], ["proof (prove)\nusing this:\n  ordered_sel_resolvent UNIV P1 P2 C\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "using ordered_res_with_selection_is_model_res"], ["proof (prove)\nusing this:\n  ordered_sel_resolvent UNIV P1 P2 C\n  ordered_sel_resolvent UNIV ?P1.0 ?P2.0 ?C \\<Longrightarrow>\n  ordered_model_resolvent ?Sel (rename_clause ?Sel ?P1.0)\n   (rename_clause ?Sel ?P2.0) (rename_clause ?Sel ?C)\n\ngoal (1 subgoal):\n 1. ordered_model_resolvent Sel (rename_clause Sel P1)\n     (rename_clause Sel P2) (rename_clause Sel C)", "by auto"], ["proof (state)\nthis:\n  ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2)\n   (rename_clause Sel C)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "have \"\\<not>tautology (rename_clause Sel C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> tautology (rename_clause Sel C)", "using renaming_preserves_tautology inverse_clause_renaming"], ["proof (prove)\nusing this:\n  tautology ?C \\<Longrightarrow> tautology (rename_clause ?Sel ?C)\n  rename_clause ?A (rename_clause ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. \\<not> tautology (rename_clause Sel C)", "by (metis \\<open>\\<not> tautology C\\<close> inverse_clause_renaming renaming_preserves_tautology)"], ["proof (state)\nthis:\n  \\<not> tautology (rename_clause Sel C)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> ?S'\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> rename_formula Sel S", "have \"rename_clause Sel P1 \\<in> rename_formula Sel ?S'\""], ["proof (prove)\nusing this:\n  P1 \\<in> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. rename_clause Sel P1 \\<in> rename_formula Sel (rename_formula Sel S)", "unfolding rename_formula_def"], ["proof (prove)\nusing this:\n  P1 \\<in> {C. \\<exists>CC. CC \\<in> S \\<and> C = rename_clause Sel CC}\n\ngoal (1 subgoal):\n 1. rename_clause Sel P1\n    \\<in> {C. \\<exists>CC.\n                 CC \\<in> {C. \\<exists>CC.\n                                 CC \\<in> S \\<and>\n                                 C = rename_clause Sel CC} \\<and>\n                 C = rename_clause Sel CC}", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel P1 \\<in> rename_formula Sel (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "hence \"rename_clause Sel P1 \\<in> S\""], ["proof (prove)\nusing this:\n  rename_clause Sel P1 \\<in> rename_formula Sel (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. rename_clause Sel P1 \\<in> S", "using inverse_formula_renaming"], ["proof (prove)\nusing this:\n  rename_clause Sel P1 \\<in> rename_formula Sel (rename_formula Sel S)\n  rename_formula ?A (rename_formula ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. rename_clause Sel P1 \\<in> S", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel P1 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "from \\<open>P2 \\<in> ?S'\\<close>"], ["proof (chain)\npicking this:\n  P2 \\<in> rename_formula Sel S", "have \"rename_clause Sel P2 \\<in> rename_formula Sel ?S'\""], ["proof (prove)\nusing this:\n  P2 \\<in> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. rename_clause Sel P2 \\<in> rename_formula Sel (rename_formula Sel S)", "unfolding rename_formula_def"], ["proof (prove)\nusing this:\n  P2 \\<in> {C. \\<exists>CC. CC \\<in> S \\<and> C = rename_clause Sel CC}\n\ngoal (1 subgoal):\n 1. rename_clause Sel P2\n    \\<in> {C. \\<exists>CC.\n                 CC \\<in> {C. \\<exists>CC.\n                                 CC \\<in> S \\<and>\n                                 C = rename_clause Sel CC} \\<and>\n                 C = rename_clause Sel CC}", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel P2 \\<in> rename_formula Sel (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "hence \"rename_clause Sel P2 \\<in> S\""], ["proof (prove)\nusing this:\n  rename_clause Sel P2 \\<in> rename_formula Sel (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. rename_clause Sel P2 \\<in> S", "using inverse_formula_renaming"], ["proof (prove)\nusing this:\n  rename_clause Sel P2 \\<in> rename_formula Sel (rename_formula Sel S)\n  rename_formula ?A (rename_formula ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. rename_clause Sel P2 \\<in> S", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel P2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "from \\<open>\\<not>tautology (rename_clause Sel C)\\<close> and ord_ren \n      and \\<open>saturated_binary_rule (ordered_model_resolvent Sel) S\\<close> \n      and \\<open>rename_clause Sel P1 \\<in> S\\<close> and \\<open>rename_clause Sel P2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology (rename_clause Sel C)\n  ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2)\n   (rename_clause Sel C)\n  saturated_binary_rule (ordered_model_resolvent Sel) S\n  rename_clause Sel P1 \\<in> S\n  rename_clause Sel P2 \\<in> S", "obtain D' where \"D' \\<in> S\" and \"subsumes D' (rename_clause Sel C)\""], ["proof (prove)\nusing this:\n  \\<not> tautology (rename_clause Sel C)\n  ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2)\n   (rename_clause Sel C)\n  saturated_binary_rule (ordered_model_resolvent Sel) S\n  rename_clause Sel P1 \\<in> S\n  rename_clause Sel P2 \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>D'.\n        \\<lbrakk>D' \\<in> S; subsumes D' (rename_clause Sel C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding saturated_binary_rule_def redundant_def"], ["proof (prove)\nusing this:\n  \\<not> tautology (rename_clause Sel C)\n  ordered_model_resolvent Sel (rename_clause Sel P1) (rename_clause Sel P2)\n   (rename_clause Sel C)\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and> ordered_model_resolvent Sel P1 P2 C \\<longrightarrow>\n     tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  rename_clause Sel P1 \\<in> S\n  rename_clause Sel P2 \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>D'.\n        \\<lbrakk>D' \\<in> S; subsumes D' (rename_clause Sel C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D' \\<in> S\n  subsumes D' (rename_clause Sel C)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "from \\<open>subsumes D' (rename_clause Sel C)\\<close>"], ["proof (chain)\npicking this:\n  subsumes D' (rename_clause Sel C)", "have \"subsumes (rename_clause Sel D') (rename_clause Sel (rename_clause Sel C))\""], ["proof (prove)\nusing this:\n  subsumes D' (rename_clause Sel C)\n\ngoal (1 subgoal):\n 1. subsumes (rename_clause Sel D')\n     (rename_clause Sel (rename_clause Sel C))", "using renaming_preserves_subsumption"], ["proof (prove)\nusing this:\n  subsumes D' (rename_clause Sel C)\n  subsumes ?C ?D \\<Longrightarrow>\n  subsumes (rename_clause ?Sel ?C) (rename_clause ?Sel ?D)\n\ngoal (1 subgoal):\n 1. subsumes (rename_clause Sel D')\n     (rename_clause Sel (rename_clause Sel C))", "by auto"], ["proof (state)\nthis:\n  subsumes (rename_clause Sel D') (rename_clause Sel (rename_clause Sel C))\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "hence \"subsumes (rename_clause Sel D') C\""], ["proof (prove)\nusing this:\n  subsumes (rename_clause Sel D') (rename_clause Sel (rename_clause Sel C))\n\ngoal (1 subgoal):\n 1. subsumes (rename_clause Sel D') C", "using inverse_clause_renaming"], ["proof (prove)\nusing this:\n  subsumes (rename_clause Sel D') (rename_clause Sel (rename_clause Sel C))\n  rename_clause ?A (rename_clause ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. subsumes (rename_clause Sel D') C", "by auto"], ["proof (state)\nthis:\n  subsumes (rename_clause Sel D') C\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "from \\<open>D' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  D' \\<in> S", "have \"rename_clause Sel D' \\<in> ?S'\""], ["proof (prove)\nusing this:\n  D' \\<in> S\n\ngoal (1 subgoal):\n 1. rename_clause Sel D' \\<in> rename_formula Sel S", "unfolding rename_formula_def"], ["proof (prove)\nusing this:\n  D' \\<in> S\n\ngoal (1 subgoal):\n 1. rename_clause Sel D'\n    \\<in> {C. \\<exists>CC. CC \\<in> S \\<and> C = rename_clause Sel CC}", "by auto"], ["proof (state)\nthis:\n  rename_clause Sel D' \\<in> rename_formula Sel S\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_sel_resolvent UNIV)\n            (rename_formula Sel S) \\<Longrightarrow>\n    False", "from this and not_subsumed and  \\<open>subsumes (rename_clause Sel D') C\\<close>"], ["proof (chain)\npicking this:\n  rename_clause Sel D' \\<in> rename_formula Sel S\n  \\<forall>D.\n     D \\<in> rename_formula Sel S \\<longrightarrow> \\<not> subsumes D C\n  subsumes (rename_clause Sel D') C", "show \"False\""], ["proof (prove)\nusing this:\n  rename_clause Sel D' \\<in> rename_formula Sel S\n  \\<forall>D.\n     D \\<in> rename_formula Sel S \\<longrightarrow> \\<not> subsumes D C\n  subsumes (rename_clause Sel D') C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  saturated_binary_rule (ordered_sel_resolvent UNIV) (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_model_resolvent Sel) \\<Longrightarrow> False", "from this and \\<open>{} \\<notin> ?S'\\<close> and \\<open>all_fulfill finite ?S'\\<close>"], ["proof (chain)\npicking this:\n  saturated_binary_rule (ordered_sel_resolvent UNIV) (rename_formula Sel S)\n  {} \\<notin> rename_formula Sel S\n  all_fulfill finite (rename_formula Sel S)", "have \"satisfiable ?S'\""], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_sel_resolvent UNIV) (rename_formula Sel S)\n  {} \\<notin> rename_formula Sel S\n  all_fulfill finite (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel S)", "using ordered_resolution_is_complete_ordered_sel"], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_sel_resolvent UNIV) (rename_formula Sel S)\n  {} \\<notin> rename_formula Sel S\n  all_fulfill finite (rename_formula Sel S)\n  Complete (ordered_sel_resolvent ?Sel)\n\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel S)", "unfolding Complete_def"], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_sel_resolvent UNIV) (rename_formula Sel S)\n  {} \\<notin> rename_formula Sel S\n  all_fulfill finite (rename_formula Sel S)\n  \\<forall>S.\n     saturated_binary_rule (ordered_sel_resolvent ?Sel) S \\<longrightarrow>\n     all_fulfill finite S \\<longrightarrow>\n     {} \\<notin> S \\<longrightarrow> satisfiable S\n\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel S)", "by auto"], ["proof (state)\nthis:\n  satisfiable (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_model_resolvent Sel) \\<Longrightarrow> False", "hence \"satisfiable (rename_formula Sel ?S')\""], ["proof (prove)\nusing this:\n  satisfiable (rename_formula Sel S)\n\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel (rename_formula Sel S))", "using renaming_preserves_satisfiability"], ["proof (prove)\nusing this:\n  satisfiable (rename_formula Sel S)\n  satisfiable ?S \\<Longrightarrow> satisfiable (rename_formula ?Sel ?S)\n\ngoal (1 subgoal):\n 1. satisfiable (rename_formula Sel (rename_formula Sel S))", "by auto"], ["proof (state)\nthis:\n  satisfiable (rename_formula Sel (rename_formula Sel S))\n\ngoal (1 subgoal):\n 1. \\<not> Complete (ordered_model_resolvent Sel) \\<Longrightarrow> False", "from this and \\<open>\\<not>satisfiable S\\<close>"], ["proof (chain)\npicking this:\n  satisfiable (rename_formula Sel (rename_formula Sel S))\n  \\<not> satisfiable S", "show \"False\""], ["proof (prove)\nusing this:\n  satisfiable (rename_formula Sel (rename_formula Sel S))\n  \\<not> satisfiable S\n\ngoal (1 subgoal):\n 1. False", "using inverse_formula_renaming"], ["proof (prove)\nusing this:\n  satisfiable (rename_formula Sel (rename_formula Sel S))\n  \\<not> satisfiable S\n  rename_formula ?A (rename_formula ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Positive and Negative Resolution\\<close>"], ["", "text \\<open>We show that positive and negative resolution simulate model resolution \nwith some specific interpretation. Then completeness follows from previous results.\\<close>"], ["", "lemma empty_interpretation_validate :\n  \"validate_literal {} L = (\\<exists>A. (L = Neg A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<Turnstile> L = (\\<exists>A. L = Neg A)", "by (meson empty_iff validate_literal.elims(2) validate_literal.simps(2))"], ["", "lemma universal_interpretation_validate :\n  \"validate_literal UNIV L = (\\<exists>A. (L = Pos A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<Turnstile> L = (\\<exists>A. L = Pos A)", "by (meson UNIV_I validate_literal.elims(2) validate_literal.simps(1))"], ["", "lemma negative_part_lemma:\n  \"(negative_part C) = (validated_part {} C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negative_part C = validated_part {} C", "unfolding negative_part_def validated_part_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {L. (\\<exists>A. L = Neg A) \\<and> L \\<in> C} =\n    {L \\<in> C. {} \\<Turnstile> L}", "using empty_interpretation_validate"], ["proof (prove)\nusing this:\n  {} \\<Turnstile> ?L = (\\<exists>A. ?L = Neg A)\n\ngoal (1 subgoal):\n 1. {L. (\\<exists>A. L = Neg A) \\<and> L \\<in> C} =\n    {L \\<in> C. {} \\<Turnstile> L}", "by blast"], ["", "lemma positive_part_lemma:\n  \"(positive_part C) = (validated_part UNIV C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive_part C = validated_part UNIV C", "unfolding positive_part_def validated_part_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {L. (\\<exists>A. L = Pos A) \\<and> L \\<in> C} =\n    {L \\<in> C. UNIV \\<Turnstile> L}", "using universal_interpretation_validate"], ["proof (prove)\nusing this:\n  UNIV \\<Turnstile> ?L = (\\<exists>A. ?L = Pos A)\n\ngoal (1 subgoal):\n 1. {L. (\\<exists>A. L = Pos A) \\<and> L \\<in> C} =\n    {L \\<in> C. UNIV \\<Turnstile> L}", "by blast"], ["", "lemma negative_resolvent_is_model_res:\n  \"less_restrictive ordered_negative_resolvent (ordered_model_resolvent UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_restrictive ordered_negative_resolvent\n     (ordered_model_resolvent UNIV)", "unfolding ordered_negative_resolvent_def ordered_model_resolvent_def  less_restrictive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P1 P2 C.\n       (\\<exists>L.\n           C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n           (validated_part UNIV P1 = {} \\<and>\n            strictly_maximal_literal P1 L) \\<and>\n           strictly_maximal_literal (validated_part UNIV P2)\n            (complement L)) \\<longrightarrow>\n       (\\<exists>L.\n           C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n           (positive_part P1 = {} \\<and>\n            strictly_maximal_literal P1 L) \\<and>\n           strictly_maximal_literal (positive_part P2) (complement L)) \\<or>\n       (\\<exists>L.\n           C = P2 - {L} \\<union> (P1 - {complement L}) \\<and>\n           (positive_part P2 = {} \\<and>\n            strictly_maximal_literal P2 L) \\<and>\n           strictly_maximal_literal (positive_part P1) (complement L))", "using positive_part_lemma"], ["proof (prove)\nusing this:\n  positive_part ?C = validated_part UNIV ?C\n\ngoal (1 subgoal):\n 1. \\<forall>P1 P2 C.\n       (\\<exists>L.\n           C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n           (validated_part UNIV P1 = {} \\<and>\n            strictly_maximal_literal P1 L) \\<and>\n           strictly_maximal_literal (validated_part UNIV P2)\n            (complement L)) \\<longrightarrow>\n       (\\<exists>L.\n           C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n           (positive_part P1 = {} \\<and>\n            strictly_maximal_literal P1 L) \\<and>\n           strictly_maximal_literal (positive_part P2) (complement L)) \\<or>\n       (\\<exists>L.\n           C = P2 - {L} \\<union> (P1 - {complement L}) \\<and>\n           (positive_part P2 = {} \\<and>\n            strictly_maximal_literal P2 L) \\<and>\n           strictly_maximal_literal (positive_part P1) (complement L))", "by auto"], ["", "lemma positive_resolvent_is_model_res:\n  \"less_restrictive ordered_positive_resolvent (ordered_model_resolvent {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_restrictive ordered_positive_resolvent (ordered_model_resolvent {})", "unfolding ordered_positive_resolvent_def ordered_model_resolvent_def less_restrictive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P1 P2 C.\n       (\\<exists>L.\n           C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n           (validated_part {} P1 = {} \\<and>\n            strictly_maximal_literal P1 L) \\<and>\n           strictly_maximal_literal (validated_part {} P2)\n            (complement L)) \\<longrightarrow>\n       (\\<exists>L.\n           C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n           (negative_part P1 = {} \\<and>\n            strictly_maximal_literal P1 L) \\<and>\n           strictly_maximal_literal (negative_part P2) (complement L)) \\<or>\n       (\\<exists>L.\n           C = P2 - {L} \\<union> (P1 - {complement L}) \\<and>\n           (negative_part P2 = {} \\<and>\n            strictly_maximal_literal P2 L) \\<and>\n           strictly_maximal_literal (negative_part P1) (complement L))", "using negative_part_lemma"], ["proof (prove)\nusing this:\n  negative_part ?C = validated_part {} ?C\n\ngoal (1 subgoal):\n 1. \\<forall>P1 P2 C.\n       (\\<exists>L.\n           C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n           (validated_part {} P1 = {} \\<and>\n            strictly_maximal_literal P1 L) \\<and>\n           strictly_maximal_literal (validated_part {} P2)\n            (complement L)) \\<longrightarrow>\n       (\\<exists>L.\n           C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n           (negative_part P1 = {} \\<and>\n            strictly_maximal_literal P1 L) \\<and>\n           strictly_maximal_literal (negative_part P2) (complement L)) \\<or>\n       (\\<exists>L.\n           C = P2 - {L} \\<union> (P1 - {complement L}) \\<and>\n           (negative_part P2 = {} \\<and>\n            strictly_maximal_literal P2 L) \\<and>\n           strictly_maximal_literal (negative_part P1) (complement L))", "by auto"], ["", "theorem ordered_positive_resolvent_is_complete : \"Complete ordered_positive_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete ordered_positive_resolvent", "using ordered_resolution_is_complete_model_resolution less_restrictive_complete positive_resolvent_is_model_res"], ["proof (prove)\nusing this:\n  Complete (ordered_model_resolvent ?Sel)\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0; Complete ?R2.0\\<rbrakk>\n  \\<Longrightarrow> Complete ?R1.0\n  less_restrictive ordered_positive_resolvent (ordered_model_resolvent {})\n\ngoal (1 subgoal):\n 1. Complete ordered_positive_resolvent", "by auto"], ["", "theorem ordered_negative_resolvent_is_complete: \"Complete ordered_negative_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete ordered_negative_resolvent", "using ordered_resolution_is_complete_model_resolution less_restrictive_complete negative_resolvent_is_model_res"], ["proof (prove)\nusing this:\n  Complete (ordered_model_resolvent ?Sel)\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0; Complete ?R2.0\\<rbrakk>\n  \\<Longrightarrow> Complete ?R1.0\n  less_restrictive ordered_negative_resolvent (ordered_model_resolvent UNIV)\n\ngoal (1 subgoal):\n 1. Complete ordered_negative_resolvent", "by auto"], ["", "subsection \\<open>Unit Resolution and Horn Renamable Clauses\\<close>"], ["", "text \\<open>Unit resolution is complete if the considered clause set can be transformed into a \nHorn clause set by renaming. \nThis result is proven by showing that unit resolution simulates\nsemantic resolution for Horn-renamable clauses (for some specific interpretation).\\<close>"], ["", "definition Horn :: \"'at Clause \\<Rightarrow> bool\"\n  where \"(Horn C) = ((card (positive_part C)) \\<le> 1)\""], ["", "definition Horn_renamable_formula :: \"'at Formula \\<Rightarrow> bool\"\n  where \"Horn_renamable_formula S = (\\<exists>I. (all_fulfill Horn (rename_formula I S)))\""], ["", "theorem unit_resolvent_complete_for_Horn_renamable_set:\n  assumes \"saturated_binary_rule unit_resolvent S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"{} \\<notin> S\" \n  assumes \"Horn_renamable_formula S\"\n  shows \"satisfiable S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable S", "from \\<open>Horn_renamable_formula S\\<close>"], ["proof (chain)\npicking this:\n  Horn_renamable_formula S", "obtain I where \"all_fulfill Horn (rename_formula I S)\""], ["proof (prove)\nusing this:\n  Horn_renamable_formula S\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        all_fulfill Horn (rename_formula I S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Horn_renamable_formula_def"], ["proof (prove)\nusing this:\n  \\<exists>I. all_fulfill Horn (rename_formula I S)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        all_fulfill Horn (rename_formula I S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  all_fulfill Horn (rename_formula I S)\n\ngoal (1 subgoal):\n 1. satisfiable S", "have \"saturated_binary_rule (ordered_model_resolvent I) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_binary_rule (ordered_model_resolvent I) S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "assume \"\\<not>saturated_binary_rule (ordered_model_resolvent I) S\""], ["proof (state)\nthis:\n  \\<not> saturated_binary_rule (ordered_model_resolvent I) S\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> saturated_binary_rule (ordered_model_resolvent I) S", "obtain P1 P2 C where \"ordered_model_resolvent I P1 P2 C\" and \"P1 \\<in> S\" and \"P2 \\<in> S\" \n      and \"\\<not>redundant C S\""], ["proof (prove)\nusing this:\n  \\<not> saturated_binary_rule (ordered_model_resolvent I) S\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>ordered_model_resolvent I P1 P2 C; P1 \\<in> S; P2 \\<in> S;\n         \\<not> redundant C S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding saturated_binary_rule_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             P1 \\<in> S \\<and>\n             P2 \\<in> S \\<and>\n             ordered_model_resolvent I P1 P2 C \\<longrightarrow>\n             redundant C S)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>ordered_model_resolvent I P1 P2 C; P1 \\<in> S; P2 \\<in> S;\n         \\<not> redundant C S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ordered_model_resolvent I P1 P2 C\n  P1 \\<in> S\n  P2 \\<in> S\n  \\<not> redundant C S\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from \\<open>ordered_model_resolvent I P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  ordered_model_resolvent I P1 P2 C", "obtain L \n      where def_c: \"C = ( (P1 - { L }) \\<union> ( P2 - { (complement L) }))\" \n      and \"strictly_maximal_literal P1 L\" and \"validated_part I P1 = {}\" \n      and \"strictly_maximal_literal (validated_part I P2) (complement L)\""], ["proof (prove)\nusing this:\n  ordered_model_resolvent I P1 P2 C\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>C = P1 - {L} \\<union> (P2 - {complement L});\n         strictly_maximal_literal P1 L; validated_part I P1 = {};\n         strictly_maximal_literal (validated_part I P2)\n          (complement L)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ordered_model_resolvent_def"], ["proof (prove)\nusing this:\n  \\<exists>L.\n     C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n     (validated_part I P1 = {} \\<and> strictly_maximal_literal P1 L) \\<and>\n     strictly_maximal_literal (validated_part I P2) (complement L)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>C = P1 - {L} \\<union> (P2 - {complement L});\n         strictly_maximal_literal P1 L; validated_part I P1 = {};\n         strictly_maximal_literal (validated_part I P2)\n          (complement L)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = P1 - {L} \\<union> (P2 - {complement L})\n  strictly_maximal_literal P1 L\n  validated_part I P1 = {}\n  strictly_maximal_literal (validated_part I P2) (complement L)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal P1 L\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal P1 L", "have \"L \\<in> P1\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal P1 L\n\ngoal (1 subgoal):\n 1. L \\<in> P1", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> P1 \\<and>\n  (\\<forall>B.\n      B \\<in> P1 \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n\ngoal (1 subgoal):\n 1. L \\<in> P1", "by auto"], ["proof (state)\nthis:\n  L \\<in> P1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal (validated_part I P2) (complement L)\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal (validated_part I P2) (complement L)", "have \"complement L \\<in> P2\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal (validated_part I P2) (complement L)\n\ngoal (1 subgoal):\n 1. complement L \\<in> P2", "unfolding strictly_maximal_literal_def validated_part_def"], ["proof (prove)\nusing this:\n  complement L \\<in> {L \\<in> P2. I \\<Turnstile> L} \\<and>\n  (\\<forall>B.\n      B \\<in> {L \\<in> P2. I \\<Turnstile> L} \\<and>\n      complement L \\<noteq> B \\<longrightarrow>\n      literal_ordering B (complement L))\n\ngoal (1 subgoal):\n 1. complement L \\<in> P2", "by auto"], ["proof (state)\nthis:\n  complement L \\<in> P2\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "have \"selected_part UNIV (rename_clause I P1) \n      =  rename_clause I (validated_part I (rename_clause I (rename_clause I P1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selected_part UNIV (rename_clause I P1) =\n    rename_clause I\n     (validated_part I (rename_clause I (rename_clause I P1)))", "using renaming_and_selected_part [of \"rename_clause I P1\" I]"], ["proof (prove)\nusing this:\n  selected_part UNIV (rename_clause I P1) =\n  rename_clause I (validated_part I (rename_clause I (rename_clause I P1)))\n\ngoal (1 subgoal):\n 1. selected_part UNIV (rename_clause I P1) =\n    rename_clause I\n     (validated_part I (rename_clause I (rename_clause I P1)))", "by auto"], ["proof (state)\nthis:\n  selected_part UNIV (rename_clause I P1) =\n  rename_clause I (validated_part I (rename_clause I (rename_clause I P1)))\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  selected_part UNIV (rename_clause I P1) =\n  rename_clause I (validated_part I (rename_clause I (rename_clause I P1)))", "have \"selected_part UNIV (rename_clause I P1) =  rename_clause I (validated_part I P1)\""], ["proof (prove)\nusing this:\n  selected_part UNIV (rename_clause I P1) =\n  rename_clause I (validated_part I (rename_clause I (rename_clause I P1)))\n\ngoal (1 subgoal):\n 1. selected_part UNIV (rename_clause I P1) =\n    rename_clause I (validated_part I P1)", "using inverse_clause_renaming"], ["proof (prove)\nusing this:\n  selected_part UNIV (rename_clause I P1) =\n  rename_clause I (validated_part I (rename_clause I (rename_clause I P1)))\n  rename_clause ?A (rename_clause ?A ?L) = ?L\n\ngoal (1 subgoal):\n 1. selected_part UNIV (rename_clause I P1) =\n    rename_clause I (validated_part I P1)", "by auto"], ["proof (state)\nthis:\n  selected_part UNIV (rename_clause I P1) =\n  rename_clause I (validated_part I P1)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from this and \\<open>validated_part I P1 = {}\\<close>"], ["proof (chain)\npicking this:\n  selected_part UNIV (rename_clause I P1) =\n  rename_clause I (validated_part I P1)\n  validated_part I P1 = {}", "have \"selected_part UNIV (rename_clause I P1) = {}\""], ["proof (prove)\nusing this:\n  selected_part UNIV (rename_clause I P1) =\n  rename_clause I (validated_part I P1)\n  validated_part I P1 = {}\n\ngoal (1 subgoal):\n 1. selected_part UNIV (rename_clause I P1) = {}", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  selected_part UNIV\n   {L. \\<exists>LL. LL \\<in> P1 \\<and> L = rename_literal I LL} =\n  {L. \\<exists>LL.\n         LL \\<in> validated_part I P1 \\<and> L = rename_literal I LL}\n  validated_part I P1 = {}\n\ngoal (1 subgoal):\n 1. selected_part UNIV\n     {L. \\<exists>LL. LL \\<in> P1 \\<and> L = rename_literal I LL} =\n    {}", "by auto"], ["proof (state)\nthis:\n  selected_part UNIV (rename_clause I P1) = {}\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  selected_part UNIV (rename_clause I P1) = {}", "have \"negative_part (rename_clause I P1) = {}\""], ["proof (prove)\nusing this:\n  selected_part UNIV (rename_clause I P1) = {}\n\ngoal (1 subgoal):\n 1. negative_part (rename_clause I P1) = {}", "unfolding selected_part_def negative_part_def"], ["proof (prove)\nusing this:\n  {L \\<in> rename_clause I P1. \\<exists>A\\<in>UNIV. L = Neg A} = {}\n\ngoal (1 subgoal):\n 1. {L. (\\<exists>A. L = Neg A) \\<and> L \\<in> rename_clause I P1} = {}", "by auto"], ["proof (state)\nthis:\n  negative_part (rename_clause I P1) = {}\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from \\<open>all_fulfill Horn (rename_formula I S)\\<close> and \\<open>P1 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill Horn (rename_formula I S)\n  P1 \\<in> S", "have \"Horn (rename_clause I P1)\""], ["proof (prove)\nusing this:\n  all_fulfill Horn (rename_formula I S)\n  P1 \\<in> S\n\ngoal (1 subgoal):\n 1. Horn (rename_clause I P1)", "unfolding all_fulfill_def and rename_formula_def"], ["proof (prove)\nusing this:\n  \\<forall>C.\n     C \\<in> {C. \\<exists>CC.\n                    CC \\<in> S \\<and>\n                    C = rename_clause I CC} \\<longrightarrow>\n     Horn C\n  P1 \\<in> S\n\ngoal (1 subgoal):\n 1. Horn (rename_clause I P1)", "by auto"], ["proof (state)\nthis:\n  Horn (rename_clause I P1)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Horn (rename_clause I P1)", "have \"card (positive_part (rename_clause I P1)) \\<le> 1\""], ["proof (prove)\nusing this:\n  Horn (rename_clause I P1)\n\ngoal (1 subgoal):\n 1. card (positive_part (rename_clause I P1)) \\<le> 1", "unfolding Horn_def"], ["proof (prove)\nusing this:\n  card (positive_part (rename_clause I P1)) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (positive_part (rename_clause I P1)) \\<le> 1", "by auto"], ["proof (state)\nthis:\n  card (positive_part (rename_clause I P1)) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from  \\<open>negative_part (rename_clause I P1) = {}\\<close>"], ["proof (chain)\npicking this:\n  negative_part (rename_clause I P1) = {}", "have \"rename_clause I P1 = (positive_part (rename_clause I P1))\""], ["proof (prove)\nusing this:\n  negative_part (rename_clause I P1) = {}\n\ngoal (1 subgoal):\n 1. rename_clause I P1 = positive_part (rename_clause I P1)", "using decomposition_clause_pos_neg"], ["proof (prove)\nusing this:\n  negative_part (rename_clause I P1) = {}\n  ?C = negative_part ?C \\<union> positive_part ?C\n\ngoal (1 subgoal):\n 1. rename_clause I P1 = positive_part (rename_clause I P1)", "by auto"], ["proof (state)\nthis:\n  rename_clause I P1 = positive_part (rename_clause I P1)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from this and \\<open>card (positive_part (rename_clause I P1)) \\<le> 1\\<close>"], ["proof (chain)\npicking this:\n  rename_clause I P1 = positive_part (rename_clause I P1)\n  card (positive_part (rename_clause I P1)) \\<le> 1", "have \"card (rename_clause I P1) \\<le> 1\""], ["proof (prove)\nusing this:\n  rename_clause I P1 = positive_part (rename_clause I P1)\n  card (positive_part (rename_clause I P1)) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (rename_clause I P1) \\<le> 1", "by auto"], ["proof (state)\nthis:\n  card (rename_clause I P1) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from \\<open>strictly_maximal_literal P1 L\\<close>"], ["proof (chain)\npicking this:\n  strictly_maximal_literal P1 L", "have \"P1 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  strictly_maximal_literal P1 L\n\ngoal (1 subgoal):\n 1. P1 \\<noteq> {}", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> P1 \\<and>\n  (\\<forall>B.\n      B \\<in> P1 \\<and> L \\<noteq> B \\<longrightarrow> literal_ordering B L)\n\ngoal (1 subgoal):\n 1. P1 \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  P1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  P1 \\<noteq> {}", "have \"rename_clause I P1 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  P1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rename_clause I P1 \\<noteq> {}", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  P1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {L. \\<exists>LL. LL \\<in> P1 \\<and> L = rename_literal I LL} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  rename_clause I P1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from \\<open>all_fulfill finite S\\<close> and \\<open>P1 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S\n  P1 \\<in> S", "have \"finite P1\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  P1 \\<in> S\n\ngoal (1 subgoal):\n 1. finite P1", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n  P1 \\<in> S\n\ngoal (1 subgoal):\n 1. finite P1", "by auto"], ["proof (state)\nthis:\n  finite P1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  finite P1", "have \"finite (rename_clause I P1)\""], ["proof (prove)\nusing this:\n  finite P1\n\ngoal (1 subgoal):\n 1. finite (rename_clause I P1)", "unfolding rename_clause_def"], ["proof (prove)\nusing this:\n  finite P1\n\ngoal (1 subgoal):\n 1. finite {L. \\<exists>LL. LL \\<in> P1 \\<and> L = rename_literal I LL}", "by auto"], ["proof (state)\nthis:\n  finite (rename_clause I P1)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from this and \\<open>rename_clause I P1 \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  finite (rename_clause I P1)\n  rename_clause I P1 \\<noteq> {}", "have \"card(rename_clause I P1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite (rename_clause I P1)\n  rename_clause I P1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (rename_clause I P1) \\<noteq> 0", "using card_0_eq"], ["proof (prove)\nusing this:\n  finite (rename_clause I P1)\n  rename_clause I P1 \\<noteq> {}\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. card (rename_clause I P1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (rename_clause I P1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from this and \\<open>card (rename_clause I P1) \\<le> 1\\<close>"], ["proof (chain)\npicking this:\n  card (rename_clause I P1) \\<noteq> 0\n  card (rename_clause I P1) \\<le> 1", "have \"card (rename_clause I P1) = 1\""], ["proof (prove)\nusing this:\n  card (rename_clause I P1) \\<noteq> 0\n  card (rename_clause I P1) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (rename_clause I P1) = 1", "by auto"], ["proof (state)\nthis:\n  card (rename_clause I P1) = 1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  card (rename_clause I P1) = 1", "have \"card P1 = 1\""], ["proof (prove)\nusing this:\n  card (rename_clause I P1) = 1\n\ngoal (1 subgoal):\n 1. card P1 = 1", "using renaming_preserves_cardinality"], ["proof (prove)\nusing this:\n  card (rename_clause I P1) = 1\n  card (rename_clause ?A ?C) = card ?C\n\ngoal (1 subgoal):\n 1. card P1 = 1", "by auto"], ["proof (state)\nthis:\n  card P1 = 1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  card P1 = 1", "have \"Unit P1\""], ["proof (prove)\nusing this:\n  card P1 = 1\n\ngoal (1 subgoal):\n 1. Unit P1", "unfolding Unit_def"], ["proof (prove)\nusing this:\n  card P1 = 1\n\ngoal (1 subgoal):\n 1. card P1 = 1", "using card_image"], ["proof (prove)\nusing this:\n  card P1 = 1\n  inj_on ?f ?A \\<Longrightarrow> card (?f ` ?A) = card ?A\n\ngoal (1 subgoal):\n 1. card P1 = 1", "by auto"], ["proof (state)\nthis:\n  Unit P1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from this and \\<open>L \\<in> P1\\<close> and \\<open>complement L \\<in> P2\\<close> and def_c"], ["proof (chain)\npicking this:\n  Unit P1\n  L \\<in> P1\n  complement L \\<in> P2\n  C = P1 - {L} \\<union> (P2 - {complement L})", "have \"unit_resolvent P1 P2 C\""], ["proof (prove)\nusing this:\n  Unit P1\n  L \\<in> P1\n  complement L \\<in> P2\n  C = P1 - {L} \\<union> (P2 - {complement L})\n\ngoal (1 subgoal):\n 1. unit_resolvent P1 P2 C", "unfolding unit_resolvent_def"], ["proof (prove)\nusing this:\n  Unit P1\n  L \\<in> P1\n  complement L \\<in> P2\n  C = P1 - {L} \\<union> (P2 - {complement L})\n\ngoal (1 subgoal):\n 1. (\\<exists>L.\n        C = P1 - {L} \\<union> (P2 - {complement L}) \\<and>\n        L \\<in> P1 \\<and> complement L \\<in> P2) \\<and>\n    Unit P1", "by auto"], ["proof (state)\nthis:\n  unit_resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule (ordered_model_resolvent I)\n            S \\<Longrightarrow>\n    False", "from this and \\<open>\\<not>(redundant C S)\\<close> and \\<open>P1 \\<in> S\\<close> and \\<open>P2 \\<in> S\\<close> \n      and \\<open>saturated_binary_rule unit_resolvent S\\<close>"], ["proof (chain)\npicking this:\n  unit_resolvent P1 P2 C\n  \\<not> redundant C S\n  P1 \\<in> S\n  P2 \\<in> S\n  saturated_binary_rule unit_resolvent S", "show \"False\""], ["proof (prove)\nusing this:\n  unit_resolvent P1 P2 C\n  \\<not> redundant C S\n  P1 \\<in> S\n  P2 \\<in> S\n  saturated_binary_rule unit_resolvent S\n\ngoal (1 subgoal):\n 1. False", "unfolding saturated_binary_rule_def"], ["proof (prove)\nusing this:\n  unit_resolvent P1 P2 C\n  \\<not> redundant C S\n  P1 \\<in> S\n  P2 \\<in> S\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and> unit_resolvent P1 P2 C \\<longrightarrow>\n     redundant C S\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  saturated_binary_rule (ordered_model_resolvent I) S\n\ngoal (1 subgoal):\n 1. satisfiable S", "from this and \\<open>all_fulfill finite S\\<close> and \\<open>{} \\<notin> S\\<close>"], ["proof (chain)\npicking this:\n  saturated_binary_rule (ordered_model_resolvent I) S\n  all_fulfill finite S\n  {} \\<notin> S", "show ?thesis"], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_model_resolvent I) S\n  all_fulfill finite S\n  {} \\<notin> S\n\ngoal (1 subgoal):\n 1. satisfiable S", "using ordered_resolution_is_complete_model_resolution"], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_model_resolvent I) S\n  all_fulfill finite S\n  {} \\<notin> S\n  Complete (ordered_model_resolvent ?Sel)\n\ngoal (1 subgoal):\n 1. satisfiable S", "unfolding Complete_def"], ["proof (prove)\nusing this:\n  saturated_binary_rule (ordered_model_resolvent I) S\n  all_fulfill finite S\n  {} \\<notin> S\n  \\<forall>S.\n     saturated_binary_rule (ordered_model_resolvent ?Sel)\n      S \\<longrightarrow>\n     all_fulfill finite S \\<longrightarrow>\n     {} \\<notin> S \\<longrightarrow> satisfiable S\n\ngoal (1 subgoal):\n 1. satisfiable S", "by auto"], ["proof (state)\nthis:\n  satisfiable S\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Computation of Saturated Clause Sets\\<close>"], ["", "text \\<open>We now provide a concrete (rather straightforward) procedure for computing saturated clause \nsets. Starting from the initial set, we define a sequence of clause sets, where each set is obtained \nfrom the previous one by applying the resolution rule in a systematic way, followed by redundancy \nelimination rules. The algorithm is generic, in the sense that it applies to any binary \ninference rule.\\<close>"], ["", "fun inferred_clause_sets :: \"'at BinaryRule \\<Rightarrow> 'at Formula \\<Rightarrow> nat \\<Rightarrow> 'at Formula\"\n where \n  \"(inferred_clause_sets R S 0) = (simplify S)\" |\n  \"(inferred_clause_sets R S (Suc N)) = \n    (simplify (add_all_deducible_clauses R (inferred_clause_sets R S N)))\""], ["", "text \\<open>The saturated set is constructed by considering the set of persistent clauses, i.e.,\nthe clauses that are generated and never deleted.\\<close>"], ["", "fun saturation :: \"'at BinaryRule \\<Rightarrow> 'at Formula \\<Rightarrow> 'at Formula\"\n where \n  \"saturation R S = { C. \\<exists>N. (\\<forall>M. (M \\<ge> N \\<longrightarrow> C \\<in> inferred_clause_sets R S M)) }\""], ["", "text \\<open>We prove that all inference rules yield finite clauses.\\<close>"], ["", "theorem ordered_resolvent_is_finite : \"derived_clauses_are_finite ordered_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derived_clauses_are_finite ordered_resolvent", "using less_restrictive_and_finite ordered_resolvent_is_resolvent resolvent_is_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0;\n   derived_clauses_are_finite ?R1.0\\<rbrakk>\n  \\<Longrightarrow> derived_clauses_are_finite ?R2.0\n  less_restrictive resolvent ordered_resolvent\n  derived_clauses_are_finite resolvent\n\ngoal (1 subgoal):\n 1. derived_clauses_are_finite ordered_resolvent", "by auto"], ["", "theorem model_resolvent_is_finite : \"derived_clauses_are_finite (ordered_model_resolvent I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derived_clauses_are_finite (ordered_model_resolvent I)", "using less_restrictive_and_finite ordered_model_resolvent_is_resolvent resolvent_is_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0;\n   derived_clauses_are_finite ?R1.0\\<rbrakk>\n  \\<Longrightarrow> derived_clauses_are_finite ?R2.0\n  less_restrictive resolvent (ordered_model_resolvent ?I)\n  derived_clauses_are_finite resolvent\n\ngoal (1 subgoal):\n 1. derived_clauses_are_finite (ordered_model_resolvent I)", "by auto"], ["", "theorem positive_resolvent_is_finite : \"derived_clauses_are_finite ordered_positive_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derived_clauses_are_finite ordered_positive_resolvent", "using less_restrictive_and_finite positive_resolvent_is_resolvent resolvent_is_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0;\n   derived_clauses_are_finite ?R1.0\\<rbrakk>\n  \\<Longrightarrow> derived_clauses_are_finite ?R2.0\n  less_restrictive resolvent ordered_positive_resolvent\n  derived_clauses_are_finite resolvent\n\ngoal (1 subgoal):\n 1. derived_clauses_are_finite ordered_positive_resolvent", "by auto"], ["", "theorem negative_resolvent_is_finite : \"derived_clauses_are_finite ordered_negative_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derived_clauses_are_finite ordered_negative_resolvent", "using less_restrictive_and_finite negative_resolvent_is_resolvent resolvent_is_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0;\n   derived_clauses_are_finite ?R1.0\\<rbrakk>\n  \\<Longrightarrow> derived_clauses_are_finite ?R2.0\n  less_restrictive resolvent ordered_negative_resolvent\n  derived_clauses_are_finite resolvent\n\ngoal (1 subgoal):\n 1. derived_clauses_are_finite ordered_negative_resolvent", "by auto"], ["", "theorem unit_resolvent_is_finite : \"derived_clauses_are_finite unit_resolvent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derived_clauses_are_finite unit_resolvent", "using less_restrictive_and_finite unit_resolvent_is_resolvent resolvent_is_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>less_restrictive ?R1.0 ?R2.0;\n   derived_clauses_are_finite ?R1.0\\<rbrakk>\n  \\<Longrightarrow> derived_clauses_are_finite ?R2.0\n  less_restrictive resolvent unit_resolvent\n  derived_clauses_are_finite resolvent\n\ngoal (1 subgoal):\n 1. derived_clauses_are_finite unit_resolvent", "by auto"], ["", "lemma all_deducible_clauses_are_finite:\n  assumes \"derived_clauses_are_finite R\"\n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (all_deducible_clauses R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill finite (all_deducible_clauses R S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> all_fulfill finite (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "assume \"\\<not>all_fulfill finite (all_deducible_clauses R S)\""], ["proof (state)\nthis:\n  \\<not> all_fulfill finite (all_deducible_clauses R S)\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill finite (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> all_fulfill finite (all_deducible_clauses R S)", "obtain C where \"C \\<in> all_deducible_clauses R S\" and \"\\<not>finite C\""], ["proof (prove)\nusing this:\n  \\<not> all_fulfill finite (all_deducible_clauses R S)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> all_deducible_clauses R S; infinite C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C.\n             C \\<in> all_deducible_clauses R S \\<longrightarrow> finite C)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> all_deducible_clauses R S; infinite C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> all_deducible_clauses R S\n  infinite C\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill finite (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> all_deducible_clauses R S\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> all_deducible_clauses R S", "have \"\\<exists> P1 P2. R P1 P2 C \\<and> P1 \\<in> S \\<and> P2 \\<in> S\""], ["proof (prove)\nusing this:\n  C \\<in> all_deducible_clauses R S\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2. R P1 P2 C \\<and> P1 \\<in> S \\<and> P2 \\<in> S", "by auto"], ["proof (state)\nthis:\n  \\<exists>P1 P2. R P1 P2 C \\<and> P1 \\<in> S \\<and> P2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill finite (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1 P2. R P1 P2 C \\<and> P1 \\<in> S \\<and> P2 \\<in> S", "obtain P1 P2 where \"R P1 P2 C\" and \"P1 \\<in> S\" and \"P2 \\<in> S\""], ["proof (prove)\nusing this:\n  \\<exists>P1 P2. R P1 P2 C \\<and> P1 \\<in> S \\<and> P2 \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>R P1 P2 C; P1 \\<in> S; P2 \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R P1 P2 C\n  P1 \\<in> S\n  P2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill finite (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> S\\<close> and \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S\n  all_fulfill finite S", "have \"finite P1\""], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. finite P1", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. finite P1", "by auto"], ["proof (state)\nthis:\n  finite P1\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill finite (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "from \\<open>P2 \\<in> S\\<close> and \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  P2 \\<in> S\n  all_fulfill finite S", "have \"finite P2\""], ["proof (prove)\nusing this:\n  P2 \\<in> S\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. finite P2", "unfolding  all_fulfill_def"], ["proof (prove)\nusing this:\n  P2 \\<in> S\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. finite P2", "by auto"], ["proof (state)\nthis:\n  finite P2\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill finite (all_deducible_clauses R S) \\<Longrightarrow>\n    False", "from \\<open>finite P1\\<close> and \\<open>finite P2\\<close> and \\<open>derived_clauses_are_finite R\\<close> and \\<open>R P1 P2 C\\<close> and \\<open>\\<not>finite C\\<close>"], ["proof (chain)\npicking this:\n  finite P1\n  finite P2\n  derived_clauses_are_finite R\n  R P1 P2 C\n  infinite C", "show \"False\""], ["proof (prove)\nusing this:\n  finite P1\n  finite P2\n  derived_clauses_are_finite R\n  R P1 P2 C\n  infinite C\n\ngoal (1 subgoal):\n 1. False", "unfolding derived_clauses_are_finite_def"], ["proof (prove)\nusing this:\n  finite P1\n  finite P2\n  \\<forall>P1 P2 C.\n     finite P1 \\<longrightarrow>\n     finite P2 \\<longrightarrow> R P1 P2 C \\<longrightarrow> finite C\n  R P1 P2 C\n  infinite C\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This entails that all the clauses occurring in the sets in the sequence are finite.\\<close>"], ["", "lemma all_inferred_clause_sets_are_finite: \n  assumes \"derived_clauses_are_finite R\" \n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (inferred_clause_sets R S N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill finite (inferred_clause_sets R S N)", "proof (induction N)"], ["proof (state)\ngoal (2 subgoals):\n 1. all_fulfill finite (inferred_clause_sets R S 0)\n 2. \\<And>N.\n       all_fulfill finite (inferred_clause_sets R S N) \\<Longrightarrow>\n       all_fulfill finite (inferred_clause_sets R S (Suc N))", "from assms"], ["proof (chain)\npicking this:\n  derived_clauses_are_finite R\n  all_fulfill finite S", "show \"all_fulfill finite (inferred_clause_sets R S 0)\""], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. all_fulfill finite (inferred_clause_sets R S 0)", "using simplify_finite"], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  all_fulfill finite ?S \\<Longrightarrow> all_fulfill finite (simplify ?S)\n\ngoal (1 subgoal):\n 1. all_fulfill finite (inferred_clause_sets R S 0)", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite (inferred_clause_sets R S 0)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       all_fulfill finite (inferred_clause_sets R S N) \\<Longrightarrow>\n       all_fulfill finite (inferred_clause_sets R S (Suc N))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>N.\n       all_fulfill finite (inferred_clause_sets R S N) \\<Longrightarrow>\n       all_fulfill finite (inferred_clause_sets R S (Suc N))", "fix N"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>N.\n       all_fulfill finite (inferred_clause_sets R S N) \\<Longrightarrow>\n       all_fulfill finite (inferred_clause_sets R S (Suc N))", "assume \"all_fulfill finite (inferred_clause_sets R S N)\""], ["proof (state)\nthis:\n  all_fulfill finite (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       all_fulfill finite (inferred_clause_sets R S N) \\<Longrightarrow>\n       all_fulfill finite (inferred_clause_sets R S (Suc N))", "then"], ["proof (chain)\npicking this:\n  all_fulfill finite (inferred_clause_sets R S N)", "have \"all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))\""], ["proof (prove)\nusing this:\n  all_fulfill finite (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (all_deducible_clauses R (inferred_clause_sets R S N))", "using assms(1) all_deducible_clauses_are_finite [of R \"inferred_clause_sets R S N\"]"], ["proof (prove)\nusing this:\n  all_fulfill finite (inferred_clause_sets R S N)\n  derived_clauses_are_finite R\n  \\<lbrakk>derived_clauses_are_finite R;\n   all_fulfill finite (inferred_clause_sets R S N)\\<rbrakk>\n  \\<Longrightarrow> all_fulfill finite\n                     (all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (all_deducible_clauses R (inferred_clause_sets R S N))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       all_fulfill finite (inferred_clause_sets R S N) \\<Longrightarrow>\n       all_fulfill finite (inferred_clause_sets R S (Suc N))", "from this and \\<open>all_fulfill finite (inferred_clause_sets R S N)\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))\n  all_fulfill finite (inferred_clause_sets R S N)", "have \"all_fulfill finite (add_all_deducible_clauses R (inferred_clause_sets R S N))\""], ["proof (prove)\nusing this:\n  all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))\n  all_fulfill finite (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "using all_fulfill_def"], ["proof (prove)\nusing this:\n  all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))\n  all_fulfill finite (inferred_clause_sets R S N)\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       all_fulfill finite (inferred_clause_sets R S N) \\<Longrightarrow>\n       all_fulfill finite (inferred_clause_sets R S (Suc N))", "then"], ["proof (chain)\npicking this:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))", "show \"all_fulfill finite (inferred_clause_sets R S (Suc N))\""], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. all_fulfill finite (inferred_clause_sets R S (Suc N))", "using simplify_finite"], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n  all_fulfill finite ?S \\<Longrightarrow> all_fulfill finite (simplify ?S)\n\ngoal (1 subgoal):\n 1. all_fulfill finite (inferred_clause_sets R S (Suc N))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite (inferred_clause_sets R S (Suc N))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_all_deducible_clauses_finite: \n  assumes \"derived_clauses_are_finite R\" \n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (add_all_deducible_clauses R (inferred_clause_sets R S N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "from assms"], ["proof (chain)\npicking this:\n  derived_clauses_are_finite R\n  all_fulfill finite S", "have \"all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))\""], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (all_deducible_clauses R (inferred_clause_sets R S N))", "using all_deducible_clauses_are_finite [of R \"inferred_clause_sets R S N\"] \n    all_inferred_clause_sets_are_finite [of R S N]"], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  \\<lbrakk>derived_clauses_are_finite R;\n   all_fulfill finite (inferred_clause_sets R S N)\\<rbrakk>\n  \\<Longrightarrow> all_fulfill finite\n                     (all_deducible_clauses R (inferred_clause_sets R S N))\n  \\<lbrakk>derived_clauses_are_finite R; all_fulfill finite S\\<rbrakk>\n  \\<Longrightarrow> all_fulfill finite (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (all_deducible_clauses R (inferred_clause_sets R S N))", "by metis"], ["proof (state)\nthis:\n  all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "then"], ["proof (chain)\npicking this:\n  all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))", "show \"all_fulfill finite (add_all_deducible_clauses R (inferred_clause_sets R S N))\""], ["proof (prove)\nusing this:\n  all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "using assms all_fulfill_def all_inferred_clause_sets_are_finite [of R S \"N\"]"], ["proof (prove)\nusing this:\n  all_fulfill finite (all_deducible_clauses R (inferred_clause_sets R S N))\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n  \\<lbrakk>derived_clauses_are_finite R; all_fulfill finite S\\<rbrakk>\n  \\<Longrightarrow> all_fulfill finite (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We show that the set of redundant clauses can only increase.\\<close>"], ["", "lemma sequence_of_inferred_clause_sets_is_monotonous: \n assumes \"derived_clauses_are_finite R\"\n assumes \"all_fulfill finite S\"\n shows \"\\<forall>C. redundant C (inferred_clause_sets R S N) \n  \\<longrightarrow> redundant C (inferred_clause_sets R S (N+M::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n       redundant C (inferred_clause_sets R S (N + M))", "proof ((induction M), auto simp del: inferred_clause_sets.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "fix M C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "assume ind_hyp: \"\\<forall>C. redundant C (inferred_clause_sets R S N) \n    \\<longrightarrow> redundant C (inferred_clause_sets R S (N+M::nat))\""], ["proof (state)\nthis:\n  \\<forall>C.\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (inferred_clause_sets R S (N + M))\n\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "assume \"redundant C (inferred_clause_sets R S N)\""], ["proof (state)\nthis:\n  redundant C (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "from this and ind_hyp"], ["proof (chain)\npicking this:\n  redundant C (inferred_clause_sets R S N)\n  \\<forall>C.\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (inferred_clause_sets R S (N + M))", "have \"redundant C (inferred_clause_sets R S (N+M))\""], ["proof (prove)\nusing this:\n  redundant C (inferred_clause_sets R S N)\n  \\<forall>C.\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (inferred_clause_sets R S (N + M))\n\ngoal (1 subgoal):\n 1. redundant C (inferred_clause_sets R S (N + M))", "by auto"], ["proof (state)\nthis:\n  redundant C (inferred_clause_sets R S (N + M))\n\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "then"], ["proof (chain)\npicking this:\n  redundant C (inferred_clause_sets R S (N + M))", "have \"redundant C (add_all_deducible_clauses R (inferred_clause_sets R S (N+M)))\""], ["proof (prove)\nusing this:\n  redundant C (inferred_clause_sets R S (N + M))\n\ngoal (1 subgoal):\n 1. redundant C\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "using deducible_clause_preserve_redundancy"], ["proof (prove)\nusing this:\n  redundant C (inferred_clause_sets R S (N + M))\n  redundant ?C ?S \\<Longrightarrow>\n  redundant ?C (add_all_deducible_clauses ?R ?S)\n\ngoal (1 subgoal):\n 1. redundant C\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "by auto"], ["proof (state)\nthis:\n  redundant C\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "then"], ["proof (chain)\npicking this:\n  redundant C\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "have \"all_fulfill finite (add_all_deducible_clauses R (inferred_clause_sets R S (N+M)))\""], ["proof (prove)\nusing this:\n  redundant C\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "using assms  add_all_deducible_clauses_finite [of R S \"N+M\"]"], ["proof (prove)\nusing this:\n  redundant C\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  \\<lbrakk>derived_clauses_are_finite R; all_fulfill finite S\\<rbrakk>\n  \\<Longrightarrow> all_fulfill finite\n                     (add_all_deducible_clauses R\n                       (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "from  \\<open>redundant C (inferred_clause_sets R S N)\\<close> and ind_hyp"], ["proof (chain)\npicking this:\n  redundant C (inferred_clause_sets R S N)\n  \\<forall>C.\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (inferred_clause_sets R S (N + M))", "have \"redundant C (inferred_clause_sets R S (N+M))\""], ["proof (prove)\nusing this:\n  redundant C (inferred_clause_sets R S N)\n  \\<forall>C.\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (inferred_clause_sets R S (N + M))\n\ngoal (1 subgoal):\n 1. redundant C (inferred_clause_sets R S (N + M))", "by auto"], ["proof (state)\nthis:\n  redundant C (inferred_clause_sets R S (N + M))\n\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "from  \\<open>redundant C (inferred_clause_sets R S (N+M))\\<close>"], ["proof (chain)\npicking this:\n  redundant C (inferred_clause_sets R S (N + M))", "have \"redundant C (add_all_deducible_clauses R (inferred_clause_sets R S (N+M)))\""], ["proof (prove)\nusing this:\n  redundant C (inferred_clause_sets R S (N + M))\n\ngoal (1 subgoal):\n 1. redundant C\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "using deducible_clause_preserve_redundancy"], ["proof (prove)\nusing this:\n  redundant C (inferred_clause_sets R S (N + M))\n  redundant ?C ?S \\<Longrightarrow>\n  redundant ?C (add_all_deducible_clauses ?R ?S)\n\ngoal (1 subgoal):\n 1. redundant C\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "by blast"], ["proof (state)\nthis:\n  redundant C\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "from this and \\<open>all_fulfill finite (add_all_deducible_clauses R (inferred_clause_sets R S (N+M)))\\<close>"], ["proof (chain)\npicking this:\n  redundant C\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "have \"redundant C (simplify (add_all_deducible_clauses R (inferred_clause_sets R S (N+M))))\""], ["proof (prove)\nusing this:\n  redundant C\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. redundant C\n     (simplify\n       (add_all_deducible_clauses R (inferred_clause_sets R S (N + M))))", "using simplify_preserves_redundancy"], ["proof (prove)\nusing this:\n  redundant C\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  \\<lbrakk>all_fulfill finite ?S; redundant ?C ?S\\<rbrakk>\n  \\<Longrightarrow> redundant ?C (simplify ?S)\n\ngoal (1 subgoal):\n 1. redundant C\n     (simplify\n       (add_all_deducible_clauses R (inferred_clause_sets R S (N + M))))", "by auto"], ["proof (state)\nthis:\n  redundant C\n   (simplify\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M))))\n\ngoal (1 subgoal):\n 1. \\<And>M C.\n       \\<lbrakk>\\<forall>C.\n                   redundant C\n                    (inferred_clause_sets R S N) \\<longrightarrow>\n                   redundant C (inferred_clause_sets R S (N + M));\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C\n                          (inferred_clause_sets R S (Suc (N + M)))", "thus \"redundant C (inferred_clause_sets R S (Suc (N + M)))\""], ["proof (prove)\nusing this:\n  redundant C\n   (simplify\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M))))\n\ngoal (1 subgoal):\n 1. redundant C (inferred_clause_sets R S (Suc (N + M)))", "by auto"], ["proof (state)\nthis:\n  redundant C (inferred_clause_sets R S (Suc (N + M)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We show that non-persistent clauses are strictly redundant in some element of the \nsequence.\\<close>"], ["", "lemma non_persistent_clauses_are_redundant:\n  assumes \"D \\<in> inferred_clause_sets R S N\"\n  assumes \"D \\<notin> saturation R S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"derived_clauses_are_finite R\"\n  shows \"\\<exists>M. strictly_redundant D (inferred_clause_sets R S M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. strictly_redundant D (inferred_clause_sets R S M)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "assume hyp: \"\\<not>(\\<exists>M. strictly_redundant D (inferred_clause_sets R S M))\""], ["proof (state)\nthis:\n  \\<nexists>M. strictly_redundant D (inferred_clause_sets R S M)\n\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<nexists>M. strictly_redundant D (inferred_clause_sets R S M)\n\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "fix M"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "have \"D \\<in> (inferred_clause_sets R S (N+M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> inferred_clause_sets R S (N + M)", "proof (induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. D \\<in> inferred_clause_sets R S (N + 0)\n 2. \\<And>M.\n       D \\<in> inferred_clause_sets R S (N + M) \\<Longrightarrow>\n       D \\<in> inferred_clause_sets R S (N + Suc M)", "show \"D \\<in> inferred_clause_sets R S (N+0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> inferred_clause_sets R S (N + 0)", "using assms(1)"], ["proof (prove)\nusing this:\n  D \\<in> inferred_clause_sets R S N\n\ngoal (1 subgoal):\n 1. D \\<in> inferred_clause_sets R S (N + 0)", "by auto"], ["proof (state)\nthis:\n  D \\<in> inferred_clause_sets R S (N + 0)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       D \\<in> inferred_clause_sets R S (N + M) \\<Longrightarrow>\n       D \\<in> inferred_clause_sets R S (N + Suc M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       D \\<in> inferred_clause_sets R S (N + M) \\<Longrightarrow>\n       D \\<in> inferred_clause_sets R S (N + Suc M)", "fix M"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       D \\<in> inferred_clause_sets R S (N + M) \\<Longrightarrow>\n       D \\<in> inferred_clause_sets R S (N + Suc M)", "assume \"D \\<in> inferred_clause_sets R S (N+M)\""], ["proof (state)\nthis:\n  D \\<in> inferred_clause_sets R S (N + M)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       D \\<in> inferred_clause_sets R S (N + M) \\<Longrightarrow>\n       D \\<in> inferred_clause_sets R S (N + Suc M)", "from this"], ["proof (chain)\npicking this:\n  D \\<in> inferred_clause_sets R S (N + M)", "have \"D \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (N+M))\""], ["proof (prove)\nusing this:\n  D \\<in> inferred_clause_sets R S (N + M)\n\ngoal (1 subgoal):\n 1. D \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (N + M))", "by auto"], ["proof (state)\nthis:\n  D \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (N + M))\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       D \\<in> inferred_clause_sets R S (N + M) \\<Longrightarrow>\n       D \\<in> inferred_clause_sets R S (N + Suc M)", "show \"D \\<in> (inferred_clause_sets R S (N+(Suc M)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> inferred_clause_sets R S (N + Suc M)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. D \\<notin> inferred_clause_sets R S (N + Suc M) \\<Longrightarrow> False", "assume \"D \\<notin> (inferred_clause_sets R S (N+(Suc M)))\""], ["proof (state)\nthis:\n  D \\<notin> inferred_clause_sets R S (N + Suc M)\n\ngoal (1 subgoal):\n 1. D \\<notin> inferred_clause_sets R S (N + Suc M) \\<Longrightarrow> False", "from this and \\<open>D \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (N+M))\\<close>"], ["proof (chain)\npicking this:\n  D \\<notin> inferred_clause_sets R S (N + Suc M)\n  D \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (N + M))", "have \"strictly_redundant D (add_all_deducible_clauses R (inferred_clause_sets R S (N+M)))\""], ["proof (prove)\nusing this:\n  D \\<notin> inferred_clause_sets R S (N + Suc M)\n  D \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (N + M))\n\ngoal (1 subgoal):\n 1. strictly_redundant D\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "using simplify_def"], ["proof (prove)\nusing this:\n  D \\<notin> inferred_clause_sets R S (N + Suc M)\n  D \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (N + M))\n  simplify ?S = {C \\<in> ?S. \\<not> strictly_redundant C ?S}\n\ngoal (1 subgoal):\n 1. strictly_redundant D\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "by auto"], ["proof (state)\nthis:\n  strictly_redundant D\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. D \\<notin> inferred_clause_sets R S (N + Suc M) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  strictly_redundant D\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "have \"all_fulfill finite (add_all_deducible_clauses R (inferred_clause_sets R S (N+M)))\""], ["proof (prove)\nusing this:\n  strictly_redundant D\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "using assms(4) assms(3)  add_all_deducible_clauses_finite [of R S \"N+M\"]"], ["proof (prove)\nusing this:\n  strictly_redundant D\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  \\<lbrakk>derived_clauses_are_finite R; all_fulfill finite S\\<rbrakk>\n  \\<Longrightarrow> all_fulfill finite\n                     (add_all_deducible_clauses R\n                       (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. D \\<notin> inferred_clause_sets R S (N + Suc M) \\<Longrightarrow> False", "from this \n          and \\<open>strictly_redundant D (add_all_deducible_clauses R (inferred_clause_sets R S (N+M)))\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  strictly_redundant D\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))", "have \"strictly_redundant D (inferred_clause_sets R S (N+(Suc M)))\""], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  strictly_redundant D\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n\ngoal (1 subgoal):\n 1. strictly_redundant D (inferred_clause_sets R S (N + Suc M))", "using simplify_preserves_strict_redundancy"], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  strictly_redundant D\n   (add_all_deducible_clauses R (inferred_clause_sets R S (N + M)))\n  \\<lbrakk>all_fulfill finite ?S; strictly_redundant ?C ?S\\<rbrakk>\n  \\<Longrightarrow> strictly_redundant ?C (simplify ?S)\n\ngoal (1 subgoal):\n 1. strictly_redundant D (inferred_clause_sets R S (N + Suc M))", "by auto"], ["proof (state)\nthis:\n  strictly_redundant D (inferred_clause_sets R S (N + Suc M))\n\ngoal (1 subgoal):\n 1. D \\<notin> inferred_clause_sets R S (N + Suc M) \\<Longrightarrow> False", "from this and hyp"], ["proof (chain)\npicking this:\n  strictly_redundant D (inferred_clause_sets R S (N + Suc M))\n  \\<nexists>M. strictly_redundant D (inferred_clause_sets R S M)", "show \"False\""], ["proof (prove)\nusing this:\n  strictly_redundant D (inferred_clause_sets R S (N + Suc M))\n  \\<nexists>M. strictly_redundant D (inferred_clause_sets R S M)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D \\<in> inferred_clause_sets R S (N + Suc M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D \\<in> inferred_clause_sets R S (N + M)\n\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  D \\<in> inferred_clause_sets R S (N + ?M2)\n\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "from assms(2) and assms(1)"], ["proof (chain)\npicking this:\n  D \\<notin> saturation R S\n  D \\<in> inferred_clause_sets R S N", "have \"\\<not>(\\<forall>M'. (M' \\<ge> N \\<longrightarrow> D \\<in> inferred_clause_sets R S M'))\""], ["proof (prove)\nusing this:\n  D \\<notin> saturation R S\n  D \\<in> inferred_clause_sets R S N\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>M'\\<ge>N. D \\<in> inferred_clause_sets R S M')", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<forall>M'\\<ge>N. D \\<in> inferred_clause_sets R S M')\n\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>M'\\<ge>N. D \\<in> inferred_clause_sets R S M')", "obtain M' where \"M' \\<ge> N\" and \"D \\<notin> inferred_clause_sets R S M'\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>M'\\<ge>N. D \\<in> inferred_clause_sets R S M')\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>N \\<le> M'; D \\<notin> inferred_clause_sets R S M'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<le> M'\n  D \\<notin> inferred_clause_sets R S M'\n\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "from \\<open>M' \\<ge> N\\<close>"], ["proof (chain)\npicking this:\n  N \\<le> M'", "obtain N':: nat where \"N' = M' - N\""], ["proof (prove)\nusing this:\n  N \\<le> M'\n\ngoal (1 subgoal):\n 1. (\\<And>N'. N' = M' - N \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N' = M' - N\n\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "have \"D \\<in> inferred_clause_sets R S (N+(M'-N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> inferred_clause_sets R S (N + (M' - N))", "by (simp add: \\<open>\\<And>M. D \\<in> inferred_clause_sets R S (N + M)\\<close>)"], ["proof (state)\nthis:\n  D \\<in> inferred_clause_sets R S (N + (M' - N))\n\ngoal (1 subgoal):\n 1. \\<nexists>M.\n       strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n    False", "from this and \\<open>D \\<notin> inferred_clause_sets R S M'\\<close>"], ["proof (chain)\npicking this:\n  D \\<in> inferred_clause_sets R S (N + (M' - N))\n  D \\<notin> inferred_clause_sets R S M'", "show \"False\""], ["proof (prove)\nusing this:\n  D \\<in> inferred_clause_sets R S (N + (M' - N))\n  D \\<notin> inferred_clause_sets R S M'\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>N \\<le> M'\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This entails that the clauses that are redundant in some set in the sequence are also \nredundant in the set of persistent clauses.\\<close>"], ["", "lemma persistent_clauses_subsume_redundant_clauses:\n  assumes \"redundant C (inferred_clause_sets R S N)\"\n  assumes \"all_fulfill finite S\"\n  assumes \"derived_clauses_are_finite R\"\n  assumes \"finite C\"\n  shows \"redundant C (saturation R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "let ?nat_order = \"{ (x::nat,y::nat). x < y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "fix I"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "have \"\\<forall>C N. finite C \\<longrightarrow> card C = I \n         \\<longrightarrow> (redundant C (inferred_clause_sets R S N)) \\<longrightarrow> redundant C (saturation R S)\" (is \"?P I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C N.\n       finite C \\<longrightarrow>\n       card C = I \\<longrightarrow>\n       redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n       redundant C (saturation R S)", "proof ((rule wf_induct [of ?nat_order ?P I]),(simp add:wf))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> {(x, y). x < y} \\<longrightarrow>\n          (\\<forall>C N.\n              finite C \\<longrightarrow>\n              card C = y \\<longrightarrow>\n              redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n              redundant C (saturation R S)) \\<Longrightarrow>\n       \\<forall>C N.\n          finite C \\<longrightarrow>\n          card C = x \\<longrightarrow>\n          redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n          redundant C (saturation R S)", "fix I"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> {(x, y). x < y} \\<longrightarrow>\n          (\\<forall>C N.\n              finite C \\<longrightarrow>\n              card C = y \\<longrightarrow>\n              redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n              redundant C (saturation R S)) \\<Longrightarrow>\n       \\<forall>C N.\n          finite C \\<longrightarrow>\n          card C = x \\<longrightarrow>\n          redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n          redundant C (saturation R S)", "assume hyp_induct: \"\\<forall>J. (J,I) \\<in> ?nat_order \\<longrightarrow> (?P J)\""], ["proof (state)\nthis:\n  \\<forall>J.\n     (J, I) \\<in> {(x, y). x < y} \\<longrightarrow>\n     (\\<forall>C N.\n         finite C \\<longrightarrow>\n         card C = J \\<longrightarrow>\n         redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n         redundant C (saturation R S))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> {(x, y). x < y} \\<longrightarrow>\n          (\\<forall>C N.\n              finite C \\<longrightarrow>\n              card C = y \\<longrightarrow>\n              redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n              redundant C (saturation R S)) \\<Longrightarrow>\n       \\<forall>C N.\n          finite C \\<longrightarrow>\n          card C = x \\<longrightarrow>\n          redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n          redundant C (saturation R S)", "show \"?P I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C N.\n       finite C \\<longrightarrow>\n       card C = I \\<longrightarrow>\n       redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n       redundant C (saturation R S)", "proof ((rule allI)+,(rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C N.\n       \\<lbrakk>finite C; card C = I;\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C (saturation R S)", "fix C N"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C N.\n       \\<lbrakk>finite C; card C = I;\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C (saturation R S)", "assume \"finite C\" \"card C = I\" \"redundant C (inferred_clause_sets R S N)\""], ["proof (state)\nthis:\n  finite C\n  card C = I\n  redundant C (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. \\<And>C N.\n       \\<lbrakk>finite C; card C = I;\n        redundant C (inferred_clause_sets R S N)\\<rbrakk>\n       \\<Longrightarrow> redundant C (saturation R S)", "show \"redundant C (saturation R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> redundant C (saturation R S)\n 2. \\<not> ?P \\<Longrightarrow> redundant C (saturation R S)", "assume \"tautology C\""], ["proof (state)\nthis:\n  tautology C\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> redundant C (saturation R S)\n 2. \\<not> ?P \\<Longrightarrow> redundant C (saturation R S)", "then"], ["proof (chain)\npicking this:\n  tautology C", "show \"redundant C (saturation R S)\""], ["proof (prove)\nusing this:\n  tautology C\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  tautology C\n\ngoal (1 subgoal):\n 1. tautology C \\<or>\n    (\\<exists>D. D \\<in> saturation R S \\<and> subsumes D C)", "by auto"], ["proof (state)\nthis:\n  redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> redundant C (saturation R S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> redundant C (saturation R S)", "assume \"\\<not>tautology C\""], ["proof (state)\nthis:\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> redundant C (saturation R S)", "from this and \\<open>redundant C (inferred_clause_sets R S N)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology C\n  redundant C (inferred_clause_sets R S N)", "obtain D \n          where \"subsumes D C\" and \"D \\<in> inferred_clause_sets R S N\""], ["proof (prove)\nusing this:\n  \\<not> tautology C\n  redundant C (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>subsumes D C; D \\<in> inferred_clause_sets R S N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  \\<not> tautology C\n  tautology C \\<or>\n  (\\<exists>D. D \\<in> inferred_clause_sets R S N \\<and> subsumes D C)\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>subsumes D C; D \\<in> inferred_clause_sets R S N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subsumes D C\n  D \\<in> inferred_clause_sets R S N\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> redundant C (saturation R S)", "show \"redundant C (saturation R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> redundant C (saturation R S)\n 2. \\<not> ?P \\<Longrightarrow> redundant C (saturation R S)", "assume \"D \\<in> saturation R S\""], ["proof (state)\nthis:\n  D \\<in> saturation R S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> redundant C (saturation R S)\n 2. \\<not> ?P \\<Longrightarrow> redundant C (saturation R S)", "from this and \\<open>subsumes D C\\<close>"], ["proof (chain)\npicking this:\n  D \\<in> saturation R S\n  subsumes D C", "show \"redundant C (saturation R S)\""], ["proof (prove)\nusing this:\n  D \\<in> saturation R S\n  subsumes D C\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  D \\<in> saturation R S\n  subsumes D C\n\ngoal (1 subgoal):\n 1. tautology C \\<or>\n    (\\<exists>D. D \\<in> saturation R S \\<and> subsumes D C)", "by auto"], ["proof (state)\nthis:\n  redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "assume \"D \\<notin> saturation R S\""], ["proof (state)\nthis:\n  D \\<notin> saturation R S\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from assms(2) assms(3) and \\<open>D \\<in> inferred_clause_sets R S N\\<close> and \\<open>D \\<notin> saturation R S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S\n  derived_clauses_are_finite R\n  D \\<in> inferred_clause_sets R S N\n  D \\<notin> saturation R S", "obtain M where \"strictly_redundant D (inferred_clause_sets R S M)\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  derived_clauses_are_finite R\n  D \\<in> inferred_clause_sets R S N\n  D \\<notin> saturation R S\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \n            non_persistent_clauses_are_redundant [of D R S]"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  derived_clauses_are_finite R\n  D \\<in> inferred_clause_sets R S N\n  D \\<notin> saturation R S\n  \\<lbrakk>D \\<in> inferred_clause_sets R S ?N; D \\<notin> saturation R S;\n   all_fulfill finite S; derived_clauses_are_finite R\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       strictly_redundant D (inferred_clause_sets R S M)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        strictly_redundant D (inferred_clause_sets R S M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  strictly_redundant D (inferred_clause_sets R S M)\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from \\<open>subsumes D C\\<close> and \\<open>\\<not>tautology C\\<close>"], ["proof (chain)\npicking this:\n  subsumes D C\n  \\<not> tautology C", "have \"\\<not>tautology D\""], ["proof (prove)\nusing this:\n  subsumes D C\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> tautology D", "unfolding subsumes_def tautology_def"], ["proof (prove)\nusing this:\n  D \\<subseteq> C\n  \\<nexists>A. Pos A \\<in> C \\<and> Neg A \\<in> C\n\ngoal (1 subgoal):\n 1. \\<nexists>A. Pos A \\<in> D \\<and> Neg A \\<in> D", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology D\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from \\<open>strictly_redundant D (inferred_clause_sets R S M)\\<close> and \\<open>\\<not>tautology D\\<close>"], ["proof (chain)\npicking this:\n  strictly_redundant D (inferred_clause_sets R S M)\n  \\<not> tautology D", "obtain D' where \"D' \\<subset> D\" and \"D' \\<in> inferred_clause_sets R S M\""], ["proof (prove)\nusing this:\n  strictly_redundant D (inferred_clause_sets R S M)\n  \\<not> tautology D\n\ngoal (1 subgoal):\n 1. (\\<And>D'.\n        \\<lbrakk>D' \\<subset> D;\n         D' \\<in> inferred_clause_sets R S M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding strictly_redundant_def"], ["proof (prove)\nusing this:\n  tautology D \\<or>\n  (\\<exists>Da. Da \\<in> inferred_clause_sets R S M \\<and> Da \\<subset> D)\n  \\<not> tautology D\n\ngoal (1 subgoal):\n 1. (\\<And>D'.\n        \\<lbrakk>D' \\<subset> D;\n         D' \\<in> inferred_clause_sets R S M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D' \\<subset> D\n  D' \\<in> inferred_clause_sets R S M\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from \\<open>D' \\<subset> D\\<close> and \\<open>subsumes D C\\<close>"], ["proof (chain)\npicking this:\n  D' \\<subset> D\n  subsumes D C", "have \"D' \\<subset> C\""], ["proof (prove)\nusing this:\n  D' \\<subset> D\n  subsumes D C\n\ngoal (1 subgoal):\n 1. D' \\<subset> C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  D' \\<subset> D\n  D \\<subseteq> C\n\ngoal (1 subgoal):\n 1. D' \\<subset> C", "by auto"], ["proof (state)\nthis:\n  D' \\<subset> C\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from \\<open>D' \\<subset> C\\<close> and \\<open>finite C\\<close>"], ["proof (chain)\npicking this:\n  D' \\<subset> C\n  finite C", "have \"finite D'\""], ["proof (prove)\nusing this:\n  D' \\<subset> C\n  finite C\n\ngoal (1 subgoal):\n 1. finite D'", "by (meson psubset_imp_subset rev_finite_subset)"], ["proof (state)\nthis:\n  finite D'\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from \\<open>D' \\<subset> C\\<close> and \\<open>finite C\\<close>"], ["proof (chain)\npicking this:\n  D' \\<subset> C\n  finite C", "have \"card D' < card C\""], ["proof (prove)\nusing this:\n  D' \\<subset> C\n  finite C\n\ngoal (1 subgoal):\n 1. card D' < card C", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  D' \\<subset> C\n  finite C\n\ngoal (1 subgoal):\n 1. card D' < card C", "using psubset_card_mono"], ["proof (prove)\nusing this:\n  D' \\<subset> C\n  finite C\n  \\<lbrakk>finite ?B; ?A \\<subset> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A < card ?B\n\ngoal (1 subgoal):\n 1. card D' < card C", "by auto"], ["proof (state)\nthis:\n  card D' < card C\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from this and \\<open>card C = I\\<close>"], ["proof (chain)\npicking this:\n  card D' < card C\n  card C = I", "have \"(card D',I) \\<in> ?nat_order\""], ["proof (prove)\nusing this:\n  card D' < card C\n  card C = I\n\ngoal (1 subgoal):\n 1. (card D', I) \\<in> {(x, y). x < y}", "by auto"], ["proof (state)\nthis:\n  (card D', I) \\<in> {(x, y). x < y}\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from \\<open>D' \\<in> inferred_clause_sets R S M\\<close>"], ["proof (chain)\npicking this:\n  D' \\<in> inferred_clause_sets R S M", "have \"redundant D' (inferred_clause_sets R S M)\""], ["proof (prove)\nusing this:\n  D' \\<in> inferred_clause_sets R S M\n\ngoal (1 subgoal):\n 1. redundant D' (inferred_clause_sets R S M)", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  D' \\<in> inferred_clause_sets R S M\n\ngoal (1 subgoal):\n 1. tautology D' \\<or>\n    (\\<exists>D. D \\<in> inferred_clause_sets R S M \\<and> D \\<subseteq> D')", "by auto"], ["proof (state)\nthis:\n  redundant D' (inferred_clause_sets R S M)\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from  hyp_induct and \\<open>(card D',I) \\<in> ?nat_order\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>J.\n     (J, I) \\<in> {(x, y). x < y} \\<longrightarrow>\n     (\\<forall>C N.\n         finite C \\<longrightarrow>\n         card C = J \\<longrightarrow>\n         redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n         redundant C (saturation R S))\n  (card D', I) \\<in> {(x, y). x < y}", "have \"?P (card D')\""], ["proof (prove)\nusing this:\n  \\<forall>J.\n     (J, I) \\<in> {(x, y). x < y} \\<longrightarrow>\n     (\\<forall>C N.\n         finite C \\<longrightarrow>\n         card C = J \\<longrightarrow>\n         redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n         redundant C (saturation R S))\n  (card D', I) \\<in> {(x, y). x < y}\n\ngoal (1 subgoal):\n 1. \\<forall>C N.\n       finite C \\<longrightarrow>\n       card C = card D' \\<longrightarrow>\n       redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n       redundant C (saturation R S)", "by force"], ["proof (state)\nthis:\n  \\<forall>C N.\n     finite C \\<longrightarrow>\n     card C = card D' \\<longrightarrow>\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "from this and \\<open>finite D'\\<close> and \\<open>redundant D' (inferred_clause_sets R S M)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>C N.\n     finite C \\<longrightarrow>\n     card C = card D' \\<longrightarrow>\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (saturation R S)\n  finite D'\n  redundant D' (inferred_clause_sets R S M)", "have \n            \"redundant D' (saturation R S)\""], ["proof (prove)\nusing this:\n  \\<forall>C N.\n     finite C \\<longrightarrow>\n     card C = card D' \\<longrightarrow>\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (saturation R S)\n  finite D'\n  redundant D' (inferred_clause_sets R S M)\n\ngoal (1 subgoal):\n 1. redundant D' (saturation R S)", "by auto"], ["proof (state)\nthis:\n  redundant D' (saturation R S)\n\ngoal (1 subgoal):\n 1. D \\<notin> saturation R S \\<Longrightarrow> redundant C (saturation R S)", "show \"redundant C (saturation R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "by (meson \\<open>D' \\<subset> C\\<close> \\<open>redundant D' (saturation R S)\\<close> \n              psubset_imp_subset subsumes_def subsumption_preserves_redundancy)"], ["proof (state)\nthis:\n  redundant C (saturation R S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  redundant C (saturation R S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  redundant C (saturation R S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C N.\n     finite C \\<longrightarrow>\n     card C = I \\<longrightarrow>\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (saturation R S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C N.\n     finite C \\<longrightarrow>\n     card C = I \\<longrightarrow>\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "}"], ["proof (state)\nthis:\n  \\<forall>C N.\n     finite C \\<longrightarrow>\n     card C = ?I2 \\<longrightarrow>\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "then"], ["proof (chain)\npicking this:\n  \\<forall>C N.\n     finite C \\<longrightarrow>\n     card C = ?I2 \\<longrightarrow>\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (saturation R S)", "show \"redundant C (saturation R S)\""], ["proof (prove)\nusing this:\n  \\<forall>C N.\n     finite C \\<longrightarrow>\n     card C = ?I2 \\<longrightarrow>\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "using assms(1) assms(4)"], ["proof (prove)\nusing this:\n  \\<forall>C N.\n     finite C \\<longrightarrow>\n     card C = ?I2 \\<longrightarrow>\n     redundant C (inferred_clause_sets R S N) \\<longrightarrow>\n     redundant C (saturation R S)\n  redundant C (inferred_clause_sets R S N)\n  finite C\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "by blast"], ["proof (state)\nthis:\n  redundant C (saturation R S)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We deduce that the set of persistent clauses is saturated.\\<close>"], ["", "theorem persistent_clauses_are_saturated:\n assumes \"derived_clauses_are_finite R\"\n assumes \"all_fulfill finite S\"\n  shows \"saturated_binary_rule R (saturation R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_binary_rule R (saturation R S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "let ?S = \"saturation R S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "assume \"\\<not>saturated_binary_rule R ?S\""], ["proof (state)\nthis:\n  \\<not> saturated_binary_rule R (saturation R S)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> saturated_binary_rule R (saturation R S)", "obtain P1 P2 C where \"R P1 P2 C\" and \"P1 \\<in> ?S\" and \"P2 \\<in> ?S\" and \"\\<not>redundant C ?S\""], ["proof (prove)\nusing this:\n  \\<not> saturated_binary_rule R (saturation R S)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>R P1 P2 C; P1 \\<in> saturation R S;\n         P2 \\<in> saturation R S;\n         \\<not> redundant C (saturation R S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding saturated_binary_rule_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             P1 \\<in> saturation R S \\<and>\n             P2 \\<in> saturation R S \\<and> R P1 P2 C \\<longrightarrow>\n             redundant C (saturation R S))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>R P1 P2 C; P1 \\<in> saturation R S;\n         P2 \\<in> saturation R S;\n         \\<not> redundant C (saturation R S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R P1 P2 C\n  P1 \\<in> saturation R S\n  P2 \\<in> saturation R S\n  \\<not> redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from \\<open>P1 \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> saturation R S", "obtain N1 where i: \"\\<forall>M. (M \\<ge> N1 \\<longrightarrow> P1 \\<in> (inferred_clause_sets R S M))\""], ["proof (prove)\nusing this:\n  P1 \\<in> saturation R S\n\ngoal (1 subgoal):\n 1. (\\<And>N1.\n        \\<forall>M\\<ge>N1.\n           P1 \\<in> inferred_clause_sets R S M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>M\\<ge>N1. P1 \\<in> inferred_clause_sets R S M\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from \\<open>P2 \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  P2 \\<in> saturation R S", "obtain N2 where ii: \"\\<forall>M. (M \\<ge> N2 \\<longrightarrow> P2 \\<in> (inferred_clause_sets R S M))\""], ["proof (prove)\nusing this:\n  P2 \\<in> saturation R S\n\ngoal (1 subgoal):\n 1. (\\<And>N2.\n        \\<forall>M\\<ge>N2.\n           P2 \\<in> inferred_clause_sets R S M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>M\\<ge>N2. P2 \\<in> inferred_clause_sets R S M\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "let ?N = \"max N1 N2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "have \"?N \\<ge> N1\" and \"?N \\<ge> N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<le> max N1 N2 &&& N2 \\<le> max N1 N2", "by auto"], ["proof (state)\nthis:\n  N1 \\<le> max N1 N2\n  N2 \\<le> max N1 N2\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from this and i"], ["proof (chain)\npicking this:\n  N1 \\<le> max N1 N2\n  N2 \\<le> max N1 N2\n  \\<forall>M\\<ge>N1. P1 \\<in> inferred_clause_sets R S M", "have \"P1 \\<in> inferred_clause_sets R S ?N\""], ["proof (prove)\nusing this:\n  N1 \\<le> max N1 N2\n  N2 \\<le> max N1 N2\n  \\<forall>M\\<ge>N1. P1 \\<in> inferred_clause_sets R S M\n\ngoal (1 subgoal):\n 1. P1 \\<in> inferred_clause_sets R S (max N1 N2)", "by metis"], ["proof (state)\nthis:\n  P1 \\<in> inferred_clause_sets R S (max N1 N2)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from \\<open>?N \\<ge> N2\\<close> and ii"], ["proof (chain)\npicking this:\n  N2 \\<le> max N1 N2\n  \\<forall>M\\<ge>N2. P2 \\<in> inferred_clause_sets R S M", "have \"P2 \\<in> inferred_clause_sets R S ?N\""], ["proof (prove)\nusing this:\n  N2 \\<le> max N1 N2\n  \\<forall>M\\<ge>N2. P2 \\<in> inferred_clause_sets R S M\n\ngoal (1 subgoal):\n 1. P2 \\<in> inferred_clause_sets R S (max N1 N2)", "by metis"], ["proof (state)\nthis:\n  P2 \\<in> inferred_clause_sets R S (max N1 N2)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from \\<open>R P1 P2 C\\<close> and \\<open>P1 \\<in> inferred_clause_sets R S ?N\\<close> and \\<open>P2 \\<in> inferred_clause_sets R S ?N\\<close>"], ["proof (chain)\npicking this:\n  R P1 P2 C\n  P1 \\<in> inferred_clause_sets R S (max N1 N2)\n  P2 \\<in> inferred_clause_sets R S (max N1 N2)", "have \"C \\<in> all_deducible_clauses R ( inferred_clause_sets R S ?N)\""], ["proof (prove)\nusing this:\n  R P1 P2 C\n  P1 \\<in> inferred_clause_sets R S (max N1 N2)\n  P2 \\<in> inferred_clause_sets R S (max N1 N2)\n\ngoal (1 subgoal):\n 1. C \\<in> all_deducible_clauses R (inferred_clause_sets R S (max N1 N2))", "by auto"], ["proof (state)\nthis:\n  C \\<in> all_deducible_clauses R (inferred_clause_sets R S (max N1 N2))\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  C \\<in> all_deducible_clauses R (inferred_clause_sets R S (max N1 N2))", "have \"C \\<in> add_all_deducible_clauses R (inferred_clause_sets R S ?N)\""], ["proof (prove)\nusing this:\n  C \\<in> all_deducible_clauses R (inferred_clause_sets R S (max N1 N2))\n\ngoal (1 subgoal):\n 1. C \\<in> add_all_deducible_clauses R\n             (inferred_clause_sets R S (max N1 N2))", "by auto"], ["proof (state)\nthis:\n  C \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2))\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  derived_clauses_are_finite R\n  all_fulfill finite S", "have \"all_fulfill finite (inferred_clause_sets R S ?N)\""], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. all_fulfill finite (inferred_clause_sets R S (max N1 N2))", "using all_inferred_clause_sets_are_finite [of R S ?N]"], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  \\<lbrakk>derived_clauses_are_finite R; all_fulfill finite S\\<rbrakk>\n  \\<Longrightarrow> all_fulfill finite\n                     (inferred_clause_sets R S (max N1 N2))\n\ngoal (1 subgoal):\n 1. all_fulfill finite (inferred_clause_sets R S (max N1 N2))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite (inferred_clause_sets R S (max N1 N2))\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  derived_clauses_are_finite R\n  all_fulfill finite S", "have \"all_fulfill finite (add_all_deducible_clauses R (inferred_clause_sets R S ?N))\""], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2)))", "using add_all_deducible_clauses_finite"], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  \\<lbrakk>derived_clauses_are_finite ?R; all_fulfill finite ?S\\<rbrakk>\n  \\<Longrightarrow> all_fulfill finite\n                     (add_all_deducible_clauses ?R\n                       (inferred_clause_sets ?R ?S ?N))\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2)))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2)))\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from this and \\<open>C \\<in> add_all_deducible_clauses R (inferred_clause_sets R S ?N)\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2)))\n  C \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2))", "have \"redundant C (inferred_clause_sets R S (Suc ?N))\""], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2)))\n  C \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2))\n\ngoal (1 subgoal):\n 1. redundant C (inferred_clause_sets R S (Suc (max N1 N2)))", "using simplify_and_membership\n    [of \"add_all_deducible_clauses R (inferred_clause_sets R S ?N)\" \n      \"inferred_clause_sets R S (Suc ?N)\" C]"], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2)))\n  C \\<in> add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2))\n  \\<lbrakk>all_fulfill finite\n            (add_all_deducible_clauses R\n              (inferred_clause_sets R S (max N1 N2)));\n   inferred_clause_sets R S (Suc (max N1 N2)) =\n   simplify\n    (add_all_deducible_clauses R (inferred_clause_sets R S (max N1 N2)));\n   C \\<in> add_all_deducible_clauses R\n            (inferred_clause_sets R S (max N1 N2))\\<rbrakk>\n  \\<Longrightarrow> redundant C (inferred_clause_sets R S (Suc (max N1 N2)))\n\ngoal (1 subgoal):\n 1. redundant C (inferred_clause_sets R S (Suc (max N1 N2)))", "by auto"], ["proof (state)\nthis:\n  redundant C (inferred_clause_sets R S (Suc (max N1 N2)))\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "have \"finite P1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite P1", "using \\<open>P1 \\<in> inferred_clause_sets R S (max N1 N2)\\<close>\n      \\<open>all_fulfill finite (inferred_clause_sets R S (max N1 N2))\\<close> all_fulfill_def"], ["proof (prove)\nusing this:\n  P1 \\<in> inferred_clause_sets R S (max N1 N2)\n  all_fulfill finite (inferred_clause_sets R S (max N1 N2))\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n\ngoal (1 subgoal):\n 1. finite P1", "by auto"], ["proof (state)\nthis:\n  finite P1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "have \"finite P2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite P2", "using \\<open>P2 \\<in> inferred_clause_sets R S (max N1 N2)\\<close>\n      \\<open>all_fulfill finite (inferred_clause_sets R S (max N1 N2))\\<close> all_fulfill_def"], ["proof (prove)\nusing this:\n  P2 \\<in> inferred_clause_sets R S (max N1 N2)\n  all_fulfill finite (inferred_clause_sets R S (max N1 N2))\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n\ngoal (1 subgoal):\n 1. finite P2", "by auto"], ["proof (state)\nthis:\n  finite P2\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from \\<open>R P1 P2 C\\<close> and \\<open>finite P1\\<close> and \\<open>finite P2\\<close> and \\<open>derived_clauses_are_finite R\\<close>"], ["proof (chain)\npicking this:\n  R P1 P2 C\n  finite P1\n  finite P2\n  derived_clauses_are_finite R", "have \"finite C\""], ["proof (prove)\nusing this:\n  R P1 P2 C\n  finite P1\n  finite P2\n  derived_clauses_are_finite R\n\ngoal (1 subgoal):\n 1. finite C", "unfolding derived_clauses_are_finite_def"], ["proof (prove)\nusing this:\n  R P1 P2 C\n  finite P1\n  finite P2\n  \\<forall>P1 P2 C.\n     finite P1 \\<longrightarrow>\n     finite P2 \\<longrightarrow> R P1 P2 C \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. finite C", "by blast"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "from assms this and \\<open>redundant C (inferred_clause_sets R S (Suc ?N))\\<close>"], ["proof (chain)\npicking this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  finite C\n  redundant C (inferred_clause_sets R S (Suc (max N1 N2)))", "have \"redundant C (saturation R S)\""], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  finite C\n  redundant C (inferred_clause_sets R S (Suc (max N1 N2)))\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "using  persistent_clauses_subsume_redundant_clauses [of C R S \"Suc ?N\"]"], ["proof (prove)\nusing this:\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  finite C\n  redundant C (inferred_clause_sets R S (Suc (max N1 N2)))\n  \\<lbrakk>redundant C (inferred_clause_sets R S (Suc (max N1 N2)));\n   all_fulfill finite S; derived_clauses_are_finite R; finite C\\<rbrakk>\n  \\<Longrightarrow> redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "by auto"], ["proof (state)\nthis:\n  redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule R (saturation R S) \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not>redundant C ?S\\<close>"], ["proof (prove)\nusing this:\n  redundant C (saturation R S)\n  \\<not> redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, we show that the computed saturated set is equivalent to the initial formula.\\<close>"], ["", "theorem saturation_is_correct: \n  assumes \"Sound R\"\n  assumes \"derived_clauses_are_finite R\"\n  assumes \"all_fulfill finite S\"\n  shows \"equivalent S (saturation R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent S (saturation R S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equivalent S (saturation R S)", "have \"entails_formula S (saturation R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula S (saturation R S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (saturation R S) \\<Longrightarrow> False", "assume \"\\<not> entails_formula S (saturation R S)\""], ["proof (state)\nthis:\n  \\<not> entails_formula S (saturation R S)\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (saturation R S) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> entails_formula S (saturation R S)", "obtain C where \"C \\<in> saturation R S\" and \"\\<not> entails S C\""], ["proof (prove)\nusing this:\n  \\<not> entails_formula S (saturation R S)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> saturation R S; \\<not> entails S C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding entails_formula_def"], ["proof (prove)\nusing this:\n  \\<not> Ball (saturation R S) (entails S)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> saturation R S; \\<not> entails S C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> saturation R S\n  \\<not> entails S C\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (saturation R S) \\<Longrightarrow> False", "from \\<open>C \\<in> saturation R S\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> saturation R S", "obtain N where \"C \\<in> inferred_clause_sets R S N\""], ["proof (prove)\nusing this:\n  C \\<in> saturation R S\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        C \\<in> inferred_clause_sets R S N \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> inferred_clause_sets R S N\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (saturation R S) \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  C \\<in> inferred_clause_sets R S N\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (saturation R S) \\<Longrightarrow> False", "fix N"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (saturation R S) \\<Longrightarrow> False", "have \"entails_formula S (inferred_clause_sets R S N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula S (inferred_clause_sets R S N)", "proof (induction N)"], ["proof (state)\ngoal (2 subgoals):\n 1. entails_formula S (inferred_clause_sets R S 0)\n 2. \\<And>N.\n       entails_formula S (inferred_clause_sets R S N) \\<Longrightarrow>\n       entails_formula S (inferred_clause_sets R S (Suc N))", "show \"entails_formula S (inferred_clause_sets R S 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula S (inferred_clause_sets R S 0)", "using assms(3) simplify_preserves_semantic validity_implies_entailment"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  \\<lbrakk>?T = simplify ?S; all_fulfill finite ?S\\<rbrakk>\n  \\<Longrightarrow> ?I \\<Turnstile> ?S = ?I \\<Turnstile> ?T\n  \\<forall>I.\n     I \\<Turnstile> ?S1.0 \\<longrightarrow>\n     I \\<Turnstile> ?S2.0 \\<Longrightarrow>\n  entails_formula ?S1.0 ?S2.0\n\ngoal (1 subgoal):\n 1. entails_formula S (inferred_clause_sets R S 0)", "by auto"], ["proof (state)\nthis:\n  entails_formula S (inferred_clause_sets R S 0)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       entails_formula S (inferred_clause_sets R S N) \\<Longrightarrow>\n       entails_formula S (inferred_clause_sets R S (Suc N))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>N.\n       entails_formula S (inferred_clause_sets R S N) \\<Longrightarrow>\n       entails_formula S (inferred_clause_sets R S (Suc N))", "fix N"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>N.\n       entails_formula S (inferred_clause_sets R S N) \\<Longrightarrow>\n       entails_formula S (inferred_clause_sets R S (Suc N))", "assume \"entails_formula S (inferred_clause_sets R S N)\""], ["proof (state)\nthis:\n  entails_formula S (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       entails_formula S (inferred_clause_sets R S N) \\<Longrightarrow>\n       entails_formula S (inferred_clause_sets R S (Suc N))", "from assms(1)"], ["proof (chain)\npicking this:\n  Sound R", "have \"entails_formula (inferred_clause_sets R S N)   \n          (add_all_deducible_clauses R (inferred_clause_sets R S N))\""], ["proof (prove)\nusing this:\n  Sound R\n\ngoal (1 subgoal):\n 1. entails_formula (inferred_clause_sets R S N)\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "using add_all_deducible_sound"], ["proof (prove)\nusing this:\n  Sound R\n  Sound ?R \\<Longrightarrow>\n  entails_formula ?S (add_all_deducible_clauses ?R ?S)\n\ngoal (1 subgoal):\n 1. entails_formula (inferred_clause_sets R S N)\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "by auto"], ["proof (state)\nthis:\n  entails_formula (inferred_clause_sets R S N)\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       entails_formula S (inferred_clause_sets R S N) \\<Longrightarrow>\n       entails_formula S (inferred_clause_sets R S (Suc N))", "from this and \\<open>entails_formula S (inferred_clause_sets R S N)\\<close>"], ["proof (chain)\npicking this:\n  entails_formula (inferred_clause_sets R S N)\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n  entails_formula S (inferred_clause_sets R S N)", "have \"entails_formula S (add_all_deducible_clauses R (inferred_clause_sets R S N))\""], ["proof (prove)\nusing this:\n  entails_formula (inferred_clause_sets R S N)\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n  entails_formula S (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. entails_formula S\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "using entails_transitive \n        [of S \"inferred_clause_sets R S N\" \"add_all_deducible_clauses R (inferred_clause_sets R S N)\"]"], ["proof (prove)\nusing this:\n  entails_formula (inferred_clause_sets R S N)\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n  entails_formula S (inferred_clause_sets R S N)\n  \\<lbrakk>entails_formula S (inferred_clause_sets R S N);\n   entails_formula (inferred_clause_sets R S N)\n    (add_all_deducible_clauses R (inferred_clause_sets R S N))\\<rbrakk>\n  \\<Longrightarrow> entails_formula S\n                     (add_all_deducible_clauses R\n                       (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. entails_formula S\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))", "by auto"], ["proof (state)\nthis:\n  entails_formula S\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       entails_formula S (inferred_clause_sets R S N) \\<Longrightarrow>\n       entails_formula S (inferred_clause_sets R S (Suc N))", "have \"inferred_clause_sets R S (Suc N) \\<subseteq> add_all_deducible_clauses R \n                (inferred_clause_sets R S N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inferred_clause_sets R S (Suc N)\n    \\<subseteq> add_all_deducible_clauses R (inferred_clause_sets R S N)", "using simplify_def"], ["proof (prove)\nusing this:\n  simplify ?S = {C \\<in> ?S. \\<not> strictly_redundant C ?S}\n\ngoal (1 subgoal):\n 1. inferred_clause_sets R S (Suc N)\n    \\<subseteq> add_all_deducible_clauses R (inferred_clause_sets R S N)", "by auto"], ["proof (state)\nthis:\n  inferred_clause_sets R S (Suc N)\n  \\<subseteq> add_all_deducible_clauses R (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       entails_formula S (inferred_clause_sets R S N) \\<Longrightarrow>\n       entails_formula S (inferred_clause_sets R S (Suc N))", "then"], ["proof (chain)\npicking this:\n  inferred_clause_sets R S (Suc N)\n  \\<subseteq> add_all_deducible_clauses R (inferred_clause_sets R S N)", "have \"entails_formula (add_all_deducible_clauses R (inferred_clause_sets R S N))\n              (inferred_clause_sets R S (Suc N))\""], ["proof (prove)\nusing this:\n  inferred_clause_sets R S (Suc N)\n  \\<subseteq> add_all_deducible_clauses R (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. entails_formula\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))\n     (inferred_clause_sets R S (Suc N))", "using entailment_subset"], ["proof (prove)\nusing this:\n  inferred_clause_sets R S (Suc N)\n  \\<subseteq> add_all_deducible_clauses R (inferred_clause_sets R S N)\n  ?S2.0 \\<subseteq> ?S1.0 \\<Longrightarrow> entails_formula ?S1.0 ?S2.0\n\ngoal (1 subgoal):\n 1. entails_formula\n     (add_all_deducible_clauses R (inferred_clause_sets R S N))\n     (inferred_clause_sets R S (Suc N))", "by auto"], ["proof (state)\nthis:\n  entails_formula (add_all_deducible_clauses R (inferred_clause_sets R S N))\n   (inferred_clause_sets R S (Suc N))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       entails_formula S (inferred_clause_sets R S N) \\<Longrightarrow>\n       entails_formula S (inferred_clause_sets R S (Suc N))", "from this and \\<open>entails_formula S (add_all_deducible_clauses R (inferred_clause_sets R S N))\\<close>"], ["proof (chain)\npicking this:\n  entails_formula (add_all_deducible_clauses R (inferred_clause_sets R S N))\n   (inferred_clause_sets R S (Suc N))\n  entails_formula S\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))", "show \"entails_formula S (inferred_clause_sets R S (Suc N))\""], ["proof (prove)\nusing this:\n  entails_formula (add_all_deducible_clauses R (inferred_clause_sets R S N))\n   (inferred_clause_sets R S (Suc N))\n  entails_formula S\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n\ngoal (1 subgoal):\n 1. entails_formula S (inferred_clause_sets R S (Suc N))", "using entails_transitive [of S \"add_all_deducible_clauses R (inferred_clause_sets R S N)\"]"], ["proof (prove)\nusing this:\n  entails_formula (add_all_deducible_clauses R (inferred_clause_sets R S N))\n   (inferred_clause_sets R S (Suc N))\n  entails_formula S\n   (add_all_deducible_clauses R (inferred_clause_sets R S N))\n  \\<lbrakk>entails_formula S\n            (add_all_deducible_clauses R (inferred_clause_sets R S N));\n   entails_formula\n    (add_all_deducible_clauses R (inferred_clause_sets R S N))\n    ?S3.0\\<rbrakk>\n  \\<Longrightarrow> entails_formula S ?S3.0\n\ngoal (1 subgoal):\n 1. entails_formula S (inferred_clause_sets R S (Suc N))", "by auto"], ["proof (state)\nthis:\n  entails_formula S (inferred_clause_sets R S (Suc N))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  entails_formula S (inferred_clause_sets R S N)\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (saturation R S) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  entails_formula S (inferred_clause_sets R S ?Na2)\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S (saturation R S) \\<Longrightarrow> False", "from this and \\<open>C \\<in> inferred_clause_sets R S N\\<close> and \\<open>\\<not> entails S C\\<close>"], ["proof (chain)\npicking this:\n  entails_formula S (inferred_clause_sets R S ?Na2)\n  C \\<in> inferred_clause_sets R S N\n  \\<not> entails S C", "show \"False\""], ["proof (prove)\nusing this:\n  entails_formula S (inferred_clause_sets R S ?Na2)\n  C \\<in> inferred_clause_sets R S N\n  \\<not> entails S C\n\ngoal (1 subgoal):\n 1. False", "unfolding entails_formula_def"], ["proof (prove)\nusing this:\n  Ball (inferred_clause_sets R S ?Na2) (entails S)\n  C \\<in> inferred_clause_sets R S N\n  \\<not> entails S C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  entails_formula S (saturation R S)\n\ngoal (1 subgoal):\n 1. equivalent S (saturation R S)", "have \"entails_formula (saturation R S) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula (saturation R S) S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> entails_formula (saturation R S) S \\<Longrightarrow> False", "assume \"\\<not> entails_formula (saturation R S) S\""], ["proof (state)\nthis:\n  \\<not> entails_formula (saturation R S) S\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula (saturation R S) S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> entails_formula (saturation R S) S", "obtain C where \"C \\<in> S\" and \"\\<not> entails (saturation R S) C\""], ["proof (prove)\nusing this:\n  \\<not> entails_formula (saturation R S) S\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> S; \\<not> entails (saturation R S) C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding entails_formula_def"], ["proof (prove)\nusing this:\n  \\<not> Ball S (entails (saturation R S))\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> S; \\<not> entails (saturation R S) C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> S\n  \\<not> entails (saturation R S) C\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula (saturation R S) S \\<Longrightarrow> False", "from \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> S", "have \"redundant C S\""], ["proof (prove)\nusing this:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. redundant C S", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subseteq> C)", "by auto"], ["proof (state)\nthis:\n  redundant C S\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula (saturation R S) S \\<Longrightarrow> False", "from assms(3) and \\<open>redundant C S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S\n  redundant C S", "have \"redundant C (inferred_clause_sets R S 0)\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  redundant C S\n\ngoal (1 subgoal):\n 1. redundant C (inferred_clause_sets R S 0)", "using simplify_preserves_redundancy"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  redundant C S\n  \\<lbrakk>all_fulfill finite ?S; redundant ?C ?S\\<rbrakk>\n  \\<Longrightarrow> redundant ?C (simplify ?S)\n\ngoal (1 subgoal):\n 1. redundant C (inferred_clause_sets R S 0)", "by auto"], ["proof (state)\nthis:\n  redundant C (inferred_clause_sets R S 0)\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula (saturation R S) S \\<Longrightarrow> False", "from assms(3) and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S\n  C \\<in> S", "have \"finite C\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite C", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite C", "by auto"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula (saturation R S) S \\<Longrightarrow> False", "from \\<open>redundant C (inferred_clause_sets R S 0)\\<close> assms(2) assms(3) \\<open>finite C\\<close>"], ["proof (chain)\npicking this:\n  redundant C (inferred_clause_sets R S 0)\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  finite C", "have \"redundant C (saturation R S)\""], ["proof (prove)\nusing this:\n  redundant C (inferred_clause_sets R S 0)\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  finite C\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "using persistent_clauses_subsume_redundant_clauses [of C R S 0]"], ["proof (prove)\nusing this:\n  redundant C (inferred_clause_sets R S 0)\n  derived_clauses_are_finite R\n  all_fulfill finite S\n  finite C\n  \\<lbrakk>redundant C (inferred_clause_sets R S 0); all_fulfill finite S;\n   derived_clauses_are_finite R; finite C\\<rbrakk>\n  \\<Longrightarrow> redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. redundant C (saturation R S)", "by auto"], ["proof (state)\nthis:\n  redundant C (saturation R S)\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula (saturation R S) S \\<Longrightarrow> False", "from this and \\<open>\\<not> entails (saturation R S) C\\<close>"], ["proof (chain)\npicking this:\n  redundant C (saturation R S)\n  \\<not> entails (saturation R S) C", "show \"False\""], ["proof (prove)\nusing this:\n  redundant C (saturation R S)\n  \\<not> entails (saturation R S) C\n\ngoal (1 subgoal):\n 1. False", "using entails_formula_def redundancy_implies_entailment"], ["proof (prove)\nusing this:\n  redundant C (saturation R S)\n  \\<not> entails (saturation R S) C\n  entails_formula ?S1.0 ?S2.0 = (\\<forall>C\\<in>?S2.0. entails ?S1.0 C)\n  redundant ?C ?S \\<Longrightarrow> entails ?S ?C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  entails_formula (saturation R S) S\n\ngoal (1 subgoal):\n 1. equivalent S (saturation R S)", "from \\<open>entails_formula S (saturation R S)\\<close> and \\<open>entails_formula (saturation R S) S\\<close>"], ["proof (chain)\npicking this:\n  entails_formula S (saturation R S)\n  entails_formula (saturation R S) S", "show ?thesis"], ["proof (prove)\nusing this:\n  entails_formula S (saturation R S)\n  entails_formula (saturation R S) S\n\ngoal (1 subgoal):\n 1. equivalent S (saturation R S)", "unfolding equivalent_def"], ["proof (prove)\nusing this:\n  entails_formula S (saturation R S)\n  entails_formula (saturation R S) S\n\ngoal (1 subgoal):\n 1. entails_formula S (saturation R S) \\<and>\n    entails_formula (saturation R S) S", "by auto"], ["proof (state)\nthis:\n  equivalent S (saturation R S)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}