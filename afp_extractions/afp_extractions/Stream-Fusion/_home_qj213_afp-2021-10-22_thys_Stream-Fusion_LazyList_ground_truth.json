{"file_name": "/home/qj213/afp-2021-10-22/thys/Stream-Fusion/LazyList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stream-Fusion", "problem_names": ["lemma mapL_strict [simp]: \"mapL\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma filterL_strict [simp]: \"filterL\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\"", "lemma foldrL_strict [simp]: \"foldrL\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>\"", "lemma enumFromToL_simps' [simp]:\n  \"x \\<le> y \\<Longrightarrow>\n    enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>y) = LCons\\<cdot>(up\\<cdot>x)\\<cdot>(enumFromToL\\<cdot>(up\\<cdot>(x+1))\\<cdot>(up\\<cdot>y))\"\n  \"\\<not> x \\<le> y \\<Longrightarrow> enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>y) = LNil\"", "lemma enumFromToL_strict [simp]:\n  \"enumFromToL\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\"\n  \"enumFromToL\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma appendL_strict [simp]: \"appendL\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"", "lemma appendL_LNil_right: \"appendL\\<cdot>xs\\<cdot>LNil = xs\"", "lemma zipWithL_strict [simp]:\n  \"zipWithL\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"\n  \"zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>\\<bottom> = \\<bottom>\"", "lemma concatMapL_strict [simp]: \"concatMapL\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], "translations": [["", "lemma mapL_strict [simp]: \"mapL\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapL\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec\n  filterL :: \"('a \\<rightarrow> tr) \\<rightarrow> 'a LList \\<rightarrow> 'a LList\"\nwhere\n  \"filterL\\<cdot>p\\<cdot>LNil = LNil\"\n| \"filterL\\<cdot>p\\<cdot>(LCons\\<cdot>x\\<cdot>xs) =\n    (If p\\<cdot>x then LCons\\<cdot>x\\<cdot>(filterL\\<cdot>p\\<cdot>xs) else filterL\\<cdot>p\\<cdot>xs)\""], ["", "lemma filterL_strict [simp]: \"filterL\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterL\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec\n  foldrL :: \"('a \\<rightarrow> 'b \\<rightarrow> 'b) \\<rightarrow> 'b \\<rightarrow> 'a LList \\<rightarrow> 'b\"\nwhere\n  \"foldrL\\<cdot>f\\<cdot>z\\<cdot>LNil = z\"\n| \"foldrL\\<cdot>f\\<cdot>z\\<cdot>(LCons\\<cdot>x\\<cdot>xs) = f\\<cdot>x\\<cdot>(foldrL\\<cdot>f\\<cdot>z\\<cdot>xs)\""], ["", "lemma foldrL_strict [simp]: \"foldrL\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldrL\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec\n  enumFromToL :: \"int\\<^sub>\\<bottom> \\<rightarrow> int\\<^sub>\\<bottom> \\<rightarrow> (int\\<^sub>\\<bottom>) LList\"\nwhere\n  \"enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>y) =\n    (if x \\<le> y then LCons\\<cdot>(up\\<cdot>x)\\<cdot>(enumFromToL\\<cdot>(up\\<cdot>(x+1))\\<cdot>(up\\<cdot>y)) else LNil)\""], ["", "lemma enumFromToL_simps' [simp]:\n  \"x \\<le> y \\<Longrightarrow>\n    enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>y) = LCons\\<cdot>(up\\<cdot>x)\\<cdot>(enumFromToL\\<cdot>(up\\<cdot>(x+1))\\<cdot>(up\\<cdot>y))\"\n  \"\\<not> x \\<le> y \\<Longrightarrow> enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>y) = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y \\<Longrightarrow>\n     enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>y) =\n     LCons\\<cdot>(up\\<cdot>x)\\<cdot>\n     (enumFromToL\\<cdot>(up\\<cdot>(x + 1))\\<cdot>(up\\<cdot>y))) &&&\n    (\\<not> x \\<le> y \\<Longrightarrow>\n     enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>y) = LNil)", "by simp_all"], ["", "declare enumFromToL.simps [simp del]"], ["", "lemma enumFromToL_strict [simp]:\n  \"enumFromToL\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\"\n  \"enumFromToL\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enumFromToL\\<cdot>\\<bottom>\\<cdot>y = \\<bottom> &&&\n    enumFromToL\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "apply (subst enumFromToL.unfold, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumFromToL\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "apply (induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. enumFromToL\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>x. enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>\\<bottom> = \\<bottom>", "apply (subst enumFromToL.unfold, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fixrec\n  appendL :: \"'a LList \\<rightarrow> 'a LList \\<rightarrow> 'a LList\"\nwhere\n  \"appendL\\<cdot>LNil\\<cdot>ys = ys\"\n| \"appendL\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>ys = LCons\\<cdot>x\\<cdot>(appendL\\<cdot>xs\\<cdot>ys)\""], ["", "lemma appendL_strict [simp]: \"appendL\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. appendL\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>", "by fixrec_simp"], ["", "lemma appendL_LNil_right: \"appendL\\<cdot>xs\\<cdot>LNil = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. appendL\\<cdot>xs\\<cdot>LNil = xs", "by (induct xs) simp_all"], ["", "fixrec\n  zipWithL :: \"('a \\<rightarrow> 'b \\<rightarrow> 'c) \\<rightarrow> 'a LList \\<rightarrow> 'b LList \\<rightarrow> 'c LList\"\nwhere\n  \"zipWithL\\<cdot>f\\<cdot>LNil\\<cdot>ys = LNil\"\n| \"zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>LNil = LNil\"\n| \"zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>(LCons\\<cdot>y\\<cdot>ys) = LCons\\<cdot>(f\\<cdot>x\\<cdot>y)\\<cdot>(zipWithL\\<cdot>f\\<cdot>xs\\<cdot>ys)\""], ["", "lemma zipWithL_strict [simp]:\n  \"zipWithL\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"\n  \"zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zipWithL\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom> &&&\n    zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>\\<bottom> =\n    \\<bottom>", "by fixrec_simp+"], ["", "fixrec\n  concatMapL :: \"('a \\<rightarrow> 'b LList) \\<rightarrow> 'a LList \\<rightarrow> 'b LList\"\nwhere\n  \"concatMapL\\<cdot>f\\<cdot>LNil = LNil\"\n| \"concatMapL\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs) = appendL\\<cdot>(f\\<cdot>x)\\<cdot>(concatMapL\\<cdot>f\\<cdot>xs)\""], ["", "lemma concatMapL_strict [simp]: \"concatMapL\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMapL\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "end"]]}