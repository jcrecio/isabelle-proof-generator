{"file_name": "/home/qj213/afp-2021-10-22/thys/Stream-Fusion/StreamFusion.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stream-Fusion", "problem_names": ["lemma unfold_mapStep:\n  fixes f :: \"'a \\<rightarrow> 'b\" and h :: \"'s \\<rightarrow> ('a, 's) Step\"\n  assumes \"s \\<noteq> \\<bottom>\"\n  shows \"unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s = mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)\"", "lemma unstream_mapS:\n  fixes f :: \"'a \\<rightarrow> 'b\" and a :: \"('a, 's) Stream\"\n  shows \"a \\<noteq> \\<bottom> \\<Longrightarrow> unstream\\<cdot>(mapS\\<cdot>f\\<cdot>a) = mapL\\<cdot>f\\<cdot>(unstream\\<cdot>a)\"", "lemma mapS_defined: \"a \\<noteq> \\<bottom> \\<Longrightarrow> mapS\\<cdot>f\\<cdot>a \\<noteq> \\<bottom>\"", "lemma mapS_cong:\n  fixes f :: \"'a \\<rightarrow> 'b\"\n  fixes a :: \"('a, 's) Stream\"\n  fixes b :: \"('a, 't) Stream\"\n  shows \"f = g \\<Longrightarrow> a \\<approx> b \\<Longrightarrow> mapS\\<cdot>f\\<cdot>a \\<approx> mapS\\<cdot>g\\<cdot>b\"", "lemma mapL_eq: \"mapL\\<cdot>f\\<cdot>xs = unstream\\<cdot>(mapS\\<cdot>f\\<cdot>(stream\\<cdot>xs))\"", "lemma unfold_filterStep:\n  fixes p :: \"'a \\<rightarrow> tr\" and h :: \"'s \\<rightarrow> ('a, 's) Step\"\n  assumes \"s \\<noteq> \\<bottom>\"\n  shows \"unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s = filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)\"", "lemma unstream_filterS:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> unstream\\<cdot>(filterS\\<cdot>p\\<cdot>a) = filterL\\<cdot>p\\<cdot>(unstream\\<cdot>a)\"", "lemma filterS_defined: \"a \\<noteq> \\<bottom> \\<Longrightarrow> filterS\\<cdot>p\\<cdot>a \\<noteq> \\<bottom>\"", "lemma filterS_cong:\n  fixes p :: \"'a \\<rightarrow> tr\"\n  fixes a :: \"('a, 's) Stream\"\n  fixes b :: \"('a, 't) Stream\"\n  shows \"p = q \\<Longrightarrow> a \\<approx> b \\<Longrightarrow> filterS\\<cdot>p\\<cdot>a \\<approx> filterS\\<cdot>q\\<cdot>b\"", "lemma filterL_eq: \"filterL\\<cdot>p\\<cdot>xs = unstream\\<cdot>(filterS\\<cdot>p\\<cdot>(stream\\<cdot>xs))\"", "lemma unfold_foldrS:\n  assumes \"s \\<noteq> \\<bottom>\" shows \"foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s) = foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s)\"", "lemma unstream_foldrS:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> foldrS\\<cdot>f\\<cdot>z\\<cdot>a = foldrL\\<cdot>f\\<cdot>z\\<cdot>(unstream\\<cdot>a)\"", "lemma foldrS_cong:\n  fixes a :: \"('a, 's) Stream\"\n  fixes b :: \"('a, 't) Stream\"\n  shows \"f = g \\<Longrightarrow> z = w \\<Longrightarrow> a \\<approx> b \\<Longrightarrow> foldrS\\<cdot>f\\<cdot>z\\<cdot>a = foldrS\\<cdot>g\\<cdot>w\\<cdot>b\"", "lemma foldrL_eq:\n  \"foldrL\\<cdot>f\\<cdot>z\\<cdot>xs = foldrS\\<cdot>f\\<cdot>z\\<cdot>(stream\\<cdot>xs)\"", "lemma enumFromToStep_strict [simp]:\n  \"enumFromToStep\\<cdot>\\<bottom>\\<cdot>x'' = \\<bottom>\"\n  \"enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>\\<bottom> = \\<bottom>\"\n  \"enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>\\<bottom>) = \\<bottom>\"", "lemma enumFromToStep_simps' [simp]:\n  \"x \\<le> y \\<Longrightarrow> enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>(up\\<cdot>x)) =\n    Yield\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>(up\\<cdot>(x+1)))\"\n  \"\\<not> x \\<le> y \\<Longrightarrow> enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>(up\\<cdot>x)) = Done\"", "lemma unfold_enumFromToStep:\n  \"unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n) = enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)\"", "lemma unstream_enumFromToS:\n  \"unstream\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y) = enumFromToL\\<cdot>x\\<cdot>y\"", "lemma enumFromToS_defined: \"enumFromToS\\<cdot>x\\<cdot>y \\<noteq> \\<bottom>\"", "lemma enumFromToS_cong:\n  \"x = x' \\<Longrightarrow> y = y' \\<Longrightarrow> enumFromToS\\<cdot>x\\<cdot>y \\<approx> enumFromToS\\<cdot>x'\\<cdot>y'\"", "lemma enumFromToL_eq: \"enumFromToL\\<cdot>x\\<cdot>y = unstream\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y)\"", "lemma appendStep_strict [simp]: \"appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0\\<cdot>\\<bottom> = \\<bottom>\"", "lemma unfold_appendStep:\n  fixes ha :: \"'s \\<rightarrow> ('a, 's) Step\"\n  fixes hb :: \"'t \\<rightarrow> ('a, 't) Step\"\n  assumes sb0 [simp]: \"sb0 \\<noteq> \\<bottom>\"\n  shows\n  \"(\\<forall>sa. sa \\<noteq> \\<bottom> \\<longrightarrow> unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>(Left\\<cdot>sa) =\n         appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>(unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n   (\\<forall>sb. sb \\<noteq> \\<bottom> \\<longrightarrow> unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>(Right\\<cdot>sb) =\n         unfold\\<cdot>hb\\<cdot>sb)\"", "lemma appendS_defined: \"xs \\<noteq> \\<bottom> \\<Longrightarrow> ys \\<noteq> \\<bottom> \\<Longrightarrow> appendS\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>\"", "lemma unstream_appendS:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> b \\<noteq> \\<bottom> \\<Longrightarrow>\n    unstream\\<cdot>(appendS\\<cdot>a\\<cdot>b) = appendL\\<cdot>(unstream\\<cdot>a)\\<cdot>(unstream\\<cdot>b)\"", "lemma appendS_cong:\n  fixes f :: \"'a \\<rightarrow> 'b\"\n  fixes a :: \"('a, 's) Stream\"\n  fixes b :: \"('a, 't) Stream\"\n  shows \"a \\<approx> a' \\<Longrightarrow> b \\<approx> b' \\<Longrightarrow> appendS\\<cdot>a\\<cdot>b \\<approx> appendS\\<cdot>a'\\<cdot>b'\"", "lemma appendL_eq: \"appendL\\<cdot>xs\\<cdot>ys = unstream\\<cdot>(appendS\\<cdot>(stream\\<cdot>xs)\\<cdot>(stream\\<cdot>ys))\"", "lemma zipWithStep_strict [simp]: \"zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\\<cdot>\\<bottom> = \\<bottom>\"", "lemma zipWithS_fix_ind_lemma:\n  fixes P Q :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\"\n  assumes P_0: \"\\<And>j. P 0 j\" and P_Suc: \"\\<And>i j. P i j \\<Longrightarrow> Q i j \\<Longrightarrow> P (Suc i) j\"\n  assumes Q_0: \"\\<And>i. Q i 0\" and Q_Suc: \"\\<And>i j. P i j \\<Longrightarrow> Q i j \\<Longrightarrow> Q i (Suc j)\"\n  shows \"P i j \\<and> Q i j\"", "lemma zipWithS_fix_ind:\n  assumes x: \"x = fix\\<cdot>f\" and y: \"y = fix\\<cdot>g\"\n  assumes adm_P: \"adm (\\<lambda>x. P (fst x) (snd x))\"\n  assumes adm_Q: \"adm (\\<lambda>x. Q (fst x) (snd x))\"\n  assumes P_0: \"\\<And>b. P \\<bottom> b\" and P_Suc: \"\\<And>a b. P a b \\<Longrightarrow> Q a b \\<Longrightarrow> P (f\\<cdot>a) b\"\n  assumes Q_0: \"\\<And>a. Q a \\<bottom>\" and Q_Suc: \"\\<And>a b. P a b \\<Longrightarrow> Q a b \\<Longrightarrow> Q a (g\\<cdot>b)\"\n  shows \"P x y \\<and> Q x y\"", "lemma unfold_zipWithStep:\n  fixes f :: \"'a \\<rightarrow> 'b \\<rightarrow> 'c\"\n  fixes ha :: \"'s \\<rightarrow> ('a, 's) Step\"\n  fixes hb :: \"'t \\<rightarrow> ('b, 't) Step\"\n  defines h_def: \"h \\<equiv> zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\"\n  shows\n  \"(\\<forall>sa sb. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n    unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n   (\\<forall>sa sb a. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n    unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n      zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>(unfold\\<cdot>hb\\<cdot>sb))\"", "lemma zipWithS_defined: \"a \\<noteq> \\<bottom> \\<Longrightarrow> b \\<noteq> \\<bottom> \\<Longrightarrow> zipWithS\\<cdot>f\\<cdot>a\\<cdot>b \\<noteq> \\<bottom>\"", "lemma unstream_zipWithS:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> b \\<noteq> \\<bottom> \\<Longrightarrow>\n    unstream\\<cdot>(zipWithS\\<cdot>f\\<cdot>a\\<cdot>b) = zipWithL\\<cdot>f\\<cdot>(unstream\\<cdot>a)\\<cdot>(unstream\\<cdot>b)\"", "lemma zipWithS_cong:\n  \"f = f' \\<Longrightarrow> a \\<approx> a' \\<Longrightarrow> b \\<approx> b' \\<Longrightarrow>\n    zipWithS\\<cdot>f\\<cdot>a\\<cdot>b \\<approx> zipWithS\\<cdot>f\\<cdot>a'\\<cdot>b'\"", "lemma zipWithL_eq:\n  \"zipWithL\\<cdot>f\\<cdot>xs\\<cdot>ys = unstream\\<cdot>(zipWithS\\<cdot>f\\<cdot>(stream\\<cdot>xs)\\<cdot>(stream\\<cdot>ys))\"", "lemma concatMapStep_strict [simp]: \"concatMapStep\\<cdot>f\\<cdot>ha\\<cdot>\\<bottom> = \\<bottom>\"", "lemma concatMapS_strict [simp]: \"concatMapS\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma unfold_concatMapStep:\n  fixes ha :: \"'s \\<rightarrow> ('a, 's) Step\"\n  fixes f :: \"'a \\<rightarrow> ('b, 't) Stream\"\n  defines h_def: \"h \\<equiv> concatMapStep\\<cdot>f\\<cdot>ha\"\n  defines f'_def: \"f' \\<equiv> unstream oo f\"\n  shows\n  \"(\\<forall>sa. sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing) = concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n   (\\<forall>sa hb sb. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>(concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))\"", "lemma unstream_concatMapS:\n  \"unstream\\<cdot>(concatMapS\\<cdot>f\\<cdot>a) = concatMapL\\<cdot>(unstream oo f)\\<cdot>(unstream\\<cdot>a)\"", "lemma concatMapS_defined: \"a \\<noteq> \\<bottom> \\<Longrightarrow> concatMapS\\<cdot>f\\<cdot>a \\<noteq> \\<bottom>\"", "lemma concatMapS_cong:\n  fixes f :: \"'a \\<Rightarrow> ('b, 's) Stream\"\n  fixes g :: \"'a \\<Rightarrow> ('b, 't) Stream\"\n  fixes a :: \"('a, 'u) Stream\"\n  fixes b :: \"('a, 'v) Stream\"\n  shows \"(\\<And>x. f x \\<approx> g x) \\<Longrightarrow> a \\<approx> b \\<Longrightarrow> cont f \\<Longrightarrow> cont g \\<Longrightarrow>\n    concatMapS\\<cdot>(\\<Lambda> x. f x)\\<cdot>a \\<approx> concatMapS\\<cdot>(\\<Lambda> x. g x)\\<cdot>b\"", "lemma concatMapL_eq:\n  \"concatMapL\\<cdot>f\\<cdot>xs = unstream\\<cdot>(concatMapS\\<cdot>(stream oo f)\\<cdot>(stream\\<cdot>xs))\"", "lemmas stream_eqs =\n  mapL_eq\n  filterL_eq\n  foldrL_eq\n  enumFromToL_eq\n  appendL_eq\n  zipWithL_eq\n  concatMapL_eq", "lemmas stream_congs =\n  unstream_cong\n  stream_cong\n  stream_unstream_cong\n  mapS_cong\n  filterS_cong\n  foldrS_cong\n  enumFromToS_cong\n  appendS_cong\n  zipWithS_cong\n  concatMapS_cong", "lemma\n  \"mapL\\<cdot>f oo filterL\\<cdot>p oo mapL\\<cdot>g =\n   unstream oo mapS\\<cdot>f oo filterS\\<cdot>p oo mapS\\<cdot>g oo stream\"", "lemma\n  \"foldrL\\<cdot>f\\<cdot>z\\<cdot>(mapL\\<cdot>g\\<cdot>(filterL\\<cdot>p\\<cdot>(enumFromToL\\<cdot>x\\<cdot>y))) =\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>(mapS\\<cdot>g\\<cdot>(filterS\\<cdot>p\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y)))\"", "lemma oo_LAM [simp]: \"cont g \\<Longrightarrow> f oo (\\<Lambda> x. g x) = (\\<Lambda> x. f\\<cdot>(g x))\"", "lemma\n  \"concatMapL\\<cdot>(\\<Lambda> k.\n    mapL\\<cdot>(\\<Lambda> m. f\\<cdot>k\\<cdot>m)\\<cdot>(enumFromToL\\<cdot>one\\<cdot>k))\\<cdot>(enumFromToL\\<cdot>one\\<cdot>n) =\n   unstream\\<cdot>(concatMapS\\<cdot>(\\<Lambda> k.\n    mapS\\<cdot>(\\<Lambda> m. f\\<cdot>k\\<cdot>m)\\<cdot>(enumFromToS\\<cdot>one\\<cdot>k))\\<cdot>(enumFromToS\\<cdot>one\\<cdot>n))\""], "translations": [["", "lemma unfold_mapStep:\n  fixes f :: \"'a \\<rightarrow> 'b\" and h :: \"'s \\<rightarrow> ('a, 's) Step\"\n  assumes \"s \\<noteq> \\<bottom>\"\n  shows \"unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s = mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s =\n    mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "proof (rule below_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s \\<sqsubseteq>\n    mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)\n 2. mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s", "show \"unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s \\<sqsubseteq> mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s \\<sqsubseteq>\n    mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "using \\<open>s \\<noteq> \\<bottom>\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s \\<sqsubseteq>\n    mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "apply (induct arbitrary: s rule: unfold_ind [where h=\"mapStep\\<cdot>f\\<cdot>h\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               x \\<noteq> \\<bottom> \\<longrightarrow>\n               a\\<cdot>x \\<sqsubseteq>\n               mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>x))\n 2. \\<And>s.\n       s \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<bottom>\\<cdot>s \\<sqsubseteq>\n       mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)\n 3. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   u\\<cdot>s \\<sqsubseteq>\n                   mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s);\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>\n                         u\\<cdot>\n                         s \\<sqsubseteq>\n                         mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "apply (simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   u\\<cdot>s \\<sqsubseteq>\n                   mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s);\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>\n                         u\\<cdot>\n                         s \\<sqsubseteq>\n                         mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "apply (case_tac \"h\\<cdot>s\", simp_all add: unfold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s \\<sqsubseteq>\n  mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s)\n\ngoal (1 subgoal):\n 1. mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s", "show \"mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq> unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s", "using \\<open>s \\<noteq> \\<bottom>\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s", "apply (induct arbitrary: s rule: unfold_ind [where h=\"h\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               x \\<noteq> \\<bottom> \\<longrightarrow>\n               mapL\\<cdot>f\\<cdot>(a\\<cdot>x) \\<sqsubseteq>\n               unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>x)\n 2. \\<And>s.\n       s \\<noteq> \\<bottom> \\<Longrightarrow>\n       mapL\\<cdot>f\\<cdot>(\\<bottom>\\<cdot>s) \\<sqsubseteq>\n       unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s\n 3. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   mapL\\<cdot>f\\<cdot>(u\\<cdot>s) \\<sqsubseteq>\n                   unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s;\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> mapL\\<cdot>f\\<cdot>\n                         (unfoldF\\<cdot>h\\<cdot>u\\<cdot>s) \\<sqsubseteq>\n                         unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s", "apply (simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   mapL\\<cdot>f\\<cdot>(u\\<cdot>s) \\<sqsubseteq>\n                   unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s;\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> mapL\\<cdot>f\\<cdot>\n                         (unfoldF\\<cdot>h\\<cdot>u\\<cdot>s) \\<sqsubseteq>\n                         unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s", "apply (case_tac \"h\\<cdot>s\", simp_all add: unfold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mapL\\<cdot>f\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n  unfold\\<cdot>(mapStep\\<cdot>f\\<cdot>h)\\<cdot>s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_mapS:\n  fixes f :: \"'a \\<rightarrow> 'b\" and a :: \"('a, 's) Stream\"\n  shows \"a \\<noteq> \\<bottom> \\<Longrightarrow> unstream\\<cdot>(mapS\\<cdot>f\\<cdot>a) = mapL\\<cdot>f\\<cdot>(unstream\\<cdot>a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> \\<bottom> \\<Longrightarrow>\n    unstream\\<cdot>(mapS\\<cdot>f\\<cdot>a) =\n    mapL\\<cdot>f\\<cdot>(unstream\\<cdot>a)", "by (induct a, simp, simp add: unfold_mapStep)"], ["", "lemma mapS_defined: \"a \\<noteq> \\<bottom> \\<Longrightarrow> mapS\\<cdot>f\\<cdot>a \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> \\<bottom> \\<Longrightarrow>\n    mapS\\<cdot>f\\<cdot>a \\<noteq> \\<bottom>", "by (induct a, simp_all)"], ["", "lemma mapS_cong:\n  fixes f :: \"'a \\<rightarrow> 'b\"\n  fixes a :: \"('a, 's) Stream\"\n  fixes b :: \"('a, 't) Stream\"\n  shows \"f = g \\<Longrightarrow> a \\<approx> b \\<Longrightarrow> mapS\\<cdot>f\\<cdot>a \\<approx> mapS\\<cdot>g\\<cdot>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = g; a \\<approx> b\\<rbrakk>\n    \\<Longrightarrow> mapS\\<cdot>f\\<cdot>a \\<approx> mapS\\<cdot>g\\<cdot>b", "unfolding bisimilar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = g;\n     unstream\\<cdot>a = unstream\\<cdot>b \\<and>\n     a \\<noteq> \\<bottom> \\<and> b \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> unstream\\<cdot>(mapS\\<cdot>f\\<cdot>a) =\n                      unstream\\<cdot>(mapS\\<cdot>g\\<cdot>b) \\<and>\n                      mapS\\<cdot>f\\<cdot>a \\<noteq> \\<bottom> \\<and>\n                      mapS\\<cdot>g\\<cdot>b \\<noteq> \\<bottom>", "by (simp add: unstream_mapS mapS_defined)"], ["", "lemma mapL_eq: \"mapL\\<cdot>f\\<cdot>xs = unstream\\<cdot>(mapS\\<cdot>f\\<cdot>(stream\\<cdot>xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapL\\<cdot>f\\<cdot>xs =\n    unstream\\<cdot>(mapS\\<cdot>f\\<cdot>(stream\\<cdot>xs))", "by (simp add: unstream_mapS)"], ["", "subsection \\<open>Filter function\\<close>"], ["", "fixrec\n  filterStep :: \"('a \\<rightarrow> tr) \\<rightarrow> ('s \\<rightarrow> ('a, 's) Step) \\<rightarrow> 's \\<rightarrow> ('a, 's) Step\"\nwhere\n  \"filterStep\\<cdot>p\\<cdot>h\\<cdot>\\<bottom> = \\<bottom>\"\n| \"s \\<noteq> \\<bottom> \\<Longrightarrow> filterStep\\<cdot>p\\<cdot>h\\<cdot>s = (case h\\<cdot>s of\n    Done \\<Rightarrow> Done\n  | Skip\\<cdot>s' \\<Rightarrow> Skip\\<cdot>s'\n  | Yield\\<cdot>x\\<cdot>s' \\<Rightarrow> (If p\\<cdot>x then Yield\\<cdot>x\\<cdot>s' else Skip\\<cdot>s'))\""], ["", "fixrec\n  filterS :: \"('a \\<rightarrow> tr) \\<rightarrow> ('a, 's) Stream \\<rightarrow> ('a, 's) Stream\"\nwhere\n  \"s \\<noteq> \\<bottom> \\<Longrightarrow> filterS\\<cdot>p\\<cdot>(Stream\\<cdot>h\\<cdot>s) = Stream\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s\""], ["", "lemma unfold_filterStep:\n  fixes p :: \"'a \\<rightarrow> tr\" and h :: \"'s \\<rightarrow> ('a, 's) Step\"\n  assumes \"s \\<noteq> \\<bottom>\"\n  shows \"unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s = filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s =\n    filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "proof (rule below_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s \\<sqsubseteq>\n    filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)\n 2. filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s", "show \"unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s \\<sqsubseteq> filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s \\<sqsubseteq>\n    filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "using \\<open>s \\<noteq> \\<bottom>\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s \\<sqsubseteq>\n    filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "apply (induct arbitrary: s rule: unfold_ind [where h=\"filterStep\\<cdot>p\\<cdot>h\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               x \\<noteq> \\<bottom> \\<longrightarrow>\n               a\\<cdot>x \\<sqsubseteq>\n               filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>x))\n 2. \\<And>s.\n       s \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<bottom>\\<cdot>s \\<sqsubseteq>\n       filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)\n 3. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   u\\<cdot>s \\<sqsubseteq>\n                   filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s);\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>\n                         u\\<cdot>\n                         s \\<sqsubseteq>\n                         filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "apply (simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   u\\<cdot>s \\<sqsubseteq>\n                   filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s);\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>\n                         u\\<cdot>\n                         s \\<sqsubseteq>\n                         filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "apply (case_tac \"h\\<cdot>s\", simp_all add: unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s a sa.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   u\\<cdot>s \\<sqsubseteq>\n                   filterL\\<cdot>p\\<cdot>\n                   (unfold2\\<cdot>(unfold\\<cdot>h)\\<cdot>(h\\<cdot>s));\n        s \\<noteq> \\<bottom>; h\\<cdot>s = Yield\\<cdot>a\\<cdot>sa;\n        sa \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfold2\\<cdot>u\\<cdot>\n                         (If p\\<cdot>a then Yield\\<cdot>a\\<cdot>sa\n                          else Skip\\<cdot>sa) \\<sqsubseteq>\n                         If p\\<cdot>a\n                         then LCons\\<cdot>a\\<cdot>\n                              (filterL\\<cdot>p\\<cdot>\n                               (unfold2\\<cdot>(unfold\\<cdot>h)\\<cdot>\n                                (h\\<cdot>sa)))\n                         else filterL\\<cdot>p\\<cdot>\n                              (unfold2\\<cdot>(unfold\\<cdot>h)\\<cdot>\n                               (h\\<cdot>sa))", "apply (case_tac \"p\\<cdot>a\" rule: trE, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s \\<sqsubseteq>\n  filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s)\n\ngoal (1 subgoal):\n 1. filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s", "show \"filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq> unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s", "using \\<open>s \\<noteq> \\<bottom>\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s", "apply (induct arbitrary: s rule: unfold_ind [where h=\"h\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               x \\<noteq> \\<bottom> \\<longrightarrow>\n               filterL\\<cdot>p\\<cdot>(a\\<cdot>x) \\<sqsubseteq>\n               unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>x)\n 2. \\<And>s.\n       s \\<noteq> \\<bottom> \\<Longrightarrow>\n       filterL\\<cdot>p\\<cdot>(\\<bottom>\\<cdot>s) \\<sqsubseteq>\n       unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s\n 3. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   filterL\\<cdot>p\\<cdot>(u\\<cdot>s) \\<sqsubseteq>\n                   unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s;\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> filterL\\<cdot>p\\<cdot>\n                         (unfoldF\\<cdot>h\\<cdot>u\\<cdot>s) \\<sqsubseteq>\n                         unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s", "apply (simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   filterL\\<cdot>p\\<cdot>(u\\<cdot>s) \\<sqsubseteq>\n                   unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s;\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> filterL\\<cdot>p\\<cdot>\n                         (unfoldF\\<cdot>h\\<cdot>u\\<cdot>s) \\<sqsubseteq>\n                         unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s", "apply (case_tac \"h\\<cdot>s\", simp_all add: unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s a sa.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   filterL\\<cdot>p\\<cdot>(u\\<cdot>s) \\<sqsubseteq>\n                   unfold2\\<cdot>\n                   (unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h))\\<cdot>\n                   (case h\\<cdot>s of Done \\<Rightarrow> Done\n                    | Skip\\<cdot>s' \\<Rightarrow> Skip\\<cdot>s'\n                    | Yield\\<cdot>x\\<cdot>s' \\<Rightarrow>\n                        If p\\<cdot>x then Yield\\<cdot>x\\<cdot>s'\n                        else Skip\\<cdot>s');\n        s \\<noteq> \\<bottom>; h\\<cdot>s = Yield\\<cdot>a\\<cdot>sa;\n        sa \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> If p\\<cdot>a\n                         then LCons\\<cdot>a\\<cdot>\n                              (filterL\\<cdot>p\\<cdot>(u\\<cdot>sa))\n                         else filterL\\<cdot>p\\<cdot>\n                              (u\\<cdot>sa) \\<sqsubseteq>\n                         unfold2\\<cdot>\n                         (unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h))\\<cdot>\n                         (If p\\<cdot>a then Yield\\<cdot>a\\<cdot>sa\n                          else Skip\\<cdot>sa)", "apply (case_tac \"p\\<cdot>a\" rule: trE, simp_all add: unfold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  filterL\\<cdot>p\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n  unfold\\<cdot>(filterStep\\<cdot>p\\<cdot>h)\\<cdot>s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_filterS:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> unstream\\<cdot>(filterS\\<cdot>p\\<cdot>a) = filterL\\<cdot>p\\<cdot>(unstream\\<cdot>a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> \\<bottom> \\<Longrightarrow>\n    unstream\\<cdot>(filterS\\<cdot>p\\<cdot>a) =\n    filterL\\<cdot>p\\<cdot>(unstream\\<cdot>a)", "by (induct a, simp, simp add: unfold_filterStep)"], ["", "lemma filterS_defined: \"a \\<noteq> \\<bottom> \\<Longrightarrow> filterS\\<cdot>p\\<cdot>a \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> \\<bottom> \\<Longrightarrow>\n    filterS\\<cdot>p\\<cdot>a \\<noteq> \\<bottom>", "by (induct a, simp_all)"], ["", "lemma filterS_cong:\n  fixes p :: \"'a \\<rightarrow> tr\"\n  fixes a :: \"('a, 's) Stream\"\n  fixes b :: \"('a, 't) Stream\"\n  shows \"p = q \\<Longrightarrow> a \\<approx> b \\<Longrightarrow> filterS\\<cdot>p\\<cdot>a \\<approx> filterS\\<cdot>q\\<cdot>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = q; a \\<approx> b\\<rbrakk>\n    \\<Longrightarrow> filterS\\<cdot>p\\<cdot>a \\<approx>\n                      filterS\\<cdot>q\\<cdot>b", "unfolding bisimilar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = q;\n     unstream\\<cdot>a = unstream\\<cdot>b \\<and>\n     a \\<noteq> \\<bottom> \\<and> b \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> unstream\\<cdot>(filterS\\<cdot>p\\<cdot>a) =\n                      unstream\\<cdot>(filterS\\<cdot>q\\<cdot>b) \\<and>\n                      filterS\\<cdot>p\\<cdot>a \\<noteq> \\<bottom> \\<and>\n                      filterS\\<cdot>q\\<cdot>b \\<noteq> \\<bottom>", "by (simp add: unstream_filterS filterS_defined)"], ["", "lemma filterL_eq: \"filterL\\<cdot>p\\<cdot>xs = unstream\\<cdot>(filterS\\<cdot>p\\<cdot>(stream\\<cdot>xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterL\\<cdot>p\\<cdot>xs =\n    unstream\\<cdot>(filterS\\<cdot>p\\<cdot>(stream\\<cdot>xs))", "by (simp add: unstream_filterS)"], ["", "subsection \\<open>Foldr function\\<close>"], ["", "fixrec\n  foldrS :: \"('a \\<rightarrow> 'b \\<rightarrow> 'b) \\<rightarrow> 'b \\<rightarrow> ('a, 's) Stream \\<rightarrow> 'b\"\nwhere\n  foldrS_Stream:\n  \"s \\<noteq> \\<bottom> \\<Longrightarrow> foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s) =\n    (case h\\<cdot>s of Done \\<Rightarrow> z\n               | Skip\\<cdot>s' \\<Rightarrow> foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s')\n               | Yield\\<cdot>x\\<cdot>s' \\<Rightarrow> f\\<cdot>x\\<cdot>(foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s')))\""], ["", "lemma unfold_foldrS:\n  assumes \"s \\<noteq> \\<bottom>\" shows \"foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s) = foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s) =\n    foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "proof (rule below_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s)\n 2. foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s)", "show \"foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s) \\<sqsubseteq> foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "using \\<open>s \\<noteq> \\<bottom>\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s)", "apply (induct arbitrary: s rule: foldrS.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>foldrS.\n            \\<forall>x.\n               x \\<noteq> \\<bottom> \\<longrightarrow>\n               foldrS\\<cdot>f\\<cdot>z\\<cdot>\n               (Stream\\<cdot>h\\<cdot>x) \\<sqsubseteq>\n               foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>x))\n 2. \\<And>s.\n       s \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<bottom>\\<cdot>f\\<cdot>z\\<cdot>\n       (Stream\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n       foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s)\n 3. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   x\\<cdot>f\\<cdot>z\\<cdot>\n                   (Stream\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n                   foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s);\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f z v.\n                             Fixrec.run\\<cdot>\n                             (match_Stream\\<cdot>v\\<cdot>\n                              (\\<Lambda> h s.\n                                  Fixrec.succeed\\<cdot>\n                                  (case h\\<cdot>s of Done \\<Rightarrow> z\n                                   | Skip\\<cdot>s' \\<Rightarrow>\n x\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s')\n                                   | Yield\\<cdot>xa\\<cdot>s' \\<Rightarrow>\n f\\<cdot>xa\\<cdot>\n (x\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s'))))))\\<cdot>\n                         f\\<cdot>\n                         z\\<cdot>\n                         (Stream\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n                         foldrL\\<cdot>f\\<cdot>z\\<cdot>\n                         (unfold\\<cdot>h\\<cdot>s)", "apply (simp, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   x\\<cdot>f\\<cdot>z\\<cdot>\n                   (Stream\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n                   foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s);\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (case h\\<cdot>s of Done \\<Rightarrow> z\n                          | Skip\\<cdot>s' \\<Rightarrow>\n                              x\\<cdot>f\\<cdot>z\\<cdot>\n                              (Stream\\<cdot>h\\<cdot>s')\n                          | Yield\\<cdot>xa\\<cdot>s' \\<Rightarrow>\n                              f\\<cdot>xa\\<cdot>\n                              (x\\<cdot>f\\<cdot>z\\<cdot>\n                               (Stream\\<cdot>h\\<cdot>s'))) \\<sqsubseteq>\n                         foldrL\\<cdot>f\\<cdot>z\\<cdot>\n                         (unfold\\<cdot>h\\<cdot>s)", "apply (case_tac \"h\\<cdot>s\", simp_all add: monofun_cfun unfold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n  foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s)\n\ngoal (1 subgoal):\n 1. foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s)", "show \"foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq> foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s)", "using \\<open>s \\<noteq> \\<bottom>\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s)", "apply (induct arbitrary: s rule: unfold_ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               x \\<noteq> \\<bottom> \\<longrightarrow>\n               foldrL\\<cdot>f\\<cdot>z\\<cdot>(a\\<cdot>x) \\<sqsubseteq>\n               foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>x))\n 2. \\<And>s.\n       s \\<noteq> \\<bottom> \\<Longrightarrow>\n       foldrL\\<cdot>f\\<cdot>z\\<cdot>(\\<bottom>\\<cdot>s) \\<sqsubseteq>\n       foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s)\n 3. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   foldrL\\<cdot>f\\<cdot>z\\<cdot>(u\\<cdot>s) \\<sqsubseteq>\n                   foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s);\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> foldrL\\<cdot>f\\<cdot>z\\<cdot>\n                         (unfoldF\\<cdot>h\\<cdot>u\\<cdot>s) \\<sqsubseteq>\n                         foldrS\\<cdot>f\\<cdot>z\\<cdot>\n                         (Stream\\<cdot>h\\<cdot>s)", "apply (simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s.\n       \\<lbrakk>\\<And>s.\n                   s \\<noteq> \\<bottom> \\<Longrightarrow>\n                   foldrL\\<cdot>f\\<cdot>z\\<cdot>(u\\<cdot>s) \\<sqsubseteq>\n                   foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s);\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> foldrL\\<cdot>f\\<cdot>z\\<cdot>\n                         (unfoldF\\<cdot>h\\<cdot>u\\<cdot>s) \\<sqsubseteq>\n                         foldrS\\<cdot>f\\<cdot>z\\<cdot>\n                         (Stream\\<cdot>h\\<cdot>s)", "apply (case_tac \"h\\<cdot>s\", simp_all add: monofun_cfun unfold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldrL\\<cdot>f\\<cdot>z\\<cdot>(unfold\\<cdot>h\\<cdot>s) \\<sqsubseteq>\n  foldrS\\<cdot>f\\<cdot>z\\<cdot>(Stream\\<cdot>h\\<cdot>s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_foldrS:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> foldrS\\<cdot>f\\<cdot>z\\<cdot>a = foldrL\\<cdot>f\\<cdot>z\\<cdot>(unstream\\<cdot>a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> \\<bottom> \\<Longrightarrow>\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>a =\n    foldrL\\<cdot>f\\<cdot>z\\<cdot>(unstream\\<cdot>a)", "by (induct a, simp, simp del: foldrS_Stream add: unfold_foldrS)"], ["", "lemma foldrS_cong:\n  fixes a :: \"('a, 's) Stream\"\n  fixes b :: \"('a, 't) Stream\"\n  shows \"f = g \\<Longrightarrow> z = w \\<Longrightarrow> a \\<approx> b \\<Longrightarrow> foldrS\\<cdot>f\\<cdot>z\\<cdot>a = foldrS\\<cdot>g\\<cdot>w\\<cdot>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = g; z = w; a \\<approx> b\\<rbrakk>\n    \\<Longrightarrow> foldrS\\<cdot>f\\<cdot>z\\<cdot>a =\n                      foldrS\\<cdot>g\\<cdot>w\\<cdot>b", "by (simp add: bisimilar_def unstream_foldrS)"], ["", "lemma foldrL_eq:\n  \"foldrL\\<cdot>f\\<cdot>z\\<cdot>xs = foldrS\\<cdot>f\\<cdot>z\\<cdot>(stream\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldrL\\<cdot>f\\<cdot>z\\<cdot>xs =\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>(stream\\<cdot>xs)", "by (simp add: unstream_foldrS)"], ["", "subsection \\<open>EnumFromTo function\\<close>"], ["", "type_synonym int' = \"int\\<^sub>\\<bottom>\""], ["", "fixrec\n  enumFromToStep :: \"int' \\<rightarrow> (int')\\<^sub>\\<bottom> \\<rightarrow> (int', (int')\\<^sub>\\<bottom>) Step\"\nwhere\n  \"enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>(up\\<cdot>x)) =\n    (if x \\<le> y then Yield\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>(up\\<cdot>(x+1))) else Done)\""], ["", "lemma enumFromToStep_strict [simp]:\n  \"enumFromToStep\\<cdot>\\<bottom>\\<cdot>x'' = \\<bottom>\"\n  \"enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>\\<bottom> = \\<bottom>\"\n  \"enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>\\<bottom>) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enumFromToStep\\<cdot>\\<bottom>\\<cdot>x'' = \\<bottom> &&&\n    enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>\\<bottom> = \\<bottom> &&&\n    enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>\\<bottom>) = \\<bottom>", "by fixrec_simp+"], ["", "lemma enumFromToStep_simps' [simp]:\n  \"x \\<le> y \\<Longrightarrow> enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>(up\\<cdot>x)) =\n    Yield\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>(up\\<cdot>(x+1)))\"\n  \"\\<not> x \\<le> y \\<Longrightarrow> enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>(up\\<cdot>x)) = Done\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y \\<Longrightarrow>\n     enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>(up\\<cdot>x)) =\n     Yield\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>(up\\<cdot>(x + 1)))) &&&\n    (\\<not> x \\<le> y \\<Longrightarrow>\n     enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>(up\\<cdot>(up\\<cdot>x)) = Done)", "by simp_all"], ["", "declare enumFromToStep.simps [simp del]"], ["", "fixrec\n  enumFromToS :: \"int' \\<rightarrow> int' \\<rightarrow> (int', (int')\\<^sub>\\<bottom>) Stream\"\nwhere\n  \"enumFromToS\\<cdot>x\\<cdot>y = Stream\\<cdot>(enumFromToStep\\<cdot>y)\\<cdot>(up\\<cdot>x)\""], ["", "declare enumFromToS.simps [simp del]"], ["", "lemma unfold_enumFromToStep:\n  \"unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n) = enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n) =\n    enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)", "proof (rule below_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>\n    (up\\<cdot>n) \\<sqsubseteq>\n    enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)\n 2. enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n    unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)", "show \"unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n) \\<sqsubseteq> enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>\n    (up\\<cdot>n) \\<sqsubseteq>\n    enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)", "apply (induct arbitrary: n rule: unfold_ind [where h=\"enumFromToStep\\<cdot>(up\\<cdot>y)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               a\\<cdot>(up\\<cdot>x) \\<sqsubseteq>\n               enumFromToL\\<cdot>x\\<cdot>(up\\<cdot>y))\n 2. \\<And>n.\n       \\<bottom>\\<cdot>(up\\<cdot>n) \\<sqsubseteq>\n       enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)\n 3. \\<And>u n.\n       (\\<And>n.\n           u\\<cdot>(up\\<cdot>n) \\<sqsubseteq>\n           enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)) \\<Longrightarrow>\n       unfoldF\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>u\\<cdot>\n       (up\\<cdot>n) \\<sqsubseteq>\n       enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)", "apply (simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u n.\n       (\\<And>n.\n           u\\<cdot>(up\\<cdot>n) \\<sqsubseteq>\n           enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)) \\<Longrightarrow>\n       unfoldF\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>u\\<cdot>\n       (up\\<cdot>n) \\<sqsubseteq>\n       enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)", "apply (case_tac n, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u n x.\n       \\<lbrakk>\\<And>n.\n                   u\\<cdot>(up\\<cdot>n) \\<sqsubseteq>\n                   enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y);\n        n = up\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> unfold2\\<cdot>u\\<cdot>\n                         (enumFromToStep\\<cdot>(up\\<cdot>y)\\<cdot>\n                          (up\\<cdot>(up\\<cdot>x))) \\<sqsubseteq>\n                         enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>y)", "apply (case_tac \"x \\<le> y\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>\n  (up\\<cdot>n) \\<sqsubseteq>\n  enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y)\n\ngoal (1 subgoal):\n 1. enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n    unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n    unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)", "show \"enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq> unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n    unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)", "apply (induct arbitrary: n rule: enumFromToL.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>enumFromToL.\n            \\<forall>x.\n               enumFromToL\\<cdot>x\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n               unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>\n               (up\\<cdot>x))\n 2. \\<And>n.\n       \\<bottom>\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n       unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)\n 3. \\<And>x n.\n       (\\<And>n.\n           x\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n           unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>\n           (up\\<cdot>n)) \\<Longrightarrow>\n       (\\<Lambda> va v.\n           Fixrec.run\\<cdot>\n           (match_up\\<cdot>va\\<cdot>\n            (\\<Lambda> xa.\n                match_up\\<cdot>v\\<cdot>\n                (\\<Lambda> y.\n                    Fixrec.succeed\\<cdot>\n                    (if xa \\<le> y\n                     then LCons\\<cdot>(up\\<cdot>xa)\\<cdot>\n                          (x\\<cdot>(up\\<cdot>(xa + 1))\\<cdot>(up\\<cdot>y))\n                     else LNil)))))\\<cdot>\n       n\\<cdot>\n       (up\\<cdot>y) \\<sqsubseteq>\n       unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)", "apply (simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       (\\<And>n.\n           x\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n           unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>\n           (up\\<cdot>n)) \\<Longrightarrow>\n       (\\<Lambda> va v.\n           Fixrec.run\\<cdot>\n           (match_up\\<cdot>va\\<cdot>\n            (\\<Lambda> xa.\n                match_up\\<cdot>v\\<cdot>\n                (\\<Lambda> y.\n                    Fixrec.succeed\\<cdot>\n                    (if xa \\<le> y\n                     then LCons\\<cdot>(up\\<cdot>xa)\\<cdot>\n                          (x\\<cdot>(up\\<cdot>(xa + 1))\\<cdot>(up\\<cdot>y))\n                     else LNil)))))\\<cdot>\n       n\\<cdot>\n       (up\\<cdot>y) \\<sqsubseteq>\n       unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)", "apply (rename_tac e n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e n.\n       (\\<And>n.\n           e\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n           unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>\n           (up\\<cdot>n)) \\<Longrightarrow>\n       (\\<Lambda> va v.\n           Fixrec.run\\<cdot>\n           (match_up\\<cdot>va\\<cdot>\n            (\\<Lambda> x.\n                match_up\\<cdot>v\\<cdot>\n                (\\<Lambda> y.\n                    Fixrec.succeed\\<cdot>\n                    (if x \\<le> y\n                     then LCons\\<cdot>(up\\<cdot>x)\\<cdot>\n                          (e\\<cdot>(up\\<cdot>(x + 1))\\<cdot>(up\\<cdot>y))\n                     else LNil)))))\\<cdot>\n       n\\<cdot>\n       (up\\<cdot>y) \\<sqsubseteq>\n       unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)", "apply (case_tac n, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e n x.\n       \\<lbrakk>\\<And>n.\n                   e\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n                   unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>\n                   (up\\<cdot>n);\n        n = up\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> va v.\n                             Fixrec.run\\<cdot>\n                             (match_up\\<cdot>va\\<cdot>\n                              (\\<Lambda> x.\n                                  match_up\\<cdot>v\\<cdot>\n                                  (\\<Lambda> y.\nFixrec.succeed\\<cdot>\n(if x \\<le> y\n then LCons\\<cdot>(up\\<cdot>x)\\<cdot>\n      (e\\<cdot>(up\\<cdot>(x + 1))\\<cdot>(up\\<cdot>y))\n else LNil)))))\\<cdot>\n                         n\\<cdot>\n                         (up\\<cdot>y) \\<sqsubseteq>\n                         unfold\\<cdot>\n                         (enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>\n                         (up\\<cdot>n)", "apply (case_tac \"x \\<le> y\", simp_all add: unfold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  enumFromToL\\<cdot>n\\<cdot>(up\\<cdot>y) \\<sqsubseteq>\n  unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>y))\\<cdot>(up\\<cdot>n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_enumFromToS:\n  \"unstream\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y) = enumFromToL\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y) =\n    enumFromToL\\<cdot>x\\<cdot>y", "apply (simp add: enumFromToS.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold\\<cdot>(enumFromToStep\\<cdot>y)\\<cdot>(up\\<cdot>x) =\n    enumFromToL\\<cdot>x\\<cdot>y", "apply (induct y, simp add: unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>xa))\\<cdot>\n       (up\\<cdot>x) =\n       enumFromToL\\<cdot>x\\<cdot>(up\\<cdot>xa)", "apply (induct x, simp add: unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       unfold\\<cdot>(enumFromToStep\\<cdot>(up\\<cdot>xa))\\<cdot>\n       (up\\<cdot>(up\\<cdot>x)) =\n       enumFromToL\\<cdot>(up\\<cdot>x)\\<cdot>(up\\<cdot>xa)", "apply (simp add: unfold_enumFromToStep)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma enumFromToS_defined: \"enumFromToS\\<cdot>x\\<cdot>y \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enumFromToS\\<cdot>x\\<cdot>y \\<noteq> \\<bottom>", "by (simp add: enumFromToS.simps)"], ["", "lemma enumFromToS_cong:\n  \"x = x' \\<Longrightarrow> y = y' \\<Longrightarrow> enumFromToS\\<cdot>x\\<cdot>y \\<approx> enumFromToS\\<cdot>x'\\<cdot>y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = x'; y = y'\\<rbrakk>\n    \\<Longrightarrow> enumFromToS\\<cdot>x\\<cdot>y \\<approx>\n                      enumFromToS\\<cdot>x'\\<cdot>y'", "unfolding bisimilar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = x'; y = y'\\<rbrakk>\n    \\<Longrightarrow> unstream\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y) =\n                      unstream\\<cdot>(enumFromToS\\<cdot>x'\\<cdot>y') \\<and>\n                      enumFromToS\\<cdot>x\\<cdot>y \\<noteq> \\<bottom> \\<and>\n                      enumFromToS\\<cdot>x'\\<cdot>y' \\<noteq> \\<bottom>", "by (simp add: enumFromToS_defined)"], ["", "lemma enumFromToL_eq: \"enumFromToL\\<cdot>x\\<cdot>y = unstream\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enumFromToL\\<cdot>x\\<cdot>y =\n    unstream\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y)", "by (simp add: unstream_enumFromToS)"], ["", "subsection \\<open>Append function\\<close>"], ["", "fixrec\n  appendStep ::\n    \"('s \\<rightarrow> ('a, 's) Step) \\<rightarrow>\n     ('t \\<rightarrow> ('a, 't) Step) \\<rightarrow>\n     't \\<rightarrow> ('s, 't) Either \\<rightarrow> ('a, ('s, 't) Either) Step\"\nwhere\n  \"sa \\<noteq> \\<bottom> \\<Longrightarrow> appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0\\<cdot>(Left\\<cdot>sa) =\n    (case ha\\<cdot>sa of\n      Done \\<Rightarrow> Skip\\<cdot>(Right\\<cdot>sb0)\n    | Skip\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(Left\\<cdot>sa')\n    | Yield\\<cdot>x\\<cdot>sa' \\<Rightarrow> Yield\\<cdot>x\\<cdot>(Left\\<cdot>sa'))\"\n| \"sb \\<noteq> \\<bottom> \\<Longrightarrow> appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0\\<cdot>(Right\\<cdot>sb) =\n    (case hb\\<cdot>sb of\n      Done \\<Rightarrow> Done\n    | Skip\\<cdot>sb' \\<Rightarrow> Skip\\<cdot>(Right\\<cdot>sb')\n    | Yield\\<cdot>x\\<cdot>sb' \\<Rightarrow> Yield\\<cdot>x\\<cdot>(Right\\<cdot>sb'))\""], ["", "lemma appendStep_strict [simp]: \"appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec\n  appendS ::\n    \"('a, 's) Stream \\<rightarrow> ('a, 't) Stream \\<rightarrow> ('a, ('s, 't) Either) Stream\"\nwhere\n  \"sa0 \\<noteq> \\<bottom> \\<Longrightarrow> sb0 \\<noteq> \\<bottom> \\<Longrightarrow>\n    appendS\\<cdot>(Stream\\<cdot>ha\\<cdot>sa0)\\<cdot>(Stream\\<cdot>hb\\<cdot>sb0) =\n      Stream\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>(Left\\<cdot>sa0)\""], ["", "lemma unfold_appendStep:\n  fixes ha :: \"'s \\<rightarrow> ('a, 's) Step\"\n  fixes hb :: \"'t \\<rightarrow> ('a, 't) Step\"\n  assumes sb0 [simp]: \"sb0 \\<noteq> \\<bottom>\"\n  shows\n  \"(\\<forall>sa. sa \\<noteq> \\<bottom> \\<longrightarrow> unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>(Left\\<cdot>sa) =\n         appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>(unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n   (\\<forall>sb. sb \\<noteq> \\<bottom> \\<longrightarrow> unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>(Right\\<cdot>sb) =\n         unfold\\<cdot>hb\\<cdot>sb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "note unfold [simp]"], ["proof (state)\nthis:\n  ?s \\<noteq> \\<bottom> \\<Longrightarrow>\n  unfold\\<cdot>?h\\<cdot>?s =\n  unfold2\\<cdot>(unfold\\<cdot>?h)\\<cdot>(?h\\<cdot>?s)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "let ?h = \"appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "have 1:\n  \"(\\<forall>sa. sa \\<noteq> \\<bottom> \\<longrightarrow>\n         unfold\\<cdot>?h\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n         appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>(unfold\\<cdot>hb\\<cdot>sb0))\n   \\<and>\n   (\\<forall>sb. sb \\<noteq> \\<bottom> \\<longrightarrow> unfold\\<cdot>?h\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq> unfold\\<cdot>hb\\<cdot>sb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) \\<sqsubseteq>\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) \\<sqsubseteq>\n        unfold\\<cdot>hb\\<cdot>sb)", "apply (rule unfold_ind [where h=\"?h\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            (\\<forall>sa.\n                sa \\<noteq> \\<bottom> \\<longrightarrow>\n                a\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n                appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n                (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n            (\\<forall>sb.\n                sb \\<noteq> \\<bottom> \\<longrightarrow>\n                a\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq>\n                unfold\\<cdot>hb\\<cdot>sb))\n 2. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        \\<bottom>\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        \\<bottom>\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq>\n        unfold\\<cdot>hb\\<cdot>sb)\n 3. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n       (\\<forall>sb.\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>hb\\<cdot>sb) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n           u\\<cdot>\n           (Left\\<cdot>sa) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n       (\\<forall>sb.\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n           u\\<cdot>\n           (Right\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>hb\\<cdot>sb)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        \\<bottom>\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        \\<bottom>\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq>\n        unfold\\<cdot>hb\\<cdot>sb)\n 2. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n       (\\<forall>sb.\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>hb\\<cdot>sb) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n           u\\<cdot>\n           (Left\\<cdot>sa) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n       (\\<forall>sb.\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n           u\\<cdot>\n           (Right\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>hb\\<cdot>sb)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n       (\\<forall>sb.\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>hb\\<cdot>sb) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n           u\\<cdot>\n           (Left\\<cdot>sa) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n       (\\<forall>sb.\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n           u\\<cdot>\n           (Right\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>hb\\<cdot>sb)", "apply (intro conjI allI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u sa.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n                    (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n                (\\<forall>sb.\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq>\n                    unfold\\<cdot>hb\\<cdot>sb);\n        sa \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>\n                         (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                         u\\<cdot>\n                         (Left\\<cdot>sa) \\<sqsubseteq>\n                         appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n                         (unfold\\<cdot>hb\\<cdot>sb0)\n 2. \\<And>u sb.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n                    (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n                (\\<forall>sb.\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq>\n                    unfold\\<cdot>hb\\<cdot>sb);\n        sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>\n                         (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                         u\\<cdot>\n                         (Right\\<cdot>sb) \\<sqsubseteq>\n                         unfold\\<cdot>hb\\<cdot>sb", "apply (case_tac \"ha\\<cdot>sa\", simp, simp, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u sb.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(Left\\<cdot>sa) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n                    (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n                (\\<forall>sb.\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(Right\\<cdot>sb) \\<sqsubseteq>\n                    unfold\\<cdot>hb\\<cdot>sb);\n        sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>\n                         (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                         u\\<cdot>\n                         (Right\\<cdot>sb) \\<sqsubseteq>\n                         unfold\\<cdot>hb\\<cdot>sb", "apply (case_tac \"hb\\<cdot>sb\", simp, simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Left\\<cdot>sa) \\<sqsubseteq>\n      appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n  (\\<forall>sb.\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Right\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>hb\\<cdot>sb)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "let ?P = \"\\<lambda>ua ub. \\<forall>sa. sa \\<noteq> \\<bottom> \\<longrightarrow>\n        appendL\\<cdot>(ua\\<cdot>sa)\\<cdot>(ub\\<cdot>sb0) \\<sqsubseteq> unfold\\<cdot>?h\\<cdot>(Left\\<cdot>sa)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "let ?Q = \"\\<lambda>ub. \\<forall>sb. sb \\<noteq> \\<bottom> \\<longrightarrow> ub\\<cdot>sb \\<sqsubseteq> unfold\\<cdot>?h\\<cdot>(Right\\<cdot>sb)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "have P_base: \"\\<And>ub. ?P \\<bottom> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ub.\n       \\<forall>sa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(\\<bottom>\\<cdot>sa)\\<cdot>\n          (ub\\<cdot>sb0) \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Left\\<cdot>sa)", "by simp"], ["proof (state)\nthis:\n  \\<forall>sa.\n     sa \\<noteq> \\<bottom> \\<longrightarrow>\n     appendL\\<cdot>(\\<bottom>\\<cdot>sa)\\<cdot>(?ub\\<cdot>sb0) \\<sqsubseteq>\n     unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n     (Left\\<cdot>sa)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "have Q_base: \"?Q \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sb.\n       sb \\<noteq> \\<bottom> \\<longrightarrow>\n       \\<bottom>\\<cdot>sb \\<sqsubseteq>\n       unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n       (Right\\<cdot>sb)", "by simp"], ["proof (state)\nthis:\n  \\<forall>sb.\n     sb \\<noteq> \\<bottom> \\<longrightarrow>\n     \\<bottom>\\<cdot>sb \\<sqsubseteq>\n     unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n     (Right\\<cdot>sb)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "have P_step: \"\\<And>ua ub. ?P ua ub \\<Longrightarrow> ?Q ub \\<Longrightarrow> ?P (unfoldF\\<cdot>ha\\<cdot>ua) ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua ub.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   appendL\\<cdot>(ua\\<cdot>sa)\\<cdot>\n                   (ub\\<cdot>sb0) \\<sqsubseteq>\n                   unfold\\<cdot>\n                   (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                   (Left\\<cdot>sa);\n        \\<forall>sb.\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           ub\\<cdot>sb \\<sqsubseteq>\n           unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n           (Right\\<cdot>sb)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            appendL\\<cdot>\n                            (unfoldF\\<cdot>ha\\<cdot>ua\\<cdot>sa)\\<cdot>\n                            (ub\\<cdot>sb0) \\<sqsubseteq>\n                            unfold\\<cdot>\n                            (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                            (Left\\<cdot>sa)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua ub sa.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   appendL\\<cdot>(ua\\<cdot>sa)\\<cdot>\n                   (ub\\<cdot>sb0) \\<sqsubseteq>\n                   unfold\\<cdot>\n                   (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                   (Left\\<cdot>sa);\n        \\<forall>sb.\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           ub\\<cdot>sb \\<sqsubseteq>\n           unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n           (Right\\<cdot>sb);\n        sa \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> appendL\\<cdot>\n                         (unfoldF\\<cdot>ha\\<cdot>ua\\<cdot>sa)\\<cdot>\n                         (ub\\<cdot>sb0) \\<sqsubseteq>\n                         unfold\\<cdot>\n                         (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                         (Left\\<cdot>sa)", "apply (case_tac \"ha\\<cdot>sa\", simp, simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>sa.\n              sa \\<noteq> \\<bottom> \\<longrightarrow>\n              appendL\\<cdot>(?ua\\<cdot>sa)\\<cdot>\n              (?ub\\<cdot>sb0) \\<sqsubseteq>\n              unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n              (Left\\<cdot>sa);\n   \\<forall>sb.\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      ?ub\\<cdot>sb \\<sqsubseteq>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Right\\<cdot>sb)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>sa.\n                       sa \\<noteq> \\<bottom> \\<longrightarrow>\n                       appendL\\<cdot>\n                       (unfoldF\\<cdot>ha\\<cdot>?ua\\<cdot>sa)\\<cdot>\n                       (?ub\\<cdot>sb0) \\<sqsubseteq>\n                       unfold\\<cdot>\n                       (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                       (Left\\<cdot>sa)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "have Q_step: \"\\<And>ua ub. ?Q ub \\<Longrightarrow> ?Q (unfoldF\\<cdot>hb\\<cdot>ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua ub.\n       \\<forall>sb.\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          ub\\<cdot>sb \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Right\\<cdot>sb) \\<Longrightarrow>\n       \\<forall>sb.\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          unfoldF\\<cdot>hb\\<cdot>ub\\<cdot>sb \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Right\\<cdot>sb)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua ub sb.\n       \\<lbrakk>\\<forall>sb.\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   ub\\<cdot>sb \\<sqsubseteq>\n                   unfold\\<cdot>\n                   (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                   (Right\\<cdot>sb);\n        sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>hb\\<cdot>ub\\<cdot>sb \\<sqsubseteq>\n                         unfold\\<cdot>\n                         (appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n                         (Right\\<cdot>sb)", "apply (case_tac \"hb\\<cdot>sb\", simp, simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>sb.\n     sb \\<noteq> \\<bottom> \\<longrightarrow>\n     ?ub\\<cdot>sb \\<sqsubseteq>\n     unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n     (Right\\<cdot>sb) \\<Longrightarrow>\n  \\<forall>sb.\n     sb \\<noteq> \\<bottom> \\<longrightarrow>\n     unfoldF\\<cdot>hb\\<cdot>?ub\\<cdot>sb \\<sqsubseteq>\n     unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n     (Right\\<cdot>sb)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "have Q: \"?Q (unfold\\<cdot>hb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sb.\n       sb \\<noteq> \\<bottom> \\<longrightarrow>\n       unfold\\<cdot>hb\\<cdot>sb \\<sqsubseteq>\n       unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n       (Right\\<cdot>sb)", "apply (rule unfold_ind [where h=\"hb\"], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>sb.\n       sb \\<noteq> \\<bottom> \\<longrightarrow>\n       \\<bottom>\\<cdot>sb \\<sqsubseteq>\n       unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n       (Right\\<cdot>sb)\n 2. \\<And>u.\n       \\<forall>sb.\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          u\\<cdot>sb \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Right\\<cdot>sb) \\<Longrightarrow>\n       \\<forall>sb.\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          unfoldF\\<cdot>hb\\<cdot>u\\<cdot>sb \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Right\\<cdot>sb)", "apply (rule Q_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<forall>sb.\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          u\\<cdot>sb \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Right\\<cdot>sb) \\<Longrightarrow>\n       \\<forall>sb.\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          unfoldF\\<cdot>hb\\<cdot>u\\<cdot>sb \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Right\\<cdot>sb)", "apply (erule Q_step)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>sb.\n     sb \\<noteq> \\<bottom> \\<longrightarrow>\n     unfold\\<cdot>hb\\<cdot>sb \\<sqsubseteq>\n     unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n     (Right\\<cdot>sb)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "have P: \"?P (unfold\\<cdot>ha) (unfold\\<cdot>hb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sa.\n       sa \\<noteq> \\<bottom> \\<longrightarrow>\n       appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n       (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n       unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n       (Left\\<cdot>sa)", "apply (rule unfold_ind [where h=\"ha\"], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>sa.\n       sa \\<noteq> \\<bottom> \\<longrightarrow>\n       appendL\\<cdot>(\\<bottom>\\<cdot>sa)\\<cdot>\n       (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n       unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n       (Left\\<cdot>sa)\n 2. \\<And>u.\n       \\<forall>sa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(u\\<cdot>sa)\\<cdot>\n          (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Left\\<cdot>sa) \\<Longrightarrow>\n       \\<forall>sa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)\\<cdot>\n          (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Left\\<cdot>sa)", "apply (rule P_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<forall>sa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(u\\<cdot>sa)\\<cdot>\n          (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Left\\<cdot>sa) \\<Longrightarrow>\n       \\<forall>sa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)\\<cdot>\n          (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Left\\<cdot>sa)", "apply (erule P_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<forall>sb.\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          unfold\\<cdot>hb\\<cdot>sb \\<sqsubseteq>\n          unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n          (Right\\<cdot>sb)", "apply (rule Q)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>sa.\n     sa \\<noteq> \\<bottom> \\<longrightarrow>\n     appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n     (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n     unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n     (Left\\<cdot>sa)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "have 2: \"?P (unfold\\<cdot>ha) (unfold\\<cdot>hb) \\<and> ?Q (unfold\\<cdot>hb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>hb\\<cdot>sb \\<sqsubseteq>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb))", "using P Q"], ["proof (prove)\nusing this:\n  \\<forall>sa.\n     sa \\<noteq> \\<bottom> \\<longrightarrow>\n     appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n     (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n     unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n     (Left\\<cdot>sa)\n  \\<forall>sb.\n     sb \\<noteq> \\<bottom> \\<longrightarrow>\n     unfold\\<cdot>hb\\<cdot>sb \\<sqsubseteq>\n     unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n     (Right\\<cdot>sb)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>hb\\<cdot>sb \\<sqsubseteq>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb))", "by (rule conjI)"], ["proof (state)\nthis:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Left\\<cdot>sa)) \\<and>\n  (\\<forall>sb.\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>hb\\<cdot>sb \\<sqsubseteq>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Right\\<cdot>sb))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "from 1 2"], ["proof (chain)\npicking this:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Left\\<cdot>sa) \\<sqsubseteq>\n      appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n  (\\<forall>sb.\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Right\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>hb\\<cdot>sb)\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Left\\<cdot>sa)) \\<and>\n  (\\<forall>sb.\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>hb\\<cdot>sb \\<sqsubseteq>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Right\\<cdot>sb))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Left\\<cdot>sa) \\<sqsubseteq>\n      appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n  (\\<forall>sb.\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Right\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>hb\\<cdot>sb)\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb0) \\<sqsubseteq>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Left\\<cdot>sa)) \\<and>\n  (\\<forall>sb.\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>hb\\<cdot>sb \\<sqsubseteq>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Right\\<cdot>sb))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Left\\<cdot>sa) =\n        appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n    (\\<forall>sb.\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n        (Right\\<cdot>sb) =\n        unfold\\<cdot>hb\\<cdot>sb)", "by (simp add: po_eq_conv [where 'a=\"'a LList\"])"], ["proof (state)\nthis:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Left\\<cdot>sa) =\n      appendL\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb0)) \\<and>\n  (\\<forall>sb.\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>(appendStep\\<cdot>ha\\<cdot>hb\\<cdot>sb0)\\<cdot>\n      (Right\\<cdot>sb) =\n      unfold\\<cdot>hb\\<cdot>sb)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma appendS_defined: \"xs \\<noteq> \\<bottom> \\<Longrightarrow> ys \\<noteq> \\<bottom> \\<Longrightarrow> appendS\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> appendS\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>", "by (cases xs, simp, cases ys, simp, simp)"], ["", "lemma unstream_appendS:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> b \\<noteq> \\<bottom> \\<Longrightarrow>\n    unstream\\<cdot>(appendS\\<cdot>a\\<cdot>b) = appendL\\<cdot>(unstream\\<cdot>a)\\<cdot>(unstream\\<cdot>b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> \\<bottom>; b \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> unstream\\<cdot>(appendS\\<cdot>a\\<cdot>b) =\n                      appendL\\<cdot>(unstream\\<cdot>a)\\<cdot>\n                      (unstream\\<cdot>b)", "apply (cases a, simp, cases b, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cfun s cfuna sa.\n       \\<lbrakk>a \\<noteq> \\<bottom>; b \\<noteq> \\<bottom>;\n        a = Stream\\<cdot>cfun\\<cdot>s; s \\<noteq> \\<bottom>;\n        b = Stream\\<cdot>cfuna\\<cdot>sa; sa \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unstream\\<cdot>(appendS\\<cdot>a\\<cdot>b) =\n                         appendL\\<cdot>(unstream\\<cdot>a)\\<cdot>\n                         (unstream\\<cdot>b)", "apply (simp add: unfold_appendStep)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma appendS_cong:\n  fixes f :: \"'a \\<rightarrow> 'b\"\n  fixes a :: \"('a, 's) Stream\"\n  fixes b :: \"('a, 't) Stream\"\n  shows \"a \\<approx> a' \\<Longrightarrow> b \\<approx> b' \\<Longrightarrow> appendS\\<cdot>a\\<cdot>b \\<approx> appendS\\<cdot>a'\\<cdot>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<approx> a'; b \\<approx> b'\\<rbrakk>\n    \\<Longrightarrow> appendS\\<cdot>a\\<cdot>b \\<approx>\n                      appendS\\<cdot>a'\\<cdot>b'", "unfolding bisimilar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unstream\\<cdot>a = unstream\\<cdot>a' \\<and>\n             a \\<noteq> \\<bottom> \\<and> a' \\<noteq> \\<bottom>;\n     unstream\\<cdot>b = unstream\\<cdot>b' \\<and>\n     b \\<noteq> \\<bottom> \\<and> b' \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> unstream\\<cdot>(appendS\\<cdot>a\\<cdot>b) =\n                      unstream\\<cdot>(appendS\\<cdot>a'\\<cdot>b') \\<and>\n                      appendS\\<cdot>a\\<cdot>b \\<noteq> \\<bottom> \\<and>\n                      appendS\\<cdot>a'\\<cdot>b' \\<noteq> \\<bottom>", "by (simp add: unstream_appendS appendS_defined)"], ["", "lemma appendL_eq: \"appendL\\<cdot>xs\\<cdot>ys = unstream\\<cdot>(appendS\\<cdot>(stream\\<cdot>xs)\\<cdot>(stream\\<cdot>ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. appendL\\<cdot>xs\\<cdot>ys =\n    unstream\\<cdot>(appendS\\<cdot>(stream\\<cdot>xs)\\<cdot>(stream\\<cdot>ys))", "by (simp add: unstream_appendS)"], ["", "subsection \\<open>ZipWith function\\<close>"], ["", "fixrec\n  zipWithStep ::\n    \"('a \\<rightarrow> 'b \\<rightarrow> 'c) \\<rightarrow>\n     ('s \\<rightarrow> ('a, 's) Step) \\<rightarrow>\n     ('t \\<rightarrow> ('b, 't) Step) \\<rightarrow>\n      's :!: 't :!: 'a L Maybe \\<rightarrow> ('c, 's :!: 't :!: 'a L Maybe) Step\"\nwhere\n  \"sa \\<noteq> \\<bottom> \\<Longrightarrow> sb \\<noteq> \\<bottom> \\<Longrightarrow>\n   zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\\<cdot>(sa :!: sb :!: Nothing) =\n   (case ha\\<cdot>sa of\n     Done \\<Rightarrow> Done\n   | Skip\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: sb :!: Nothing)\n   | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: sb :!: Just\\<cdot>(L\\<cdot>a)))\"\n| \"sa \\<noteq> \\<bottom> \\<Longrightarrow> sb \\<noteq> \\<bottom> \\<Longrightarrow>\n   zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n   (case hb\\<cdot>sb of\n     Done \\<Rightarrow> Done\n   | Skip\\<cdot>sb' \\<Rightarrow> Skip\\<cdot>(sa :!: sb' :!: Just\\<cdot>(L\\<cdot>a))\n   | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow> Yield\\<cdot>(f\\<cdot>a\\<cdot>b)\\<cdot>(sa :!: sb' :!: Nothing))\""], ["", "lemma zipWithStep_strict [simp]: \"zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec\n  zipWithS :: \"('a \\<rightarrow> 'b \\<rightarrow> 'c) \\<rightarrow>\n      ('a, 's) Stream \\<rightarrow> ('b, 't) Stream \\<rightarrow> ('c, 's :!: 't :!: 'a L Maybe) Stream\"\nwhere\n  \"sa0 \\<noteq> \\<bottom> \\<Longrightarrow> sb0 \\<noteq> \\<bottom> \\<Longrightarrow> zipWithS\\<cdot>f\\<cdot>(Stream\\<cdot>ha\\<cdot>sa0)\\<cdot>(Stream\\<cdot>hb\\<cdot>sb0) =\n    Stream\\<cdot>(zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb)\\<cdot>(sa0 :!: sb0 :!: Nothing)\""], ["", "lemma zipWithS_fix_ind_lemma:\n  fixes P Q :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\"\n  assumes P_0: \"\\<And>j. P 0 j\" and P_Suc: \"\\<And>i j. P i j \\<Longrightarrow> Q i j \\<Longrightarrow> P (Suc i) j\"\n  assumes Q_0: \"\\<And>i. Q i 0\" and Q_Suc: \"\\<And>i j. P i j \\<Longrightarrow> Q i j \\<Longrightarrow> Q i (Suc j)\"\n  shows \"P i j \\<and> Q i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P i j \\<and> Q i j", "apply (induct n \\<equiv> \"i + j\" arbitrary: i j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j. 0 = i + j \\<Longrightarrow> P i j \\<and> Q i j\n 2. \\<And>n i j.\n       \\<lbrakk>\\<And>i j. n = i + j \\<Longrightarrow> P i j \\<and> Q i j;\n        Suc n = i + j\\<rbrakk>\n       \\<Longrightarrow> P i j \\<and> Q i j", "apply (simp add: P_0 Q_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j. n = i + j \\<Longrightarrow> P i j \\<and> Q i j;\n        Suc n = i + j\\<rbrakk>\n       \\<Longrightarrow> P i j \\<and> Q i j", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j. n = i + j \\<Longrightarrow> P i j \\<and> Q i j;\n        Suc n = i + j\\<rbrakk>\n       \\<Longrightarrow> P i j\n 2. \\<And>n i j.\n       \\<lbrakk>\\<And>i j. n = i + j \\<Longrightarrow> P i j \\<and> Q i j;\n        Suc n = i + j\\<rbrakk>\n       \\<Longrightarrow> Q i j", "apply (case_tac i, simp add: P_0, simp add: P_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j. n = i + j \\<Longrightarrow> P i j \\<and> Q i j;\n        Suc n = i + j\\<rbrakk>\n       \\<Longrightarrow> Q i j", "apply (case_tac j, simp add: Q_0, simp add: Q_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zipWithS_fix_ind:\n  assumes x: \"x = fix\\<cdot>f\" and y: \"y = fix\\<cdot>g\"\n  assumes adm_P: \"adm (\\<lambda>x. P (fst x) (snd x))\"\n  assumes adm_Q: \"adm (\\<lambda>x. Q (fst x) (snd x))\"\n  assumes P_0: \"\\<And>b. P \\<bottom> b\" and P_Suc: \"\\<And>a b. P a b \\<Longrightarrow> Q a b \\<Longrightarrow> P (f\\<cdot>a) b\"\n  assumes Q_0: \"\\<And>a. Q a \\<bottom>\" and Q_Suc: \"\\<And>a b. P a b \\<Longrightarrow> Q a b \\<Longrightarrow> Q a (g\\<cdot>b)\"\n  shows \"P x y \\<and> Q x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y \\<and> Q x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P x y \\<and> Q x y", "have 1: \"\\<And>i j. P (iterate i\\<cdot>f\\<cdot>\\<bottom>) (iterate j\\<cdot>g\\<cdot>\\<bottom>) \\<and> Q (iterate i\\<cdot>f\\<cdot>\\<bottom>) (iterate j\\<cdot>g\\<cdot>\\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       P (iterate i\\<cdot>f\\<cdot>\\<bottom>)\n        (iterate j\\<cdot>g\\<cdot>\\<bottom>) \\<and>\n       Q (iterate i\\<cdot>f\\<cdot>\\<bottom>)\n        (iterate j\\<cdot>g\\<cdot>\\<bottom>)", "apply (rule_tac i=i and j=j in zipWithS_fix_ind_lemma)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i j ja.\n       P (iterate 0\\<cdot>f\\<cdot>\\<bottom>)\n        (iterate ja\\<cdot>g\\<cdot>\\<bottom>)\n 2. \\<And>i j ia ja.\n       \\<lbrakk>P (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                 (iterate ja\\<cdot>g\\<cdot>\\<bottom>);\n        Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n         (iterate ja\\<cdot>g\\<cdot>\\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> P (iterate (Suc ia)\\<cdot>f\\<cdot>\\<bottom>)\n                          (iterate ja\\<cdot>g\\<cdot>\\<bottom>)\n 3. \\<And>i j ia.\n       Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n        (iterate 0\\<cdot>g\\<cdot>\\<bottom>)\n 4. \\<And>i j ia ja.\n       \\<lbrakk>P (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                 (iterate ja\\<cdot>g\\<cdot>\\<bottom>);\n        Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n         (iterate ja\\<cdot>g\\<cdot>\\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                          (iterate (Suc ja)\\<cdot>g\\<cdot>\\<bottom>)", "apply (simp add: P_0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j ia ja.\n       \\<lbrakk>P (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                 (iterate ja\\<cdot>g\\<cdot>\\<bottom>);\n        Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n         (iterate ja\\<cdot>g\\<cdot>\\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> P (iterate (Suc ia)\\<cdot>f\\<cdot>\\<bottom>)\n                          (iterate ja\\<cdot>g\\<cdot>\\<bottom>)\n 2. \\<And>i j ia.\n       Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n        (iterate 0\\<cdot>g\\<cdot>\\<bottom>)\n 3. \\<And>i j ia ja.\n       \\<lbrakk>P (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                 (iterate ja\\<cdot>g\\<cdot>\\<bottom>);\n        Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n         (iterate ja\\<cdot>g\\<cdot>\\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                          (iterate (Suc ja)\\<cdot>g\\<cdot>\\<bottom>)", "apply (simp add: P_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j ia.\n       Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n        (iterate 0\\<cdot>g\\<cdot>\\<bottom>)\n 2. \\<And>i j ia ja.\n       \\<lbrakk>P (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                 (iterate ja\\<cdot>g\\<cdot>\\<bottom>);\n        Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n         (iterate ja\\<cdot>g\\<cdot>\\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                          (iterate (Suc ja)\\<cdot>g\\<cdot>\\<bottom>)", "apply (simp add: Q_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j ia ja.\n       \\<lbrakk>P (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                 (iterate ja\\<cdot>g\\<cdot>\\<bottom>);\n        Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n         (iterate ja\\<cdot>g\\<cdot>\\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> Q (iterate ia\\<cdot>f\\<cdot>\\<bottom>)\n                          (iterate (Suc ja)\\<cdot>g\\<cdot>\\<bottom>)", "apply (simp add: Q_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (iterate ?i\\<cdot>f\\<cdot>\\<bottom>)\n   (iterate ?j\\<cdot>g\\<cdot>\\<bottom>) \\<and>\n  Q (iterate ?i\\<cdot>f\\<cdot>\\<bottom>)\n   (iterate ?j\\<cdot>g\\<cdot>\\<bottom>)\n\ngoal (1 subgoal):\n 1. P x y \\<and> Q x y", "have \"case_prod P (\\<Squnion>i. (iterate i\\<cdot>f\\<cdot>\\<bottom>, iterate i\\<cdot>g\\<cdot>\\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case \\<Squnion>i.\n            (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n             iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n    (x, xa) \\<Rightarrow> P x xa", "apply (rule admD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. case a of (a, b) \\<Rightarrow> P a b)\n 2. chain\n     (\\<lambda>i.\n         (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n          iterate i\\<cdot>g\\<cdot>\\<bottom>))\n 3. \\<And>i.\n       case (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n             iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n       (a, b) \\<Rightarrow> P a b", "apply (simp add: split_def adm_P)"], ["proof (prove)\ngoal (2 subgoals):\n 1. chain\n     (\\<lambda>i.\n         (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n          iterate i\\<cdot>g\\<cdot>\\<bottom>))\n 2. \\<And>i.\n       case (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n             iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n       (a, b) \\<Rightarrow> P a b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       case (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n             iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n       (a, b) \\<Rightarrow> P a b", "apply (simp add: 1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case \\<Squnion>i.\n          (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n           iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n  (x, xa) \\<Rightarrow> P x xa\n\ngoal (1 subgoal):\n 1. P x y \\<and> Q x y", "then"], ["proof (chain)\npicking this:\n  case \\<Squnion>i.\n          (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n           iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n  (x, xa) \\<Rightarrow> P x xa", "have P: \"P x y\""], ["proof (prove)\nusing this:\n  case \\<Squnion>i.\n          (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n           iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n  (x, xa) \\<Rightarrow> P x xa\n\ngoal (1 subgoal):\n 1. P x y", "unfolding x y fix_def2"], ["proof (prove)\nusing this:\n  case \\<Squnion>i.\n          (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n           iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n  (x, xa) \\<Rightarrow> P x xa\n\ngoal (1 subgoal):\n 1. P (\\<Squnion>i. iterate i\\<cdot>f\\<cdot>\\<bottom>)\n     (\\<Squnion>i. iterate i\\<cdot>g\\<cdot>\\<bottom>)", "by (simp add: lub_prod)"], ["proof (state)\nthis:\n  P x y\n\ngoal (1 subgoal):\n 1. P x y \\<and> Q x y", "have \"case_prod Q (\\<Squnion>i. (iterate i\\<cdot>f\\<cdot>\\<bottom>, iterate i\\<cdot>g\\<cdot>\\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case \\<Squnion>i.\n            (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n             iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n    (x, xa) \\<Rightarrow> Q x xa", "apply (rule admD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. case a of (a, b) \\<Rightarrow> Q a b)\n 2. chain\n     (\\<lambda>i.\n         (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n          iterate i\\<cdot>g\\<cdot>\\<bottom>))\n 3. \\<And>i.\n       case (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n             iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n       (a, b) \\<Rightarrow> Q a b", "apply (simp add: split_def adm_Q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. chain\n     (\\<lambda>i.\n         (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n          iterate i\\<cdot>g\\<cdot>\\<bottom>))\n 2. \\<And>i.\n       case (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n             iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n       (a, b) \\<Rightarrow> Q a b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       case (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n             iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n       (a, b) \\<Rightarrow> Q a b", "apply (simp add: 1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case \\<Squnion>i.\n          (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n           iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n  (x, xa) \\<Rightarrow> Q x xa\n\ngoal (1 subgoal):\n 1. P x y \\<and> Q x y", "then"], ["proof (chain)\npicking this:\n  case \\<Squnion>i.\n          (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n           iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n  (x, xa) \\<Rightarrow> Q x xa", "have Q: \"Q x y\""], ["proof (prove)\nusing this:\n  case \\<Squnion>i.\n          (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n           iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n  (x, xa) \\<Rightarrow> Q x xa\n\ngoal (1 subgoal):\n 1. Q x y", "unfolding x y fix_def2"], ["proof (prove)\nusing this:\n  case \\<Squnion>i.\n          (iterate i\\<cdot>f\\<cdot>\\<bottom>,\n           iterate i\\<cdot>g\\<cdot>\\<bottom>) of\n  (x, xa) \\<Rightarrow> Q x xa\n\ngoal (1 subgoal):\n 1. Q (\\<Squnion>i. iterate i\\<cdot>f\\<cdot>\\<bottom>)\n     (\\<Squnion>i. iterate i\\<cdot>g\\<cdot>\\<bottom>)", "by (simp add: lub_prod)"], ["proof (state)\nthis:\n  Q x y\n\ngoal (1 subgoal):\n 1. P x y \\<and> Q x y", "from P Q"], ["proof (chain)\npicking this:\n  P x y\n  Q x y", "show ?thesis"], ["proof (prove)\nusing this:\n  P x y\n  Q x y\n\ngoal (1 subgoal):\n 1. P x y \\<and> Q x y", "by simp"], ["proof (state)\nthis:\n  P x y \\<and> Q x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unfold_zipWithStep:\n  fixes f :: \"'a \\<rightarrow> 'b \\<rightarrow> 'c\"\n  fixes ha :: \"'s \\<rightarrow> ('a, 's) Step\"\n  fixes hb :: \"'t \\<rightarrow> ('b, 't) Step\"\n  defines h_def: \"h \\<equiv> zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\"\n  shows\n  \"(\\<forall>sa sb. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n    unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n   (\\<forall>sa sb a. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n    unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n      zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>(unfold\\<cdot>hb\\<cdot>sb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "note unfold [simp]"], ["proof (state)\nthis:\n  ?s \\<noteq> \\<bottom> \\<Longrightarrow>\n  unfold\\<cdot>?h\\<cdot>?s =\n  unfold2\\<cdot>(unfold\\<cdot>?h)\\<cdot>(?h\\<cdot>?s)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "have h_simps [simp]:\n    \"\\<And>sa sb. sa \\<noteq> \\<bottom> \\<Longrightarrow> sb \\<noteq> \\<bottom> \\<Longrightarrow> h\\<cdot>(sa :!: sb :!: Nothing) =\n      (case ha\\<cdot>sa of\n        Done \\<Rightarrow> Done\n      | Skip\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: sb :!: Nothing)\n      | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: sb :!: Just\\<cdot>(L\\<cdot>a)))\"\n    \"\\<And>sa sb a. sa \\<noteq> \\<bottom> \\<Longrightarrow> sb \\<noteq> \\<bottom> \\<Longrightarrow> h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n      (case hb\\<cdot>sb of\n        Done \\<Rightarrow> Done\n      | Skip\\<cdot>sb' \\<Rightarrow> Skip\\<cdot>(sa :!: sb' :!: Just\\<cdot>(L\\<cdot>a))\n      | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow> Yield\\<cdot>(f\\<cdot>a\\<cdot>b)\\<cdot>(sa :!: sb' :!: Nothing))\"\n    \"h\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sa sb.\n        \\<lbrakk>sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n        \\<Longrightarrow> h\\<cdot>(sa :!: sb :!: Nothing) =\n                          (case ha\\<cdot>sa of Done \\<Rightarrow> Done\n                           | Skip\\<cdot>sa' \\<Rightarrow>\n                               Skip\\<cdot>(sa' :!: sb :!: Nothing)\n                           | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow>\n                               Skip\\<cdot>\n                               (sa' :!: sb :!: Just\\<cdot>(L\\<cdot>a)))) &&&\n    (\\<And>sa sb a.\n        \\<lbrakk>sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n        \\<Longrightarrow> h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n                          (case hb\\<cdot>sb of Done \\<Rightarrow> Done\n                           | Skip\\<cdot>sb' \\<Rightarrow>\n                               Skip\\<cdot>\n                               (sa :!: sb' :!: Just\\<cdot>(L\\<cdot>a))\n                           | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow>\n                               Yield\\<cdot>(f\\<cdot>a\\<cdot>b)\\<cdot>\n                               (sa :!: sb' :!: Nothing))) &&&\n    h\\<cdot>\\<bottom> = \\<bottom>", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sa sb.\n        \\<lbrakk>sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n        \\<Longrightarrow> zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\\<cdot>\n                          (sa :!: sb :!: Nothing) =\n                          (case ha\\<cdot>sa of Done \\<Rightarrow> Done\n                           | Skip\\<cdot>sa' \\<Rightarrow>\n                               Skip\\<cdot>(sa' :!: sb :!: Nothing)\n                           | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow>\n                               Skip\\<cdot>\n                               (sa' :!: sb :!: Just\\<cdot>(L\\<cdot>a)))) &&&\n    (\\<And>sa sb a.\n        \\<lbrakk>sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n        \\<Longrightarrow> zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\\<cdot>\n                          (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n                          (case hb\\<cdot>sb of Done \\<Rightarrow> Done\n                           | Skip\\<cdot>sb' \\<Rightarrow>\n                               Skip\\<cdot>\n                               (sa :!: sb' :!: Just\\<cdot>(L\\<cdot>a))\n                           | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow>\n                               Yield\\<cdot>(f\\<cdot>a\\<cdot>b)\\<cdot>\n                               (sa :!: sb' :!: Nothing))) &&&\n    zipWithStep\\<cdot>f\\<cdot>ha\\<cdot>hb\\<cdot>\\<bottom> = \\<bottom>", "by simp_all"], ["proof (state)\nthis:\n  \\<lbrakk>?sa \\<noteq> \\<bottom>; ?sb \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> h\\<cdot>(?sa :!: ?sb :!: Nothing) =\n                    (case ha\\<cdot>?sa of Done \\<Rightarrow> Done\n                     | Skip\\<cdot>sa' \\<Rightarrow>\n                         Skip\\<cdot>(sa' :!: ?sb :!: Nothing)\n                     | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow>\n                         Skip\\<cdot>\n                         (sa' :!: ?sb :!: Just\\<cdot>(L\\<cdot>a)))\n  \\<lbrakk>?sa \\<noteq> \\<bottom>; ?sb \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> h\\<cdot>(?sa :!: ?sb :!: Just\\<cdot>(L\\<cdot>?a)) =\n                    (case hb\\<cdot>?sb of Done \\<Rightarrow> Done\n                     | Skip\\<cdot>sb' \\<Rightarrow>\n                         Skip\\<cdot>\n                         (?sa :!: sb' :!: Just\\<cdot>(L\\<cdot>?a))\n                     | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow>\n                         Yield\\<cdot>(f\\<cdot>?a\\<cdot>b)\\<cdot>\n                         (?sa :!: sb' :!: Nothing))\n  h\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "have 1:\n  \"(\\<forall>sa sb. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n    unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>(unfold\\<cdot>hb\\<cdot>sb))\n   \\<and>\n   (\\<forall>sa sb a. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n    unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n      zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>(unfold\\<cdot>hb\\<cdot>sb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "apply (rule unfold_ind [where h=\"h\"], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        \\<bottom>\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        \\<bottom>\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))\n 2. \\<And>u.\n       (\\<forall>sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n           zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n       (\\<forall>sa sb a.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n           zipWithL\\<cdot>f\\<cdot>\n           (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb)) \\<Longrightarrow>\n       (\\<forall>sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n           (sa :!: sb :!: Nothing) \\<sqsubseteq>\n           zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n       (\\<forall>sa sb a.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n           zipWithL\\<cdot>f\\<cdot>\n           (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       (\\<forall>sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n           zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n       (\\<forall>sa sb a.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n           zipWithL\\<cdot>f\\<cdot>\n           (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb)) \\<Longrightarrow>\n       (\\<forall>sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n           (sa :!: sb :!: Nothing) \\<sqsubseteq>\n           zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n       (\\<forall>sa sb a.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n           zipWithL\\<cdot>f\\<cdot>\n           (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n           (unfold\\<cdot>hb\\<cdot>sb))", "apply (intro conjI allI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u sa sb.\n       \\<lbrakk>(\\<forall>sa sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n                    zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n                    (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n                (\\<forall>sa sb a.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n                    zipWithL\\<cdot>f\\<cdot>\n                    (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n                    (unfold\\<cdot>hb\\<cdot>sb));\n        sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!: sb :!: Nothing) \\<sqsubseteq>\n                         zipWithL\\<cdot>f\\<cdot>\n                         (unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n                         (unfold\\<cdot>hb\\<cdot>sb)\n 2. \\<And>u sa sb a.\n       \\<lbrakk>(\\<forall>sa sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n                    zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n                    (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n                (\\<forall>sa sb a.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n                    zipWithL\\<cdot>f\\<cdot>\n                    (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n                    (unfold\\<cdot>hb\\<cdot>sb));\n        sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!: sb :!:\n                          Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n                         zipWithL\\<cdot>f\\<cdot>\n                         (LCons\\<cdot>a\\<cdot>\n                          (unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n                         (unfold\\<cdot>hb\\<cdot>sb)", "apply (case_tac \"ha\\<cdot>sa\", simp, simp, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u sa sb a.\n       \\<lbrakk>(\\<forall>sa sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n                    zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n                    (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n                (\\<forall>sa sb a.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n                    zipWithL\\<cdot>f\\<cdot>\n                    (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n                    (unfold\\<cdot>hb\\<cdot>sb));\n        sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!: sb :!:\n                          Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n                         zipWithL\\<cdot>f\\<cdot>\n                         (LCons\\<cdot>a\\<cdot>\n                          (unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n                         (unfold\\<cdot>hb\\<cdot>sb)", "apply (case_tac \"hb\\<cdot>sb\", simp, simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n  (\\<forall>sa sb a.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>\n      (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n      zipWithL\\<cdot>f\\<cdot>\n      (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "let ?P = \"\\<lambda>ua ub. \\<forall>sa sb. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n        zipWithL\\<cdot>f\\<cdot>(ua\\<cdot>sa)\\<cdot>(ub\\<cdot>sb) \\<sqsubseteq> unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "let ?Q = \"\\<lambda>ua ub. \\<forall>sa sb a. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n        zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(ua\\<cdot>sa))\\<cdot>(ub\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "have P_base: \"\\<And>ub. ?P \\<bottom> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ub.\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(\\<bottom>\\<cdot>sa)\\<cdot>\n          (ub\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)", "by simp"], ["proof (state)\nthis:\n  \\<forall>sa sb.\n     sa \\<noteq> \\<bottom> \\<longrightarrow>\n     sb \\<noteq> \\<bottom> \\<longrightarrow>\n     zipWithL\\<cdot>f\\<cdot>(\\<bottom>\\<cdot>sa)\\<cdot>\n     (?ub\\<cdot>sb) \\<sqsubseteq>\n     unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "have Q_base: \"\\<And>ua. ?Q ua \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<forall>sa sb a.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(ua\\<cdot>sa))\\<cdot>\n          (\\<bottom>\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a))", "by simp"], ["proof (state)\nthis:\n  \\<forall>sa sb a.\n     sa \\<noteq> \\<bottom> \\<longrightarrow>\n     sb \\<noteq> \\<bottom> \\<longrightarrow>\n     zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(?ua\\<cdot>sa))\\<cdot>\n     (\\<bottom>\\<cdot>sb) \\<sqsubseteq>\n     unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "have P_step: \"\\<And>ua ub. ?P ua ub \\<Longrightarrow> ?Q ua ub \\<Longrightarrow> ?P (unfoldF\\<cdot>ha\\<cdot>ua) ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua ub.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(ua\\<cdot>sa)\\<cdot>\n                   (ub\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb a.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(ua\\<cdot>sa))\\<cdot>\n           (ub\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (unfoldF\\<cdot>ha\\<cdot>ua\\<cdot>sa)\\<cdot>\n                            (ub\\<cdot>sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)", "by (clarsimp, case_tac \"ha\\<cdot>sa\", simp_all)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>sa sb.\n              sa \\<noteq> \\<bottom> \\<longrightarrow>\n              sb \\<noteq> \\<bottom> \\<longrightarrow>\n              zipWithL\\<cdot>f\\<cdot>(?ua\\<cdot>sa)\\<cdot>\n              (?ub\\<cdot>sb) \\<sqsubseteq>\n              unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n   \\<forall>sa sb a.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(?ua\\<cdot>sa))\\<cdot>\n      (?ub\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>sa sb.\n                       sa \\<noteq> \\<bottom> \\<longrightarrow>\n                       sb \\<noteq> \\<bottom> \\<longrightarrow>\n                       zipWithL\\<cdot>f\\<cdot>\n                       (unfoldF\\<cdot>ha\\<cdot>?ua\\<cdot>sa)\\<cdot>\n                       (?ub\\<cdot>sb) \\<sqsubseteq>\n                       unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "have Q_step: \"\\<And>ua ub. ?P ua ub \\<Longrightarrow> ?Q ua ub \\<Longrightarrow> ?Q ua (unfoldF\\<cdot>hb\\<cdot>ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua ub.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(ua\\<cdot>sa)\\<cdot>\n                   (ub\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb a.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(ua\\<cdot>sa))\\<cdot>\n           (ub\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb a.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (LCons\\<cdot>a\\<cdot>(ua\\<cdot>sa))\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>ub\\<cdot>\n                             sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a))", "by (clarsimp, case_tac \"hb\\<cdot>sb\", simp_all)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>sa sb.\n              sa \\<noteq> \\<bottom> \\<longrightarrow>\n              sb \\<noteq> \\<bottom> \\<longrightarrow>\n              zipWithL\\<cdot>f\\<cdot>(?ua\\<cdot>sa)\\<cdot>\n              (?ub\\<cdot>sb) \\<sqsubseteq>\n              unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n   \\<forall>sa sb a.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>a\\<cdot>(?ua\\<cdot>sa))\\<cdot>\n      (?ub\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>sa sb a.\n                       sa \\<noteq> \\<bottom> \\<longrightarrow>\n                       sb \\<noteq> \\<bottom> \\<longrightarrow>\n                       zipWithL\\<cdot>f\\<cdot>\n                       (LCons\\<cdot>a\\<cdot>(?ua\\<cdot>sa))\\<cdot>\n                       (unfoldF\\<cdot>hb\\<cdot>?ub\\<cdot>sb) \\<sqsubseteq>\n                       unfold\\<cdot>h\\<cdot>\n                       (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "have 2: \"?P (unfold\\<cdot>ha) (unfold\\<cdot>hb) \\<and> ?Q (unfold\\<cdot>ha) (unfold\\<cdot>hb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb) \\<sqsubseteq>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb) \\<sqsubseteq>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)))", "apply (rule zipWithS_fix_ind [OF unfold_eq_fix [of ha] unfold_eq_fix [of hb]])"], ["proof (prove)\ngoal (6 subgoals):\n 1. adm (\\<lambda>x.\n            \\<forall>sa sb.\n               sa \\<noteq> \\<bottom> \\<longrightarrow>\n               sb \\<noteq> \\<bottom> \\<longrightarrow>\n               zipWithL\\<cdot>f\\<cdot>(fst x\\<cdot>sa)\\<cdot>\n               (snd x\\<cdot>sb) \\<sqsubseteq>\n               unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing))\n 2. adm (\\<lambda>x.\n            \\<forall>sa sb a.\n               sa \\<noteq> \\<bottom> \\<longrightarrow>\n               sb \\<noteq> \\<bottom> \\<longrightarrow>\n               zipWithL\\<cdot>f\\<cdot>\n               (LCons\\<cdot>a\\<cdot>(fst x\\<cdot>sa))\\<cdot>\n               (snd x\\<cdot>sb) \\<sqsubseteq>\n               unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)))\n 3. \\<And>b.\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(\\<bottom>\\<cdot>sa)\\<cdot>\n          (b\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\n 4. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (unfoldF\\<cdot>ha\\<cdot>a\\<cdot>sa)\\<cdot>\n                            (b\\<cdot>sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\n 5. \\<And>a.\n       \\<forall>sa sb aa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n          (\\<bottom>\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\n 6. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb aa.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>b\\<cdot>\n                             sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))", "apply (simp, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b.\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(\\<bottom>\\<cdot>sa)\\<cdot>\n          (b\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\n 2. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (unfoldF\\<cdot>ha\\<cdot>a\\<cdot>sa)\\<cdot>\n                            (b\\<cdot>sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\n 3. \\<And>a.\n       \\<forall>sa sb aa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n          (\\<bottom>\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\n 4. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb aa.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>b\\<cdot>\n                             sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))", "(* admissibility *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b.\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(\\<bottom>\\<cdot>sa)\\<cdot>\n          (b\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\n 2. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (unfoldF\\<cdot>ha\\<cdot>a\\<cdot>sa)\\<cdot>\n                            (b\\<cdot>sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\n 3. \\<And>a.\n       \\<forall>sa sb aa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n          (\\<bottom>\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\n 4. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb aa.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>b\\<cdot>\n                             sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))", "apply (rule P_base)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (unfoldF\\<cdot>ha\\<cdot>a\\<cdot>sa)\\<cdot>\n                            (b\\<cdot>sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)\n 2. \\<And>a.\n       \\<forall>sa sb aa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n          (\\<bottom>\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\n 3. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb aa.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>b\\<cdot>\n                             sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))", "apply (erule (1) P_step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<forall>sa sb aa.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n          (\\<bottom>\\<cdot>sb) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\n 2. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb aa.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>b\\<cdot>\n                             sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))", "apply (rule Q_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>sa sb.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   sb \\<noteq> \\<bottom> \\<longrightarrow>\n                   zipWithL\\<cdot>f\\<cdot>(a\\<cdot>sa)\\<cdot>\n                   (b\\<cdot>sb) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing);\n        \\<forall>sa sb aa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           zipWithL\\<cdot>f\\<cdot>(LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n           (b\\<cdot>sb) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb aa.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            zipWithL\\<cdot>f\\<cdot>\n                            (LCons\\<cdot>aa\\<cdot>(a\\<cdot>sa))\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>b\\<cdot>\n                             sb) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: sb :!: Just\\<cdot>(L\\<cdot>aa))", "apply (erule (1) Q_step)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)) \\<and>\n  (\\<forall>sa sb a.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      zipWithL\\<cdot>f\\<cdot>\n      (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "from 1 2"], ["proof (chain)\npicking this:\n  (\\<forall>sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n  (\\<forall>sa sb a.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>\n      (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n      zipWithL\\<cdot>f\\<cdot>\n      (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb))\n  (\\<forall>sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)) \\<and>\n  (\\<forall>sa sb a.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      zipWithL\\<cdot>f\\<cdot>\n      (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) \\<sqsubseteq>\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n  (\\<forall>sa sb a.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>\n      (sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) \\<sqsubseteq>\n      zipWithL\\<cdot>f\\<cdot>\n      (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb))\n  (\\<forall>sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing)) \\<and>\n  (\\<forall>sa sb a.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      zipWithL\\<cdot>f\\<cdot>\n      (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n        zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n    (\\<forall>sa sb a.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n        zipWithL\\<cdot>f\\<cdot>\n        (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n        (unfold\\<cdot>hb\\<cdot>sb))", "by (simp_all add: po_eq_conv [where 'a=\"'c LList\"])"], ["proof (state)\nthis:\n  (\\<forall>sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Nothing) =\n      zipWithL\\<cdot>f\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb)) \\<and>\n  (\\<forall>sa sb a.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: sb :!: Just\\<cdot>(L\\<cdot>a)) =\n      zipWithL\\<cdot>f\\<cdot>\n      (LCons\\<cdot>a\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\\<cdot>\n      (unfold\\<cdot>hb\\<cdot>sb))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zipWithS_defined: \"a \\<noteq> \\<bottom> \\<Longrightarrow> b \\<noteq> \\<bottom> \\<Longrightarrow> zipWithS\\<cdot>f\\<cdot>a\\<cdot>b \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> \\<bottom>; b \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> zipWithS\\<cdot>f\\<cdot>a\\<cdot>b \\<noteq> \\<bottom>", "by (cases a, simp, cases b, simp, simp)"], ["", "lemma unstream_zipWithS:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> b \\<noteq> \\<bottom> \\<Longrightarrow>\n    unstream\\<cdot>(zipWithS\\<cdot>f\\<cdot>a\\<cdot>b) = zipWithL\\<cdot>f\\<cdot>(unstream\\<cdot>a)\\<cdot>(unstream\\<cdot>b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> \\<bottom>; b \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> unstream\\<cdot>(zipWithS\\<cdot>f\\<cdot>a\\<cdot>b) =\n                      zipWithL\\<cdot>f\\<cdot>(unstream\\<cdot>a)\\<cdot>\n                      (unstream\\<cdot>b)", "apply (cases a, simp, cases b, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cfun s cfuna sa.\n       \\<lbrakk>a \\<noteq> \\<bottom>; b \\<noteq> \\<bottom>;\n        a = Stream\\<cdot>cfun\\<cdot>s; s \\<noteq> \\<bottom>;\n        b = Stream\\<cdot>cfuna\\<cdot>sa; sa \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unstream\\<cdot>(zipWithS\\<cdot>f\\<cdot>a\\<cdot>b) =\n                         zipWithL\\<cdot>f\\<cdot>(unstream\\<cdot>a)\\<cdot>\n                         (unstream\\<cdot>b)", "apply (simp add: unfold_zipWithStep)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zipWithS_cong:\n  \"f = f' \\<Longrightarrow> a \\<approx> a' \\<Longrightarrow> b \\<approx> b' \\<Longrightarrow>\n    zipWithS\\<cdot>f\\<cdot>a\\<cdot>b \\<approx> zipWithS\\<cdot>f\\<cdot>a'\\<cdot>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = f'; a \\<approx> a'; b \\<approx> b'\\<rbrakk>\n    \\<Longrightarrow> zipWithS\\<cdot>f\\<cdot>a\\<cdot>b \\<approx>\n                      zipWithS\\<cdot>f\\<cdot>a'\\<cdot>b'", "unfolding bisimilar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = f';\n     unstream\\<cdot>a = unstream\\<cdot>a' \\<and>\n     a \\<noteq> \\<bottom> \\<and> a' \\<noteq> \\<bottom>;\n     unstream\\<cdot>b = unstream\\<cdot>b' \\<and>\n     b \\<noteq> \\<bottom> \\<and> b' \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> unstream\\<cdot>(zipWithS\\<cdot>f\\<cdot>a\\<cdot>b) =\n                      unstream\\<cdot>\n                      (zipWithS\\<cdot>f\\<cdot>a'\\<cdot>b') \\<and>\n                      zipWithS\\<cdot>f\\<cdot>a\\<cdot>b \\<noteq>\n                      \\<bottom> \\<and>\n                      zipWithS\\<cdot>f\\<cdot>a'\\<cdot>b' \\<noteq> \\<bottom>", "by (simp add: unstream_zipWithS zipWithS_defined)"], ["", "lemma zipWithL_eq:\n  \"zipWithL\\<cdot>f\\<cdot>xs\\<cdot>ys = unstream\\<cdot>(zipWithS\\<cdot>f\\<cdot>(stream\\<cdot>xs)\\<cdot>(stream\\<cdot>ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zipWithL\\<cdot>f\\<cdot>xs\\<cdot>ys =\n    unstream\\<cdot>\n    (zipWithS\\<cdot>f\\<cdot>(stream\\<cdot>xs)\\<cdot>(stream\\<cdot>ys))", "by (simp add: unstream_zipWithS)"], ["", "subsection \\<open>ConcatMap function\\<close>"], ["", "fixrec\n  concatMapStep ::\n    \"('a \\<rightarrow> ('b, 't) Stream) \\<rightarrow>\n     ('s \\<rightarrow> ('a, 's) Step) \\<rightarrow>\n     's :!: ('b, 't) Stream Maybe \\<rightarrow>\n     ('b, 's :!: ('b, 't) Stream Maybe) Step\"\nwhere\n  \"sa \\<noteq> \\<bottom> \\<Longrightarrow> concatMapStep\\<cdot>f\\<cdot>ha\\<cdot>(sa :!: Nothing) =\n    (case ha\\<cdot>sa of\n      Done \\<Rightarrow> Done\n    | Skip\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: Nothing)\n    | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: Just\\<cdot>(f\\<cdot>a)))\"\n| \"sa \\<noteq> \\<bottom> \\<Longrightarrow> sb \\<noteq> \\<bottom> \\<Longrightarrow>\n    concatMapStep\\<cdot>f\\<cdot>ha\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n    (case hb\\<cdot>sb of\n      Done \\<Rightarrow> Skip\\<cdot>(sa :!: Nothing)\n    | Skip\\<cdot>sb' \\<Rightarrow> Skip\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb'))\n    | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow> Yield\\<cdot>b\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb')))\""], ["", "lemma concatMapStep_strict [simp]: \"concatMapStep\\<cdot>f\\<cdot>ha\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMapStep\\<cdot>f\\<cdot>ha\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec\n  concatMapS ::\n    \"('a \\<rightarrow> ('b, 't) Stream) \\<rightarrow> ('a, 's) Stream \\<rightarrow>\n     ('b, 's :!: ('b, 't) Stream Maybe) Stream\"\nwhere\n  \"s \\<noteq> \\<bottom> \\<Longrightarrow> concatMapS\\<cdot>f\\<cdot>(Stream\\<cdot>h\\<cdot>s) = Stream\\<cdot>(concatMapStep\\<cdot>f\\<cdot>h)\\<cdot>(s :!: Nothing)\""], ["", "lemma concatMapS_strict [simp]: \"concatMapS\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMapS\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma unfold_concatMapStep:\n  fixes ha :: \"'s \\<rightarrow> ('a, 's) Step\"\n  fixes f :: \"'a \\<rightarrow> ('b, 't) Stream\"\n  defines h_def: \"h \\<equiv> concatMapStep\\<cdot>f\\<cdot>ha\"\n  defines f'_def: \"f' \\<equiv> unstream oo f\"\n  shows\n  \"(\\<forall>sa. sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing) = concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n   (\\<forall>sa hb sb. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>(concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "note unfold [simp]"], ["proof (state)\nthis:\n  ?s \\<noteq> \\<bottom> \\<Longrightarrow>\n  unfold\\<cdot>?h\\<cdot>?s =\n  unfold2\\<cdot>(unfold\\<cdot>?h)\\<cdot>(?h\\<cdot>?s)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "have h_simps [simp]:\n    \"\\<And>sa. sa \\<noteq> \\<bottom> \\<Longrightarrow> h\\<cdot>(sa :!: Nothing) =\n      (case ha\\<cdot>sa of Done \\<Rightarrow> Done\n      | Skip\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: Nothing)\n      | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: Just\\<cdot>(f\\<cdot>a)))\"\n    \"\\<And>sa hb sb. sa \\<noteq> \\<bottom> \\<Longrightarrow> sb \\<noteq> \\<bottom> \\<Longrightarrow> h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n      (case hb\\<cdot>sb of Done \\<Rightarrow> Skip\\<cdot>(sa :!: Nothing)\n      | Skip\\<cdot>sb' \\<Rightarrow> Skip\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb'))\n      | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow> Yield\\<cdot>b\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb')))\"\n    \"h\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sa.\n        sa \\<noteq> \\<bottom> \\<Longrightarrow>\n        h\\<cdot>(sa :!: Nothing) =\n        (case ha\\<cdot>sa of Done \\<Rightarrow> Done\n         | Skip\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: Nothing)\n         | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow>\n             Skip\\<cdot>(sa' :!: Just\\<cdot>(f\\<cdot>a)))) &&&\n    (\\<And>sa hb sb.\n        \\<lbrakk>sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n        \\<Longrightarrow> h\\<cdot>\n                          (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n                          (case hb\\<cdot>sb of\n                           Done \\<Rightarrow> Skip\\<cdot>(sa :!: Nothing)\n                           | Skip\\<cdot>sb' \\<Rightarrow>\n                               Skip\\<cdot>\n                               (sa :!:\n                                Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb'))\n                           | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow>\n                               Yield\\<cdot>b\\<cdot>\n                               (sa :!:\n                                Just\\<cdot>\n                                (Stream\\<cdot>hb\\<cdot>sb')))) &&&\n    h\\<cdot>\\<bottom> = \\<bottom>", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sa.\n        sa \\<noteq> \\<bottom> \\<Longrightarrow>\n        concatMapStep\\<cdot>f\\<cdot>ha\\<cdot>(sa :!: Nothing) =\n        (case ha\\<cdot>sa of Done \\<Rightarrow> Done\n         | Skip\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: Nothing)\n         | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow>\n             Skip\\<cdot>(sa' :!: Just\\<cdot>(f\\<cdot>a)))) &&&\n    (\\<And>sa hb sb.\n        \\<lbrakk>sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n        \\<Longrightarrow> concatMapStep\\<cdot>f\\<cdot>ha\\<cdot>\n                          (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n                          (case hb\\<cdot>sb of\n                           Done \\<Rightarrow> Skip\\<cdot>(sa :!: Nothing)\n                           | Skip\\<cdot>sb' \\<Rightarrow>\n                               Skip\\<cdot>\n                               (sa :!:\n                                Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb'))\n                           | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow>\n                               Yield\\<cdot>b\\<cdot>\n                               (sa :!:\n                                Just\\<cdot>\n                                (Stream\\<cdot>hb\\<cdot>sb')))) &&&\n    concatMapStep\\<cdot>f\\<cdot>ha\\<cdot>\\<bottom> = \\<bottom>", "by simp_all"], ["proof (state)\nthis:\n  ?sa \\<noteq> \\<bottom> \\<Longrightarrow>\n  h\\<cdot>(?sa :!: Nothing) =\n  (case ha\\<cdot>?sa of Done \\<Rightarrow> Done\n   | Skip\\<cdot>sa' \\<Rightarrow> Skip\\<cdot>(sa' :!: Nothing)\n   | Yield\\<cdot>a\\<cdot>sa' \\<Rightarrow>\n       Skip\\<cdot>(sa' :!: Just\\<cdot>(f\\<cdot>a)))\n  \\<lbrakk>?sa \\<noteq> \\<bottom>; ?sb \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> h\\<cdot>\n                    (?sa :!: Just\\<cdot>(Stream\\<cdot>?hb\\<cdot>?sb)) =\n                    (case ?hb\\<cdot>?sb of\n                     Done \\<Rightarrow> Skip\\<cdot>(?sa :!: Nothing)\n                     | Skip\\<cdot>sb' \\<Rightarrow>\n                         Skip\\<cdot>\n                         (?sa :!: Just\\<cdot>(Stream\\<cdot>?hb\\<cdot>sb'))\n                     | Yield\\<cdot>b\\<cdot>sb' \\<Rightarrow>\n                         Yield\\<cdot>b\\<cdot>\n                         (?sa :!: Just\\<cdot>(Stream\\<cdot>?hb\\<cdot>sb')))\n  h\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "have f'_beta [simp]: \"\\<And>a. f'\\<cdot>a = unstream\\<cdot>(f\\<cdot>a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. f'\\<cdot>a = unstream\\<cdot>(f\\<cdot>a)", "unfolding f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. (unstream oo f)\\<cdot>a = unstream\\<cdot>(f\\<cdot>a)", "by simp"], ["proof (state)\nthis:\n  f'\\<cdot>?a = unstream\\<cdot>(f\\<cdot>?a)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "have 1:\n  \"(\\<forall>sa. sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing) \\<sqsubseteq> concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa))\n   \\<and>\n   (\\<forall>sa hb sb. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>(concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "apply (rule unfold_ind [where h=\"h\"], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        \\<bottom>\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        \\<bottom>\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))\n 2. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n           concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n       (\\<forall>sa hb sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfold\\<cdot>ha\\<cdot>sa))) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>h\\<cdot>u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n           concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n       (\\<forall>sa hb sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n           concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n       (\\<forall>sa hb sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           u\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfold\\<cdot>ha\\<cdot>sa))) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>h\\<cdot>u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n           concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n       (\\<forall>sa hb sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "apply (intro conjI allI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u sa.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n                    concatMapL\\<cdot>f'\\<cdot>\n                    (unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n                (\\<forall>sa hb sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!:\n                     Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                    (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)));\n        sa \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!: Nothing) \\<sqsubseteq>\n                         concatMapL\\<cdot>f'\\<cdot>\n                         (unfold\\<cdot>ha\\<cdot>sa)\n 2. \\<And>u sa hb sb.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n                    concatMapL\\<cdot>f'\\<cdot>\n                    (unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n                (\\<forall>sa hb sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!:\n                     Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                    (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)));\n        sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!:\n                          Just\\<cdot>\n                          (Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                         appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                         (concatMapL\\<cdot>f'\\<cdot>\n                          (unfold\\<cdot>ha\\<cdot>sa))", "apply (case_tac \"ha\\<cdot>sa\", simp, simp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u sa a s.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n                    concatMapL\\<cdot>f'\\<cdot>\n                    (unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n                (\\<forall>sa hb sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!:\n                     Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                    (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)));\n        sa \\<noteq> \\<bottom>; ha\\<cdot>sa = Yield\\<cdot>a\\<cdot>s;\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!: Nothing) \\<sqsubseteq>\n                         concatMapL\\<cdot>f'\\<cdot>\n                         (unfold\\<cdot>ha\\<cdot>sa)\n 2. \\<And>u sa hb sb.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n                    concatMapL\\<cdot>f'\\<cdot>\n                    (unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n                (\\<forall>sa hb sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!:\n                     Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                    (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)));\n        sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!:\n                          Just\\<cdot>\n                          (Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                         appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                         (concatMapL\\<cdot>f'\\<cdot>\n                          (unfold\\<cdot>ha\\<cdot>sa))", "apply (rename_tac a sa')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u sa a sa'.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n                    concatMapL\\<cdot>f'\\<cdot>\n                    (unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n                (\\<forall>sa hb sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!:\n                     Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                    (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)));\n        sa \\<noteq> \\<bottom>; ha\\<cdot>sa = Yield\\<cdot>a\\<cdot>sa';\n        sa' \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!: Nothing) \\<sqsubseteq>\n                         concatMapL\\<cdot>f'\\<cdot>\n                         (unfold\\<cdot>ha\\<cdot>sa)\n 2. \\<And>u sa hb sb.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n                    concatMapL\\<cdot>f'\\<cdot>\n                    (unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n                (\\<forall>sa hb sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!:\n                     Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                    (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)));\n        sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!:\n                          Just\\<cdot>\n                          (Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                         appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                         (concatMapL\\<cdot>f'\\<cdot>\n                          (unfold\\<cdot>ha\\<cdot>sa))", "apply (case_tac \"f\\<cdot>a\", simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u sa hb sb.\n       \\<lbrakk>(\\<forall>sa.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n                    concatMapL\\<cdot>f'\\<cdot>\n                    (unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n                (\\<forall>sa hb sb.\n                    sa \\<noteq> \\<bottom> \\<longrightarrow>\n                    sb \\<noteq> \\<bottom> \\<longrightarrow>\n                    u\\<cdot>\n                    (sa :!:\n                     Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                    appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                    (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)));\n        sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unfoldF\\<cdot>h\\<cdot>u\\<cdot>\n                         (sa :!:\n                          Just\\<cdot>\n                          (Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n                         appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                         (concatMapL\\<cdot>f'\\<cdot>\n                          (unfold\\<cdot>ha\\<cdot>sa))", "apply (case_tac \"hb\\<cdot>sb\", simp, simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n      concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n  (\\<forall>sa hb sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>\n      (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n      appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n      (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "let ?P = \"\\<lambda>ua. \\<forall>sa. sa \\<noteq> \\<bottom> \\<longrightarrow>\n        concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa) \\<sqsubseteq> unfold\\<cdot>h\\<cdot>(sa :!: Nothing)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "let ?Q = \"\\<lambda>hb ua ub. \\<forall>sa sb. sa \\<noteq> \\<bottom> \\<longrightarrow> sb \\<noteq> \\<bottom> \\<longrightarrow>\n        appendL\\<cdot>(ub\\<cdot>sb)\\<cdot>(concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa)) \\<sqsubseteq>\n            unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "have P_base: \"?P \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sa.\n       sa \\<noteq> \\<bottom> \\<longrightarrow>\n       concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa) \\<sqsubseteq>\n       unfold\\<cdot>h\\<cdot>(sa :!: Nothing)", "by simp"], ["proof (state)\nthis:\n  \\<forall>sa.\n     sa \\<noteq> \\<bottom> \\<longrightarrow>\n     concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa) \\<sqsubseteq>\n     unfold\\<cdot>h\\<cdot>(sa :!: Nothing)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "have P_step: \"\\<And>ua. ?P ua \\<Longrightarrow> \\<forall>hb. ?Q hb ua (unfold\\<cdot>hb) \\<Longrightarrow> ?P (unfoldF\\<cdot>ha\\<cdot>ua)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            concatMapL\\<cdot>f'\\<cdot>\n                            (unfoldF\\<cdot>ha\\<cdot>ua\\<cdot>\n                             sa) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>(sa :!: Nothing)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua sa.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb));\n        sa \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> concatMapL\\<cdot>f'\\<cdot>\n                         (unfoldF\\<cdot>ha\\<cdot>ua\\<cdot>sa) \\<sqsubseteq>\n                         unfold\\<cdot>h\\<cdot>(sa :!: Nothing)", "apply (case_tac \"ha\\<cdot>sa\", simp, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua sa a s.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb));\n        sa \\<noteq> \\<bottom>; ha\\<cdot>sa = Yield\\<cdot>a\\<cdot>s;\n        s \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> concatMapL\\<cdot>f'\\<cdot>\n                         (unfoldF\\<cdot>ha\\<cdot>ua\\<cdot>sa) \\<sqsubseteq>\n                         unfold\\<cdot>h\\<cdot>(sa :!: Nothing)", "apply (rename_tac a sa')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua sa a sa'.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb));\n        sa \\<noteq> \\<bottom>; ha\\<cdot>sa = Yield\\<cdot>a\\<cdot>sa';\n        sa' \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> concatMapL\\<cdot>f'\\<cdot>\n                         (unfoldF\\<cdot>ha\\<cdot>ua\\<cdot>sa) \\<sqsubseteq>\n                         unfold\\<cdot>h\\<cdot>(sa :!: Nothing)", "apply (case_tac \"f\\<cdot>a\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>sa.\n              sa \\<noteq> \\<bottom> \\<longrightarrow>\n              concatMapL\\<cdot>f'\\<cdot>(?ua\\<cdot>sa) \\<sqsubseteq>\n              unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n   \\<forall>hb sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n      (concatMapL\\<cdot>f'\\<cdot>(?ua\\<cdot>sa)) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>\n      (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>sa.\n                       sa \\<noteq> \\<bottom> \\<longrightarrow>\n                       concatMapL\\<cdot>f'\\<cdot>\n                       (unfoldF\\<cdot>ha\\<cdot>?ua\\<cdot>sa) \\<sqsubseteq>\n                       unfold\\<cdot>h\\<cdot>(sa :!: Nothing)\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "have Q_base: \"\\<And>ua hb. ?Q hb ua \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua hb.\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(\\<bottom>\\<cdot>sb)\\<cdot>\n          (concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa)) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>\n          (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))", "by simp"], ["proof (state)\nthis:\n  \\<forall>sa sb.\n     sa \\<noteq> \\<bottom> \\<longrightarrow>\n     sb \\<noteq> \\<bottom> \\<longrightarrow>\n     appendL\\<cdot>(\\<bottom>\\<cdot>sb)\\<cdot>\n     (concatMapL\\<cdot>f'\\<cdot>(?ua\\<cdot>sa)) \\<sqsubseteq>\n     unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>?hb\\<cdot>sb))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "have Q_step: \"\\<And>hb ua ub. ?P ua \\<Longrightarrow> ?Q hb ua ub \\<Longrightarrow> ?Q hb ua (unfoldF\\<cdot>hb\\<cdot>ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>hb ua ub.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(ub\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            appendL\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>ub\\<cdot>sb)\\<cdot>\n                            (concatMapL\\<cdot>f'\\<cdot>\n                             (ua\\<cdot>sa)) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>hb ua ub sa sb.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(ub\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(ua\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb));\n        sa \\<noteq> \\<bottom>; sb \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> appendL\\<cdot>\n                         (unfoldF\\<cdot>hb\\<cdot>ub\\<cdot>sb)\\<cdot>\n                         (concatMapL\\<cdot>f'\\<cdot>\n                          (ua\\<cdot>sa)) \\<sqsubseteq>\n                         unfold\\<cdot>h\\<cdot>\n                         (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))", "apply (case_tac \"hb\\<cdot>sb\", simp, simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>sa.\n              sa \\<noteq> \\<bottom> \\<longrightarrow>\n              concatMapL\\<cdot>f'\\<cdot>(?ua\\<cdot>sa) \\<sqsubseteq>\n              unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n   \\<forall>sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      appendL\\<cdot>(?ub\\<cdot>sb)\\<cdot>\n      (concatMapL\\<cdot>f'\\<cdot>(?ua\\<cdot>sa)) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>\n      (sa :!: Just\\<cdot>(Stream\\<cdot>?hb\\<cdot>sb))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>sa sb.\n                       sa \\<noteq> \\<bottom> \\<longrightarrow>\n                       sb \\<noteq> \\<bottom> \\<longrightarrow>\n                       appendL\\<cdot>\n                       (unfoldF\\<cdot>?hb\\<cdot>?ub\\<cdot>sb)\\<cdot>\n                       (concatMapL\\<cdot>f'\\<cdot>\n                        (?ua\\<cdot>sa)) \\<sqsubseteq>\n                       unfold\\<cdot>h\\<cdot>\n                       (sa :!: Just\\<cdot>(Stream\\<cdot>?hb\\<cdot>sb))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "have 2: \"?P (unfold\\<cdot>ha) \\<and> (\\<forall>hb. ?Q hb (unfold\\<cdot>ha) (unfold\\<cdot>hb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa) \\<sqsubseteq>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n    (\\<forall>hb sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<sqsubseteq>\n        unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))", "apply (rule unfold_ind [where h=\"ha\"], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa) \\<sqsubseteq>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n    (\\<forall>hb sa sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa)) \\<sqsubseteq>\n        unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))\n 2. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>\n           (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>sa.\n       sa \\<noteq> \\<bottom> \\<longrightarrow>\n       concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa) \\<sqsubseteq>\n       unfold\\<cdot>h\\<cdot>(sa :!: Nothing)\n 2. \\<forall>hb sa sb.\n       sa \\<noteq> \\<bottom> \\<longrightarrow>\n       sb \\<noteq> \\<bottom> \\<longrightarrow>\n       appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n       (concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa)) \\<sqsubseteq>\n       unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\n 3. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>\n           (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))", "apply (rule P_base)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>hb sa sb.\n       sa \\<noteq> \\<bottom> \\<longrightarrow>\n       sb \\<noteq> \\<bottom> \\<longrightarrow>\n       appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n       (concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa)) \\<sqsubseteq>\n       unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\n 2. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>\n           (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))", "apply (rule allI, rule_tac h=hb in unfold_ind, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>hb.\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(\\<bottom>\\<cdot>sb)\\<cdot>\n          (concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa)) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>\n          (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\n 2. \\<And>hb u.\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(u\\<cdot>sb)\\<cdot>\n          (concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa)) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>\n          (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<Longrightarrow>\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(unfoldF\\<cdot>hb\\<cdot>u\\<cdot>sb)\\<cdot>\n          (concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa)) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>\n          (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\n 3. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>\n           (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))", "apply (rule Q_base)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>hb u.\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(u\\<cdot>sb)\\<cdot>\n          (concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa)) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>\n          (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<Longrightarrow>\n       \\<forall>sa sb.\n          sa \\<noteq> \\<bottom> \\<longrightarrow>\n          sb \\<noteq> \\<bottom> \\<longrightarrow>\n          appendL\\<cdot>(unfoldF\\<cdot>hb\\<cdot>u\\<cdot>sb)\\<cdot>\n          (concatMapL\\<cdot>f'\\<cdot>(\\<bottom>\\<cdot>sa)) \\<sqsubseteq>\n          unfold\\<cdot>h\\<cdot>\n          (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\n 2. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>\n           (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))", "apply (erule Q_step [OF P_base])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))) \\<Longrightarrow>\n       (\\<forall>sa.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           concatMapL\\<cdot>f'\\<cdot>\n           (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n       (\\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>sa.\n                             sa \\<noteq> \\<bottom> \\<longrightarrow>\n                             concatMapL\\<cdot>f'\\<cdot>\n                             (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>\n                              sa) \\<sqsubseteq>\n                             unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n                         (\\<forall>hb sa sb.\n                             sa \\<noteq> \\<bottom> \\<longrightarrow>\n                             sb \\<noteq> \\<bottom> \\<longrightarrow>\n                             appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                             (concatMapL\\<cdot>f'\\<cdot>\n                              (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>\n                               sa)) \\<sqsubseteq>\n                             unfold\\<cdot>h\\<cdot>\n                             (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            concatMapL\\<cdot>f'\\<cdot>\n                            (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>\n                             sa) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>(sa :!: Nothing)\n 2. \\<And>u.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>hb sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                            (concatMapL\\<cdot>f'\\<cdot>\n                             (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>\n                              sa)) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))", "apply (erule (1) P_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>hb sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n                            (concatMapL\\<cdot>f'\\<cdot>\n                             (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>\n                              sa)) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))", "apply (rule allI, rule_tac h=hb in unfold_ind, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u hb.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            appendL\\<cdot>(\\<bottom>\\<cdot>sb)\\<cdot>\n                            (concatMapL\\<cdot>f'\\<cdot>\n                             (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>\n                              sa)) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\n 2. \\<And>u hb ua.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb));\n        \\<forall>sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(ua\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            appendL\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>ua\\<cdot>sb)\\<cdot>\n                            (concatMapL\\<cdot>f'\\<cdot>\n                             (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>\n                              sa)) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))", "apply (rule Q_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u hb ua.\n       \\<lbrakk>\\<forall>sa.\n                   sa \\<noteq> \\<bottom> \\<longrightarrow>\n                   concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa) \\<sqsubseteq>\n                   unfold\\<cdot>h\\<cdot>(sa :!: Nothing);\n        \\<forall>hb sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>(u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb));\n        \\<forall>sa sb.\n           sa \\<noteq> \\<bottom> \\<longrightarrow>\n           sb \\<noteq> \\<bottom> \\<longrightarrow>\n           appendL\\<cdot>(ua\\<cdot>sb)\\<cdot>\n           (concatMapL\\<cdot>f'\\<cdot>\n            (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>sa)) \\<sqsubseteq>\n           unfold\\<cdot>h\\<cdot>\n           (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa sb.\n                            sa \\<noteq> \\<bottom> \\<longrightarrow>\n                            sb \\<noteq> \\<bottom> \\<longrightarrow>\n                            appendL\\<cdot>\n                            (unfoldF\\<cdot>hb\\<cdot>ua\\<cdot>sb)\\<cdot>\n                            (concatMapL\\<cdot>f'\\<cdot>\n                             (unfoldF\\<cdot>ha\\<cdot>u\\<cdot>\n                              sa)) \\<sqsubseteq>\n                            unfold\\<cdot>h\\<cdot>\n                            (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb))", "apply (erule (2) Q_step [OF P_step])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n  (\\<forall>hb sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n      (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "from 1 2"], ["proof (chain)\npicking this:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n      concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n  (\\<forall>sa hb sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>\n      (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n      appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n      (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n  (\\<forall>hb sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n      (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing) \\<sqsubseteq>\n      concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n  (\\<forall>sa hb sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>\n      (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) \\<sqsubseteq>\n      appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n      (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing)) \\<and>\n  (\\<forall>hb sa sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n      (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<sqsubseteq>\n      unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)))\n\ngoal (1 subgoal):\n 1. (\\<forall>sa.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n        concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n    (\\<forall>sa hb sb.\n        sa \\<noteq> \\<bottom> \\<longrightarrow>\n        sb \\<noteq> \\<bottom> \\<longrightarrow>\n        unfold\\<cdot>h\\<cdot>\n        (sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n        appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n        (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))", "by (simp_all add: po_eq_conv [where 'a=\"'b LList\"])"], ["proof (state)\nthis:\n  (\\<forall>sa.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Nothing) =\n      concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)) \\<and>\n  (\\<forall>sa hb sb.\n      sa \\<noteq> \\<bottom> \\<longrightarrow>\n      sb \\<noteq> \\<bottom> \\<longrightarrow>\n      unfold\\<cdot>h\\<cdot>(sa :!: Just\\<cdot>(Stream\\<cdot>hb\\<cdot>sb)) =\n      appendL\\<cdot>(unfold\\<cdot>hb\\<cdot>sb)\\<cdot>\n      (concatMapL\\<cdot>f'\\<cdot>(unfold\\<cdot>ha\\<cdot>sa)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_concatMapS:\n  \"unstream\\<cdot>(concatMapS\\<cdot>f\\<cdot>a) = concatMapL\\<cdot>(unstream oo f)\\<cdot>(unstream\\<cdot>a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream\\<cdot>(concatMapS\\<cdot>f\\<cdot>a) =\n    concatMapL\\<cdot>(unstream oo f)\\<cdot>(unstream\\<cdot>a)", "by (cases a, simp, simp add: unfold_concatMapStep)"], ["", "lemma concatMapS_defined: \"a \\<noteq> \\<bottom> \\<Longrightarrow> concatMapS\\<cdot>f\\<cdot>a \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> \\<bottom> \\<Longrightarrow>\n    concatMapS\\<cdot>f\\<cdot>a \\<noteq> \\<bottom>", "by (induct a, simp_all)"], ["", "lemma concatMapS_cong:\n  fixes f :: \"'a \\<Rightarrow> ('b, 's) Stream\"\n  fixes g :: \"'a \\<Rightarrow> ('b, 't) Stream\"\n  fixes a :: \"('a, 'u) Stream\"\n  fixes b :: \"('a, 'v) Stream\"\n  shows \"(\\<And>x. f x \\<approx> g x) \\<Longrightarrow> a \\<approx> b \\<Longrightarrow> cont f \\<Longrightarrow> cont g \\<Longrightarrow>\n    concatMapS\\<cdot>(\\<Lambda> x. f x)\\<cdot>a \\<approx> concatMapS\\<cdot>(\\<Lambda> x. g x)\\<cdot>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f x \\<approx> g x; a \\<approx> b; cont f;\n     cont g\\<rbrakk>\n    \\<Longrightarrow> concatMapS\\<cdot>(\\<Lambda> x. f x)\\<cdot>a \\<approx>\n                      concatMapS\\<cdot>(\\<Lambda> x. g x)\\<cdot>b", "unfolding bisimilar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                unstream\\<cdot>(f x) = unstream\\<cdot>(g x) \\<and>\n                f x \\<noteq> \\<bottom> \\<and> g x \\<noteq> \\<bottom>;\n     unstream\\<cdot>a = unstream\\<cdot>b \\<and>\n     a \\<noteq> \\<bottom> \\<and> b \\<noteq> \\<bottom>;\n     cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> unstream\\<cdot>\n                      (concatMapS\\<cdot>(Abs_cfun f)\\<cdot>a) =\n                      unstream\\<cdot>\n                      (concatMapS\\<cdot>(Abs_cfun g)\\<cdot>b) \\<and>\n                      concatMapS\\<cdot>(Abs_cfun f)\\<cdot>a \\<noteq>\n                      \\<bottom> \\<and>\n                      concatMapS\\<cdot>(Abs_cfun g)\\<cdot>b \\<noteq>\n                      \\<bottom>", "by (simp add: unstream_concatMapS oo_def concatMapS_defined)"], ["", "lemma concatMapL_eq:\n  \"concatMapL\\<cdot>f\\<cdot>xs = unstream\\<cdot>(concatMapS\\<cdot>(stream oo f)\\<cdot>(stream\\<cdot>xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMapL\\<cdot>f\\<cdot>xs =\n    unstream\\<cdot>(concatMapS\\<cdot>(stream oo f)\\<cdot>(stream\\<cdot>xs))", "by (simp add: unstream_concatMapS oo_def eta_cfun)"], ["", "subsection \\<open>Examples\\<close>"], ["", "lemmas stream_eqs =\n  mapL_eq\n  filterL_eq\n  foldrL_eq\n  enumFromToL_eq\n  appendL_eq\n  zipWithL_eq\n  concatMapL_eq"], ["", "lemmas stream_congs =\n  unstream_cong\n  stream_cong\n  stream_unstream_cong\n  mapS_cong\n  filterS_cong\n  foldrS_cong\n  enumFromToS_cong\n  appendS_cong\n  zipWithS_cong\n  concatMapS_cong"], ["", "lemma\n  \"mapL\\<cdot>f oo filterL\\<cdot>p oo mapL\\<cdot>g =\n   unstream oo mapS\\<cdot>f oo filterS\\<cdot>p oo mapS\\<cdot>g oo stream\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapL\\<cdot>f oo filterL\\<cdot>p oo mapL\\<cdot>g =\n    unstream oo mapS\\<cdot>f oo filterS\\<cdot>p oo mapS\\<cdot>g oo stream", "apply (rule cfun_eqI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mapL\\<cdot>f\\<cdot>(filterL\\<cdot>p\\<cdot>(mapL\\<cdot>g\\<cdot>x)) =\n       unstream\\<cdot>\n       (mapS\\<cdot>f\\<cdot>\n        (filterS\\<cdot>p\\<cdot>(mapS\\<cdot>g\\<cdot>(stream\\<cdot>x))))", "apply (unfold stream_eqs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       unstream\\<cdot>\n       (mapS\\<cdot>f\\<cdot>\n        (stream\\<cdot>\n         (unstream\\<cdot>\n          (filterS\\<cdot>p\\<cdot>\n           (stream\\<cdot>\n            (unstream\\<cdot>(mapS\\<cdot>g\\<cdot>(stream\\<cdot>x)))))))) =\n       unstream\\<cdot>\n       (mapS\\<cdot>f\\<cdot>\n        (filterS\\<cdot>p\\<cdot>(mapS\\<cdot>g\\<cdot>(stream\\<cdot>x))))", "apply (intro stream_congs refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  \"foldrL\\<cdot>f\\<cdot>z\\<cdot>(mapL\\<cdot>g\\<cdot>(filterL\\<cdot>p\\<cdot>(enumFromToL\\<cdot>x\\<cdot>y))) =\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>(mapS\\<cdot>g\\<cdot>(filterS\\<cdot>p\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldrL\\<cdot>f\\<cdot>z\\<cdot>\n    (mapL\\<cdot>g\\<cdot>\n     (filterL\\<cdot>p\\<cdot>(enumFromToL\\<cdot>x\\<cdot>y))) =\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>\n    (mapS\\<cdot>g\\<cdot>\n     (filterS\\<cdot>p\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y)))", "apply (unfold stream_eqs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldrS\\<cdot>f\\<cdot>z\\<cdot>\n    (stream\\<cdot>\n     (unstream\\<cdot>\n      (mapS\\<cdot>g\\<cdot>\n       (stream\\<cdot>\n        (unstream\\<cdot>\n         (filterS\\<cdot>p\\<cdot>\n          (stream\\<cdot>\n           (unstream\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y))))))))) =\n    foldrS\\<cdot>f\\<cdot>z\\<cdot>\n    (mapS\\<cdot>g\\<cdot>\n     (filterS\\<cdot>p\\<cdot>(enumFromToS\\<cdot>x\\<cdot>y)))", "apply (intro stream_congs refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma oo_LAM [simp]: \"cont g \\<Longrightarrow> f oo (\\<Lambda> x. g x) = (\\<Lambda> x. f\\<cdot>(g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont g \\<Longrightarrow>\n    f oo (\\<Lambda> x. g x) = (\\<Lambda> x. f\\<cdot>(g x))", "unfolding oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont g \\<Longrightarrow>\n    (\\<Lambda> f g x. f\\<cdot>(g\\<cdot>x))\\<cdot>f\\<cdot>\n    (\\<Lambda> x. g x) =\n    (\\<Lambda> x. f\\<cdot>(g x))", "by simp"], ["", "lemma\n  \"concatMapL\\<cdot>(\\<Lambda> k.\n    mapL\\<cdot>(\\<Lambda> m. f\\<cdot>k\\<cdot>m)\\<cdot>(enumFromToL\\<cdot>one\\<cdot>k))\\<cdot>(enumFromToL\\<cdot>one\\<cdot>n) =\n   unstream\\<cdot>(concatMapS\\<cdot>(\\<Lambda> k.\n    mapS\\<cdot>(\\<Lambda> m. f\\<cdot>k\\<cdot>m)\\<cdot>(enumFromToS\\<cdot>one\\<cdot>k))\\<cdot>(enumFromToS\\<cdot>one\\<cdot>n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMapL\\<cdot>\n    (\\<Lambda> k.\n        mapL\\<cdot>(\\<Lambda> m. f\\<cdot>k\\<cdot>m)\\<cdot>\n        (enumFromToL\\<cdot>one\\<cdot>k))\\<cdot>\n    (enumFromToL\\<cdot>one\\<cdot>n) =\n    unstream\\<cdot>\n    (concatMapS\\<cdot>\n     (\\<Lambda> k.\n         mapS\\<cdot>(\\<Lambda> m. f\\<cdot>k\\<cdot>m)\\<cdot>\n         (enumFromToS\\<cdot>one\\<cdot>k))\\<cdot>\n     (enumFromToS\\<cdot>one\\<cdot>n))", "unfolding stream_eqs"], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream\\<cdot>\n    (concatMapS\\<cdot>\n     (stream oo\n      (\\<Lambda> k.\n          unstream\\<cdot>\n          (mapS\\<cdot>(Abs_cfun (Rep_cfun (f\\<cdot>k)))\\<cdot>\n           (stream\\<cdot>\n            (unstream\\<cdot>(enumFromToS\\<cdot>one\\<cdot>k))))))\\<cdot>\n     (stream\\<cdot>(unstream\\<cdot>(enumFromToS\\<cdot>one\\<cdot>n)))) =\n    unstream\\<cdot>\n    (concatMapS\\<cdot>\n     (\\<Lambda> k.\n         mapS\\<cdot>(\\<Lambda> m. f\\<cdot>k\\<cdot>m)\\<cdot>\n         (enumFromToS\\<cdot>one\\<cdot>k))\\<cdot>\n     (enumFromToS\\<cdot>one\\<cdot>n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream\\<cdot>\n    (concatMapS\\<cdot>\n     (\\<Lambda> k.\n         stream\\<cdot>\n         (unstream\\<cdot>\n          (mapS\\<cdot>(Abs_cfun (Rep_cfun (f\\<cdot>k)))\\<cdot>\n           (stream\\<cdot>\n            (unstream\\<cdot>(enumFromToS\\<cdot>one\\<cdot>k))))))\\<cdot>\n     (stream\\<cdot>(unstream\\<cdot>(enumFromToS\\<cdot>one\\<cdot>n)))) =\n    unstream\\<cdot>\n    (concatMapS\\<cdot>\n     (\\<Lambda> k.\n         mapS\\<cdot>(\\<Lambda> m. f\\<cdot>k\\<cdot>m)\\<cdot>\n         (enumFromToS\\<cdot>one\\<cdot>k))\\<cdot>\n     (enumFromToS\\<cdot>one\\<cdot>n))", "apply (simp add: stream_congs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}