{"file_name": "/home/qj213/afp-2021-10-22/thys/Elliptic_Curves_Group_Law/Elliptic_Test.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Elliptic_Curves_Group_Law", "problem_names": ["lemma (in residues) res_of_natural_eq: \"\\<guillemotleft>n\\<guillemotright>\\<^sub>\\<nat> = int n mod m\"", "lemma (in residues) res_of_integer_eq: \"\\<guillemotleft>i\\<guillemotright> = i mod m\"", "lemma (in residues) res_pow_eq: \"x [^] (n::nat) = x ^ n mod m\"", "lemma (in residues) res_sub_eq: \"(x mod m) \\<ominus> (y mod m) = (x mod m - y mod m) mod m\"", "lemma (in residues) pdouble_residue_eq: \"pdouble a p = mpdouble m a p\"", "lemma (in residues) padd_residue_eq: \"padd a p\\<^sub>1 p\\<^sub>2 = mpadd m a p\\<^sub>1 p\\<^sub>2\"", "lemma fast_ppoint_mult_0 [simp]: \"fast_ppoint_mult m a 0 p = (0, 0, 0)\"", "lemma fast_ppoint_mult_even [simp]:\n  \"n \\<noteq> 0 \\<Longrightarrow> n mod 2 = 0 \\<Longrightarrow>\n   fast_ppoint_mult m a n p = mpdouble m a (fast_ppoint_mult m a (n div 2) p)\"", "lemma fast_ppoint_mult_odd [simp]:\n  \"n \\<noteq> 0 \\<Longrightarrow> n mod 2 \\<noteq> 0 \\<Longrightarrow>\n   fast_ppoint_mult m a n p = mpadd m a p (mpdouble m a (fast_ppoint_mult m a (n div 2) p))\"", "lemma (in residues_prime_gt2) fast_ppoint_mult_closed:\n  assumes \"a \\<in> carrier R\" \"b \\<in> carrier R\" \"on_curvep a b q\"\n  shows \"on_curvep a b (fast_ppoint_mult (int p) a n q)\"", "lemma (in residues_prime_gt2) point_mult_residue_eq:\n  assumes \"a \\<in> carrier R\" \"b \\<in> carrier R\" \"on_curvep a b q\" \"nonsingular a b\"\n  shows \"proj_eq (ppoint_mult a n q) (fast_ppoint_mult (int p) a n q)\"", "lemma (in residues_prime) make_affine_residue_eq:\n  assumes \"in_carrierp q\"\n  shows \"make_affine q = mmake_affine (int p) q\"", "lemma (in residues_prime_gt2) on_curve_residues_eq:\n  \"on_curve a b q = mon_curve (int p) a b q\"", "lemma \"mon_curve m a b (Point gx gy)\"", "lemma \"mmake_affine m (fast_ppoint_mult m a priv (gx, gy, 1)) = Point pubx puby\"", "lemma \"mmake_affine m (fast_ppoint_mult m a order (gx, gy, 1)) = Infinity\""], "translations": [["", "lemma (in residues) res_of_natural_eq: \"\\<guillemotleft>n\\<guillemotright>\\<^sub>\\<nat> = int n mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>n\\<guillemotright>\\<^sub>\\<nat> = int n mod m", "by (induct n)\n    (simp_all add: of_natural_def res_zero_eq res_one_eq res_add_eq mod_add_right_eq)"], ["", "lemma (in residues) res_of_integer_eq: \"\\<guillemotleft>i\\<guillemotright> = i mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>i\\<guillemotright> = i mod m", "by (simp add: of_integer_def res_of_natural_eq res_neg_eq mod_minus_eq)"], ["", "lemma (in residues) res_pow_eq: \"x [^] (n::nat) = x ^ n mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] n = x ^ n mod m", "using m_gt_one"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. x [^] n = x ^ n mod m", "by (induct n)\n    (simp_all add: res_one_eq res_mult_eq mult_ac mod_mult_right_eq)"], ["", "lemma (in residues) res_sub_eq: \"(x mod m) \\<ominus> (y mod m) = (x mod m - y mod m) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod m \\<ominus> y mod m = (x mod m - y mod m) mod m", "by (simp add: minus_eq res_neg_eq res_add_eq mod_minus_eq mod_add_eq mod_diff_eq)"], ["", "definition mpdouble :: \"int \\<Rightarrow> int \\<Rightarrow> int ppoint \\<Rightarrow> int ppoint\" where\n  \"mpdouble m a p =\n     (let (x, y, z) = p\n      in\n        if z = 0 then p\n        else\n          let\n            l = 2 mod m **\\<^bsub>m\\<^esub> y **\\<^bsub>m\\<^esub> z;\n            n = 3 mod m **\\<^bsub>m\\<^esub> x ^^^\\<^bsub>m\\<^esub> 2 ++\\<^bsub>m\\<^esub> a **\\<^bsub>m\\<^esub> z ^^^\\<^bsub>m\\<^esub> 2\n          in\n            (l **\\<^bsub>m\\<^esub> (n ^^^\\<^bsub>m\\<^esub> 2 --\\<^bsub>m\\<^esub> 4 mod m **\\<^bsub>m\\<^esub> x **\\<^bsub>m\\<^esub> y **\\<^bsub>m\\<^esub> l),\n             n **\\<^bsub>m\\<^esub> (6 mod m **\\<^bsub>m\\<^esub> x **\\<^bsub>m\\<^esub> y **\\<^bsub>m\\<^esub> l --\\<^bsub>m\\<^esub> n ^^^\\<^bsub>m\\<^esub> 2) --\\<^bsub>m\\<^esub>\n             2 mod m **\\<^bsub>m\\<^esub> y ^^^\\<^bsub>m\\<^esub> 2 **\\<^bsub>m\\<^esub> l ^^^\\<^bsub>m\\<^esub> 2,\n             l ^^^\\<^bsub>m\\<^esub> 3))\""], ["", "definition mpadd :: \"int \\<Rightarrow> int \\<Rightarrow> int ppoint \\<Rightarrow> int ppoint \\<Rightarrow> int ppoint\" where\n  \"mpadd m a p\\<^sub>1 p\\<^sub>2 =\n     (let\n        (x\\<^sub>1, y\\<^sub>1, z\\<^sub>1) = p\\<^sub>1;\n        (x\\<^sub>2, y\\<^sub>2, z\\<^sub>2) = p\\<^sub>2\n      in\n        if z\\<^sub>1 = 0 then p\\<^sub>2\n        else if z\\<^sub>2 = 0 then p\\<^sub>1\n        else\n          let\n            d\\<^sub>1 = x\\<^sub>2 **\\<^bsub>m\\<^esub> z\\<^sub>1;\n            d\\<^sub>2 = x\\<^sub>1 **\\<^bsub>m\\<^esub> z\\<^sub>2;\n            l = d\\<^sub>1 --\\<^bsub>m\\<^esub> d\\<^sub>2;\n            n = y\\<^sub>2 **\\<^bsub>m\\<^esub> z\\<^sub>1 --\\<^bsub>m\\<^esub> y\\<^sub>1 **\\<^bsub>m\\<^esub> z\\<^sub>2\n          in\n            if l = 0 then\n              if n = 0 then mpdouble m a p\\<^sub>1\n              else (0, 0, 0)\n            else\n              let h = n ^^^\\<^bsub>m\\<^esub> 2 **\\<^bsub>m\\<^esub> z\\<^sub>1 **\\<^bsub>m\\<^esub> z\\<^sub>2 --\\<^bsub>m\\<^esub> (d\\<^sub>1 ++\\<^bsub>m\\<^esub> d\\<^sub>2) **\\<^bsub>m\\<^esub> l ^^^\\<^bsub>m\\<^esub> 2\n              in\n                (l **\\<^bsub>m\\<^esub> h,\n                 (d\\<^sub>2 **\\<^bsub>m\\<^esub> l ^^^\\<^bsub>m\\<^esub> 2 --\\<^bsub>m\\<^esub> h) **\\<^bsub>m\\<^esub> n --\\<^bsub>m\\<^esub> l ^^^\\<^bsub>m\\<^esub> 3 **\\<^bsub>m\\<^esub> y\\<^sub>1 **\\<^bsub>m\\<^esub> z\\<^sub>2,\n                 l ^^^\\<^bsub>m\\<^esub> 3 **\\<^bsub>m\\<^esub> z\\<^sub>1 **\\<^bsub>m\\<^esub> z\\<^sub>2))\""], ["", "lemma (in residues) pdouble_residue_eq: \"pdouble a p = mpdouble m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdouble a p = mpdouble m a p", "by (simp only: pdouble_def mpdouble_def\n    madd_def mmult_def msub_def mpow_def res_zero_eq res_add_eq res_mult_eq res_of_integer_eq\n    res_pow_eq res_sub_eq)"], ["", "lemma (in residues) padd_residue_eq: \"padd a p\\<^sub>1 p\\<^sub>2 = mpadd m a p\\<^sub>1 p\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. padd a p\\<^sub>1 p\\<^sub>2 = mpadd m a p\\<^sub>1 p\\<^sub>2", "by (simp only: padd_def mpadd_def pdouble_residue_eq\n    madd_def mmult_def msub_def mpow_def res_zero_eq res_add_eq res_mult_eq res_of_integer_eq\n    res_pow_eq res_sub_eq Let_def)"], ["", "fun fast_ppoint_mult :: \"int \\<Rightarrow> int \\<Rightarrow> nat \\<Rightarrow> int ppoint \\<Rightarrow> int ppoint\"\nwhere\n  \"fast_ppoint_mult m a n p =\n     (if n = 0 then (0, 0, 0)\n      else if n mod 2 = 0 then mpdouble m a (fast_ppoint_mult m a (n div 2) p)\n      else mpadd m a p (mpdouble m a (fast_ppoint_mult m a (n div 2) p)))\""], ["", "lemma fast_ppoint_mult_0 [simp]: \"fast_ppoint_mult m a 0 p = (0, 0, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_ppoint_mult m a 0 p = (0, 0, 0)", "by simp"], ["", "lemma fast_ppoint_mult_even [simp]:\n  \"n \\<noteq> 0 \\<Longrightarrow> n mod 2 = 0 \\<Longrightarrow>\n   fast_ppoint_mult m a n p = mpdouble m a (fast_ppoint_mult m a (n div 2) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0; n mod 2 = 0\\<rbrakk>\n    \\<Longrightarrow> fast_ppoint_mult m a n p =\n                      mpdouble m a (fast_ppoint_mult m a (n div 2) p)", "by simp"], ["", "lemma fast_ppoint_mult_odd [simp]:\n  \"n \\<noteq> 0 \\<Longrightarrow> n mod 2 \\<noteq> 0 \\<Longrightarrow>\n   fast_ppoint_mult m a n p = mpadd m a p (mpdouble m a (fast_ppoint_mult m a (n div 2) p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fast_ppoint_mult m a n p =\n                      mpadd m a p\n                       (mpdouble m a (fast_ppoint_mult m a (n div 2) p))", "by simp"], ["", "declare fast_ppoint_mult.simps [simp del]"], ["", "locale residues_prime_gt2 = residues_prime +\n  assumes gt2: \"2 < p\""], ["", "sublocale residues_prime_gt2 < ell_field"], ["proof (prove)\ngoal (1 subgoal):\n 1. ell_field R", "using gt2"], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. ell_field R", "by unfold_locales (simp add: res_of_integer_eq res_zero_eq)"], ["", "lemma (in residues_prime_gt2) fast_ppoint_mult_closed:\n  assumes \"a \\<in> carrier R\" \"b \\<in> carrier R\" \"on_curvep a b q\"\n  shows \"on_curvep a b (fast_ppoint_mult (int p) a n q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. on_curvep a b (fast_ppoint_mult (int p) a n q)", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n\ngoal (1 subgoal):\n 1. on_curvep a b (fast_ppoint_mult (int p) a n q)", "proof (induct \"int p\" a n q rule: fast_ppoint_mult.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n pa.\n       \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R;\n                 b \\<in> carrier R; on_curvep a b pa\\<rbrakk>\n                \\<Longrightarrow> on_curvep a b\n                                   (fast_ppoint_mult (int p) a (n div 2)\n                                     pa);\n        \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n         b \\<in> carrier R; on_curvep a b pa\\<rbrakk>\n        \\<Longrightarrow> on_curvep a b\n                           (fast_ppoint_mult (int p) a (n div 2) pa);\n        a \\<in> carrier R; b \\<in> carrier R; on_curvep a b pa\\<rbrakk>\n       \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a n pa)", "case (1 a n q)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R; b \\<in> carrier R;\n   on_curvep a b q\\<rbrakk>\n  \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a (n div 2) q)\n  \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n   b \\<in> carrier R; on_curvep a b q\\<rbrakk>\n  \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a (n div 2) q)\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n\ngoal (1 subgoal):\n 1. \\<And>a n pa.\n       \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R;\n                 b \\<in> carrier R; on_curvep a b pa\\<rbrakk>\n                \\<Longrightarrow> on_curvep a b\n                                   (fast_ppoint_mult (int p) a (n div 2)\n                                     pa);\n        \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n         b \\<in> carrier R; on_curvep a b pa\\<rbrakk>\n        \\<Longrightarrow> on_curvep a b\n                           (fast_ppoint_mult (int p) a (n div 2) pa);\n        a \\<in> carrier R; b \\<in> carrier R; on_curvep a b pa\\<rbrakk>\n       \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a n pa)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_curvep a b (fast_ppoint_mult (int p) a n q)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a n q)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    on_curvep a b (fast_ppoint_mult (int p) a n q)", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a n q)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    on_curvep a b (fast_ppoint_mult (int p) a n q)", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. on_curvep a b (fast_ppoint_mult (int p) a n q)", "using m_gt_one"], ["proof (prove)\nusing this:\n  n = 0\n  1 < int p\n\ngoal (1 subgoal):\n 1. on_curvep a b (fast_ppoint_mult (int p) a n q)", "by (simp add: on_curvep_infinity [simplified res_zero_eq] res_carrier_eq)"], ["proof (state)\nthis:\n  on_curvep a b (fast_ppoint_mult (int p) a n q)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    on_curvep a b (fast_ppoint_mult (int p) a n q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    on_curvep a b (fast_ppoint_mult (int p) a n q)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    on_curvep a b (fast_ppoint_mult (int p) a n q)", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R; b \\<in> carrier R;\n   on_curvep a b q\\<rbrakk>\n  \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a (n div 2) q)\n  \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n   b \\<in> carrier R; on_curvep a b q\\<rbrakk>\n  \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a (n div 2) q)\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  n \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R; b \\<in> carrier R;\n   on_curvep a b q\\<rbrakk>\n  \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a (n div 2) q)\n  \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n   b \\<in> carrier R; on_curvep a b q\\<rbrakk>\n  \\<Longrightarrow> on_curvep a b (fast_ppoint_mult (int p) a (n div 2) q)\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. on_curvep a b (fast_ppoint_mult (int p) a n q)", "by (cases \"n mod 2 = 0\")\n        (simp_all add: padd_residue_eq [symmetric] pdouble_residue_eq [symmetric]\n          padd_closed pdouble_closed)"], ["proof (state)\nthis:\n  on_curvep a b (fast_ppoint_mult (int p) a n q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  on_curvep a b (fast_ppoint_mult (int p) a n q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in residues_prime_gt2) point_mult_residue_eq:\n  assumes \"a \\<in> carrier R\" \"b \\<in> carrier R\" \"on_curvep a b q\" \"nonsingular a b\"\n  shows \"proj_eq (ppoint_mult a n q) (fast_ppoint_mult (int p) a n q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_eq (ppoint_mult a n q) (fast_ppoint_mult (int p) a n q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_eq (ppoint_mult a n q) (fast_ppoint_mult (int p) a n q)", "from assms"], ["proof (chain)\npicking this:\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  nonsingular a b", "have \"point_mult a n (make_affine q) = make_affine (fast_ppoint_mult (int p) a n q)\""], ["proof (prove)\nusing this:\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  nonsingular a b\n\ngoal (1 subgoal):\n 1. point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "proof (induct \"int p\" a n q rule: fast_ppoint_mult.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n pa.\n       \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R;\n                 b \\<in> carrier R; on_curvep a b pa;\n                 nonsingular a b\\<rbrakk>\n                \\<Longrightarrow> point_mult a (n div 2) (make_affine pa) =\n                                  make_affine\n                                   (fast_ppoint_mult (int p) a (n div 2)\n                                     pa);\n        \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n         b \\<in> carrier R; on_curvep a b pa; nonsingular a b\\<rbrakk>\n        \\<Longrightarrow> point_mult a (n div 2) (make_affine pa) =\n                          make_affine\n                           (fast_ppoint_mult (int p) a (n div 2) pa);\n        a \\<in> carrier R; b \\<in> carrier R; on_curvep a b pa;\n        nonsingular a b\\<rbrakk>\n       \\<Longrightarrow> point_mult a n (make_affine pa) =\n                         make_affine (fast_ppoint_mult (int p) a n pa)", "case (1 a n q)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R; b \\<in> carrier R;\n   on_curvep a b q; nonsingular a b\\<rbrakk>\n  \\<Longrightarrow> point_mult a (n div 2) (make_affine q) =\n                    make_affine (fast_ppoint_mult (int p) a (n div 2) q)\n  \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n   b \\<in> carrier R; on_curvep a b q; nonsingular a b\\<rbrakk>\n  \\<Longrightarrow> point_mult a (n div 2) (make_affine q) =\n                    make_affine (fast_ppoint_mult (int p) a (n div 2) q)\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  nonsingular a b\n\ngoal (1 subgoal):\n 1. \\<And>a n pa.\n       \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R;\n                 b \\<in> carrier R; on_curvep a b pa;\n                 nonsingular a b\\<rbrakk>\n                \\<Longrightarrow> point_mult a (n div 2) (make_affine pa) =\n                                  make_affine\n                                   (fast_ppoint_mult (int p) a (n div 2)\n                                     pa);\n        \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n         b \\<in> carrier R; on_curvep a b pa; nonsingular a b\\<rbrakk>\n        \\<Longrightarrow> point_mult a (n div 2) (make_affine pa) =\n                          make_affine\n                           (fast_ppoint_mult (int p) a (n div 2) pa);\n        a \\<in> carrier R; b \\<in> carrier R; on_curvep a b pa;\n        nonsingular a b\\<rbrakk>\n       \\<Longrightarrow> point_mult a n (make_affine pa) =\n                         make_affine (fast_ppoint_mult (int p) a n pa)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "by (simp add: make_affine_infinity [simplified res_zero_eq])"], ["proof (state)\nthis:\n  point_mult a n (make_affine q) =\n  make_affine (fast_ppoint_mult (int p) a n q)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "have \"point_mult a n (make_affine q) =\n        point_mult a (n div 2 * 2 + n mod 2) (make_affine q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point_mult a n (make_affine q) =\n    point_mult a (n div 2 * 2 + n mod 2) (make_affine q)", "by simp"], ["proof (state)\nthis:\n  point_mult a n (make_affine q) =\n  point_mult a (n div 2 * 2 + n mod 2) (make_affine q)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "also"], ["proof (state)\nthis:\n  point_mult a n (make_affine q) =\n  point_mult a (n div 2 * 2 + n mod 2) (make_affine q)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "from 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R; b \\<in> carrier R;\n   on_curvep a b q; nonsingular a b\\<rbrakk>\n  \\<Longrightarrow> point_mult a (n div 2) (make_affine q) =\n                    make_affine (fast_ppoint_mult (int p) a (n div 2) q)\n  \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n   b \\<in> carrier R; on_curvep a b q; nonsingular a b\\<rbrakk>\n  \\<Longrightarrow> point_mult a (n div 2) (make_affine q) =\n                    make_affine (fast_ppoint_mult (int p) a (n div 2) q)\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  nonsingular a b", "have \"\\<dots> = add a (point_mult a 2 (point_mult a (n div 2) (make_affine q)))\n        (point_mult a (n mod 2) (make_affine q))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R; b \\<in> carrier R;\n   on_curvep a b q; nonsingular a b\\<rbrakk>\n  \\<Longrightarrow> point_mult a (n div 2) (make_affine q) =\n                    make_affine (fast_ppoint_mult (int p) a (n div 2) q)\n  \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n   b \\<in> carrier R; on_curvep a b q; nonsingular a b\\<rbrakk>\n  \\<Longrightarrow> point_mult a (n div 2) (make_affine q) =\n                    make_affine (fast_ppoint_mult (int p) a (n div 2) q)\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  nonsingular a b\n\ngoal (1 subgoal):\n 1. point_mult a (n div 2 * 2 + n mod 2) (make_affine q) =\n    local.add a (point_mult a 2 (point_mult a (n div 2) (make_affine q)))\n     (point_mult a (n mod 2) (make_affine q))", "by (simp only: point_mult_mult point_mult_add\n          on_curvep_iff_on_curve [symmetric] on_curvep_imp_in_carrierp)"], ["proof (state)\nthis:\n  point_mult a (n div 2 * 2 + n mod 2) (make_affine q) =\n  local.add a (point_mult a 2 (point_mult a (n div 2) (make_affine q)))\n   (point_mult a (n mod 2) (make_affine q))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "also"], ["proof (state)\nthis:\n  point_mult a (n div 2 * 2 + n mod 2) (make_affine q) =\n  local.add a (point_mult a 2 (point_mult a (n div 2) (make_affine q)))\n   (point_mult a (n mod 2) (make_affine q))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "have \"\\<dots> = make_affine (fast_ppoint_mult (int p) a n q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.add a (point_mult a 2 (point_mult a (n div 2) (make_affine q)))\n     (point_mult a (n mod 2) (make_affine q)) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "using 1 False"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<noteq> 0; n mod 2 = 0; a \\<in> carrier R; b \\<in> carrier R;\n   on_curvep a b q; nonsingular a b\\<rbrakk>\n  \\<Longrightarrow> point_mult a (n div 2) (make_affine q) =\n                    make_affine (fast_ppoint_mult (int p) a (n div 2) q)\n  \\<lbrakk>n \\<noteq> 0; n mod 2 \\<noteq> 0; a \\<in> carrier R;\n   b \\<in> carrier R; on_curvep a b q; nonsingular a b\\<rbrakk>\n  \\<Longrightarrow> point_mult a (n div 2) (make_affine q) =\n                    make_affine (fast_ppoint_mult (int p) a (n div 2) q)\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  nonsingular a b\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. local.add a (point_mult a 2 (point_mult a (n div 2) (make_affine q)))\n     (point_mult a (n mod 2) (make_affine q)) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "by (cases \"n mod 2 = 0\")\n          (simp_all add: padd_residue_eq [symmetric] pdouble_residue_eq [symmetric] add_0_r\n             padd_correct pdouble_correct\n             fast_ppoint_mult_closed on_curvep_imp_in_carrierp [of a b]\n             point_mult2_eq_double pdouble_closed\n             add_assoc [symmetric] add_comm add_comm' on_curvep_iff_on_curve [symmetric])"], ["proof (state)\nthis:\n  local.add a (point_mult a 2 (point_mult a (n div 2) (make_affine q)))\n   (point_mult a (n mod 2) (make_affine q)) =\n  make_affine (fast_ppoint_mult (int p) a n q)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "finally"], ["proof (chain)\npicking this:\n  point_mult a n (make_affine q) =\n  make_affine (fast_ppoint_mult (int p) a n q)", "show ?thesis"], ["proof (prove)\nusing this:\n  point_mult a n (make_affine q) =\n  make_affine (fast_ppoint_mult (int p) a n q)\n\ngoal (1 subgoal):\n 1. point_mult a n (make_affine q) =\n    make_affine (fast_ppoint_mult (int p) a n q)", "."], ["proof (state)\nthis:\n  point_mult a n (make_affine q) =\n  make_affine (fast_ppoint_mult (int p) a n q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  point_mult a n (make_affine q) =\n  make_affine (fast_ppoint_mult (int p) a n q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  point_mult a n (make_affine q) =\n  make_affine (fast_ppoint_mult (int p) a n q)\n\ngoal (1 subgoal):\n 1. proj_eq (ppoint_mult a n q) (fast_ppoint_mult (int p) a n q)", "with assms"], ["proof (chain)\npicking this:\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  nonsingular a b\n  point_mult a n (make_affine q) =\n  make_affine (fast_ppoint_mult (int p) a n q)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> carrier R\n  b \\<in> carrier R\n  on_curvep a b q\n  nonsingular a b\n  point_mult a n (make_affine q) =\n  make_affine (fast_ppoint_mult (int p) a n q)\n\ngoal (1 subgoal):\n 1. proj_eq (ppoint_mult a n q) (fast_ppoint_mult (int p) a n q)", "by (simp add: make_affine_proj_eq_iff fast_ppoint_mult_closed\n      ppoint_mult_correct on_curvep_imp_in_carrierp [of a b])"], ["proof (state)\nthis:\n  proj_eq (ppoint_mult a n q) (fast_ppoint_mult (int p) a n q)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mmake_affine :: \"int \\<Rightarrow> int ppoint \\<Rightarrow> int point\" where\n  \"mmake_affine q p =\n     (let (x, y, z) = p\n      in if z = 0 then Infinity else\n        let (a, b) = bezout_coefficients z q\n        in Point (a **\\<^bsub>q\\<^esub> x) (a **\\<^bsub>q\\<^esub>y))\""], ["", "lemma (in residues_prime) make_affine_residue_eq:\n  assumes \"in_carrierp q\"\n  shows \"make_affine q = mmake_affine (int p) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_affine q = mmake_affine (int p) q", "proof (cases q)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       q = (a, b, c) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "case (fields x y z)"], ["proof (state)\nthis:\n  q = (x, y, z)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       q = (a, b, c) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. make_affine q = mmake_affine (int p) q", "proof (cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> make_affine q = mmake_affine (int p) q\n 2. z \\<noteq> 0 \\<Longrightarrow> make_affine q = mmake_affine (int p) q", "case True"], ["proof (state)\nthis:\n  z = 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> make_affine q = mmake_affine (int p) q\n 2. z \\<noteq> 0 \\<Longrightarrow> make_affine q = mmake_affine (int p) q", "with fields"], ["proof (chain)\npicking this:\n  q = (x, y, z)\n  z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  q = (x, y, z)\n  z = 0\n\ngoal (1 subgoal):\n 1. make_affine q = mmake_affine (int p) q", "by (simp add: make_affine_def mmake_affine_def res_zero_eq)"], ["proof (state)\nthis:\n  make_affine q = mmake_affine (int p) q\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> make_affine q = mmake_affine (int p) q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> make_affine q = mmake_affine (int p) q", "case False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> make_affine q = mmake_affine (int p) q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. make_affine q = mmake_affine (int p) q", "proof (cases \"bezout_coefficients z (int p)\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       bezout_coefficients z (int p) = (a, b) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "case (Pair a b)"], ["proof (state)\nthis:\n  bezout_coefficients z (int p) = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       bezout_coefficients z (int p) = (a, b) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "with fields False assms"], ["proof (chain)\npicking this:\n  q = (x, y, z)\n  z \\<noteq> 0\n  in_carrierp q\n  bezout_coefficients z (int p) = (a, b)", "have \"\\<not> int p dvd z\""], ["proof (prove)\nusing this:\n  q = (x, y, z)\n  z \\<noteq> 0\n  in_carrierp q\n  bezout_coefficients z (int p) = (a, b)\n\ngoal (1 subgoal):\n 1. \\<not> int p dvd z", "by (auto simp add: in_carrierp_def res_carrier_eq prime_imp_coprime zdvd_not_zless)"], ["proof (state)\nthis:\n  \\<not> int p dvd z\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       bezout_coefficients z (int p) = (a, b) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "with p_prime"], ["proof (chain)\npicking this:\n  prime p\n  \\<not> int p dvd z", "have \"coprime (int p) z\""], ["proof (prove)\nusing this:\n  prime p\n  \\<not> int p dvd z\n\ngoal (1 subgoal):\n 1. coprime (int p) z", "by (auto intro: prime_imp_coprime)"], ["proof (state)\nthis:\n  coprime (int p) z\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       bezout_coefficients z (int p) = (a, b) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "then"], ["proof (chain)\npicking this:\n  coprime (int p) z", "have \"coprime z (int p)\""], ["proof (prove)\nusing this:\n  coprime (int p) z\n\ngoal (1 subgoal):\n 1. coprime z (int p)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  coprime z (int p)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       bezout_coefficients z (int p) = (a, b) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "then"], ["proof (chain)\npicking this:\n  coprime z (int p)", "have \"fst (bezout_coefficients z (int p)) * z +\n        snd (bezout_coefficients z (int p)) * int p = 1\""], ["proof (prove)\nusing this:\n  coprime z (int p)\n\ngoal (1 subgoal):\n 1. fst (bezout_coefficients z (int p)) * z +\n    snd (bezout_coefficients z (int p)) * int p =\n    1", "by (simp add: bezout_coefficients_fst_snd)"], ["proof (state)\nthis:\n  fst (bezout_coefficients z (int p)) * z +\n  snd (bezout_coefficients z (int p)) * int p =\n  1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       bezout_coefficients z (int p) = (a, b) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "with m_gt_one"], ["proof (chain)\npicking this:\n  1 < int p\n  fst (bezout_coefficients z (int p)) * z +\n  snd (bezout_coefficients z (int p)) * int p =\n  1", "have \"fst (bezout_coefficients z (int p)) * z mod int p = 1\""], ["proof (prove)\nusing this:\n  1 < int p\n  fst (bezout_coefficients z (int p)) * z +\n  snd (bezout_coefficients z (int p)) * int p =\n  1\n\ngoal (1 subgoal):\n 1. fst (bezout_coefficients z (int p)) * z mod int p = 1", "by (auto dest: arg_cong [of _ _ \"\\<lambda>x. x mod int p\"])"], ["proof (state)\nthis:\n  fst (bezout_coefficients z (int p)) * z mod int p = 1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       bezout_coefficients z (int p) = (a, b) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "then"], ["proof (chain)\npicking this:\n  fst (bezout_coefficients z (int p)) * z mod int p = 1", "have \"z \\<otimes> (fst (bezout_coefficients z (int p)) mod int p) = \\<one>\""], ["proof (prove)\nusing this:\n  fst (bezout_coefficients z (int p)) * z mod int p = 1\n\ngoal (1 subgoal):\n 1. z \\<otimes> (fst (bezout_coefficients z (int p)) mod int p) = \\<one>", "by (simp add: res_mult_eq res_one_eq mult.commute mod_mult_right_eq)"], ["proof (state)\nthis:\n  z \\<otimes> (fst (bezout_coefficients z (int p)) mod int p) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       bezout_coefficients z (int p) = (a, b) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "with fields assms"], ["proof (chain)\npicking this:\n  q = (x, y, z)\n  in_carrierp q\n  z \\<otimes> (fst (bezout_coefficients z (int p)) mod int p) = \\<one>", "have \"inv z = fst (bezout_coefficients z (int p)) mod int p\""], ["proof (prove)\nusing this:\n  q = (x, y, z)\n  in_carrierp q\n  z \\<otimes> (fst (bezout_coefficients z (int p)) mod int p) = \\<one>\n\ngoal (1 subgoal):\n 1. inv z = fst (bezout_coefficients z (int p)) mod int p", "by (simp add: inverse_unique in_carrierp_def res_carrier_eq)"], ["proof (state)\nthis:\n  inv z = fst (bezout_coefficients z (int p)) mod int p\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       bezout_coefficients z (int p) = (a, b) \\<Longrightarrow>\n       make_affine q = mmake_affine (int p) q", "with fields Pair False"], ["proof (chain)\npicking this:\n  q = (x, y, z)\n  bezout_coefficients z (int p) = (a, b)\n  z \\<noteq> 0\n  inv z = fst (bezout_coefficients z (int p)) mod int p", "show ?thesis"], ["proof (prove)\nusing this:\n  q = (x, y, z)\n  bezout_coefficients z (int p) = (a, b)\n  z \\<noteq> 0\n  inv z = fst (bezout_coefficients z (int p)) mod int p\n\ngoal (1 subgoal):\n 1. make_affine q = mmake_affine (int p) q", "by (simp add: make_affine_def mmake_affine_def res_zero_eq m_div_def\n          res_mult_eq mmult_def mod_mult_right_eq mult.commute)"], ["proof (state)\nthis:\n  make_affine q = mmake_affine (int p) q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  make_affine q = mmake_affine (int p) q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  make_affine q = mmake_affine (int p) q\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mon_curve :: \"int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int point \\<Rightarrow> bool\" where\n  \"mon_curve m a b p = (case p of\n       Infinity \\<Rightarrow> True\n     | Point x y \\<Rightarrow> 0 \\<le> x \\<and> x < m \\<and> 0 \\<le> y \\<and> y < m \\<and>\n         y ^^^\\<^bsub>m\\<^esub> 2 = x ^^^\\<^bsub>m\\<^esub> 3 ++\\<^bsub>m\\<^esub> a **\\<^bsub>m\\<^esub> x ++\\<^bsub>m\\<^esub> b)\""], ["", "lemma (in residues_prime_gt2) on_curve_residues_eq:\n  \"on_curve a b q = mon_curve (int p) a b q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. on_curve a b q = mon_curve (int p) a b q", "by (simp add: on_curve_def mon_curve_def res_carrier_eq res_add_eq res_mult_eq res_pow_eq\n    madd_def mmult_def mpow_def split: point.split)"], ["", "subsection \\<open>The NIST Curve P-521\\<close>"], ["", "text \\<open>\nThe following test data is taken from RFC 5903 \\cite{RFC5903}, \\S 3.3 and \\S 8.3.\nThe curve parameters can also be found in \\S D.1.2.5 of FIPS PUB 186-4 \\cite{FIPS186-4}.\n\\<close>"], ["", "definition m :: int where\n  \"m = 0x01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\""], ["", "definition a :: int where\n  \"a = m - 3\""], ["", "definition b :: int where\n  \"b = 0x0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\""], ["", "definition gx :: int where\n  \"gx = 0x00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\""], ["", "definition gy :: int where\n  \"gy = 0x011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\""], ["", "definition priv :: nat where\n  \"priv = 0x0037ADE9319A89F4DABDB3EF411AACCCA5123C61ACAB57B5393DCE47608172A095AA85A30FE1C2952C6771D937BA9777F5957B2639BAB072462F68C27A57382D4A52\""], ["", "definition pubx :: int where\n  \"pubx = 0x0015417E84DBF28C0AD3C278713349DC7DF153C897A1891BD98BAB4357C9ECBEE1E3BF42E00B8E380AEAE57C2D107564941885942AF5A7F4601723C4195D176CED3E\""], ["", "definition puby :: int where\n  \"puby = 0x017CAE20B6641D2EEB695786D8C946146239D099E18E1D5A514C739D7CB4A10AD8A788015AC405D7799DC75E7B7D5B6CF2261A6A7F1507438BF01BEB6CA3926F9582\""], ["", "definition order :: nat where\n  \"order = 0x01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\""], ["", "lemma \"mon_curve m a b (Point gx gy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_curve m a b (Point gx gy)", "by eval"], ["", "lemma \"mmake_affine m (fast_ppoint_mult m a priv (gx, gy, 1)) = Point pubx puby\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmake_affine m (fast_ppoint_mult m a priv (gx, gy, 1)) = Point pubx puby", "by eval"], ["", "lemma \"mmake_affine m (fast_ppoint_mult m a order (gx, gy, 1)) = Infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmake_affine m (fast_ppoint_mult m a Elliptic_Test.order (gx, gy, 1)) =\n    Infinity", "by eval"], ["", "end"]]}