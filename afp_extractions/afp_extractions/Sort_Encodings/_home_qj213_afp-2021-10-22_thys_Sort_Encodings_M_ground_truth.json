{"file_name": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings/M.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings", "problem_names": ["lemma wtC_append[simp]: \"wtC (c1 @ c2) \\<longleftrightarrow> wtC c1 \\<and> wtC c2\"", "lemma wtPB_Un[simp]: \"wtPB (\\<Phi>1 \\<union> \\<Phi>2) \\<longleftrightarrow> wtPB \\<Phi>1 \\<and> wtPB \\<Phi>2\"", "lemma wtPB_UN[simp]: \"wtPB (\\<Union> i \\<in> I. \\<Phi> i) \\<longleftrightarrow> (\\<forall> i \\<in> I. wtPB (\\<Phi> i))\"", "lemma wtPB_sappend[simp]:\nassumes \"wtPB \\<Phi>1\" and \"wtPB \\<Phi>2\"  shows \"wtPB (\\<Phi>1 @@ \\<Phi>2)\"", "lemma wtSB_wt[simp]: \"wtSB \\<pi> \\<Longrightarrow> wt (\\<pi> x)\"", "lemma wtSB_tpOf[simp]: \"wtSB \\<pi> \\<Longrightarrow> tpOf (\\<pi> x) = tpOfV x\"", "lemma wt_tpOf_subst:\nassumes \"wtSB \\<pi>\" and \"wt T\"\nshows \"wt (subst \\<pi> T) \\<and> tpOf (subst \\<pi> T) = tpOf T\"", "lemmas wt_subst[simp] = wt_tpOf_subst[THEN conjunct1]", "lemmas tpOf_subst[simp] = wt_tpOf_subst[THEN conjunct2]", "lemma wtSB_o:\nassumes 1: \"wtSB \\<pi>1\" and 2: \"wtSB \\<pi>2\"\nshows \"wtSB (subst \\<pi>1 o \\<pi>2)\"", "lemma length_getTvars[simp]: \"length (getTvars \\<sigma>l) = length \\<sigma>l\"", "lemma wt_getTvars[simp]: \"list_all wt (getTvars \\<sigma>l)\"", "lemma wt_nth_getTvars[simp]:\n\"i < length \\<sigma>l \\<Longrightarrow> wt (getTvars \\<sigma>l ! i)\"", "lemma map_tpOf_getTvars[simp]: \"map tpOf (getTvars \\<sigma>l) = \\<sigma>l\"", "lemma tpOf_nth_getTvars[simp]:\n\"i < length \\<sigma>l \\<Longrightarrow> tpOf (getTvars \\<sigma>l ! i) = \\<sigma>l ! i\"", "lemma wtTE_intT[simp]: \"wtE \\<xi> \\<Longrightarrow> intT (tpOfV x) (\\<xi> x)\"", "lemma pickT[simp]: \"intT \\<sigma> (pickT \\<sigma>)\"", "lemma ex_pickE:\nassumes \"length xl = length al\"\nand \"distinct xl\" and \"\\<And> i. i < length xl \\<Longrightarrow> intT (tpOfV (xl!i)) (al!i)\"\nshows \"\\<exists> \\<xi>. wtE \\<xi> \\<and> (\\<forall> i < length xl. \\<xi> (xl!i) = al!i)\"", "lemma wtE_pickE_pickE:\nassumes \"length xl = length al\"\nand \"distinct xl\" and \"\\<And> i. i < length xl \\<Longrightarrow> intT (tpOfV (xl!i)) (al!i)\"\nshows \"wtE (pickE xl al) \\<and> (\\<forall> i. i < length xl \\<longrightarrow> pickE xl al (xl!i) = al!i)\"", "lemmas wtE_pickE[simp] = wtE_pickE_pickE[THEN conjunct1]", "lemma pickE[simp]:\nassumes \"length xl = length al\"\nand \"distinct xl\" and \"\\<And> i. i < length xl \\<Longrightarrow> intT (tpOfV (xl!i)) (al!i)\"\nand \"i < length xl\"\nshows \"pickE xl al (xl!i) = al!i\"", "lemma wtE_pickAnyE[simp]: \"wtE pickAnyE\"", "lemma satC_append[simp]: \"satC \\<xi> (c1 @ c2) \\<longleftrightarrow> satC \\<xi> c1 \\<or> satC \\<xi> c2\"", "lemma satC_iff_set: \"satC \\<xi> c \\<longleftrightarrow> (\\<exists> l \\<in> set c. satL \\<xi> l)\"", "lemma satPB_Un[simp]: \"satPB \\<xi> (\\<Phi>1 \\<union> \\<Phi>2) \\<longleftrightarrow> satPB \\<xi> \\<Phi>1 \\<and> satPB \\<xi> \\<Phi>2\"", "lemma satPB_UN[simp]: \"satPB \\<xi> (\\<Union> i \\<in> I. \\<Phi> i) \\<longleftrightarrow> (\\<forall> i \\<in> I. satPB \\<xi> (\\<Phi> i))\"", "lemma satPB_sappend[simp]: \"satPB \\<xi> (\\<Phi>1 @@ \\<Phi>2) \\<longleftrightarrow> satPB \\<xi> \\<Phi>1 \\<or> satPB \\<xi> \\<Phi>2\"", "lemma SAT_UN[simp]: \"SAT (\\<Union> i \\<in> I. \\<Phi> i) \\<longleftrightarrow> (\\<forall> i \\<in> I. SAT (\\<Phi> i))\"", "lemma wt_int:\nassumes wtE: \"wtE \\<xi>\" and wt: \"wt T\"\nshows \"intT (tpOf T) (int \\<xi> T)\"", "lemma int_cong:\nassumes \"\\<And>x. x \\<in> vars T \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"int \\<xi>1 T = int \\<xi>2 T\"", "lemma satA_cong:\nassumes \"\\<And>x. x \\<in> varsA at \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"satA \\<xi>1 at \\<longleftrightarrow> satA \\<xi>2 at\"", "lemma satL_cong:\nassumes \"\\<And> x. x \\<in> varsL l \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"satL \\<xi>1 l \\<longleftrightarrow> satL \\<xi>2 l\"", "lemma satC_cong:\nassumes \"\\<And> x. x \\<in> varsC c \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"satC \\<xi>1 c \\<longleftrightarrow> satC \\<xi>2 c\"", "lemma satPB_cong:\nassumes \"\\<And> x. x \\<in> varsPB \\<Phi> \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"satPB \\<xi>1 \\<Phi> \\<longleftrightarrow> satPB \\<xi>2 \\<Phi>\"", "lemma int_o:\n\"int (int \\<xi> o \\<rho>) T = int \\<xi> (subst \\<rho> T)\"", "lemmas int_subst = int_o[symmetric]", "lemma int_o_subst:\n\"int \\<xi> o subst \\<rho> = int (int \\<xi> o \\<rho>)\"", "lemma satA_o:\n\"satA (int \\<xi> o \\<rho>) at = satA \\<xi> (substA \\<rho> at)\"", "lemmas satA_subst = satA_o[symmetric]", "lemma satA_o_subst:\n\"satA \\<xi> o substA \\<rho> = satA (int \\<xi> o \\<rho>)\"", "lemma satL_o:\n\"satL (int \\<xi> o \\<rho>) l = satL \\<xi> (substL \\<rho> l)\"", "lemmas satL_subst = satL_o[symmetric]", "lemma satL_o_subst:\n\"satL \\<xi> o substL \\<rho> = satL (int \\<xi> o \\<rho>)\"", "lemma satC_o:\n\"satC (int \\<xi> o \\<rho>) c = satC \\<xi> (substC \\<rho> c)\"", "lemmas satC_subst = satC_o[symmetric]", "lemma satC_o_subst:\n\"satC \\<xi> o substC \\<rho> = satC (int \\<xi> o \\<rho>)\"", "lemma satPB_o:\n\"satPB (int \\<xi> o \\<rho>) \\<Phi> = satPB \\<xi> (substPB \\<rho> \\<Phi>)\"", "lemmas satPB_subst = satPB_o[symmetric]", "lemma satPB_o_subst:\n\"satPB \\<xi> o substPB \\<rho> = satPB (int \\<xi> o \\<rho>)\"", "lemma wtE_o:\nassumes 1: \"wtE \\<xi>\" and 2: \"wtSB \\<rho>\"\nshows \"wtE (int \\<xi> o \\<rho>)\"", "lemma wtE_compE:\nassumes \"wtSB \\<rho>\" and \"wtE \\<xi>\"  shows \"wtE (compE \\<rho> \\<xi>)\"", "lemma compE_upd: \"compE (\\<rho> (x := T)) \\<xi> = (compE \\<rho> \\<xi>) (x := int \\<xi> T)\"", "lemma fsyms_int_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsyms T \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.int intF1 \\<xi> T = Struct.int intF2 \\<xi> T\"", "lemma fsyms_satA_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsymsA at \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.satA intF1 intP \\<xi> at \\<longleftrightarrow> Struct.satA intF2 intP \\<xi> at\"", "lemma fsyms_satL_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsymsL l \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.satL intF1 intP \\<xi> l \\<longleftrightarrow> Struct.satL intF2 intP \\<xi> l\"", "lemma fsyms_satC_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsymsC c \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.satC intF1 intP \\<xi> c \\<longleftrightarrow> Struct.satC intF2 intP \\<xi> c\"", "lemma fsyms_satPB_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsymsPB \\<Phi> \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.satPB intF1 intP \\<xi> \\<Phi> \\<longleftrightarrow> Struct.satPB intF2 intP \\<xi> \\<Phi>\"", "lemma fsymsPB_Un[simp]: \"fsymsPB (\\<Phi>1 \\<union> \\<Phi>2) = fsymsPB \\<Phi>1 \\<union> fsymsPB \\<Phi>2\"", "lemma fsymsC_append[simp]: \"fsymsC (c1 @ c2) = fsymsC c1 \\<union> fsymsC c2\"", "lemma fsymsPB_sappend_incl[simp]:\n\"fsymsPB (\\<Phi>1 @@ \\<Phi>2) \\<subseteq>  fsymsPB \\<Phi>1 \\<union> fsymsPB \\<Phi>2\"", "lemma fsymsPB_sappend[simp]:\nassumes 1: \"\\<Phi>1 \\<noteq> {}\" and 2: \"\\<Phi>2 \\<noteq> {}\"\nshows \"fsymsPB (\\<Phi>1 @@ \\<Phi>2) = fsymsPB \\<Phi>1 \\<union> fsymsPB \\<Phi>2\"", "lemma Struct_upd:\nassumes \"Struct wtFsym wtPsym arOf resOf intT intF intP\"\nand \"\\<And> al. list_all2 intT (arOf ef) al \\<Longrightarrow> intT (resOf ef) (EF al)\"\nshows \"Struct wtFsym wtPsym arOf resOf intT (intF (ef := EF)) intP\"", "lemma sat_\\<Phi>: \"wtE \\<xi> \\<Longrightarrow> satPB \\<xi> \\<Phi>\""], "translations": [["", "lemma wtC_append[simp]: \"wtC (c1 @ c2) \\<longleftrightarrow> wtC c1 \\<and> wtC c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtC (c1 @ c2) = (wtC c1 \\<and> wtC c2)", "unfolding wtC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all wtL (c1 @ c2) = (list_all wtL c1 \\<and> list_all wtL c2)", "by simp"], ["", "(* Well-typed problems *)"], ["", "definition \"wtPB \\<Phi> \\<equiv> \\<forall> c \\<in> \\<Phi>. wtC c\""], ["", "lemma wtPB_Un[simp]: \"wtPB (\\<Phi>1 \\<union> \\<Phi>2) \\<longleftrightarrow> wtPB \\<Phi>1 \\<and> wtPB \\<Phi>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtPB (\\<Phi>1 \\<union> \\<Phi>2) = (wtPB \\<Phi>1 \\<and> wtPB \\<Phi>2)", "unfolding wtPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (\\<Phi>1 \\<union> \\<Phi>2) wtC =\n    (Ball \\<Phi>1 wtC \\<and> Ball \\<Phi>2 wtC)", "by auto"], ["", "lemma wtPB_UN[simp]: \"wtPB (\\<Union> i \\<in> I. \\<Phi> i) \\<longleftrightarrow> (\\<forall> i \\<in> I. wtPB (\\<Phi> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtPB (\\<Union> (\\<Phi> ` I)) = (\\<forall>i\\<in>I. wtPB (\\<Phi> i))", "unfolding wtPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (\\<Union> (\\<Phi> ` I)) wtC =\n    (\\<forall>i\\<in>I. Ball (\\<Phi> i) wtC)", "by auto"], ["", "lemma wtPB_sappend[simp]:\nassumes \"wtPB \\<Phi>1\" and \"wtPB \\<Phi>2\"  shows \"wtPB (\\<Phi>1 @@ \\<Phi>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtPB (\\<Phi>1 @@ \\<Phi>2)", "using assms"], ["proof (prove)\nusing this:\n  wtPB \\<Phi>1\n  wtPB \\<Phi>2\n\ngoal (1 subgoal):\n 1. wtPB (\\<Phi>1 @@ \\<Phi>2)", "unfolding wtPB_def sappend_def"], ["proof (prove)\nusing this:\n  Ball \\<Phi>1 wtC\n  Ball \\<Phi>2 wtC\n\ngoal (1 subgoal):\n 1. Ball {al @ bl |al bl. al \\<in> \\<Phi>1 \\<and> bl \\<in> \\<Phi>2} wtC", "by auto"], ["", "(* Well-typed substitutions *)"], ["", "definition \"wtSB \\<pi> \\<equiv> \\<forall> x. wt (\\<pi> x) \\<and> tpOf (\\<pi> x) = tpOfV x\""], ["", "lemma wtSB_wt[simp]: \"wtSB \\<pi> \\<Longrightarrow> wt (\\<pi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtSB \\<pi> \\<Longrightarrow> wt (\\<pi> x)", "unfolding wtSB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       wt (\\<pi> x) \\<and> tpOf (\\<pi> x) = tpOfV x \\<Longrightarrow>\n    wt (\\<pi> x)", "by auto"], ["", "lemma wtSB_tpOf[simp]: \"wtSB \\<pi> \\<Longrightarrow> tpOf (\\<pi> x) = tpOfV x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtSB \\<pi> \\<Longrightarrow> tpOf (\\<pi> x) = tpOfV x", "unfolding wtSB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       wt (\\<pi> x) \\<and> tpOf (\\<pi> x) = tpOfV x \\<Longrightarrow>\n    tpOf (\\<pi> x) = tpOfV x", "by auto"], ["", "lemma wt_tpOf_subst:\nassumes \"wtSB \\<pi>\" and \"wt T\"\nshows \"wt (subst \\<pi> T) \\<and> tpOf (subst \\<pi> T) = tpOf T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (subst \\<pi> T) \\<and> tpOf (subst \\<pi> T) = tpOf T", "using assms"], ["proof (prove)\nusing this:\n  wtSB \\<pi>\n  wt T\n\ngoal (1 subgoal):\n 1. wt (subst \\<pi> T) \\<and> tpOf (subst \\<pi> T) = tpOf T", "apply(induct T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>wtSB \\<pi>; wt (Var x)\\<rbrakk>\n       \\<Longrightarrow> wt (subst \\<pi> (Var x)) \\<and>\n                         tpOf (subst \\<pi> (Var x)) = tpOf (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wtSB \\<pi> \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     wt (subst \\<pi> a) \\<and>\n                     tpOf (subst \\<pi> a) = tpOf a)\n                 Tl;\n        wtSB \\<pi>; wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> wt (subst \\<pi> (Fn f Tl)) \\<and>\n                         tpOf (subst \\<pi> (Fn f Tl)) = tpOf (Fn f Tl)", "by (auto simp add: list_all_iff)"], ["", "lemmas wt_subst[simp] = wt_tpOf_subst[THEN conjunct1]"], ["", "lemmas tpOf_subst[simp] = wt_tpOf_subst[THEN conjunct2]"], ["", "lemma wtSB_o:\nassumes 1: \"wtSB \\<pi>1\" and 2: \"wtSB \\<pi>2\"\nshows \"wtSB (subst \\<pi>1 o \\<pi>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtSB (subst \\<pi>1 \\<circ> \\<pi>2)", "using 2"], ["proof (prove)\nusing this:\n  wtSB \\<pi>2\n\ngoal (1 subgoal):\n 1. wtSB (subst \\<pi>1 \\<circ> \\<pi>2)", "unfolding wtSB_def"], ["proof (prove)\nusing this:\n  \\<forall>x. wt (\\<pi>2 x) \\<and> tpOf (\\<pi>2 x) = tpOfV x\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       wt ((subst \\<pi>1 \\<circ> \\<pi>2) x) \\<and>\n       tpOf ((subst \\<pi>1 \\<circ> \\<pi>2) x) = tpOfV x", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>x. wt (\\<pi>2 x) \\<and> tpOf (\\<pi>2 x) = tpOfV x\n  wtSB \\<pi>1\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       wt ((subst \\<pi>1 \\<circ> \\<pi>2) x) \\<and>\n       tpOf ((subst \\<pi>1 \\<circ> \\<pi>2) x) = tpOfV x", "by auto"], ["", "(* Getting variable terms for given types: *)"], ["", "definition \"getTvars \\<sigma>l \\<equiv> map Var (getVars \\<sigma>l)\""], ["", "lemma length_getTvars[simp]: \"length (getTvars \\<sigma>l) = length \\<sigma>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (getTvars \\<sigma>l) = length \\<sigma>l", "unfolding getTvars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map Var (getVars \\<sigma>l)) = length \\<sigma>l", "by auto"], ["", "lemma wt_getTvars[simp]: \"list_all wt (getTvars \\<sigma>l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all wt (getTvars \\<sigma>l)", "unfolding list_all_length getTvars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length (map Var (getVars \\<sigma>l)).\n       wt (map Var (getVars \\<sigma>l) ! n)", "by simp"], ["", "lemma wt_nth_getTvars[simp]:\n\"i < length \\<sigma>l \\<Longrightarrow> wt (getTvars \\<sigma>l ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length \\<sigma>l \\<Longrightarrow> wt (getTvars \\<sigma>l ! i)", "unfolding getTvars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length \\<sigma>l \\<Longrightarrow>\n    wt (map Var (getVars \\<sigma>l) ! i)", "by auto"], ["", "lemma map_tpOf_getTvars[simp]: \"map tpOf (getTvars \\<sigma>l) = \\<sigma>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map tpOf (getTvars \\<sigma>l) = \\<sigma>l", "unfolding getTvars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map tpOf (map Var (getVars \\<sigma>l)) = \\<sigma>l", "unfolding list_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map tpOf (map Var (getVars \\<sigma>l))) =\n    length \\<sigma>l \\<and>\n    (\\<forall>i<length (map tpOf (map Var (getVars \\<sigma>l))).\n        map tpOf (map Var (getVars \\<sigma>l)) ! i = \\<sigma>l ! i)", "by auto"], ["", "lemma tpOf_nth_getTvars[simp]:\n\"i < length \\<sigma>l \\<Longrightarrow> tpOf (getTvars \\<sigma>l ! i) = \\<sigma>l ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length \\<sigma>l \\<Longrightarrow>\n    tpOf (getTvars \\<sigma>l ! i) = \\<sigma>l ! i", "unfolding getTvars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length \\<sigma>l \\<Longrightarrow>\n    tpOf (map Var (getVars \\<sigma>l) ! i) = \\<sigma>l ! i", "by auto"], ["", "end"], ["", "(* context Signature *)"], ["", "subsection \\<open>Structures\\<close>"], ["", "text\\<open>We split a structre into a ``type structure'' that interprets the types \nand the rest of the structure that interprets the function and relation symbols.\\<close>"], ["", "text\\<open>Type structures:\\<close>"], ["", "locale Tstruct =\nfixes intT :: \"'tp \\<Rightarrow> 'univ \\<Rightarrow> bool\"\nassumes NE_intT: \"NE (intT \\<sigma>)\""], ["", "text\\<open>Environment:\\<close>"], ["", "type_synonym ('tp,'univ) env = \"'tp \\<Rightarrow> var \\<Rightarrow> 'univ\""], ["", "text\\<open>Structures:\\<close>"], ["", "locale Struct = Signature wtFsym wtPsym arOf resOf parOf +\n                Tstruct intT\nfor wtFsym and wtPsym\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf :: \"'fsym \\<Rightarrow> 'tp\"\nand parOf :: \"'psym \\<Rightarrow> 'tp list\"\nand intT :: \"'tp \\<Rightarrow> 'univ \\<Rightarrow> bool\"\n+\nfixes\n    intF :: \"'fsym \\<Rightarrow> 'univ list \\<Rightarrow> 'univ\"\nand intP :: \"'psym \\<Rightarrow> 'univ list \\<Rightarrow> bool\"\nassumes\nintF: \"\\<lbrakk>wtFsym f; list_all2 intT (arOf f) al\\<rbrakk> \\<Longrightarrow> intT (resOf f) (intF f al)\"\nand\ndummy: \"intP = intP\"\nbegin"], ["", "text\\<open>Well-typed environment:\\<close>"], ["", "definition \"wtE \\<xi> \\<equiv> \\<forall> x. intT (tpOfV x) (\\<xi> x)\""], ["", "lemma wtTE_intT[simp]: \"wtE \\<xi> \\<Longrightarrow> intT (tpOfV x) (\\<xi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE \\<xi> \\<Longrightarrow> intT (tpOfV x) (\\<xi> x)", "unfolding wtE_def dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. intT (tpOfV x) (\\<xi> x) \\<Longrightarrow>\n    intT (tpOfV x) (\\<xi> x)", "by auto"], ["", "(* Picking an element from the domain of a given type: *)"], ["", "definition \"pickT \\<sigma> \\<equiv> SOME a. intT \\<sigma> a\""], ["", "lemma pickT[simp]: \"intT \\<sigma> (pickT \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> (pickT \\<sigma>)", "unfolding pickT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> (SOME a. intT \\<sigma> a)", "apply(rule someI_ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "using NE_intT"], ["proof (prove)\nusing this:\n  \\<exists>a. intT ?\\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "by auto"], ["", "text\\<open>Picking a well-typed environment:\\<close>"], ["", "definition\n\"pickE (xl::var list) al \\<equiv>\n SOME \\<xi>. wtE \\<xi> \\<and> (\\<forall> i < length xl. \\<xi> (xl!i) = al!i)\""], ["", "lemma ex_pickE:\nassumes \"length xl = length al\"\nand \"distinct xl\" and \"\\<And> i. i < length xl \\<Longrightarrow> intT (tpOfV (xl!i)) (al!i)\"\nshows \"\\<exists> \\<xi>. wtE \\<xi> \\<and> (\\<forall> i < length xl. \\<xi> (xl!i) = al!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<xi>.\n       wtE \\<xi> \\<and> (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)", "using assms"], ["proof (prove)\nusing this:\n  length xl = length al\n  distinct xl\n  ?i1 < length xl \\<Longrightarrow> intT (tpOfV (xl ! ?i1)) (al ! ?i1)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<xi>.\n       wtE \\<xi> \\<and> (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)", "proof(induct rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [];\n     \\<And>i.\n        i < length [] \\<Longrightarrow>\n        intT (tpOfV ([] ! i)) ([] ! i)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<xi>.\n                         wtE \\<xi> \\<and>\n                         (\\<forall>i<length []. \\<xi> ([] ! i) = [] ! i)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>distinct xs;\n         \\<And>i.\n            i < length xs \\<Longrightarrow>\n            intT (tpOfV (xs ! i)) (ys ! i)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<xi>.\n                             wtE \\<xi> \\<and>\n                             (\\<forall>i<length xs.\n                                 \\<xi> (xs ! i) = ys ! i);\n        distinct (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           intT (tpOfV ((x # xs) ! i)) ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<xi>.\n                            wtE \\<xi> \\<and>\n                            (\\<forall>i<length (x # xs).\n                                \\<xi> ((x # xs) ! i) = (y # ys) ! i)", "case Nil"], ["proof (state)\nthis:\n  distinct []\n  ?i1 < length [] \\<Longrightarrow> intT (tpOfV ([] ! ?i1)) ([] ! ?i1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [];\n     \\<And>i.\n        i < length [] \\<Longrightarrow>\n        intT (tpOfV ([] ! i)) ([] ! i)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<xi>.\n                         wtE \\<xi> \\<and>\n                         (\\<forall>i<length []. \\<xi> ([] ! i) = [] ! i)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>distinct xs;\n         \\<And>i.\n            i < length xs \\<Longrightarrow>\n            intT (tpOfV (xs ! i)) (ys ! i)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<xi>.\n                             wtE \\<xi> \\<and>\n                             (\\<forall>i<length xs.\n                                 \\<xi> (xs ! i) = ys ! i);\n        distinct (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           intT (tpOfV ((x # xs) ! i)) ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<xi>.\n                            wtE \\<xi> \\<and>\n                            (\\<forall>i<length (x # xs).\n                                \\<xi> ((x # xs) ! i) = (y # ys) ! i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<xi>.\n       wtE \\<xi> \\<and> (\\<forall>i<length []. \\<xi> ([] ! i) = [] ! i)", "apply(rule exI[of _ \"\\<lambda> x. pickT (tpOfV x)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (\\<lambda>a. pickT (tpOfV a)) \\<and>\n    (\\<forall>i<length []. pickT (tpOfV ([] ! i)) = [] ! i)", "unfolding wtE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. intT (tpOfV x) (pickT (tpOfV x))) \\<and>\n    (\\<forall>i<length []. pickT (tpOfV ([] ! i)) = [] ! i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<xi>.\n     wtE \\<xi> \\<and> (\\<forall>i<length []. \\<xi> ([] ! i) = [] ! i)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>distinct xs;\n         \\<And>i.\n            i < length xs \\<Longrightarrow>\n            intT (tpOfV (xs ! i)) (ys ! i)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<xi>.\n                             wtE \\<xi> \\<and>\n                             (\\<forall>i<length xs.\n                                 \\<xi> (xs ! i) = ys ! i);\n        distinct (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           intT (tpOfV ((x # xs) ! i)) ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<xi>.\n                            wtE \\<xi> \\<and>\n                            (\\<forall>i<length (x # xs).\n                                \\<xi> ((x # xs) ! i) = (y # ys) ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>distinct xs;\n         \\<And>i.\n            i < length xs \\<Longrightarrow>\n            intT (tpOfV (xs ! i)) (ys ! i)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<xi>.\n                             wtE \\<xi> \\<and>\n                             (\\<forall>i<length xs.\n                                 \\<xi> (xs ! i) = ys ! i);\n        distinct (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           intT (tpOfV ((x # xs) ! i)) ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<xi>.\n                            wtE \\<xi> \\<and>\n                            (\\<forall>i<length (x # xs).\n                                \\<xi> ((x # xs) ! i) = (y # ys) ! i)", "case (Cons x xl a al)"], ["proof (state)\nthis:\n  length xl = length al\n  \\<lbrakk>distinct xl;\n   \\<And>i.\n      i < length xl \\<Longrightarrow>\n      intT (tpOfV (xl ! i)) (al ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<xi>.\n                       wtE \\<xi> \\<and>\n                       (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)\n  distinct (x # xl)\n  ?i1 < length (x # xl) \\<Longrightarrow>\n  intT (tpOfV ((x # xl) ! ?i1)) ((a # al) ! ?i1)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>distinct xs;\n         \\<And>i.\n            i < length xs \\<Longrightarrow>\n            intT (tpOfV (xs ! i)) (ys ! i)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<xi>.\n                             wtE \\<xi> \\<and>\n                             (\\<forall>i<length xs.\n                                 \\<xi> (xs ! i) = ys ! i);\n        distinct (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           intT (tpOfV ((x # xs) ! i)) ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<xi>.\n                            wtE \\<xi> \\<and>\n                            (\\<forall>i<length (x # xs).\n                                \\<xi> ((x # xs) ! i) = (y # ys) ! i)", "then"], ["proof (chain)\npicking this:\n  length xl = length al\n  \\<lbrakk>distinct xl;\n   \\<And>i.\n      i < length xl \\<Longrightarrow>\n      intT (tpOfV (xl ! i)) (al ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<xi>.\n                       wtE \\<xi> \\<and>\n                       (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)\n  distinct (x # xl)\n  ?i1 < length (x # xl) \\<Longrightarrow>\n  intT (tpOfV ((x # xl) ! ?i1)) ((a # al) ! ?i1)", "obtain \\<xi> where 1: \"wtE \\<xi>\" and 2: \"\\<forall> i < length xl. \\<xi> (xl!i) = al!i\""], ["proof (prove)\nusing this:\n  length xl = length al\n  \\<lbrakk>distinct xl;\n   \\<And>i.\n      i < length xl \\<Longrightarrow>\n      intT (tpOfV (xl ! i)) (al ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<xi>.\n                       wtE \\<xi> \\<and>\n                       (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)\n  distinct (x # xl)\n  ?i1 < length (x # xl) \\<Longrightarrow>\n  intT (tpOfV ((x # xl) ! ?i1)) ((a # al) ! ?i1)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<xi>.\n        \\<lbrakk>wtE \\<xi>;\n         \\<forall>i<length xl. \\<xi> (xl ! i) = al ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  wtE \\<xi>\n  \\<forall>i<length xl. \\<xi> (xl ! i) = al ! i\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>distinct xs;\n         \\<And>i.\n            i < length xs \\<Longrightarrow>\n            intT (tpOfV (xs ! i)) (ys ! i)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<xi>.\n                             wtE \\<xi> \\<and>\n                             (\\<forall>i<length xs.\n                                 \\<xi> (xs ! i) = ys ! i);\n        distinct (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           intT (tpOfV ((x # xs) ! i)) ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<xi>.\n                            wtE \\<xi> \\<and>\n                            (\\<forall>i<length (x # xs).\n                                \\<xi> ((x # xs) ! i) = (y # ys) ! i)", "define \\<xi>' where \"\\<xi>' x' = (if x = x' then a else \\<xi> x')\" for x'"], ["proof (state)\nthis:\n  \\<xi>' ?x' = (if x = ?x' then a else \\<xi> ?x')\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>distinct xs;\n         \\<And>i.\n            i < length xs \\<Longrightarrow>\n            intT (tpOfV (xs ! i)) (ys ! i)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<xi>.\n                             wtE \\<xi> \\<and>\n                             (\\<forall>i<length xs.\n                                 \\<xi> (xs ! i) = ys ! i);\n        distinct (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           intT (tpOfV ((x # xs) ! i)) ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<xi>.\n                            wtE \\<xi> \\<and>\n                            (\\<forall>i<length (x # xs).\n                                \\<xi> ((x # xs) ! i) = (y # ys) ! i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<xi>.\n       wtE \\<xi> \\<and>\n       (\\<forall>i<length (x # xl). \\<xi> ((x # xl) ! i) = (a # al) ! i)", "proof(rule exI[of _ \\<xi>'], unfold wtE_def, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. intT (tpOfV x) (\\<xi>' x)\n 2. \\<And>i.\n       i < length (x # xl) \\<Longrightarrow>\n       \\<xi>' ((x # xl) ! i) = (a # al) ! i", "fix x'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. intT (tpOfV x) (\\<xi>' x)\n 2. \\<And>i.\n       i < length (x # xl) \\<Longrightarrow>\n       \\<xi>' ((x # xl) ! i) = (a # al) ! i", "show \"intT (tpOfV x') (\\<xi>' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (tpOfV x') (\\<xi>' x')", "using 1 Cons.prems(2)[of 0]"], ["proof (prove)\nusing this:\n  wtE \\<xi>\n  0 < length (x # xl) \\<Longrightarrow>\n  intT (tpOfV ((x # xl) ! 0)) ((a # al) ! 0)\n\ngoal (1 subgoal):\n 1. intT (tpOfV x') (\\<xi>' x')", "unfolding \\<xi>'_def"], ["proof (prove)\nusing this:\n  wtE \\<xi>\n  0 < length (x # xl) \\<Longrightarrow>\n  intT (tpOfV ((x # xl) ! 0)) ((a # al) ! 0)\n\ngoal (1 subgoal):\n 1. intT (tpOfV x') (if x = x' then a else \\<xi> x')", "by auto"], ["proof (state)\nthis:\n  intT (tpOfV x') (\\<xi>' x')\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (x # xl) \\<Longrightarrow>\n       \\<xi>' ((x # xl) ! i) = (a # al) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (x # xl) \\<Longrightarrow>\n       \\<xi>' ((x # xl) ! i) = (a # al) ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (x # xl) \\<Longrightarrow>\n       \\<xi>' ((x # xl) ! i) = (a # al) ! i", "assume i: \"i < length (x # xl)\""], ["proof (state)\nthis:\n  i < length (x # xl)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (x # xl) \\<Longrightarrow>\n       \\<xi>' ((x # xl) ! i) = (a # al) ! i", "thus \"\\<xi>' ((x # xl) ! i) = (a # al) ! i\""], ["proof (prove)\nusing this:\n  i < length (x # xl)\n\ngoal (1 subgoal):\n 1. \\<xi>' ((x # xl) ! i) = (a # al) ! i", "proof(cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length (x # xl); i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<xi>' ((x # xl) ! i) = (a # al) ! i\n 2. \\<And>nat.\n       \\<lbrakk>i < length (x # xl); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<xi>' ((x # xl) ! i) = (a # al) ! i", "case (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length (x # xl); i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<xi>' ((x # xl) ! i) = (a # al) ! i\n 2. \\<And>nat.\n       \\<lbrakk>i < length (x # xl); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<xi>' ((x # xl) ! i) = (a # al) ! i", "hence j: \"j < length xl\""], ["proof (prove)\nusing this:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. j < length xl", "using i"], ["proof (prove)\nusing this:\n  i = Suc j\n  i < length (x # xl)\n\ngoal (1 subgoal):\n 1. j < length xl", "by auto"], ["proof (state)\nthis:\n  j < length xl\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length (x # xl); i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<xi>' ((x # xl) ! i) = (a # al) ! i\n 2. \\<And>nat.\n       \\<lbrakk>i < length (x # xl); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<xi>' ((x # xl) ! i) = (a # al) ! i", "have \"\\<not> x = (x # xl) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> (x # xl) ! i", "using Suc i Cons.prems(1)"], ["proof (prove)\nusing this:\n  i = Suc j\n  i < length (x # xl)\n  distinct (x # xl)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (x # xl) ! i", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> (x # xl) ! i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length (x # xl); i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<xi>' ((x # xl) ! i) = (a # al) ! i\n 2. \\<And>nat.\n       \\<lbrakk>i < length (x # xl); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<xi>' ((x # xl) ! i) = (a # al) ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> (x # xl) ! i\n\ngoal (1 subgoal):\n 1. \\<xi>' ((x # xl) ! i) = (a # al) ! i", "using Suc"], ["proof (prove)\nusing this:\n  x \\<noteq> (x # xl) ! i\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<xi>' ((x # xl) ! i) = (a # al) ! i", "using j Cons.prems(1) Cons.hyps 2"], ["proof (prove)\nusing this:\n  x \\<noteq> (x # xl) ! i\n  i = Suc j\n  j < length xl\n  distinct (x # xl)\n  length xl = length al\n  \\<lbrakk>distinct xl;\n   \\<And>i.\n      i < length xl \\<Longrightarrow>\n      intT (tpOfV (xl ! i)) (al ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<xi>.\n                       wtE \\<xi> \\<and>\n                       (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)\n  \\<forall>i<length xl. \\<xi> (xl ! i) = al ! i\n\ngoal (1 subgoal):\n 1. \\<xi>' ((x # xl) ! i) = (a # al) ! i", "unfolding \\<xi>'_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (x # xl) ! i\n  i = Suc j\n  j < length xl\n  distinct (x # xl)\n  length xl = length al\n  \\<lbrakk>distinct xl;\n   \\<And>i.\n      i < length xl \\<Longrightarrow>\n      intT (tpOfV (xl ! i)) (al ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<xi>.\n                       wtE \\<xi> \\<and>\n                       (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)\n  \\<forall>i<length xl. \\<xi> (xl ! i) = al ! i\n\ngoal (1 subgoal):\n 1. (if x = (x # xl) ! i then a else \\<xi> ((x # xl) ! i)) = (a # al) ! i", "by auto"], ["proof (state)\nthis:\n  \\<xi>' ((x # xl) ! i) = (a # al) ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (x # xl); i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<xi>' ((x # xl) ! i) = (a # al) ! i", "qed(insert Cons.prems(1) Cons.hyps 2, unfold \\<xi>'_def, simp)"], ["proof (state)\nthis:\n  \\<xi>' ((x # xl) ! i) = (a # al) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<xi>.\n     wtE \\<xi> \\<and>\n     (\\<forall>i<length (x # xl). \\<xi> ((x # xl) ! i) = (a # al) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wtE_pickE_pickE:\nassumes \"length xl = length al\"\nand \"distinct xl\" and \"\\<And> i. i < length xl \\<Longrightarrow> intT (tpOfV (xl!i)) (al!i)\"\nshows \"wtE (pickE xl al) \\<and> (\\<forall> i. i < length xl \\<longrightarrow> pickE xl al (xl!i) = al!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (pickE xl al) \\<and>\n    (\\<forall>i<length xl. pickE xl al (xl ! i) = al ! i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. wtE (pickE xl al) \\<and>\n    (\\<forall>i<length xl. pickE xl al (xl ! i) = al ! i)", "let ?phi = \"\\<lambda> \\<xi>. wtE \\<xi> \\<and> (\\<forall> i < length xl. \\<xi> (xl!i) = al!i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. wtE (pickE xl al) \\<and>\n    (\\<forall>i<length xl. pickE xl al (xl ! i) = al ! i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (pickE xl al) \\<and>\n    (\\<forall>i<length xl. pickE xl al (xl ! i) = al ! i)", "unfolding pickE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (SOME \\<xi>.\n            wtE \\<xi> \\<and>\n            (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)) \\<and>\n    (\\<forall>i<length xl.\n        (SOME \\<xi>.\n            wtE \\<xi> \\<and>\n            (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i))\n         (xl ! i) =\n        al ! i)", "apply(rule someI_ex[of ?phi])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<xi>.\n       wtE \\<xi> \\<and> (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)", "using ex_pickE[OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>i. i < length xl \\<Longrightarrow> i < length xl) \\<Longrightarrow>\n  \\<exists>\\<xi>.\n     wtE \\<xi> \\<and> (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<xi>.\n       wtE \\<xi> \\<and> (\\<forall>i<length xl. \\<xi> (xl ! i) = al ! i)", "by simp"], ["proof (state)\nthis:\n  wtE (pickE xl al) \\<and>\n  (\\<forall>i<length xl. pickE xl al (xl ! i) = al ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas wtE_pickE[simp] = wtE_pickE_pickE[THEN conjunct1]"], ["", "lemma pickE[simp]:\nassumes \"length xl = length al\"\nand \"distinct xl\" and \"\\<And> i. i < length xl \\<Longrightarrow> intT (tpOfV (xl!i)) (al!i)\"\nand \"i < length xl\"\nshows \"pickE xl al (xl!i) = al!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pickE xl al (xl ! i) = al ! i", "using assms wtE_pickE_pickE"], ["proof (prove)\nusing this:\n  length xl = length al\n  distinct xl\n  ?i1 < length xl \\<Longrightarrow> intT (tpOfV (xl ! ?i1)) (al ! ?i1)\n  i < length xl\n  \\<lbrakk>length ?xl = length ?al; distinct ?xl;\n   \\<And>i.\n      i < length ?xl \\<Longrightarrow>\n      intT (tpOfV (?xl ! i)) (?al ! i)\\<rbrakk>\n  \\<Longrightarrow> wtE (pickE ?xl ?al) \\<and>\n                    (\\<forall>i<length ?xl.\n                        pickE ?xl ?al (?xl ! i) = ?al ! i)\n\ngoal (1 subgoal):\n 1. pickE xl al (xl ! i) = al ! i", "by auto"], ["", "definition \"pickAnyE \\<equiv> pickE [] []\""], ["", "lemma wtE_pickAnyE[simp]: \"wtE pickAnyE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE pickAnyE", "unfolding pickAnyE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (pickE [] [])", "by (rule wtE_pickE) auto"], ["", "(* Interpretation of terms: *)"], ["", "fun int where\n\"int \\<xi> (Var x) = \\<xi> x\"\n|\n\"int \\<xi> (Fn f Tl) = intF f (map (int \\<xi>) Tl)\""], ["", "(* Satisfaction of atoms: *)"], ["", "fun satA where\n\"satA \\<xi> (Eq T1 T2) \\<longleftrightarrow> int \\<xi> T1 = int \\<xi> T2\"\n|\n\"satA \\<xi> (Pr p Tl) \\<longleftrightarrow> intP p (map (int \\<xi>) Tl)\""], ["", "(* Satisfaction literals: *)"], ["", "fun satL where\n\"satL \\<xi> (Pos a) \\<longleftrightarrow> satA \\<xi> a\"\n|\n\"satL \\<xi> (Neg a) \\<longleftrightarrow> \\<not> satA \\<xi> a\""], ["", "(* Satisfaction of clauses: *)"], ["", "definition \"satC \\<xi> \\<equiv> list_ex (satL \\<xi>)\""], ["", "lemma satC_append[simp]: \"satC \\<xi> (c1 @ c2) \\<longleftrightarrow> satC \\<xi> c1 \\<or> satC \\<xi> c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satC \\<xi> (c1 @ c2) = (satC \\<xi> c1 \\<or> satC \\<xi> c2)", "unfolding satC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex (satL \\<xi>) (c1 @ c2) =\n    (list_ex (satL \\<xi>) c1 \\<or> list_ex (satL \\<xi>) c2)", "by auto"], ["", "lemma satC_iff_set: \"satC \\<xi> c \\<longleftrightarrow> (\\<exists> l \\<in> set c. satL \\<xi> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satC \\<xi> c = (\\<exists>l\\<in>set c. satL \\<xi> l)", "unfolding satC_def Bex_set[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (set c) (satL \\<xi>) = (\\<exists>l\\<in>set c. satL \\<xi> l)", ".."], ["", "(* satisfaction of problems *)"], ["", "definition \"satPB \\<xi> \\<Phi> \\<equiv> \\<forall> c \\<in> \\<Phi>. satC \\<xi> c\""], ["", "lemma satPB_Un[simp]: \"satPB \\<xi> (\\<Phi>1 \\<union> \\<Phi>2) \\<longleftrightarrow> satPB \\<xi> \\<Phi>1 \\<and> satPB \\<xi> \\<Phi>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB \\<xi> (\\<Phi>1 \\<union> \\<Phi>2) =\n    (satPB \\<xi> \\<Phi>1 \\<and> satPB \\<xi> \\<Phi>2)", "unfolding satPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>\\<Phi>1 \\<union> \\<Phi>2. satC \\<xi> c) =\n    ((\\<forall>c\\<in>\\<Phi>1. satC \\<xi> c) \\<and>\n     (\\<forall>c\\<in>\\<Phi>2. satC \\<xi> c))", "by auto"], ["", "lemma satPB_UN[simp]: \"satPB \\<xi> (\\<Union> i \\<in> I. \\<Phi> i) \\<longleftrightarrow> (\\<forall> i \\<in> I. satPB \\<xi> (\\<Phi> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB \\<xi> (\\<Union> (\\<Phi> ` I)) =\n    (\\<forall>i\\<in>I. satPB \\<xi> (\\<Phi> i))", "unfolding satPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>\\<Union> (\\<Phi> ` I). satC \\<xi> c) =\n    (\\<forall>i\\<in>I. \\<forall>c\\<in>\\<Phi> i. satC \\<xi> c)", "by auto"], ["", "lemma satPB_sappend[simp]: \"satPB \\<xi> (\\<Phi>1 @@ \\<Phi>2) \\<longleftrightarrow> satPB \\<xi> \\<Phi>1 \\<or> satPB \\<xi> \\<Phi>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB \\<xi> (\\<Phi>1 @@ \\<Phi>2) =\n    (satPB \\<xi> \\<Phi>1 \\<or> satPB \\<xi> \\<Phi>2)", "unfolding satPB_def sappend_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>{al @ bl |al bl.\n                     al \\<in> \\<Phi>1 \\<and> bl \\<in> \\<Phi>2}.\n        satC \\<xi> c) =\n    ((\\<forall>c\\<in>\\<Phi>1. satC \\<xi> c) \\<or>\n     (\\<forall>c\\<in>\\<Phi>2. satC \\<xi> c))", "by (fastforce simp: satC_append)"], ["", "definition \"SAT \\<Phi> \\<equiv> \\<forall> \\<xi>. wtE \\<xi> \\<longrightarrow> satPB \\<xi> \\<Phi>\""], ["", "lemma SAT_UN[simp]: \"SAT (\\<Union> i \\<in> I. \\<Phi> i) \\<longleftrightarrow> (\\<forall> i \\<in> I. SAT (\\<Phi> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAT (\\<Union> (\\<Phi> ` I)) = (\\<forall>i\\<in>I. SAT (\\<Phi> i))", "unfolding SAT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<xi>.\n        wtE \\<xi> \\<longrightarrow> satPB \\<xi> (\\<Union> (\\<Phi> ` I))) =\n    (\\<forall>i\\<in>I.\n        \\<forall>\\<xi>. wtE \\<xi> \\<longrightarrow> satPB \\<xi> (\\<Phi> i))", "by auto"], ["", "text\\<open>Soundness of typing w.r.t. interpretation:\\<close>"], ["", "lemma wt_int:\nassumes wtE: \"wtE \\<xi>\" and wt: \"wt T\"\nshows \"intT (tpOf T) (int \\<xi> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (tpOf T) (int \\<xi> T)", "using wt"], ["proof (prove)\nusing this:\n  wt T\n\ngoal (1 subgoal):\n 1. intT (tpOf T) (int \\<xi> T)", "apply(induct T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow> intT (tpOf (Var x)) (int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow> intT (tpOf a) (int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> intT (tpOf (Fn f Tl)) (int \\<xi> (Fn f Tl))", "using wtE"], ["proof (prove)\nusing this:\n  wtE \\<xi>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow> intT (tpOf (Var x)) (int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow> intT (tpOf a) (int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> intT (tpOf (Fn f Tl)) (int \\<xi> (Fn f Tl))", "by (auto intro!: intF simp add: list_all2_map_map)"], ["", "lemma int_cong:\nassumes \"\\<And>x. x \\<in> vars T \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"int \\<xi>1 T = int \\<xi>2 T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int \\<xi>1 T = int \\<xi>2 T", "using assms"], ["proof (prove)\nusing this:\n  ?x1 \\<in> vars T \\<Longrightarrow> \\<xi>1 ?x1 = \\<xi>2 ?x1\n\ngoal (1 subgoal):\n 1. int \\<xi>1 T = int \\<xi>2 T", "proof(induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> vars (Var x) \\<Longrightarrow>\n           \\<xi>1 xa = \\<xi>2 xa) \\<Longrightarrow>\n       int \\<xi>1 (Var x) = int \\<xi>2 (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<forall>x.\n                         x \\<in> vars a \\<longrightarrow>\n                         \\<xi>1 x = \\<xi>2 x) \\<longrightarrow>\n                     int \\<xi>1 a = int \\<xi>2 a)\n                 Tl;\n        \\<And>x.\n           x \\<in> vars (Fn f Tl) \\<Longrightarrow>\n           \\<xi>1 x = \\<xi>2 x\\<rbrakk>\n       \\<Longrightarrow> int \\<xi>1 (Fn f Tl) = int \\<xi>2 (Fn f Tl)", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       (\\<forall>x.\n           x \\<in> vars a \\<longrightarrow>\n           \\<xi>1 x = \\<xi>2 x) \\<longrightarrow>\n       int \\<xi>1 a = int \\<xi>2 a)\n   Tl\n  ?x1 \\<in> vars (Fn f Tl) \\<Longrightarrow> \\<xi>1 ?x1 = \\<xi>2 ?x1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> vars (Var x) \\<Longrightarrow>\n           \\<xi>1 xa = \\<xi>2 xa) \\<Longrightarrow>\n       int \\<xi>1 (Var x) = int \\<xi>2 (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<forall>x.\n                         x \\<in> vars a \\<longrightarrow>\n                         \\<xi>1 x = \\<xi>2 x) \\<longrightarrow>\n                     int \\<xi>1 a = int \\<xi>2 a)\n                 Tl;\n        \\<And>x.\n           x \\<in> vars (Fn f Tl) \\<Longrightarrow>\n           \\<xi>1 x = \\<xi>2 x\\<rbrakk>\n       \\<Longrightarrow> int \\<xi>1 (Fn f Tl) = int \\<xi>2 (Fn f Tl)", "hence 1: \"map (int \\<xi>1) Tl = map (int \\<xi>2) Tl\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       (\\<forall>x.\n           x \\<in> vars a \\<longrightarrow>\n           \\<xi>1 x = \\<xi>2 x) \\<longrightarrow>\n       int \\<xi>1 a = int \\<xi>2 a)\n   Tl\n  ?x1 \\<in> vars (Fn f Tl) \\<Longrightarrow> \\<xi>1 ?x1 = \\<xi>2 ?x1\n\ngoal (1 subgoal):\n 1. map (int \\<xi>1) Tl = map (int \\<xi>2) Tl", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set Tl.\n     (\\<forall>x.\n         x \\<in> vars a \\<longrightarrow>\n         \\<xi>1 x = \\<xi>2 x) \\<longrightarrow>\n     int \\<xi>1 a = int \\<xi>2 a\n  ?x1 \\<in> vars (Fn f Tl) \\<Longrightarrow> \\<xi>1 ?x1 = \\<xi>2 ?x1\n\ngoal (1 subgoal):\n 1. map (int \\<xi>1) Tl = map (int \\<xi>2) Tl", "by (auto intro: map_ext)"], ["proof (state)\nthis:\n  map (int \\<xi>1) Tl = map (int \\<xi>2) Tl\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> vars (Var x) \\<Longrightarrow>\n           \\<xi>1 xa = \\<xi>2 xa) \\<Longrightarrow>\n       int \\<xi>1 (Var x) = int \\<xi>2 (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<forall>x.\n                         x \\<in> vars a \\<longrightarrow>\n                         \\<xi>1 x = \\<xi>2 x) \\<longrightarrow>\n                     int \\<xi>1 a = int \\<xi>2 a)\n                 Tl;\n        \\<And>x.\n           x \\<in> vars (Fn f Tl) \\<Longrightarrow>\n           \\<xi>1 x = \\<xi>2 x\\<rbrakk>\n       \\<Longrightarrow> int \\<xi>1 (Fn f Tl) = int \\<xi>2 (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. int \\<xi>1 (Fn f Tl) = int \\<xi>2 (Fn f Tl)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. intF f (map (int \\<xi>1) Tl) = intF f (map (int \\<xi>2) Tl)", "by (metis 1)"], ["proof (state)\nthis:\n  int \\<xi>1 (Fn f Tl) = int \\<xi>2 (Fn f Tl)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> vars (Var x) \\<Longrightarrow>\n           \\<xi>1 xa = \\<xi>2 xa) \\<Longrightarrow>\n       int \\<xi>1 (Var x) = int \\<xi>2 (Var x)", "qed auto"], ["", "lemma satA_cong:\nassumes \"\\<And>x. x \\<in> varsA at \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"satA \\<xi>1 at \\<longleftrightarrow> satA \\<xi>2 at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satA \\<xi>1 at = satA \\<xi>2 at", "using assms int_cong[of _ \\<xi>1 \\<xi>2]"], ["proof (prove)\nusing this:\n  ?x1 \\<in> varsA at \\<Longrightarrow> \\<xi>1 ?x1 = \\<xi>2 ?x1\n  (\\<And>x.\n      x \\<in> vars ?T \\<Longrightarrow>\n      \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n  int \\<xi>1 ?T = int \\<xi>2 ?T\n\ngoal (1 subgoal):\n 1. satA \\<xi>1 at = satA \\<xi>2 at", "apply(cases at)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> varsA at \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x;\n        \\<And>T.\n           (\\<And>x.\n               x \\<in> vars T \\<Longrightarrow>\n               \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n           int \\<xi>1 T = int \\<xi>2 T;\n        at = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> satA \\<xi>1 at = satA \\<xi>2 at\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> varsA at \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x;\n        \\<And>T.\n           (\\<And>x.\n               x \\<in> vars T \\<Longrightarrow>\n               \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n           int \\<xi>1 T = int \\<xi>2 T;\n        at = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> satA \\<xi>1 at = satA \\<xi>2 at", "apply(fastforce intro!: int_cong[of _ \\<xi>1 \\<xi>2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> varsA at \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x;\n        \\<And>T.\n           (\\<And>x.\n               x \\<in> vars T \\<Longrightarrow>\n               \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n           int \\<xi>1 T = int \\<xi>2 T;\n        at = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> satA \\<xi>1 at = satA \\<xi>2 at", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x.\n                   \\<exists>xa\\<in>set x22.\n                      x \\<in> vars xa \\<Longrightarrow>\n                   \\<xi>1 x = \\<xi>2 x;\n        \\<And>T.\n           (\\<And>x.\n               x \\<in> vars T \\<Longrightarrow>\n               \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n           int \\<xi>1 T = int \\<xi>2 T;\n        at = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> intP x21 (map (int \\<xi>1) x22) =\n                         intP x21 (map (int \\<xi>2) x22)", "by (metis (hide_lams, mono_tags) map_eq_conv)"], ["", "lemma satL_cong:\nassumes \"\\<And> x. x \\<in> varsL l \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"satL \\<xi>1 l \\<longleftrightarrow> satL \\<xi>2 l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satL \\<xi>1 l = satL \\<xi>2 l", "using assms satA_cong[of _ \\<xi>1 \\<xi>2]"], ["proof (prove)\nusing this:\n  ?x1 \\<in> varsL l \\<Longrightarrow> \\<xi>1 ?x1 = \\<xi>2 ?x1\n  (\\<And>x.\n      x \\<in> varsA ?at \\<Longrightarrow>\n      \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n  satA \\<xi>1 ?at = satA \\<xi>2 ?at\n\ngoal (1 subgoal):\n 1. satL \\<xi>1 l = satL \\<xi>2 l", "by (cases l, auto)"], ["", "lemma satC_cong:\nassumes \"\\<And> x. x \\<in> varsC c \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"satC \\<xi>1 c \\<longleftrightarrow> satC \\<xi>2 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satC \\<xi>1 c = satC \\<xi>2 c", "using assms satL_cong[of _ \\<xi>1 \\<xi>2]"], ["proof (prove)\nusing this:\n  ?x1 \\<in> varsC c \\<Longrightarrow> \\<xi>1 ?x1 = \\<xi>2 ?x1\n  (\\<And>x.\n      x \\<in> varsL ?l \\<Longrightarrow>\n      \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n  satL \\<xi>1 ?l = satL \\<xi>2 ?l\n\ngoal (1 subgoal):\n 1. satC \\<xi>1 c = satC \\<xi>2 c", "unfolding satC_def varsC_def"], ["proof (prove)\nusing this:\n  ?x1 \\<in> \\<Union> (set (map varsL c)) \\<Longrightarrow>\n  \\<xi>1 ?x1 = \\<xi>2 ?x1\n  (\\<And>x.\n      x \\<in> varsL ?l \\<Longrightarrow>\n      \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n  satL \\<xi>1 ?l = satL \\<xi>2 ?l\n\ngoal (1 subgoal):\n 1. list_ex (satL \\<xi>1) c = list_ex (satL \\<xi>2) c", "apply (induct c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> \\<Union> (set (map varsL [])) \\<Longrightarrow>\n                \\<xi>1 x = \\<xi>2 x;\n     \\<And>l.\n        (\\<And>x.\n            x \\<in> varsL l \\<Longrightarrow>\n            \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n        satL \\<xi>1 l = satL \\<xi>2 l\\<rbrakk>\n    \\<Longrightarrow> list_ex (satL \\<xi>1) [] = list_ex (satL \\<xi>2) []\n 2. \\<And>a c.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> \\<Union>\n                                     (set (map varsL c)) \\<Longrightarrow>\n                            \\<xi>1 x = \\<xi>2 x;\n                 \\<And>l.\n                    (\\<And>x.\n                        x \\<in> varsL l \\<Longrightarrow>\n                        \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n                    satL \\<xi>1 l = satL \\<xi>2 l\\<rbrakk>\n                \\<Longrightarrow> list_ex (satL \\<xi>1) c =\n                                  list_ex (satL \\<xi>2) c;\n        \\<And>x.\n           x \\<in> \\<Union> (set (map varsL (a # c))) \\<Longrightarrow>\n           \\<xi>1 x = \\<xi>2 x;\n        \\<And>l.\n           (\\<And>x.\n               x \\<in> varsL l \\<Longrightarrow>\n               \\<xi>1 x = \\<xi>2 x) \\<Longrightarrow>\n           satL \\<xi>1 l = satL \\<xi>2 l\\<rbrakk>\n       \\<Longrightarrow> list_ex (satL \\<xi>1) (a # c) =\n                         list_ex (satL \\<xi>2) (a # c)", "by (fastforce intro!: satL_cong[of _ \\<xi>1 \\<xi>2])+"], ["", "lemma satPB_cong:\nassumes \"\\<And> x. x \\<in> varsPB \\<Phi> \\<Longrightarrow> \\<xi>1 x = \\<xi>2 x\"\nshows \"satPB \\<xi>1 \\<Phi> \\<longleftrightarrow> satPB \\<xi>2 \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB \\<xi>1 \\<Phi> = satPB \\<xi>2 \\<Phi>", "by (force simp: satPB_def varsPB_def intro!: satC_cong ball_cong assms)"], ["", "lemma int_o:\n\"int (int \\<xi> o \\<rho>) T = int \\<xi> (subst \\<rho> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (int \\<xi> \\<circ> \\<rho>) T = int \\<xi> (subst \\<rho> T)", "apply(induct T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       int (int \\<xi> \\<circ> \\<rho>) (Var x) =\n       int \\<xi> (subst \\<rho> (Var x))\n 2. \\<And>f Tl.\n       list_all\n        (\\<lambda>a.\n            int (int \\<xi> \\<circ> \\<rho>) a = int \\<xi> (subst \\<rho> a))\n        Tl \\<Longrightarrow>\n       int (int \\<xi> \\<circ> \\<rho>) (Fn f Tl) =\n       int \\<xi> (subst \\<rho> (Fn f Tl))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       list_all\n        (\\<lambda>a.\n            int (\\<lambda>a. int \\<xi> (\\<rho> a)) a =\n            int \\<xi> (subst \\<rho> a))\n        Tl \\<Longrightarrow>\n       intF f (map (int (\\<lambda>a. int \\<xi> (\\<rho> a))) Tl) =\n       intF f (map (int \\<xi> \\<circ> subst \\<rho>) Tl)", "unfolding list_all_iff o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<forall>a\\<in>set Tl.\n          int (\\<lambda>a. int \\<xi> (\\<rho> a)) a =\n          int \\<xi> (subst \\<rho> a) \\<Longrightarrow>\n       intF f (map (int (\\<lambda>a. int \\<xi> (\\<rho> a))) Tl) =\n       intF f (map (\\<lambda>x. int \\<xi> (subst \\<rho> x)) Tl)", "using map_ext"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> set ?xs \\<longrightarrow> ?f x = ?g x) \\<Longrightarrow>\n  map ?f ?xs = map ?g ?xs\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<forall>a\\<in>set Tl.\n          int (\\<lambda>a. int \\<xi> (\\<rho> a)) a =\n          int \\<xi> (subst \\<rho> a) \\<Longrightarrow>\n       intF f (map (int (\\<lambda>a. int \\<xi> (\\<rho> a))) Tl) =\n       intF f (map (\\<lambda>x. int \\<xi> (subst \\<rho> x)) Tl)", "by (metis (lifting, no_types))"], ["", "lemmas int_subst = int_o[symmetric]"], ["", "lemma int_o_subst:\n\"int \\<xi> o subst \\<rho> = int (int \\<xi> o \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int \\<xi> \\<circ> subst \\<rho> = int (int \\<xi> \\<circ> \\<rho>)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (int \\<xi> \\<circ> subst \\<rho>) x = int (int \\<xi> \\<circ> \\<rho>) x", "apply(subst comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. int \\<xi> (subst \\<rho> x) = int (int \\<xi> \\<circ> \\<rho>) x", "unfolding int_o[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       int (int \\<xi> \\<circ> \\<rho>) x = int (int \\<xi> \\<circ> \\<rho>) x", ".."], ["", "lemma satA_o:\n\"satA (int \\<xi> o \\<rho>) at = satA \\<xi> (substA \\<rho> at)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satA (int \\<xi> \\<circ> \\<rho>) at = satA \\<xi> (substA \\<rho> at)", "by (cases at, simp_all add: int_o_subst int_o[of \\<xi> \\<rho>])"], ["", "lemmas satA_subst = satA_o[symmetric]"], ["", "lemma satA_o_subst:\n\"satA \\<xi> o substA \\<rho> = satA (int \\<xi> o \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satA \\<xi> \\<circ> substA \\<rho> = satA (int \\<xi> \\<circ> \\<rho>)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (satA \\<xi> \\<circ> substA \\<rho>) x =\n       satA (int \\<xi> \\<circ> \\<rho>) x", "apply(subst comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       satA \\<xi> (substA \\<rho> x) = satA (int \\<xi> \\<circ> \\<rho>) x", "unfolding satA_o[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       satA (int \\<xi> \\<circ> \\<rho>) x = satA (int \\<xi> \\<circ> \\<rho>) x", ".."], ["", "lemma satL_o:\n\"satL (int \\<xi> o \\<rho>) l = satL \\<xi> (substL \\<rho> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satL (int \\<xi> \\<circ> \\<rho>) l = satL \\<xi> (substL \\<rho> l)", "using satA_o[of \\<xi> \\<rho>]"], ["proof (prove)\nusing this:\n  satA (int \\<xi> \\<circ> \\<rho>) ?at = satA \\<xi> (substA \\<rho> ?at)\n\ngoal (1 subgoal):\n 1. satL (int \\<xi> \\<circ> \\<rho>) l = satL \\<xi> (substL \\<rho> l)", "by (cases l, simp_all)"], ["", "lemmas satL_subst = satL_o[symmetric]"], ["", "lemma satL_o_subst:\n\"satL \\<xi> o substL \\<rho> = satL (int \\<xi> o \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satL \\<xi> \\<circ> substL \\<rho> = satL (int \\<xi> \\<circ> \\<rho>)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (satL \\<xi> \\<circ> substL \\<rho>) x =\n       satL (int \\<xi> \\<circ> \\<rho>) x", "apply(subst comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       satL \\<xi> (substL \\<rho> x) = satL (int \\<xi> \\<circ> \\<rho>) x", "unfolding satL_o[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       satL (int \\<xi> \\<circ> \\<rho>) x = satL (int \\<xi> \\<circ> \\<rho>) x", ".."], ["", "lemma satC_o:\n\"satC (int \\<xi> o \\<rho>) c = satC \\<xi> (substC \\<rho> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satC (int \\<xi> \\<circ> \\<rho>) c = satC \\<xi> (substC \\<rho> c)", "using satL_o[of \\<xi> \\<rho>]"], ["proof (prove)\nusing this:\n  satL (int \\<xi> \\<circ> \\<rho>) ?l = satL \\<xi> (substL \\<rho> ?l)\n\ngoal (1 subgoal):\n 1. satC (int \\<xi> \\<circ> \\<rho>) c = satC \\<xi> (substC \\<rho> c)", "unfolding satC_def substC_def"], ["proof (prove)\nusing this:\n  satL (int \\<xi> \\<circ> \\<rho>) ?l = satL \\<xi> (substL \\<rho> ?l)\n\ngoal (1 subgoal):\n 1. list_ex (satL (int \\<xi> \\<circ> \\<rho>)) c =\n    list_ex (satL \\<xi>) (map (substL \\<rho>) c)", "by (induct c, auto)"], ["", "lemmas satC_subst = satC_o[symmetric]"], ["", "lemma satC_o_subst:\n\"satC \\<xi> o substC \\<rho> = satC (int \\<xi> o \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satC \\<xi> \\<circ> substC \\<rho> = satC (int \\<xi> \\<circ> \\<rho>)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (satC \\<xi> \\<circ> substC \\<rho>) x =\n       satC (int \\<xi> \\<circ> \\<rho>) x", "apply(subst comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       satC \\<xi> (substC \\<rho> x) = satC (int \\<xi> \\<circ> \\<rho>) x", "unfolding satC_o[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       satC (int \\<xi> \\<circ> \\<rho>) x = satC (int \\<xi> \\<circ> \\<rho>) x", ".."], ["", "lemma satPB_o:\n\"satPB (int \\<xi> o \\<rho>) \\<Phi> = satPB \\<xi> (substPB \\<rho> \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB (int \\<xi> \\<circ> \\<rho>) \\<Phi> =\n    satPB \\<xi> (substPB \\<rho> \\<Phi>)", "using satC_o[of \\<xi> \\<rho>]"], ["proof (prove)\nusing this:\n  satC (int \\<xi> \\<circ> \\<rho>) ?c = satC \\<xi> (substC \\<rho> ?c)\n\ngoal (1 subgoal):\n 1. satPB (int \\<xi> \\<circ> \\<rho>) \\<Phi> =\n    satPB \\<xi> (substPB \\<rho> \\<Phi>)", "unfolding satPB_def substPB_def"], ["proof (prove)\nusing this:\n  satC (int \\<xi> \\<circ> \\<rho>) ?c = satC \\<xi> (substC \\<rho> ?c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>\\<Phi>. satC (int \\<xi> \\<circ> \\<rho>) c) =\n    (\\<forall>c\\<in>{substC \\<rho> c |c. c \\<in> \\<Phi>}. satC \\<xi> c)", "by auto"], ["", "lemmas satPB_subst = satPB_o[symmetric]"], ["", "lemma satPB_o_subst:\n\"satPB \\<xi> o substPB \\<rho> = satPB (int \\<xi> o \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB \\<xi> \\<circ> substPB \\<rho> = satPB (int \\<xi> \\<circ> \\<rho>)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (satPB \\<xi> \\<circ> substPB \\<rho>) x =\n       satPB (int \\<xi> \\<circ> \\<rho>) x", "apply(subst comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       satPB \\<xi> (substPB \\<rho> x) = satPB (int \\<xi> \\<circ> \\<rho>) x", "unfolding satPB_o[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       satPB (int \\<xi> \\<circ> \\<rho>) x =\n       satPB (int \\<xi> \\<circ> \\<rho>) x", ".."], ["", "lemma wtE_o:\nassumes 1: \"wtE \\<xi>\" and 2: \"wtSB \\<rho>\"\nshows \"wtE (int \\<xi> o \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (int \\<xi> \\<circ> \\<rho>)", "unfolding wtE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. intT (tpOfV x) ((int \\<xi> \\<circ> \\<rho>) x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. intT (tpOfV x) ((int \\<xi> \\<circ> \\<rho>) x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. intT (tpOfV x) ((int \\<xi> \\<circ> \\<rho>) x)", "have 0: \"tpOfV x = tpOf (\\<rho> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tpOfV x = tpOf (\\<rho> x)", "using 2"], ["proof (prove)\nusing this:\n  wtSB \\<rho>\n\ngoal (1 subgoal):\n 1. tpOfV x = tpOf (\\<rho> x)", "by auto"], ["proof (state)\nthis:\n  tpOfV x = tpOf (\\<rho> x)\n\ngoal (1 subgoal):\n 1. \\<And>x. intT (tpOfV x) ((int \\<xi> \\<circ> \\<rho>) x)", "show \"intT (tpOfV x) ((int \\<xi> \\<circ> \\<rho>) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (tpOfV x) ((int \\<xi> \\<circ> \\<rho>) x)", "apply(subst 0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (tpOf (\\<rho> x)) ((int \\<xi> \\<circ> \\<rho>) x)", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (tpOf (\\<rho> x)) (int \\<xi> (\\<rho> x))", "apply(rule wt_int[OF 1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (\\<rho> x)", "using 2"], ["proof (prove)\nusing this:\n  wtSB \\<rho>\n\ngoal (1 subgoal):\n 1. wt (\\<rho> x)", "by auto"], ["proof (state)\nthis:\n  intT (tpOfV x) ((int \\<xi> \\<circ> \\<rho>) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* fixme: unify compE and int \\<xi> o \\<rho>, since they are the same *)"], ["", "definition \"compE \\<rho> \\<xi> x \\<equiv> int \\<xi> (\\<rho> x)\""], ["", "lemma wtE_compE:\nassumes \"wtSB \\<rho>\" and \"wtE \\<xi>\"  shows \"wtE (compE \\<rho> \\<xi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (compE \\<rho> \\<xi>)", "unfolding wtE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. intT (tpOfV x) (compE \\<rho> \\<xi> x)", "using assms wt_int"], ["proof (prove)\nusing this:\n  wtSB \\<rho>\n  wtE \\<xi>\n  \\<lbrakk>wtE ?\\<xi>; wt ?T\\<rbrakk>\n  \\<Longrightarrow> intT (tpOf ?T) (int ?\\<xi> ?T)\n\ngoal (1 subgoal):\n 1. \\<forall>x. intT (tpOfV x) (compE \\<rho> \\<xi> x)", "unfolding wtSB_def compE_def"], ["proof (prove)\nusing this:\n  \\<forall>x. wt (\\<rho> x) \\<and> tpOf (\\<rho> x) = tpOfV x\n  wtE \\<xi>\n  \\<lbrakk>wtE ?\\<xi>; wt ?T\\<rbrakk>\n  \\<Longrightarrow> intT (tpOf ?T) (int ?\\<xi> ?T)\n\ngoal (1 subgoal):\n 1. \\<forall>x. intT (tpOfV x) (int \\<xi> (\\<rho> x))", "by fastforce"], ["", "lemma compE_upd: \"compE (\\<rho> (x := T)) \\<xi> = (compE \\<rho> \\<xi>) (x := int \\<xi> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compE (\\<rho>(x := T)) \\<xi> = (compE \\<rho> \\<xi>)(x := int \\<xi> T)", "unfolding compE_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa. int \\<xi> ((\\<rho>(x := T)) xa)) =\n    (\\<lambda>x. int \\<xi> (\\<rho> x))(x := int \\<xi> T)", "by auto"], ["", "end"], ["", "(* context Struct *)"], ["", "context Signature begin"], ["", "(* The function symbols of: *)"], ["", "fun fsyms where\n\"fsyms (Var x) = {}\"\n|\n\"fsyms (Fn f Tl) = {f} \\<union> \\<Union> (set (map fsyms Tl))\""], ["", "fun fsymsA where\n\"fsymsA (Eq T1 T2) = fsyms T1 \\<union> fsyms T2\"\n|\n\"fsymsA (Pr p Tl) = \\<Union> (set (map fsyms Tl))\""], ["", "fun fsymsL where\n\"fsymsL (Pos at) = fsymsA at\"\n|\n\"fsymsL (Neg at) = fsymsA at\""], ["", "definition \"fsymsC c = \\<Union> (set (map fsymsL c))\""], ["", "definition \"fsymsPB \\<Phi> = \\<Union> {fsymsC c | c. c \\<in> \\<Phi>}\""], ["", "lemma fsyms_int_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsyms T \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.int intF1 \\<xi> T = Struct.int intF2 \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Struct.int intF1 \\<xi> T = Struct.int intF2 \\<xi> T", "using 0"], ["proof (prove)\nusing this:\n  ?f1 \\<in> fsyms T \\<Longrightarrow> intF1 ?f1 = intF2 ?f1\n\ngoal (1 subgoal):\n 1. Struct.int intF1 \\<xi> T = Struct.int intF2 \\<xi> T", "proof(induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>f.\n           f \\<in> fsyms (Var x) \\<Longrightarrow>\n           intF1 f = intF2 f) \\<Longrightarrow>\n       Struct.int intF1 \\<xi> (Var x) = Struct.int intF2 \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<forall>x.\n                         x \\<in> fsyms a \\<longrightarrow>\n                         intF1 x = intF2 x) \\<longrightarrow>\n                     Struct.int intF1 \\<xi> a = Struct.int intF2 \\<xi> a)\n                 Tl;\n        \\<And>fa.\n           fa \\<in> fsyms (Fn f Tl) \\<Longrightarrow>\n           intF1 fa = intF2 fa\\<rbrakk>\n       \\<Longrightarrow> Struct.int intF1 \\<xi> (Fn f Tl) =\n                         Struct.int intF2 \\<xi> (Fn f Tl)", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       (\\<forall>x.\n           x \\<in> fsyms a \\<longrightarrow>\n           intF1 x = intF2 x) \\<longrightarrow>\n       Struct.int intF1 \\<xi> a = Struct.int intF2 \\<xi> a)\n   Tl\n  ?f1 \\<in> fsyms (Fn f Tl) \\<Longrightarrow> intF1 ?f1 = intF2 ?f1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>f.\n           f \\<in> fsyms (Var x) \\<Longrightarrow>\n           intF1 f = intF2 f) \\<Longrightarrow>\n       Struct.int intF1 \\<xi> (Var x) = Struct.int intF2 \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<forall>x.\n                         x \\<in> fsyms a \\<longrightarrow>\n                         intF1 x = intF2 x) \\<longrightarrow>\n                     Struct.int intF1 \\<xi> a = Struct.int intF2 \\<xi> a)\n                 Tl;\n        \\<And>fa.\n           fa \\<in> fsyms (Fn f Tl) \\<Longrightarrow>\n           intF1 fa = intF2 fa\\<rbrakk>\n       \\<Longrightarrow> Struct.int intF1 \\<xi> (Fn f Tl) =\n                         Struct.int intF2 \\<xi> (Fn f Tl)", "hence 1: \"map (Struct.int intF1 \\<xi>) Tl = map (Struct.int intF2 \\<xi>) Tl\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       (\\<forall>x.\n           x \\<in> fsyms a \\<longrightarrow>\n           intF1 x = intF2 x) \\<longrightarrow>\n       Struct.int intF1 \\<xi> a = Struct.int intF2 \\<xi> a)\n   Tl\n  ?f1 \\<in> fsyms (Fn f Tl) \\<Longrightarrow> intF1 ?f1 = intF2 ?f1\n\ngoal (1 subgoal):\n 1. map (Struct.int intF1 \\<xi>) Tl = map (Struct.int intF2 \\<xi>) Tl", "unfolding list_all_iff map_ext"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set Tl.\n     (\\<forall>x.\n         x \\<in> fsyms a \\<longrightarrow>\n         intF1 x = intF2 x) \\<longrightarrow>\n     Struct.int intF1 \\<xi> a = Struct.int intF2 \\<xi> a\n  ?f1 \\<in> fsyms (Fn f Tl) \\<Longrightarrow> intF1 ?f1 = intF2 ?f1\n\ngoal (1 subgoal):\n 1. map (Struct.int intF1 \\<xi>) Tl = map (Struct.int intF2 \\<xi>) Tl", "by auto"], ["proof (state)\nthis:\n  map (Struct.int intF1 \\<xi>) Tl = map (Struct.int intF2 \\<xi>) Tl\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>f.\n           f \\<in> fsyms (Var x) \\<Longrightarrow>\n           intF1 f = intF2 f) \\<Longrightarrow>\n       Struct.int intF1 \\<xi> (Var x) = Struct.int intF2 \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<forall>x.\n                         x \\<in> fsyms a \\<longrightarrow>\n                         intF1 x = intF2 x) \\<longrightarrow>\n                     Struct.int intF1 \\<xi> a = Struct.int intF2 \\<xi> a)\n                 Tl;\n        \\<And>fa.\n           fa \\<in> fsyms (Fn f Tl) \\<Longrightarrow>\n           intF1 fa = intF2 fa\\<rbrakk>\n       \\<Longrightarrow> Struct.int intF1 \\<xi> (Fn f Tl) =\n                         Struct.int intF2 \\<xi> (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Struct.int intF1 \\<xi> (Fn f Tl) = Struct.int intF2 \\<xi> (Fn f Tl)", "using Fn Struct.int.simps[OF S1, of \\<xi>] Struct.int.simps[OF S2, of \\<xi>]"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       (\\<forall>x.\n           x \\<in> fsyms a \\<longrightarrow>\n           intF1 x = intF2 x) \\<longrightarrow>\n       Struct.int intF1 \\<xi> a = Struct.int intF2 \\<xi> a)\n   Tl\n  ?f1 \\<in> fsyms (Fn f Tl) \\<Longrightarrow> intF1 ?f1 = intF2 ?f1\n  Struct.int intF1 \\<xi> (Var ?x) = \\<xi> ?x\n  Struct.int intF1 \\<xi> (Fn ?f ?Tl) =\n  intF1 ?f (map (Struct.int intF1 \\<xi>) ?Tl)\n  Struct.int intF2 \\<xi> (Var ?x) = \\<xi> ?x\n  Struct.int intF2 \\<xi> (Fn ?f ?Tl) =\n  intF2 ?f (map (Struct.int intF2 \\<xi>) ?Tl)\n\ngoal (1 subgoal):\n 1. Struct.int intF1 \\<xi> (Fn f Tl) = Struct.int intF2 \\<xi> (Fn f Tl)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all\n              (\\<lambda>a.\n                  (\\<forall>x.\n                      x \\<in> fsyms a \\<longrightarrow>\n                      intF1 x = intF2 x) \\<longrightarrow>\n                  Struct.int intF1 \\<xi> a = Struct.int intF2 \\<xi> a)\n              Tl;\n     \\<And>fa.\n        fa = f \\<or>\n        (\\<exists>x\\<in>set Tl. fa \\<in> fsyms x) \\<Longrightarrow>\n        intF1 fa = intF2 fa;\n     \\<And>x. Struct.int intF1 \\<xi> (Var x) = \\<xi> x;\n     \\<And>f Tl.\n        Struct.int intF1 \\<xi> (Fn f Tl) =\n        intF1 f (map (Struct.int intF1 \\<xi>) Tl);\n     \\<And>x. Struct.int intF2 \\<xi> (Var x) = \\<xi> x;\n     \\<And>f Tl.\n        Struct.int intF2 \\<xi> (Fn f Tl) =\n        intF2 f (map (Struct.int intF2 \\<xi>) Tl)\\<rbrakk>\n    \\<Longrightarrow> intF2 f (map (Struct.int intF1 \\<xi>) Tl) =\n                      intF2 f (map (Struct.int intF2 \\<xi>) Tl)", "using 1"], ["proof (prove)\nusing this:\n  map (Struct.int intF1 \\<xi>) Tl = map (Struct.int intF2 \\<xi>) Tl\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all\n              (\\<lambda>a.\n                  (\\<forall>x.\n                      x \\<in> fsyms a \\<longrightarrow>\n                      intF1 x = intF2 x) \\<longrightarrow>\n                  Struct.int intF1 \\<xi> a = Struct.int intF2 \\<xi> a)\n              Tl;\n     \\<And>fa.\n        fa = f \\<or>\n        (\\<exists>x\\<in>set Tl. fa \\<in> fsyms x) \\<Longrightarrow>\n        intF1 fa = intF2 fa;\n     \\<And>x. Struct.int intF1 \\<xi> (Var x) = \\<xi> x;\n     \\<And>f Tl.\n        Struct.int intF1 \\<xi> (Fn f Tl) =\n        intF1 f (map (Struct.int intF1 \\<xi>) Tl);\n     \\<And>x. Struct.int intF2 \\<xi> (Var x) = \\<xi> x;\n     \\<And>f Tl.\n        Struct.int intF2 \\<xi> (Fn f Tl) =\n        intF2 f (map (Struct.int intF2 \\<xi>) Tl)\\<rbrakk>\n    \\<Longrightarrow> intF2 f (map (Struct.int intF1 \\<xi>) Tl) =\n                      intF2 f (map (Struct.int intF2 \\<xi>) Tl)", "by metis"], ["proof (state)\nthis:\n  Struct.int intF1 \\<xi> (Fn f Tl) = Struct.int intF2 \\<xi> (Fn f Tl)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>f.\n           f \\<in> fsyms (Var x) \\<Longrightarrow>\n           intF1 f = intF2 f) \\<Longrightarrow>\n       Struct.int intF1 \\<xi> (Var x) = Struct.int intF2 \\<xi> (Var x)", "qed (auto simp: Struct.int.simps[OF S1, of \\<xi>] Struct.int.simps[OF S2, of \\<xi>])"], ["", "lemma fsyms_satA_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsymsA at \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.satA intF1 intP \\<xi> at \\<longleftrightarrow> Struct.satA intF2 intP \\<xi> at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Struct.satA intF1 intP \\<xi> at = Struct.satA intF2 intP \\<xi> at", "using 0 fsyms_int_cong[OF S1 S2]"], ["proof (prove)\nusing this:\n  ?f1 \\<in> fsymsA at \\<Longrightarrow> intF1 ?f1 = intF2 ?f1\n  (\\<And>f.\n      f \\<in> fsyms ?T \\<Longrightarrow>\n      intF1 f = intF2 f) \\<Longrightarrow>\n  Struct.int intF1 ?\\<xi> ?T = Struct.int intF2 ?\\<xi> ?T\n\ngoal (1 subgoal):\n 1. Struct.satA intF1 intP \\<xi> at = Struct.satA intF2 intP \\<xi> at", "apply(cases at)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>\\<And>f.\n                   f \\<in> fsymsA at \\<Longrightarrow> intF1 f = intF2 f;\n        \\<And>T \\<xi>.\n           (\\<And>f.\n               f \\<in> fsyms T \\<Longrightarrow>\n               intF1 f = intF2 f) \\<Longrightarrow>\n           Struct.int intF1 \\<xi> T = Struct.int intF2 \\<xi> T;\n        at = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> Struct.satA intF1 intP \\<xi> at =\n                         Struct.satA intF2 intP \\<xi> at\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>f.\n                   f \\<in> fsymsA at \\<Longrightarrow> intF1 f = intF2 f;\n        \\<And>T \\<xi>.\n           (\\<And>f.\n               f \\<in> fsyms T \\<Longrightarrow>\n               intF1 f = intF2 f) \\<Longrightarrow>\n           Struct.int intF1 \\<xi> T = Struct.int intF2 \\<xi> T;\n        at = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> Struct.satA intF1 intP \\<xi> at =\n                         Struct.satA intF2 intP \\<xi> at", "apply(fastforce intro!: fsyms_int_cong[OF S1 S2, of _ \\<xi>]\n                simp: Struct.satA.simps[OF S1, of \\<xi>] Struct.satA.simps[OF S2, of \\<xi>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>f.\n                   f \\<in> fsymsA at \\<Longrightarrow> intF1 f = intF2 f;\n        \\<And>T \\<xi>.\n           (\\<And>f.\n               f \\<in> fsyms T \\<Longrightarrow>\n               intF1 f = intF2 f) \\<Longrightarrow>\n           Struct.int intF1 \\<xi> T = Struct.int intF2 \\<xi> T;\n        at = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> Struct.satA intF1 intP \\<xi> at =\n                         Struct.satA intF2 intP \\<xi> at", "apply (simp add: Struct.satA.simps[OF S1, of \\<xi>] Struct.satA.simps[OF S2, of \\<xi>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>f.\n                   \\<exists>x\\<in>set x22. f \\<in> fsyms x \\<Longrightarrow>\n                   intF1 f = intF2 f;\n        \\<And>T \\<xi>.\n           (\\<And>f.\n               f \\<in> fsyms T \\<Longrightarrow>\n               intF1 f = intF2 f) \\<Longrightarrow>\n           Struct.int intF1 \\<xi> T = Struct.int intF2 \\<xi> T;\n        at = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> intP x21 (map (Struct.int intF1 \\<xi>) x22) =\n                         intP x21 (map (Struct.int intF2 \\<xi>) x22)", "by (metis (hide_lams, mono_tags) map_eq_conv)"], ["", "lemma fsyms_satL_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsymsL l \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.satL intF1 intP \\<xi> l \\<longleftrightarrow> Struct.satL intF2 intP \\<xi> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Struct.satL intF1 intP \\<xi> l = Struct.satL intF2 intP \\<xi> l", "using 0 fsyms_satA_cong[OF S1 S2]"], ["proof (prove)\nusing this:\n  ?f1 \\<in> fsymsL l \\<Longrightarrow> intF1 ?f1 = intF2 ?f1\n  (\\<And>f.\n      f \\<in> fsymsA ?at \\<Longrightarrow>\n      intF1 f = intF2 f) \\<Longrightarrow>\n  Struct.satA intF1 intP ?\\<xi> ?at = Struct.satA intF2 intP ?\\<xi> ?at\n\ngoal (1 subgoal):\n 1. Struct.satL intF1 intP \\<xi> l = Struct.satL intF2 intP \\<xi> l", "by (cases l, auto simp: Struct.satL.simps[OF S1, of \\<xi>] Struct.satL.simps[OF S2, of \\<xi>])"], ["", "lemma fsyms_satC_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsymsC c \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.satC intF1 intP \\<xi> c \\<longleftrightarrow> Struct.satC intF2 intP \\<xi> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Struct.satC intF1 intP \\<xi> c = Struct.satC intF2 intP \\<xi> c", "using 0 fsyms_satL_cong[OF S1 S2]"], ["proof (prove)\nusing this:\n  ?f1 \\<in> fsymsC c \\<Longrightarrow> intF1 ?f1 = intF2 ?f1\n  (\\<And>f.\n      f \\<in> fsymsL ?l \\<Longrightarrow>\n      intF1 f = intF2 f) \\<Longrightarrow>\n  Struct.satL intF1 intP ?\\<xi> ?l = Struct.satL intF2 intP ?\\<xi> ?l\n\ngoal (1 subgoal):\n 1. Struct.satC intF1 intP \\<xi> c = Struct.satC intF2 intP \\<xi> c", "unfolding Struct.satC_def[OF S1] Struct.satC_def[OF S2] fsymsC_def"], ["proof (prove)\nusing this:\n  ?f1 \\<in> \\<Union> (set (map fsymsL c)) \\<Longrightarrow>\n  intF1 ?f1 = intF2 ?f1\n  (\\<And>f.\n      f \\<in> fsymsL ?l \\<Longrightarrow>\n      intF1 f = intF2 f) \\<Longrightarrow>\n  Struct.satL intF1 intP ?\\<xi> ?l = Struct.satL intF2 intP ?\\<xi> ?l\n\ngoal (1 subgoal):\n 1. list_ex (Struct.satL intF1 intP \\<xi>) c =\n    list_ex (Struct.satL intF2 intP \\<xi>) c", "apply (induct c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>f.\n                f \\<in> \\<Union> (set (map fsymsL [])) \\<Longrightarrow>\n                intF1 f = intF2 f;\n     \\<And>l \\<xi>.\n        (\\<And>f.\n            f \\<in> fsymsL l \\<Longrightarrow>\n            intF1 f = intF2 f) \\<Longrightarrow>\n        Struct.satL intF1 intP \\<xi> l =\n        Struct.satL intF2 intP \\<xi> l\\<rbrakk>\n    \\<Longrightarrow> list_ex (Struct.satL intF1 intP \\<xi>) [] =\n                      list_ex (Struct.satL intF2 intP \\<xi>) []\n 2. \\<And>a c.\n       \\<lbrakk>\\<lbrakk>\\<And>f.\n                            f \\<in> \\<Union>\n                                     (set (map fsymsL c)) \\<Longrightarrow>\n                            intF1 f = intF2 f;\n                 \\<And>l \\<xi>.\n                    (\\<And>f.\n                        f \\<in> fsymsL l \\<Longrightarrow>\n                        intF1 f = intF2 f) \\<Longrightarrow>\n                    Struct.satL intF1 intP \\<xi> l =\n                    Struct.satL intF2 intP \\<xi> l\\<rbrakk>\n                \\<Longrightarrow> list_ex (Struct.satL intF1 intP \\<xi>) c =\n                                  list_ex (Struct.satL intF2 intP \\<xi>) c;\n        \\<And>f.\n           f \\<in> \\<Union> (set (map fsymsL (a # c))) \\<Longrightarrow>\n           intF1 f = intF2 f;\n        \\<And>l \\<xi>.\n           (\\<And>f.\n               f \\<in> fsymsL l \\<Longrightarrow>\n               intF1 f = intF2 f) \\<Longrightarrow>\n           Struct.satL intF1 intP \\<xi> l =\n           Struct.satL intF2 intP \\<xi> l\\<rbrakk>\n       \\<Longrightarrow> list_ex (Struct.satL intF1 intP \\<xi>) (a # c) =\n                         list_ex (Struct.satL intF2 intP \\<xi>) (a # c)", "by (fastforce intro!: fsyms_satL_cong[OF S1 S2])+"], ["", "lemma fsyms_satPB_cong:\nassumes S1: \"Struct wtFsym wtPsym arOf resOf intT intF1 intP\"\nand S2: \"Struct wtFsym wtPsym arOf resOf intT intF2 intP\"\nand 0: \"\\<And> f. f \\<in> fsymsPB \\<Phi> \\<Longrightarrow> intF1 f = intF2 f\"\nshows \"Struct.satPB intF1 intP \\<xi> \\<Phi> \\<longleftrightarrow> Struct.satPB intF2 intP \\<xi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Struct.satPB intF1 intP \\<xi> \\<Phi> =\n    Struct.satPB intF2 intP \\<xi> \\<Phi>", "by (force simp: Struct.satPB_def[OF S1] Struct.satPB_def[OF S2] fsymsPB_def\n          intro!: fsyms_satC_cong[OF S1 S2] ball_cong 0)"], ["", "lemma fsymsPB_Un[simp]: \"fsymsPB (\\<Phi>1 \\<union> \\<Phi>2) = fsymsPB \\<Phi>1 \\<union> fsymsPB \\<Phi>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fsymsPB (\\<Phi>1 \\<union> \\<Phi>2) =\n    fsymsPB \\<Phi>1 \\<union> fsymsPB \\<Phi>2", "unfolding fsymsPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {fsymsC c |c. c \\<in> \\<Phi>1 \\<union> \\<Phi>2} =\n    \\<Union> {fsymsC c |c. c \\<in> \\<Phi>1} \\<union>\n    \\<Union> {fsymsC c |c. c \\<in> \\<Phi>2}", "by auto"], ["", "lemma fsymsC_append[simp]: \"fsymsC (c1 @ c2) = fsymsC c1 \\<union> fsymsC c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fsymsC (c1 @ c2) = fsymsC c1 \\<union> fsymsC c2", "unfolding fsymsC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (map fsymsL (c1 @ c2))) =\n    \\<Union> (set (map fsymsL c1)) \\<union> \\<Union> (set (map fsymsL c2))", "by auto"], ["", "lemma fsymsPB_sappend_incl[simp]:\n\"fsymsPB (\\<Phi>1 @@ \\<Phi>2) \\<subseteq>  fsymsPB \\<Phi>1 \\<union> fsymsPB \\<Phi>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n    \\<subseteq> fsymsPB \\<Phi>1 \\<union> fsymsPB \\<Phi>2", "by (unfold fsymsPB_def sappend_def, fastforce)"], ["", "lemma fsymsPB_sappend[simp]:\nassumes 1: \"\\<Phi>1 \\<noteq> {}\" and 2: \"\\<Phi>2 \\<noteq> {}\"\nshows \"fsymsPB (\\<Phi>1 @@ \\<Phi>2) = fsymsPB \\<Phi>1 \\<union> fsymsPB \\<Phi>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fsymsPB (\\<Phi>1 @@ \\<Phi>2) = fsymsPB \\<Phi>1 \\<union> fsymsPB \\<Phi>2", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>1 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n 3. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>1 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n 3. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>1 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n 3. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "assume \"x \\<in> fsymsPB \\<Phi>1\""], ["proof (state)\nthis:\n  x \\<in> fsymsPB \\<Phi>1\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>1 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n 3. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "then"], ["proof (chain)\npicking this:\n  x \\<in> fsymsPB \\<Phi>1", "obtain c1 c2 where \"x \\<in> fsymsC c1\" and \"c1 \\<in> \\<Phi>1\" and \"c2 \\<in> \\<Phi>2\""], ["proof (prove)\nusing this:\n  x \\<in> fsymsPB \\<Phi>1\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>x \\<in> fsymsC c1; c1 \\<in> \\<Phi>1;\n         c2 \\<in> \\<Phi>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2"], ["proof (prove)\nusing this:\n  x \\<in> fsymsPB \\<Phi>1\n  \\<Phi>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>x \\<in> fsymsC c1; c1 \\<in> \\<Phi>1;\n         c2 \\<in> \\<Phi>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fsymsPB_def"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> {fsymsC c |c. c \\<in> \\<Phi>1}\n  \\<Phi>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>x \\<in> fsymsC c1; c1 \\<in> \\<Phi>1;\n         c2 \\<in> \\<Phi>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> fsymsC c1\n  c1 \\<in> \\<Phi>1\n  c2 \\<in> \\<Phi>2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>1 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n 3. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "thus \"x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\""], ["proof (prove)\nusing this:\n  x \\<in> fsymsC c1\n  c1 \\<in> \\<Phi>1\n  c2 \\<in> \\<Phi>2\n\ngoal (1 subgoal):\n 1. x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "unfolding sappend_def fsymsPB_def"], ["proof (prove)\nusing this:\n  x \\<in> fsymsC c1\n  c1 \\<in> \\<Phi>1\n  c2 \\<in> \\<Phi>2\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union>\n             {fsymsC c |c.\n              c \\<in> {al @ bl |al bl.\n                       al \\<in> \\<Phi>1 \\<and> bl \\<in> \\<Phi>2}}", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "}"], ["proof (state)\nthis:\n  x \\<in> fsymsPB \\<Phi>1 \\<Longrightarrow>\n  x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "{"], ["proof (state)\nthis:\n  x \\<in> fsymsPB \\<Phi>1 \\<Longrightarrow>\n  x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "assume \"x \\<in> fsymsPB \\<Phi>2\""], ["proof (state)\nthis:\n  x \\<in> fsymsPB \\<Phi>2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "then"], ["proof (chain)\npicking this:\n  x \\<in> fsymsPB \\<Phi>2", "obtain c1 c2 where \"x \\<in> fsymsC c2\" and \"c1 \\<in> \\<Phi>1\" and \"c2 \\<in> \\<Phi>2\""], ["proof (prove)\nusing this:\n  x \\<in> fsymsPB \\<Phi>2\n\ngoal (1 subgoal):\n 1. (\\<And>c2 c1.\n        \\<lbrakk>x \\<in> fsymsC c2; c1 \\<in> \\<Phi>1;\n         c2 \\<in> \\<Phi>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  x \\<in> fsymsPB \\<Phi>2\n  \\<Phi>1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>c2 c1.\n        \\<lbrakk>x \\<in> fsymsC c2; c1 \\<in> \\<Phi>1;\n         c2 \\<in> \\<Phi>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fsymsPB_def"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> {fsymsC c |c. c \\<in> \\<Phi>2}\n  \\<Phi>1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>c2 c1.\n        \\<lbrakk>x \\<in> fsymsC c2; c1 \\<in> \\<Phi>1;\n         c2 \\<in> \\<Phi>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> fsymsC c2\n  c1 \\<in> \\<Phi>1\n  c2 \\<in> \\<Phi>2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1\n 2. \\<And>x.\n       x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n       x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "thus \"x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\""], ["proof (prove)\nusing this:\n  x \\<in> fsymsC c2\n  c1 \\<in> \\<Phi>1\n  c2 \\<in> \\<Phi>2\n\ngoal (1 subgoal):\n 1. x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)", "unfolding sappend_def fsymsPB_def"], ["proof (prove)\nusing this:\n  x \\<in> fsymsC c2\n  c1 \\<in> \\<Phi>1\n  c2 \\<in> \\<Phi>2\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union>\n             {fsymsC c |c.\n              c \\<in> {al @ bl |al bl.\n                       al \\<in> \\<Phi>1 \\<and> bl \\<in> \\<Phi>2}}", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1", "}"], ["proof (state)\nthis:\n  x \\<in> fsymsPB \\<Phi>2 \\<Longrightarrow>\n  x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> fsymsPB (\\<Phi>1 @@ \\<Phi>2);\n        x \\<notin> fsymsPB \\<Phi>2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fsymsPB \\<Phi>1", "qed(unfold fsymsPB_def sappend_def, fastforce)"], ["", "lemma Struct_upd:\nassumes \"Struct wtFsym wtPsym arOf resOf intT intF intP\"\nand \"\\<And> al. list_all2 intT (arOf ef) al \\<Longrightarrow> intT (resOf ef) (EF al)\"\nshows \"Struct wtFsym wtPsym arOf resOf intT (intF (ef := EF)) intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Struct wtFsym wtPsym arOf resOf intT (intF(ef := EF)) intP", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (resOf f) ((intF(ef := EF)) f al)\n 3. intP = intP", "using assms"], ["proof (prove)\nusing this:\n  Struct wtFsym wtPsym arOf resOf intT intF intP\n  list_all2 intT (arOf ef) ?al1 \\<Longrightarrow> intT (resOf ef) (EF ?al1)\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (resOf f) ((intF(ef := EF)) f al)\n 3. intP = intP", "unfolding Struct_def Struct_axioms_def Tstruct_def"], ["proof (prove)\nusing this:\n  Signature TYPE('tp) wtFsym wtPsym \\<and>\n  (\\<forall>\\<sigma>. \\<exists>a. intT \\<sigma> a) \\<and>\n  (\\<forall>f al.\n      wtFsym f \\<longrightarrow>\n      list_all2 intT (arOf f) al \\<longrightarrow>\n      intT (resOf f) (intF f al)) \\<and>\n  intP = intP\n  list_all2 intT (arOf ef) ?al1 \\<Longrightarrow> intT (resOf ef) (EF ?al1)\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (resOf f) ((intF(ef := EF)) f al)\n 3. intP = intP", "by auto"], ["", "end"], ["", "(* context Signature *)"], ["", "subsection\\<open>Problems\\<close>"], ["", "text\\<open>A problem is a potentially infinitary formula in clausal form, i.e., \na potentially infinite conjunction of clauses.\\<close>"], ["", "locale Problem = Signature wtFsym wtPsym arOf resOf parOf\nfor wtFsym wtPsym\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf :: \"'fsym \\<Rightarrow> 'tp\"\nand parOf :: \"'psym \\<Rightarrow> 'tp list\"\n+\nfixes \\<Phi> :: \"('fsym, 'psym) prob\"\nassumes wt_\\<Phi>: \"wtPB \\<Phi>\""], ["", "subsection\\<open>Models of a problem\\<close>"], ["", "text\\<open>Model of a problem:\\<close>"], ["", "locale Model = Problem + Struct +\nassumes SAT: \"SAT \\<Phi>\"\nbegin"], ["", "lemma sat_\\<Phi>: \"wtE \\<xi> \\<Longrightarrow> satPB \\<xi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE \\<xi> \\<Longrightarrow> satPB \\<xi> \\<Phi>", "using SAT"], ["proof (prove)\nusing this:\n  SAT \\<Phi>\n\ngoal (1 subgoal):\n 1. wtE \\<xi> \\<Longrightarrow> satPB \\<xi> \\<Phi>", "unfolding SAT_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<xi>. wtE \\<xi> \\<longrightarrow> satPB \\<xi> \\<Phi>\n\ngoal (1 subgoal):\n 1. wtE \\<xi> \\<Longrightarrow> satPB \\<xi> \\<Phi>", "by auto"], ["", "end"], ["", "end"]]}