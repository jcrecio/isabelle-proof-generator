{"file_name": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings/Mcalc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings", "problem_names": ["lemma nvT_vars[simp]: \"x \\<in> nvT T \\<Longrightarrow> x \\<in> vars T\"", "lemma nvA_varsA[simp]: \"x \\<in> nvA at \\<Longrightarrow> x \\<in> varsA at\"", "lemma nvL_varsL[simp]: \"x \\<in> nvL l \\<Longrightarrow> x \\<in> varsL l\"", "lemma nvC_varsC[simp]: \"x \\<in> nvC c \\<Longrightarrow> x \\<in> varsC c\"", "lemma nvPB_varsPB[simp]: \"x \\<in> nvPB \\<Longrightarrow> x \\<in> varsPB \\<Phi>\"", "lemma mcalc_iff: \"\\<sigma> \\<turnstile> c \\<longleftrightarrow> infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvC c. tpOfV x \\<noteq> \\<sigma>)\"", "lemma intT_proj[simp]: \"intT \\<sigma> (proj \\<sigma> a)\"", "lemma proj_id[simp]: \"intT \\<sigma> a \\<Longrightarrow> proj \\<sigma> a = a\"", "lemma surj_proj:\nassumes \"intT \\<sigma> a\"   shows \"\\<exists> b. proj \\<sigma> b = a\"", "lemma not_infTp_I_intT[simp]: \"\\<not> infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a\"", "lemma infTp_I_intT[simp]: \"infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a = intT \\<sigma> a\"", "lemma NE_I_intT: \"NE (I_intT \\<sigma>)\"", "lemma I_intF:\nassumes f: \"wtFsym f\" and al: \"list_all2 I_intT (arOf f) al\"\nshows \"I_intT (resOf f) (I_intF f al)\"", "lemma Tstruct_I_intT: \"Tstruct I_intT\"", "lemma inf_I_intT: \"infinite {a. I_intT \\<sigma> a}\"", "lemma InfStruct: \"IInfStruct I_intT I_intF I_intP\"", "lemma transE[simp]: \"transE \\<xi> x = proj (tpOfV x) (\\<xi> x)\"", "lemma wtE_transE[simp]: \"I.wtE \\<xi> \\<Longrightarrow> Ik.wtE (transE \\<xi>)\"", "lemma Ik_intT_int:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\"\nand snv: \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvT T. tpOfV x \\<noteq> \\<sigma>)\"\nshows \"Ik_intT (tpOf T) (I.int \\<xi> T)\"", "lemma int_transE_proj:\n  assumes wt: \"Ik.wt T\"\n  shows \"Ik.int (transE \\<xi>) T = proj (tpOf T) (I.int \\<xi> T)\"", "lemma int_transE_snv[simp]:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\" and snv: \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvT T. tpOfV x \\<noteq> \\<sigma>)\"\nshows \"Ik.int (transE \\<xi>) T = I.int \\<xi> T\"", "lemma int_transE_Fn:\nassumes wt: \"list_all wt Tl\" and f: \"wtFsym f\" and \\<xi>: \"I.wtE \\<xi>\"\nand ar: \"arOf f = map tpOf Tl\"\nshows \"Ik.int (transE \\<xi>) (Fn f Tl) = I.int \\<xi> (Fn f Tl)\"", "lemma intP_transE[simp]:\nassumes wt: \"list_all wt Tl\" and p: \"wtPsym p\" and ar: \"parOf p = map tpOf Tl\"\nshows \"Ik_intP p (map (Ik.int (transE \\<xi>)) Tl) = I_intP p (map (I.int \\<xi>) Tl)\"", "lemma satA_snvA_transE[simp]:\nassumes wtA: \"Ik.wtA at\" and \\<xi>: \"I.wtE \\<xi>\"\nand pA: \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvA at. tpOfV x \\<noteq> \\<sigma>)\"\nshows \"Ik.satA (transE \\<xi>) at \\<longleftrightarrow> I.satA \\<xi> at\"", "lemma satA_transE[simp]:\nassumes wtA: \"Ik.wtA at\" and \"I.satA \\<xi> at\"\nshows \"Ik.satA (transE \\<xi>) at\"", "lemma satL_snvL_transE[simp]:\nassumes wtL: \"Ik.wtL l\" and \\<xi>: \"I.wtE \\<xi>\"\nand pL: \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvL l. tpOfV x \\<noteq> \\<sigma>)\" and \"Ik.satL (transE \\<xi>) l\"\nshows \"I.satL \\<xi> l\"", "lemma satC_snvC_transE[simp]:\nassumes wtC: \"Ik.wtC c\" and \\<xi>: \"I.wtE \\<xi>\"\nand pC: \"\\<And> \\<sigma>. \\<sigma> \\<turnstile> c\" and \"Ik.satC (transE \\<xi>) c\"\nshows \"I.satC \\<xi> c\"", "lemma satPB_snvPB_transE[simp]:\nassumes \\<xi>: \"I.wtE \\<xi>\"  shows \"I.satPB \\<xi> \\<Phi>\"", "lemma I_SAT: \"I.SAT \\<Phi>\"", "lemma InfModel: \"IInfModel I_intT I_intF I_intP\"", "theorem monot: monot"], "translations": [["", "lemma nvT_vars[simp]: \"x \\<in> nvT T \\<Longrightarrow> x \\<in> vars T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> nvT T \\<Longrightarrow> x \\<in> vars T", "by (induct T) (auto split: if_splits)"], ["", "lemma nvA_varsA[simp]: \"x \\<in> nvA at \\<Longrightarrow> x \\<in> varsA at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> nvA at \\<Longrightarrow> x \\<in> varsA at", "by (cases at, auto)"], ["", "lemma nvL_varsL[simp]: \"x \\<in> nvL l \\<Longrightarrow> x \\<in> varsL l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> nvL l \\<Longrightarrow> x \\<in> varsL l", "by (cases l, auto)"], ["", "lemma nvC_varsC[simp]: \"x \\<in> nvC c \\<Longrightarrow> x \\<in> varsC c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> nvC c \\<Longrightarrow> x \\<in> varsC c", "unfolding varsC_def nvC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (set (map nvL c)) \\<Longrightarrow>\n    x \\<in> \\<Union> (set (map varsL c))", "by(induct c, auto)"], ["", "lemma nvPB_varsPB[simp]: \"x \\<in> nvPB \\<Longrightarrow> x \\<in> varsPB \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> nvPB \\<Longrightarrow> x \\<in> varsPB \\<Phi>", "unfolding varsPB_def nvPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (nvC ` \\<Phi>) \\<Longrightarrow>\n    x \\<in> \\<Union> {varsC c |c. c \\<in> \\<Phi>}", "by auto"], ["", "subsection\\<open>The calculus\\<close>"], ["", "inductive mcalc (infix \"\\<turnstile>\" 40) where\n [simp]: \"infTp \\<sigma> \\<Longrightarrow> \\<sigma> \\<turnstile> c\"\n|[simp]: \"(\\<forall> x \\<in> nvC c. tpOfV x \\<noteq> \\<sigma>) \\<Longrightarrow> \\<sigma> \\<turnstile> c\""], ["", "lemma mcalc_iff: \"\\<sigma> \\<turnstile> c \\<longleftrightarrow> infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvC c. tpOfV x \\<noteq> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<turnstile> c) =\n    (infTp \\<sigma> \\<or> (\\<forall>x\\<in>nvC c. tpOfV x \\<noteq> \\<sigma>))", "unfolding mcalc.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>\\<sigma>' ca.\n         \\<sigma> = \\<sigma>' \\<and> c = ca \\<and> infTp \\<sigma>') \\<or>\n     (\\<exists>ca \\<sigma>'.\n         \\<sigma> = \\<sigma>' \\<and>\n         c = ca \\<and>\n         (\\<forall>x\\<in>nvC ca. tpOfV x \\<noteq> \\<sigma>'))) =\n    (infTp \\<sigma> \\<or> (\\<forall>x\\<in>nvC c. tpOfV x \\<noteq> \\<sigma>))", "by simp"], ["", "end"], ["", "(* context ProblemIk *)"], ["", "locale ProblemIkMcalc = ProblemIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf and parOf and \\<Phi> and infTp\n+ assumes mcalc: \"\\<And> \\<sigma> c. c \\<in> \\<Phi> \\<Longrightarrow> \\<sigma> \\<turnstile> c\""], ["", "locale ModelIkMcalc =\nModelIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp intT intF intP +\nProblemIkMcalc wtFsym wtPsym arOf resOf parOf \\<Phi> infTp\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf and parOf and \\<Phi> and infTp and intT and intF and intP"], ["", "subsection\\<open>Extension of a structure to an infinite structure\nby adding indistinguishable elements\\<close>"], ["", "context ModelIkMcalc begin"], ["", "text\\<open>The projection from univ to a structure:\\<close>"], ["", "definition proj where \"proj \\<sigma> a \\<equiv> if intT \\<sigma> a then a else pickT \\<sigma>\""], ["", "lemma intT_proj[simp]: \"intT \\<sigma> (proj \\<sigma> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> (proj \\<sigma> a)", "unfolding proj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> (if intT \\<sigma> a then a else pickT \\<sigma>)", "using pickT"], ["proof (prove)\nusing this:\n  intT ?\\<sigma> (pickT ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. intT \\<sigma> (if intT \\<sigma> a then a else pickT \\<sigma>)", "by auto"], ["", "lemma proj_id[simp]: \"intT \\<sigma> a \\<Longrightarrow> proj \\<sigma> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> a \\<Longrightarrow> proj \\<sigma> a = a", "unfolding proj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> a \\<Longrightarrow>\n    (if intT \\<sigma> a then a else pickT \\<sigma>) = a", "by auto"], ["", "lemma surj_proj:\nassumes \"intT \\<sigma> a\"   shows \"\\<exists> b. proj \\<sigma> b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b. proj \\<sigma> b = a", "using assms"], ["proof (prove)\nusing this:\n  intT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>b. proj \\<sigma> b = a", "by (intro exI[of _ a]) simp"], ["", "definition \"I_intT \\<sigma> (a::univ) \\<equiv> infTp \\<sigma> \\<longrightarrow> intT \\<sigma> a\""], ["", "definition \"I_intF f al \\<equiv> intF f (map2 proj (arOf f) al)\""], ["", "definition \"I_intP p al \\<equiv> intP p (map2 proj (parOf p) al)\""], ["", "lemma not_infTp_I_intT[simp]: \"\\<not> infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a", "unfolding I_intT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> infTp \\<sigma> \\<Longrightarrow>\n    infTp \\<sigma> \\<longrightarrow> intT \\<sigma> a", "by simp"], ["", "lemma infTp_I_intT[simp]: \"infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a = intT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a = intT \\<sigma> a", "unfolding I_intT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<Longrightarrow>\n    (infTp \\<sigma> \\<longrightarrow> intT \\<sigma> a) = intT \\<sigma> a", "by simp"], ["", "lemma NE_I_intT: \"NE (I_intT \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. I_intT \\<sigma> a", "using NE_intT"], ["proof (prove)\nusing this:\n  \\<exists>a. intT ?\\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>a. I_intT \\<sigma> a", "by (cases \"infTp \\<sigma>\", auto)"], ["", "lemma I_intF:\nassumes f: \"wtFsym f\" and al: \"list_all2 I_intT (arOf f) al\"\nshows \"I_intT (resOf f) (I_intF f al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_intT (resOf f) (I_intF f al)", "unfolding I_intT_def I_intF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<longrightarrow>\n    intT (resOf f) (intF f (map2 proj (arOf f) al))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<Longrightarrow>\n    intT (resOf f) (intF f (map2 proj (arOf f) al))", "apply(rule intF[OF f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<Longrightarrow>\n    list_all2 intT (arOf f) (map2 proj (arOf f) al)", "using al"], ["proof (prove)\nusing this:\n  list_all2 I_intT (arOf f) al\n\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<Longrightarrow>\n    list_all2 intT (arOf f) (map2 proj (arOf f) al)", "unfolding list_all2_length"], ["proof (prove)\nusing this:\n  length (arOf f) = length al \\<and>\n  (\\<forall>i<length (arOf f). I_intT (arOf f ! i) (al ! i))\n\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<Longrightarrow>\n    length (arOf f) = length (map2 proj (arOf f) al) \\<and>\n    (\\<forall>i<length (arOf f).\n        intT (arOf f ! i) (map2 proj (arOf f) al ! i))", "by auto"], ["", "lemma Tstruct_I_intT: \"Tstruct I_intT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Tstruct I_intT", "by standard (rule NE_I_intT)"], ["", "lemma inf_I_intT: \"infinite {a. I_intT \\<sigma> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {a. I_intT \\<sigma> a}", "by (cases \"infTp \\<sigma>\", auto)"], ["", "lemma InfStruct: \"IInfStruct I_intT I_intF I_intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfStruct I_intT I_intF I_intP", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. I_intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 I_intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> I_intT (resOf f) (I_intF f al)\n 3. I_intP = I_intP\n 4. \\<And>\\<sigma>. infinite {a. I_intT \\<sigma> a}", "using NE_I_intT I_intF Tstruct_I_intT inf_I_intT"], ["proof (prove)\nusing this:\n  \\<exists>a. I_intT ?\\<sigma> a\n  \\<lbrakk>wtFsym ?f; list_all2 I_intT (arOf ?f) ?al\\<rbrakk>\n  \\<Longrightarrow> I_intT (resOf ?f) (I_intF ?f ?al)\n  CM.Tstruct I_intT\n  infinite {a. I_intT ?\\<sigma> a}\n\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. I_intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 I_intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> I_intT (resOf f) (I_intF f al)\n 3. I_intP = I_intP\n 4. \\<And>\\<sigma>. infinite {a. I_intT \\<sigma> a}", "by auto"], ["", "end"], ["", "(* context ModelIkMcalc *)"], ["", "sublocale ModelIkMcalc < InfStruct where\nintT = I_intT and intF = I_intF and intP = I_intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfStruct I_intT I_intF I_intP", "using InfStruct"], ["proof (prove)\nusing this:\n  IInfStruct I_intT I_intF I_intP\n\ngoal (1 subgoal):\n 1. IInfStruct I_intT I_intF I_intP", "."], ["", "subsection\\<open>The soundness of the calculus\\<close>"], ["", "text\\<open>In what follows, ``Ik'' stands for the original\n(augmented with infiniteness-knowledge)\nand ``I'' for the infinite structure constructed from it\nthrough the above sublocale statement.\\<close>"], ["", "context ModelIkMcalc begin"], ["", "text\\<open>The environment translation along the projection:\\<close>"], ["", "definition \"transE \\<xi> \\<equiv> \\<lambda> x. proj (tpOfV x) (\\<xi> x)\""], ["", "lemma transE[simp]: \"transE \\<xi> x = proj (tpOfV x) (\\<xi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transE \\<xi> x = proj (tpOfV x) (\\<xi> x)", "unfolding transE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj (tpOfV x) (\\<xi> x) = proj (tpOfV x) (\\<xi> x)", "by simp"], ["", "lemma wtE_transE[simp]: \"I.wtE \\<xi> \\<Longrightarrow> Ik.wtE (transE \\<xi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.wtE \\<xi> \\<Longrightarrow> Ik.wtE (transE \\<xi>)", "unfolding Ik.wtE_def I.wtE_def transE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. I_intT (tpOfV x) (\\<xi> x) \\<Longrightarrow>\n    \\<forall>x. intT (tpOfV x) (proj (tpOfV x) (\\<xi> x))", "by auto"], ["", "abbreviation \"Ik_intT \\<equiv> intT\""], ["", "abbreviation \"Ik_intF \\<equiv> intF\""], ["", "abbreviation \"Ik_intP \\<equiv> intP\""], ["", "lemma Ik_intT_int:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\"\nand snv: \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvT T. tpOfV x \\<noteq> \\<sigma>)\"\nshows \"Ik_intT (tpOf T) (I.int \\<xi> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "proof(cases \"\\<exists> x. T = Var x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. T = Var x \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "case True"], ["proof (state)\nthis:\n  \\<exists>x. T = Var x\n\ngoal (2 subgoals):\n 1. \\<exists>x. T = Var x \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. T = Var x", "obtain x where T: \"T = Var x\""], ["proof (prove)\nusing this:\n  \\<exists>x. T = Var x\n\ngoal (1 subgoal):\n 1. (\\<And>x. T = Var x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  T = Var x\n\ngoal (2 subgoals):\n 1. \\<exists>x. T = Var x \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "proof(cases \"infTp (tpOf T)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "case True"], ["proof (state)\nthis:\n  infTp (tpOf T)\n\ngoal (2 subgoals):\n 1. infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  infTp (tpOf T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "using T"], ["proof (prove)\nusing this:\n  infTp (tpOf T)\n  T = Var x\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "using wtE_transE[OF \\<xi>]"], ["proof (prove)\nusing this:\n  infTp (tpOf T)\n  T = Var x\n  Ik.wtE (transE \\<xi>)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "by (metis I.wt_int I_intT_def \\<xi> wt)"], ["proof (state)\nthis:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "case False"], ["proof (state)\nthis:\n  \\<not> infTp (tpOf T)\n\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "hence \"\\<forall> x \\<in> nvT T. tpOfV x \\<noteq> tpOf T\""], ["proof (prove)\nusing this:\n  \\<not> infTp (tpOf T)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>nvT T. tpOfV x \\<noteq> tpOf T", "using snv"], ["proof (prove)\nusing this:\n  \\<not> infTp (tpOf T)\n  infTp ?\\<sigma>2 \\<or> (\\<forall>x\\<in>nvT T. tpOfV x \\<noteq> ?\\<sigma>2)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>nvT T. tpOfV x \\<noteq> tpOf T", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>nvT T. tpOfV x \\<noteq> tpOf T\n\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "hence \"Ik.full (tpOf T)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>nvT T. tpOfV x \\<noteq> tpOf T\n\ngoal (1 subgoal):\n 1. Ik.full (tpOf T)", "using T"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>nvT T. tpOfV x \\<noteq> tpOf T\n  T = Var x\n\ngoal (1 subgoal):\n 1. Ik.full (tpOf T)", "by (cases T, simp_all)"], ["proof (state)\nthis:\n  Ik.full (tpOf T)\n\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Ik.full (tpOf T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "unfolding Ik.full_def"], ["proof (prove)\nusing this:\n  \\<forall>d. Ik_intT (tpOf T) d\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "by simp"], ["proof (state)\nthis:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "case False"], ["proof (state)\nthis:\n  \\<nexists>x. T = Var x\n\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "hence nonVar: \"\\<not> (\\<exists> x. T = Var x)\""], ["proof (prove)\nusing this:\n  \\<nexists>x. T = Var x\n\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x", "by (cases T, auto)"], ["proof (state)\nthis:\n  \\<nexists>x. T = Var x\n\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>x. T = Var x\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "using nonVar wt"], ["proof (prove)\nusing this:\n  \\<nexists>x. T = Var x\n  \\<nexists>x. T = Var x\n  wt T\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "apply(induct T, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik_intT (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "unfolding I_intF_def tpOf.simps int.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a)\n                      (Struct.int\n                        (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                        \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik_intT (resOf f)\n                          (Ik_intF f\n                            (map2 proj (arOf f)\n                              (map (Struct.int\n                                     (\\<lambda>f al.\n   Ik_intF f (map2 proj (arOf f) al))\n                                     \\<xi>)\n                                Tl)))", "apply(rule Ik.intF, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a)\n                      (Struct.int\n                        (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                        \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> list_all2 Ik_intT (arOf f)\n                          (map2 proj (arOf f)\n                            (map (Struct.int\n                                   (\\<lambda>f al.\n Ik_intF f (map2 proj (arOf f) al))\n                                   \\<xi>)\n                              Tl))", "apply(rule listAll2_map2I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a)\n                      (Struct.int\n                        (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                        \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> length (arOf f) =\n                         length\n                          (map (Struct.int\n                                 (\\<lambda>f al.\n                                     Ik_intF f (map2 proj (arOf f) al))\n                                 \\<xi>)\n                            Tl)\n 2. \\<And>f Tl i.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a)\n                      (Struct.int\n                        (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                        \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl); i < length (arOf f)\\<rbrakk>\n       \\<Longrightarrow> Ik_intT (arOf f ! i)\n                          (proj (arOf f ! i)\n                            (map (Struct.int\n                                   (\\<lambda>f al.\n Ik_intF f (map2 proj (arOf f) al))\n                                   \\<xi>)\n                              Tl !\n                             i))", "by auto"], ["proof (state)\nthis:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_transE_proj:\n  assumes wt: \"Ik.wt T\"\n  shows \"Ik.int (transE \\<xi>) T = proj (tpOf T) (I.int \\<xi> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = proj (tpOf T) (I.int \\<xi> T)", "using wt"], ["proof (prove)\nusing this:\n  wt T\n\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = proj (tpOf T) (I.int \\<xi> T)", "proof (induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     Ik.int (transE \\<xi>) a =\n                     proj (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik.int (transE \\<xi>) (Fn f Tl) =\n                         proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     Ik.int (transE \\<xi>) a =\n                     proj (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik.int (transE \\<xi>) (Fn f Tl) =\n                         proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "have 0: \"Ik_intT (resOf f) (I_intF f (map (int \\<xi>) Tl))\" (is \"Ik_intT ?\\<sigma> ?a\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (resOf f) (I_intF f (map (I.int \\<xi>) Tl))", "unfolding I_intF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (resOf f)\n     (Ik_intF f\n       (map2 proj (arOf f)\n         (map (Struct.int (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                \\<xi>)\n           Tl)))", "apply(rule Ik.intF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wtFsym f\n 2. list_all2 Ik_intT (arOf f)\n     (map2 proj (arOf f)\n       (map (Struct.int (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n              \\<xi>)\n         Tl))", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (2 subgoals):\n 1. wtFsym f\n 2. list_all2 Ik_intT (arOf f)\n     (map2 proj (arOf f)\n       (map (Struct.int (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n              \\<xi>)\n         Tl))", "unfolding list_all2_length list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set Tl.\n     wt a \\<longrightarrow>\n     Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a)\n  wt (Fn f Tl)\n\ngoal (2 subgoals):\n 1. wtFsym f\n 2. length (arOf f) =\n    length\n     (map2 proj (arOf f)\n       (map (Struct.int (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n              \\<xi>)\n         Tl)) \\<and>\n    (\\<forall>i<length (arOf f).\n        Ik_intT (arOf f ! i)\n         (map2 proj (arOf f)\n           (map (Struct.int\n                  (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al)) \\<xi>)\n             Tl) !\n          i))", "by auto"], ["proof (state)\nthis:\n  Ik_intT (resOf f) (I_intF f (map (I.int \\<xi>) Tl))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     Ik.int (transE \\<xi>) a =\n                     proj (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik.int (transE \\<xi>) (Fn f Tl) =\n                         proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "have 1: \"proj ?\\<sigma> ?a = ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj (resOf f) (I_intF f (map (I.int \\<xi>) Tl)) =\n    I_intF f (map (I.int \\<xi>) Tl)", "using proj_id[OF 0]"], ["proof (prove)\nusing this:\n  proj (resOf f) (I_intF f (map (I.int \\<xi>) Tl)) =\n  I_intF f (map (I.int \\<xi>) Tl)\n\ngoal (1 subgoal):\n 1. proj (resOf f) (I_intF f (map (I.int \\<xi>) Tl)) =\n    I_intF f (map (I.int \\<xi>) Tl)", "."], ["proof (state)\nthis:\n  proj (resOf f) (I_intF f (map (I.int \\<xi>) Tl)) =\n  I_intF f (map (I.int \\<xi>) Tl)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     Ik.int (transE \\<xi>) a =\n                     proj (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik.int (transE \\<xi>) (Fn f Tl) =\n                         proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Fn f Tl) =\n    proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Fn f Tl) =\n    proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "unfolding Ik.int.simps int.simps tpOf.simps 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intF f (map (Ik.int (transE \\<xi>)) Tl) =\n    I_intF f (map (I.int \\<xi>) Tl)", "unfolding I_intF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intF f (map (Ik.int (transE \\<xi>)) Tl) =\n    Ik_intF f (map2 proj (arOf f) (map (I.int \\<xi>) Tl))", "apply(rule arg_cong[of _ _ \"intF f\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl =\n    map2 proj (arOf f) (map (I.int \\<xi>) Tl)", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "have l[simp]: \"length (arOf f) = length Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (arOf f) = length Tl", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. length (arOf f) = length Tl", "by simp"], ["proof (state)\nthis:\n  length (arOf f) = length Tl\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "assume \"i < length (map (Ik.int (transE \\<xi>)) Tl)\""], ["proof (state)\nthis:\n  i < length (map (Ik.int (transE \\<xi>)) Tl)\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "hence i[simp]: \"i < length Tl\""], ["proof (prove)\nusing this:\n  i < length (map (Ik.int (transE \\<xi>)) Tl)\n\ngoal (1 subgoal):\n 1. i < length Tl", "by simp"], ["proof (state)\nthis:\n  i < length Tl\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "have 0: \"arOf f ! i = tpOf (Tl ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arOf f ! i = tpOf (Tl ! i)", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. arOf f ! i = tpOf (Tl ! i)", "by simp"], ["proof (state)\nthis:\n  arOf f ! i = tpOf (Tl ! i)\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "have [simp]: \"Ik.int (transE \\<xi>) (Tl ! i) = proj (arOf f ! i) (I.int \\<xi> (Tl ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Tl ! i) =\n    proj (arOf f ! i) (I.int \\<xi> (Tl ! i))", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Tl ! i) =\n    proj (tpOf (Tl ! i)) (I.int \\<xi> (Tl ! i))", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Tl ! i) =\n    proj (tpOf (Tl ! i)) (I.int \\<xi> (Tl ! i))", "by (auto simp: list_all_length transE_def)"], ["proof (state)\nthis:\n  Ik.int (transE \\<xi>) (Tl ! i) = proj (arOf f ! i) (I.int \\<xi> (Tl ! i))\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "show \"map (Ik.int (transE \\<xi>)) Tl ! i =\n          map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl ! i =\n    map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl ! i =\n    map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  \\<forall>n<length Tl.\n     wt (Tl ! n) \\<longrightarrow>\n     Ik.int (transE \\<xi>) (Tl ! n) =\n     proj (tpOf (Tl ! n)) (I.int \\<xi> (Tl ! n))\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl ! i =\n    map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "by simp"], ["proof (state)\nthis:\n  map (Ik.int (transE \\<xi>)) Tl ! i =\n  map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i\n\ngoal (1 subgoal):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))", "qed(use Fn in simp)"], ["proof (state)\nthis:\n  Ik.int (transE \\<xi>) (Fn f Tl) =\n  proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))", "qed simp"], ["", "lemma int_transE_snv[simp]:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\" and snv: \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvT T. tpOfV x \\<noteq> \\<sigma>)\"\nshows \"Ik.int (transE \\<xi>) T = I.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = I.int \\<xi> T", "unfolding int_transE_proj[OF wt]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj (tpOf T) (I.int \\<xi> T) = I.int \\<xi> T", "apply(rule proj_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "using Ik_intT_int[OF wt \\<xi> snv]"], ["proof (prove)\nusing this:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "."], ["", "lemma int_transE_Fn:\nassumes wt: \"list_all wt Tl\" and f: \"wtFsym f\" and \\<xi>: \"I.wtE \\<xi>\"\nand ar: \"arOf f = map tpOf Tl\"\nshows \"Ik.int (transE \\<xi>) (Fn f Tl) = I.int \\<xi> (Fn f Tl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Fn f Tl) = I.int \\<xi> (Fn f Tl)", "apply(rule int_transE_snv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wt (Fn f Tl)\n 2. I.wtE \\<xi>\n 3. \\<And>\\<sigma>.\n       infTp \\<sigma> \\<or>\n       (\\<forall>x\\<in>nvT (Fn f Tl). tpOfV x \\<noteq> \\<sigma>)", "using assms"], ["proof (prove)\nusing this:\n  list_all wt Tl\n  wtFsym f\n  I.wtE \\<xi>\n  arOf f = map tpOf Tl\n\ngoal (3 subgoals):\n 1. wt (Fn f Tl)\n 2. I.wtE \\<xi>\n 3. \\<And>\\<sigma>.\n       infTp \\<sigma> \\<or>\n       (\\<forall>x\\<in>nvT (Fn f Tl). tpOfV x \\<noteq> \\<sigma>)", "by auto"], ["", "lemma intP_transE[simp]:\nassumes wt: \"list_all wt Tl\" and p: \"wtPsym p\" and ar: \"parOf p = map tpOf Tl\"\nshows \"Ik_intP p (map (Ik.int (transE \\<xi>)) Tl) = I_intP p (map (I.int \\<xi>) Tl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intP p (map (Ik.int (transE \\<xi>)) Tl) =\n    I_intP p (map (I.int \\<xi>) Tl)", "unfolding I_intP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intP p (map (Ik.int (transE \\<xi>)) Tl) =\n    Ik_intP p (map2 proj (parOf p) (map (I.int \\<xi>) Tl))", "apply(rule arg_cong[of _ _ \"Ik_intP p\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl =\n    map2 proj (parOf p) (map (I.int \\<xi>) Tl)", "apply(rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (parOf p) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (parOf p) (map (I.int \\<xi>) Tl) ! i", "using assms"], ["proof (prove)\nusing this:\n  list_all wt Tl\n  wtPsym p\n  parOf p = map tpOf Tl\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (parOf p) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (parOf p) (map (I.int \\<xi>) Tl) ! i", "using int_transE_proj"], ["proof (prove)\nusing this:\n  list_all wt Tl\n  wtPsym p\n  parOf p = map tpOf Tl\n  wt ?T \\<Longrightarrow>\n  Ik.int (transE ?\\<xi>) ?T = proj (tpOf ?T) (I.int ?\\<xi> ?T)\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (parOf p) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (parOf p) (map (I.int \\<xi>) Tl) ! i", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  \\<forall>n<length Tl. wt (Tl ! n)\n  wtPsym p\n  parOf p = map tpOf Tl\n  wt ?T \\<Longrightarrow>\n  Ik.int (transE ?\\<xi>) ?T = proj (tpOf ?T) (I.int ?\\<xi> ?T)\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (parOf p) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (parOf p) (map (I.int \\<xi>) Tl) ! i", "by auto"], ["", "lemma satA_snvA_transE[simp]:\nassumes wtA: \"Ik.wtA at\" and \\<xi>: \"I.wtE \\<xi>\"\nand pA: \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvA at. tpOfV x \\<noteq> \\<sigma>)\"\nshows \"Ik.satA (transE \\<xi>) at \\<longleftrightarrow> I.satA \\<xi> at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.satA (transE \\<xi>) at = I.satA \\<xi> at", "using assms"], ["proof (prove)\nusing this:\n  wtA at\n  I.wtE \\<xi>\n  infTp ?\\<sigma>2 \\<or>\n  (\\<forall>x\\<in>nvA at. tpOfV x \\<noteq> ?\\<sigma>2)\n\ngoal (1 subgoal):\n 1. Ik.satA (transE \\<xi>) at = I.satA \\<xi> at", "apply (cases at, simp_all add: ball_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       \\<lbrakk>wt x11 \\<and> wt x12 \\<and> tpOf x11 = tpOf x12;\n        \\<And>\\<sigma>.\n           infTp \\<sigma> \\<or>\n           (\\<forall>x\\<in>nvT x11. tpOfV x \\<noteq> \\<sigma>) \\<and>\n           (\\<forall>x\\<in>nvT x12. tpOfV x \\<noteq> \\<sigma>);\n        at = Eq x11 x12; I.wtE \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (Ik.int (transE \\<xi>) x11 =\n                          Ik.int (transE \\<xi>) x12) =\n                         (I.int \\<xi> x11 = I.int \\<xi> x12)", "by (metis int_transE_snv)"], ["", "(* The next contrapositive twist is crucial for proving satL_transE: *)"], ["", "lemma satA_transE[simp]:\nassumes wtA: \"Ik.wtA at\" and \"I.satA \\<xi> at\"\nshows \"Ik.satA (transE \\<xi>) at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.satA (transE \\<xi>) at", "using assms"], ["proof (prove)\nusing this:\n  wtA at\n  I.satA \\<xi> at\n\ngoal (1 subgoal):\n 1. Ik.satA (transE \\<xi>) at", "apply(cases at)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>wtA at; I.satA \\<xi> at; at = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> Ik.satA (transE \\<xi>) at\n 2. \\<And>x21 x22.\n       \\<lbrakk>wtA at; I.satA \\<xi> at; at = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> Ik.satA (transE \\<xi>) at", "using int_transE_proj"], ["proof (prove)\nusing this:\n  wt ?T \\<Longrightarrow>\n  Ik.int (transE ?\\<xi>) ?T = proj (tpOf ?T) (I.int ?\\<xi> ?T)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>wtA at; I.satA \\<xi> at; at = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> Ik.satA (transE \\<xi>) at\n 2. \\<And>x21 x22.\n       \\<lbrakk>wtA at; I.satA \\<xi> at; at = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> Ik.satA (transE \\<xi>) at", "by auto"], ["", "lemma satL_snvL_transE[simp]:\nassumes wtL: \"Ik.wtL l\" and \\<xi>: \"I.wtE \\<xi>\"\nand pL: \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nvL l. tpOfV x \\<noteq> \\<sigma>)\" and \"Ik.satL (transE \\<xi>) l\"\nshows \"I.satL \\<xi> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "using assms"], ["proof (prove)\nusing this:\n  wtL l\n  I.wtE \\<xi>\n  infTp ?\\<sigma>2 \\<or> (\\<forall>x\\<in>nvL l. tpOfV x \\<noteq> ?\\<sigma>2)\n  Ik.satL (transE \\<xi>) l\n\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "by (cases l) auto"], ["", "lemma satC_snvC_transE[simp]:\nassumes wtC: \"Ik.wtC c\" and \\<xi>: \"I.wtE \\<xi>\"\nand pC: \"\\<And> \\<sigma>. \\<sigma> \\<turnstile> c\" and \"Ik.satC (transE \\<xi>) c\"\nshows \"I.satC \\<xi> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satC \\<xi> c", "using assms"], ["proof (prove)\nusing this:\n  wtC c\n  I.wtE \\<xi>\n  ?\\<sigma>2 \\<turnstile> c\n  Ik.satC (transE \\<xi>) c\n\ngoal (1 subgoal):\n 1. I.satC \\<xi> c", "unfolding Ik.mcalc_iff Ik.satC_def satC_def Ik.wtC_def nvC_def"], ["proof (prove)\nusing this:\n  list_all wtL c\n  I.wtE \\<xi>\n  infTp ?\\<sigma>2 \\<or>\n  (\\<forall>x\\<in>\\<Union> (set (map nvL c)). tpOfV x \\<noteq> ?\\<sigma>2)\n  list_ex (Ik.satL (transE \\<xi>)) c\n\ngoal (1 subgoal):\n 1. list_ex (I.satL \\<xi>) c", "unfolding list_all_iff list_ex_iff"], ["proof (prove)\nusing this:\n  Ball (set c) wtL\n  I.wtE \\<xi>\n  infTp ?\\<sigma>2 \\<or>\n  (\\<forall>x\\<in>\\<Union> (set (map nvL c)). tpOfV x \\<noteq> ?\\<sigma>2)\n  Bex (set c) (Ik.satL (transE \\<xi>))\n\ngoal (1 subgoal):\n 1. Bex (set c) (I.satL \\<xi>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball (set c) wtL; I.wtE \\<xi>;\n     \\<And>\\<sigma>.\n        infTp \\<sigma> \\<or>\n        (\\<forall>y\\<in>set c.\n            \\<forall>x\\<in>nvL y. tpOfV x \\<noteq> \\<sigma>);\n     \\<exists>x\\<in>set c. Ik.satL (transE \\<xi>) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>set c. I.satL \\<xi> x", "by (metis nth_mem satL_snvL_transE)"], ["", "lemma satPB_snvPB_transE[simp]:\nassumes \\<xi>: \"I.wtE \\<xi>\"  shows \"I.satPB \\<xi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satPB \\<xi> \\<Phi>", "using Ik.wt_\\<Phi> Ik.sat_\\<Phi>[OF wtE_transE[OF \\<xi>]]"], ["proof (prove)\nusing this:\n  wtPB \\<Phi>\n  Ik.satPB (transE \\<xi>) \\<Phi>\n\ngoal (1 subgoal):\n 1. I.satPB \\<xi> \\<Phi>", "using mcalc \\<xi>"], ["proof (prove)\nusing this:\n  wtPB \\<Phi>\n  Ik.satPB (transE \\<xi>) \\<Phi>\n  ?c \\<in> \\<Phi> \\<Longrightarrow> ?\\<sigma> \\<turnstile> ?c\n  I.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. I.satPB \\<xi> \\<Phi>", "unfolding Ik.satPB_def satPB_def Ik.wtPB_def nvPB_def"], ["proof (prove)\nusing this:\n  Ball \\<Phi> wtC\n  \\<forall>c\\<in>\\<Phi>. Ik.satC (transE \\<xi>) c\n  ?c \\<in> \\<Phi> \\<Longrightarrow> ?\\<sigma> \\<turnstile> ?c\n  I.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<Phi>. I.satC \\<xi> c", "by auto"], ["", "lemma I_SAT: \"I.SAT \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.SAT \\<Phi>", "unfolding I.SAT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>. I.wtE \\<xi> \\<longrightarrow> I.satPB \\<xi> \\<Phi>", "by auto"], ["", "lemma InfModel: \"IInfModel I_intT I_intF I_intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfModel I_intT I_intF I_intP", "by standard (rule I_SAT)"], ["", "end"], ["", "(* context ModelIkMcalc *)"], ["", "sublocale ModelIkMcalc < inf?: InfModel where\nintT = I_intT and intF = I_intF and intP = I_intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfModel I_intT I_intF I_intP", "using InfModel"], ["proof (prove)\nusing this:\n  IInfModel I_intT I_intF I_intP\n\ngoal (1 subgoal):\n 1. IInfModel I_intT I_intF I_intP", "."], ["", "context ProblemIkMcalc begin"], ["", "abbreviation \"MModelIkMcalc \\<equiv> ModelIkMcalc wtFsym wtPsym arOf resOf parOf \\<Phi> infTp\""], ["", "theorem monot: monot"], ["proof (prove)\ngoal (1 subgoal):\n 1. monot", "unfolding monot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>intT intF intP. MModel intT intF intP) \\<longrightarrow>\n    (\\<exists>intTI intFI intPI. IInfModel intTI intFI intPI)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>intT intF intP.\n       MModel intT intF intP \\<Longrightarrow>\n       \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "fix intT intF intP"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>intT intF intP.\n       MModel intT intF intP \\<Longrightarrow>\n       \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "assume \"MModel intT intF intP\""], ["proof (state)\nthis:\n  MModel intT intF intP\n\ngoal (1 subgoal):\n 1. \\<And>intT intF intP.\n       MModel intT intF intP \\<Longrightarrow>\n       \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "hence M: \"MModelIkMcalc intT intF intP\""], ["proof (prove)\nusing this:\n  MModel intT intF intP\n\ngoal (1 subgoal):\n 1. MModelIkMcalc intT intF intP", "unfolding ModelIkMcalc_def ModelIk_def"], ["proof (prove)\nusing this:\n  MModel intT intF intP\n\ngoal (1 subgoal):\n 1. (ProblemIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp \\<and>\n     MModel intT intF intP) \\<and>\n    ProblemIkMcalc wtFsym wtPsym arOf resOf parOf \\<Phi> infTp", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. MModel intT intF intP \\<Longrightarrow>\n    ProblemIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp\n 2. MModel intT intF intP \\<Longrightarrow>\n    ProblemIkMcalc wtFsym wtPsym arOf resOf parOf \\<Phi> infTp", ".."], ["proof (state)\nthis:\n  MModelIkMcalc intT intF intP\n\ngoal (1 subgoal):\n 1. \\<And>intT intF intP.\n       MModel intT intF intP \\<Longrightarrow>\n       \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "show \"\\<exists> intTI intFI intPI. IInfModel intTI intFI intPI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "using ModelIkMcalc.InfModel[OF M]"], ["proof (prove)\nusing this:\n  IInfModel (ModelIkMcalc.I_intT infTp intT)\n   (ModelIkMcalc.I_intF arOf intT intF)\n   (ModelIkMcalc.I_intP parOf intT intP)\n\ngoal (1 subgoal):\n 1. \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "by auto"], ["proof (state)\nthis:\n  \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ProblemIkMcalc *)"], ["", "text\\<open>Final theorem in sublocale form: Any problem that passes the\n  monotonicity calculus is monotonic:\\<close>"], ["", "sublocale ProblemIkMcalc < MonotProblem"], ["proof (prove)\ngoal (1 subgoal):\n 1. MonotProblem wtFsym wtPsym arOf resOf parOf \\<Phi>", "by standard (rule monot)"], ["", "end"]]}