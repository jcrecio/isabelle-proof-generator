{"file_name": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings/G.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings", "problem_names": ["lemma protCl_resOf_arOf[simp]:\nassumes \"protCl (resOf f)\" and \"i < length (arOf f)\"\nshows \"protCl (arOf f ! i)\"", "lemma countable_GE_wtFsym: \"countable (Collect GE_wtFsym)\" (is \"countable ?K\")", "lemma countable_GE_wtPsym: \"countable (Collect GE_wtPsym)\" (is \"countable ?K\")", "lemma finite_glitOfL[simp]: \"finite (glitOfL l)\"", "lemma finite_glitOfC[simp]: \"finite (glitOfC c)\"", "lemma set_gC[simp]: \"set (gC c) = gL ` (set c) \\<union> glitOfC c\"", "lemma tpOf_g[simp]: \"GE.tpOf (gT T) = Ik.tpOf T\"", "lemma wt_g[simp]: \"Ik.wt T \\<Longrightarrow> GE.wt (gT T)\"", "lemma wtA_gA[simp]: \"Ik.wtA at \\<Longrightarrow> GE.wtA (gA at)\"", "lemma wtL_gL[simp]: \"Ik.wtL l \\<Longrightarrow> GE.wtL (gL l)\"", "lemma wtC_map_gL[simp]: \"Ik.wtC c \\<Longrightarrow> GE.wtC (map gL c)\"", "lemma wtL_grdLit_unprot[simp]: \"\\<not> unprot (tpOfV x) \\<Longrightarrow> GE.wtL (grdLit x)\"", "lemma wtL_grdLit[simp]: \"prot (tpOfV x) \\<or> protFw (tpOfV x) \\<Longrightarrow> GE.wtL (grdLit x)\"", "lemma wtL_glitOfL[simp]: \"l' \\<in> glitOfL l \\<Longrightarrow> GE.wtL l'\"", "lemma wtL_glitOfC[simp]: \"l' \\<in> glitOfC c \\<Longrightarrow> GE.wtL l'\"", "lemma wtC_list_glitOfC[simp]: \"GE.wtC (list (glitOfC c))\"", "lemma wtC_gC[simp]: \"Ik.wtC c \\<Longrightarrow> GE.wtC (gC c)\"", "lemma wtA_cOfFax_unprot[simp]: \"\\<lbrakk>wtFsym f; \\<not> unprot (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtA (cOfFax f)\"", "lemma wtA_cOfFax[simp]:\n\"\\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtA (cOfFax f)\"", "lemma wtA_hOfFax[simp]:\n\"\\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk> \\<Longrightarrow> list_all GE.wtA (hOfFax f)\"", "lemma wtC_fax_unprot[simp]: \"\\<lbrakk>wtFsym f; \\<not> unprot (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtC (fax f)\"", "lemma wtC_fax[simp]: \"\\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtC (fax f)\"", "lemma wtC_faxCD[simp]: \"\\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtC (faxCD f)\"", "lemma wtPB_Fax[simp]: \"GE.wtPB Fax\"", "lemma wtC_wax_unprot[simp]: \"\\<lbrakk>\\<not> unprot \\<sigma>; \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk> \\<Longrightarrow> GE.wtC (wax \\<sigma>)\"", "lemma wtC_wax[simp]: \"\\<lbrakk>prot \\<sigma> \\<or> protFw \\<sigma>; \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk> \\<Longrightarrow> GE.wtC (wax \\<sigma>)\"", "lemma wtPB_Wax[simp]: \"GE.wtPB Wax\"", "lemma wtPB_gC_\\<Phi>[simp]: \"GE.wtPB (gC ` \\<Phi>)\"", "lemma wtPB_tPB[simp]: \"GE.wtPB gPB\"", "lemma wtA_Guard:\nassumes \"GE.wtA (Pr (Guard \\<sigma>) Tl)\"\nshows \"\\<exists> T. Tl = [T] \\<and> GE.wt T \\<and> tpOf T = \\<sigma>\"", "lemma wt_Wit:\nassumes \"GE.wt (Fn (Wit \\<sigma>) Tl)\"  shows \"Tl = []\"", "lemma tpOf_Wit: \"GE.tpOf (Fn (Wit \\<sigma>) Tl) = \\<sigma>\"", "lemma g_int[simp]: \"GE.int \\<xi> (gT T) = Ik.int \\<xi> T\"", "lemma map_g_int[simp]: \"map (GE.int \\<xi> \\<circ> gT) Tl = map (Ik.int \\<xi>) Tl\"", "lemma gA_satA[simp]: \"GE.satA \\<xi> (gA at) \\<longleftrightarrow> Ik.satA \\<xi> at\"", "lemma gL_satL[simp]: \"GE.satL \\<xi> (gL l) \\<longleftrightarrow> Ik.satL \\<xi> l\"", "lemma map_gL_satC[simp]: \"GE.satC \\<xi> (map gL c) \\<longleftrightarrow> Ik.satC \\<xi> c\"", "lemma gC_satC[simp]:\nassumes \"Ik.satC \\<xi> c\"  shows \"GE.satC \\<xi> (gC c)\"", "lemma gC_\\<Phi>_satPB[simp]:\nassumes \"Ik.satPB \\<xi> \\<Phi>\"  shows \"GE.satPB \\<xi> (gC ` \\<Phi>)\"", "lemma Fax_Wax_satPB:\n\"GE.satPB \\<xi> (Fax) \\<and> GE.satPB \\<xi> (Wax)\"", "lemmas Fax_satPB[simp] = Fax_Wax_satPB[THEN conjunct1]", "lemmas Wax_satPB[simp] = Fax_Wax_satPB[THEN conjunct2]", "lemma soundness: \"GE.SAT gPB\"", "theorem G_soundness:\n\"Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB intT GE_intF GE_intP\"", "lemma GE_Guard_all: (* fixme: messy proof *)\nassumes f: \"wtFsym f\"\nand al: \"list_all2 eintT (arOf f) al\"\nshows\n\"(\\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f)\n  \\<longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al])\n \\<and>\n (protCl (resOf f) \\<longrightarrow>\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n  \\<longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al])\"\n(is \"(?A1 \\<longrightarrow> ?C) \\<and>\n     (?A2 \\<longrightarrow> ?H2 \\<longrightarrow> ?C)\")", "lemma GE_Guard_not_unprot_protCl:\nassumes f: \"wtFsym f\" and f2: \"\\<not> unprot (resOf f)\" \"\\<not> protCl (resOf f)\"\nand al: \"list_all2 eintT (arOf f) al\"\nshows \"eintP (Guard (resOf f)) [intF f al]\"", "lemma GE_Guard_protCl:\nassumes f: \"wtFsym f\" and f2: \"protCl (resOf f)\" and al: \"list_all2 eintT (arOf f) al\"\nand H: \"list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\"\nshows \"eintP (Guard (resOf f)) [intF f al]\"", "lemma GE_Guard_not_unprot:\nassumes f: \"wtFsym f\" and f2: \"\\<not> unprot (resOf f)\" and al: \"list_all2 eintT (arOf f) al\"\nand H: \"list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\"\nshows \"eintP (Guard (resOf f)) [intF f al]\"", "lemma GE_Wit:\nassumes \\<sigma>: \"\\<not> unprot \\<sigma>\" \"\\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\"\nshows \"eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]\"", "lemma NE_intT_forget: \"NE (intT \\<sigma>)\"", "lemma wt_intF:\nassumes f: \"wtFsym f\" and al: \"list_all2 intT (arOf f) al\"\nshows \"intT (resOf f) (intF f al)\"", "lemma Struct: \"Struct wtFsym wtPsym arOf resOf intT intF intP\"", "lemma wtE[simp]: \"Ik.wtE \\<xi> \\<Longrightarrow> GE.wtE \\<xi>\"", "lemma int_g[simp]: \"GE.int \\<xi> (gT T) = Ik.int \\<xi> T\"", "lemma map_int_g[simp]:\n\"map (Ik.int \\<xi>) Tl = map (GE.int \\<xi> \\<circ> gT) Tl\"", "lemma satA_gA[simp]: \"GE.satA \\<xi> (gA at) \\<longleftrightarrow> Ik.satA \\<xi> at\"", "lemma satL_gL[simp]: \"GE.satL \\<xi> (gL l) \\<longleftrightarrow> Ik.satL \\<xi> l\"", "lemma satC_map_gL[simp]: \"GE.satC \\<xi> (map gL c) \\<longleftrightarrow> Ik.satC \\<xi> c\"", "lemma wtE_not_grdLit_unprot[simp]: (* crucial: *)\nassumes \"Ik.wtE \\<xi>\" and \"\\<not> unprot (tpOfV x)\"\nshows \"\\<not> GE.satL \\<xi> (grdLit x)\"", "lemma wtE_not_grdLit[simp]:\nassumes \"Ik.wtE \\<xi>\" and \"prot (tpOfV x) \\<or> protFw (tpOfV x)\"\nshows \"\\<not> GE.satL \\<xi> (grdLit x)\"", "lemma wtE_not_glitOfL[simp]:\nassumes \"Ik.wtE \\<xi>\"\nshows \"\\<not> GE.satC \\<xi> (list (glitOfL l))\"", "lemma wtE_not_glitOfC[simp]:\nassumes \"Ik.wtE \\<xi>\"\nshows \"\\<not> GE.satC \\<xi> (list (glitOfC c))\"", "lemma satC_gC[simp]:\nassumes \"Ik.wtE \\<xi>\" and \"GE.satC \\<xi> (gC c)\"\nshows \"Ik.satC \\<xi> c\"", "lemma satPB_gPB[simp]:\nassumes \"Ik.wtE \\<xi>\" and \"GE.satPB \\<xi> (gC ` \\<Phi>)\"\nshows \"Ik.satPB \\<xi> \\<Phi>\"", "lemma completeness: \"Ik.SAT \\<Phi>\"", "lemma G_completeness: \"Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\"", "lemma pol_ct: \"pol \\<sigma>1 p = pol \\<sigma>2 p\"", "lemma nv2_nv[simp]: \"GE.nv2T (gT T) = GE.nvT T\"", "lemma nv2L_nvL[simp]: \"GE.nv2L (gL l) = GE.nvL l\"", "lemma nv2L:\nassumes \"l \\<in> set c\" and mc: \"GE.mcalc \\<sigma> c\"\nshows \"infTp \\<sigma> \\<or> (\\<forall> x \\<in> GE.nv2L (gL l). tpOfV x \\<noteq> \\<sigma>)\"", "lemma isGuard_grdLit[simp]: \"GE.isGuard x (grdLit x)\"", "lemma nv2L_grdLit[simp]: \"GE.nv2L (grdLit x) = {}\"", "lemma mcalc_mcalc2: \"GE.mcalc \\<sigma> c \\<Longrightarrow> GE.mcalc2 \\<sigma> (gC c)\"", "lemma nv2L_wax[simp]: \"l' \\<in> set (wax \\<sigma>) \\<Longrightarrow> GE.nv2L l' = {}\"", "lemma nv2L_Wax:\nassumes \"c' \\<in> Wax\" and \"l' \\<in> set c'\"\nshows \"GE.nv2L l' = {}\"", "lemma nv2L_cOfFax[simp]: \"GE.nv2L (Pos (cOfFax \\<sigma>)) = {}\"", "lemma nv2L_hOfFax[simp]:\nassumes \"at \\<in> set (hOfFax \\<sigma>)\"\nshows \"GE.nv2L (Neg at) = {}\"", "lemma nv2L_fax[simp]: \"l \\<in> set (fax \\<sigma>) \\<Longrightarrow> GE.nv2L l = {}\"", "lemma nv2L_faxCD[simp]: \"l \\<in> set (faxCD \\<sigma>) \\<Longrightarrow> GE.nv2L l = {}\"", "lemma nv2L_Fax:\nassumes \"c' \\<in> Fax\" and \"l' \\<in> set c'\"\nshows \"GE.nv2L l' = {}\"", "lemma grdOf:\nassumes c': \"c' \\<in> gPB\" and l': \"l' \\<in> set c'\"\nand x: \"x \\<in> GE.nv2L l'\" and i: \"\\<not> infTp (tpOfV x)\"\nshows \"grdOf c' l' x \\<in> set c' \\<and> GE.isGuard x (grdOf c' l' x)\"", "lemma mcalc2:\nassumes c': \"c' \\<in> gPB\"\nshows \"GE.mcalc2 \\<sigma> c'\"", "theorem G_monotonic:\n\"MonotProblem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB\""], "translations": [["", "lemma protCl_resOf_arOf[simp]:\nassumes \"protCl (resOf f)\" and \"i < length (arOf f)\"\nshows \"protCl (arOf f ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. protCl (arOf f ! i)", "using assms protCl_fsym"], ["proof (prove)\nusing this:\n  protCl (resOf f)\n  i < length (arOf f)\n  protCl (?resPf ?f) \\<Longrightarrow> list_all protCl (arOf ?f)\n\ngoal (1 subgoal):\n 1. protCl (arOf f ! i)", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  protCl (resOf f)\n  i < length (arOf f)\n  protCl (?resPf ?f) \\<Longrightarrow>\n  \\<forall>n<length (arOf ?f). protCl (arOf ?f ! n)\n\ngoal (1 subgoal):\n 1. protCl (arOf f ! i)", "by auto"], ["", "text\\<open>``GE'' stands for ``guard encoding'':\\<close>"], ["", "fun GE_wtFsym where\n \"GE_wtFsym (Oldf f) \\<longleftrightarrow> wtFsym f\"\n|\"GE_wtFsym (Wit \\<sigma>) \\<longleftrightarrow> \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\""], ["", "fun GE_arOf where\n \"GE_arOf (Oldf f) = arOf f\"\n|\"GE_arOf (Wit \\<sigma>) = []\""], ["", "fun GE_resOf where\n \"GE_resOf (Oldf f) = resOf f\"\n|\"GE_resOf (Wit \\<sigma>) = \\<sigma>\""], ["", "fun GE_wtPsym where\n \"GE_wtPsym (Oldp p) \\<longleftrightarrow> wtPsym p\"\n|\"GE_wtPsym (Guard \\<sigma>) \\<longleftrightarrow> \\<not> unprot \\<sigma>\""], ["", "fun GE_parOf where\n \"GE_parOf (Oldp p) = parOf p\"\n|\"GE_parOf (Guard \\<sigma>) = [\\<sigma>]\""], ["", "lemma countable_GE_wtFsym: \"countable (Collect GE_wtFsym)\" (is \"countable ?K\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "let ?F = \"\\<lambda> ef. case ef of Oldf f \\<Rightarrow> Inl f | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "let ?U = \"UNIV::'tp set\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "let ?L = \"(Collect wtFsym) <+> ?U\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "have \"inj_on ?F ?K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>ef.\n         case ef of Oldf f \\<Rightarrow> Inl f\n         | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n     (Collect GE_wtFsym)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Collect GE_wtFsym.\n       \\<forall>y\\<in>Collect GE_wtFsym.\n          (case x of Oldf x \\<Rightarrow> Inl x\n           | Wit x \\<Rightarrow> Inr x) =\n          (case y of Oldf x \\<Rightarrow> Inl x\n           | Wit x \\<Rightarrow> Inr x) \\<longrightarrow>\n          x = y", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>GE_wtFsym x; GE_wtFsym y;\n        (case x of Oldf x \\<Rightarrow> Inl x | Wit x \\<Rightarrow> Inr x) =\n        (case y of Oldf x \\<Rightarrow> Inl x\n         | Wit x \\<Rightarrow> Inr x)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac x, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y x1.\n       \\<lbrakk>wtFsym x1; GE_wtFsym y;\n        Inl x1 =\n        (case y of Oldf x \\<Rightarrow> Inl x | Wit x \\<Rightarrow> Inr x);\n        x = Oldf x1\\<rbrakk>\n       \\<Longrightarrow> Oldf x1 = y\n 2. \\<And>x y x2.\n       \\<lbrakk>isRes x2 \\<longrightarrow> protCl x2; GE_wtFsym y;\n        Inr x2 =\n        (case y of Oldf x \\<Rightarrow> Inl x | Wit x \\<Rightarrow> Inr x);\n        x = Wit x2\\<rbrakk>\n       \\<Longrightarrow> Wit x2 = y", "by (case_tac y, simp_all)+"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtFsym)\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "moreover"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtFsym)\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "have \"?F ` ?K \\<subseteq> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ef.\n        case ef of Oldf f \\<Rightarrow> Inl f\n        | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n    Collect GE_wtFsym\n    \\<subseteq> Collect wtFsym <+> UNIV", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ef.\n       GE_wtFsym ef \\<Longrightarrow>\n       (case ef of Oldf f \\<Rightarrow> Inl f\n        | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n       \\<in> Collect wtFsym <+> UNIV", "by (case_tac ef, auto)"], ["proof (state)\nthis:\n  (\\<lambda>ef.\n      case ef of Oldf f \\<Rightarrow> Inl f\n      | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n  Collect GE_wtFsym\n  \\<subseteq> Collect wtFsym <+> UNIV\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "ultimately"], ["proof (chain)\npicking this:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtFsym)\n  (\\<lambda>ef.\n      case ef of Oldf f \\<Rightarrow> Inl f\n      | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n  Collect GE_wtFsym\n  \\<subseteq> Collect wtFsym <+> UNIV", "have \"|?K| \\<le>o |?L|\""], ["proof (prove)\nusing this:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtFsym)\n  (\\<lambda>ef.\n      case ef of Oldf f \\<Rightarrow> Inl f\n      | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n  Collect GE_wtFsym\n  \\<subseteq> Collect wtFsym <+> UNIV\n\ngoal (1 subgoal):\n 1. |Collect GE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV|", "unfolding card_of_ordLeq[symmetric]"], ["proof (prove)\nusing this:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtFsym)\n  (\\<lambda>ef.\n      case ef of Oldf f \\<Rightarrow> Inl f\n      | Wit \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n  Collect GE_wtFsym\n  \\<subseteq> Collect wtFsym <+> UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       inj_on f (Collect GE_wtFsym) \\<and>\n       f ` Collect GE_wtFsym \\<subseteq> Collect wtFsym <+> UNIV", "by auto"], ["proof (state)\nthis:\n  |Collect GE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV|\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "moreover"], ["proof (state)\nthis:\n  |Collect GE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV|\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "have \"countable ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (Collect wtFsym <+> UNIV)", "using countable_wtFsym countable_tp"], ["proof (prove)\nusing this:\n  countable {f. wtFsym f}\n  countable UNIV\n\ngoal (1 subgoal):\n 1. countable (Collect wtFsym <+> UNIV)", "by (metis countable_Plus)"], ["proof (state)\nthis:\n  countable (Collect wtFsym <+> UNIV)\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "ultimately"], ["proof (chain)\npicking this:\n  |Collect GE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV|\n  countable (Collect wtFsym <+> UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  |Collect GE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV|\n  countable (Collect wtFsym <+> UNIV)\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtFsym)", "by(rule countable_ordLeq)"], ["proof (state)\nthis:\n  countable (Collect GE_wtFsym)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma countable_GE_wtPsym: \"countable (Collect GE_wtPsym)\" (is \"countable ?K\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "let ?F = \"\\<lambda> ep. case ep of Oldp p \\<Rightarrow> Inl p | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "let ?U = \"UNIV::'tp set\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "let ?L = \"(Collect wtPsym) <+> ?U\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "have \"inj_on ?F ?K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>ep.\n         case ep of Oldp p \\<Rightarrow> Inl p\n         | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n     (Collect GE_wtPsym)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Collect GE_wtPsym.\n       \\<forall>y\\<in>Collect GE_wtPsym.\n          (case x of Oldp x \\<Rightarrow> Inl x\n           | Guard x \\<Rightarrow> Inr x) =\n          (case y of Oldp x \\<Rightarrow> Inl x\n           | Guard x \\<Rightarrow> Inr x) \\<longrightarrow>\n          x = y", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>GE_wtPsym x; GE_wtPsym y;\n        (case x of Oldp x \\<Rightarrow> Inl x\n         | Guard x \\<Rightarrow> Inr x) =\n        (case y of Oldp x \\<Rightarrow> Inl x\n         | Guard x \\<Rightarrow> Inr x)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac x, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y x1.\n       \\<lbrakk>wtPsym x1; GE_wtPsym y;\n        Inl x1 =\n        (case y of Oldp x \\<Rightarrow> Inl x\n         | Guard x \\<Rightarrow> Inr x);\n        x = Oldp x1\\<rbrakk>\n       \\<Longrightarrow> Oldp x1 = y\n 2. \\<And>x y x2.\n       \\<lbrakk>\\<not> unprot x2; GE_wtPsym y;\n        Inr x2 =\n        (case y of Oldp x \\<Rightarrow> Inl x\n         | Guard x \\<Rightarrow> Inr x);\n        x = Guard x2\\<rbrakk>\n       \\<Longrightarrow> Guard x2 = y", "by (case_tac y, simp_all)+"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>ep.\n       case ep of Oldp p \\<Rightarrow> Inl p\n       | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtPsym)\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "moreover"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>ep.\n       case ep of Oldp p \\<Rightarrow> Inl p\n       | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtPsym)\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "have \"?F ` ?K \\<subseteq> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ep.\n        case ep of Oldp p \\<Rightarrow> Inl p\n        | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n    Collect GE_wtPsym\n    \\<subseteq> Collect wtPsym <+> UNIV", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ep.\n       GE_wtPsym ep \\<Longrightarrow>\n       (case ep of Oldp p \\<Rightarrow> Inl p\n        | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n       \\<in> Collect wtPsym <+> UNIV", "by (case_tac ep, auto)"], ["proof (state)\nthis:\n  (\\<lambda>ep.\n      case ep of Oldp p \\<Rightarrow> Inl p\n      | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n  Collect GE_wtPsym\n  \\<subseteq> Collect wtPsym <+> UNIV\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "ultimately"], ["proof (chain)\npicking this:\n  inj_on\n   (\\<lambda>ep.\n       case ep of Oldp p \\<Rightarrow> Inl p\n       | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtPsym)\n  (\\<lambda>ep.\n      case ep of Oldp p \\<Rightarrow> Inl p\n      | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n  Collect GE_wtPsym\n  \\<subseteq> Collect wtPsym <+> UNIV", "have \"|?K| \\<le>o |?L|\""], ["proof (prove)\nusing this:\n  inj_on\n   (\\<lambda>ep.\n       case ep of Oldp p \\<Rightarrow> Inl p\n       | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtPsym)\n  (\\<lambda>ep.\n      case ep of Oldp p \\<Rightarrow> Inl p\n      | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n  Collect GE_wtPsym\n  \\<subseteq> Collect wtPsym <+> UNIV\n\ngoal (1 subgoal):\n 1. |Collect GE_wtPsym| \\<le>o |Collect wtPsym <+> UNIV|", "unfolding card_of_ordLeq[symmetric]"], ["proof (prove)\nusing this:\n  inj_on\n   (\\<lambda>ep.\n       case ep of Oldp p \\<Rightarrow> Inl p\n       | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>)\n   (Collect GE_wtPsym)\n  (\\<lambda>ep.\n      case ep of Oldp p \\<Rightarrow> Inl p\n      | Guard \\<sigma> \\<Rightarrow> Inr \\<sigma>) `\n  Collect GE_wtPsym\n  \\<subseteq> Collect wtPsym <+> UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       inj_on f (Collect GE_wtPsym) \\<and>\n       f ` Collect GE_wtPsym \\<subseteq> Collect wtPsym <+> UNIV", "by auto"], ["proof (state)\nthis:\n  |Collect GE_wtPsym| \\<le>o |Collect wtPsym <+> UNIV|\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "moreover"], ["proof (state)\nthis:\n  |Collect GE_wtPsym| \\<le>o |Collect wtPsym <+> UNIV|\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "have \"countable ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (Collect wtPsym <+> UNIV)", "using countable_wtPsym countable_tp"], ["proof (prove)\nusing this:\n  countable {p. wtPsym p}\n  countable UNIV\n\ngoal (1 subgoal):\n 1. countable (Collect wtPsym <+> UNIV)", "by (metis countable_Plus)"], ["proof (state)\nthis:\n  countable (Collect wtPsym <+> UNIV)\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "ultimately"], ["proof (chain)\npicking this:\n  |Collect GE_wtPsym| \\<le>o |Collect wtPsym <+> UNIV|\n  countable (Collect wtPsym <+> UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  |Collect GE_wtPsym| \\<le>o |Collect wtPsym <+> UNIV|\n  countable (Collect wtPsym <+> UNIV)\n\ngoal (1 subgoal):\n 1. countable (Collect GE_wtPsym)", "by(rule countable_ordLeq)"], ["proof (state)\nthis:\n  countable (Collect GE_wtPsym)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ProblemIkTpartG *)"], ["", "sublocale ProblemIkTpartG < GE? : Signature\nwhere wtFsym = GE_wtFsym and wtPsym = GE_wtPsym\nand arOf = GE_arOf and resOf = GE_resOf and parOf = GE_parOf"], ["proof (prove)\ngoal (1 subgoal):\n 1. Signature TYPE('tp) GE_wtFsym GE_wtPsym", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. countable UNIV\n 2. countable (Collect GE_wtFsym)\n 3. countable (Collect GE_wtPsym)", "using countable_tp countable_GE_wtFsym countable_GE_wtPsym"], ["proof (prove)\nusing this:\n  countable UNIV\n  countable (Collect GE_wtFsym)\n  countable (Collect GE_wtPsym)\n\ngoal (3 subgoals):\n 1. countable UNIV\n 2. countable (Collect GE_wtFsym)\n 3. countable (Collect GE_wtPsym)", "by auto"], ["", "context ProblemIkTpartG\nbegin"], ["", "text\\<open>The guarding literal of a variable:\\<close>"], ["", "definition grdLit :: \"var \\<Rightarrow> (('fsym, 'tp) efsym, ('psym, 'tp) epsym) lit\"\nwhere \"grdLit x \\<equiv> Neg (Pr (Guard (tpOfV x)) [Var x])\""], ["", "text\\<open>The (set of) guarding literals of a literal and of a clause:\\<close>"], ["", "(* of a literal: *)"], ["", "fun glitOfL ::\n\"('fsym, 'psym) lit \\<Rightarrow> (('fsym, 'tp) efsym, ('psym, 'tp) epsym) lit set\"\nwhere\n\"glitOfL (Pos at) =\n {grdLit x | x. x \\<in> varsA at \\<and> (prot (tpOfV x) \\<or> (protFw (tpOfV x) \\<and> x \\<in> nvA at))}\"\n|\n\"glitOfL (Neg at) = {grdLit x | x. x \\<in> varsA at \\<and> prot (tpOfV x)}\""], ["", "(* of a clause: *)"], ["", "definition \"glitOfC c \\<equiv> \\<Union> (set (map glitOfL c))\""], ["", "lemma finite_glitOfL[simp]: \"finite (glitOfL l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (glitOfL l)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (glitOfL l)", "have \"glitOfL l \\<subseteq> grdLit ` {x . x \\<in> varsL l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. glitOfL l \\<subseteq> grdLit ` {x. x \\<in> varsL l}", "by (cases l, auto)"], ["proof (state)\nthis:\n  glitOfL l \\<subseteq> grdLit ` {x. x \\<in> varsL l}\n\ngoal (1 subgoal):\n 1. finite (glitOfL l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  glitOfL l \\<subseteq> grdLit ` {x. x \\<in> varsL l}\n\ngoal (1 subgoal):\n 1. finite (glitOfL l)", "by (metis Collect_mem_eq finite_surj finite_varsL)"], ["proof (state)\nthis:\n  finite (glitOfL l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_glitOfC[simp]: \"finite (glitOfC c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (glitOfC c)", "unfolding glitOfC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (set (map glitOfL c)))", "apply(rule finite_Union)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set (map glitOfL c))\n 2. \\<And>M. M \\<in> set (map glitOfL c) \\<Longrightarrow> finite M", "using finite_glitOfL"], ["proof (prove)\nusing this:\n  finite (glitOfL ?l)\n\ngoal (2 subgoals):\n 1. finite (set (map glitOfL c))\n 2. \\<And>M. M \\<in> set (map glitOfL c) \\<Longrightarrow> finite M", "by auto"], ["", "fun gT where\n\"gT (Var x) = Var x\"\n|\n\"gT (Fn f Tl) = Fn (Oldf f) (map gT Tl)\""], ["", "fun gA where\n\"gA (Eq T1 T2) = Eq (gT T1) (gT T2)\"\n|\n\"gA (Pr p Tl) = Pr (Oldp p) (map gT Tl)\""], ["", "fun gL where\n\"gL (Pos at) = Pos (gA at)\"\n|\n\"gL (Neg at) = Neg (gA at)\""], ["", "definition \"gC c \\<equiv> (map gL c) @ (list (glitOfC c))\""], ["", "lemma set_gC[simp]: \"set (gC c) = gL ` (set c) \\<union> glitOfC c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (gC c) = gL ` set c \\<union> glitOfC c", "unfolding gC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map gL c @ list (glitOfC c)) = gL ` set c \\<union> glitOfC c", "by simp"], ["", "text\\<open>The extra axioms:\\<close>"], ["", "text\\<open>The function axioms:\\<close>"], ["", "(* conclusion (atom): *)"], ["", "definition \"cOfFax f = Pr (Guard (resOf f)) [Fn (Oldf f) (getTvars (arOf f))]\""], ["", "(* hypotheses (list of atoms): *)"], ["", "definition \"hOfFax f = map2 (Pr o Guard) (arOf f) (map singl (getTvars (arOf f)))\""], ["", "(* The axiom (clause) for non-classically-decorated (lightweight and featherweigh) types: *)"], ["", "definition \"fax f \\<equiv> [Pos (cOfFax f)]\""], ["", "(* The axiom (clause) for classically-decorated types: *)"], ["", "definition \"faxCD f \\<equiv> map Neg (hOfFax f) @ fax f\""], ["", "(* The set of axioms: *)"], ["", "definition\n\"Fax \\<equiv> {fax f | f. wtFsym f \\<and> \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f)} \\<union>\n       {faxCD f | f. wtFsym f \\<and> protCl (resOf f)}\""], ["", "text\\<open>The witness axioms:\\<close>"], ["", "(* The axiom (clause): *)"], ["", "definition \"wax \\<sigma> \\<equiv> [Pos (Pr (Guard \\<sigma>) [Fn (Wit \\<sigma>) []])]\""], ["", "(* The set of axioms: *)"], ["", "definition \"Wax \\<equiv> {wax \\<sigma> | \\<sigma>. \\<not> unprot \\<sigma> \\<and> (\\<not> isRes \\<sigma> \\<or> protCl \\<sigma>)}\""], ["", "definition \"gPB = gC ` \\<Phi> \\<union> Fax \\<union> Wax\""], ["", "text\\<open>Well-typedness of the translation:\\<close>"], ["", "lemma tpOf_g[simp]: \"GE.tpOf (gT T) = Ik.tpOf T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.tpOf (gT T) = Ik.tpOf T", "by (cases T) auto"], ["", "lemma wt_g[simp]: \"Ik.wt T \\<Longrightarrow> GE.wt (gT T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wt T \\<Longrightarrow> GE.wt (gT T)", "by (induct T, auto simp add: list_all_iff)"], ["", "lemma wtA_gA[simp]: \"Ik.wtA at \\<Longrightarrow> GE.wtA (gA at)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wtA at \\<Longrightarrow> GE.wtA (gA at)", "by (cases at, auto simp add: list_all_iff)"], ["", "lemma wtL_gL[simp]: \"Ik.wtL l \\<Longrightarrow> GE.wtL (gL l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wtL l \\<Longrightarrow> GE.wtL (gL l)", "by (cases l, auto)"], ["", "lemma wtC_map_gL[simp]: \"Ik.wtC c \\<Longrightarrow> GE.wtC (map gL c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wtC c \\<Longrightarrow> GE.wtC (map gL c)", "unfolding Ik.wtC_def GE.wtC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all Ik.wtL c \\<Longrightarrow> list_all GE.wtL (map gL c)", "by (induct c, auto)"], ["", "lemma wtL_grdLit_unprot[simp]: \"\\<not> unprot (tpOfV x) \\<Longrightarrow> GE.wtL (grdLit x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unprot (GE.tpOfV x) \\<Longrightarrow> GE.wtL (grdLit x)", "unfolding grdLit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unprot (GE.tpOfV x) \\<Longrightarrow>\n    GE.wtL (Neg (Pr (Guard (GE.tpOfV x)) [Var x]))", "by auto"], ["", "lemma wtL_grdLit[simp]: \"prot (tpOfV x) \\<or> protFw (tpOfV x) \\<Longrightarrow> GE.wtL (grdLit x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x) \\<Longrightarrow>\n    GE.wtL (grdLit x)", "apply(rule wtL_grdLit_unprot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x) \\<Longrightarrow>\n    \\<not> unprot (GE.tpOfV x)", "unfolding unprot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x) \\<Longrightarrow>\n    \\<not> (\\<not> prot (GE.tpOfV x) \\<and> \\<not> protFw (GE.tpOfV x))", "by auto"], ["", "lemma wtL_glitOfL[simp]: \"l' \\<in> glitOfL l \\<Longrightarrow> GE.wtL l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<in> glitOfL l \\<Longrightarrow> GE.wtL l'", "by (cases l, auto)"], ["", "lemma wtL_glitOfC[simp]: \"l' \\<in> glitOfC c \\<Longrightarrow> GE.wtL l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<in> glitOfC c \\<Longrightarrow> GE.wtL l'", "unfolding glitOfC_def GE.wtC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<in> \\<Union> (set (map glitOfL c)) \\<Longrightarrow> GE.wtL l'", "by (induct c, auto)"], ["", "lemma wtC_list_glitOfC[simp]: \"GE.wtC (list (glitOfC c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.wtC (list (glitOfC c))", "unfolding glitOfC_def GE.wtC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all GE.wtL (list (\\<Union> (set (map glitOfL c))))", "by auto"], ["", "lemma wtC_gC[simp]: \"Ik.wtC c \\<Longrightarrow> GE.wtC (gC c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wtC c \\<Longrightarrow> GE.wtC (gC c)", "unfolding gC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wtC c \\<Longrightarrow> GE.wtC (map gL c @ list (glitOfC c))", "by simp"], ["", "lemma wtA_cOfFax_unprot[simp]: \"\\<lbrakk>wtFsym f; \\<not> unprot (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtA (cOfFax f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; \\<not> unprot (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtA (cOfFax f)", "unfolding cOfFax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; \\<not> unprot (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtA\n                       (Pr (Guard (resOf f))\n                         [Fn (Oldf f) (GE.getTvars (arOf f))])", "by simp"], ["", "lemma wtA_cOfFax[simp]:\n\"\\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtA (cOfFax f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtA (cOfFax f)", "apply(rule wtA_cOfFax_unprot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> wtFsym f\n 2. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> \\<not> unprot (resOf f)", "unfolding unprot_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> wtFsym f\n 2. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<not> prot (resOf f) \\<and>\n                              \\<not> protFw (resOf f))", "by auto"], ["", "lemma wtA_hOfFax[simp]:\n\"\\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk> \\<Longrightarrow> list_all GE.wtA (hOfFax f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> list_all GE.wtA (hOfFax f)", "unfolding hOfFax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> list_all GE.wtA\n                       (map2 (Pr \\<circ> Guard) (arOf f)\n                         (map singl (GE.getTvars (arOf f))))", "unfolding list_all_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n<length\n                                  (map2 (Pr \\<circ> Guard) (arOf f)\n                                    (map singl (GE.getTvars (arOf f)))).\n                         GE.wtA\n                          (map2 (Pr \\<circ> Guard) (arOf f)\n                            (map singl (GE.getTvars (arOf f))) !\n                           n)", "by (auto simp add: singl_def unprot_def)"], ["", "lemma wtC_fax_unprot[simp]: \"\\<lbrakk>wtFsym f; \\<not> unprot (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtC (fax f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; \\<not> unprot (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (fax f)", "unfolding fax_def GE.wtC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; \\<not> unprot (resOf f)\\<rbrakk>\n    \\<Longrightarrow> list_all GE.wtL [Pos (cOfFax f)]", "by auto"], ["", "lemma wtC_fax[simp]: \"\\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtC (fax f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (fax f)", "apply(rule wtC_fax_unprot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> wtFsym f\n 2. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> \\<not> unprot (resOf f)", "unfolding unprot_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> wtFsym f\n 2. \\<lbrakk>wtFsym f; prot (resOf f) \\<or> protFw (resOf f)\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<not> prot (resOf f) \\<and>\n                              \\<not> protFw (resOf f))", "by auto"], ["", "lemma wtC_faxCD[simp]: \"\\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk> \\<Longrightarrow> GE.wtC (faxCD f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (faxCD f)", "unfolding faxCD_def GE.wtC_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (map Neg (hOfFax f)) \\<and> GE.wtC (fax f)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (map Neg (hOfFax f))\n 2. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (fax f)", "using wtA_hOfFax[unfolded list_all_length]"], ["proof (prove)\nusing this:\n  \\<lbrakk>wtFsym ?f; protCl (resOf ?f)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>n<length (hOfFax ?f). GE.wtA (hOfFax ?f ! n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (map Neg (hOfFax f))\n 2. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (fax f)", "apply(simp add: GE.wtC_def list_all_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtFsym f; protCl (resOf f)\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (fax f)", "by simp"], ["", "lemma wtPB_Fax[simp]: \"GE.wtPB Fax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.wtPB Fax", "unfolding Fax_def GE.wtPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball\n     ({fax f |f.\n       wtFsym f \\<and>\n       \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f)} \\<union>\n      {faxCD f |f. wtFsym f \\<and> protCl (resOf f)})\n     GE.wtC", "by auto"], ["", "lemma wtC_wax_unprot[simp]: \"\\<lbrakk>\\<not> unprot \\<sigma>; \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk> \\<Longrightarrow> GE.wtC (wax \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> unprot \\<sigma>;\n     \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (wax \\<sigma>)", "unfolding wax_def GE.wtC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> unprot \\<sigma>;\n     \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> list_all GE.wtL\n                       [Pos (Pr (Guard \\<sigma>) [Fn (Wit \\<sigma>) []])]", "by simp"], ["", "lemma wtC_wax[simp]: \"\\<lbrakk>prot \\<sigma> \\<or> protFw \\<sigma>; \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk> \\<Longrightarrow> GE.wtC (wax \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prot \\<sigma> \\<or> protFw \\<sigma>;\n     \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> GE.wtC (wax \\<sigma>)", "apply(rule wtC_wax_unprot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prot \\<sigma> \\<or> protFw \\<sigma>;\n     \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> unprot \\<sigma>\n 2. \\<lbrakk>prot \\<sigma> \\<or> protFw \\<sigma>;\n     \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>", "unfolding unprot_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prot \\<sigma> \\<or> protFw \\<sigma>;\n     \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<not> prot \\<sigma> \\<and>\n                              \\<not> protFw \\<sigma>)\n 2. \\<lbrakk>prot \\<sigma> \\<or> protFw \\<sigma>;\n     \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>", "by auto"], ["", "lemma wtPB_Wax[simp]: \"GE.wtPB Wax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.wtPB Wax", "unfolding Wax_def GE.wtPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball\n     {wax \\<sigma> |\\<sigma>.\n      \\<not> unprot \\<sigma> \\<and>\n      (\\<not> isRes \\<sigma> \\<or> protCl \\<sigma>)}\n     GE.wtC", "by auto"], ["", "lemma wtPB_gC_\\<Phi>[simp]: \"GE.wtPB (gC ` \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.wtPB (gC ` \\<Phi>)", "using Ik.wt_\\<Phi>"], ["proof (prove)\nusing this:\n  Ik.wtPB \\<Phi>\n\ngoal (1 subgoal):\n 1. GE.wtPB (gC ` \\<Phi>)", "unfolding Ik.wtPB_def GE.wtPB_def"], ["proof (prove)\nusing this:\n  Ball \\<Phi> Ik.wtC\n\ngoal (1 subgoal):\n 1. Ball (gC ` \\<Phi>) GE.wtC", "by auto"], ["", "lemma wtPB_tPB[simp]: \"GE.wtPB gPB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.wtPB gPB", "unfolding gPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.wtPB (gC ` \\<Phi> \\<union> Fax \\<union> Wax)", "by simp"], ["", "(*  *)"], ["", "lemma wtA_Guard:\nassumes \"GE.wtA (Pr (Guard \\<sigma>) Tl)\"\nshows \"\\<exists> T. Tl = [T] \\<and> GE.wt T \\<and> tpOf T = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. Tl = [T] \\<and> GE.wt T \\<and> GE.tpOf T = \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  GE.wtA (Pr (Guard \\<sigma>) Tl)\n\ngoal (1 subgoal):\n 1. \\<exists>T. Tl = [T] \\<and> GE.wt T \\<and> GE.tpOf T = \\<sigma>", "by simp (metis (hide_lams, no_types) list.inject map_eq_Cons_conv \n                           list_all_simps map_is_Nil_conv neq_Nil_conv)"], ["", "lemma wt_Wit:\nassumes \"GE.wt (Fn (Wit \\<sigma>) Tl)\"  shows \"Tl = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tl = []", "using assms"], ["proof (prove)\nusing this:\n  GE.wt (Fn (Wit \\<sigma>) Tl)\n\ngoal (1 subgoal):\n 1. Tl = []", "by simp"], ["", "lemma tpOf_Wit: \"GE.tpOf (Fn (Wit \\<sigma>) Tl) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.tpOf (Fn (Wit \\<sigma>) Tl) = \\<sigma>", "by simp"], ["", "end"], ["", "(* context ProblemIkTpartG *)"], ["", "subsection\\<open>Soundness\\<close>"], ["", "context ModelIkTpartG begin"], ["", "(* The identity-guard extension of a given structure of the original signature *)"], ["", "fun GE_intF where\n \"GE_intF (Oldf f) al = intF f al\"\n|\"GE_intF (Wit \\<sigma>) al = pickT \\<sigma>\""], ["", "(* note: for witnesses, we only care about al being [] *)"], ["", "fun GE_intP where\n \"GE_intP (Oldp p) al = intP p al\"\n|\"GE_intP (Guard \\<sigma>) al = True\""], ["", "(* note: for guards, we only care about al being a singleton *)"], ["", "end"], ["", "(* context ModelIkTpartG *)"], ["", "sublocale ModelIkTpartG < GE? : Struct\nwhere wtFsym = GE_wtFsym and wtPsym = GE_wtPsym and\narOf = GE_arOf and resOf = GE_resOf and parOf = GE_parOf\nand intF = GE_intF and intP = GE_intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Struct GE_wtFsym GE_wtPsym GE_arOf GE_resOf intT GE_intF GE_intP", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f al.\n       \\<lbrakk>GE_wtFsym f; list_all2 intT (GE_arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (GE_resOf f) (GE_intF f al)\n 2. GE_intP = GE_intP", "fix ef al"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f al.\n       \\<lbrakk>GE_wtFsym f; list_all2 intT (GE_arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (GE_resOf f) (GE_intF f al)\n 2. GE_intP = GE_intP", "assume \"GE_wtFsym ef\" and \"list_all2 intT (GE_arOf ef) al\""], ["proof (state)\nthis:\n  GE_wtFsym ef\n  list_all2 intT (GE_arOf ef) al\n\ngoal (2 subgoals):\n 1. \\<And>f al.\n       \\<lbrakk>GE_wtFsym f; list_all2 intT (GE_arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (GE_resOf f) (GE_intF f al)\n 2. GE_intP = GE_intP", "thus \"intT (GE_resOf ef) (GE_intF ef al)\""], ["proof (prove)\nusing this:\n  GE_wtFsym ef\n  list_all2 intT (GE_arOf ef) al\n\ngoal (1 subgoal):\n 1. intT (GE_resOf ef) (GE_intF ef al)", "using intF"], ["proof (prove)\nusing this:\n  GE_wtFsym ef\n  list_all2 intT (GE_arOf ef) al\n  \\<lbrakk>wtFsym ?f; list_all2 intT (arOf ?f) ?al\\<rbrakk>\n  \\<Longrightarrow> intT (resOf ?f) (intF ?f ?al)\n\ngoal (1 subgoal):\n 1. intT (GE_resOf ef) (GE_intF ef al)", "by (cases ef, auto)"], ["proof (state)\nthis:\n  intT (GE_resOf ef) (GE_intF ef al)\n\ngoal (1 subgoal):\n 1. GE_intP = GE_intP", "qed auto"], ["", "context ModelIkTpartG begin"], ["", "lemma g_int[simp]: \"GE.int \\<xi> (gT T) = Ik.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.int \\<xi> (gT T) = Ik.int \\<xi> T", "proof (induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a) Tl\n\ngoal (2 subgoals):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "hence 0: \"map (GE.int \\<xi> \\<circ> gT) Tl = map (Ik.int \\<xi>) Tl\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a) Tl\n\ngoal (1 subgoal):\n 1. map (GE.int \\<xi> \\<circ> gT) Tl = map (Ik.int \\<xi>) Tl", "unfolding list_eq_iff list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set Tl. GE.int \\<xi> (gT a) = Ik.int \\<xi> a\n\ngoal (1 subgoal):\n 1. length (map (GE.int \\<xi> \\<circ> gT) Tl) =\n    length (map (Ik.int \\<xi>) Tl) \\<and>\n    (\\<forall>i<length (map (GE.int \\<xi> \\<circ> gT) Tl).\n        map (GE.int \\<xi> \\<circ> gT) Tl ! i = map (Ik.int \\<xi>) Tl ! i)", "by auto"], ["proof (state)\nthis:\n  map (GE.int \\<xi> \\<circ> gT) Tl = map (Ik.int \\<xi>) Tl\n\ngoal (2 subgoals):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "by (simp add: 0)"], ["proof (state)\nthis:\n  GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)\n\ngoal (1 subgoal):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)", "qed auto"], ["", "lemma map_g_int[simp]: \"map (GE.int \\<xi> \\<circ> gT) Tl = map (Ik.int \\<xi>) Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (GE.int \\<xi> \\<circ> gT) Tl = map (Ik.int \\<xi>) Tl", "unfolding list_eq_iff list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (GE.int \\<xi> \\<circ> gT) Tl) =\n    length (map (Ik.int \\<xi>) Tl) \\<and>\n    (\\<forall>i<length (map (GE.int \\<xi> \\<circ> gT) Tl).\n        map (GE.int \\<xi> \\<circ> gT) Tl ! i = map (Ik.int \\<xi>) Tl ! i)", "by auto"], ["", "lemma gA_satA[simp]: \"GE.satA \\<xi> (gA at) \\<longleftrightarrow> Ik.satA \\<xi> at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.satA \\<xi> (gA at) = Ik.satA \\<xi> at", "apply(cases at)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow>\n       GE.satA \\<xi> (gA at) = Ik.satA \\<xi> at\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow>\n       GE.satA \\<xi> (gA at) = Ik.satA \\<xi> at", "by auto"], ["", "lemma gL_satL[simp]: \"GE.satL \\<xi> (gL l) \\<longleftrightarrow> Ik.satL \\<xi> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.satL \\<xi> (gL l) = Ik.satL \\<xi> l", "apply(cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       l = Pos x1 \\<Longrightarrow> GE.satL \\<xi> (gL l) = Ik.satL \\<xi> l\n 2. \\<And>x2.\n       l = Neg x2 \\<Longrightarrow> GE.satL \\<xi> (gL l) = Ik.satL \\<xi> l", "by auto"], ["", "lemma map_gL_satC[simp]: \"GE.satC \\<xi> (map gL c) \\<longleftrightarrow> Ik.satC \\<xi> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.satC \\<xi> (map gL c) = Ik.satC \\<xi> c", "unfolding GE.satC_def Ik.satC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex (GE.satL \\<xi>) (map gL c) = list_ex (Ik.satL \\<xi>) c", "by (induct c, auto)"], ["", "lemma gC_satC[simp]:\nassumes \"Ik.satC \\<xi> c\"  shows \"GE.satC \\<xi> (gC c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.satC \\<xi> (gC c)", "using assms"], ["proof (prove)\nusing this:\n  Ik.satC \\<xi> c\n\ngoal (1 subgoal):\n 1. GE.satC \\<xi> (gC c)", "unfolding gC_def"], ["proof (prove)\nusing this:\n  Ik.satC \\<xi> c\n\ngoal (1 subgoal):\n 1. GE.satC \\<xi> (map gL c @ list (glitOfC c))", "by simp"], ["", "lemma gC_\\<Phi>_satPB[simp]:\nassumes \"Ik.satPB \\<xi> \\<Phi>\"  shows \"GE.satPB \\<xi> (gC ` \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.satPB \\<xi> (gC ` \\<Phi>)", "using assms"], ["proof (prove)\nusing this:\n  Ik.satPB \\<xi> \\<Phi>\n\ngoal (1 subgoal):\n 1. GE.satPB \\<xi> (gC ` \\<Phi>)", "unfolding GE.satPB_def Ik.satPB_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<Phi>. Ik.satC \\<xi> c\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>gC ` \\<Phi>. GE.satC \\<xi> c", "by auto"], ["", "lemma Fax_Wax_satPB:\n\"GE.satPB \\<xi> (Fax) \\<and> GE.satPB \\<xi> (Wax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.satPB \\<xi> Fax \\<and> GE.satPB \\<xi> Wax", "unfolding GE.satPB_def GE.satC_def Fax_def Wax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>{fax f |f.\n                     wtFsym f \\<and>\n                     \\<not> unprot (resOf f) \\<and>\n                     \\<not> protCl (resOf f)} \\<union>\n                    {faxCD f |f. wtFsym f \\<and> protCl (resOf f)}.\n        list_ex (GE.satL \\<xi>) c) \\<and>\n    (\\<forall>c\\<in>{wax \\<sigma> |\\<sigma>.\n                     \\<not> unprot \\<sigma> \\<and>\n                     (\\<not> isRes \\<sigma> \\<or> protCl \\<sigma>)}.\n        list_ex (GE.satL \\<xi>) c)", "by (auto simp add: cOfFax_def hOfFax_def fax_def faxCD_def wax_def)"], ["", "lemmas Fax_satPB[simp] = Fax_Wax_satPB[THEN conjunct1]"], ["", "lemmas Wax_satPB[simp] = Fax_Wax_satPB[THEN conjunct2]"], ["", "lemma soundness: \"GE.SAT gPB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.SAT gPB", "unfolding GE.SAT_def gPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>.\n       GE.wtE \\<xi> \\<longrightarrow>\n       GE.satPB \\<xi> (gC ` \\<Phi> \\<union> Fax \\<union> Wax)", "using SAT"], ["proof (prove)\nusing this:\n  Ik.SAT \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>.\n       GE.wtE \\<xi> \\<longrightarrow>\n       GE.satPB \\<xi> (gC ` \\<Phi> \\<union> Fax \\<union> Wax)", "unfolding Ik.SAT_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<xi>. GE.wtE \\<xi> \\<longrightarrow> Ik.satPB \\<xi> \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>.\n       GE.wtE \\<xi> \\<longrightarrow>\n       GE.satPB \\<xi> (gC ` \\<Phi> \\<union> Fax \\<union> Wax)", "by auto"], ["", "theorem G_soundness:\n\"Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB intT GE_intF GE_intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB intT GE_intF\n     GE_intP", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. GE.wtPB gPB\n 2. GE.SAT gPB", "using wtPB_tPB soundness"], ["proof (prove)\nusing this:\n  GE.wtPB gPB\n  GE.SAT gPB\n\ngoal (2 subgoals):\n 1. GE.wtPB gPB\n 2. GE.SAT gPB", "by auto"], ["", "end"], ["", "(* context ModelIkTpartG *)\n\n(* Soundness theorem in sublocale form: Given a problem (with indicated\ntype partition) and a model for it, we obtain a model of the tag-extended (GE)\nproblem: *)"], ["", "sublocale ModelIkTpartG < GE? : Model\nwhere wtFsym = GE_wtFsym and wtPsym = GE_wtPsym and\narOf = GE_arOf and resOf = GE_resOf and parOf = GE_parOf\nand \\<Phi> = gPB and intF = GE_intF and intP = GE_intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB intT GE_intF\n     GE_intP", "using G_soundness"], ["proof (prove)\nusing this:\n  CM.Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB intT GE_intF\n   GE_intP\n\ngoal (1 subgoal):\n 1. CM.Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB intT GE_intF\n     GE_intP", "."], ["", "subsection\\<open>Completeness\\<close>"], ["", "(* Problem with type partition and model of its guard-encoding translation: *)"], ["", "locale ProblemIkTpartG_GEModel =\nIk? : ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot protFw protCl +\nGE? : Model \"ProblemIkTpartG.GE_wtFsym wtFsym resOf protCl\"\n            \"ProblemIkTpartG.GE_wtPsym wtPsym prot protFw\"\n            \"ProblemIkTpartG.GE_arOf arOf\" \"ProblemIkTpartG.GE_resOf resOf\"\n            \"ProblemIkTpartG.GE_parOf parOf\"\n            gPB eintT eintF eintP\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\"\nand wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf and parOf and \\<Phi> and infTp and prot and protFw and protCl\nand eintT and eintF and eintP"], ["", "context ProblemIkTpartG_GEModel begin"], ["", "text\\<open>The reduct structure of a given structure in the guard-extended signature:\\<close>"], ["", "definition\n\"intT \\<sigma> a \\<equiv>\n if unprot \\<sigma> then eintT \\<sigma> a\n else eintT \\<sigma> a \\<and> eintP (Guard \\<sigma>) [a]\""], ["", "definition\n\"intF f al \\<equiv> eintF (Oldf f) al\""], ["", "definition\n\"intP p al \\<equiv> eintP (Oldp p) al\""], ["", "(* Semantic rephrasings of the fact that the (guarded problem) model satisfies\n   Fax and Wax *)"], ["", "lemma GE_Guard_all: (* fixme: messy proof *)\nassumes f: \"wtFsym f\"\nand al: \"list_all2 eintT (arOf f) al\"\nshows\n\"(\\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f)\n  \\<longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al])\n \\<and>\n (protCl (resOf f) \\<longrightarrow>\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n  \\<longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al])\"\n(is \"(?A1 \\<longrightarrow> ?C) \\<and>\n     (?A2 \\<longrightarrow> ?H2 \\<longrightarrow> ?C)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> unprot (resOf f) \\<and>\n     \\<not> protCl (resOf f) \\<longrightarrow>\n     eintP (Guard (resOf f)) [eintF (Oldf f) al]) \\<and>\n    (protCl (resOf f) \\<longrightarrow>\n     list_all2 (eintP \\<circ> Guard) (arOf f)\n      (map singl al) \\<longrightarrow>\n     eintP (Guard (resOf f)) [eintF (Oldf f) al])", "proof(intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "define xl where \"xl = getVars (arOf f)\""], ["proof (state)\nthis:\n  xl = GE.getVars (arOf f)\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "have l[simp]: \"length xl = length al\" \"length al = length (arOf f)\"\n                \"length (getTvars (arOf f)) = length (arOf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xl = length al &&&\n    length al = length (arOf f) &&&\n    length (GE.getTvars (arOf f)) = length (arOf f)", "unfolding xl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (GE.getVars (arOf f)) = length al &&&\n    length al = length (arOf f) &&&\n    length (GE.getTvars (arOf f)) = length (arOf f)", "using al"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. length (GE.getVars (arOf f)) = length al &&&\n    length al = length (arOf f) &&&\n    length (GE.getTvars (arOf f)) = length (arOf f)", "unfolding list_all2_iff"], ["proof (prove)\nusing this:\n  length (arOf f) = length al \\<and>\n  (\\<forall>(x, y)\\<in>set (zip (arOf f) al). eintT x y)\n\ngoal (1 subgoal):\n 1. length (GE.getVars (arOf f)) = length al &&&\n    length al = length (arOf f) &&&\n    length (GE.getTvars (arOf f)) = length (arOf f)", "by auto"], ["proof (state)\nthis:\n  length xl = length al\n  length al = length (arOf f)\n  length (GE.getTvars (arOf f)) = length (arOf f)\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "have 1[simp]: \"\\<And> i. i < length (arOf f) \\<Longrightarrow> tpOfV (xl!i) = (arOf f)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow> GE.tpOfV (xl ! i) = arOf f ! i", "unfolding xl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow>\n       GE.tpOfV (GE.getVars (arOf f) ! i) = arOf f ! i", "by auto"], ["proof (state)\nthis:\n  ?i14 < length (arOf f) \\<Longrightarrow>\n  GE.tpOfV (xl ! ?i14) = arOf f ! ?i14\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "have xl[simp]: \"distinct xl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xl", "unfolding xl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (GE.getVars (arOf f))", "using distinct_getVars"], ["proof (prove)\nusing this:\n  distinct (GE.getVars ?\\<sigma>l)\n\ngoal (1 subgoal):\n 1. distinct (GE.getVars (arOf f))", "by auto"], ["proof (state)\nthis:\n  distinct xl\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "define \\<xi> where \"\\<xi> = pickE xl al\""], ["proof (state)\nthis:\n  \\<xi> = pickE xl al\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "have \\<xi>: \"GE.wtE \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE \\<xi>", "unfolding \\<xi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (pickE xl al)", "apply(rule wtE_pickE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length xl = length al\n 2. distinct xl\n 3. \\<And>i.\n       i < length xl \\<Longrightarrow> eintT (GE.tpOfV (xl ! i)) (al ! i)", "using al list_all2_nthD"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n  \\<lbrakk>list_all2 ?P ?xs ?ys; ?p < length ?xs\\<rbrakk>\n  \\<Longrightarrow> ?P (?xs ! ?p) (?ys ! ?p)\n\ngoal (3 subgoals):\n 1. length xl = length al\n 2. distinct xl\n 3. \\<And>i.\n       i < length xl \\<Longrightarrow> eintT (GE.tpOfV (xl ! i)) (al ! i)", "by auto"], ["proof (state)\nthis:\n  wtE \\<xi>\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "have [simp]: \"\\<And> i. i < length (arOf f) \\<Longrightarrow> \\<xi> (xl ! i) = al ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < length (arOf f) \\<Longrightarrow> \\<xi> (xl ! i) = al ! i", "using al"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length (arOf f) \\<Longrightarrow> \\<xi> (xl ! i) = al ! i", "unfolding \\<xi>_def"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow> pickE xl al (xl ! i) = al ! i", "by (auto simp: list_all2_length intro: pickE)"], ["proof (state)\nthis:\n  ?i14 < length (arOf f) \\<Longrightarrow> \\<xi> (xl ! ?i14) = al ! ?i14\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "have 0: \"map (GE.int \\<xi>) (getTvars (arOf f)) = al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (int \\<xi>) (GE.getTvars (arOf f)) = al", "apply(rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map (int \\<xi>) (GE.getTvars (arOf f))) = length al\n 2. \\<And>i.\n       i < length (map (int \\<xi>) (GE.getTvars (arOf f))) \\<Longrightarrow>\n       map (int \\<xi>) (GE.getTvars (arOf f)) ! i = al ! i", "using al"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (2 subgoals):\n 1. length (map (int \\<xi>) (GE.getTvars (arOf f))) = length al\n 2. \\<And>i.\n       i < length (map (int \\<xi>) (GE.getTvars (arOf f))) \\<Longrightarrow>\n       map (int \\<xi>) (GE.getTvars (arOf f)) ! i = al ! i", "by (auto simp: list_all2_length getTvars_def xl_def[symmetric])"], ["proof (state)\nthis:\n  map (int \\<xi>) (GE.getTvars (arOf f)) = al\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "have 1:\n  \"GE.satC \\<xi> (map Neg (map2 (Pr \\<circ> Guard) (arOf f) (map singl (getTvars (arOf f))))) \\<longleftrightarrow>\n   \\<not> list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satC \\<xi>\n     (map Neg\n       (map2 (Pr \\<circ> Guard) (arOf f)\n         (map singl (GE.getTvars (arOf f))))) =\n    (\\<not> list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al))", "unfolding GE.satC_def list_ex_length list_all2_map2 singl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n<length\n                 (map Neg\n                   (map2 (Pr \\<circ> Guard) (arOf f)\n                     (map (\\<lambda>a. [a]) (GE.getTvars (arOf f))))).\n        satL \\<xi>\n         (map Neg\n           (map2 (Pr \\<circ> Guard) (arOf f)\n             (map (\\<lambda>a. [a]) (GE.getTvars (arOf f)))) !\n          n)) =\n    (\\<not> list_all2 (\\<lambda>x y. (eintP \\<circ> Guard) x [y]) (arOf f)\n             al)", "unfolding list_all2_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n<length\n                 (map Neg\n                   (map2 (Pr \\<circ> Guard) (arOf f)\n                     (map (\\<lambda>a. [a]) (GE.getTvars (arOf f))))).\n        satL \\<xi>\n         (map Neg\n           (map2 (Pr \\<circ> Guard) (arOf f)\n             (map (\\<lambda>a. [a]) (GE.getTvars (arOf f)))) !\n          n)) =\n    (\\<not> (length (arOf f) = length al \\<and>\n             (\\<forall>i<length (arOf f).\n                 (eintP \\<circ> Guard) (arOf f ! i) [al ! i])))", "by (auto simp add: map_zip_map2 singl_def getTvars_def xl_def[symmetric])"], ["proof (state)\nthis:\n  satC \\<xi>\n   (map Neg\n     (map2 (Pr \\<circ> Guard) (arOf f)\n       (map singl (GE.getTvars (arOf f))))) =\n  (\\<not> list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al))\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "have Fax: \"GE.satPB \\<xi> Fax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB \\<xi> Fax", "using GE.sat_\\<Phi>[OF \\<xi>]"], ["proof (prove)\nusing this:\n  satPB \\<xi> gPB\n\ngoal (1 subgoal):\n 1. satPB \\<xi> Fax", "unfolding gPB_def"], ["proof (prove)\nusing this:\n  satPB \\<xi> (gC ` \\<Phi> \\<union> Fax \\<union> Wax)\n\ngoal (1 subgoal):\n 1. satPB \\<xi> Fax", "by simp"], ["proof (state)\nthis:\n  satPB \\<xi> Fax\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "{"], ["proof (state)\nthis:\n  satPB \\<xi> Fax\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "assume ?A1"], ["proof (state)\nthis:\n  \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f)\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "hence \"GE.satC \\<xi> (fax f)\""], ["proof (prove)\nusing this:\n  \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f)\n\ngoal (1 subgoal):\n 1. satC \\<xi> (fax f)", "using f Fax"], ["proof (prove)\nusing this:\n  \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f)\n  wtFsym f\n  satPB \\<xi> Fax\n\ngoal (1 subgoal):\n 1. satC \\<xi> (fax f)", "unfolding GE.satPB_def Fax_def"], ["proof (prove)\nusing this:\n  \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f)\n  wtFsym f\n  \\<forall>c\\<in>{fax f |f.\n                  wtFsym f \\<and>\n                  \\<not> unprot (resOf f) \\<and>\n                  \\<not> protCl (resOf f)} \\<union>\n                 {faxCD f |f. wtFsym f \\<and> protCl (resOf f)}.\n     satC \\<xi> c\n\ngoal (1 subgoal):\n 1. satC \\<xi> (fax f)", "by auto"], ["proof (state)\nthis:\n  satC \\<xi> (fax f)\n\ngoal (2 subgoals):\n 1. \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [eintF (Oldf f) al]\n 2. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "thus ?C"], ["proof (prove)\nusing this:\n  satC \\<xi> (fax f)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [eintF (Oldf f) al]", "unfolding fax_def cOfFax_def GE.satC_def"], ["proof (prove)\nusing this:\n  list_ex (satL \\<xi>)\n   [Pos (Pr (Guard (resOf f)) [Fn (Oldf f) (GE.getTvars (arOf f))])]\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [eintF (Oldf f) al]", "by (simp add: 0)"], ["proof (state)\nthis:\n  eintP (Guard (resOf f)) [eintF (Oldf f) al]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "}"], ["proof (state)\nthis:\n  \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n  eintP (Guard (resOf f)) [eintF (Oldf f) al]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "{"], ["proof (state)\nthis:\n  \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<Longrightarrow>\n  eintP (Guard (resOf f)) [eintF (Oldf f) al]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "assume ?A2 and ?H2"], ["proof (state)\nthis:\n  protCl (resOf f)\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "hence \"GE.satC \\<xi> (faxCD f)\""], ["proof (prove)\nusing this:\n  protCl (resOf f)\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n\ngoal (1 subgoal):\n 1. satC \\<xi> (faxCD f)", "using f Fax"], ["proof (prove)\nusing this:\n  protCl (resOf f)\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n  wtFsym f\n  satPB \\<xi> Fax\n\ngoal (1 subgoal):\n 1. satC \\<xi> (faxCD f)", "unfolding GE.satPB_def Fax_def"], ["proof (prove)\nusing this:\n  protCl (resOf f)\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n  wtFsym f\n  \\<forall>c\\<in>{fax f |f.\n                  wtFsym f \\<and>\n                  \\<not> unprot (resOf f) \\<and>\n                  \\<not> protCl (resOf f)} \\<union>\n                 {faxCD f |f. wtFsym f \\<and> protCl (resOf f)}.\n     satC \\<xi> c\n\ngoal (1 subgoal):\n 1. satC \\<xi> (faxCD f)", "by auto"], ["proof (state)\nthis:\n  satC \\<xi> (faxCD f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>protCl (resOf f);\n     list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n    \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]", "thus ?C"], ["proof (prove)\nusing this:\n  satC \\<xi> (faxCD f)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [eintF (Oldf f) al]", "using \\<open>?H2\\<close>"], ["proof (prove)\nusing this:\n  satC \\<xi> (faxCD f)\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [eintF (Oldf f) al]", "unfolding faxCD_def fax_def cOfFax_def hOfFax_def"], ["proof (prove)\nusing this:\n  satC \\<xi>\n   (map Neg\n     (map2 (Pr \\<circ> Guard) (arOf f) (map singl (GE.getTvars (arOf f)))) @\n    [Pos (Pr (Guard (resOf f)) [Fn (Oldf f) (GE.getTvars (arOf f))])])\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [eintF (Oldf f) al]", "unfolding GE.satC_append 1"], ["proof (prove)\nusing this:\n  \\<not> list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al) \\<or>\n  satC \\<xi>\n   [Pos (Pr (Guard (resOf f)) [Fn (Oldf f) (GE.getTvars (arOf f))])]\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [eintF (Oldf f) al]", "unfolding GE.satC_def"], ["proof (prove)\nusing this:\n  \\<not> list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al) \\<or>\n  list_ex (satL \\<xi>)\n   [Pos (Pr (Guard (resOf f)) [Fn (Oldf f) (GE.getTvars (arOf f))])]\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [eintF (Oldf f) al]", "by (simp add: 0)"], ["proof (state)\nthis:\n  eintP (Guard (resOf f)) [eintF (Oldf f) al]\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>protCl (resOf f);\n   list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\\<rbrakk>\n  \\<Longrightarrow> eintP (Guard (resOf f)) [eintF (Oldf f) al]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma GE_Guard_not_unprot_protCl:\nassumes f: \"wtFsym f\" and f2: \"\\<not> unprot (resOf f)\" \"\\<not> protCl (resOf f)\"\nand al: \"list_all2 eintT (arOf f) al\"\nshows \"eintP (Guard (resOf f)) [intF f al]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "using GE_Guard_all[OF f al] f2"], ["proof (prove)\nusing this:\n  (\\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<longrightarrow>\n   eintP (Guard (resOf f)) [eintF (Oldf f) al]) \\<and>\n  (protCl (resOf f) \\<longrightarrow>\n   list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al) \\<longrightarrow>\n   eintP (Guard (resOf f)) [eintF (Oldf f) al])\n  \\<not> unprot (resOf f)\n  \\<not> protCl (resOf f)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "unfolding intF_def"], ["proof (prove)\nusing this:\n  (\\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<longrightarrow>\n   eintP (Guard (resOf f)) [eintF (Oldf f) al]) \\<and>\n  (protCl (resOf f) \\<longrightarrow>\n   list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al) \\<longrightarrow>\n   eintP (Guard (resOf f)) [eintF (Oldf f) al])\n  \\<not> unprot (resOf f)\n  \\<not> protCl (resOf f)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [eintF (Oldf f) al]", "by auto"], ["", "lemma GE_Guard_protCl:\nassumes f: \"wtFsym f\" and f2: \"protCl (resOf f)\" and al: \"list_all2 eintT (arOf f) al\"\nand H: \"list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\"\nshows \"eintP (Guard (resOf f)) [intF f al]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "using GE_Guard_all[OF f al] f2 H"], ["proof (prove)\nusing this:\n  (\\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<longrightarrow>\n   eintP (Guard (resOf f)) [eintF (Oldf f) al]) \\<and>\n  (protCl (resOf f) \\<longrightarrow>\n   list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al) \\<longrightarrow>\n   eintP (Guard (resOf f)) [eintF (Oldf f) al])\n  protCl (resOf f)\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "unfolding intF_def"], ["proof (prove)\nusing this:\n  (\\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f) \\<longrightarrow>\n   eintP (Guard (resOf f)) [eintF (Oldf f) al]) \\<and>\n  (protCl (resOf f) \\<longrightarrow>\n   list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al) \\<longrightarrow>\n   eintP (Guard (resOf f)) [eintF (Oldf f) al])\n  protCl (resOf f)\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [eintF (Oldf f) al]", "by auto"], ["", "lemma GE_Guard_not_unprot:\nassumes f: \"wtFsym f\" and f2: \"\\<not> unprot (resOf f)\" and al: \"list_all2 eintT (arOf f) al\"\nand H: \"list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\"\nshows \"eintP (Guard (resOf f)) [intF f al]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "apply(cases \"protCl (resOf f)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]\n 2. \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [intF f al]", "using GE_Guard_protCl[OF f _ al H]"], ["proof (prove)\nusing this:\n  protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]\n\ngoal (2 subgoals):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]\n 2. \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [intF f al]", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [intF f al]", "using GE_Guard_not_unprot_protCl[OF f f2 _ al]"], ["proof (prove)\nusing this:\n  \\<not> protCl (resOf f) \\<Longrightarrow>\n  eintP (Guard (resOf f)) [intF f al]\n\ngoal (1 subgoal):\n 1. \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [intF f al]", "by simp"], ["", "lemma GE_Wit:\nassumes \\<sigma>: \"\\<not> unprot \\<sigma>\" \"\\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\"\nshows \"eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "define \\<xi> where \"\\<xi> = pickE [] []\""], ["proof (state)\nthis:\n  \\<xi> = pickE [] []\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "have \\<xi>: \"GE.wtE \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE \\<xi>", "unfolding \\<xi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (pickE [] [])", "apply(rule wtE_pickE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length [] = length []\n 2. distinct []\n 3. \\<And>i.\n       i < length [] \\<Longrightarrow> eintT (GE.tpOfV ([] ! i)) ([] ! i)", "by auto"], ["proof (state)\nthis:\n  wtE \\<xi>\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "have \"GE.satPB \\<xi> Wax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB \\<xi> Wax", "using GE.sat_\\<Phi>[OF \\<xi>]"], ["proof (prove)\nusing this:\n  satPB \\<xi> gPB\n\ngoal (1 subgoal):\n 1. satPB \\<xi> Wax", "unfolding gPB_def"], ["proof (prove)\nusing this:\n  satPB \\<xi> (gC ` \\<Phi> \\<union> Fax \\<union> Wax)\n\ngoal (1 subgoal):\n 1. satPB \\<xi> Wax", "by simp"], ["proof (state)\nthis:\n  satPB \\<xi> Wax\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "hence \"GE.satC \\<xi> (wax \\<sigma>)\""], ["proof (prove)\nusing this:\n  satPB \\<xi> Wax\n\ngoal (1 subgoal):\n 1. satC \\<xi> (wax \\<sigma>)", "unfolding Wax_def GE.satPB_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>{wax \\<sigma> |\\<sigma>.\n                  \\<not> unprot \\<sigma> \\<and>\n                  (\\<not> isRes \\<sigma> \\<or> protCl \\<sigma>)}.\n     satC \\<xi> c\n\ngoal (1 subgoal):\n 1. satC \\<xi> (wax \\<sigma>)", "using \\<sigma>"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>{wax \\<sigma> |\\<sigma>.\n                  \\<not> unprot \\<sigma> \\<and>\n                  (\\<not> isRes \\<sigma> \\<or> protCl \\<sigma>)}.\n     satC \\<xi> c\n  \\<not> unprot \\<sigma>\n  \\<not> isRes \\<sigma> \\<or> protCl \\<sigma>\n\ngoal (1 subgoal):\n 1. satC \\<xi> (wax \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  satC \\<xi> (wax \\<sigma>)\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "thus ?thesis"], ["proof (prove)\nusing this:\n  satC \\<xi> (wax \\<sigma>)\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "unfolding satC_def wax_def"], ["proof (prove)\nusing this:\n  list_ex (satL \\<xi>) [Pos (Pr (Guard \\<sigma>) [Fn (Wit \\<sigma>) []])]\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "by simp"], ["proof (state)\nthis:\n  eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NE_intT_forget: \"NE (intT \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "obtain a where a: \"eintT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. eintT \\<sigma> a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using GE.NE_intT"], ["proof (prove)\nusing this:\n  \\<exists>a. eintT ?\\<sigma> a\n\ngoal (1 subgoal):\n 1. (\\<And>a. eintT \\<sigma> a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "proof(cases \"unprot \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case True"], ["proof (state)\nthis:\n  unprot \\<sigma>\n\ngoal (2 subgoals):\n 1. unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "thus ?thesis"], ["proof (prove)\nusing this:\n  unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "using a"], ["proof (prove)\nusing this:\n  unprot \\<sigma>\n  eintT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "unfolding intT_def"], ["proof (prove)\nusing this:\n  unprot \\<sigma>\n  eintT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       if unprot \\<sigma> then eintT \\<sigma> a\n       else eintT \\<sigma> a \\<and> eintP (Guard \\<sigma>) [a]", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case False"], ["proof (state)\nthis:\n  \\<not> unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "note unprot = False"], ["proof (state)\nthis:\n  \\<not> unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "proof(cases \"isRes \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case True"], ["proof (state)\nthis:\n  isRes \\<sigma>\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "then"], ["proof (chain)\npicking this:\n  isRes \\<sigma>", "obtain f where f: \"wtFsym f\" and \\<sigma>: \"\\<sigma> = resOf f\""], ["proof (prove)\nusing this:\n  isRes \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>wtFsym f; \\<sigma> = resOf f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding isRes_def"], ["proof (prove)\nusing this:\n  \\<exists>f. wtFsym f \\<and> resOf f = \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>wtFsym f; \\<sigma> = resOf f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  wtFsym f\n  \\<sigma> = resOf f\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "define al where \"al = map pickT (arOf f)\""], ["proof (state)\nthis:\n  al = map pickT (arOf f)\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have al: \"list_all2 eintT (arOf f) al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 eintT (arOf f) al", "unfolding al_def list_all2_map2"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. eintT x (pickT y)) (arOf f) (arOf f)", "unfolding list_all2_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (arOf f) = length (arOf f) \\<and>\n    (\\<forall>i<length (arOf f). eintT (arOf f ! i) (pickT (arOf f ! i)))", "by auto"], ["proof (state)\nthis:\n  list_all2 eintT (arOf f) al\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "define a where \"a = intF f al\""], ["proof (state)\nthis:\n  a = intF f al\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have a: \"eintT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> a", "unfolding a_def \\<sigma> intF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT (resOf f) (eintF (Oldf f) al)", "using f al"], ["proof (prove)\nusing this:\n  wtFsym f\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. eintT (resOf f) (eintF (Oldf f) al)", "by (metis GE_arOf.simps GE_resOf.simps GE_wtFsym.simps GE.intF)"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "proof (cases \"protCl \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case True"], ["proof (state)\nthis:\n  protCl \\<sigma>\n\ngoal (2 subgoals):\n 1. protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "define a where \"a = eintF (Wit \\<sigma>) []\""], ["proof (state)\nthis:\n  a = eintF (Wit \\<sigma>) []\n\ngoal (2 subgoals):\n 1. protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have \"eintT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> (eintF (Wit \\<sigma>) [])", "by (metis True GE_arOf.simps GE_resOf.simps GE_wtFsym.simps intF list_all2_Nil)"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (2 subgoals):\n 1. protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "moreover"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (2 subgoals):\n 1. protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have \"eintP (Guard \\<sigma>) [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [a]", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "using GE_Wit[OF unprot] True"], ["proof (prove)\nusing this:\n  \\<not> isRes \\<sigma> \\<or> protCl \\<sigma> \\<Longrightarrow>\n  eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]\n  protCl \\<sigma>\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "by simp"], ["proof (state)\nthis:\n  eintP (Guard \\<sigma>) [a]\n\ngoal (2 subgoals):\n 1. protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "ultimately"], ["proof (chain)\npicking this:\n  eintT \\<sigma> a\n  eintP (Guard \\<sigma>) [a]", "show ?thesis"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintP (Guard \\<sigma>) [a]\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "using unprot"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintP (Guard \\<sigma>) [a]\n  \\<not> unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "unfolding intT_def"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintP (Guard \\<sigma>) [a]\n  \\<not> unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       if unprot \\<sigma> then eintT \\<sigma> a\n       else eintT \\<sigma> a \\<and> eintP (Guard \\<sigma>) [a]", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case False"], ["proof (state)\nthis:\n  \\<not> protCl \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "hence \"eintP (Guard \\<sigma>) [a]\""], ["proof (prove)\nusing this:\n  \\<not> protCl \\<sigma>\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [a]", "using unprot GE_Guard_not_unprot_protCl[OF f _ _ al]"], ["proof (prove)\nusing this:\n  \\<not> protCl \\<sigma>\n  \\<not> unprot \\<sigma>\n  \\<lbrakk>\\<not> unprot (resOf f); \\<not> protCl (resOf f)\\<rbrakk>\n  \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [a]", "unfolding \\<sigma> a_def"], ["proof (prove)\nusing this:\n  \\<not> protCl (resOf f)\n  \\<not> unprot (resOf f)\n  \\<lbrakk>\\<not> unprot (resOf f); \\<not> protCl (resOf f)\\<rbrakk>\n  \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "by simp"], ["proof (state)\nthis:\n  eintP (Guard \\<sigma>) [a]\n\ngoal (1 subgoal):\n 1. \\<not> protCl \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "thus ?thesis"], ["proof (prove)\nusing this:\n  eintP (Guard \\<sigma>) [a]\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "using unprot a"], ["proof (prove)\nusing this:\n  eintP (Guard \\<sigma>) [a]\n  \\<not> unprot \\<sigma>\n  eintT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "unfolding intT_def"], ["proof (prove)\nusing this:\n  eintP (Guard \\<sigma>) [a]\n  \\<not> unprot \\<sigma>\n  eintT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       if unprot \\<sigma> then eintT \\<sigma> a\n       else eintT \\<sigma> a \\<and> eintP (Guard \\<sigma>) [a]", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case False"], ["proof (state)\nthis:\n  \\<not> isRes \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "define a where \"a = eintF (Wit \\<sigma>) []\""], ["proof (state)\nthis:\n  a = eintF (Wit \\<sigma>) []\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have \"eintT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> (eintF (Wit \\<sigma>) [])", "by (metis False GE_arOf.simps GE_resOf.simps GE_wtFsym.simps intF list_all2_Nil)"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "moreover"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have \"eintP (Guard \\<sigma>) [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [a]", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "using GE_Wit[OF unprot] False"], ["proof (prove)\nusing this:\n  \\<not> isRes \\<sigma> \\<or> protCl \\<sigma> \\<Longrightarrow>\n  eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]\n  \\<not> isRes \\<sigma>\n\ngoal (1 subgoal):\n 1. eintP (Guard \\<sigma>) [eintF (Wit \\<sigma>) []]", "by simp"], ["proof (state)\nthis:\n  eintP (Guard \\<sigma>) [a]\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "ultimately"], ["proof (chain)\npicking this:\n  eintT \\<sigma> a\n  eintP (Guard \\<sigma>) [a]", "show ?thesis"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintP (Guard \\<sigma>) [a]\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "using unprot"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintP (Guard \\<sigma>) [a]\n  \\<not> unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "unfolding intT_def"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintP (Guard \\<sigma>) [a]\n  \\<not> unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       if unprot \\<sigma> then eintT \\<sigma> a\n       else eintT \\<sigma> a \\<and> eintP (Guard \\<sigma>) [a]", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_intF:\nassumes f: \"wtFsym f\" and al: \"list_all2 intT (arOf f) al\"\nshows \"intT (resOf f) (intF f al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "have 0: \"list_all2 eintT (arOf f) al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 eintT (arOf f) al", "using al"], ["proof (prove)\nusing this:\n  list_all2 intT (arOf f) al\n\ngoal (1 subgoal):\n 1. list_all2 eintT (arOf f) al", "unfolding intT_def[abs_def] list_all2_length"], ["proof (prove)\nusing this:\n  length (arOf f) = length al \\<and>\n  (\\<forall>i<length (arOf f).\n      if unprot (arOf f ! i) then eintT (arOf f ! i) (al ! i)\n      else eintT (arOf f ! i) (al ! i) \\<and>\n           eintP (Guard (arOf f ! i)) [al ! i])\n\ngoal (1 subgoal):\n 1. length (arOf f) = length al \\<and>\n    (\\<forall>i<length (arOf f). eintT (arOf f ! i) (al ! i))", "by metis"], ["proof (state)\nthis:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "hence \"eintT (resOf f) (eintF (Oldf f) al)\""], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. eintT (resOf f) (eintF (Oldf f) al)", "by (metis GE_arOf.simps GE_resOf.simps GE_wtFsym.simps f al GE.intF)"], ["proof (state)\nthis:\n  eintT (resOf f) (eintF (Oldf f) al)\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "hence 1: \"eintT (resOf f) (intF f al)\""], ["proof (prove)\nusing this:\n  eintT (resOf f) (eintF (Oldf f) al)\n\ngoal (1 subgoal):\n 1. eintT (resOf f) (intF f al)", "unfolding intF_def"], ["proof (prove)\nusing this:\n  eintT (resOf f) (eintF (Oldf f) al)\n\ngoal (1 subgoal):\n 1. eintT (resOf f) (eintF (Oldf f) al)", "by simp"], ["proof (state)\nthis:\n  eintT (resOf f) (intF f al)\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "proof(cases \"unprot (resOf f)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)\n 2. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "case True"], ["proof (state)\nthis:\n  unprot (resOf f)\n\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)\n 2. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "thus ?thesis"], ["proof (prove)\nusing this:\n  unprot (resOf f)\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "unfolding intT_def"], ["proof (prove)\nusing this:\n  unprot (resOf f)\n\ngoal (1 subgoal):\n 1. if unprot (resOf f) then eintT (resOf f) (intF f al)\n    else eintT (resOf f) (intF f al) \\<and>\n         eintP (Guard (resOf f)) [intF f al]", "by (simp add: 1)"], ["proof (state)\nthis:\n  intT (resOf f) (intF f al)\n\ngoal (1 subgoal):\n 1. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "case False"], ["proof (state)\nthis:\n  \\<not> unprot (resOf f)\n\ngoal (1 subgoal):\n 1. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "note unprot = False"], ["proof (state)\nthis:\n  \\<not> unprot (resOf f)\n\ngoal (1 subgoal):\n 1. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "have \"eintP (Guard (resOf f)) [intF f al]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "proof(cases \"protCl (resOf f)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]\n 2. \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [intF f al]", "case False"], ["proof (state)\nthis:\n  \\<not> protCl (resOf f)\n\ngoal (2 subgoals):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]\n 2. \\<not> protCl (resOf f) \\<Longrightarrow>\n    eintP (Guard (resOf f)) [intF f al]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "using GE_Guard_not_unprot_protCl[OF f unprot False 0]"], ["proof (prove)\nusing this:\n  eintP (Guard (resOf f)) [intF f al]\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "."], ["proof (state)\nthis:\n  eintP (Guard (resOf f)) [intF f al]\n\ngoal (1 subgoal):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]", "case True"], ["proof (state)\nthis:\n  protCl (resOf f)\n\ngoal (1 subgoal):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]", "hence \"list_all protCl (arOf f)\""], ["proof (prove)\nusing this:\n  protCl (resOf f)\n\ngoal (1 subgoal):\n 1. list_all protCl (arOf f)", "using protCl_fsym"], ["proof (prove)\nusing this:\n  protCl (resOf f)\n  protCl (?resPf ?f) \\<Longrightarrow> list_all protCl (arOf ?f)\n\ngoal (1 subgoal):\n 1. list_all protCl (arOf f)", "by simp"], ["proof (state)\nthis:\n  list_all protCl (arOf f)\n\ngoal (1 subgoal):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]", "hence \"list_all (\\<lambda> \\<sigma>. \\<not> unprot \\<sigma>) (arOf f)\""], ["proof (prove)\nusing this:\n  list_all protCl (arOf f)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>\\<sigma>. \\<not> unprot \\<sigma>) (arOf f)", "unfolding list_all_length unprot_def"], ["proof (prove)\nusing this:\n  \\<forall>n<length (arOf f). protCl (arOf f ! n)\n\ngoal (1 subgoal):\n 1. \\<forall>n<length (arOf f).\n       \\<not> (\\<not> prot (arOf f ! n) \\<and> \\<not> protFw (arOf f ! n))", "by auto"], ["proof (state)\nthis:\n  list_all (\\<lambda>\\<sigma>. \\<not> unprot \\<sigma>) (arOf f)\n\ngoal (1 subgoal):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]", "hence 2: \"list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>\\<sigma>. \\<not> unprot \\<sigma>) (arOf f)\n\ngoal (1 subgoal):\n 1. list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)", "using al"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>\\<sigma>. \\<not> unprot \\<sigma>) (arOf f)\n  list_all2 intT (arOf f) al\n\ngoal (1 subgoal):\n 1. list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)", "unfolding intT_def[abs_def] list_all2_length list_all_length\n      singl_def[abs_def]"], ["proof (prove)\nusing this:\n  \\<forall>n<length (arOf f). \\<not> unprot (arOf f ! n)\n  length (arOf f) = length al \\<and>\n  (\\<forall>i<length (arOf f).\n      if unprot (arOf f ! i) then eintT (arOf f ! i) (al ! i)\n      else eintT (arOf f ! i) (al ! i) \\<and>\n           eintP (Guard (arOf f ! i)) [al ! i])\n\ngoal (1 subgoal):\n 1. length (arOf f) = length (map (\\<lambda>a. [a]) al) \\<and>\n    (\\<forall>i<length (arOf f).\n        (eintP \\<circ> Guard) (arOf f ! i) (map (\\<lambda>a. [a]) al ! i))", "by auto"], ["proof (state)\nthis:\n  list_all2 (eintP \\<circ> Guard) (arOf f) (map singl al)\n\ngoal (1 subgoal):\n 1. protCl (resOf f) \\<Longrightarrow> eintP (Guard (resOf f)) [intF f al]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "using GE_Guard_protCl[OF f True 0 2]"], ["proof (prove)\nusing this:\n  eintP (Guard (resOf f)) [intF f al]\n\ngoal (1 subgoal):\n 1. eintP (Guard (resOf f)) [intF f al]", "."], ["proof (state)\nthis:\n  eintP (Guard (resOf f)) [intF f al]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eintP (Guard (resOf f)) [intF f al]\n\ngoal (1 subgoal):\n 1. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "thus ?thesis"], ["proof (prove)\nusing this:\n  eintP (Guard (resOf f)) [intF f al]\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "using unprot"], ["proof (prove)\nusing this:\n  eintP (Guard (resOf f)) [intF f al]\n  \\<not> unprot (resOf f)\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "unfolding intT_def"], ["proof (prove)\nusing this:\n  eintP (Guard (resOf f)) [intF f al]\n  \\<not> unprot (resOf f)\n\ngoal (1 subgoal):\n 1. if unprot (resOf f) then eintT (resOf f) (intF f al)\n    else eintT (resOf f) (intF f al) \\<and>\n         eintP (Guard (resOf f)) [intF f al]", "by (simp add: 1)"], ["proof (state)\nthis:\n  intT (resOf f) (intF f al)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  intT (resOf f) (intF f al)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Struct: \"Struct wtFsym wtPsym arOf resOf intT intF intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.SStruct intT intF intP", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (resOf f) (intF f al)\n 3. intP = intP", "using NE_intT_forget wt_intF"], ["proof (prove)\nusing this:\n  \\<exists>a. intT ?\\<sigma> a\n  \\<lbrakk>wtFsym ?f; list_all2 intT (arOf ?f) ?al\\<rbrakk>\n  \\<Longrightarrow> intT (resOf ?f) (intF ?f ?al)\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (resOf f) (intF f al)\n 3. intP = intP", "by auto"], ["", "end"], ["", "(* context ProblemIkTpartG_GEModel *)"], ["", "sublocale ProblemIkTpartG_GEModel < Ik? : Struct\nwhere intT = intT and intF = intF and intP = intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.SStruct intT intF intP", "using Struct"], ["proof (prove)\nusing this:\n  Ik.SStruct intT intF intP\n\ngoal (1 subgoal):\n 1. Ik.SStruct intT intF intP", "."], ["", "context ProblemIkTpartG_GEModel begin"], ["", "lemma wtE[simp]: \"Ik.wtE \\<xi> \\<Longrightarrow> GE.wtE \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wtE \\<xi> \\<Longrightarrow> GE.wtE \\<xi>", "unfolding Ik.wtE_def GE.wtE_def intT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       if unprot (GE.tpOfV x) then eintT (GE.tpOfV x) (\\<xi> x)\n       else eintT (GE.tpOfV x) (\\<xi> x) \\<and>\n            eintP (Guard (GE.tpOfV x)) [\\<xi> x] \\<Longrightarrow>\n    \\<forall>x. eintT (GE.tpOfV x) (\\<xi> x)", "by metis"], ["", "lemma int_g[simp]: \"GE.int \\<xi> (gT T) = Ik.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.int \\<xi> (gT T) = Ik.int \\<xi> T", "proof (induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a) Tl\n\ngoal (2 subgoals):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "let ?ar = \"arOf f\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "let ?r = \"resOf f\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "have 0: \"map (Ik.int \\<xi>) Tl = map (GE.int \\<xi> \\<circ> gT) Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Ik.int \\<xi>) Tl = map (GE.int \\<xi> \\<circ> gT) Tl", "apply(rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map (Ik.int \\<xi>) Tl) =\n    length (map (GE.int \\<xi> \\<circ> gT) Tl)\n 2. \\<And>i.\n       i < length (map (Ik.int \\<xi>) Tl) \\<Longrightarrow>\n       map (Ik.int \\<xi>) Tl ! i = map (GE.int \\<xi> \\<circ> gT) Tl ! i", "using Fn"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a) Tl\n\ngoal (2 subgoals):\n 1. length (map (Ik.int \\<xi>) Tl) =\n    length (map (GE.int \\<xi> \\<circ> gT) Tl)\n 2. \\<And>i.\n       i < length (map (Ik.int \\<xi>) Tl) \\<Longrightarrow>\n       map (Ik.int \\<xi>) Tl ! i = map (GE.int \\<xi> \\<circ> gT) Tl ! i", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  \\<forall>n<length Tl. GE.int \\<xi> (gT (Tl ! n)) = Ik.int \\<xi> (Tl ! n)\n\ngoal (2 subgoals):\n 1. length (map (Ik.int \\<xi>) Tl) =\n    length (map (GE.int \\<xi> \\<circ> gT) Tl)\n 2. \\<And>i.\n       i < length (map (Ik.int \\<xi>) Tl) \\<Longrightarrow>\n       map (Ik.int \\<xi>) Tl ! i = map (GE.int \\<xi> \\<circ> gT) Tl ! i", "by auto"], ["proof (state)\nthis:\n  map (Ik.int \\<xi>) Tl = map (GE.int \\<xi> \\<circ> gT) Tl\n\ngoal (2 subgoals):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "unfolding Ik.int.simps GE.int.simps gT.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintF (Oldf f) (map (GE.int \\<xi>) (map gT Tl)) =\n    intF f (map (Ik.int \\<xi>) Tl)", "unfolding intF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintF (Oldf f) (map (GE.int \\<xi>) (map gT Tl)) =\n    eintF (Oldf f) (map (Ik.int \\<xi>) Tl)", "using Fn"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>a. GE.int \\<xi> (gT a) = Ik.int \\<xi> a) Tl\n\ngoal (1 subgoal):\n 1. eintF (Oldf f) (map (GE.int \\<xi>) (map gT Tl)) =\n    eintF (Oldf f) (map (Ik.int \\<xi>) Tl)", "by (simp add: 0)"], ["proof (state)\nthis:\n  GE.int \\<xi> (gT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)\n\ngoal (1 subgoal):\n 1. \\<And>x. GE.int \\<xi> (gT (Var x)) = Ik.int \\<xi> (Var x)", "qed auto"], ["", "lemma map_int_g[simp]:\n\"map (Ik.int \\<xi>) Tl = map (GE.int \\<xi> \\<circ> gT) Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Ik.int \\<xi>) Tl = map (GE.int \\<xi> \\<circ> gT) Tl", "apply(rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map (Ik.int \\<xi>) Tl) =\n    length (map (GE.int \\<xi> \\<circ> gT) Tl)\n 2. \\<And>i.\n       i < length (map (Ik.int \\<xi>) Tl) \\<Longrightarrow>\n       map (Ik.int \\<xi>) Tl ! i = map (GE.int \\<xi> \\<circ> gT) Tl ! i", "unfolding list_all_length"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map (Ik.int \\<xi>) Tl) =\n    length (map (GE.int \\<xi> \\<circ> gT) Tl)\n 2. \\<And>i.\n       i < length (map (Ik.int \\<xi>) Tl) \\<Longrightarrow>\n       map (Ik.int \\<xi>) Tl ! i = map (GE.int \\<xi> \\<circ> gT) Tl ! i", "by auto"], ["", "lemma satA_gA[simp]: \"GE.satA \\<xi> (gA at) \\<longleftrightarrow> Ik.satA \\<xi> at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.satA \\<xi> (gA at) = Ik.satA \\<xi> at", "by (cases at) (auto simp add: intP_def)"], ["", "lemma satL_gL[simp]: \"GE.satL \\<xi> (gL l) \\<longleftrightarrow> Ik.satL \\<xi> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.satL \\<xi> (gL l) = Ik.satL \\<xi> l", "by (cases l) auto"], ["", "lemma satC_map_gL[simp]: \"GE.satC \\<xi> (map gL c) \\<longleftrightarrow> Ik.satC \\<xi> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.satC \\<xi> (map gL c) = Ik.satC \\<xi> c", "unfolding GE.satC_def Ik.satC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex (GE.satL \\<xi>) (map gL c) = list_ex (Ik.satL \\<xi>) c", "by (induct c) auto"], ["", "lemma wtE_not_grdLit_unprot[simp]: (* crucial: *)\nassumes \"Ik.wtE \\<xi>\" and \"\\<not> unprot (tpOfV x)\"\nshows \"\\<not> GE.satL \\<xi> (grdLit x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> GE.satL \\<xi> (grdLit x)", "using assms"], ["proof (prove)\nusing this:\n  Ik.wtE \\<xi>\n  \\<not> unprot (GE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<not> GE.satL \\<xi> (grdLit x)", "unfolding Ik.wtE_def intT_def grdLit_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     if unprot (GE.tpOfV x) then eintT (GE.tpOfV x) (\\<xi> x)\n     else eintT (GE.tpOfV x) (\\<xi> x) \\<and>\n          eintP (Guard (GE.tpOfV x)) [\\<xi> x]\n  \\<not> unprot (GE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<not> GE.satL \\<xi> (Neg (Pr (Guard (GE.tpOfV x)) [Var x]))", "by simp"], ["", "lemma wtE_not_grdLit[simp]:\nassumes \"Ik.wtE \\<xi>\" and \"prot (tpOfV x) \\<or> protFw (tpOfV x)\"\nshows \"\\<not> GE.satL \\<xi> (grdLit x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> GE.satL \\<xi> (grdLit x)", "apply(rule wtE_not_grdLit_unprot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ik.wtE \\<xi>\n 2. \\<not> unprot (GE.tpOfV x)", "using assms"], ["proof (prove)\nusing this:\n  Ik.wtE \\<xi>\n  prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)\n\ngoal (2 subgoals):\n 1. Ik.wtE \\<xi>\n 2. \\<not> unprot (GE.tpOfV x)", "unfolding unprot_def"], ["proof (prove)\nusing this:\n  Ik.wtE \\<xi>\n  prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)\n\ngoal (2 subgoals):\n 1. Ik.wtE \\<xi>\n 2. \\<not> (\\<not> prot (GE.tpOfV x) \\<and> \\<not> protFw (GE.tpOfV x))", "by auto"], ["", "lemma wtE_not_glitOfL[simp]:\nassumes \"Ik.wtE \\<xi>\"\nshows \"\\<not> GE.satC \\<xi> (list (glitOfL l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> GE.satC \\<xi> (list (glitOfL l))", "using assms"], ["proof (prove)\nusing this:\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. \\<not> GE.satC \\<xi> (list (glitOfL l))", "unfolding GE.satC_def list_ex_list[OF finite_glitOfL]"], ["proof (prove)\nusing this:\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. \\<not> Bex (glitOfL l) (GE.satL \\<xi>)", "by (cases l, auto)"], ["", "lemma wtE_not_glitOfC[simp]:\nassumes \"Ik.wtE \\<xi>\"\nshows \"\\<not> GE.satC \\<xi> (list (glitOfC c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> GE.satC \\<xi> (list (glitOfC c))", "using wtE_not_glitOfL[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> GE.satC \\<xi> (list (glitOfL ?l))\n\ngoal (1 subgoal):\n 1. \\<not> GE.satC \\<xi> (list (glitOfC c))", "unfolding GE.satC_def list_ex_list[OF finite_glitOfC] list_ex_list[OF finite_glitOfL]"], ["proof (prove)\nusing this:\n  \\<not> Bex (glitOfL ?l) (GE.satL \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<not> Bex (glitOfC c) (GE.satL \\<xi>)", "unfolding glitOfC_def"], ["proof (prove)\nusing this:\n  \\<not> Bex (glitOfL ?l) (GE.satL \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<not> Bex (\\<Union> (set (map glitOfL c))) (GE.satL \\<xi>)", "by auto"], ["", "lemma satC_gC[simp]:\nassumes \"Ik.wtE \\<xi>\" and \"GE.satC \\<xi> (gC c)\"\nshows \"Ik.satC \\<xi> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.satC \\<xi> c", "using assms"], ["proof (prove)\nusing this:\n  Ik.wtE \\<xi>\n  GE.satC \\<xi> (gC c)\n\ngoal (1 subgoal):\n 1. Ik.satC \\<xi> c", "unfolding gC_def"], ["proof (prove)\nusing this:\n  Ik.wtE \\<xi>\n  GE.satC \\<xi> (map gL c @ list (glitOfC c))\n\ngoal (1 subgoal):\n 1. Ik.satC \\<xi> c", "by simp"], ["", "lemma satPB_gPB[simp]:\nassumes \"Ik.wtE \\<xi>\" and \"GE.satPB \\<xi> (gC ` \\<Phi>)\"\nshows \"Ik.satPB \\<xi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.satPB \\<xi> \\<Phi>", "using Ik.wt_\\<Phi> assms"], ["proof (prove)\nusing this:\n  Ik.wtPB \\<Phi>\n  Ik.wtE \\<xi>\n  GE.satPB \\<xi> (gC ` \\<Phi>)\n\ngoal (1 subgoal):\n 1. Ik.satPB \\<xi> \\<Phi>", "unfolding GE.satPB_def Ik.satPB_def"], ["proof (prove)\nusing this:\n  Ik.wtPB \\<Phi>\n  Ik.wtE \\<xi>\n  \\<forall>c\\<in>gC ` \\<Phi>. GE.satC \\<xi> c\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<Phi>. Ik.satC \\<xi> c", "by (auto simp add: Ik.wtPB_def)"], ["", "lemma completeness: \"Ik.SAT \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.SAT \\<Phi>", "unfolding Ik.SAT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>. Ik.wtE \\<xi> \\<longrightarrow> Ik.satPB \\<xi> \\<Phi>", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "fix \\<xi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "assume \\<xi>: \"Ik.wtE \\<xi>\""], ["proof (state)\nthis:\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "hence \"GE.wtE \\<xi>\""], ["proof (prove)\nusing this:\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. GE.wtE \\<xi>", "by simp"], ["proof (state)\nthis:\n  GE.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "hence \"GE.satPB \\<xi> gPB\""], ["proof (prove)\nusing this:\n  GE.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. GE.satPB \\<xi> gPB", "by (rule GE.sat_\\<Phi>)"], ["proof (state)\nthis:\n  GE.satPB \\<xi> gPB\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "hence \"GE.satPB \\<xi> (gC ` \\<Phi>)\""], ["proof (prove)\nusing this:\n  GE.satPB \\<xi> gPB\n\ngoal (1 subgoal):\n 1. GE.satPB \\<xi> (gC ` \\<Phi>)", "unfolding gPB_def"], ["proof (prove)\nusing this:\n  GE.satPB \\<xi> (gC ` \\<Phi> \\<union> Fax \\<union> Wax)\n\ngoal (1 subgoal):\n 1. GE.satPB \\<xi> (gC ` \\<Phi>)", "by simp"], ["proof (state)\nthis:\n  GE.satPB \\<xi> (gC ` \\<Phi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "thus \"Ik.satPB \\<xi> \\<Phi>\""], ["proof (prove)\nusing this:\n  GE.satPB \\<xi> (gC ` \\<Phi>)\n\ngoal (1 subgoal):\n 1. Ik.satPB \\<xi> \\<Phi>", "using \\<xi>"], ["proof (prove)\nusing this:\n  GE.satPB \\<xi> (gC ` \\<Phi>)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. Ik.satPB \\<xi> \\<Phi>", "by simp"], ["proof (state)\nthis:\n  Ik.satPB \\<xi> \\<Phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma G_completeness: \"Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.MModel intT intF intP", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.SAT \\<Phi>", "using completeness"], ["proof (prove)\nusing this:\n  Ik.SAT \\<Phi>\n\ngoal (1 subgoal):\n 1. Ik.SAT \\<Phi>", "."], ["", "end"], ["", "(* context ProblemIkTpartG_GEModel *)\n\n(* Completeness theorem in sublocale form: Given a problem (with indicated\ntype partition) and a model for its guard-translated problem,\nwe obtain a model of the original problem: *)"], ["", "sublocale ProblemIkTpartG_GEModel < Ik? : Model\nwhere intT = intT and intF = intF and intP = intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.MModel intT intF intP", "using G_completeness"], ["proof (prove)\nusing this:\n  Ik.MModel intT intF intP\n\ngoal (1 subgoal):\n 1. Ik.MModel intT intF intP", "."], ["", "subsection\\<open>The result of the guard translation is an infiniteness-augmented problem\\<close>"], ["", "(* An observation similar to the corresponding one for tags applies here.  *)"], ["", "sublocale ProblemIkTpartG < GE? : Problem\nwhere wtFsym = GE_wtFsym and wtPsym = GE_wtPsym\nand arOf = GE_arOf and resOf = GE_resOf and parOf = GE_parOf\nand \\<Phi> = gPB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Problem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.wtPB gPB", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale ProblemIkTpartG < GE? : ProblemIk\nwhere wtFsym = GE_wtFsym and wtPsym = GE_wtPsym\nand arOf = GE_arOf and resOf = GE_resOf and parOf = GE_parOf\nand \\<Phi> = gPB"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIk GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB infTp", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "fix \\<sigma> eintT eintF eintP a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "assume \\<sigma>: \"infTp \\<sigma>\""], ["proof (state)\nthis:\n  infTp \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "assume M: \"Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB eintT eintF eintP\""], ["proof (state)\nthis:\n  GE.MModel eintT eintF eintP\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "let ?GE_intT = \"ProblemIkTpartG_GEModel.intT prot protFw eintT eintP\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "let ?GE_intF = \"ProblemIkTpartG_GEModel.intF eintF\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "let ?GE_intP = \"ProblemIkTpartG_GEModel.intP eintP\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "have 0: \"ProblemIkTpartG_GEModel wtFsym wtPsym arOf resOf parOf\n                                   \\<Phi> infTp prot protFw protCl eintT eintF eintP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkTpartG_GEModel wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot\n     protFw protCl eintT eintF eintP", "using M"], ["proof (prove)\nusing this:\n  GE.MModel eintT eintF eintP\n\ngoal (1 subgoal):\n 1. ProblemIkTpartG_GEModel wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot\n     protFw protCl eintT eintF eintP", "unfolding ProblemIkTpartG_GEModel_def"], ["proof (prove)\nusing this:\n  GE.MModel eintT eintF eintP\n\ngoal (1 subgoal):\n 1. ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot protFw\n     protCl \\<and>\n    GE.MModel eintT eintF eintP", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. GE.MModel eintT eintF eintP \\<Longrightarrow>\n    ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot protFw\n     protCl", ".."], ["proof (state)\nthis:\n  ProblemIkTpartG_GEModel wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot\n   protFw protCl eintT eintF eintP\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "hence MM: \"Ik.MModel ?GE_intT ?GE_intF ?GE_intP\""], ["proof (prove)\nusing this:\n  ProblemIkTpartG_GEModel wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot\n   protFw protCl eintT eintF eintP\n\ngoal (1 subgoal):\n 1. Ik.MModel (ProblemIkTpartG_GEModel.intT prot protFw eintT eintP)\n     (ProblemIkTpartG_GEModel.intF eintF)\n     (ProblemIkTpartG_GEModel.intP eintP)", "by (rule ProblemIkTpartG_GEModel.G_completeness)"], ["proof (state)\nthis:\n  Ik.MModel (ProblemIkTpartG_GEModel.intT prot protFw eintT eintP)\n   (ProblemIkTpartG_GEModel.intF eintF) (ProblemIkTpartG_GEModel.intP eintP)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "have \"infinite {a. ?GE_intT \\<sigma> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite\n     {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}", "using infTp[OF \\<sigma> MM]"], ["proof (prove)\nusing this:\n  infinite\n   {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n\ngoal (1 subgoal):\n 1. infinite\n     {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}", "."], ["proof (state)\nthis:\n  infinite\n   {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "moreover"], ["proof (state)\nthis:\n  infinite\n   {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "have \"{a. ?GE_intT \\<sigma> a} \\<subseteq> {a. eintT \\<sigma> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n    \\<subseteq> {a. eintT \\<sigma> a}", "using ProblemIkTpartG_GEModel.intT_def[OF 0]"], ["proof (prove)\nusing this:\n  ProblemIkTpartG_GEModel.intT prot protFw eintT eintP ?\\<sigma> ?a \\<equiv>\n  if unprot ?\\<sigma> then eintT ?\\<sigma> ?a\n  else eintT ?\\<sigma> ?a \\<and> eintP (Guard ?\\<sigma>) [?a]\n\ngoal (1 subgoal):\n 1. {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n    \\<subseteq> {a. eintT \\<sigma> a}", "by auto"], ["proof (state)\nthis:\n  {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n  \\<subseteq> {a. eintT \\<sigma> a}\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; GE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "ultimately"], ["proof (chain)\npicking this:\n  infinite\n   {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n  {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n  \\<subseteq> {a. eintT \\<sigma> a}", "show \"infinite {a. eintT \\<sigma> a}\""], ["proof (prove)\nusing this:\n  infinite\n   {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n  {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n  \\<subseteq> {a. eintT \\<sigma> a}\n\ngoal (1 subgoal):\n 1. infinite {a. eintT \\<sigma> a}", "using infinite_super"], ["proof (prove)\nusing this:\n  infinite\n   {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n  {a. ProblemIkTpartG_GEModel.intT prot protFw eintT eintP \\<sigma> a}\n  \\<subseteq> {a. eintT \\<sigma> a}\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. infinite {a. eintT \\<sigma> a}", "by blast"], ["proof (state)\nthis:\n  infinite {a. eintT \\<sigma> a}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The verification of the second monotonicity calculus criterion\nfor the guarded problem\\<close>"], ["", "context ProblemIkTpartG begin"], ["", "fun pol where\n\"pol _ (Oldp p) = Cext\"\n|\n\"pol _ (Guard \\<sigma>) = Fext\""], ["", "lemma pol_ct: \"pol \\<sigma>1 p = pol \\<sigma>2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pol \\<sigma>1 p = pol \\<sigma>2 p", "by(cases p, auto)"], ["", "definition \"grdOf c l x = grdLit x\""], ["", "end"], ["", "sublocale ProblemIkTpartG < GE?: ProblemIkPol\nwhere wtFsym = GE_wtFsym and wtPsym = GE_wtPsym\nand arOf = GE_arOf and resOf = GE_resOf and parOf = GE_parOf\nand \\<Phi> = gPB and pol = pol and grdOf = grdOf"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkPol GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB infTp", ".."], ["", "context ProblemIkTpartG begin"], ["", "lemma nv2_nv[simp]: \"GE.nv2T (gT T) = GE.nvT T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2T (gT T) = nvT T", "apply (induct T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. nv2T (gT (Var x)) = nvT (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. nv2T (gT a) = nvT a) Tl \\<Longrightarrow>\n       nv2T (gT (Fn f Tl)) = nvT (Fn f Tl)", "by auto"], ["", "lemma nv2L_nvL[simp]: \"GE.nv2L (gL l) = GE.nvL l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2L (gL l) = nvL l", "proof(cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. l = Pos x1 \\<Longrightarrow> nv2L (gL l) = nvL l\n 2. \\<And>x2. l = Neg x2 \\<Longrightarrow> nv2L (gL l) = nvL l", "case (Pos at)"], ["proof (state)\nthis:\n  l = Pos at\n\ngoal (2 subgoals):\n 1. \\<And>x1. l = Pos x1 \\<Longrightarrow> nv2L (gL l) = nvL l\n 2. \\<And>x2. l = Neg x2 \\<Longrightarrow> nv2L (gL l) = nvL l", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = Pos at\n\ngoal (1 subgoal):\n 1. nv2L (gL l) = nvL l", "by (cases at, simp_all)"], ["proof (state)\nthis:\n  nv2L (gL l) = nvL l\n\ngoal (1 subgoal):\n 1. \\<And>x2. l = Neg x2 \\<Longrightarrow> nv2L (gL l) = nvL l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2. l = Neg x2 \\<Longrightarrow> nv2L (gL l) = nvL l", "case (Neg at)"], ["proof (state)\nthis:\n  l = Neg at\n\ngoal (1 subgoal):\n 1. \\<And>x2. l = Neg x2 \\<Longrightarrow> nv2L (gL l) = nvL l", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = Neg at\n\ngoal (1 subgoal):\n 1. nv2L (gL l) = nvL l", "by (cases at, auto)"], ["proof (state)\nthis:\n  nv2L (gL l) = nvL l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nv2L:\nassumes \"l \\<in> set c\" and mc: \"GE.mcalc \\<sigma> c\"\nshows \"infTp \\<sigma> \\<or> (\\<forall> x \\<in> GE.nv2L (gL l). tpOfV x \\<noteq> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<or>\n    (\\<forall>x\\<in>nv2L (gL l). GE.tpOfV x \\<noteq> \\<sigma>)", "using assms mc nv2L_nvL"], ["proof (prove)\nusing this:\n  l \\<in> set c\n  \\<sigma> \\<turnstile> c\n  \\<sigma> \\<turnstile> c\n  nv2L (gL ?l) = nvL ?l\n\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<or>\n    (\\<forall>x\\<in>nv2L (gL l). GE.tpOfV x \\<noteq> \\<sigma>)", "unfolding GE.mcalc_iff GE.nvC_def"], ["proof (prove)\nusing this:\n  l \\<in> set c\n  infTp \\<sigma> \\<or>\n  (\\<forall>x\\<in>\\<Union> (set (map nvL c)). GE.tpOfV x \\<noteq> \\<sigma>)\n  infTp \\<sigma> \\<or>\n  (\\<forall>x\\<in>\\<Union> (set (map nvL c)). GE.tpOfV x \\<noteq> \\<sigma>)\n  nv2L (gL ?l) = nvL ?l\n\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<or>\n    (\\<forall>x\\<in>nv2L (gL l). GE.tpOfV x \\<noteq> \\<sigma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<in> set c;\n     infTp \\<sigma> \\<or>\n     (\\<forall>y\\<in>set c.\n         \\<forall>x\\<in>nvL y. GE.tpOfV x \\<noteq> \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> infTp \\<sigma> \\<or>\n                      (\\<forall>x\\<in>nvL l. GE.tpOfV x \\<noteq> \\<sigma>)", "using nv2L_nvL[of l]"], ["proof (prove)\nusing this:\n  nv2L (gL l) = nvL l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<in> set c;\n     infTp \\<sigma> \\<or>\n     (\\<forall>y\\<in>set c.\n         \\<forall>x\\<in>nvL y. GE.tpOfV x \\<noteq> \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> infTp \\<sigma> \\<or>\n                      (\\<forall>x\\<in>nvL l. GE.tpOfV x \\<noteq> \\<sigma>)", "by (metis empty_subsetI equalityI nv2L_nvL)"], ["", "(* The guarding literals are guarded: *)"], ["", "lemma isGuard_grdLit[simp]: \"GE.isGuard x (grdLit x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isGuard x (grdLit x)", "unfolding grdLit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. isGuard x (Neg (Pr (Guard (GE.tpOfV x)) [Var x]))", "by auto"], ["", "lemma nv2L_grdLit[simp]: \"GE.nv2L (grdLit x) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2L (grdLit x) = {}", "unfolding grdLit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2L (Neg (Pr (Guard (GE.tpOfV x)) [Var x])) = {}", "by auto"], ["", "lemma mcalc_mcalc2: \"GE.mcalc \\<sigma> c \\<Longrightarrow> GE.mcalc2 \\<sigma> (gC c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<turnstile> c \\<Longrightarrow> mcalc2 \\<sigma> (gC c)", "using nv2L"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<in> set ?c; ?\\<sigma> \\<turnstile> ?c\\<rbrakk>\n  \\<Longrightarrow> infTp ?\\<sigma> \\<or>\n                    (\\<forall>x\\<in>nv2L (gL ?l).\n                        GE.tpOfV x \\<noteq> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<turnstile> c \\<Longrightarrow> mcalc2 \\<sigma> (gC c)", "unfolding GE.mcalc2_iff gC_def glitOfC_def grdOf_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<in> set ?c; ?\\<sigma> \\<turnstile> ?c\\<rbrakk>\n  \\<Longrightarrow> infTp ?\\<sigma> \\<or>\n                    (\\<forall>x\\<in>nv2L (gL ?l).\n                        GE.tpOfV x \\<noteq> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<turnstile> c \\<Longrightarrow>\n    infTp \\<sigma> \\<or>\n    (\\<forall>l x.\n        l \\<in> set (map gL c @\n                     list (\\<Union> (set (map glitOfL c)))) \\<and>\n        x \\<in> nv2L l \\<and> GE.tpOfV x = \\<sigma> \\<longrightarrow>\n        isGuard x (grdLit x))", "by auto"], ["", "lemma nv2L_wax[simp]: \"l' \\<in> set (wax \\<sigma>) \\<Longrightarrow> GE.nv2L l' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<in> set (wax \\<sigma>) \\<Longrightarrow> nv2L l' = {}", "unfolding wax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<in> set [Pos (Pr (Guard \\<sigma>)\n                        [Fn (Wit \\<sigma>) []])] \\<Longrightarrow>\n    nv2L l' = {}", "by auto"], ["", "lemma nv2L_Wax:\nassumes \"c' \\<in> Wax\" and \"l' \\<in> set c'\"\nshows \"GE.nv2L l' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2L l' = {}", "using assms"], ["proof (prove)\nusing this:\n  c' \\<in> Wax\n  l' \\<in> set c'\n\ngoal (1 subgoal):\n 1. nv2L l' = {}", "unfolding Wax_def"], ["proof (prove)\nusing this:\n  c' \\<in> {wax \\<sigma> |\\<sigma>.\n            \\<not> unprot \\<sigma> \\<and>\n            (\\<not> isRes \\<sigma> \\<or> protCl \\<sigma>)}\n  l' \\<in> set c'\n\ngoal (1 subgoal):\n 1. nv2L l' = {}", "by auto"], ["", "lemma nv2L_cOfFax[simp]: \"GE.nv2L (Pos (cOfFax \\<sigma>)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2L (Pos (cOfFax \\<sigma>)) = {}", "unfolding cOfFax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2L\n     (Pos (Pr (Guard (resOf \\<sigma>))\n            [Fn (Oldf \\<sigma>) (GE.getTvars (arOf \\<sigma>))])) =\n    {}", "by auto"], ["", "lemma nv2L_hOfFax[simp]:\nassumes \"at \\<in> set (hOfFax \\<sigma>)\"\nshows \"GE.nv2L (Neg at) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2L (Neg at) = {}", "using assms"], ["proof (prove)\nusing this:\n  at \\<in> set (hOfFax \\<sigma>)\n\ngoal (1 subgoal):\n 1. nv2L (Neg at) = {}", "unfolding hOfFax_def"], ["proof (prove)\nusing this:\n  at \\<in> set (map2 (Pr \\<circ> Guard) (arOf \\<sigma>)\n                 (map singl (GE.getTvars (arOf \\<sigma>))))\n\ngoal (1 subgoal):\n 1. nv2L (Neg at) = {}", "by auto"], ["", "lemma nv2L_fax[simp]: \"l \\<in> set (fax \\<sigma>) \\<Longrightarrow> GE.nv2L l = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> set (fax \\<sigma>) \\<Longrightarrow> nv2L l = {}", "unfolding fax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> set [Pos (cOfFax \\<sigma>)] \\<Longrightarrow> nv2L l = {}", "by auto"], ["", "lemma nv2L_faxCD[simp]: \"l \\<in> set (faxCD \\<sigma>) \\<Longrightarrow> GE.nv2L l = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> set (faxCD \\<sigma>) \\<Longrightarrow> nv2L l = {}", "unfolding faxCD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> set (map Neg (hOfFax \\<sigma>) @ fax \\<sigma>) \\<Longrightarrow>\n    nv2L l = {}", "by auto"], ["", "lemma nv2L_Fax:\nassumes \"c' \\<in> Fax\" and \"l' \\<in> set c'\"\nshows \"GE.nv2L l' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2L l' = {}", "using assms"], ["proof (prove)\nusing this:\n  c' \\<in> Fax\n  l' \\<in> set c'\n\ngoal (1 subgoal):\n 1. nv2L l' = {}", "unfolding Fax_def"], ["proof (prove)\nusing this:\n  c' \\<in> {fax f |f.\n            wtFsym f \\<and>\n            \\<not> unprot (resOf f) \\<and> \\<not> protCl (resOf f)} \\<union>\n           {faxCD f |f. wtFsym f \\<and> protCl (resOf f)}\n  l' \\<in> set c'\n\ngoal (1 subgoal):\n 1. nv2L l' = {}", "by auto"], ["", "lemma grdOf:\nassumes c': \"c' \\<in> gPB\" and l': \"l' \\<in> set c'\"\nand x: \"x \\<in> GE.nv2L l'\" and i: \"\\<not> infTp (tpOfV x)\"\nshows \"grdOf c' l' x \\<in> set c' \\<and> GE.isGuard x (grdOf c' l' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "proof(cases \"c' \\<in> Fax \\<union> Wax\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c' \\<in> Fax \\<union> Wax \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n 2. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "case True"], ["proof (state)\nthis:\n  c' \\<in> Fax \\<union> Wax\n\ngoal (2 subgoals):\n 1. c' \\<in> Fax \\<union> Wax \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n 2. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c' \\<in> Fax \\<union> Wax\n\ngoal (1 subgoal):\n 1. grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "using x l' nv2L_Wax nv2L_Fax"], ["proof (prove)\nusing this:\n  c' \\<in> Fax \\<union> Wax\n  x \\<in> nv2L l'\n  l' \\<in> set c'\n  \\<lbrakk>?c' \\<in> Wax; ?l' \\<in> set ?c'\\<rbrakk>\n  \\<Longrightarrow> nv2L ?l' = {}\n  \\<lbrakk>?c' \\<in> Fax; ?l' \\<in> set ?c'\\<rbrakk>\n  \\<Longrightarrow> nv2L ?l' = {}\n\ngoal (1 subgoal):\n 1. grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "by force"], ["proof (state)\nthis:\n  grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n\ngoal (1 subgoal):\n 1. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "case False"], ["proof (state)\nthis:\n  c' \\<notin> Fax \\<union> Wax\n\ngoal (1 subgoal):\n 1. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "then"], ["proof (chain)\npicking this:\n  c' \\<notin> Fax \\<union> Wax", "obtain c where c': \"c' = gC c\" and c: \"c \\<in> \\<Phi>\""], ["proof (prove)\nusing this:\n  c' \\<notin> Fax \\<union> Wax\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c' = gC c; c \\<in> \\<Phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using c'"], ["proof (prove)\nusing this:\n  c' \\<notin> Fax \\<union> Wax\n  c' \\<in> gPB\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c' = gC c; c \\<in> \\<Phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding gPB_def"], ["proof (prove)\nusing this:\n  c' \\<notin> Fax \\<union> Wax\n  c' \\<in> gC ` \\<Phi> \\<union> Fax \\<union> Wax\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c' = gC c; c \\<in> \\<Phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c' = gC c\n  c \\<in> \\<Phi>\n\ngoal (1 subgoal):\n 1. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "proof(cases \"l' \\<in> glitOfC c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l' \\<in> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n 2. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "case True"], ["proof (state)\nthis:\n  l' \\<in> glitOfC c\n\ngoal (2 subgoals):\n 1. l' \\<in> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n 2. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "then"], ["proof (chain)\npicking this:\n  l' \\<in> glitOfC c", "obtain l where l: \"l \\<in> set c\" and l': \"l' \\<in> glitOfL l\""], ["proof (prove)\nusing this:\n  l' \\<in> glitOfC c\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> set c; l' \\<in> glitOfL l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding glitOfC_def"], ["proof (prove)\nusing this:\n  l' \\<in> \\<Union> (set (map glitOfL c))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> set c; l' \\<in> glitOfL l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l \\<in> set c\n  l' \\<in> glitOfL l\n\ngoal (2 subgoals):\n 1. l' \\<in> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n 2. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "then"], ["proof (chain)\npicking this:\n  l \\<in> set c\n  l' \\<in> glitOfL l", "obtain x1 where \"l' = grdLit x1\""], ["proof (prove)\nusing this:\n  l \\<in> set c\n  l' \\<in> glitOfL l\n\ngoal (1 subgoal):\n 1. (\\<And>x1. l' = grdLit x1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using l'"], ["proof (prove)\nusing this:\n  l \\<in> set c\n  l' \\<in> glitOfL l\n  l' \\<in> glitOfL l\n\ngoal (1 subgoal):\n 1. (\\<And>x1. l' = grdLit x1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l rule: lit.exhaust) auto"], ["proof (state)\nthis:\n  l' = grdLit x1\n\ngoal (2 subgoals):\n 1. l' \\<in> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n 2. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "hence \"GE.nv2L l' = {}\""], ["proof (prove)\nusing this:\n  l' = grdLit x1\n\ngoal (1 subgoal):\n 1. nv2L l' = {}", "by simp"], ["proof (state)\nthis:\n  nv2L l' = {}\n\ngoal (2 subgoals):\n 1. l' \\<in> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n 2. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  nv2L l' = {}\n\ngoal (1 subgoal):\n 1. grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "using x"], ["proof (prove)\nusing this:\n  nv2L l' = {}\n  x \\<in> nv2L l'\n\ngoal (1 subgoal):\n 1. grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "by simp"], ["proof (state)\nthis:\n  grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "let ?\\<sigma> = \"tpOfV x\""], ["proof (state)\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "case False"], ["proof (state)\nthis:\n  l' \\<notin> glitOfC c\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "then"], ["proof (chain)\npicking this:\n  l' \\<notin> glitOfC c", "obtain l where l: \"l \\<in> set c\" and l': \"l' = gL l\""], ["proof (prove)\nusing this:\n  l' \\<notin> glitOfC c\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> set c; l' = gL l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using l'"], ["proof (prove)\nusing this:\n  l' \\<notin> glitOfC c\n  l' \\<in> set c'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> set c; l' = gL l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding c' gC_def"], ["proof (prove)\nusing this:\n  l' \\<notin> glitOfC c\n  l' \\<in> set (map gL c @ list (glitOfC c))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> set c; l' = gL l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l \\<in> set c\n  l' = gL l\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "hence x: \"x \\<in> GE.nvL l\""], ["proof (prove)\nusing this:\n  l \\<in> set c\n  l' = gL l\n\ngoal (1 subgoal):\n 1. x \\<in> nvL l", "using x"], ["proof (prove)\nusing this:\n  l \\<in> set c\n  l' = gL l\n  x \\<in> nv2L l'\n\ngoal (1 subgoal):\n 1. x \\<in> nvL l", "by simp"], ["proof (state)\nthis:\n  x \\<in> nvL l\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "hence \"x \\<in> GE.nvC c\""], ["proof (prove)\nusing this:\n  x \\<in> nvL l\n\ngoal (1 subgoal):\n 1. x \\<in> nvC c", "using l"], ["proof (prove)\nusing this:\n  x \\<in> nvL l\n  l \\<in> set c\n\ngoal (1 subgoal):\n 1. x \\<in> nvC c", "unfolding GE.nvC_def"], ["proof (prove)\nusing this:\n  x \\<in> nvL l\n  l \\<in> set c\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (set (map nvL c))", "by auto"], ["proof (state)\nthis:\n  x \\<in> nvC c\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "hence \"\\<not> GE.mcalc ?\\<sigma> c\""], ["proof (prove)\nusing this:\n  x \\<in> nvC c\n\ngoal (1 subgoal):\n 1. \\<not> GE.tpOfV x \\<turnstile> c", "using i"], ["proof (prove)\nusing this:\n  x \\<in> nvC c\n  \\<not> infTp (GE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<not> GE.tpOfV x \\<turnstile> c", "unfolding GE.mcalc_iff"], ["proof (prove)\nusing this:\n  x \\<in> nvC c\n  \\<not> infTp (GE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<not> (infTp (GE.tpOfV x) \\<or>\n            (\\<forall>xa\\<in>nvC c. GE.tpOfV xa \\<noteq> GE.tpOfV x))", "by auto"], ["proof (state)\nthis:\n  \\<not> GE.tpOfV x \\<turnstile> c\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "hence tp: \"prot ?\\<sigma> \\<or> protFw ?\\<sigma>\""], ["proof (prove)\nusing this:\n  \\<not> GE.tpOfV x \\<turnstile> c\n\ngoal (1 subgoal):\n 1. prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)", "using unprot_mcalc[OF _ c]"], ["proof (prove)\nusing this:\n  \\<not> GE.tpOfV x \\<turnstile> c\n  unprot ?\\<sigma> \\<Longrightarrow> ?\\<sigma> \\<turnstile> c\n\ngoal (1 subgoal):\n 1. prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)", "unfolding unprot_def"], ["proof (prove)\nusing this:\n  \\<not> GE.tpOfV x \\<turnstile> c\n  \\<not> prot ?\\<sigma> \\<and> \\<not> protFw ?\\<sigma> \\<Longrightarrow>\n  ?\\<sigma> \\<turnstile> c\n\ngoal (1 subgoal):\n 1. prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)", "by auto"], ["proof (state)\nthis:\n  prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "moreover"], ["proof (state)\nthis:\n  prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "obtain at where l_at: \"l = Pos at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>at. l = Pos at \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using x"], ["proof (prove)\nusing this:\n  x \\<in> nvL l\n\ngoal (1 subgoal):\n 1. (\\<And>at. l = Pos at \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(cases l, auto)"], ["proof (state)\nthis:\n  l = Pos at\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "moreover"], ["proof (state)\nthis:\n  l = Pos at\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "have \"x \\<in> varsA at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> varsA at", "using x"], ["proof (prove)\nusing this:\n  x \\<in> nvL l\n\ngoal (1 subgoal):\n 1. x \\<in> varsA at", "unfolding l_at"], ["proof (prove)\nusing this:\n  x \\<in> nvL (Pos at)\n\ngoal (1 subgoal):\n 1. x \\<in> varsA at", "by auto"], ["proof (state)\nthis:\n  x \\<in> varsA at\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "ultimately"], ["proof (chain)\npicking this:\n  prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)\n  l = Pos at\n  x \\<in> varsA at", "have \"grdLit x \\<in> glitOfL l\""], ["proof (prove)\nusing this:\n  prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)\n  l = Pos at\n  x \\<in> varsA at\n\ngoal (1 subgoal):\n 1. grdLit x \\<in> glitOfL l", "using x"], ["proof (prove)\nusing this:\n  prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)\n  l = Pos at\n  x \\<in> varsA at\n  x \\<in> nvL l\n\ngoal (1 subgoal):\n 1. grdLit x \\<in> glitOfL l", "unfolding l_at"], ["proof (prove)\nusing this:\n  prot (GE.tpOfV x) \\<or> protFw (GE.tpOfV x)\n  Pos at = Pos at\n  x \\<in> varsA at\n  x \\<in> nvL (Pos at)\n\ngoal (1 subgoal):\n 1. grdLit x \\<in> glitOfL (Pos at)", "by force"], ["proof (state)\nthis:\n  grdLit x \\<in> glitOfL l\n\ngoal (1 subgoal):\n 1. l' \\<notin> glitOfC c \\<Longrightarrow>\n    grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  grdLit x \\<in> glitOfL l\n\ngoal (1 subgoal):\n 1. grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "using l x"], ["proof (prove)\nusing this:\n  grdLit x \\<in> glitOfL l\n  l \\<in> set c\n  x \\<in> nvL l\n\ngoal (1 subgoal):\n 1. grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)", "unfolding grdOf_def c' gC_def glitOfC_def"], ["proof (prove)\nusing this:\n  grdLit x \\<in> glitOfL l\n  l \\<in> set c\n  x \\<in> nvL l\n\ngoal (1 subgoal):\n 1. grdLit x\n    \\<in> set (map gL c @ list (\\<Union> (set (map glitOfL c)))) \\<and>\n    isGuard x (grdLit x)", "by auto"], ["proof (state)\nthis:\n  grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  grdOf c' l' x \\<in> set c' \\<and> isGuard x (grdOf c' l' x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mcalc2:\nassumes c': \"c' \\<in> gPB\"\nshows \"GE.mcalc2 \\<sigma> c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcalc2 \\<sigma> c'", "proof(cases \"c' \\<in> Fax \\<union> Wax\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c' \\<in> Fax \\<union> Wax \\<Longrightarrow> mcalc2 \\<sigma> c'\n 2. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow> mcalc2 \\<sigma> c'", "case True"], ["proof (state)\nthis:\n  c' \\<in> Fax \\<union> Wax\n\ngoal (2 subgoals):\n 1. c' \\<in> Fax \\<union> Wax \\<Longrightarrow> mcalc2 \\<sigma> c'\n 2. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow> mcalc2 \\<sigma> c'", "thus ?thesis"], ["proof (prove)\nusing this:\n  c' \\<in> Fax \\<union> Wax\n\ngoal (1 subgoal):\n 1. mcalc2 \\<sigma> c'", "using nv2L_Wax nv2L_Fax"], ["proof (prove)\nusing this:\n  c' \\<in> Fax \\<union> Wax\n  \\<lbrakk>?c' \\<in> Wax; ?l' \\<in> set ?c'\\<rbrakk>\n  \\<Longrightarrow> nv2L ?l' = {}\n  \\<lbrakk>?c' \\<in> Fax; ?l' \\<in> set ?c'\\<rbrakk>\n  \\<Longrightarrow> nv2L ?l' = {}\n\ngoal (1 subgoal):\n 1. mcalc2 \\<sigma> c'", "unfolding GE.mcalc2_iff"], ["proof (prove)\nusing this:\n  c' \\<in> Fax \\<union> Wax\n  \\<lbrakk>?c' \\<in> Wax; ?l' \\<in> set ?c'\\<rbrakk>\n  \\<Longrightarrow> nv2L ?l' = {}\n  \\<lbrakk>?c' \\<in> Fax; ?l' \\<in> set ?c'\\<rbrakk>\n  \\<Longrightarrow> nv2L ?l' = {}\n\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<or>\n    (\\<forall>l x.\n        l \\<in> set c' \\<and>\n        x \\<in> nv2L l \\<and> GE.tpOfV x = \\<sigma> \\<longrightarrow>\n        isGuard x (grdOf c' l x))", "by fastforce"], ["proof (state)\nthis:\n  mcalc2 \\<sigma> c'\n\ngoal (1 subgoal):\n 1. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow> mcalc2 \\<sigma> c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow> mcalc2 \\<sigma> c'", "case False"], ["proof (state)\nthis:\n  c' \\<notin> Fax \\<union> Wax\n\ngoal (1 subgoal):\n 1. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow> mcalc2 \\<sigma> c'", "hence c': \"c' \\<in> gPB\""], ["proof (prove)\nusing this:\n  c' \\<notin> Fax \\<union> Wax\n\ngoal (1 subgoal):\n 1. c' \\<in> gPB", "using c'"], ["proof (prove)\nusing this:\n  c' \\<notin> Fax \\<union> Wax\n  c' \\<in> gPB\n\ngoal (1 subgoal):\n 1. c' \\<in> gPB", "unfolding gPB_def"], ["proof (prove)\nusing this:\n  c' \\<notin> Fax \\<union> Wax\n  c' \\<in> gC ` \\<Phi> \\<union> Fax \\<union> Wax\n\ngoal (1 subgoal):\n 1. c' \\<in> gC ` \\<Phi> \\<union> Fax \\<union> Wax", "by auto"], ["proof (state)\nthis:\n  c' \\<in> gPB\n\ngoal (1 subgoal):\n 1. c' \\<notin> Fax \\<union> Wax \\<Longrightarrow> mcalc2 \\<sigma> c'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mcalc2 \\<sigma> c'", "unfolding GE.mcalc2_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<or>\n    (\\<forall>l x.\n        l \\<in> set c' \\<and>\n        x \\<in> nv2L l \\<and> GE.tpOfV x = \\<sigma> \\<longrightarrow>\n        isGuard x (grdOf c' l x))", "using grdOf[OF c']"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l' \\<in> set c'; ?x \\<in> nv2L ?l';\n   \\<not> infTp (GE.tpOfV ?x)\\<rbrakk>\n  \\<Longrightarrow> grdOf c' ?l' ?x \\<in> set c' \\<and>\n                    isGuard ?x (grdOf c' ?l' ?x)\n\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<or>\n    (\\<forall>l x.\n        l \\<in> set c' \\<and>\n        x \\<in> nv2L l \\<and> GE.tpOfV x = \\<sigma> \\<longrightarrow>\n        isGuard x (grdOf c' l x))", "by auto"], ["proof (state)\nthis:\n  mcalc2 \\<sigma> c'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ProblemIkTpartG *)"], ["", "sublocale ProblemIkTpartG < GE?: ProblemIkPolMcalc2C\nwhere wtFsym = GE_wtFsym and wtPsym = GE_wtPsym\nand arOf = GE_arOf and resOf = GE_resOf and parOf = GE_parOf\nand \\<Phi> = gPB and pol = pol and grdOf = grdOf"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkPolMcalc2C GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB\n     infTp pol grdOf", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c l x.\n       \\<lbrakk>c \\<in> gPB; l \\<in> set c; x \\<in> nv2L l;\n        \\<not> infTp (GE.tpOfV x)\\<rbrakk>\n       \\<Longrightarrow> grdOf c l x \\<in> set c\n 2. \\<And>\\<sigma> c. c \\<in> gPB \\<Longrightarrow> mcalc2 \\<sigma> c\n 3. \\<And>\\<sigma>1 P \\<sigma>2. pol \\<sigma>1 P = pol \\<sigma>2 P", "using grdOf mcalc2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c' \\<in> gPB; ?l' \\<in> set ?c'; ?x \\<in> nv2L ?l';\n   \\<not> infTp (GE.tpOfV ?x)\\<rbrakk>\n  \\<Longrightarrow> grdOf ?c' ?l' ?x \\<in> set ?c' \\<and>\n                    isGuard ?x (grdOf ?c' ?l' ?x)\n  ?c' \\<in> gPB \\<Longrightarrow> mcalc2 ?\\<sigma> ?c'\n\ngoal (3 subgoals):\n 1. \\<And>c l x.\n       \\<lbrakk>c \\<in> gPB; l \\<in> set c; x \\<in> nv2L l;\n        \\<not> infTp (GE.tpOfV x)\\<rbrakk>\n       \\<Longrightarrow> grdOf c l x \\<in> set c\n 2. \\<And>\\<sigma> c. c \\<in> gPB \\<Longrightarrow> mcalc2 \\<sigma> c\n 3. \\<And>\\<sigma>1 P \\<sigma>2. pol \\<sigma>1 P = pol \\<sigma>2 P", "apply (auto simp: pol_ct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* We already know that ProblemIkMcalc < MonotProblem, so by transitivity we obtain\nthe following main theorem, stating that the guard translation yields a monotonic\nproblem *)"], ["", "context ProblemIkTpartG begin"], ["", "theorem G_monotonic:\n\"MonotProblem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MonotProblem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB", ".."], ["", "end"], ["", "(* context ProblemIkTpartG *)\n\n\n(* Also in sublocale form: *)"], ["", "sublocale ProblemIkTpartG < GE?: MonotProblem\nwhere wtFsym = GE_wtFsym and wtPsym = GE_wtPsym\nand arOf = GE_arOf and resOf = GE_resOf and parOf = GE_parOf\nand \\<Phi> = gPB"], ["proof (prove)\ngoal (1 subgoal):\n 1. MonotProblem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB", "using G_monotonic"], ["proof (prove)\nusing this:\n  MonotProblem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB\n\ngoal (1 subgoal):\n 1. MonotProblem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf gPB", "."], ["", "end"]]}