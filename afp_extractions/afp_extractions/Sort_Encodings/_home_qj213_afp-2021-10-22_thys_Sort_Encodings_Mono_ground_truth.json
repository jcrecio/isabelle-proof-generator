{"file_name": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings/Mono.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings", "problem_names": ["lemma full2[simp]: \"intT \\<sigma> d\"", "lemma full_True: \"intT = (\\<lambda> \\<sigma> D. True)\"", "lemma infTp_infinite[simp]: \"infTp \\<sigma> \\<Longrightarrow> infinite {a. intT \\<sigma> a}\"", "lemma MI_pred:\nassumes \"MModel intT intF intP\"\nshows \"\\<exists> K. MI_pred K\"", "lemma MI_pred_MI:\nassumes \"MModel intT intF intP\"\nshows \"MI_pred MI\"", "lemma InfModel_intTI_intFI_intPI:\nassumes \"MModel intT intF intP\"\nshows \"IInfModel intTI intFI intPI\"", "lemma InfModelI: \"IInfModel intTI intFI intPI\"", "lemma intTF: \"intTF \\<sigma> a\"", "lemma ex_toFull: \"\\<exists> F. bij_betw F {a::univ. intT \\<sigma> a} (UNIV::univ set)\"", "lemma toFull: \"bij_betw (toFull \\<sigma>) {a. intT \\<sigma> a} UNIV\"", "lemma toFull_fromFull[simp]: \"toFull \\<sigma> (fromFull \\<sigma> a) = a\"", "lemma fromFull_toFull[simp]: \"intT \\<sigma> a \\<Longrightarrow> fromFull \\<sigma> (toFull \\<sigma> a) = a\"", "lemma fromFull_inj[simp]: \"fromFull \\<sigma> a = fromFull \\<sigma> b \\<longleftrightarrow> a = b\"", "lemma toFull_inj[simp]:\nassumes \"intT \\<sigma> a\" and \"intT \\<sigma> b\"\nshows \"toFull \\<sigma> a = toFull \\<sigma> b \\<longleftrightarrow> a = b\"", "lemma fromFull[simp]: \"intT \\<sigma> (fromFull \\<sigma> a)\"", "lemma toFull_iff_fromFull:\nassumes \"intT \\<sigma> a\"\nshows \"toFull \\<sigma> a = b \\<longleftrightarrow> a = fromFull \\<sigma> b\"", "lemma Tstruct: \"Tstruct intTF\"", "lemma FullStruct: \"FullStruct wtFsym wtPsym arOf resOf intTF intFF intPF\"", "lemma kE[simp]: \"kE \\<xi> x = fromFull (tpOfV x) (\\<xi> x)\"", "lemma wtE[simp]: \"F.wtE \\<xi>\"", "lemma kE_wtE[simp]: \"I.wtE (kE \\<xi>)\"", "lemma kE_int_toFull:\nassumes \\<xi>: \"I.wtE (kE \\<xi>)\" and T: \"wt T\"\nshows \"toFull (tpOf T) (I.int (kE \\<xi>) T) = F.int \\<xi> T\"", "lemma kE_int[simp]:\nassumes \\<xi>: \"I.wtE (kE \\<xi>)\" and T: \"wt T\"\nshows \"I.int (kE \\<xi>) T = fromFull (tpOf T) (F.int \\<xi> T)\"", "lemma map_kE_int[simp]:\n  assumes \\<xi>: \"I.wtE (kE \\<xi>)\" and T: \"list_all wt Tl\"\n  shows \"map (I.int (kE \\<xi>)) Tl = map2 fromFull (map tpOf Tl) (map (F.int \\<xi>) Tl)\"", "lemma kE_satA[simp]:\nassumes at: \"wtA at\" and \\<xi>: \"I.wtE (kE \\<xi>)\"\nshows \"I.satA (kE \\<xi>) at \\<longleftrightarrow> F.satA \\<xi> at\"", "lemma kE_satL[simp]:\nassumes l: \"wtL l\" and \\<xi>: \"I.wtE (kE \\<xi>)\"\nshows \"I.satL (kE \\<xi>) l \\<longleftrightarrow> F.satL \\<xi> l\"", "lemma kE_satC[simp]:\nassumes c: \"wtC c\" and \\<xi>: \"I.wtE (kE \\<xi>)\"\nshows \"I.satC (kE \\<xi>) c \\<longleftrightarrow> F.satC \\<xi> c\"", "lemma kE_satPB:\nassumes \\<xi>: \"I.wtE (kE \\<xi>)\"  shows \"F.satPB \\<xi> \\<Phi>\"", "lemma F_SAT: \"F.SAT \\<Phi>\"", "lemma FullModel: \"FullModel wtFsym wtPsym arOf resOf parOf \\<Phi> intTF intFF intPF\"", "theorem FullModel_intTF_intFF_intPF:\nassumes \"MModel intT intF intP\"\nshows \"FFullModel intTF intFF intPF\""], "translations": [["", "lemma full2[simp]: \"intT \\<sigma> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> d", "using full"], ["proof (prove)\nusing this:\n  full ?\\<sigma>\n\ngoal (1 subgoal):\n 1. intT \\<sigma> d", "unfolding full_def"], ["proof (prove)\nusing this:\n  \\<forall>d. intT ?\\<sigma> d\n\ngoal (1 subgoal):\n 1. intT \\<sigma> d", "by simp"], ["", "lemma full_True: \"intT = (\\<lambda> \\<sigma> D. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT = (\\<lambda>\\<sigma> D. True)", "apply(intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> D. intT \\<sigma> D = True", "by auto"], ["", "end"], ["", "locale FullModel =\nF? : Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP +\nF? : FullStruct wtFsym wtPsym arOf resOf parOf intT intF intP\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf and parOf and \\<Phi> and intT and intF and intP"], ["", "text\\<open>An infinite structure is one with all carriers infinite:\\<close>"], ["", "locale InfStruct = I? : Struct +\nassumes inf: \"infinite {a. intT \\<sigma> a}\""], ["", "locale InfModel =\nI? : Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP +\nI? : InfStruct wtFsym wtPsym arOf resOf parOf intT intF intP\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf and parOf and \\<Phi> and intT and intF and intP"], ["", "context Problem begin"], ["", "abbreviation \"SStruct \\<equiv> Struct wtFsym wtPsym arOf resOf\""], ["", "abbreviation \"FFullStruct \\<equiv> FullStruct wtFsym wtPsym arOf resOf\""], ["", "abbreviation \"IInfStruct \\<equiv> InfStruct wtFsym wtPsym arOf resOf\""], ["", "abbreviation \"MModel \\<equiv> Model wtFsym wtPsym arOf resOf parOf \\<Phi>\""], ["", "abbreviation \"FFullModel \\<equiv> FullModel wtFsym wtPsym arOf resOf parOf \\<Phi>\""], ["", "abbreviation \"IInfModel \\<equiv> InfModel wtFsym wtPsym arOf resOf parOf \\<Phi>\""], ["", "end"], ["", "text\\<open>Problem that deduces some infiniteness constraints:\\<close>"], ["", "locale ProblemIk = Ik? : Problem wtFsym wtPsym arOf resOf parOf \\<Phi>\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf and parOf and \\<Phi>\n+\nfixes infTp :: \"'tp \\<Rightarrow> bool\"\n(* infTp assumes that \\<Phi> implies infiniteness on the infTp-marked types,\ni.e., any model of \\<Phi> is infinite on these types: *)\nassumes infTp:\n\"\\<And> \\<sigma> intT intF intP (a::univ). \\<lbrakk>infTp \\<sigma>; MModel intT intF intP\\<rbrakk> \\<Longrightarrow> infinite {a. intT \\<sigma> a}\""], ["", "locale ModelIk =\nIk? : ProblemIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp +\nIk? : Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf and parOf and \\<Phi> and infTp and intT and intF and intP\nbegin"], ["", "lemma infTp_infinite[simp]: \"infTp \\<sigma> \\<Longrightarrow> infinite {a. intT \\<sigma> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "apply(rule ProblemIk.infTp[of wtFsym wtPsym arOf resOf parOf \\<Phi> infTp])"], ["proof (prove)\ngoal (3 subgoals):\n 1. infTp \\<sigma> \\<Longrightarrow>\n    ProblemIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp\n 2. infTp \\<sigma> \\<Longrightarrow> infTp \\<sigma>\n 3. infTp \\<sigma> \\<Longrightarrow> MModel intT ?intF ?intP", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<Longrightarrow> infTp \\<sigma>", "by simp"], ["", "end"], ["", "subsection\\<open>Monotonicity\\<close>"], ["", "context Problem begin"], ["", "(* Monotonicity: *)"], ["", "definition\n\"monot \\<equiv>\n (\\<exists> intT intF intP. MModel intT intF intP)\n \\<longrightarrow>\n (\\<exists> intTI intFI intPI. IInfModel intTI intFI intPI)\""], ["", "end"], ["", "locale MonotProblem = Problem +\nassumes monot: monot"], ["", "locale MonotProblemIk =\nMonotProblem wtFsym wtPsym arOf resOf parOf \\<Phi> +\nProblemIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\" and resOf and parOf and \\<Phi> and infTp"], ["", "context MonotProblem\nbegin"], ["", "definition \"MI_pred K \\<equiv> IInfModel (fst3 K) (snd3 K) (trd3 K)\""], ["", "definition \"MI \\<equiv> SOME K. MI_pred K\""], ["", "lemma MI_pred:\nassumes \"MModel intT intF intP\"\nshows \"\\<exists> K. MI_pred K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex MI_pred", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex MI_pred", "obtain T F R where \"MI_pred (T,F,R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T F R.\n        MI_pred (T, F, R) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using monot assms"], ["proof (prove)\nusing this:\n  monot\n  MModel intT intF intP\n\ngoal (1 subgoal):\n 1. (\\<And>T F R.\n        MI_pred (T, F, R) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding monot_def MI_pred_def"], ["proof (prove)\nusing this:\n  (\\<exists>intT intF intP. MModel intT intF intP) \\<longrightarrow>\n  (\\<exists>intTI intFI intPI. IInfModel intTI intFI intPI)\n  MModel intT intF intP\n\ngoal (1 subgoal):\n 1. (\\<And>T F R.\n        IInfModel (fst3 (T, F, R)) (snd3 (T, F, R))\n         (trd3 (T, F, R)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  MI_pred (T, F, R)\n\ngoal (1 subgoal):\n 1. Ex MI_pred", "thus ?thesis"], ["proof (prove)\nusing this:\n  MI_pred (T, F, R)\n\ngoal (1 subgoal):\n 1. Ex MI_pred", "by blast"], ["proof (state)\nthis:\n  Ex MI_pred\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MI_pred_MI:\nassumes \"MModel intT intF intP\"\nshows \"MI_pred MI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MI_pred MI", "using MI_pred[OF assms]"], ["proof (prove)\nusing this:\n  Ex MI_pred\n\ngoal (1 subgoal):\n 1. MI_pred MI", "unfolding MI_def"], ["proof (prove)\nusing this:\n  Ex MI_pred\n\ngoal (1 subgoal):\n 1. MI_pred (Eps MI_pred)", "by (rule someI_ex)"], ["", "definition \"intTI \\<equiv> fst3 MI\""], ["", "definition \"intFI \\<equiv> snd3 MI\""], ["", "definition \"intPI \\<equiv> trd3 MI\""], ["", "lemma InfModel_intTI_intFI_intPI:\nassumes \"MModel intT intF intP\"\nshows \"IInfModel intTI intFI intPI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfModel intTI intFI intPI", "using MI_pred_MI[OF assms]"], ["proof (prove)\nusing this:\n  MI_pred MI\n\ngoal (1 subgoal):\n 1. IInfModel intTI intFI intPI", "unfolding MI_pred_def intFI_def intPI_def intTI_def"], ["proof (prove)\nusing this:\n  IInfModel (fst3 MI) (snd3 MI) (trd3 MI)\n\ngoal (1 subgoal):\n 1. IInfModel (fst3 MI) (snd3 MI) (trd3 MI)", "."], ["", "end"], ["", "(* context MonotProblem *)"], ["", "locale MonotModel = M? : MonotProblem + M? : Model"], ["", "context MonotModel begin"], ["", "lemma InfModelI: \"IInfModel intTI intFI intPI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfModel intTI intFI intPI", "apply(rule MonotProblem.InfModel_intTI_intFI_intPI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. MonotProblem wtFsym wtPsym arOf resOf parOf \\<Phi>\n 2. MModel ?intT ?intF ?intP", "apply standard"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* Trivial fact: Any monotonic problem that has a model also has an infinite model: *)"], ["", "sublocale MonotModel < InfModel where\nintT = intTI and intF = intFI and intP = intPI"], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfModel intTI intFI intPI", "using InfModelI"], ["proof (prove)\nusing this:\n  IInfModel intTI intFI intPI\n\ngoal (1 subgoal):\n 1. IInfModel intTI intFI intPI", "."], ["", "context InfModel begin"], ["", "definition \"toFull \\<sigma> \\<equiv> SOME F. bij_betw F {a::univ. intT \\<sigma> a} (UNIV::univ set)\""], ["", "definition \"fromFull \\<sigma> \\<equiv> inv_into {a::univ. intT \\<sigma> a} (toFull \\<sigma>)\""], ["", "definition \"intTF \\<sigma> a \\<equiv> True\""], ["", "definition \"intFF f al \\<equiv> toFull (resOf f) (intF f (map2 fromFull (arOf f) al))\""], ["", "definition \"intPF p al \\<equiv> intP p (map2 fromFull (parOf p) al)\""], ["", "lemma intTF: \"intTF \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intTF \\<sigma> a", "unfolding intTF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "by auto"], ["", "lemma ex_toFull: \"\\<exists> F. bij_betw F {a::univ. intT \\<sigma> a} (UNIV::univ set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F. bij_betw F {a. intT \\<sigma> a} UNIV", "by (metis inf card_of_ordIso card_of_UNIV countable_univ UnE\n          countable_infinite not_ordLeq_ordLess ordLeq_ordLess_Un_ordIso)"], ["", "lemma toFull: \"bij_betw (toFull \\<sigma>) {a. intT \\<sigma> a} UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (toFull \\<sigma>) {a. intT \\<sigma> a} UNIV", "by (metis (lifting) ex_toFull someI_ex toFull_def)"], ["", "lemma toFull_fromFull[simp]: \"toFull \\<sigma> (fromFull \\<sigma> a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toFull \\<sigma> (fromFull \\<sigma> a) = a", "by (metis UNIV_I bij_betw_inv_into_right fromFull_def toFull)"], ["", "lemma fromFull_toFull[simp]: \"intT \\<sigma> a \\<Longrightarrow> fromFull \\<sigma> (toFull \\<sigma> a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> a \\<Longrightarrow>\n    fromFull \\<sigma> (toFull \\<sigma> a) = a", "by (metis CollectI bij_betw_inv_into_left toFull fromFull_def)"], ["", "lemma fromFull_inj[simp]: \"fromFull \\<sigma> a = fromFull \\<sigma> b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fromFull \\<sigma> a = fromFull \\<sigma> b) = (a = b)", "by (metis toFull_fromFull)"], ["", "lemma toFull_inj[simp]:\nassumes \"intT \\<sigma> a\" and \"intT \\<sigma> b\"\nshows \"toFull \\<sigma> a = toFull \\<sigma> b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (toFull \\<sigma> a = toFull \\<sigma> b) = (a = b)", "by (metis assms fromFull_toFull)"], ["", "lemma fromFull[simp]: \"intT \\<sigma> (fromFull \\<sigma> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> (fromFull \\<sigma> a)", "unfolding fromFull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> (inv_into {a. intT \\<sigma> a} (toFull \\<sigma>) a)", "apply(rule inv_into_into[of a \"toFull \\<sigma>\" \"{a. intT \\<sigma> a}\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> toFull \\<sigma> ` {a. intT \\<sigma> a}", "using toFull"], ["proof (prove)\nusing this:\n  bij_betw (toFull ?\\<sigma>) {a. intT ?\\<sigma> a} UNIV\n\ngoal (1 subgoal):\n 1. a \\<in> toFull \\<sigma> ` {a. intT \\<sigma> a}", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on (toFull ?\\<sigma>) (Collect (intT ?\\<sigma>)) \\<and>\n  toFull ?\\<sigma> ` Collect (intT ?\\<sigma>) = UNIV\n\ngoal (1 subgoal):\n 1. a \\<in> toFull \\<sigma> ` {a. intT \\<sigma> a}", "by auto"], ["", "lemma toFull_iff_fromFull:\nassumes \"intT \\<sigma> a\"\nshows \"toFull \\<sigma> a = b \\<longleftrightarrow> a = fromFull \\<sigma> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (toFull \\<sigma> a = b) = (a = fromFull \\<sigma> b)", "by (metis assms fromFull_toFull toFull_fromFull)"], ["", "lemma Tstruct: \"Tstruct intTF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Tstruct intTF", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. \\<exists>a. intTF \\<sigma> a", "unfolding intTF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. \\<exists>a. True", "by simp"], ["", "lemma FullStruct: \"FullStruct wtFsym wtPsym arOf resOf intTF intFF intPF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFullStruct intTF intFF intPF", "apply (unfold_locales)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. intTF \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 intTF (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intTF (resOf f) (intFF f al)\n 3. intPF = intPF\n 4. \\<And>\\<sigma>. Tstruct.full intTF \\<sigma>", "unfolding intTF_def Tstruct.full_def[OF Tstruct]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. True\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f;\n        list_all2 (\\<lambda>\\<sigma> a. True) (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> True\n 3. intPF = intPF\n 4. \\<And>\\<sigma>. \\<forall>d. True", "by auto"], ["", "end"], ["", "(* locale InfModel *)"], ["", "sublocale InfModel < FullStruct\nwhere intT = intTF and intF = intFF and intP = intPF"], ["proof (prove)\ngoal (1 subgoal):\n 1. FFullStruct intTF intFF intPF", "using FullStruct"], ["proof (prove)\nusing this:\n  FFullStruct intTF intFF intPF\n\ngoal (1 subgoal):\n 1. FFullStruct intTF intFF intPF", "."], ["", "context InfModel begin"], ["", "definition \"kE \\<xi> \\<equiv> \\<lambda> x. fromFull (tpOfV x) (\\<xi> x)\""], ["", "lemma kE[simp]: \"kE \\<xi> x = fromFull (tpOfV x) (\\<xi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kE \\<xi> x = fromFull (tpOfV x) (\\<xi> x)", "unfolding kE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fromFull (tpOfV x) (\\<xi> x) = fromFull (tpOfV x) (\\<xi> x)", "by simp"], ["", "lemma wtE[simp]: \"F.wtE \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F.wtE \\<xi>", "unfolding F.wtE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. intTF (tpOfV x) (\\<xi> x)", "by simp"], ["", "lemma kE_wtE[simp]: \"I.wtE (kE \\<xi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.wtE (kE \\<xi>)", "unfolding I.wtE_def kE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. intT (tpOfV x) (fromFull (tpOfV x) (\\<xi> x))", "by simp"], ["", "lemma kE_int_toFull:\nassumes \\<xi>: \"I.wtE (kE \\<xi>)\" and T: \"wt T\"\nshows \"toFull (tpOf T) (I.int (kE \\<xi>) T) = F.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toFull (tpOf T) (I.int (kE \\<xi>) T) = F.int \\<xi> T", "using T"], ["proof (prove)\nusing this:\n  wt T\n\ngoal (1 subgoal):\n 1. toFull (tpOf T) (I.int (kE \\<xi>) T) = F.int \\<xi> T", "proof(induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       toFull (tpOf (Var x)) (I.int (kE \\<xi>) (Var x)) =\n       F.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     toFull (tpOf a) (I.int (kE \\<xi>) a) = F.int \\<xi> a)\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> toFull (tpOf (Fn f Tl))\n                          (I.int (kE \\<xi>) (Fn f Tl)) =\n                         F.int \\<xi> (Fn f Tl)", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       toFull (tpOf a) (I.int (kE \\<xi>) a) = F.int \\<xi> a)\n   Tl\n  wt (Fn f Tl)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       toFull (tpOf (Var x)) (I.int (kE \\<xi>) (Var x)) =\n       F.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     toFull (tpOf a) (I.int (kE \\<xi>) a) = F.int \\<xi> a)\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> toFull (tpOf (Fn f Tl))\n                          (I.int (kE \\<xi>) (Fn f Tl)) =\n                         F.int \\<xi> (Fn f Tl)", "have 0: \"map (I.int (kE \\<xi>)) Tl =\n           map2 fromFull (arOf f) (map (F.int \\<xi>) Tl)\"\n  (is \"map ?F Tl = map2 fromFull (arOf f) (map ?H Tl)\"\n   is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (I.int (kE \\<xi>)) Tl =\n    map2 fromFull (arOf f) (map (F.int \\<xi>) Tl)", "proof(rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map (I.int (kE \\<xi>)) Tl) =\n    length (map2 fromFull (arOf f) (map (F.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "have l: \"length Tl = length (arOf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Tl = length (arOf f)", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       toFull (tpOf a) (I.int (kE \\<xi>) a) = F.int \\<xi> a)\n   Tl\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. length Tl = length (arOf f)", "by simp"], ["proof (state)\nthis:\n  length Tl = length (arOf f)\n\ngoal (2 subgoals):\n 1. length (map (I.int (kE \\<xi>)) Tl) =\n    length (map2 fromFull (arOf f) (map (F.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "thus \"length ?L = length ?R\""], ["proof (prove)\nusing this:\n  length Tl = length (arOf f)\n\ngoal (1 subgoal):\n 1. length (map (I.int (kE \\<xi>)) Tl) =\n    length (map2 fromFull (arOf f) (map (F.int \\<xi>) Tl))", "by simp"], ["proof (state)\nthis:\n  length (map (I.int (kE \\<xi>)) Tl) =\n  length (map2 fromFull (arOf f) (map (F.int \\<xi>) Tl))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "assume \"i < length ?L\""], ["proof (state)\nthis:\n  i < length (map (I.int (kE \\<xi>)) Tl)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "hence i: \"i < length Tl\""], ["proof (prove)\nusing this:\n  i < length (map (I.int (kE \\<xi>)) Tl)\n\ngoal (1 subgoal):\n 1. i < length Tl", "by simp"], ["proof (state)\nthis:\n  i < length Tl\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "let ?toFull = \"toFull (arOf f!i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "let ?fromFull = \"fromFull (arOf f!i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "have tp: \"tpOf (Tl ! i) = arOf f ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tpOf (Tl ! i) = arOf f ! i", "using Fn(2) i"], ["proof (prove)\nusing this:\n  wt (Fn f Tl)\n  i < length Tl\n\ngoal (1 subgoal):\n 1. tpOf (Tl ! i) = arOf f ! i", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  wt (Fn f Tl)\n  i < length Tl\n\ngoal (1 subgoal):\n 1. tpOf (Tl ! i) = arOf f ! i", "by auto"], ["proof (state)\nthis:\n  tpOf (Tl ! i) = arOf f ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "have wt: \"wt (Tl!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (Tl ! i)", "using Fn i"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       toFull (tpOf a) (I.int (kE \\<xi>) a) = F.int \\<xi> a)\n   Tl\n  wt (Fn f Tl)\n  i < length Tl\n\ngoal (1 subgoal):\n 1. wt (Tl ! i)", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  wt (Tl ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "have \"intT (arOf f!i) (?F (Tl!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i))", "using I.wt_int[OF \\<xi> wt]"], ["proof (prove)\nusing this:\n  intT (tpOf (Tl ! i)) (I.int (kE \\<xi>) (Tl ! i))\n\ngoal (1 subgoal):\n 1. intT (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i))", "unfolding tp"], ["proof (prove)\nusing this:\n  intT (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i))\n\ngoal (1 subgoal):\n 1. intT (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i))", "."], ["proof (state)\nthis:\n  intT (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "moreover"], ["proof (state)\nthis:\n  intT (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "have \"?toFull (?F (Tl!i)) = ?H (Tl!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toFull (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i)) = F.int \\<xi> (Tl ! i)", "using Fn tp i"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       toFull (tpOf a) (I.int (kE \\<xi>) a) = F.int \\<xi> a)\n   Tl\n  wt (Fn f Tl)\n  tpOf (Tl ! i) = arOf f ! i\n  i < length Tl\n\ngoal (1 subgoal):\n 1. toFull (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i)) = F.int \\<xi> (Tl ! i)", "by (auto simp: list_all_iff kE_def)"], ["proof (state)\nthis:\n  toFull (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i)) = F.int \\<xi> (Tl ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "ultimately"], ["proof (chain)\npicking this:\n  intT (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i))\n  toFull (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i)) = F.int \\<xi> (Tl ! i)", "have \"?F (Tl!i) = fromFull (arOf f!i) (?H (Tl!i))\""], ["proof (prove)\nusing this:\n  intT (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i))\n  toFull (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i)) = F.int \\<xi> (Tl ! i)\n\ngoal (1 subgoal):\n 1. I.int (kE \\<xi>) (Tl ! i) = fromFull (arOf f ! i) (F.int \\<xi> (Tl ! i))", "using toFull_iff_fromFull"], ["proof (prove)\nusing this:\n  intT (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i))\n  toFull (arOf f ! i) (I.int (kE \\<xi>) (Tl ! i)) = F.int \\<xi> (Tl ! i)\n  intT ?\\<sigma> ?a \\<Longrightarrow>\n  (toFull ?\\<sigma> ?a = ?b) = (?a = fromFull ?\\<sigma> ?b)\n\ngoal (1 subgoal):\n 1. I.int (kE \\<xi>) (Tl ! i) = fromFull (arOf f ! i) (F.int \\<xi> (Tl ! i))", "by blast"], ["proof (state)\nthis:\n  I.int (kE \\<xi>) (Tl ! i) = fromFull (arOf f ! i) (F.int \\<xi> (Tl ! i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "thus \"?L!i = ?R!i\""], ["proof (prove)\nusing this:\n  I.int (kE \\<xi>) (Tl ! i) = fromFull (arOf f ! i) (F.int \\<xi> (Tl ! i))\n\ngoal (1 subgoal):\n 1. map (I.int (kE \\<xi>)) Tl ! i =\n    map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "using l i"], ["proof (prove)\nusing this:\n  I.int (kE \\<xi>) (Tl ! i) = fromFull (arOf f ! i) (F.int \\<xi> (Tl ! i))\n  length Tl = length (arOf f)\n  i < length Tl\n\ngoal (1 subgoal):\n 1. map (I.int (kE \\<xi>)) Tl ! i =\n    map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i", "by simp"], ["proof (state)\nthis:\n  map (I.int (kE \\<xi>)) Tl ! i =\n  map2 fromFull (arOf f) (map (F.int \\<xi>) Tl) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (I.int (kE \\<xi>)) Tl = map2 fromFull (arOf f) (map (F.int \\<xi>) Tl)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       toFull (tpOf (Var x)) (I.int (kE \\<xi>) (Var x)) =\n       F.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     toFull (tpOf a) (I.int (kE \\<xi>) a) = F.int \\<xi> a)\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> toFull (tpOf (Fn f Tl))\n                          (I.int (kE \\<xi>) (Fn f Tl)) =\n                         F.int \\<xi> (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. toFull (tpOf (Fn f Tl)) (I.int (kE \\<xi>) (Fn f Tl)) =\n    F.int \\<xi> (Fn f Tl)", "unfolding I.int.simps F.int.simps tpOf.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. toFull (resOf f) (intF f (map (I.int (kE \\<xi>)) Tl)) =\n    intFF f (map (F.int \\<xi>) Tl)", "unfolding intFF_def 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. toFull (resOf f)\n     (intF f\n       (map2 fromFull (arOf f)\n         (map (Struct.int\n                (\\<lambda>f al.\n                    toFull (resOf f) (intF f (map2 fromFull (arOf f) al)))\n                \\<xi>)\n           Tl))) =\n    toFull (resOf f)\n     (intF f\n       (map2 fromFull (arOf f)\n         (map (Struct.int\n                (\\<lambda>f al.\n                    toFull (resOf f) (intF f (map2 fromFull (arOf f) al)))\n                \\<xi>)\n           Tl)))", ".."], ["proof (state)\nthis:\n  toFull (tpOf (Fn f Tl)) (I.int (kE \\<xi>) (Fn f Tl)) =\n  F.int \\<xi> (Fn f Tl)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       toFull (tpOf (Var x)) (I.int (kE \\<xi>) (Var x)) =\n       F.int \\<xi> (Var x)", "qed simp"], ["", "lemma kE_int[simp]:\nassumes \\<xi>: \"I.wtE (kE \\<xi>)\" and T: \"wt T\"\nshows \"I.int (kE \\<xi>) T = fromFull (tpOf T) (F.int \\<xi> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.int (kE \\<xi>) T = fromFull (tpOf T) (F.int \\<xi> T)", "using kE_int_toFull[OF assms]"], ["proof (prove)\nusing this:\n  toFull (tpOf T) (I.int (kE \\<xi>) T) = F.int \\<xi> T\n\ngoal (1 subgoal):\n 1. I.int (kE \\<xi>) T = fromFull (tpOf T) (F.int \\<xi> T)", "unfolding toFull_iff_fromFull[OF I.wt_int[OF \\<xi> T]]"], ["proof (prove)\nusing this:\n  I.int (kE \\<xi>) T = fromFull (tpOf T) (F.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. I.int (kE \\<xi>) T = fromFull (tpOf T) (F.int \\<xi> T)", "."], ["", "lemma map_kE_int[simp]:\n  assumes \\<xi>: \"I.wtE (kE \\<xi>)\" and T: \"list_all wt Tl\"\n  shows \"map (I.int (kE \\<xi>)) Tl = map2 fromFull (map tpOf Tl) (map (F.int \\<xi>) Tl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (I.int (kE \\<xi>)) Tl =\n    map2 fromFull (map tpOf Tl) (map (F.int \\<xi>) Tl)", "apply(rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map (I.int (kE \\<xi>)) Tl) =\n    length (map2 fromFull (map tpOf Tl) (map (F.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (map tpOf Tl) (map (F.int \\<xi>) Tl) ! i", "apply (metis (lifting) length_map length_map2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (I.int (kE \\<xi>)) Tl) \\<Longrightarrow>\n       map (I.int (kE \\<xi>)) Tl ! i =\n       map2 fromFull (map tpOf Tl) (map (F.int \\<xi>) Tl) ! i", "by (metis T \\<xi> kE_int length_map list_all_length nth_map nth_map2)"], ["", "lemma kE_satA[simp]:\nassumes at: \"wtA at\" and \\<xi>: \"I.wtE (kE \\<xi>)\"\nshows \"I.satA (kE \\<xi>) at \\<longleftrightarrow> F.satA \\<xi> at\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satA (kE \\<xi>) at = F.satA \\<xi> at", "using assms"], ["proof (prove)\nusing this:\n  wtA at\n  I.wtE (kE \\<xi>)\n\ngoal (1 subgoal):\n 1. I.satA (kE \\<xi>) at = F.satA \\<xi> at", "by (cases at, auto simp add: intPF_def)"], ["", "lemma kE_satL[simp]:\nassumes l: \"wtL l\" and \\<xi>: \"I.wtE (kE \\<xi>)\"\nshows \"I.satL (kE \\<xi>) l \\<longleftrightarrow> F.satL \\<xi> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satL (kE \\<xi>) l = F.satL \\<xi> l", "using assms"], ["proof (prove)\nusing this:\n  wtL l\n  I.wtE (kE \\<xi>)\n\ngoal (1 subgoal):\n 1. I.satL (kE \\<xi>) l = F.satL \\<xi> l", "by (cases l, auto)"], ["", "lemma kE_satC[simp]:\nassumes c: \"wtC c\" and \\<xi>: \"I.wtE (kE \\<xi>)\"\nshows \"I.satC (kE \\<xi>) c \\<longleftrightarrow> F.satC \\<xi> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satC (kE \\<xi>) c = F.satC \\<xi> c", "unfolding I.satC_def F.satC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex (I.satL (kE \\<xi>)) c = list_ex (F.satL \\<xi>) c", "using assms"], ["proof (prove)\nusing this:\n  wtC c\n  I.wtE (kE \\<xi>)\n\ngoal (1 subgoal):\n 1. list_ex (I.satL (kE \\<xi>)) c = list_ex (F.satL \\<xi>) c", "by(induct c, auto simp add: wtC_def)"], ["", "lemma kE_satPB:\nassumes \\<xi>: \"I.wtE (kE \\<xi>)\"  shows \"F.satPB \\<xi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F.satPB \\<xi> \\<Phi>", "using I.sat_\\<Phi>[OF assms]"], ["proof (prove)\nusing this:\n  I.satPB (kE \\<xi>) \\<Phi>\n\ngoal (1 subgoal):\n 1. F.satPB \\<xi> \\<Phi>", "using wt_\\<Phi> assms"], ["proof (prove)\nusing this:\n  I.satPB (kE \\<xi>) \\<Phi>\n  wtPB \\<Phi>\n  I.wtE (kE \\<xi>)\n\ngoal (1 subgoal):\n 1. F.satPB \\<xi> \\<Phi>", "unfolding I.satPB_def F.satPB_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<Phi>. I.satC (kE \\<xi>) c\n  wtPB \\<Phi>\n  I.wtE (kE \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<Phi>. F.satC \\<xi> c", "by (auto simp add: wtPB_def)"], ["", "lemma F_SAT: \"F.SAT \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F.SAT \\<Phi>", "unfolding F.SAT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>. F.wtE \\<xi> \\<longrightarrow> F.satPB \\<xi> \\<Phi>", "using kE_satPB kE_wtE"], ["proof (prove)\nusing this:\n  I.wtE (kE ?\\<xi>) \\<Longrightarrow> F.satPB ?\\<xi> \\<Phi>\n  I.wtE (kE ?\\<xi>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>. F.wtE \\<xi> \\<longrightarrow> F.satPB \\<xi> \\<Phi>", "by auto"], ["", "lemma FullModel: \"FullModel wtFsym wtPsym arOf resOf parOf \\<Phi> intTF intFF intPF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFullModel intTF intFF intPF", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. F.SAT \\<Phi>", "using F_SAT"], ["proof (prove)\nusing this:\n  F.SAT \\<Phi>\n\ngoal (1 subgoal):\n 1. F.SAT \\<Phi>", "."], ["", "end"], ["", "(* context InfModel *)"], ["", "sublocale InfModel < FullModel where\nintT = intTF and intF = intFF and intP = intPF"], ["proof (prove)\ngoal (1 subgoal):\n 1. FFullModel intTF intFF intPF", "using FullModel"], ["proof (prove)\nusing this:\n  FFullModel intTF intFF intPF\n\ngoal (1 subgoal):\n 1. FFullModel intTF intFF intPF", "."], ["", "context MonotProblem begin"], ["", "definition \"intTF \\<equiv> InfModel.intTF\""], ["", "definition \"intFF \\<equiv> InfModel.intFF arOf resOf intTI intFI\""], ["", "definition \"intPF \\<equiv> InfModel.intPF parOf intTI intPI\""], ["", "text\\<open>Strengthening of the infiniteness condition for monotonicity,\nreplacing infininetess by fullness:\\<close>"], ["", "theorem FullModel_intTF_intFF_intPF:\nassumes \"MModel intT intF intP\"\nshows \"FFullModel intTF intFF intPF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFullModel intTF intFF intPF", "unfolding intTF_def intFF_def intPF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FFullModel InfModel.intTF (InfModel.intFF arOf resOf intTI intFI)\n     (InfModel.intPF parOf intTI intPI)", "apply(rule InfModel.FullModel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfModel intTI intFI intPI", "using InfModel_intTI_intFI_intPI[OF assms]"], ["proof (prove)\nusing this:\n  IInfModel intTI intFI intPI\n\ngoal (1 subgoal):\n 1. IInfModel intTI intFI intPI", "."], ["", "end"], ["", "(* context MonotProblem *)"], ["", "sublocale MonotModel < FullModel where\nintT = intTF and intF = intFF and intP = intPF"], ["proof (prove)\ngoal (1 subgoal):\n 1. FFullModel InfModel.intTF local.intFF local.intPF", "using FullModel"], ["proof (prove)\nusing this:\n  FFullModel InfModel.intTF local.intFF local.intPF\n\ngoal (1 subgoal):\n 1. FFullModel InfModel.intTF local.intFF local.intPF", "."], ["", "end"]]}