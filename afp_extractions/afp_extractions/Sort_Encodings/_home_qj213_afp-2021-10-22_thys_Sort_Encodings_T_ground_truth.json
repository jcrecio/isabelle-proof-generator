{"file_name": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings/T.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings", "problem_names": ["lemma countable_TE_wtFsym: \"countable (Collect TE_wtFsym)\" (is \"countable ?K\")", "lemma tpOf_tNN[simp]: \"TE.tpOf (tNN T) = Ik.tpOf T\"", "lemma tpOf_t[simp]: \"TE.tpOf (tT T) = Ik.tpOf T\"", "lemma wt_tNN[simp]: \"Ik.wt T \\<Longrightarrow> TE.wt (tNN T)\"", "lemma wt_t[simp]: \"Ik.wt T \\<Longrightarrow> TE.wt (tT T)\"", "lemma wtL_tL[simp]: \"Ik.wtL l \\<Longrightarrow> TE.wtL (tL l)\"", "lemma wtC_tC[simp]: \"Ik.wtC c \\<Longrightarrow> TE.wtC (tC c)\"", "lemma tpOf_rOfFax[simp]: \"TE.tpOf (rOfFax f) = resOf f\"", "lemma tpOf_lOfFax[simp]: \"TE.tpOf (lOfFax f) = resOf f\"", "lemma tpOf_rOfWax[simp]: \"TE.tpOf (rOfWax \\<sigma>) = \\<sigma>\"", "lemma tpOf_lOfWax[simp]: \"TE.tpOf (lOfWax \\<sigma>) = \\<sigma>\"", "lemma wt_rOfFax[simp]: \"wtFsym f \\<Longrightarrow> TE.wt (rOfFax f)\"", "lemma wt_lOfFax[simp]: \"wtFsym f \\<Longrightarrow> TE.wt (lOfFax f)\"", "lemma wt_rOfWax[simp]: \"\\<not> isRes \\<sigma> \\<Longrightarrow> TE.wt (rOfWax \\<sigma>)\"", "lemma wt_lOfWax[simp]: \"\\<not> isRes \\<sigma> \\<Longrightarrow> TE.wt (lOfWax \\<sigma>)\"", "lemma wtPB_Fax[simp]: \"TE.wtPB Fax\"", "lemma wtPB_Wax[simp]: \"TE.wtPB Wax\"", "lemma wtPB_tC_\\<Phi>[simp]: \"TE.wtPB (tC ` \\<Phi>)\"", "lemma wtPB_tPB[simp]: \"TE.wtPB tPB\"", "lemma wt_Tag:\nassumes \"TE.wt (Fn (Tag \\<sigma>) Tl)\"\nshows \"\\<exists> T. Tl = [T] \\<and> TE.wt T \\<and> tpOf T = \\<sigma>\"", "lemma tpOf_Tag: \"TE.tpOf (Fn (Tag \\<sigma>) Tl) = \\<sigma>\"", "lemma wt_Wit:\nassumes \"TE.wt (Fn (Wit \\<sigma>) Tl)\"\nshows \"Tl = []\"", "lemma tpOf_Wit: \"TE.tpOf (Fn (Wit \\<sigma>) Tl) = \\<sigma>\"", "lemma tNN_int[simp]: \"TE.int \\<xi> (tNN T) = Ik.int \\<xi> T\"", "lemma map_tNN_int[simp]: \"map (TE.int \\<xi> \\<circ> tNN) Tl = map (Ik.int \\<xi>) Tl\"", "lemma t_int[simp]: \"TE.int \\<xi> (tT T) = Ik.int \\<xi> T\"", "lemma map_t_int[simp]: \"map (TE.int \\<xi> \\<circ> tT) Tl = map (Ik.int \\<xi>) Tl\"", "lemma tL_satL[simp]: \"TE.satL \\<xi> (tL l) \\<longleftrightarrow> Ik.satL \\<xi> l\"", "lemma tC_satC[simp]: \"TE.satC \\<xi> (tC c) \\<longleftrightarrow> Ik.satC \\<xi> c\"", "lemma tC_\\<Phi>_satPB[simp]: \"TE.satPB \\<xi> (tC ` \\<Phi>) \\<longleftrightarrow> Ik.satPB \\<xi> \\<Phi>\"", "lemma Fax_Wax_satPB:\n\"TE.satPB \\<xi> (Fax) \\<and> TE.satPB \\<xi> (Wax)\"", "lemmas Fax_satPB[simp] = Fax_Wax_satPB[THEN conjunct1]", "lemmas Wax_satPB[simp] = Fax_Wax_satPB[THEN conjunct2]", "lemma soundness: \"TE.SAT tPB\"", "theorem T_soundness:\n\"Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB intT TE_intF intP\"", "lemma inImage_iimg[simp]: \"a \\<in> f ` B \\<Longrightarrow> iimg B f a = a\"", "lemma not_inImage_iimg[simp]: \"a \\<notin> f ` B \\<Longrightarrow> iimg B f a = f a\"", "lemma iimg[simp]: \"a \\<in> B \\<Longrightarrow> iimg B f (f a) = f a\"", "lemma unprot_ntsem[simp]: \"unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow> ntsem \\<sigma> a = a\"", "lemma protFw_ntsem[simp]: \"protFw \\<sigma> \\<Longrightarrow> ntsem \\<sigma> a = a\"", "lemma inImage_ntsem[simp]:\n\"a \\<in> (eintF (Tag \\<sigma>) o singl) ` {b. eintT \\<sigma> b} \\<Longrightarrow> ntsem \\<sigma> a = a\"", "lemma not_unprot_inImage_ntsem[simp]:\nassumes \"\\<not> unprot \\<sigma>\" and \"\\<not> protFw \\<sigma>\" and \"a \\<notin> (eintF (Tag \\<sigma>) o singl) ` {b. eintT \\<sigma> b}\"\nshows \"ntsem \\<sigma> a = eintF (Tag \\<sigma>) [a]\"", "lemma ntsem[simp]:\n\"eintT \\<sigma> b \\<Longrightarrow> ntsem \\<sigma> (eintF (Tag \\<sigma>) [b]) = eintF (Tag \\<sigma>) [b]\"", "lemma eintT_ntsem:\nassumes a: \"eintT \\<sigma> a\"  shows \"eintT \\<sigma> (ntsem \\<sigma> a)\"", "lemma TE_Tag: (* fixme: messy proof *)\nassumes f: \"wtFsym f\" and al: \"list_all2 eintT (arOf f) al\"\nshows \"eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al\"", "lemma TE_Wit:\nassumes \\<sigma>: \"\\<not> isRes \\<sigma>\" \"protFw \\<sigma>\"\nshows \"eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []\"", "lemma NE_intT_forget: \"NE (intT \\<sigma>)\"", "lemma wt_intF:\nassumes f: \"wtFsym f\" and al: \"list_all2 intT (arOf f) al\"\nshows \"intT (resOf f) (intF f al)\"", "lemma Struct: \"Struct wtFsym wtPsym arOf resOf intT intF intP\"", "lemma unprot_invt[simp]: \"unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow> invt \\<sigma> a = a\"", "lemma invt_invt_inImage:\nassumes \\<sigma>: \"\\<not> unprot \\<sigma>\" \"\\<not> protFw \\<sigma>\"\nand a: \"a \\<in> (eintF (Tag \\<sigma>) o singl) ` {b. eintT \\<sigma> b}\"\nshows \"eintT \\<sigma> (invt \\<sigma> a) \\<and> eintF (Tag \\<sigma>) [invt \\<sigma> a] = a\"", "lemmas invt[simp] = invt_invt_inImage[THEN conjunct1]", "lemmas invt_inImage[simp] = invt_invt_inImage[THEN conjunct2]", "lemma wt_eenv:\nassumes \\<xi>: \"Ik.wtE \\<xi>\"  shows \"TE.wtE (eenv \\<xi>)\"", "lemma int_tNN[simp]:\nassumes T: \"Ik.Ik.wt T\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.int (eenv \\<xi>) (tNN T) = Ik.int \\<xi> T\"", "lemma map_int_tNN[simp]:\nassumes Tl: \"list_all Ik.Ik.wt Tl\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows\n\"map2 ntsem (map Ik.Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl\"", "lemma int_t[simp]:\nassumes T: \"Ik.Ik.wt T\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.int (eenv \\<xi>) (tT T) = Ik.int \\<xi> T\"", "lemma map_int_t[simp]:\nassumes Tl: \"list_all Ik.Ik.wt Tl\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows\n\"map2 ntsem (map Ik.Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n map (TE.int (eenv \\<xi>) \\<circ> tT) Tl\"", "lemma satL_tL[simp]:\nassumes l: \"Ik.Ik.wtL l\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.satL (eenv \\<xi>) (tL l) \\<longleftrightarrow> Ik.satL \\<xi> l\"", "lemma satC_tC[simp]:\nassumes l: \"Ik.Ik.wtC c\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.satC (eenv \\<xi>) (tC c) \\<longleftrightarrow> Ik.satC \\<xi> c\"", "lemma satPB_tPB[simp]:\nassumes \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.satPB (eenv \\<xi>) (tC ` \\<Phi>) \\<longleftrightarrow> Ik.satPB \\<xi> \\<Phi>\"", "lemma completeness: \"Ik.SAT \\<Phi>\"", "lemma T_completeness: \"Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\"", "lemma nvT_t[simp]: \"\\<not> unprot \\<sigma> \\<Longrightarrow> (\\<forall> x \\<in> TE.nvT (tT T). tpOfV x \\<noteq> \\<sigma>)\"", "lemma nvL_tL[simp]: \"\\<not> unprot \\<sigma> \\<Longrightarrow> (\\<forall> x \\<in> TE.nvL (tL l). tpOfV x \\<noteq> \\<sigma>)\"", "lemma nvC_tC[simp]: \"\\<not> unprot \\<sigma> \\<Longrightarrow> (\\<forall> x \\<in> TE.nvC (tC c). tpOfV x \\<noteq> \\<sigma>)\"", "lemma unprot_nvT_t[simp]:\n\"unprot (tpOfV x) \\<Longrightarrow> x \\<in> TE.nvT (tT T) \\<longleftrightarrow> x \\<in>  TE.nvT T\"", "lemma tpL_nvT_tL[simp]:\n\"unprot (tpOfV x) \\<Longrightarrow> x \\<in> TE.nvL (tL l) \\<longleftrightarrow> x \\<in> TE.nvL l\"", "lemma unprot_nvC_tC[simp]:\n\"unprot (tpOfV x) \\<Longrightarrow> x \\<in> TE.nvC (tC c) \\<longleftrightarrow> x \\<in> TE.nvC c\"", "lemma nv_OfFax[simp]:\n\"x \\<notin> TE.nvT (lOfFax f)\"  \"x \\<notin> TE.nvT (rOfFax f)\"", "lemma nv_OfWax[simp]:\n\"x \\<notin> TE.nvT (lOfWax \\<sigma>')\"  \"x \\<notin> TE.nvT (rOfWax \\<sigma>')\"", "lemma nvC_Fax: \"c \\<in> Fax \\<Longrightarrow> TE.nvC c = {}\"", "lemma mcalc_Fax: \"c \\<in> Fax \\<Longrightarrow> TE.mcalc \\<sigma> c\"", "lemma nvC_Wax: \"c \\<in> Wax \\<Longrightarrow> TE.nvC c = {}\"", "lemma mcalc_Wax: \"c \\<in> Wax \\<Longrightarrow> TE.mcalc \\<sigma> c\"", "theorem T_monotonic:\n\"MonotProblem TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB\""], "translations": [["", "lemma countable_TE_wtFsym: \"countable (Collect TE_wtFsym)\" (is \"countable ?K\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "let ?F = \"\\<lambda> ef. case ef of Oldf f \\<Rightarrow> Inl f | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>) | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "let ?U = \"(UNIV::'tp set) <+> (UNIV::'tp set)\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "let ?L = \"(Collect wtFsym) <+> ?U\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "have \"inj_on ?F ?K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>ef.\n         case ef of Oldf f \\<Rightarrow> Inl f\n         | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n         | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>))\n     (Collect TE_wtFsym)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Collect TE_wtFsym.\n       \\<forall>y\\<in>Collect TE_wtFsym.\n          (case x of Oldf x \\<Rightarrow> Inl x\n           | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n           | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>)) =\n          (case y of Oldf x \\<Rightarrow> Inl x\n           | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n           | Wit \\<sigma> \\<Rightarrow>\n               Inr (Inr \\<sigma>)) \\<longrightarrow>\n          x = y", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>TE_wtFsym x; TE_wtFsym y;\n        (case x of Oldf x \\<Rightarrow> Inl x\n         | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n         | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>)) =\n        (case y of Oldf x \\<Rightarrow> Inl x\n         | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n         | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>))\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac x, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y x1.\n       \\<lbrakk>wtFsym x1; TE_wtFsym y;\n        Inl x1 =\n        (case y of Oldf x \\<Rightarrow> Inl x\n         | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n         | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>));\n        x = Oldf x1\\<rbrakk>\n       \\<Longrightarrow> Oldf x1 = y\n 2. \\<And>x y x2.\n       \\<lbrakk>TE_wtFsym y;\n        Inr (Inl x2) =\n        (case y of Oldf x \\<Rightarrow> Inl x\n         | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n         | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>));\n        x = Tag x2\\<rbrakk>\n       \\<Longrightarrow> Tag x2 = y\n 3. \\<And>x y x3.\n       \\<lbrakk>\\<not> isRes x3; TE_wtFsym y;\n        Inr (Inr x3) =\n        (case y of Oldf x \\<Rightarrow> Inl x\n         | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n         | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>));\n        x = Wit x3\\<rbrakk>\n       \\<Longrightarrow> Wit x3 = y", "by (case_tac y, simp_all)+"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n       | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>))\n   (Collect TE_wtFsym)\n\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "moreover"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n       | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>))\n   (Collect TE_wtFsym)\n\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "have \"?F ` ?K \\<subseteq> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ef.\n        case ef of Oldf f \\<Rightarrow> Inl f\n        | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n        | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>)) `\n    Collect TE_wtFsym\n    \\<subseteq> Collect wtFsym <+> UNIV <+> UNIV", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ef.\n       TE_wtFsym ef \\<Longrightarrow>\n       (case ef of Oldf f \\<Rightarrow> Inl f\n        | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n        | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>))\n       \\<in> Collect wtFsym <+> UNIV <+> UNIV", "by (case_tac ef, auto)"], ["proof (state)\nthis:\n  (\\<lambda>ef.\n      case ef of Oldf f \\<Rightarrow> Inl f\n      | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n      | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>)) `\n  Collect TE_wtFsym\n  \\<subseteq> Collect wtFsym <+> UNIV <+> UNIV\n\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "ultimately"], ["proof (chain)\npicking this:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n       | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>))\n   (Collect TE_wtFsym)\n  (\\<lambda>ef.\n      case ef of Oldf f \\<Rightarrow> Inl f\n      | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n      | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>)) `\n  Collect TE_wtFsym\n  \\<subseteq> Collect wtFsym <+> UNIV <+> UNIV", "have \"|?K| \\<le>o |?L|\""], ["proof (prove)\nusing this:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n       | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>))\n   (Collect TE_wtFsym)\n  (\\<lambda>ef.\n      case ef of Oldf f \\<Rightarrow> Inl f\n      | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n      | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>)) `\n  Collect TE_wtFsym\n  \\<subseteq> Collect wtFsym <+> UNIV <+> UNIV\n\ngoal (1 subgoal):\n 1. |Collect TE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV <+> UNIV|", "unfolding card_of_ordLeq[symmetric]"], ["proof (prove)\nusing this:\n  inj_on\n   (\\<lambda>ef.\n       case ef of Oldf f \\<Rightarrow> Inl f\n       | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n       | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>))\n   (Collect TE_wtFsym)\n  (\\<lambda>ef.\n      case ef of Oldf f \\<Rightarrow> Inl f\n      | Tag \\<sigma> \\<Rightarrow> Inr (Inl \\<sigma>)\n      | Wit \\<sigma> \\<Rightarrow> Inr (Inr \\<sigma>)) `\n  Collect TE_wtFsym\n  \\<subseteq> Collect wtFsym <+> UNIV <+> UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       inj_on f (Collect TE_wtFsym) \\<and>\n       f ` Collect TE_wtFsym \\<subseteq> Collect wtFsym <+> UNIV <+> UNIV", "by auto"], ["proof (state)\nthis:\n  |Collect TE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV <+> UNIV|\n\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "moreover"], ["proof (state)\nthis:\n  |Collect TE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV <+> UNIV|\n\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "have \"countable ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (Collect wtFsym <+> UNIV <+> UNIV)", "using countable_wtFsym countable_tp"], ["proof (prove)\nusing this:\n  countable {f. wtFsym f}\n  countable UNIV\n\ngoal (1 subgoal):\n 1. countable (Collect wtFsym <+> UNIV <+> UNIV)", "by (metis countable_Plus)"], ["proof (state)\nthis:\n  countable (Collect wtFsym <+> UNIV <+> UNIV)\n\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "ultimately"], ["proof (chain)\npicking this:\n  |Collect TE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV <+> UNIV|\n  countable (Collect wtFsym <+> UNIV <+> UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  |Collect TE_wtFsym| \\<le>o |Collect wtFsym <+> UNIV <+> UNIV|\n  countable (Collect wtFsym <+> UNIV <+> UNIV)\n\ngoal (1 subgoal):\n 1. countable (Collect TE_wtFsym)", "by(rule countable_ordLeq)"], ["proof (state)\nthis:\n  countable (Collect TE_wtFsym)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ProblemIkTpart *)"], ["", "sublocale ProblemIkTpart < TE? : Signature\nwhere wtFsym = TE_wtFsym and arOf = TE_arOf and resOf = TE_resOf"], ["proof (prove)\ngoal (1 subgoal):\n 1. Signature TYPE('tp) TE_wtFsym wtPsym", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. countable UNIV\n 2. countable (Collect TE_wtFsym)\n 3. countable {p. wtPsym p}", "using countable_tp countable_TE_wtFsym countable_wtPsym"], ["proof (prove)\nusing this:\n  countable UNIV\n  countable (Collect TE_wtFsym)\n  countable {p. wtPsym p}\n\ngoal (3 subgoals):\n 1. countable UNIV\n 2. countable (Collect TE_wtFsym)\n 3. countable {p. wtPsym p}", "by auto"], ["", "context ProblemIkTpart\nbegin"], ["", "(* encoding of non-naked terms *)"], ["", "fun tNN where\n\"tNN (Var x) =\n (if unprot (tpOfV x) \\<or> protFw (tpOfV x) then Var x else Fn (Tag (tpOfV x)) [Var x])\"\n|\n\"tNN (Fn f Tl) = (if unprot (resOf f) \\<or> protFw (resOf f)\n                    then Fn (Oldf f) (map tNN Tl)\n                    else Fn (Tag (resOf f)) [Fn (Oldf f) (map tNN Tl)])\""], ["", "fun tT where\n\"tT (Var x) = (if unprot (tpOfV x) then Var x else Fn (Tag (tpOfV x)) [Var x])\"\n|\n\"tT t = tNN t\""], ["", "fun tL where\n\"tL (Pos (Eq T1 T2)) = Pos (Eq (tT T1) (tT T2))\"\n|\n\"tL (Neg (Eq T1 T2)) = Neg (Eq (tNN T1) (tNN T2))\"\n|\n\"tL (Pos (Pr p Tl)) = Pos (Pr p (map tNN Tl))\"\n|\n\"tL (Neg (Pr p Tl)) = Neg (Pr p (map tNN Tl))\""], ["", "definition \"tC \\<equiv> map tL\""], ["", "(* The extra axioms: *)\n\n(* The function axioms: *)\n(* Lefthand side: *)"], ["", "definition \"rOfFax f = Fn (Oldf f) (getTvars (arOf f))\""], ["", "(* Righthand side: *)"], ["", "definition \"lOfFax f = Fn (Tag (resOf f)) [rOfFax f]\""], ["", "definition \"Fax \\<equiv> {[Pos (Eq (lOfFax f) (rOfFax f))] | f. wtFsym f}\""], ["", "(* The witness axioms: *)\n(* Lefthand side: *)"], ["", "definition \"rOfWax \\<sigma> = Fn (Wit \\<sigma>) []\""], ["", "(* Righthand side: *)"], ["", "definition \"lOfWax \\<sigma> = Fn (Tag \\<sigma>) [rOfWax \\<sigma>]\""], ["", "definition \"Wax \\<equiv> {[Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))] | \\<sigma>. \\<not> isRes \\<sigma> \\<and> protFw \\<sigma>}\""], ["", "definition \"tPB = tC ` \\<Phi> \\<union> Fax \\<union> Wax\""], ["", "(* Well-typedness of the translation: *)"], ["", "lemma tpOf_tNN[simp]: \"TE.tpOf (tNN T) = Ik.tpOf T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (tNN T) = Ik.tpOf T", "by (induct T) auto"], ["", "lemma tpOf_t[simp]: \"TE.tpOf (tT T) = Ik.tpOf T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (tT T) = Ik.tpOf T", "by (cases T) auto"], ["", "lemma wt_tNN[simp]: \"Ik.wt T \\<Longrightarrow> TE.wt (tNN T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wt T \\<Longrightarrow> TE.wt (tNN T)", "by (induct T, auto simp add: list_all_iff)"], ["", "lemma wt_t[simp]: \"Ik.wt T \\<Longrightarrow> TE.wt (tT T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wt T \\<Longrightarrow> TE.wt (tT T)", "by (cases T, auto simp add: list_all_iff)"], ["", "lemma wtL_tL[simp]: \"Ik.wtL l \\<Longrightarrow> TE.wtL (tL l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wtL l \\<Longrightarrow> TE.wtL (tL l)", "apply(cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Ik.wtL l; l = Pos x1\\<rbrakk>\n       \\<Longrightarrow> TE.wtL (tL l)\n 2. \\<And>x2.\n       \\<lbrakk>Ik.wtL l; l = Neg x2\\<rbrakk>\n       \\<Longrightarrow> TE.wtL (tL l)", "apply (rename_tac [!] atm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>atm.\n       \\<lbrakk>Ik.wtL l; l = Pos atm\\<rbrakk>\n       \\<Longrightarrow> TE.wtL (tL l)\n 2. \\<And>atm.\n       \\<lbrakk>Ik.wtL l; l = Neg atm\\<rbrakk>\n       \\<Longrightarrow> TE.wtL (tL l)", "apply(case_tac [!] atm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>atm x11 x12.\n       \\<lbrakk>Ik.wtL l; l = Pos atm; atm = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> TE.wtL (tL l)\n 2. \\<And>atm x21 x22.\n       \\<lbrakk>Ik.wtL l; l = Pos atm; atm = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> TE.wtL (tL l)\n 3. \\<And>atm x11 x12.\n       \\<lbrakk>Ik.wtL l; l = Neg atm; atm = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> TE.wtL (tL l)\n 4. \\<And>atm x21 x22.\n       \\<lbrakk>Ik.wtL l; l = Neg atm; atm = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> TE.wtL (tL l)", "by (auto simp add: list_all_iff)"], ["", "lemma wtC_tC[simp]: \"Ik.wtC c \\<Longrightarrow> TE.wtC (tC c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.wtC c \\<Longrightarrow> TE.wtC (tC c)", "unfolding tC_def Ik.wtC_def TE.wtC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all Ik.wtL c \\<Longrightarrow> list_all TE.wtL (map tL c)", "by (induct c, auto)"], ["", "lemma tpOf_rOfFax[simp]: \"TE.tpOf (rOfFax f) = resOf f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (rOfFax f) = resOf f", "unfolding rOfFax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (Fn (Oldf f) (TE.getTvars (arOf f))) = resOf f", "by simp"], ["", "lemma tpOf_lOfFax[simp]: \"TE.tpOf (lOfFax f) = resOf f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (lOfFax f) = resOf f", "unfolding lOfFax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (Fn (Tag (resOf f)) [rOfFax f]) = resOf f", "by simp"], ["", "lemma tpOf_rOfWax[simp]: \"TE.tpOf (rOfWax \\<sigma>) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (rOfWax \\<sigma>) = \\<sigma>", "unfolding rOfWax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (Fn (Wit \\<sigma>) []) = \\<sigma>", "by simp"], ["", "lemma tpOf_lOfWax[simp]: \"TE.tpOf (lOfWax \\<sigma>) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (lOfWax \\<sigma>) = \\<sigma>", "unfolding lOfWax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (Fn (Tag \\<sigma>) [rOfWax \\<sigma>]) = \\<sigma>", "by simp"], ["", "lemma wt_rOfFax[simp]: \"wtFsym f \\<Longrightarrow> TE.wt (rOfFax f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtFsym f \\<Longrightarrow> TE.wt (rOfFax f)", "unfolding rOfFax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtFsym f \\<Longrightarrow> TE.wt (Fn (Oldf f) (TE.getTvars (arOf f)))", "by simp"], ["", "lemma wt_lOfFax[simp]: \"wtFsym f \\<Longrightarrow> TE.wt (lOfFax f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtFsym f \\<Longrightarrow> TE.wt (lOfFax f)", "unfolding lOfFax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtFsym f \\<Longrightarrow> TE.wt (Fn (Tag (resOf f)) [rOfFax f])", "by simp"], ["", "lemma wt_rOfWax[simp]: \"\\<not> isRes \\<sigma> \\<Longrightarrow> TE.wt (rOfWax \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> TE.wt (rOfWax \\<sigma>)", "unfolding rOfWax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> TE.wt (Fn (Wit \\<sigma>) [])", "by simp"], ["", "lemma wt_lOfWax[simp]: \"\\<not> isRes \\<sigma> \\<Longrightarrow> TE.wt (lOfWax \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> TE.wt (lOfWax \\<sigma>)", "unfolding lOfWax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow>\n    TE.wt (Fn (Tag \\<sigma>) [rOfWax \\<sigma>])", "by simp"], ["", "lemma wtPB_Fax[simp]: \"TE.wtPB Fax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.wtPB Fax", "unfolding Fax_def TE.wtPB_def TE.wtC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>{[Pos (Eq (lOfFax f) (rOfFax f))] |f. wtFsym f}.\n       list_all TE.wtL c", "by auto"], ["", "lemma wtPB_Wax[simp]: \"TE.wtPB Wax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.wtPB Wax", "unfolding Wax_def TE.wtPB_def TE.wtC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>{[Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))] |\n                    \\<sigma>. \\<not> isRes \\<sigma> \\<and> protFw \\<sigma>}.\n       list_all TE.wtL c", "by auto"], ["", "lemma wtPB_tC_\\<Phi>[simp]: \"TE.wtPB (tC ` \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.wtPB (tC ` \\<Phi>)", "using Ik.wt_\\<Phi>"], ["proof (prove)\nusing this:\n  Ik.wtPB \\<Phi>\n\ngoal (1 subgoal):\n 1. TE.wtPB (tC ` \\<Phi>)", "unfolding Ik.wtPB_def TE.wtPB_def"], ["proof (prove)\nusing this:\n  Ball \\<Phi> Ik.wtC\n\ngoal (1 subgoal):\n 1. Ball (tC ` \\<Phi>) TE.wtC", "by auto"], ["", "lemma wtPB_tPB[simp]: \"TE.wtPB tPB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.wtPB tPB", "unfolding tPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.wtPB (tC ` \\<Phi> \\<union> Fax \\<union> Wax)", "by simp"], ["", "(*  *)"], ["", "lemma wt_Tag:\nassumes \"TE.wt (Fn (Tag \\<sigma>) Tl)\"\nshows \"\\<exists> T. Tl = [T] \\<and> TE.wt T \\<and> tpOf T = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. Tl = [T] \\<and> TE.wt T \\<and> TE.tpOf T = \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  TE.wt (Fn (Tag \\<sigma>) Tl)\n\ngoal (1 subgoal):\n 1. \\<exists>T. Tl = [T] \\<and> TE.wt T \\<and> TE.tpOf T = \\<sigma>", "by simp (metis (hide_lams, no_types) list.inject list_all_simps(1) map_eq_Cons_conv neq_Nil_conv)"], ["", "lemma tpOf_Tag: \"TE.tpOf (Fn (Tag \\<sigma>) Tl) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (Fn (Tag \\<sigma>) Tl) = \\<sigma>", "by simp"], ["", "lemma wt_Wit:\nassumes \"TE.wt (Fn (Wit \\<sigma>) Tl)\"\nshows \"Tl = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tl = []", "using assms"], ["proof (prove)\nusing this:\n  TE.wt (Fn (Wit \\<sigma>) Tl)\n\ngoal (1 subgoal):\n 1. Tl = []", "by simp"], ["", "lemma tpOf_Wit: \"TE.tpOf (Fn (Wit \\<sigma>) Tl) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.tpOf (Fn (Wit \\<sigma>) Tl) = \\<sigma>", "by simp"], ["", "end"], ["", "(* context ProblemIkTpart *)"], ["", "subsection\\<open>Soundness\\<close>"], ["", "context ModelIkTpart begin"], ["", "(* The identity-tag extension of a given structure of the original signature *)"], ["", "fun TE_intF where\n \"TE_intF (Oldf f) al = intF f al\"\n|\"TE_intF (Tag \\<sigma>) al = hd al\"\n|\"TE_intF (Wit \\<sigma>) al = pickT \\<sigma>\""], ["", "(* note: for tags, we only care about al being the singleton list [a],\n   and hence the interpretation returns a; for witnesses, we only care\n   about al being [] *)"], ["", "end"], ["", "(* context ModelIkTpart *)"], ["", "sublocale ModelIkTpart < TE? : Struct\nwhere wtFsym = TE_wtFsym and arOf = TE_arOf and resOf = TE_resOf and intF = TE_intF"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Struct TE_wtFsym wtPsym TE_arOf TE_resOf intT TE_intF intP", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f al.\n       \\<lbrakk>TE_wtFsym f; list_all2 intT (TE_arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (TE_resOf f) (TE_intF f al)\n 2. intP = intP", "fix ef al"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f al.\n       \\<lbrakk>TE_wtFsym f; list_all2 intT (TE_arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (TE_resOf f) (TE_intF f al)\n 2. intP = intP", "assume \"TE_wtFsym ef\" and \"list_all2 intT (TE_arOf ef) al\""], ["proof (state)\nthis:\n  TE_wtFsym ef\n  list_all2 intT (TE_arOf ef) al\n\ngoal (2 subgoals):\n 1. \\<And>f al.\n       \\<lbrakk>TE_wtFsym f; list_all2 intT (TE_arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (TE_resOf f) (TE_intF f al)\n 2. intP = intP", "thus \"intT (TE_resOf ef) (TE_intF ef al)\""], ["proof (prove)\nusing this:\n  TE_wtFsym ef\n  list_all2 intT (TE_arOf ef) al\n\ngoal (1 subgoal):\n 1. intT (TE_resOf ef) (TE_intF ef al)", "using intF"], ["proof (prove)\nusing this:\n  TE_wtFsym ef\n  list_all2 intT (TE_arOf ef) al\n  \\<lbrakk>wtFsym ?f; list_all2 intT (arOf ?f) ?al\\<rbrakk>\n  \\<Longrightarrow> intT (resOf ?f) (intF ?f ?al)\n\ngoal (1 subgoal):\n 1. intT (TE_resOf ef) (TE_intF ef al)", "by (cases ef, auto)"], ["proof (state)\nthis:\n  intT (TE_resOf ef) (TE_intF ef al)\n\ngoal (1 subgoal):\n 1. intP = intP", "qed auto"], ["", "context ModelIkTpart begin"], ["", "lemma tNN_int[simp]: \"TE.int \\<xi> (tNN T) = Ik.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int \\<xi> (tNN T) = Ik.int \\<xi> T", "proof(induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. TE.int \\<xi> (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. TE.int \\<xi> (tNN a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       TE.int \\<xi> (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all (\\<lambda>a. TE.int \\<xi> (tNN a) = Ik.int \\<xi> a) Tl\n\ngoal (2 subgoals):\n 1. \\<And>x. TE.int \\<xi> (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. TE.int \\<xi> (tNN a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       TE.int \\<xi> (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "hence 0: \"map (TE.int \\<xi> \\<circ> tNN) Tl = map (Ik.int \\<xi>) Tl\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>a. TE.int \\<xi> (tNN a) = Ik.int \\<xi> a) Tl\n\ngoal (1 subgoal):\n 1. map (TE.int \\<xi> \\<circ> tNN) Tl = map (Ik.int \\<xi>) Tl", "unfolding list_eq_iff list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set Tl. TE.int \\<xi> (tNN a) = Ik.int \\<xi> a\n\ngoal (1 subgoal):\n 1. length (map (TE.int \\<xi> \\<circ> tNN) Tl) =\n    length (map (Ik.int \\<xi>) Tl) \\<and>\n    (\\<forall>i<length (map (TE.int \\<xi> \\<circ> tNN) Tl).\n        map (TE.int \\<xi> \\<circ> tNN) Tl ! i = map (Ik.int \\<xi>) Tl ! i)", "by auto"], ["proof (state)\nthis:\n  map (TE.int \\<xi> \\<circ> tNN) Tl = map (Ik.int \\<xi>) Tl\n\ngoal (2 subgoals):\n 1. \\<And>x. TE.int \\<xi> (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       list_all (\\<lambda>a. TE.int \\<xi> (tNN a) = Ik.int \\<xi> a)\n        Tl \\<Longrightarrow>\n       TE.int \\<xi> (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int \\<xi> (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "by (simp add: 0)"], ["proof (state)\nthis:\n  TE.int \\<xi> (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)\n\ngoal (1 subgoal):\n 1. \\<And>x. TE.int \\<xi> (tNN (Var x)) = Ik.int \\<xi> (Var x)", "qed auto"], ["", "lemma map_tNN_int[simp]: \"map (TE.int \\<xi> \\<circ> tNN) Tl = map (Ik.int \\<xi>) Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (TE.int \\<xi> \\<circ> tNN) Tl = map (Ik.int \\<xi>) Tl", "unfolding list_eq_iff list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (TE.int \\<xi> \\<circ> tNN) Tl) =\n    length (map (Ik.int \\<xi>) Tl) \\<and>\n    (\\<forall>i<length (map (TE.int \\<xi> \\<circ> tNN) Tl).\n        map (TE.int \\<xi> \\<circ> tNN) Tl ! i = map (Ik.int \\<xi>) Tl ! i)", "by auto"], ["", "lemma t_int[simp]: \"TE.int \\<xi> (tT T) = Ik.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int \\<xi> (tT T) = Ik.int \\<xi> T", "by (cases T, auto)"], ["", "lemma map_t_int[simp]: \"map (TE.int \\<xi> \\<circ> tT) Tl = map (Ik.int \\<xi>) Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (TE.int \\<xi> \\<circ> tT) Tl = map (Ik.int \\<xi>) Tl", "unfolding list_eq_iff list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (TE.int \\<xi> \\<circ> tT) Tl) =\n    length (map (Ik.int \\<xi>) Tl) \\<and>\n    (\\<forall>i<length (map (TE.int \\<xi> \\<circ> tT) Tl).\n        map (TE.int \\<xi> \\<circ> tT) Tl ! i = map (Ik.int \\<xi>) Tl ! i)", "by auto"], ["", "lemma tL_satL[simp]: \"TE.satL \\<xi> (tL l) \\<longleftrightarrow> Ik.satL \\<xi> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.satL \\<xi> (tL l) = Ik.satL \\<xi> l", "apply(cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       l = Pos x1 \\<Longrightarrow> TE.satL \\<xi> (tL l) = Ik.satL \\<xi> l\n 2. \\<And>x2.\n       l = Neg x2 \\<Longrightarrow> TE.satL \\<xi> (tL l) = Ik.satL \\<xi> l", "apply (rename_tac [!] atm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>atm.\n       l = Pos atm \\<Longrightarrow> TE.satL \\<xi> (tL l) = Ik.satL \\<xi> l\n 2. \\<And>atm.\n       l = Neg atm \\<Longrightarrow> TE.satL \\<xi> (tL l) = Ik.satL \\<xi> l", "apply(case_tac [!] atm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>atm x11 x12.\n       \\<lbrakk>l = Pos atm; atm = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> TE.satL \\<xi> (tL l) = Ik.satL \\<xi> l\n 2. \\<And>atm x21 x22.\n       \\<lbrakk>l = Pos atm; atm = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> TE.satL \\<xi> (tL l) = Ik.satL \\<xi> l\n 3. \\<And>atm x11 x12.\n       \\<lbrakk>l = Neg atm; atm = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> TE.satL \\<xi> (tL l) = Ik.satL \\<xi> l\n 4. \\<And>atm x21 x22.\n       \\<lbrakk>l = Neg atm; atm = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> TE.satL \\<xi> (tL l) = Ik.satL \\<xi> l", "by auto"], ["", "lemma tC_satC[simp]: \"TE.satC \\<xi> (tC c) \\<longleftrightarrow> Ik.satC \\<xi> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.satC \\<xi> (tC c) = Ik.satC \\<xi> c", "unfolding TE.satC_def Ik.satC_def tC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex (TE.satL \\<xi>) (map tL c) = list_ex (Ik.satL \\<xi>) c", "by (induct c, auto)"], ["", "lemma tC_\\<Phi>_satPB[simp]: \"TE.satPB \\<xi> (tC ` \\<Phi>) \\<longleftrightarrow> Ik.satPB \\<xi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.satPB \\<xi> (tC ` \\<Phi>) = Ik.satPB \\<xi> \\<Phi>", "unfolding TE.satPB_def Ik.satPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>tC ` \\<Phi>. TE.satC \\<xi> c) =\n    (\\<forall>c\\<in>\\<Phi>. Ik.satC \\<xi> c)", "by auto"], ["", "lemma Fax_Wax_satPB:\n\"TE.satPB \\<xi> (Fax) \\<and> TE.satPB \\<xi> (Wax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.satPB \\<xi> Fax \\<and> TE.satPB \\<xi> Wax", "unfolding TE.satPB_def TE.satC_def Fax_def Wax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>{[Pos (Eq (lOfFax f) (rOfFax f))] |f. wtFsym f}.\n        list_ex (TE.satL \\<xi>) c) \\<and>\n    (\\<forall>c\\<in>{[Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))] |\n                     \\<sigma>.\n                     \\<not> isRes \\<sigma> \\<and> protFw \\<sigma>}.\n        list_ex (TE.satL \\<xi>) c)", "by (auto simp add: lOfFax_def rOfFax_def lOfWax_def rOfWax_def)"], ["", "lemmas Fax_satPB[simp] = Fax_Wax_satPB[THEN conjunct1]"], ["", "lemmas Wax_satPB[simp] = Fax_Wax_satPB[THEN conjunct2]"], ["", "lemma soundness: \"TE.SAT tPB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.SAT tPB", "unfolding TE.SAT_def tPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>.\n       TE.wtE \\<xi> \\<longrightarrow>\n       TE.satPB \\<xi> (tC ` \\<Phi> \\<union> Fax \\<union> Wax)", "using SAT"], ["proof (prove)\nusing this:\n  Ik.SAT \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>.\n       TE.wtE \\<xi> \\<longrightarrow>\n       TE.satPB \\<xi> (tC ` \\<Phi> \\<union> Fax \\<union> Wax)", "unfolding Ik.SAT_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<xi>. TE.wtE \\<xi> \\<longrightarrow> Ik.satPB \\<xi> \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>.\n       TE.wtE \\<xi> \\<longrightarrow>\n       TE.satPB \\<xi> (tC ` \\<Phi> \\<union> Fax \\<union> Wax)", "by auto"], ["", "theorem T_soundness:\n\"Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB intT TE_intF intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB intT TE_intF intP", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. TE.wtPB tPB\n 2. TE.SAT tPB", "using wtPB_tPB soundness"], ["proof (prove)\nusing this:\n  TE.wtPB tPB\n  TE.SAT tPB\n\ngoal (2 subgoals):\n 1. TE.wtPB tPB\n 2. TE.SAT tPB", "by auto"], ["", "end"], ["", "(* context ModelIkTpart *)\n\n\n\n(* Soundness theorem in sublocale form: Given a problem (with indicated\ntype partition) and a model for it, we obtain a model of the tag-extended (TE)\nproblem: *)"], ["", "sublocale ModelIkTpart < TE? : Model\nwhere wtFsym = TE_wtFsym and arOf = TE_arOf and resOf = TE_resOf\nand \\<Phi> = tPB and intF = TE_intF"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB intT TE_intF intP", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. TE.wtPB tPB\n 2. TE.SAT tPB", "using wtPB_tPB soundness"], ["proof (prove)\nusing this:\n  TE.wtPB tPB\n  TE.SAT tPB\n\ngoal (2 subgoals):\n 1. TE.wtPB tPB\n 2. TE.SAT tPB", "by auto"], ["", "subsection\\<open>Completeness\\<close>"], ["", "(* iimg B f transforms f into a function f' having the same B-range as f\nand such that it is the identity on its B-image, namely, \\<forall> b \\<in> B. f' (f' a) = f' a;\nalso, it holds that \\<forall> b \\<in> B. f' (f b) = f b *)"], ["", "definition \"iimg B f a \\<equiv> if a \\<in> f ` B then a else f a\""], ["", "lemma inImage_iimg[simp]: \"a \\<in> f ` B \\<Longrightarrow> iimg B f a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> f ` B \\<Longrightarrow> iimg B f a = a", "unfolding iimg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> f ` B \\<Longrightarrow> (if a \\<in> f ` B then a else f a) = a", "by auto"], ["", "lemma not_inImage_iimg[simp]: \"a \\<notin> f ` B \\<Longrightarrow> iimg B f a = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> f ` B \\<Longrightarrow> iimg B f a = f a", "unfolding iimg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> f ` B \\<Longrightarrow>\n    (if a \\<in> f ` B then a else f a) = f a", "by auto"], ["", "lemma iimg[simp]: \"a \\<in> B \\<Longrightarrow> iimg B f (f a) = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> B \\<Longrightarrow> iimg B f (f a) = f a", "by (cases \"a \\<in> f ` B\", auto)"], ["", "(* Problem with type partition and model of its tag-encoding translation: *)"], ["", "locale ProblemIkTpart_TEModel =\nIk? : ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot protFw +\nTE? : Model \"ProblemIkTpart.TE_wtFsym wtFsym resOf\" wtPsym\n           \"ProblemIkTpart.TE_arOf arOf\" \"ProblemIkTpart.TE_resOf resOf\" parOf\n           tPB eintT eintF eintP\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\"\nand wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf and parOf and \\<Phi> and infTp and prot and protFw\nand eintT and eintF and eintP"], ["", "context ProblemIkTpart_TEModel begin"], ["", "(* new tag semantics (taking as input elements, instead of singleton lists): *)"], ["", "definition\n\"ntsem \\<sigma> \\<equiv>\n if unprot \\<sigma> \\<or> protFw \\<sigma> then id\n                   else iimg {b. eintT \\<sigma> b} (eintF (Tag \\<sigma>) o singl)\""], ["", "lemma unprot_ntsem[simp]: \"unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow> ntsem \\<sigma> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow>\n    ntsem \\<sigma> a = a", "unfolding ntsem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow>\n    (if unprot \\<sigma> \\<or> protFw \\<sigma> then id\n     else iimg {b. eintT \\<sigma> b} (eintF (Tag \\<sigma>) \\<circ> singl))\n     a =\n    a", "by simp"], ["", "lemma protFw_ntsem[simp]: \"protFw \\<sigma> \\<Longrightarrow> ntsem \\<sigma> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. protFw \\<sigma> \\<Longrightarrow> ntsem \\<sigma> a = a", "unfolding ntsem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. protFw \\<sigma> \\<Longrightarrow>\n    (if unprot \\<sigma> \\<or> protFw \\<sigma> then id\n     else iimg {b. eintT \\<sigma> b} (eintF (Tag \\<sigma>) \\<circ> singl))\n     a =\n    a", "by simp"], ["", "lemma inImage_ntsem[simp]:\n\"a \\<in> (eintF (Tag \\<sigma>) o singl) ` {b. eintT \\<sigma> b} \\<Longrightarrow> ntsem \\<sigma> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) `\n            {b. eintT \\<sigma> b} \\<Longrightarrow>\n    ntsem \\<sigma> a = a", "unfolding ntsem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) `\n            {b. eintT \\<sigma> b} \\<Longrightarrow>\n    (if unprot \\<sigma> \\<or> protFw \\<sigma> then id\n     else iimg {b. eintT \\<sigma> b} (eintF (Tag \\<sigma>) \\<circ> singl))\n     a =\n    a", "by simp"], ["", "lemma not_unprot_inImage_ntsem[simp]:\nassumes \"\\<not> unprot \\<sigma>\" and \"\\<not> protFw \\<sigma>\" and \"a \\<notin> (eintF (Tag \\<sigma>) o singl) ` {b. eintT \\<sigma> b}\"\nshows \"ntsem \\<sigma> a = eintF (Tag \\<sigma>) [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ntsem \\<sigma> a = eintF (Tag \\<sigma>) [a]", "using assms"], ["proof (prove)\nusing this:\n  \\<not> unprot \\<sigma>\n  \\<not> protFw \\<sigma>\n  a \\<notin> (eintF (Tag \\<sigma>) \\<circ> singl) ` {b. eintT \\<sigma> b}\n\ngoal (1 subgoal):\n 1. ntsem \\<sigma> a = eintF (Tag \\<sigma>) [a]", "unfolding ntsem_def"], ["proof (prove)\nusing this:\n  \\<not> unprot \\<sigma>\n  \\<not> protFw \\<sigma>\n  a \\<notin> (eintF (Tag \\<sigma>) \\<circ> singl) ` {b. eintT \\<sigma> b}\n\ngoal (1 subgoal):\n 1. (if unprot \\<sigma> \\<or> protFw \\<sigma> then id\n     else iimg {b. eintT \\<sigma> b} (eintF (Tag \\<sigma>) \\<circ> singl))\n     a =\n    eintF (Tag \\<sigma>) [a]", "by (simp add: singl_def)"], ["", "(* crucial: *)"], ["", "lemma ntsem[simp]:\n\"eintT \\<sigma> b \\<Longrightarrow> ntsem \\<sigma> (eintF (Tag \\<sigma>) [b]) = eintF (Tag \\<sigma>) [b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> b \\<Longrightarrow>\n    ntsem \\<sigma> (eintF (Tag \\<sigma>) [b]) = eintF (Tag \\<sigma>) [b]", "unfolding singl_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> b \\<Longrightarrow>\n    ntsem \\<sigma> (eintF (Tag \\<sigma>) (singl b)) =\n    eintF (Tag \\<sigma>) (singl b)", "by simp"], ["", "lemma eintT_ntsem:\nassumes a: \"eintT \\<sigma> a\"  shows \"eintT \\<sigma> (ntsem \\<sigma> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> (ntsem \\<sigma> a)", "proof(cases \"unprot \\<sigma> \\<or> protFw \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)\n 2. \\<not> (unprot \\<sigma> \\<or> protFw \\<sigma>) \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)", "case False"], ["proof (state)\nthis:\n  \\<not> (unprot \\<sigma> \\<or> protFw \\<sigma>)\n\ngoal (2 subgoals):\n 1. unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)\n 2. \\<not> (unprot \\<sigma> \\<or> protFw \\<sigma>) \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)", "note unprot = False"], ["proof (state)\nthis:\n  \\<not> (unprot \\<sigma> \\<or> protFw \\<sigma>)\n\ngoal (2 subgoals):\n 1. unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)\n 2. \\<not> (unprot \\<sigma> \\<or> protFw \\<sigma>) \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> (ntsem \\<sigma> a)", "proof(cases \"a \\<in> (eintF (Tag \\<sigma>) o singl) ` {b. eintT \\<sigma> b}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) `\n            {b. eintT \\<sigma> b} \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)\n 2. a \\<notin> (eintF (Tag \\<sigma>) \\<circ> singl) `\n               {b. eintT \\<sigma> b} \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)", "case False"], ["proof (state)\nthis:\n  a \\<notin> (eintF (Tag \\<sigma>) \\<circ> singl) ` {b. eintT \\<sigma> b}\n\ngoal (2 subgoals):\n 1. a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) `\n            {b. eintT \\<sigma> b} \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)\n 2. a \\<notin> (eintF (Tag \\<sigma>) \\<circ> singl) `\n               {b. eintT \\<sigma> b} \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)", "hence 1: \"ntsem \\<sigma> a = eintF (Tag \\<sigma>) [a]\""], ["proof (prove)\nusing this:\n  a \\<notin> (eintF (Tag \\<sigma>) \\<circ> singl) ` {b. eintT \\<sigma> b}\n\ngoal (1 subgoal):\n 1. ntsem \\<sigma> a = eintF (Tag \\<sigma>) [a]", "using unprot"], ["proof (prove)\nusing this:\n  a \\<notin> (eintF (Tag \\<sigma>) \\<circ> singl) ` {b. eintT \\<sigma> b}\n  \\<not> (unprot \\<sigma> \\<or> protFw \\<sigma>)\n\ngoal (1 subgoal):\n 1. ntsem \\<sigma> a = eintF (Tag \\<sigma>) [a]", "by simp"], ["proof (state)\nthis:\n  ntsem \\<sigma> a = eintF (Tag \\<sigma>) [a]\n\ngoal (2 subgoals):\n 1. a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) `\n            {b. eintT \\<sigma> b} \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)\n 2. a \\<notin> (eintF (Tag \\<sigma>) \\<circ> singl) `\n               {b. eintT \\<sigma> b} \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> (ntsem \\<sigma> a)", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> (eintF (Tag \\<sigma>) [a])", "using a TE.intF"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  \\<lbrakk>TE_wtFsym ?f; list_all2 eintT (TE_arOf ?f) ?al\\<rbrakk>\n  \\<Longrightarrow> eintT (TE_resOf ?f) (eintF ?f ?al)\n\ngoal (1 subgoal):\n 1. eintT \\<sigma> (eintF (Tag \\<sigma>) [a])", "by (metis TE_arOf.simps TE_resOf.simps TE_wtFsym.simps list_all2_Cons list_all2_Nil)"], ["proof (state)\nthis:\n  eintT \\<sigma> (ntsem \\<sigma> a)\n\ngoal (1 subgoal):\n 1. a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) `\n            {b. eintT \\<sigma> b} \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)", "qed(insert a, auto)"], ["proof (state)\nthis:\n  eintT \\<sigma> (ntsem \\<sigma> a)\n\ngoal (1 subgoal):\n 1. unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow>\n    eintT \\<sigma> (ntsem \\<sigma> a)", "qed(insert a, simp)"], ["", "(* The reduct structure of a given structure in the tag-extended signature: *)"], ["", "definition\n\"intT \\<sigma> a \\<equiv>\n if unprot \\<sigma> then eintT \\<sigma> a\n else if protFw \\<sigma> then eintT \\<sigma> a \\<and> eintF (Tag \\<sigma>) [a] = a\n else eintT \\<sigma> a \\<and> a \\<in> (eintF (Tag \\<sigma>) o singl) ` {b. eintT \\<sigma> b}\""], ["", "definition\n\"intF f al \\<equiv>\n if unprot (resOf f) \\<or> protFw (resOf f)\n   then eintF (Oldf f) (map2 ntsem (arOf f) al)\n   else eintF (Tag (resOf f)) [eintF (Oldf f) (map2 ntsem (arOf f) al)]\""], ["", "definition\n\"intP p al \\<equiv> eintP p (map2 ntsem (parOf p) al)\""], ["", "(* Semantic rephrasings of the fact that the (tagged problem) model satisfies\n   Fax and Wax *)"], ["", "lemma TE_Tag: (* fixme: messy proof *)\nassumes f: \"wtFsym f\" and al: \"list_all2 eintT (arOf f) al\"\nshows \"eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "define xl where \"xl = getVars (arOf f)\""], ["proof (state)\nthis:\n  xl = TE.getVars (arOf f)\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "have l[simp]: \"length xl = length al\" \"length al = length (arOf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xl = length al &&& length al = length (arOf f)", "unfolding xl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (TE.getVars (arOf f)) = length al &&& length al = length (arOf f)", "using al"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. length (TE.getVars (arOf f)) = length al &&& length al = length (arOf f)", "unfolding list_all2_iff"], ["proof (prove)\nusing this:\n  length (arOf f) = length al \\<and>\n  (\\<forall>(x, y)\\<in>set (zip (arOf f) al). eintT x y)\n\ngoal (1 subgoal):\n 1. length (TE.getVars (arOf f)) = length al &&& length al = length (arOf f)", "by auto"], ["proof (state)\nthis:\n  length xl = length al\n  length al = length (arOf f)\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "have 1[simp]: \"\\<And> i. i < length (arOf f) \\<Longrightarrow> tpOfV (xl!i) = (arOf f)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow> TE.tpOfV (xl ! i) = arOf f ! i", "unfolding xl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow>\n       TE.tpOfV (TE.getVars (arOf f) ! i) = arOf f ! i", "by auto"], ["proof (state)\nthis:\n  ?i11 < length (arOf f) \\<Longrightarrow>\n  TE.tpOfV (xl ! ?i11) = arOf f ! ?i11\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "have xl[simp]: \"distinct xl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xl", "unfolding xl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (TE.getVars (arOf f))", "using distinct_getVars"], ["proof (prove)\nusing this:\n  distinct (TE.getVars ?\\<sigma>l)\n\ngoal (1 subgoal):\n 1. distinct (TE.getVars (arOf f))", "by auto"], ["proof (state)\nthis:\n  distinct xl\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "define \\<xi> where \"\\<xi> = pickE xl al\""], ["proof (state)\nthis:\n  \\<xi> = pickE xl al\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "have \\<xi>: \"TE.wtE \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE \\<xi>", "unfolding \\<xi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (pickE xl al)", "apply(rule wtE_pickE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length xl = length al\n 2. distinct xl\n 3. \\<And>i.\n       i < length xl \\<Longrightarrow> eintT (TE.tpOfV (xl ! i)) (al ! i)", "using al  list_all2_nthD"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n  \\<lbrakk>list_all2 ?P ?xs ?ys; ?p < length ?xs\\<rbrakk>\n  \\<Longrightarrow> ?P (?xs ! ?p) (?ys ! ?p)\n\ngoal (3 subgoals):\n 1. length xl = length al\n 2. distinct xl\n 3. \\<And>i.\n       i < length xl \\<Longrightarrow> eintT (TE.tpOfV (xl ! i)) (al ! i)", "by auto"], ["proof (state)\nthis:\n  wtE \\<xi>\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "have [simp]: \"\\<And> i. i < length (arOf f) \\<Longrightarrow> \\<xi> (xl ! i) = al ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < length (arOf f) \\<Longrightarrow> \\<xi> (xl ! i) = al ! i", "using al"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length (arOf f) \\<Longrightarrow> \\<xi> (xl ! i) = al ! i", "unfolding \\<xi>_def"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow> pickE xl al (xl ! i) = al ! i", "by (auto simp: list_all2_length intro: pickE)"], ["proof (state)\nthis:\n  ?i11 < length (arOf f) \\<Longrightarrow> \\<xi> (xl ! ?i11) = al ! ?i11\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "have 0: \"map (TE.int \\<xi>) (getTvars (arOf f)) = al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (int \\<xi>) (TE.getTvars (arOf f)) = al", "apply(rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map (int \\<xi>) (TE.getTvars (arOf f))) = length al\n 2. \\<And>i.\n       i < length (map (int \\<xi>) (TE.getTvars (arOf f))) \\<Longrightarrow>\n       map (int \\<xi>) (TE.getTvars (arOf f)) ! i = al ! i", "using al"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (2 subgoals):\n 1. length (map (int \\<xi>) (TE.getTvars (arOf f))) = length al\n 2. \\<And>i.\n       i < length (map (int \\<xi>) (TE.getTvars (arOf f))) \\<Longrightarrow>\n       map (int \\<xi>) (TE.getTvars (arOf f)) ! i = al ! i", "by (auto simp: list_all2_length getTvars_def xl_def[symmetric])"], ["proof (state)\nthis:\n  map (int \\<xi>) (TE.getTvars (arOf f)) = al\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "have \"TE.satPB \\<xi> Fax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB \\<xi> Fax", "using TE.sat_\\<Phi>[OF \\<xi>]"], ["proof (prove)\nusing this:\n  satPB \\<xi> tPB\n\ngoal (1 subgoal):\n 1. satPB \\<xi> Fax", "unfolding tPB_def"], ["proof (prove)\nusing this:\n  satPB \\<xi> (tC ` \\<Phi> \\<union> Fax \\<union> Wax)\n\ngoal (1 subgoal):\n 1. satPB \\<xi> Fax", "by simp"], ["proof (state)\nthis:\n  satPB \\<xi> Fax\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "hence \"TE.satC \\<xi> [Pos (Eq (lOfFax f) (rOfFax f))]\""], ["proof (prove)\nusing this:\n  satPB \\<xi> Fax\n\ngoal (1 subgoal):\n 1. satC \\<xi> [Pos (Eq (lOfFax f) (rOfFax f))]", "unfolding TE.satPB_def Fax_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>{[Pos (Eq (lOfFax f) (rOfFax f))] |f. wtFsym f}.\n     satC \\<xi> c\n\ngoal (1 subgoal):\n 1. satC \\<xi> [Pos (Eq (lOfFax f) (rOfFax f))]", "using f"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>{[Pos (Eq (lOfFax f) (rOfFax f))] |f. wtFsym f}.\n     satC \\<xi> c\n  wtFsym f\n\ngoal (1 subgoal):\n 1. satC \\<xi> [Pos (Eq (lOfFax f) (rOfFax f))]", "by auto"], ["proof (state)\nthis:\n  satC \\<xi> [Pos (Eq (lOfFax f) (rOfFax f))]\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "hence \"TE.satA \\<xi> (Eq (lOfFax f) (rOfFax f))\""], ["proof (prove)\nusing this:\n  satC \\<xi> [Pos (Eq (lOfFax f) (rOfFax f))]\n\ngoal (1 subgoal):\n 1. satA \\<xi> (Eq (lOfFax f) (rOfFax f))", "unfolding TE.satC_def"], ["proof (prove)\nusing this:\n  list_ex (satL \\<xi>) [Pos (Eq (lOfFax f) (rOfFax f))]\n\ngoal (1 subgoal):\n 1. satA \\<xi> (Eq (lOfFax f) (rOfFax f))", "by simp"], ["proof (state)\nthis:\n  satA \\<xi> (Eq (lOfFax f) (rOfFax f))\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "thus ?thesis"], ["proof (prove)\nusing this:\n  satA \\<xi> (Eq (lOfFax f) (rOfFax f))\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "using al"], ["proof (prove)\nusing this:\n  satA \\<xi> (Eq (lOfFax f) (rOfFax f))\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "by (simp add: lOfFax_def rOfFax_def 0)"], ["proof (state)\nthis:\n  eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TE_Wit:\nassumes \\<sigma>: \"\\<not> isRes \\<sigma>\" \"protFw \\<sigma>\"\nshows \"eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "define \\<xi> where \"\\<xi> = pickE [] []\""], ["proof (state)\nthis:\n  \\<xi> = pickE [] []\n\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "have \\<xi>: \"TE.wtE \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE \\<xi>", "unfolding \\<xi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtE (pickE [] [])", "apply(rule wtE_pickE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length [] = length []\n 2. distinct []\n 3. \\<And>i.\n       i < length [] \\<Longrightarrow> eintT (TE.tpOfV ([] ! i)) ([] ! i)", "by auto"], ["proof (state)\nthis:\n  wtE \\<xi>\n\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "have \"TE.satPB \\<xi> Wax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satPB \\<xi> Wax", "using TE.sat_\\<Phi>[OF \\<xi>]"], ["proof (prove)\nusing this:\n  satPB \\<xi> tPB\n\ngoal (1 subgoal):\n 1. satPB \\<xi> Wax", "unfolding tPB_def"], ["proof (prove)\nusing this:\n  satPB \\<xi> (tC ` \\<Phi> \\<union> Fax \\<union> Wax)\n\ngoal (1 subgoal):\n 1. satPB \\<xi> Wax", "by simp"], ["proof (state)\nthis:\n  satPB \\<xi> Wax\n\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "hence \"TE.satC \\<xi> [Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))]\""], ["proof (prove)\nusing this:\n  satPB \\<xi> Wax\n\ngoal (1 subgoal):\n 1. satC \\<xi> [Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))]", "unfolding TE.satPB_def Wax_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>{[Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))] |\\<sigma>.\n                  \\<not> isRes \\<sigma> \\<and> protFw \\<sigma>}.\n     satC \\<xi> c\n\ngoal (1 subgoal):\n 1. satC \\<xi> [Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))]", "using \\<sigma>"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>{[Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))] |\\<sigma>.\n                  \\<not> isRes \\<sigma> \\<and> protFw \\<sigma>}.\n     satC \\<xi> c\n  \\<not> isRes \\<sigma>\n  protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. satC \\<xi> [Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))]", "by auto"], ["proof (state)\nthis:\n  satC \\<xi> [Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))]\n\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "hence \"TE.satA \\<xi> (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))\""], ["proof (prove)\nusing this:\n  satC \\<xi> [Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))]\n\ngoal (1 subgoal):\n 1. satA \\<xi> (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))", "unfolding TE.satC_def"], ["proof (prove)\nusing this:\n  list_ex (satL \\<xi>) [Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))]\n\ngoal (1 subgoal):\n 1. satA \\<xi> (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  satA \\<xi> (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))\n\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "thus ?thesis"], ["proof (prove)\nusing this:\n  satA \\<xi> (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))\n\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "unfolding TE.satA.simps lOfWax_def rOfWax_def"], ["proof (prove)\nusing this:\n  int \\<xi> (Fn (Tag \\<sigma>) [Fn (Wit \\<sigma>) []]) =\n  int \\<xi> (Fn (Wit \\<sigma>) [])\n\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "by simp"], ["proof (state)\nthis:\n  eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NE_intT_forget: \"NE (intT \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "obtain b where b: \"eintT \\<sigma> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b. eintT \\<sigma> b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using TE.NE_intT"], ["proof (prove)\nusing this:\n  \\<exists>a. eintT ?\\<sigma> a\n\ngoal (1 subgoal):\n 1. (\\<And>b. eintT \\<sigma> b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  eintT \\<sigma> b\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "proof(cases \"unprot \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case True"], ["proof (state)\nthis:\n  unprot \\<sigma>\n\ngoal (2 subgoals):\n 1. unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "thus ?thesis"], ["proof (prove)\nusing this:\n  unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "using b"], ["proof (prove)\nusing this:\n  unprot \\<sigma>\n  eintT \\<sigma> b\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "unfolding intT_def"], ["proof (prove)\nusing this:\n  unprot \\<sigma>\n  eintT \\<sigma> b\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       if unprot \\<sigma> then eintT \\<sigma> a\n       else if protFw \\<sigma>\n            then eintT \\<sigma> a \\<and> eintF (Tag \\<sigma>) [a] = a\n            else eintT \\<sigma> a \\<and>\n                 a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) `\n                         {b. eintT \\<sigma> b}", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case False"], ["proof (state)\nthis:\n  \\<not> unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "note unprot = False"], ["proof (state)\nthis:\n  \\<not> unprot \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "proof(cases \"protFw \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case True"], ["proof (state)\nthis:\n  protFw \\<sigma>\n\ngoal (2 subgoals):\n 1. protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "note protFw = True"], ["proof (state)\nthis:\n  protFw \\<sigma>\n\ngoal (2 subgoals):\n 1. protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "proof(cases \"isRes \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case True"], ["proof (state)\nthis:\n  isRes \\<sigma>\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "then"], ["proof (chain)\npicking this:\n  isRes \\<sigma>", "obtain f where f: \"wtFsym f\" and \\<sigma>: \"\\<sigma> = resOf f\""], ["proof (prove)\nusing this:\n  isRes \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>wtFsym f; \\<sigma> = resOf f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding isRes_def"], ["proof (prove)\nusing this:\n  \\<exists>f. wtFsym f \\<and> resOf f = \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>wtFsym f; \\<sigma> = resOf f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  wtFsym f\n  \\<sigma> = resOf f\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "define al where \"al = map pickT (arOf f)\""], ["proof (state)\nthis:\n  al = map pickT (arOf f)\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have al: \"list_all2 eintT (arOf f) al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 eintT (arOf f) al", "unfolding al_def list_all2_map2"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. eintT x (pickT y)) (arOf f) (arOf f)", "unfolding list_all2_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (arOf f) = length (arOf f) \\<and>\n    (\\<forall>i<length (arOf f). eintT (arOf f ! i) (pickT (arOf f ! i)))", "by auto"], ["proof (state)\nthis:\n  list_all2 eintT (arOf f) al\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "define a where \"a = eintF (Oldf f) al\""], ["proof (state)\nthis:\n  a = eintF (Oldf f) al\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have \"eintT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> a", "unfolding a_def \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT (resOf f) (eintF (Oldf f) al)", "using f al"], ["proof (prove)\nusing this:\n  wtFsym f\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. eintT (resOf f) (eintF (Oldf f) al)", "by (metis TE_arOf.simps TE_resOf.simps TE_wtFsym.simps TE.intF)"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "moreover"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have \"eintF (Tag \\<sigma>) [a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [a] = a", "unfolding \\<sigma> a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "using TE_Tag[OF f al]"], ["proof (prove)\nusing this:\n  eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al\n\ngoal (1 subgoal):\n 1. eintF (Tag (resOf f)) [eintF (Oldf f) al] = eintF (Oldf f) al", "."], ["proof (state)\nthis:\n  eintF (Tag \\<sigma>) [a] = a\n\ngoal (2 subgoals):\n 1. isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a\n 2. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "ultimately"], ["proof (chain)\npicking this:\n  eintT \\<sigma> a\n  eintF (Tag \\<sigma>) [a] = a", "show ?thesis"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintF (Tag \\<sigma>) [a] = a\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "using unprot protFw"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintF (Tag \\<sigma>) [a] = a\n  \\<not> unprot \\<sigma>\n  protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "unfolding intT_def"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintF (Tag \\<sigma>) [a] = a\n  \\<not> unprot \\<sigma>\n  protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       if unprot \\<sigma> then eintT \\<sigma> a\n       else if protFw \\<sigma>\n            then eintT \\<sigma> a \\<and> eintF (Tag \\<sigma>) [a] = a\n            else eintT \\<sigma> a \\<and>\n                 a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) `\n                         {b. eintT \\<sigma> b}", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case False"], ["proof (state)\nthis:\n  \\<not> isRes \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "define a where \"a = eintF (Wit \\<sigma>) []\""], ["proof (state)\nthis:\n  a = eintF (Wit \\<sigma>) []\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have \"eintT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> (eintF (Wit \\<sigma>) [])", "by (metis False TE_arOf.simps TE_resOf.simps TE_wtFsym.simps TE.intF list_all2_NilR)"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "moreover"], ["proof (state)\nthis:\n  eintT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "have \"eintF (Tag \\<sigma>) [a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [a] = a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "using TE_Wit[OF False protFw]"], ["proof (prove)\nusing this:\n  eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []\n\ngoal (1 subgoal):\n 1. eintF (Tag \\<sigma>) [eintF (Wit \\<sigma>) []] = eintF (Wit \\<sigma>) []", "."], ["proof (state)\nthis:\n  eintF (Tag \\<sigma>) [a] = a\n\ngoal (1 subgoal):\n 1. \\<not> isRes \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "ultimately"], ["proof (chain)\npicking this:\n  eintT \\<sigma> a\n  eintF (Tag \\<sigma>) [a] = a", "show ?thesis"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintF (Tag \\<sigma>) [a] = a\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "using unprot protFw"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintF (Tag \\<sigma>) [a] = a\n  \\<not> unprot \\<sigma>\n  protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "unfolding intT_def"], ["proof (prove)\nusing this:\n  eintT \\<sigma> a\n  eintF (Tag \\<sigma>) [a] = a\n  \\<not> unprot \\<sigma>\n  protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       if unprot \\<sigma> then eintT \\<sigma> a\n       else if protFw \\<sigma>\n            then eintT \\<sigma> a \\<and> eintF (Tag \\<sigma>) [a] = a\n            else eintT \\<sigma> a \\<and>\n                 a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) `\n                         {b. eintT \\<sigma> b}", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<not> protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "case False"], ["proof (state)\nthis:\n  \\<not> protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "hence \"eintT \\<sigma> (eintF (Tag \\<sigma>) [b])\""], ["proof (prove)\nusing this:\n  \\<not> protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. eintT \\<sigma> (eintF (Tag \\<sigma>) [b])", "using b list_all2_Cons list_all2_NilL"], ["proof (prove)\nusing this:\n  \\<not> protFw \\<sigma>\n  eintT \\<sigma> b\n  list_all2 ?P (?x # ?xs) (?y # ?ys) =\n  (?P ?x ?y \\<and> list_all2 ?P ?xs ?ys)\n  list_all2 ?R [] ?ys = (?ys = [])\n\ngoal (1 subgoal):\n 1. eintT \\<sigma> (eintF (Tag \\<sigma>) [b])", "by (metis TE.intF TE_arOf.simps TE_resOf.simps TE_wtFsym.simps)"], ["proof (state)\nthis:\n  eintT \\<sigma> (eintF (Tag \\<sigma>) [b])\n\ngoal (1 subgoal):\n 1. \\<not> protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "hence \"intT \\<sigma> (eintF (Tag \\<sigma>) [b])\""], ["proof (prove)\nusing this:\n  eintT \\<sigma> (eintF (Tag \\<sigma>) [b])\n\ngoal (1 subgoal):\n 1. intT \\<sigma> (eintF (Tag \\<sigma>) [b])", "unfolding intT_def singl_def[abs_def]"], ["proof (prove)\nusing this:\n  eintT \\<sigma> (eintF (Tag \\<sigma>) [b])\n\ngoal (1 subgoal):\n 1. if unprot \\<sigma> then eintT \\<sigma> (eintF (Tag \\<sigma>) [b])\n    else if protFw \\<sigma>\n         then eintT \\<sigma> (eintF (Tag \\<sigma>) [b]) \\<and>\n              eintF (Tag \\<sigma>) [eintF (Tag \\<sigma>) [b]] =\n              eintF (Tag \\<sigma>) [b]\n         else eintT \\<sigma> (eintF (Tag \\<sigma>) [b]) \\<and>\n              eintF (Tag \\<sigma>) [b]\n              \\<in> (eintF (Tag \\<sigma>) \\<circ> (\\<lambda>a. [a])) `\n                    {b. eintT \\<sigma> b}", "using b False"], ["proof (prove)\nusing this:\n  eintT \\<sigma> (eintF (Tag \\<sigma>) [b])\n  eintT \\<sigma> b\n  \\<not> protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. if unprot \\<sigma> then eintT \\<sigma> (eintF (Tag \\<sigma>) [b])\n    else if protFw \\<sigma>\n         then eintT \\<sigma> (eintF (Tag \\<sigma>) [b]) \\<and>\n              eintF (Tag \\<sigma>) [eintF (Tag \\<sigma>) [b]] =\n              eintF (Tag \\<sigma>) [b]\n         else eintT \\<sigma> (eintF (Tag \\<sigma>) [b]) \\<and>\n              eintF (Tag \\<sigma>) [b]\n              \\<in> (eintF (Tag \\<sigma>) \\<circ> (\\<lambda>a. [a])) `\n                    {b. eintT \\<sigma> b}", "by auto"], ["proof (state)\nthis:\n  intT \\<sigma> (eintF (Tag \\<sigma>) [b])\n\ngoal (1 subgoal):\n 1. \\<not> protFw \\<sigma> \\<Longrightarrow> \\<exists>a. intT \\<sigma> a", "thus ?thesis"], ["proof (prove)\nusing this:\n  intT \\<sigma> (eintF (Tag \\<sigma>) [b])\n\ngoal (1 subgoal):\n 1. \\<exists>a. intT \\<sigma> a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. intT \\<sigma> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_intF:\nassumes f: \"wtFsym f\" and al: \"list_all2 intT (arOf f) al\"\nshows \"intT (resOf f) (intF f al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "let ?t = \"eintF (Tag (resOf f))\""], ["proof (state)\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "let ?t'al = \"map2 ntsem (arOf f) al\""], ["proof (state)\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "have al: \"list_all2 eintT (arOf f) al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 eintT (arOf f) al", "using al"], ["proof (prove)\nusing this:\n  list_all2 intT (arOf f) al\n\ngoal (1 subgoal):\n 1. list_all2 eintT (arOf f) al", "unfolding list_all2_length intT_def"], ["proof (prove)\nusing this:\n  length (arOf f) = length al \\<and>\n  (\\<forall>i<length (arOf f).\n      if unprot (arOf f ! i) then eintT (arOf f ! i) (al ! i)\n      else if protFw (arOf f ! i)\n           then eintT (arOf f ! i) (al ! i) \\<and>\n                eintF (Tag (arOf f ! i)) [al ! i] = al ! i\n           else eintT (arOf f ! i) (al ! i) \\<and>\n                al ! i\n                \\<in> (eintF (Tag (arOf f ! i)) \\<circ> singl) `\n                      {b. eintT (arOf f ! i) b})\n\ngoal (1 subgoal):\n 1. length (arOf f) = length al \\<and>\n    (\\<forall>i<length (arOf f). eintT (arOf f ! i) (al ! i))", "by metis"], ["proof (state)\nthis:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "have 0: \"list_all2 eintT (arOf f) ?t'al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 eintT (arOf f) (map2 ntsem (arOf f) al)", "proof(rule listAll2_map2I)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (arOf f) = length al\n 2. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow>\n       eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))", "show l: \"length (arOf f) = length al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (arOf f) = length al", "using al"], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. length (arOf f) = length al", "unfolding list_all2_length"], ["proof (prove)\nusing this:\n  length (arOf f) = length al \\<and>\n  (\\<forall>i<length (arOf f). eintT (arOf f ! i) (al ! i))\n\ngoal (1 subgoal):\n 1. length (arOf f) = length al", "by simp"], ["proof (state)\nthis:\n  length (arOf f) = length al\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow>\n       eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow>\n       eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))", "assume \"i < length (arOf f)\""], ["proof (state)\nthis:\n  i < length (arOf f)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow>\n       eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))", "hence 1: \"eintT (arOf f ! i) (al ! i)\""], ["proof (prove)\nusing this:\n  i < length (arOf f)\n\ngoal (1 subgoal):\n 1. eintT (arOf f ! i) (al ! i)", "using al"], ["proof (prove)\nusing this:\n  i < length (arOf f)\n  list_all2 eintT (arOf f) al\n\ngoal (1 subgoal):\n 1. eintT (arOf f ! i) (al ! i)", "unfolding list_all2_length"], ["proof (prove)\nusing this:\n  i < length (arOf f)\n  length (arOf f) = length al \\<and>\n  (\\<forall>i<length (arOf f). eintT (arOf f ! i) (al ! i))\n\ngoal (1 subgoal):\n 1. eintT (arOf f ! i) (al ! i)", "by simp"], ["proof (state)\nthis:\n  eintT (arOf f ! i) (al ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (arOf f) \\<Longrightarrow>\n       eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))", "show \"eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))", "using eintT_ntsem[OF 1]"], ["proof (prove)\nusing this:\n  eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))\n\ngoal (1 subgoal):\n 1. eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))", "."], ["proof (state)\nthis:\n  eintT (arOf f ! i) (ntsem (arOf f ! i) (al ! i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 eintT (arOf f) (map2 ntsem (arOf f) al)\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "hence 1: \"eintT (resOf f) (eintF (Oldf f) ?t'al)\""], ["proof (prove)\nusing this:\n  list_all2 eintT (arOf f) (map2 ntsem (arOf f) al)\n\ngoal (1 subgoal):\n 1. eintT (resOf f) (eintF (Oldf f) (map2 ntsem (arOf f) al))", "by (metis TE_arOf.simps TE_resOf.simps TE_wtFsym.simps f TE.intF)"], ["proof (state)\nthis:\n  eintT (resOf f) (eintF (Oldf f) (map2 ntsem (arOf f) al))\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "proof(cases \"unprot (resOf f)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)\n 2. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "case True"], ["proof (state)\nthis:\n  unprot (resOf f)\n\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)\n 2. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "thus ?thesis"], ["proof (prove)\nusing this:\n  unprot (resOf f)\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "unfolding intF_def intT_def"], ["proof (prove)\nusing this:\n  unprot (resOf f)\n\ngoal (1 subgoal):\n 1. if unprot (resOf f)\n    then eintT (resOf f)\n          (if unprot (resOf f) \\<or> protFw (resOf f)\n           then eintF (Oldf f) (map2 ntsem (arOf f) al)\n           else eintF (Tag (resOf f))\n                 [eintF (Oldf f) (map2 ntsem (arOf f) al)])\n    else if protFw (resOf f)\n         then eintT (resOf f)\n               (if unprot (resOf f) \\<or> protFw (resOf f)\n                then eintF (Oldf f) (map2 ntsem (arOf f) al)\n                else eintF (Tag (resOf f))\n                      [eintF (Oldf f) (map2 ntsem (arOf f) al)]) \\<and>\n              eintF (Tag (resOf f))\n               [if unprot (resOf f) \\<or> protFw (resOf f)\n                then eintF (Oldf f) (map2 ntsem (arOf f) al)\n                else eintF (Tag (resOf f))\n                      [eintF (Oldf f) (map2 ntsem (arOf f) al)]] =\n              (if unprot (resOf f) \\<or> protFw (resOf f)\n               then eintF (Oldf f) (map2 ntsem (arOf f) al)\n               else eintF (Tag (resOf f))\n                     [eintF (Oldf f) (map2 ntsem (arOf f) al)])\n         else eintT (resOf f)\n               (if unprot (resOf f) \\<or> protFw (resOf f)\n                then eintF (Oldf f) (map2 ntsem (arOf f) al)\n                else eintF (Tag (resOf f))\n                      [eintF (Oldf f) (map2 ntsem (arOf f) al)]) \\<and>\n              (if unprot (resOf f) \\<or> protFw (resOf f)\n               then eintF (Oldf f) (map2 ntsem (arOf f) al)\n               else eintF (Tag (resOf f))\n                     [eintF (Oldf f) (map2 ntsem (arOf f) al)])\n              \\<in> (eintF (Tag (resOf f)) \\<circ> singl) `\n                    {b. eintT (resOf f) b}", "by (simp add: 1)"], ["proof (state)\nthis:\n  intT (resOf f) (intF f al)\n\ngoal (1 subgoal):\n 1. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "case False"], ["proof (state)\nthis:\n  \\<not> unprot (resOf f)\n\ngoal (1 subgoal):\n 1. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "note unprot = False"], ["proof (state)\nthis:\n  \\<not> unprot (resOf f)\n\ngoal (1 subgoal):\n 1. \\<not> unprot (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "proof(cases \"protFw (resOf f)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)\n 2. \\<not> protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "case True"], ["proof (state)\nthis:\n  protFw (resOf f)\n\ngoal (2 subgoals):\n 1. protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)\n 2. \\<not> protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "thus ?thesis"], ["proof (prove)\nusing this:\n  protFw (resOf f)\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "using unprot TE_Tag[OF f 0] 1"], ["proof (prove)\nusing this:\n  protFw (resOf f)\n  \\<not> unprot (resOf f)\n  eintF (Tag (resOf f)) [eintF (Oldf f) (map2 ntsem (arOf f) al)] =\n  eintF (Oldf f) (map2 ntsem (arOf f) al)\n  eintT (resOf f) (eintF (Oldf f) (map2 ntsem (arOf f) al))\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "unfolding intF_def intT_def"], ["proof (prove)\nusing this:\n  protFw (resOf f)\n  \\<not> unprot (resOf f)\n  eintF (Tag (resOf f)) [eintF (Oldf f) (map2 ntsem (arOf f) al)] =\n  eintF (Oldf f) (map2 ntsem (arOf f) al)\n  eintT (resOf f) (eintF (Oldf f) (map2 ntsem (arOf f) al))\n\ngoal (1 subgoal):\n 1. if unprot (resOf f)\n    then eintT (resOf f)\n          (if unprot (resOf f) \\<or> protFw (resOf f)\n           then eintF (Oldf f) (map2 ntsem (arOf f) al)\n           else eintF (Tag (resOf f))\n                 [eintF (Oldf f) (map2 ntsem (arOf f) al)])\n    else if protFw (resOf f)\n         then eintT (resOf f)\n               (if unprot (resOf f) \\<or> protFw (resOf f)\n                then eintF (Oldf f) (map2 ntsem (arOf f) al)\n                else eintF (Tag (resOf f))\n                      [eintF (Oldf f) (map2 ntsem (arOf f) al)]) \\<and>\n              eintF (Tag (resOf f))\n               [if unprot (resOf f) \\<or> protFw (resOf f)\n                then eintF (Oldf f) (map2 ntsem (arOf f) al)\n                else eintF (Tag (resOf f))\n                      [eintF (Oldf f) (map2 ntsem (arOf f) al)]] =\n              (if unprot (resOf f) \\<or> protFw (resOf f)\n               then eintF (Oldf f) (map2 ntsem (arOf f) al)\n               else eintF (Tag (resOf f))\n                     [eintF (Oldf f) (map2 ntsem (arOf f) al)])\n         else eintT (resOf f)\n               (if unprot (resOf f) \\<or> protFw (resOf f)\n                then eintF (Oldf f) (map2 ntsem (arOf f) al)\n                else eintF (Tag (resOf f))\n                      [eintF (Oldf f) (map2 ntsem (arOf f) al)]) \\<and>\n              (if unprot (resOf f) \\<or> protFw (resOf f)\n               then eintF (Oldf f) (map2 ntsem (arOf f) al)\n               else eintF (Tag (resOf f))\n                     [eintF (Oldf f) (map2 ntsem (arOf f) al)])\n              \\<in> (eintF (Tag (resOf f)) \\<circ> singl) `\n                    {b. eintT (resOf f) b}", "by simp"], ["proof (state)\nthis:\n  intT (resOf f) (intF f al)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "case False"], ["proof (state)\nthis:\n  \\<not> protFw (resOf f)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "have \"eintT (resOf f) (intF f al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT (resOf f) (intF f al)", "using intF_def 0 1 TE_Tag f"], ["proof (prove)\nusing this:\n  intF ?f ?al \\<equiv>\n  if unprot (resOf ?f) \\<or> protFw (resOf ?f)\n  then eintF (Oldf ?f) (map2 ntsem (arOf ?f) ?al)\n  else eintF (Tag (resOf ?f)) [eintF (Oldf ?f) (map2 ntsem (arOf ?f) ?al)]\n  list_all2 eintT (arOf f) (map2 ntsem (arOf f) al)\n  eintT (resOf f) (eintF (Oldf f) (map2 ntsem (arOf f) al))\n  \\<lbrakk>wtFsym ?f; list_all2 eintT (arOf ?f) ?al\\<rbrakk>\n  \\<Longrightarrow> eintF (Tag (resOf ?f)) [eintF (Oldf ?f) ?al] =\n                    eintF (Oldf ?f) ?al\n  wtFsym f\n\ngoal (1 subgoal):\n 1. eintT (resOf f) (intF f al)", "by auto"], ["proof (state)\nthis:\n  eintT (resOf f) (intF f al)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "moreover"], ["proof (state)\nthis:\n  eintT (resOf f) (intF f al)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "have\n      \"intF f al \\<in> (eintF (Tag (resOf f)) o singl) ` {b. eintT (resOf f) b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intF f al\n    \\<in> (eintF (Tag (resOf f)) \\<circ> singl) ` {b. eintT (resOf f) b}", "unfolding intF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) al)\n     else eintF (Tag (resOf f)) [eintF (Oldf f) (map2 ntsem (arOf f) al)])\n    \\<in> (eintF (Tag (resOf f)) \\<circ> singl) ` {b. eintT (resOf f) b}", "using 1 unprot False"], ["proof (prove)\nusing this:\n  eintT (resOf f) (eintF (Oldf f) (map2 ntsem (arOf f) al))\n  \\<not> unprot (resOf f)\n  \\<not> protFw (resOf f)\n\ngoal (1 subgoal):\n 1. (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) al)\n     else eintF (Tag (resOf f)) [eintF (Oldf f) (map2 ntsem (arOf f) al)])\n    \\<in> (eintF (Tag (resOf f)) \\<circ> singl) ` {b. eintT (resOf f) b}", "by (auto simp add: singl_def)"], ["proof (state)\nthis:\n  intF f al\n  \\<in> (eintF (Tag (resOf f)) \\<circ> singl) ` {b. eintT (resOf f) b}\n\ngoal (1 subgoal):\n 1. \\<not> protFw (resOf f) \\<Longrightarrow> intT (resOf f) (intF f al)", "ultimately"], ["proof (chain)\npicking this:\n  eintT (resOf f) (intF f al)\n  intF f al\n  \\<in> (eintF (Tag (resOf f)) \\<circ> singl) ` {b. eintT (resOf f) b}", "show ?thesis"], ["proof (prove)\nusing this:\n  eintT (resOf f) (intF f al)\n  intF f al\n  \\<in> (eintF (Tag (resOf f)) \\<circ> singl) ` {b. eintT (resOf f) b}\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "using False"], ["proof (prove)\nusing this:\n  eintT (resOf f) (intF f al)\n  intF f al\n  \\<in> (eintF (Tag (resOf f)) \\<circ> singl) ` {b. eintT (resOf f) b}\n  \\<not> protFw (resOf f)\n\ngoal (1 subgoal):\n 1. intT (resOf f) (intF f al)", "unfolding intT_def"], ["proof (prove)\nusing this:\n  eintT (resOf f) (intF f al)\n  intF f al\n  \\<in> (eintF (Tag (resOf f)) \\<circ> singl) ` {b. eintT (resOf f) b}\n  \\<not> protFw (resOf f)\n\ngoal (1 subgoal):\n 1. if unprot (resOf f) then eintT (resOf f) (intF f al)\n    else if protFw (resOf f)\n         then eintT (resOf f) (intF f al) \\<and>\n              eintF (Tag (resOf f)) [intF f al] = intF f al\n         else eintT (resOf f) (intF f al) \\<and>\n              intF f al\n              \\<in> (eintF (Tag (resOf f)) \\<circ> singl) `\n                    {b. eintT (resOf f) b}", "by simp"], ["proof (state)\nthis:\n  intT (resOf f) (intF f al)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  intT (resOf f) (intF f al)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  intT (resOf f) (intF f al)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Struct: \"Struct wtFsym wtPsym arOf resOf intT intF intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.SStruct intT intF intP", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (resOf f) (intF f al)\n 3. intP = intP", "using NE_intT_forget wt_intF"], ["proof (prove)\nusing this:\n  \\<exists>a. intT ?\\<sigma> a\n  \\<lbrakk>wtFsym ?f; list_all2 intT (arOf ?f) ?al\\<rbrakk>\n  \\<Longrightarrow> intT (resOf ?f) (intF ?f ?al)\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> intT (resOf f) (intF f al)\n 3. intP = intP", "by auto"], ["", "end"], ["", "(* context ProblemIkTpart_TEModel *)"], ["", "sublocale ProblemIkTpart_TEModel < Ik? : Struct\nwhere intT = intT and intF = intF and intP = intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.SStruct intT intF intP", "using Struct"], ["proof (prove)\nusing this:\n  Ik.SStruct intT intF intP\n\ngoal (1 subgoal):\n 1. Ik.SStruct intT intF intP", "."], ["", "context ProblemIkTpart_TEModel begin"], ["", "(* The inverse of the tag function (required for translating environments backwards)*)"], ["", "definition\n\"invt \\<sigma> a \\<equiv> if unprot \\<sigma> \\<or> protFw \\<sigma> then a else (SOME b. eintT \\<sigma> b \\<and> eintF (Tag \\<sigma>) [b] = a)\""], ["", "lemma unprot_invt[simp]: \"unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow> invt \\<sigma> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow>\n    invt \\<sigma> a = a", "unfolding invt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unprot \\<sigma> \\<or> protFw \\<sigma> \\<Longrightarrow>\n    (if unprot \\<sigma> \\<or> protFw \\<sigma> then a\n     else SOME b. eintT \\<sigma> b \\<and> eintF (Tag \\<sigma>) [b] = a) =\n    a", "by auto"], ["", "lemma invt_invt_inImage:\nassumes \\<sigma>: \"\\<not> unprot \\<sigma>\" \"\\<not> protFw \\<sigma>\"\nand a: \"a \\<in> (eintF (Tag \\<sigma>) o singl) ` {b. eintT \\<sigma> b}\"\nshows \"eintT \\<sigma> (invt \\<sigma> a) \\<and> eintF (Tag \\<sigma>) [invt \\<sigma> a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT \\<sigma> (invt \\<sigma> a) \\<and>\n    eintF (Tag \\<sigma>) [invt \\<sigma> a] = a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. eintT \\<sigma> (invt \\<sigma> a) \\<and>\n    eintF (Tag \\<sigma>) [invt \\<sigma> a] = a", "obtain b where \"eintT \\<sigma> b\" and \"eintF (Tag \\<sigma>) [b] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>eintT \\<sigma> b; eintF (Tag \\<sigma>) [b] = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a"], ["proof (prove)\nusing this:\n  a \\<in> (eintF (Tag \\<sigma>) \\<circ> singl) ` {b. eintT \\<sigma> b}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>eintT \\<sigma> b; eintF (Tag \\<sigma>) [b] = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding image_def singl_def[symmetric]"], ["proof (prove)\nusing this:\n  a \\<in> {y. \\<exists>x\\<in>Collect (eintT \\<sigma>).\n                 y = (eintF (Tag \\<sigma>) \\<circ> singl) x}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>eintT \\<sigma> b;\n         eintF (Tag \\<sigma>) (singl b) = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eintT \\<sigma> b\n  eintF (Tag \\<sigma>) [b] = a\n\ngoal (1 subgoal):\n 1. eintT \\<sigma> (invt \\<sigma> a) \\<and>\n    eintF (Tag \\<sigma>) [invt \\<sigma> a] = a", "thus ?thesis"], ["proof (prove)\nusing this:\n  eintT \\<sigma> b\n  eintF (Tag \\<sigma>) [b] = a\n\ngoal (1 subgoal):\n 1. eintT \\<sigma> (invt \\<sigma> a) \\<and>\n    eintF (Tag \\<sigma>) [invt \\<sigma> a] = a", "using \\<sigma>"], ["proof (prove)\nusing this:\n  eintT \\<sigma> b\n  eintF (Tag \\<sigma>) [b] = a\n  \\<not> unprot \\<sigma>\n  \\<not> protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. eintT \\<sigma> (invt \\<sigma> a) \\<and>\n    eintF (Tag \\<sigma>) [invt \\<sigma> a] = a", "unfolding invt_def"], ["proof (prove)\nusing this:\n  eintT \\<sigma> b\n  eintF (Tag \\<sigma>) [b] = a\n  \\<not> unprot \\<sigma>\n  \\<not> protFw \\<sigma>\n\ngoal (1 subgoal):\n 1. eintT \\<sigma>\n     (if unprot \\<sigma> \\<or> protFw \\<sigma> then a\n      else SOME b.\n              eintT \\<sigma> b \\<and> eintF (Tag \\<sigma>) [b] = a) \\<and>\n    eintF (Tag \\<sigma>)\n     [if unprot \\<sigma> \\<or> protFw \\<sigma> then a\n      else SOME b. eintT \\<sigma> b \\<and> eintF (Tag \\<sigma>) [b] = a] =\n    a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eintT \\<sigma> b; eintF (Tag \\<sigma>) [b] = a;\n     \\<not> unprot \\<sigma>; \\<not> protFw \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> eintT \\<sigma>\n                       (SOME b.\n                           eintT \\<sigma> b \\<and>\n                           eintF (Tag \\<sigma>) [b] = a) \\<and>\n                      eintF (Tag \\<sigma>)\n                       [SOME b.\n                           eintT \\<sigma> b \\<and>\n                           eintF (Tag \\<sigma>) [b] = a] =\n                      a", "apply(rule someI_ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eintT \\<sigma> b; eintF (Tag \\<sigma>) [b] = a;\n     \\<not> unprot \\<sigma>; \\<not> protFw \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         eintT \\<sigma> x \\<and>\n                         eintF (Tag \\<sigma>) [x] = a", "by auto"], ["proof (state)\nthis:\n  eintT \\<sigma> (invt \\<sigma> a) \\<and>\n  eintF (Tag \\<sigma>) [invt \\<sigma> a] = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas invt[simp] = invt_invt_inImage[THEN conjunct1]"], ["", "lemmas invt_inImage[simp] = invt_invt_inImage[THEN conjunct2]"], ["", "(* We translate the environments of the tag-extended-problem model\nto environments of its original-signature reduct: *)"], ["", "term invt"], ["", "definition \"eenv \\<xi> x \\<equiv> invt (tpOfV x) (\\<xi> x)\""], ["", "lemma wt_eenv:\nassumes \\<xi>: \"Ik.wtE \\<xi>\"  shows \"TE.wtE (eenv \\<xi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.wtE (eenv \\<xi>)", "unfolding TE.wtE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. eintT (TE.tpOfV x) (eenv \\<xi> x)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. eintT (TE.tpOfV x) (eenv \\<xi> x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. eintT (TE.tpOfV x) (eenv \\<xi> x)", "let ?\\<sigma> = \"TE.tpOfV x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. eintT (TE.tpOfV x) (eenv \\<xi> x)", "show \"eintT ?\\<sigma> (eenv \\<xi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (eenv \\<xi> x)", "proof(cases \"unprot ?\\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow> eintT (TE.tpOfV x) (eenv \\<xi> x)\n 2. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "case True"], ["proof (state)\nthis:\n  unprot (TE.tpOfV x)\n\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow> eintT (TE.tpOfV x) (eenv \\<xi> x)\n 2. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "note unprot = True"], ["proof (state)\nthis:\n  unprot (TE.tpOfV x)\n\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow> eintT (TE.tpOfV x) (eenv \\<xi> x)\n 2. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (eenv \\<xi> x)", "unfolding eenv_def"], ["proof (prove)\nusing this:\n  unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (invt (TE.tpOfV x) (\\<xi> x))", "by (metis \\<xi> Ik.wtTE_intT intT_def unprot_invt)"], ["proof (state)\nthis:\n  eintT (TE.tpOfV x) (eenv \\<xi> x)\n\ngoal (1 subgoal):\n 1. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "case False"], ["proof (state)\nthis:\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "note unprot = False"], ["proof (state)\nthis:\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (eenv \\<xi> x)", "proof(cases \"protFw ?\\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. protFw (TE.tpOfV x) \\<Longrightarrow> eintT (TE.tpOfV x) (eenv \\<xi> x)\n 2. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "case True"], ["proof (state)\nthis:\n  protFw (TE.tpOfV x)\n\ngoal (2 subgoals):\n 1. protFw (TE.tpOfV x) \\<Longrightarrow> eintT (TE.tpOfV x) (eenv \\<xi> x)\n 2. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (eenv \\<xi> x)", "unfolding eenv_def"], ["proof (prove)\nusing this:\n  protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (invt (TE.tpOfV x) (\\<xi> x))", "using unprot \\<xi>"], ["proof (prove)\nusing this:\n  protFw (TE.tpOfV x)\n  \\<not> unprot (TE.tpOfV x)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (invt (TE.tpOfV x) (\\<xi> x))", "by (metis Ik.wtTE_intT intT_def unprot_invt)"], ["proof (state)\nthis:\n  eintT (TE.tpOfV x) (eenv \\<xi> x)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "case False"], ["proof (state)\nthis:\n  \\<not> protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    eintT (TE.tpOfV x) (eenv \\<xi> x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (eenv \\<xi> x)", "unfolding eenv_def"], ["proof (prove)\nusing this:\n  \\<not> protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (invt (TE.tpOfV x) (\\<xi> x))", "using unprot \\<xi>"], ["proof (prove)\nusing this:\n  \\<not> protFw (TE.tpOfV x)\n  \\<not> unprot (TE.tpOfV x)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. eintT (TE.tpOfV x) (invt (TE.tpOfV x) (\\<xi> x))", "by (metis (no_types) \\<xi> Ik.wtE_def intT_def invt)"], ["proof (state)\nthis:\n  eintT (TE.tpOfV x) (eenv \\<xi> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eintT (TE.tpOfV x) (eenv \\<xi> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eintT (TE.tpOfV x) (eenv \\<xi> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_tNN[simp]:\nassumes T: \"Ik.Ik.wt T\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.int (eenv \\<xi>) (tNN T) = Ik.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN T) = Ik.int \\<xi> T", "using T"], ["proof (prove)\nusing this:\n  Ik.wt T\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN T) = Ik.int \\<xi> T", "proof(induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       Ik.wt (Var x) \\<Longrightarrow>\n       TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "case (Var x)"], ["proof (state)\nthis:\n  Ik.wt (Var x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       Ik.wt (Var x) \\<Longrightarrow>\n       TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "let ?\\<sigma> = \"TE.tpOfV x\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       Ik.wt (Var x) \\<Longrightarrow>\n       TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "proof(cases \"unprot ?\\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "case False"], ["proof (state)\nthis:\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "note unprot = False"], ["proof (state)\nthis:\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "proof(cases \"protFw ?\\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "case True"], ["proof (state)\nthis:\n  protFw (TE.tpOfV x)\n\ngoal (2 subgoals):\n 1. protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "using unprot \\<xi>"], ["proof (prove)\nusing this:\n  protFw (TE.tpOfV x)\n  \\<not> unprot (TE.tpOfV x)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "unfolding eenv_def Ik.wtE_def intT_def"], ["proof (prove)\nusing this:\n  protFw (TE.tpOfV x)\n  \\<not> unprot (TE.tpOfV x)\n  \\<forall>x.\n     if unprot (TE.tpOfV x) then eintT (TE.tpOfV x) (\\<xi> x)\n     else if protFw (TE.tpOfV x)\n          then eintT (TE.tpOfV x) (\\<xi> x) \\<and>\n               eintF (Tag (TE.tpOfV x)) [\\<xi> x] = \\<xi> x\n          else eintT (TE.tpOfV x) (\\<xi> x) \\<and>\n               \\<xi> x\n               \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) `\n                     {b. eintT (TE.tpOfV x) b}\n\ngoal (1 subgoal):\n 1. TE.int (\\<lambda>a. invt (TE.tpOfV a) (\\<xi> a)) (tNN (Var x)) =\n    Ik.int \\<xi> (Var x)", "by simp"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "case False"], ["proof (state)\nthis:\n  \\<not> protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "hence \"\\<xi> x \\<in> (eintF (Tag ?\\<sigma>) \\<circ> singl) ` {b. eintT ?\\<sigma> b}\""], ["proof (prove)\nusing this:\n  \\<not> protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<xi> x\n    \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) `\n          {b. eintT (TE.tpOfV x) b}", "using \\<xi> unprot"], ["proof (prove)\nusing this:\n  \\<not> protFw (TE.tpOfV x)\n  Ik.wtE \\<xi>\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<xi> x\n    \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) `\n          {b. eintT (TE.tpOfV x) b}", "unfolding wtE_def intT_def singl_def[abs_def]"], ["proof (prove)\nusing this:\n  \\<not> protFw (TE.tpOfV x)\n  \\<forall>x.\n     if unprot (TE.tpOfV x) then eintT (TE.tpOfV x) (\\<xi> x)\n     else if protFw (TE.tpOfV x)\n          then eintT (TE.tpOfV x) (\\<xi> x) \\<and>\n               eintF (Tag (TE.tpOfV x)) [\\<xi> x] = \\<xi> x\n          else eintT (TE.tpOfV x) (\\<xi> x) \\<and>\n               \\<xi> x\n               \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> (\\<lambda>a. [a])) `\n                     {b. eintT (TE.tpOfV x) b}\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<xi> x\n    \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> (\\<lambda>a. [a])) `\n          {b. eintT (TE.tpOfV x) b}", "by (simp cong del: image_cong_simp)"], ["proof (state)\nthis:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "using unprot"], ["proof (prove)\nusing this:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "unfolding eenv_def"], ["proof (prove)\nusing this:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. TE.int (\\<lambda>a. invt (TE.tpOfV a) (\\<xi> a)) (tNN (Var x)) =\n    Ik.int \\<xi> (Var x)", "using False"], ["proof (prove)\nusing this:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n  \\<not> unprot (TE.tpOfV x)\n  \\<not> protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. TE.int (\\<lambda>a. invt (TE.tpOfV a) (\\<xi> a)) (tNN (Var x)) =\n    Ik.int \\<xi> (Var x)", "by simp"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n\ngoal (1 subgoal):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)", "qed(unfold eenv_def, simp)"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tNN (Var x)) = Ik.int \\<xi> (Var x)\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "let ?e\\<xi> = \"eenv \\<xi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "let ?ar = \"arOf f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "let ?r = \"resOf f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "have l: \"length ?ar = length Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (arOf f) = length Tl", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. length (arOf f) = length Tl", "by simp"], ["proof (state)\nthis:\n  length (arOf f) = length Tl\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "have 0: \"map2 ntsem ?ar (map (Ik.int \\<xi>) Tl) =\n           map (TE.int ?e\\<xi> \\<circ> tNN) Tl\"  (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "proof(rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl)\n 2. \\<And>i.\n       i < length\n            (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) \\<Longrightarrow>\n       map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n       map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl)\n 2. \\<And>i.\n       i < length\n            (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) \\<Longrightarrow>\n       map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n       map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "assume \"i < length ?L\""], ["proof (state)\nthis:\n  i < length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n\ngoal (2 subgoals):\n 1. length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl)\n 2. \\<And>i.\n       i < length\n            (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) \\<Longrightarrow>\n       map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n       map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "hence i: \"i < length ?ar\""], ["proof (prove)\nusing this:\n  i < length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n\ngoal (1 subgoal):\n 1. i < length (arOf f)", "using l"], ["proof (prove)\nusing this:\n  i < length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n  length (arOf f) = length Tl\n\ngoal (1 subgoal):\n 1. i < length (arOf f)", "by simp"], ["proof (state)\nthis:\n  i < length (arOf f)\n\ngoal (2 subgoals):\n 1. length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl)\n 2. \\<And>i.\n       i < length\n            (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) \\<Longrightarrow>\n       map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n       map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "hence 1: \"TE.int (eenv \\<xi>) (tNN (Tl!i)) = Ik.int \\<xi> (Tl!i)\""], ["proof (prove)\nusing this:\n  i < length (arOf f)\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN (Tl ! i)) = Ik.int \\<xi> (Tl ! i)", "using Fn"], ["proof (prove)\nusing this:\n  i < length (arOf f)\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN (Tl ! i)) = Ik.int \\<xi> (Tl ! i)", "by (auto simp: list_all_length)"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tNN (Tl ! i)) = Ik.int \\<xi> (Tl ! i)\n\ngoal (2 subgoals):\n 1. length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl)\n 2. \\<And>i.\n       i < length\n            (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) \\<Longrightarrow>\n       map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n       map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "have 2: \"?ar ! i = Ik.Ik.tpOf (Tl!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arOf f ! i = Ik.tpOf (Tl ! i)", "using Fn i"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n  i < length (arOf f)\n\ngoal (1 subgoal):\n 1. arOf f ! i = Ik.tpOf (Tl ! i)", "by simp"], ["proof (state)\nthis:\n  arOf f ! i = Ik.tpOf (Tl ! i)\n\ngoal (2 subgoals):\n 1. length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl)\n 2. \\<And>i.\n       i < length\n            (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) \\<Longrightarrow>\n       map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n       map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "have 3: \"intT (?ar ! i) (Ik.int \\<xi> (Tl ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (arOf f ! i) (Ik.int \\<xi> (Tl ! i))", "unfolding 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))", "apply(rule wt_int)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ik.wtE \\<xi>\n 2. Ik.wt (Tl ! i)", "using Fn \\<xi> i"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n  Ik.wtE \\<xi>\n  i < length (arOf f)\n\ngoal (2 subgoals):\n 1. Ik.wtE \\<xi>\n 2. Ik.wt (Tl ! i)", "by (auto simp: list_all_length)"], ["proof (state)\nthis:\n  intT (arOf f ! i) (Ik.int \\<xi> (Tl ! i))\n\ngoal (2 subgoals):\n 1. length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl)\n 2. \\<And>i.\n       i < length\n            (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) \\<Longrightarrow>\n       map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n       map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "show \"?L!i = ?R!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "apply (cases \"unprot (?ar ! i) \\<or> protFw (?ar ! i)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (arOf f ! i) \\<or> protFw (arOf f ! i) \\<Longrightarrow>\n    map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i\n 2. \\<not> (unprot (arOf f ! i) \\<or> protFw (arOf f ! i)) \\<Longrightarrow>\n    map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "using i 1 l 3"], ["proof (prove)\nusing this:\n  i < length (arOf f)\n  TE.int (eenv \\<xi>) (tNN (Tl ! i)) = Ik.int \\<xi> (Tl ! i)\n  length (arOf f) = length Tl\n  intT (arOf f ! i) (Ik.int \\<xi> (Tl ! i))\n\ngoal (2 subgoals):\n 1. unprot (arOf f ! i) \\<or> protFw (arOf f ! i) \\<Longrightarrow>\n    map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i\n 2. \\<not> (unprot (arOf f ! i) \\<or> protFw (arOf f ! i)) \\<Longrightarrow>\n    map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "unfolding intT_def"], ["proof (prove)\nusing this:\n  i < length (arOf f)\n  TE.int (eenv \\<xi>) (tNN (Tl ! i)) = Ik.int \\<xi> (Tl ! i)\n  length (arOf f) = length Tl\n  if unprot (arOf f ! i) then eintT (arOf f ! i) (Ik.int \\<xi> (Tl ! i))\n  else if protFw (arOf f ! i)\n       then eintT (arOf f ! i) (Ik.int \\<xi> (Tl ! i)) \\<and>\n            eintF (Tag (arOf f ! i)) [Ik.int \\<xi> (Tl ! i)] =\n            Ik.int \\<xi> (Tl ! i)\n       else eintT (arOf f ! i) (Ik.int \\<xi> (Tl ! i)) \\<and>\n            Ik.int \\<xi> (Tl ! i)\n            \\<in> (eintF (Tag (arOf f ! i)) \\<circ> singl) `\n                  {b. eintT (arOf f ! i) b}\n\ngoal (2 subgoals):\n 1. unprot (arOf f ! i) \\<or> protFw (arOf f ! i) \\<Longrightarrow>\n    map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i\n 2. \\<not> (unprot (arOf f ! i) \\<or> protFw (arOf f ! i)) \\<Longrightarrow>\n    map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i", "by auto"], ["proof (state)\nthis:\n  map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) ! i =\n  map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i\n\ngoal (1 subgoal):\n 1. length (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl)", "qed(insert l, auto)"], ["proof (state)\nthis:\n  map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) =\n  map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "apply(cases \"unprot ?r \\<or> protFw ?r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "unfolding Ik.int.simps TE.int.simps tT.simps"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = intF f (map (Ik.int \\<xi>) Tl)\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = intF f (map (Ik.int \\<xi>) Tl)", "unfolding intF_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n    (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n     else eintF (Tag (resOf f))\n           [eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))])\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n    (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n     else eintF (Tag (resOf f))\n           [eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))])", "using Fn 0"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tNN a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n  map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) =\n  map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl\n\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n    (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n     else eintF (Tag (resOf f))\n           [eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))])\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n    (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n     else eintF (Tag (resOf f))\n           [eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))])", "by auto"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_int_tNN[simp]:\nassumes Tl: \"list_all Ik.Ik.wt Tl\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows\n\"map2 ntsem (map Ik.Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "assume i: \"i < length Tl\""], ["proof (state)\nthis:\n  i < length Tl\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "hence wt: \"Ik.Ik.wt (Tl!i)\""], ["proof (prove)\nusing this:\n  i < length Tl\n\ngoal (1 subgoal):\n 1. Ik.wt (Tl ! i)", "using Tl"], ["proof (prove)\nusing this:\n  i < length Tl\n  list_all Ik.wt Tl\n\ngoal (1 subgoal):\n 1. Ik.wt (Tl ! i)", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  i < length Tl\n  \\<forall>n<length Tl. Ik.wt (Tl ! n)\n\ngoal (1 subgoal):\n 1. Ik.wt (Tl ! i)", "by simp"], ["proof (state)\nthis:\n  Ik.wt (Tl ! i)\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "have \"intT (Ik.Ik.tpOf (Tl!i)) (Ik.int \\<xi> (Tl!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))", "using Ik.wt_int[OF \\<xi> wt]"], ["proof (prove)\nusing this:\n  intT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))\n\ngoal (1 subgoal):\n 1. intT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))", "."], ["proof (state)\nthis:\n  intT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "}"], ["proof (state)\nthis:\n  ?i13 < length Tl \\<Longrightarrow>\n  intT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  intT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "using [[unfold_abs_def = false]]"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  intT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "using assms"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  intT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n  list_all Ik.wt Tl\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "unfolding intT_def list_all_length"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  if unprot (Ik.tpOf (Tl ! ?i13))\n  then eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n  else if protFw (Ik.tpOf (Tl ! ?i13))\n       then eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13)) \\<and>\n            eintF (Tag (Ik.tpOf (Tl ! ?i13))) [Ik.int \\<xi> (Tl ! ?i13)] =\n            Ik.int \\<xi> (Tl ! ?i13)\n       else eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13)) \\<and>\n            Ik.int \\<xi> (Tl ! ?i13)\n            \\<in> (eintF (Tag (Ik.tpOf (Tl ! ?i13))) \\<circ> singl) `\n                  {b. eintT (Ik.tpOf (Tl ! ?i13)) b}\n  \\<forall>n<length Tl. Ik.wt (Tl ! n)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "unfolding list_eq_iff"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  if unprot (Ik.tpOf (Tl ! ?i13))\n  then eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n  else if protFw (Ik.tpOf (Tl ! ?i13))\n       then eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13)) \\<and>\n            eintF (Tag (Ik.tpOf (Tl ! ?i13))) [Ik.int \\<xi> (Tl ! ?i13)] =\n            Ik.int \\<xi> (Tl ! ?i13)\n       else eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13)) \\<and>\n            Ik.int \\<xi> (Tl ! ?i13)\n            \\<in> (eintF (Tag (Ik.tpOf (Tl ! ?i13))) \\<circ> singl) `\n                  {b. eintT (Ik.tpOf (Tl ! ?i13)) b}\n  \\<forall>n<length Tl. Ik.wt (Tl ! n)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. length (map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl) \\<and>\n    (\\<forall>i<length\n                 (map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl)).\n        map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) ! i =\n        map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl ! i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>i.\n                   i < length Tl \\<Longrightarrow>\n                   if unprot (Ik.tpOf (Tl ! i))\n                   then eintT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))\n                   else if protFw (Ik.tpOf (Tl ! i))\n                        then eintT (Ik.tpOf (Tl ! i))\n                              (Ik.int \\<xi> (Tl ! i)) \\<and>\n                             eintF (Tag (Ik.tpOf (Tl ! i)))\n                              [Ik.int \\<xi> (Tl ! i)] =\n                             Ik.int \\<xi> (Tl ! i)\n                        else eintT (Ik.tpOf (Tl ! i))\n                              (Ik.int \\<xi> (Tl ! i)) \\<and>\n                             Ik.int \\<xi> (Tl ! i)\n                             \\<in> (eintF (Tag (Ik.tpOf (Tl ! i))) \\<circ>\n                                    singl) `\n                                   {b. eintT (Ik.tpOf (Tl ! i)) b};\n        \\<forall>n<length Tl. Ik.wt (Tl ! n); Ik.wtE \\<xi>;\n        i < length Tl\\<rbrakk>\n       \\<Longrightarrow> ntsem (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i)) =\n                         Ik.int \\<xi> (Tl ! i)", "by (metis inImage_ntsem unprot_ntsem)"], ["proof (state)\nthis:\n  map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n  map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_t[simp]:\nassumes T: \"Ik.Ik.wt T\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.int (eenv \\<xi>) (tT T) = Ik.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tT T) = Ik.int \\<xi> T", "using T"], ["proof (prove)\nusing this:\n  Ik.wt T\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tT T) = Ik.int \\<xi> T", "proof(induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       Ik.wt (Var x) \\<Longrightarrow>\n       TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "case (Var x)"], ["proof (state)\nthis:\n  Ik.wt (Var x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       Ik.wt (Var x) \\<Longrightarrow>\n       TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "let ?\\<sigma> = \"tpOfV x\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       Ik.wt (Var x) \\<Longrightarrow>\n       TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "proof(cases \"unprot ?\\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "case False"], ["proof (state)\nthis:\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "note unprot = False"], ["proof (state)\nthis:\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "proof(cases \"protFw ?\\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "case True"], ["proof (state)\nthis:\n  protFw (TE.tpOfV x)\n\ngoal (2 subgoals):\n 1. protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n 2. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "using unprot \\<xi>"], ["proof (prove)\nusing this:\n  protFw (TE.tpOfV x)\n  \\<not> unprot (TE.tpOfV x)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "unfolding eenv_def Ik.wtE_def intT_def"], ["proof (prove)\nusing this:\n  protFw (TE.tpOfV x)\n  \\<not> unprot (TE.tpOfV x)\n  \\<forall>x.\n     if unprot (TE.tpOfV x) then eintT (TE.tpOfV x) (\\<xi> x)\n     else if protFw (TE.tpOfV x)\n          then eintT (TE.tpOfV x) (\\<xi> x) \\<and>\n               eintF (Tag (TE.tpOfV x)) [\\<xi> x] = \\<xi> x\n          else eintT (TE.tpOfV x) (\\<xi> x) \\<and>\n               \\<xi> x\n               \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) `\n                     {b. eintT (TE.tpOfV x) b}\n\ngoal (1 subgoal):\n 1. TE.int (\\<lambda>a. invt (TE.tpOfV a) (\\<xi> a)) (tT (Var x)) =\n    Ik.int \\<xi> (Var x)", "by simp"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "case False"], ["proof (state)\nthis:\n  \\<not> protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "hence \"\\<xi> x \\<in> (eintF (Tag ?\\<sigma>) \\<circ> singl) ` {b. eintT ?\\<sigma> b}\""], ["proof (prove)\nusing this:\n  \\<not> protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<xi> x\n    \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) `\n          {b. eintT (TE.tpOfV x) b}", "using \\<xi> unprot"], ["proof (prove)\nusing this:\n  \\<not> protFw (TE.tpOfV x)\n  Ik.wtE \\<xi>\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<xi> x\n    \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) `\n          {b. eintT (TE.tpOfV x) b}", "unfolding wtE_def intT_def singl_def[abs_def]"], ["proof (prove)\nusing this:\n  \\<not> protFw (TE.tpOfV x)\n  \\<forall>x.\n     if unprot (TE.tpOfV x) then eintT (TE.tpOfV x) (\\<xi> x)\n     else if protFw (TE.tpOfV x)\n          then eintT (TE.tpOfV x) (\\<xi> x) \\<and>\n               eintF (Tag (TE.tpOfV x)) [\\<xi> x] = \\<xi> x\n          else eintT (TE.tpOfV x) (\\<xi> x) \\<and>\n               \\<xi> x\n               \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> (\\<lambda>a. [a])) `\n                     {b. eintT (TE.tpOfV x) b}\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. \\<xi> x\n    \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> (\\<lambda>a. [a])) `\n          {b. eintT (TE.tpOfV x) b}", "by (simp cong del: image_cong_simp)"], ["proof (state)\nthis:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n\ngoal (1 subgoal):\n 1. \\<not> protFw (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "using unprot"], ["proof (prove)\nusing this:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "unfolding eenv_def"], ["proof (prove)\nusing this:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n  \\<not> unprot (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. TE.int (\\<lambda>a. invt (TE.tpOfV a) (\\<xi> a)) (tT (Var x)) =\n    Ik.int \\<xi> (Var x)", "using False"], ["proof (prove)\nusing this:\n  \\<xi> x\n  \\<in> (eintF (Tag (TE.tpOfV x)) \\<circ> singl) ` {b. eintT (TE.tpOfV x) b}\n  \\<not> unprot (TE.tpOfV x)\n  \\<not> protFw (TE.tpOfV x)\n\ngoal (1 subgoal):\n 1. TE.int (\\<lambda>a. invt (TE.tpOfV a) (\\<xi> a)) (tT (Var x)) =\n    Ik.int \\<xi> (Var x)", "by simp"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n\ngoal (1 subgoal):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)", "qed(unfold eenv_def, simp)"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tT (Var x)) = Ik.int \\<xi> (Var x)\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "let ?e\\<xi> = \"eenv \\<xi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "let ?ar = \"arOf f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "let ?r = \"resOf f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "have l: \"length ?ar = length Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (arOf f) = length Tl", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. length (arOf f) = length Tl", "by simp"], ["proof (state)\nthis:\n  length (arOf f) = length Tl\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "have ar: \"?ar = map Ik.Ik.tpOf Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arOf f = map Ik.tpOf Tl", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. arOf f = map Ik.tpOf Tl", "by simp"], ["proof (state)\nthis:\n  arOf f = map Ik.tpOf Tl\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "have 0: \"map2 ntsem ?ar (map (Ik.int \\<xi>) Tl) = map (TE.int ?e\\<xi> \\<circ> tNN) Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "unfolding ar"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl", "apply(rule map_int_tNN[OF _ \\<xi>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all Ik.wt Tl", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. list_all Ik.wt Tl", "by simp"], ["proof (state)\nthis:\n  map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) =\n  map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl\n\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     Ik.wt a \\<longrightarrow>\n                     TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n                 Tl;\n        Ik.wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> TE.int (eenv \\<xi>) (tT (Fn f Tl)) =\n                         Ik.int \\<xi> (Fn f Tl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.int (eenv \\<xi>) (tT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "apply(cases \"unprot ?r \\<or> protFw ?r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)", "unfolding  Ik.int.simps TE.int.simps tT.simps"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = intF f (map (Ik.int \\<xi>) Tl)\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) = intF f (map (Ik.int \\<xi>) Tl)", "unfolding intF_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n    (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n     else eintF (Tag (resOf f))\n           [eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))])\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n    (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n     else eintF (Tag (resOf f))\n           [eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))])", "using Fn 0"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       Ik.wt a \\<longrightarrow>\n       TE.int (eenv \\<xi>) (tT a) = Ik.int \\<xi> a)\n   Tl\n  Ik.wt (Fn f Tl)\n  map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl) =\n  map (TE.int (eenv \\<xi>) \\<circ> tNN) Tl\n\ngoal (2 subgoals):\n 1. unprot (resOf f) \\<or> protFw (resOf f) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n    (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n     else eintF (Tag (resOf f))\n           [eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))])\n 2. \\<not> (unprot (resOf f) \\<or> protFw (resOf f)) \\<Longrightarrow>\n    TE.int (eenv \\<xi>) (tNN (Fn f Tl)) =\n    (if unprot (resOf f) \\<or> protFw (resOf f)\n     then eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))\n     else eintF (Tag (resOf f))\n           [eintF (Oldf f) (map2 ntsem (arOf f) (map (Ik.int \\<xi>) Tl))])", "by auto"], ["proof (state)\nthis:\n  TE.int (eenv \\<xi>) (tT (Fn f Tl)) = Ik.int \\<xi> (Fn f Tl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_int_t[simp]:\nassumes Tl: \"list_all Ik.Ik.wt Tl\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows\n\"map2 ntsem (map Ik.Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n map (TE.int (eenv \\<xi>) \\<circ> tT) Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "assume i: \"i < length Tl\""], ["proof (state)\nthis:\n  i < length Tl\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "hence wt: \"Ik.Ik.wt (Tl!i)\""], ["proof (prove)\nusing this:\n  i < length Tl\n\ngoal (1 subgoal):\n 1. Ik.wt (Tl ! i)", "using Tl"], ["proof (prove)\nusing this:\n  i < length Tl\n  list_all Ik.wt Tl\n\ngoal (1 subgoal):\n 1. Ik.wt (Tl ! i)", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  i < length Tl\n  \\<forall>n<length Tl. Ik.wt (Tl ! n)\n\ngoal (1 subgoal):\n 1. Ik.wt (Tl ! i)", "by simp"], ["proof (state)\nthis:\n  Ik.wt (Tl ! i)\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "have \"intT (Ik.Ik.tpOf (Tl!i)) (Ik.int \\<xi> (Tl!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))", "using wt_int[OF \\<xi> wt]"], ["proof (prove)\nusing this:\n  intT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))\n\ngoal (1 subgoal):\n 1. intT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))", "."], ["proof (state)\nthis:\n  intT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "}"], ["proof (state)\nthis:\n  ?i13 < length Tl \\<Longrightarrow>\n  intT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  intT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "using [[unfold_abs_def = false]]"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  intT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "using assms"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  intT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n  list_all Ik.wt Tl\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "unfolding intT_def list_all_length"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  if unprot (Ik.tpOf (Tl ! ?i13))\n  then eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n  else if protFw (Ik.tpOf (Tl ! ?i13))\n       then eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13)) \\<and>\n            eintF (Tag (Ik.tpOf (Tl ! ?i13))) [Ik.int \\<xi> (Tl ! ?i13)] =\n            Ik.int \\<xi> (Tl ! ?i13)\n       else eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13)) \\<and>\n            Ik.int \\<xi> (Tl ! ?i13)\n            \\<in> (eintF (Tag (Ik.tpOf (Tl ! ?i13))) \\<circ> singl) `\n                  {b. eintT (Ik.tpOf (Tl ! ?i13)) b}\n  \\<forall>n<length Tl. Ik.wt (Tl ! n)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n    map (TE.int (eenv \\<xi>) \\<circ> tT) Tl", "unfolding list_eq_iff"], ["proof (prove)\nusing this:\n  ?i13 < length Tl \\<Longrightarrow>\n  if unprot (Ik.tpOf (Tl ! ?i13))\n  then eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13))\n  else if protFw (Ik.tpOf (Tl ! ?i13))\n       then eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13)) \\<and>\n            eintF (Tag (Ik.tpOf (Tl ! ?i13))) [Ik.int \\<xi> (Tl ! ?i13)] =\n            Ik.int \\<xi> (Tl ! ?i13)\n       else eintT (Ik.tpOf (Tl ! ?i13)) (Ik.int \\<xi> (Tl ! ?i13)) \\<and>\n            Ik.int \\<xi> (Tl ! ?i13)\n            \\<in> (eintF (Tag (Ik.tpOf (Tl ! ?i13))) \\<circ> singl) `\n                  {b. eintT (Ik.tpOf (Tl ! ?i13)) b}\n  \\<forall>n<length Tl. Ik.wt (Tl ! n)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. length (map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl)) =\n    length (map (TE.int (eenv \\<xi>) \\<circ> tT) Tl) \\<and>\n    (\\<forall>i<length\n                 (map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl)).\n        map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) ! i =\n        map (TE.int (eenv \\<xi>) \\<circ> tT) Tl ! i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>i.\n                   i < length Tl \\<Longrightarrow>\n                   if unprot (Ik.tpOf (Tl ! i))\n                   then eintT (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i))\n                   else if protFw (Ik.tpOf (Tl ! i))\n                        then eintT (Ik.tpOf (Tl ! i))\n                              (Ik.int \\<xi> (Tl ! i)) \\<and>\n                             eintF (Tag (Ik.tpOf (Tl ! i)))\n                              [Ik.int \\<xi> (Tl ! i)] =\n                             Ik.int \\<xi> (Tl ! i)\n                        else eintT (Ik.tpOf (Tl ! i))\n                              (Ik.int \\<xi> (Tl ! i)) \\<and>\n                             Ik.int \\<xi> (Tl ! i)\n                             \\<in> (eintF (Tag (Ik.tpOf (Tl ! i))) \\<circ>\n                                    singl) `\n                                   {b. eintT (Ik.tpOf (Tl ! i)) b};\n        \\<forall>n<length Tl. Ik.wt (Tl ! n); Ik.wtE \\<xi>;\n        i < length Tl\\<rbrakk>\n       \\<Longrightarrow> ntsem (Ik.tpOf (Tl ! i)) (Ik.int \\<xi> (Tl ! i)) =\n                         Ik.int \\<xi> (Tl ! i)", "by (metis inImage_ntsem unprot_ntsem)"], ["proof (state)\nthis:\n  map2 ntsem (map Ik.tpOf Tl) (map (Ik.int \\<xi>) Tl) =\n  map (TE.int (eenv \\<xi>) \\<circ> tT) Tl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma satL_tL[simp]:\nassumes l: \"Ik.Ik.wtL l\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.satL (eenv \\<xi>) (tL l) \\<longleftrightarrow> Ik.satL \\<xi> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.satL (eenv \\<xi>) (tL l) = Ik.satL \\<xi> l", "using assms"], ["proof (prove)\nusing this:\n  Ik.wtL l\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. TE.satL (eenv \\<xi>) (tL l) = Ik.satL \\<xi> l", "apply(cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Ik.wtL l; Ik.wtE \\<xi>; l = Pos x1\\<rbrakk>\n       \\<Longrightarrow> TE.satL (eenv \\<xi>) (tL l) = Ik.satL \\<xi> l\n 2. \\<And>x2.\n       \\<lbrakk>Ik.wtL l; Ik.wtE \\<xi>; l = Neg x2\\<rbrakk>\n       \\<Longrightarrow> TE.satL (eenv \\<xi>) (tL l) = Ik.satL \\<xi> l", "apply (rename_tac [!] atm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>atm.\n       \\<lbrakk>Ik.wtL l; Ik.wtE \\<xi>; l = Pos atm\\<rbrakk>\n       \\<Longrightarrow> TE.satL (eenv \\<xi>) (tL l) = Ik.satL \\<xi> l\n 2. \\<And>atm.\n       \\<lbrakk>Ik.wtL l; Ik.wtE \\<xi>; l = Neg atm\\<rbrakk>\n       \\<Longrightarrow> TE.satL (eenv \\<xi>) (tL l) = Ik.satL \\<xi> l", "by (case_tac [!] atm) (auto simp add: intP_def)"], ["", "lemma satC_tC[simp]:\nassumes l: \"Ik.Ik.wtC c\" and \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.satC (eenv \\<xi>) (tC c) \\<longleftrightarrow> Ik.satC \\<xi> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.satC (eenv \\<xi>) (tC c) = Ik.satC \\<xi> c", "unfolding TE.satC_def Ik.satC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex (TE.satL (eenv \\<xi>)) (tC c) = list_ex (Ik.satL \\<xi>) c", "using assms"], ["proof (prove)\nusing this:\n  Ik.wtC c\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. list_ex (TE.satL (eenv \\<xi>)) (tC c) = list_ex (Ik.satL \\<xi>) c", "by (induct c, auto simp add: Ik.Ik.wtC_def tC_def)"], ["", "lemma satPB_tPB[simp]:\nassumes \\<xi>: \"Ik.wtE \\<xi>\"\nshows \"TE.satPB (eenv \\<xi>) (tC ` \\<Phi>) \\<longleftrightarrow> Ik.satPB \\<xi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.satPB (eenv \\<xi>) (tC ` \\<Phi>) = Ik.satPB \\<xi> \\<Phi>", "using Ik.wt_\\<Phi> assms"], ["proof (prove)\nusing this:\n  Ik.wtPB \\<Phi>\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. TE.satPB (eenv \\<xi>) (tC ` \\<Phi>) = Ik.satPB \\<xi> \\<Phi>", "unfolding TE.satPB_def Ik.satPB_def"], ["proof (prove)\nusing this:\n  Ik.wtPB \\<Phi>\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>tC ` \\<Phi>. TE.satC (eenv \\<xi>) c) =\n    (\\<forall>c\\<in>\\<Phi>. Ik.satC \\<xi> c)", "by (auto simp add: Ik.Ik.wtPB_def)"], ["", "lemma completeness: \"Ik.SAT \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.SAT \\<Phi>", "unfolding Ik.SAT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>. Ik.wtE \\<xi> \\<longrightarrow> Ik.satPB \\<xi> \\<Phi>", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "fix \\<xi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "assume \\<xi>: \"Ik.wtE \\<xi>\""], ["proof (state)\nthis:\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "hence \"TE.wtE (eenv \\<xi>)\""], ["proof (prove)\nusing this:\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. TE.wtE (eenv \\<xi>)", "by(rule wt_eenv)"], ["proof (state)\nthis:\n  TE.wtE (eenv \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "hence \"TE.satPB (eenv \\<xi>) tPB\""], ["proof (prove)\nusing this:\n  TE.wtE (eenv \\<xi>)\n\ngoal (1 subgoal):\n 1. TE.satPB (eenv \\<xi>) tPB", "by (rule TE.sat_\\<Phi>)"], ["proof (state)\nthis:\n  TE.satPB (eenv \\<xi>) tPB\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "hence \"TE.satPB (eenv \\<xi>) (tC ` \\<Phi>)\""], ["proof (prove)\nusing this:\n  TE.satPB (eenv \\<xi>) tPB\n\ngoal (1 subgoal):\n 1. TE.satPB (eenv \\<xi>) (tC ` \\<Phi>)", "unfolding tPB_def"], ["proof (prove)\nusing this:\n  TE.satPB (eenv \\<xi>) (tC ` \\<Phi> \\<union> Fax \\<union> Wax)\n\ngoal (1 subgoal):\n 1. TE.satPB (eenv \\<xi>) (tC ` \\<Phi>)", "by simp"], ["proof (state)\nthis:\n  TE.satPB (eenv \\<xi>) (tC ` \\<Phi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>. Ik.wtE \\<xi> \\<Longrightarrow> Ik.satPB \\<xi> \\<Phi>", "thus \"Ik.satPB \\<xi> \\<Phi>\""], ["proof (prove)\nusing this:\n  TE.satPB (eenv \\<xi>) (tC ` \\<Phi>)\n\ngoal (1 subgoal):\n 1. Ik.satPB \\<xi> \\<Phi>", "using \\<xi>"], ["proof (prove)\nusing this:\n  TE.satPB (eenv \\<xi>) (tC ` \\<Phi>)\n  Ik.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. Ik.satPB \\<xi> \\<Phi>", "by simp"], ["proof (state)\nthis:\n  Ik.satPB \\<xi> \\<Phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_completeness: \"Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.MModel intT intF intP", "by standard (rule completeness)"], ["", "end"], ["", "(* context ProblemIkTpart_TEModel *)\n\n(* Completeness theorem in sublocale form: Given a problem (with indicated\ntype partition) and a model for its tag-translated problem,\nwe obtain a model of the original problem: *)"], ["", "sublocale ProblemIkTpart_TEModel < O? : Model\nwhere intT = intT and intF = intF and intP = intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.MModel intT intF intP", "using T_completeness"], ["proof (prove)\nusing this:\n  Ik.MModel intT intF intP\n\ngoal (1 subgoal):\n 1. Ik.MModel intT intF intP", "."], ["", "subsection\\<open>The result of the tag translation is an infiniteness-augmented problem\\<close>"], ["", "(* Note that basic fact, merely stating that\nthe translation is well-defined between infiniteness-augmented problems,\nis only proved at this late stage since it requires completeness.\nThis is an interesting dependency, not spotted in the paper. *)"], ["", "sublocale ProblemIkTpart < TE? : Problem\nwhere wtFsym = TE_wtFsym and arOf = TE_arOf and resOf = TE_resOf\nand \\<Phi> = tPB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Problem TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.wtPB tPB", "by auto"], ["", "sublocale ProblemIkTpart < TE? : ProblemIk\nwhere wtFsym = TE_wtFsym and arOf = TE_arOf and resOf = TE_resOf\nand \\<Phi> = tPB"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIk TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB infTp", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "fix \\<sigma> eintT eintF eintP a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "assume \\<sigma>: \"infTp \\<sigma>\""], ["proof (state)\nthis:\n  infTp \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "assume M: \"Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB eintT eintF eintP\""], ["proof (state)\nthis:\n  TE.MModel eintT eintF eintP\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "let ?TE_intT = \"ProblemIkTpart_TEModel.intT prot protFw eintT eintF\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "let ?TE_intF = \"ProblemIkTpart_TEModel.intF arOf resOf prot protFw eintT eintF\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "let ?TE_intP = \"ProblemIkTpart_TEModel.intP parOf prot protFw eintT eintF eintP\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "have 0: \"ProblemIkTpart_TEModel wtFsym wtPsym arOf resOf parOf\n                                   \\<Phi> infTp prot protFw eintT eintF eintP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkTpart_TEModel wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot\n     protFw eintT eintF eintP", "using M"], ["proof (prove)\nusing this:\n  TE.MModel eintT eintF eintP\n\ngoal (1 subgoal):\n 1. ProblemIkTpart_TEModel wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot\n     protFw eintT eintF eintP", "unfolding ProblemIkTpart_TEModel_def"], ["proof (prove)\nusing this:\n  TE.MModel eintT eintF eintP\n\ngoal (1 subgoal):\n 1. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot\n     protFw \\<and>\n    TE.MModel eintT eintF eintP", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. TE.MModel eintT eintF eintP \\<Longrightarrow>\n    ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot protFw", "apply standard"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ProblemIkTpart_TEModel wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot\n   protFw eintT eintF eintP\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "hence MM: \"Ik.MModel ?TE_intT ?TE_intF ?TE_intP\""], ["proof (prove)\nusing this:\n  ProblemIkTpart_TEModel wtFsym wtPsym arOf resOf parOf \\<Phi> infTp prot\n   protFw eintT eintF eintP\n\ngoal (1 subgoal):\n 1. Ik.MModel (ProblemIkTpart_TEModel.intT prot protFw eintT eintF)\n     (ProblemIkTpart_TEModel.intF arOf resOf prot protFw eintT eintF)\n     (ProblemIkTpart_TEModel.intP parOf prot protFw eintT eintF eintP)", "by (rule ProblemIkTpart_TEModel.T_completeness)"], ["proof (state)\nthis:\n  Ik.MModel (ProblemIkTpart_TEModel.intT prot protFw eintT eintF)\n   (ProblemIkTpart_TEModel.intF arOf resOf prot protFw eintT eintF)\n   (ProblemIkTpart_TEModel.intP parOf prot protFw eintT eintF eintP)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "have \"infinite {a. ?TE_intT \\<sigma> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite\n     {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}", "using infTp[OF \\<sigma> MM]"], ["proof (prove)\nusing this:\n  infinite\n   {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n\ngoal (1 subgoal):\n 1. infinite\n     {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}", "."], ["proof (state)\nthis:\n  infinite\n   {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "moreover"], ["proof (state)\nthis:\n  infinite\n   {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "have \"{a. ?TE_intT \\<sigma> a} \\<subseteq> {a. eintT \\<sigma> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n    \\<subseteq> {a. eintT \\<sigma> a}", "using ProblemIkTpart_TEModel.intT_def[OF 0]"], ["proof (prove)\nusing this:\n  ProblemIkTpart_TEModel.intT prot protFw eintT eintF ?\\<sigma> ?a \\<equiv>\n  if unprot ?\\<sigma> then eintT ?\\<sigma> ?a\n  else if protFw ?\\<sigma>\n       then eintT ?\\<sigma> ?a \\<and> eintF (Tag ?\\<sigma>) [?a] = ?a\n       else eintT ?\\<sigma> ?a \\<and>\n            ?a \\<in> (eintF (Tag ?\\<sigma>) \\<circ> singl) `\n                     {b. eintT ?\\<sigma> b}\n\ngoal (1 subgoal):\n 1. {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n    \\<subseteq> {a. eintT \\<sigma> a}", "by auto"], ["proof (state)\nthis:\n  {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n  \\<subseteq> {a. eintT \\<sigma> a}\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> intT intF intP a.\n       \\<lbrakk>infTp \\<sigma>; TE.MModel intT intF intP\\<rbrakk>\n       \\<Longrightarrow> infinite {a. intT \\<sigma> a}", "ultimately"], ["proof (chain)\npicking this:\n  infinite\n   {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n  {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n  \\<subseteq> {a. eintT \\<sigma> a}", "show \"infinite {a. eintT \\<sigma> a}\""], ["proof (prove)\nusing this:\n  infinite\n   {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n  {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n  \\<subseteq> {a. eintT \\<sigma> a}\n\ngoal (1 subgoal):\n 1. infinite {a. eintT \\<sigma> a}", "using infinite_super"], ["proof (prove)\nusing this:\n  infinite\n   {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n  {a. ProblemIkTpart_TEModel.intT prot protFw eintT eintF \\<sigma> a}\n  \\<subseteq> {a. eintT \\<sigma> a}\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. infinite {a. eintT \\<sigma> a}", "by blast"], ["proof (state)\nthis:\n  infinite {a. eintT \\<sigma> a}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The verification of the first monotonicity calculus criterion\nfor the tagged problem\\<close>"], ["", "context ProblemIkTpart begin"], ["", "lemma nvT_t[simp]: \"\\<not> unprot \\<sigma> \\<Longrightarrow> (\\<forall> x \\<in> TE.nvT (tT T). tpOfV x \\<noteq> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow>\n    \\<forall>x\\<in>nvT (tT T). TE.tpOfV x \\<noteq> \\<sigma>", "apply(induct T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<not> unprot \\<sigma> \\<Longrightarrow>\n       \\<forall>x\\<in>nvT (tT (Var x)). TE.tpOfV x \\<noteq> \\<sigma>\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     \\<not> unprot \\<sigma> \\<longrightarrow>\n                     (\\<forall>x\\<in>nvT (tT a).\n                         TE.tpOfV x \\<noteq> \\<sigma>))\n                 Tl;\n        \\<not> unprot \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>nvT (tT (Fn f Tl)).\n                            TE.tpOfV x \\<noteq> \\<sigma>", "by auto"], ["", "lemma nvL_tL[simp]: \"\\<not> unprot \\<sigma> \\<Longrightarrow> (\\<forall> x \\<in> TE.nvL (tL l). tpOfV x \\<noteq> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow>\n    \\<forall>x\\<in>nvL (tL l). TE.tpOfV x \\<noteq> \\<sigma>", "apply(cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<not> unprot \\<sigma>; l = Pos x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>nvL (tL l).\n                            TE.tpOfV x \\<noteq> \\<sigma>\n 2. \\<And>x2.\n       \\<lbrakk>\\<not> unprot \\<sigma>; l = Neg x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>nvL (tL l).\n                            TE.tpOfV x \\<noteq> \\<sigma>", "apply(rename_tac [!] atm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>atm.\n       \\<lbrakk>\\<not> unprot \\<sigma>; l = Pos atm\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>nvL (tL l).\n                            TE.tpOfV x \\<noteq> \\<sigma>\n 2. \\<And>atm.\n       \\<lbrakk>\\<not> unprot \\<sigma>; l = Neg atm\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>nvL (tL l).\n                            TE.tpOfV x \\<noteq> \\<sigma>", "apply(case_tac [!] atm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>atm x11 x12.\n       \\<lbrakk>\\<not> unprot \\<sigma>; l = Pos atm;\n        atm = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>nvL (tL l).\n                            TE.tpOfV x \\<noteq> \\<sigma>\n 2. \\<And>atm x21 x22.\n       \\<lbrakk>\\<not> unprot \\<sigma>; l = Pos atm;\n        atm = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>nvL (tL l).\n                            TE.tpOfV x \\<noteq> \\<sigma>\n 3. \\<And>atm x11 x12.\n       \\<lbrakk>\\<not> unprot \\<sigma>; l = Neg atm;\n        atm = Eq x11 x12\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>nvL (tL l).\n                            TE.tpOfV x \\<noteq> \\<sigma>\n 4. \\<And>atm x21 x22.\n       \\<lbrakk>\\<not> unprot \\<sigma>; l = Neg atm;\n        atm = Pr x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>nvL (tL l).\n                            TE.tpOfV x \\<noteq> \\<sigma>", "by auto (metis nvT_t)+"], ["", "lemma nvC_tC[simp]: \"\\<not> unprot \\<sigma> \\<Longrightarrow> (\\<forall> x \\<in> TE.nvC (tC c). tpOfV x \\<noteq> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow>\n    \\<forall>x\\<in>nvC (tC c). TE.tpOfV x \\<noteq> \\<sigma>", "unfolding tC_def TE.nvC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow>\n    \\<forall>x\\<in>\\<Union> (set (map nvL (map tL c))).\n       TE.tpOfV x \\<noteq> \\<sigma>", "apply (induct c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> unprot \\<sigma> \\<Longrightarrow>\n    \\<forall>x\\<in>\\<Union> (set (map nvL (map tL []))).\n       TE.tpOfV x \\<noteq> \\<sigma>\n 2. \\<And>a c.\n       \\<lbrakk>\\<not> unprot \\<sigma> \\<Longrightarrow>\n                \\<forall>x\\<in>\\<Union> (set (map nvL (map tL c))).\n                   TE.tpOfV x \\<noteq> \\<sigma>;\n        \\<not> unprot \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<Union>\n   (set (map nvL (map tL (a # c)))).\n                            TE.tpOfV x \\<noteq> \\<sigma>", "by auto (metis (full_types) nvL_tL)+"], ["", "lemma unprot_nvT_t[simp]:\n\"unprot (tpOfV x) \\<Longrightarrow> x \\<in> TE.nvT (tT T) \\<longleftrightarrow> x \\<in>  TE.nvT T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    (x \\<in> nvT (tT T)) = (x \\<in> nvT T)", "by (induct T, auto)"], ["", "lemma tpL_nvT_tL[simp]:\n\"unprot (tpOfV x) \\<Longrightarrow> x \\<in> TE.nvL (tL l) \\<longleftrightarrow> x \\<in> TE.nvL l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    (x \\<in> nvL (tL l)) = (x \\<in> nvL l)", "by (cases l, rename_tac [!] atm, case_tac [!] atm, auto)"], ["", "lemma unprot_nvC_tC[simp]:\n\"unprot (tpOfV x) \\<Longrightarrow> x \\<in> TE.nvC (tC c) \\<longleftrightarrow> x \\<in> TE.nvC c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    (x \\<in> nvC (tC c)) = (x \\<in> nvC c)", "unfolding tC_def TE.nvC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    (x \\<in> \\<Union> (set (map nvL (map tL c)))) =\n    (x \\<in> \\<Union> (set (map nvL c)))", "apply (induct c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. unprot (TE.tpOfV x) \\<Longrightarrow>\n    (x \\<in> \\<Union> (set (map nvL (map tL [])))) =\n    (x \\<in> \\<Union> (set (map nvL [])))\n 2. \\<And>a c.\n       \\<lbrakk>unprot (TE.tpOfV x) \\<Longrightarrow>\n                (x \\<in> \\<Union> (set (map nvL (map tL c)))) =\n                (x \\<in> \\<Union> (set (map nvL c)));\n        unprot (TE.tpOfV x)\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> \\<Union>\n                                   (set (map nvL (map tL (a # c))))) =\n                         (x \\<in> \\<Union> (set (map nvL (a # c))))", "by auto"], ["", "(* The added axioms are monotonic *)"], ["", "lemma nv_OfFax[simp]:\n\"x \\<notin> TE.nvT (lOfFax f)\"  \"x \\<notin> TE.nvT (rOfFax f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> nvT (lOfFax f) &&& x \\<notin> nvT (rOfFax f)", "unfolding lOfFax_def rOfFax_def lOfWax_def rOfWax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> nvT (Fn (Tag (resOf f))\n                     [Fn (Oldf f) (TE.getTvars (arOf f))]) &&&\n    x \\<notin> nvT (Fn (Oldf f) (TE.getTvars (arOf f)))", "by auto"], ["", "lemma nv_OfWax[simp]:\n\"x \\<notin> TE.nvT (lOfWax \\<sigma>')\"  \"x \\<notin> TE.nvT (rOfWax \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> nvT (lOfWax \\<sigma>') &&& x \\<notin> nvT (rOfWax \\<sigma>')", "unfolding lOfFax_def rOfFax_def lOfWax_def rOfWax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> nvT (Fn (Tag \\<sigma>') [Fn (Wit \\<sigma>') []]) &&&\n    x \\<notin> nvT (Fn (Wit \\<sigma>') [])", "by auto"], ["", "lemma nvC_Fax: \"c \\<in> Fax \\<Longrightarrow> TE.nvC c = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> Fax \\<Longrightarrow> nvC c = {}", "unfolding Fax_def TE.nvC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> {[Pos (Eq (lOfFax f) (rOfFax f))] |f.\n             wtFsym f} \\<Longrightarrow>\n    \\<Union> (set (map nvL c)) = {}", "by auto"], ["", "lemma mcalc_Fax: \"c \\<in> Fax \\<Longrightarrow> TE.mcalc \\<sigma> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> Fax \\<Longrightarrow> \\<sigma> \\<turnstile> c", "using nvC_Fax"], ["proof (prove)\nusing this:\n  ?c \\<in> Fax \\<Longrightarrow> nvC ?c = {}\n\ngoal (1 subgoal):\n 1. c \\<in> Fax \\<Longrightarrow> \\<sigma> \\<turnstile> c", "unfolding TE.mcalc_iff"], ["proof (prove)\nusing this:\n  ?c \\<in> Fax \\<Longrightarrow> nvC ?c = {}\n\ngoal (1 subgoal):\n 1. c \\<in> Fax \\<Longrightarrow>\n    infTp \\<sigma> \\<or>\n    (\\<forall>x\\<in>nvC c. TE.tpOfV x \\<noteq> \\<sigma>)", "by auto"], ["", "lemma nvC_Wax: \"c \\<in> Wax \\<Longrightarrow> TE.nvC c = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> Wax \\<Longrightarrow> nvC c = {}", "unfolding Wax_def TE.nvC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> {[Pos (Eq (lOfWax \\<sigma>) (rOfWax \\<sigma>))] |\\<sigma>.\n             \\<not> isRes \\<sigma> \\<and> protFw \\<sigma>} \\<Longrightarrow>\n    \\<Union> (set (map nvL c)) = {}", "by auto"], ["", "lemma mcalc_Wax: \"c \\<in> Wax \\<Longrightarrow> TE.mcalc \\<sigma> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> Wax \\<Longrightarrow> \\<sigma> \\<turnstile> c", "using nvC_Wax[of c]"], ["proof (prove)\nusing this:\n  c \\<in> Wax \\<Longrightarrow> nvC c = {}\n\ngoal (1 subgoal):\n 1. c \\<in> Wax \\<Longrightarrow> \\<sigma> \\<turnstile> c", "by simp"], ["", "end"], ["", "(* context ProblemIkTpart *)"], ["", "sublocale ProblemIkTpart < TE?: ProblemIkMcalc\nwhere wtFsym = TE_wtFsym and arOf = TE_arOf and resOf = TE_resOf\nand \\<Phi> = tPB"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkMcalc TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB infTp", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> c. c \\<in> tPB \\<Longrightarrow> \\<sigma> \\<turnstile> c", "fix \\<sigma> c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> c. c \\<in> tPB \\<Longrightarrow> \\<sigma> \\<turnstile> c", "assume \"c \\<in> tPB\""], ["proof (state)\nthis:\n  c \\<in> tPB\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> c. c \\<in> tPB \\<Longrightarrow> \\<sigma> \\<turnstile> c", "thus \"TE.mcalc \\<sigma> c\""], ["proof (prove)\nusing this:\n  c \\<in> tPB\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<turnstile> c", "unfolding tPB_def"], ["proof (prove)\nusing this:\n  c \\<in> tC ` \\<Phi> \\<union> Fax \\<union> Wax\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<turnstile> c", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<Phi>; c = tC x\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<turnstile> tC x\n 2. c \\<in> Fax \\<Longrightarrow> \\<sigma> \\<turnstile> c\n 3. c \\<in> Wax \\<Longrightarrow> \\<sigma> \\<turnstile> c", "fix d"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<Phi>; c = tC x\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<turnstile> tC x\n 2. c \\<in> Fax \\<Longrightarrow> \\<sigma> \\<turnstile> c\n 3. c \\<in> Wax \\<Longrightarrow> \\<sigma> \\<turnstile> c", "assume d: \"d \\<in> \\<Phi>\""], ["proof (state)\nthis:\n  d \\<in> \\<Phi>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<Phi>; c = tC x\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<turnstile> tC x\n 2. c \\<in> Fax \\<Longrightarrow> \\<sigma> \\<turnstile> c\n 3. c \\<in> Wax \\<Longrightarrow> \\<sigma> \\<turnstile> c", "thus \"TE.mcalc \\<sigma> (tC d)\""], ["proof (prove)\nusing this:\n  d \\<in> \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<turnstile> tC d", "using unprot_mcalc[OF _ d]"], ["proof (prove)\nusing this:\n  d \\<in> \\<Phi>\n  unprot ?\\<sigma> \\<Longrightarrow> ?\\<sigma> \\<turnstile> d\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<turnstile> tC d", "unfolding TE.mcalc_iff"], ["proof (prove)\nusing this:\n  d \\<in> \\<Phi>\n  unprot ?\\<sigma> \\<Longrightarrow>\n  infTp ?\\<sigma> \\<or>\n  (\\<forall>x\\<in>nvC d. TE.tpOfV x \\<noteq> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<or>\n    (\\<forall>x\\<in>nvC (tC d). TE.tpOfV x \\<noteq> \\<sigma>)", "by (cases \"unprot \\<sigma>\", auto, force)"], ["proof (state)\nthis:\n  \\<sigma> \\<turnstile> tC d\n\ngoal (2 subgoals):\n 1. c \\<in> Fax \\<Longrightarrow> \\<sigma> \\<turnstile> c\n 2. c \\<in> Wax \\<Longrightarrow> \\<sigma> \\<turnstile> c", "qed(insert mcalc_Fax mcalc_Wax, blast+)"], ["proof (state)\nthis:\n  \\<sigma> \\<turnstile> c\n\ngoal:\nNo subgoals!", "qed"], ["", "(* We already know that ProblemIkMcalc < MonotProblem, so by transitivity we obtain\nthe following main theorem, stating that the tag translation yields a monotonic\nproblem *)"], ["", "context ProblemIkTpart begin"], ["", "theorem T_monotonic:\n\"MonotProblem TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MonotProblem TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB", ".."], ["", "end"], ["", "(* context ProblemIkTpart *)"], ["", "sublocale ProblemIkTpart < TE?: MonotProblem\nwhere wtFsym = TE_wtFsym and arOf = TE_arOf and resOf = TE_resOf and \\<Phi> = tPB"], ["proof (prove)\ngoal (1 subgoal):\n 1. MonotProblem TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB", "using T_monotonic"], ["proof (prove)\nusing this:\n  MonotProblem TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB\n\ngoal (1 subgoal):\n 1. MonotProblem TE_wtFsym wtPsym TE_arOf TE_resOf parOf tPB", "."], ["", "end"]]}