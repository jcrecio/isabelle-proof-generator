{"file_name": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings/Mcalc2C.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings", "problem_names": ["lemma pol_polC: \"pol \\<sigma> P = polC P\"", "lemma nv2L_simps[simp]:\n\"nv2L (Pos (Pr p Tl)) = (case polC p of Fext \\<Rightarrow> \\<Union> (set (map nv2T Tl)) |_ \\<Rightarrow> {})\"\n\"nv2L (Neg (Pr p Tl)) = (case polC p of Text \\<Rightarrow> \\<Union> (set (map nv2T Tl)) |_ \\<Rightarrow> {})\"", "lemma isGuard_simps[simp]:\n\"isGuard x (Pos (Pr p Tl)) \\<longleftrightarrow> x \\<in> \\<Union> (set (map nv2T Tl)) \\<and> polC p = Text\"\n\"isGuard x (Neg (Pr p Tl)) \\<longleftrightarrow> x \\<in> \\<Union> (set (map nv2T Tl)) \\<and> polC p = Fext\"", "lemma intT_proj[simp]: \"intT \\<sigma> (proj \\<sigma> a)\"", "lemma proj_id[simp]: \"intT \\<sigma> a \\<Longrightarrow> proj \\<sigma> a = a\"", "lemma map_proj_id[simp]:\nassumes \"list_all2 intT \\<sigma>l al\"\nshows \"map2 proj \\<sigma>l al = al\"", "lemma surj_proj:\nassumes \"intT \\<sigma> a\"   shows \"\\<exists> b. proj \\<sigma> b = a\"", "lemma not_infTp_I_intT[simp]: \"\\<not> infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a\"", "lemma infTp_I_intT[simp]: \"infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a = intT \\<sigma> a\"", "lemma NE_I_intT: \"NE (I_intT \\<sigma>)\"", "lemma I_intP_Cext[simp]:\n\"polC p = Cext \\<Longrightarrow> I_intP p al = intP p (map2 proj (parOf p) al)\"", "lemma I_intP_Text_imp[simp]:\nassumes \"polC p = Text\" and \"intP p al\"\nshows \"I_intP p al\"", "lemma I_intP_Fext_imp[simp]:\nassumes \"polC p = Fext\" and \"\\<not> intP p al\"\nshows \"\\<not> I_intP p al\"", "lemma I_intP_intT[simp]:\nassumes \"list_all2 intT (parOf p) al\"\nshows \"I_intP p al = intP p al\"", "lemma I_intP_Text_not_intT[simp]:\nassumes \"polC p = Text\" and \"\\<not> list_all2 intT (parOf p) al\"\nshows \"I_intP p al\"", "lemma I_intP_Fext_not_intT[simp]:\nassumes \"polC p = Fext\" and \"\\<not> list_all2 intT (parOf p) al\"\nshows \"\\<not> I_intP p al\"", "lemma I_intF:\nassumes f: \"wtFsym f\" and al: \"list_all2 I_intT (arOf f) al\"\nshows \"I_intT (resOf f) (I_intF f al)\"", "lemma Tstruct_I_intT: \"Tstruct I_intT\"", "lemma inf_I_intT: \"infinite {a. I_intT \\<sigma> a}\"", "lemma InfStruct: \"IInfStruct I_intT I_intF I_intP\"", "lemma transE[simp]: \"transE \\<xi> x = proj (tpOfV x) (\\<xi> x)\"", "lemma wtE_transE[simp]: \"I.wtE \\<xi> \\<Longrightarrow> Ik.wtE (transE \\<xi>)\"", "lemma Ik_intT_int:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\"\nand nv2T: \"infTp (Ik.tpOf T) \\<or> (\\<forall> x \\<in> nv2T T. tpOfV x \\<noteq> Ik.tpOf T)\"\nshows \"Ik_intT (Ik.tpOf T) (I.int \\<xi> T)\"", "lemma int_transE_proj:\n  assumes wt: \"Ik.wt T\"\n  shows \"Ik.int (transE \\<xi>) T = proj (tpOf T) (I.int \\<xi> T)\"", "lemma int_transE_nv2T:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\"\nand nv2T: \"infTp (Ik.tpOf T) \\<or> (\\<forall> x \\<in> nv2T T. tpOfV x \\<noteq> Ik.tpOf T)\"\nshows \"Ik.int (transE \\<xi>) T = I.int \\<xi> T\"", "lemma isGuard_not_satL_intT:\nassumes wtL: \"Ik.wtL l\"\nand (* crucial hypothesis--the essence of guarding:*) ns: \"\\<not> I.satL \\<xi> l\"\nand g: \"isGuard x l\" and \\<xi>: \"I.wtE \\<xi>\"\nshows \"Ik_intT (tpOfV x) (\\<xi> x)\" (is \"Ik_intT ?\\<sigma> (\\<xi> x)\")", "lemma int_transE[simp]:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T: \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2T T\\<rbrakk> \\<Longrightarrow>\n           \\<exists> l. Ik.wtL l \\<and> \\<not> I.satL \\<xi> l \\<and> isGuard x l\"\nshows \"Ik.int (transE \\<xi>) T = I.int \\<xi> T\"", "lemma intT_int_transE[simp]:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T: \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2T T\\<rbrakk> \\<Longrightarrow>\n           \\<exists> l. Ik.wtL l \\<and> \\<not> I.satL \\<xi> l \\<and> isGuard x l\"\nshows \"Ik_intT (Ik.tpOf T) (I.int \\<xi> T)\"", "lemma map_int_transE_nv2T[simp]:\nassumes wt: \"list_all Ik.wt Tl\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T: \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); \\<exists>T\\<in>set Tl. x \\<in> nv2T T\\<rbrakk> \\<Longrightarrow>\n           \\<exists> l. Ik.wtL l \\<and> \\<not> I.satL \\<xi> l \\<and> isGuard x l\"\nshows \"map (Ik.int (transE \\<xi>)) Tl = map (I.int \\<xi>) Tl\"", "lemma list_all2_intT_int_transE_nv2T[simp]:\nassumes wt: \"list_all Ik.wt Tl\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T: \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); \\<exists>T\\<in>set Tl. x \\<in> nv2T T\\<rbrakk> \\<Longrightarrow>\n           \\<exists> l. Ik.wtL l \\<and> \\<not> I.satL \\<xi> l \\<and> isGuard x l\"\nshows \"list_all2 Ik_intT (map Ik.tpOf Tl) (map (I.int \\<xi>) Tl)\"", "lemma map_proj_transE[simp]:\nassumes wt: \"list_all wt Tl\"\nshows \"map (Ik.int (transE \\<xi>)) Tl =\n       map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl)\"", "lemma satL_transE[simp]:\nassumes wtL: \"Ik.wtL l\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T:  \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2L l\\<rbrakk> \\<Longrightarrow>\n             \\<exists> l'. Ik.wtL l' \\<and> \\<not> I.satL \\<xi> l' \\<and> isGuard x l'\"\nand \"Ik.satL (transE \\<xi>) l\"\nshows \"I.satL \\<xi> l\"", "lemma satPB_transE[simp]:\nassumes \\<xi>: \"I.wtE \\<xi>\"  shows \"I.satPB \\<xi> \\<Phi>\"", "lemma I_SAT: \"I.SAT \\<Phi>\"", "lemma InfModel: \"IInfModel I_intT I_intF I_intP\"", "theorem monot: monot"], "translations": [["", "lemma pol_polC: \"pol \\<sigma> P = polC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pol \\<sigma> P = polC P", "unfolding polC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pol \\<sigma> P = pol any P", "using pol_ct"], ["proof (prove)\nusing this:\n  pol ?\\<sigma>1.0 ?P = pol ?\\<sigma>2.0 ?P\n\ngoal (1 subgoal):\n 1. pol \\<sigma> P = pol any P", "by auto"], ["", "lemma nv2L_simps[simp]:\n\"nv2L (Pos (Pr p Tl)) = (case polC p of Fext \\<Rightarrow> \\<Union> (set (map nv2T Tl)) |_ \\<Rightarrow> {})\"\n\"nv2L (Neg (Pr p Tl)) = (case polC p of Text \\<Rightarrow> \\<Union> (set (map nv2T Tl)) |_ \\<Rightarrow> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nv2L (Pos (Pr p Tl)) =\n    (case polC p of Fext \\<Rightarrow> \\<Union> (set (map nv2T Tl))\n     | _ \\<Rightarrow> {}) &&&\n    nv2L (Neg (Pr p Tl)) =\n    (case polC p of Text \\<Rightarrow> \\<Union> (set (map nv2T Tl))\n     | _ \\<Rightarrow> {})", "by (auto split: epol.splits simp: pol_polC)"], ["", "declare nv2L.simps(3,4)[simp del]"], ["", "lemma isGuard_simps[simp]:\n\"isGuard x (Pos (Pr p Tl)) \\<longleftrightarrow> x \\<in> \\<Union> (set (map nv2T Tl)) \\<and> polC p = Text\"\n\"isGuard x (Neg (Pr p Tl)) \\<longleftrightarrow> x \\<in> \\<Union> (set (map nv2T Tl)) \\<and> polC p = Fext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isGuard x (Pos (Pr p Tl)) =\n    (x \\<in> \\<Union> (set (map nv2T Tl)) \\<and> polC p = Text) &&&\n    isGuard x (Neg (Pr p Tl)) =\n    (x \\<in> \\<Union> (set (map nv2T Tl)) \\<and> polC p = Fext)", "by (auto simp: pol_polC)"], ["", "declare isGuard.simps(3,4)[simp del]"], ["", "end"], ["", "(* context  ProblemIkPolMcalc2 *)"], ["", "locale ModelIkPolMcalc2C =\nModelIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp intT intF intP +\nProblemIkPolMcalc2C wtFsym wtPsym arOf resOf parOf \\<Phi> infTp pol grdOf\nfor wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\"\nand resOf and parOf and \\<Phi> and infTp pol and grdOf and intT and intF and intP"], ["", "subsection\\<open>Extension of a structure to an infinte structure\nby adding indistinguishable elements\\<close>"], ["", "context ModelIkPolMcalc2C begin"], ["", "(* The projection from univ to a structure: *)"], ["", "definition proj where \"proj \\<sigma> a \\<equiv> if intT \\<sigma> a then a else pickT \\<sigma>\""], ["", "lemma intT_proj[simp]: \"intT \\<sigma> (proj \\<sigma> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> (proj \\<sigma> a)", "unfolding proj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> (if intT \\<sigma> a then a else pickT \\<sigma>)", "using pickT"], ["proof (prove)\nusing this:\n  intT ?\\<sigma> (pickT ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. intT \\<sigma> (if intT \\<sigma> a then a else pickT \\<sigma>)", "by auto"], ["", "lemma proj_id[simp]: \"intT \\<sigma> a \\<Longrightarrow> proj \\<sigma> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> a \\<Longrightarrow> proj \\<sigma> a = a", "unfolding proj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. intT \\<sigma> a \\<Longrightarrow>\n    (if intT \\<sigma> a then a else pickT \\<sigma>) = a", "by auto"], ["", "lemma map_proj_id[simp]:\nassumes \"list_all2 intT \\<sigma>l al\"\nshows \"map2 proj \\<sigma>l al = al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 proj \\<sigma>l al = al", "apply(rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map2 proj \\<sigma>l al) = length al\n 2. \\<And>i.\n       i < length (map2 proj \\<sigma>l al) \\<Longrightarrow>\n       map2 proj \\<sigma>l al ! i = al ! i", "using assms"], ["proof (prove)\nusing this:\n  list_all2 intT \\<sigma>l al\n\ngoal (2 subgoals):\n 1. length (map2 proj \\<sigma>l al) = length al\n 2. \\<And>i.\n       i < length (map2 proj \\<sigma>l al) \\<Longrightarrow>\n       map2 proj \\<sigma>l al ! i = al ! i", "unfolding list_all2_length"], ["proof (prove)\nusing this:\n  length \\<sigma>l = length al \\<and>\n  (\\<forall>i<length \\<sigma>l. intT (\\<sigma>l ! i) (al ! i))\n\ngoal (2 subgoals):\n 1. length (map2 proj \\<sigma>l al) = length al\n 2. \\<And>i.\n       i < length (map2 proj \\<sigma>l al) \\<Longrightarrow>\n       map2 proj \\<sigma>l al ! i = al ! i", "by auto"], ["", "lemma surj_proj:\nassumes \"intT \\<sigma> a\"   shows \"\\<exists> b. proj \\<sigma> b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b. proj \\<sigma> b = a", "using assms"], ["proof (prove)\nusing this:\n  intT \\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>b. proj \\<sigma> b = a", "by (intro exI[of _ a]) simp"], ["", "definition \"I_intT \\<sigma> (a::univ) \\<equiv> infTp \\<sigma> \\<longrightarrow> intT \\<sigma> a\""], ["", "definition \"I_intF f al \\<equiv> intF f (map2 proj (arOf f) al)\""], ["", "definition\n\"I_intP p al \\<equiv>\n case polC p of\n   Cext \\<Rightarrow> intP p (map2 proj (parOf p) al)\n  |Text \\<Rightarrow> if list_all2 intT (parOf p) al then intP p al else True\n  |Fext \\<Rightarrow> if list_all2 intT (parOf p) al then intP p al else False\""], ["", "lemma not_infTp_I_intT[simp]: \"\\<not> infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a", "unfolding I_intT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> infTp \\<sigma> \\<Longrightarrow>\n    infTp \\<sigma> \\<longrightarrow> intT \\<sigma> a", "by simp"], ["", "lemma infTp_I_intT[simp]: \"infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a = intT \\<sigma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<Longrightarrow> I_intT \\<sigma> a = intT \\<sigma> a", "unfolding I_intT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp \\<sigma> \\<Longrightarrow>\n    (infTp \\<sigma> \\<longrightarrow> intT \\<sigma> a) = intT \\<sigma> a", "by simp"], ["", "lemma NE_I_intT: \"NE (I_intT \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. I_intT \\<sigma> a", "using NE_intT"], ["proof (prove)\nusing this:\n  \\<exists>a. intT ?\\<sigma> a\n\ngoal (1 subgoal):\n 1. \\<exists>a. I_intT \\<sigma> a", "by (cases \"infTp \\<sigma>\", auto)"], ["", "lemma I_intP_Cext[simp]:\n\"polC p = Cext \\<Longrightarrow> I_intP p al = intP p (map2 proj (parOf p) al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polC p = Cext \\<Longrightarrow>\n    I_intP p al = intP p (map2 proj (parOf p) al)", "unfolding I_intP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. polC p = Cext \\<Longrightarrow>\n    (case polC p of Cext \\<Rightarrow> intP p (map2 proj (parOf p) al)\n     | Text \\<Rightarrow>\n         if list_all2 intT (parOf p) al then intP p al else True\n     | Fext \\<Rightarrow>\n         if list_all2 intT (parOf p) al then intP p al else False) =\n    intP p (map2 proj (parOf p) al)", "by simp"], ["", "lemma I_intP_Text_imp[simp]:\nassumes \"polC p = Text\" and \"intP p al\"\nshows \"I_intP p al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_intP p al", "using assms"], ["proof (prove)\nusing this:\n  polC p = Text\n  intP p al\n\ngoal (1 subgoal):\n 1. I_intP p al", "unfolding I_intP_def"], ["proof (prove)\nusing this:\n  polC p = Text\n  intP p al\n\ngoal (1 subgoal):\n 1. case polC p of Cext \\<Rightarrow> intP p (map2 proj (parOf p) al)\n    | Text \\<Rightarrow>\n        if list_all2 intT (parOf p) al then intP p al else True\n    | Fext \\<Rightarrow>\n        if list_all2 intT (parOf p) al then intP p al else False", "by auto"], ["", "lemma I_intP_Fext_imp[simp]:\nassumes \"polC p = Fext\" and \"\\<not> intP p al\"\nshows \"\\<not> I_intP p al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> I_intP p al", "using assms"], ["proof (prove)\nusing this:\n  polC p = Fext\n  \\<not> intP p al\n\ngoal (1 subgoal):\n 1. \\<not> I_intP p al", "unfolding I_intP_def"], ["proof (prove)\nusing this:\n  polC p = Fext\n  \\<not> intP p al\n\ngoal (1 subgoal):\n 1. \\<not> (case polC p of\n            Cext \\<Rightarrow> intP p (map2 proj (parOf p) al)\n            | Text \\<Rightarrow>\n                if list_all2 intT (parOf p) al then intP p al else True\n            | Fext \\<Rightarrow>\n                if list_all2 intT (parOf p) al then intP p al else False)", "by (cases \"list_all2 intT (parOf p) al\", auto)"], ["", "lemma I_intP_intT[simp]:\nassumes \"list_all2 intT (parOf p) al\"\nshows \"I_intP p al = intP p al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_intP p al = intP p al", "using assms"], ["proof (prove)\nusing this:\n  list_all2 intT (parOf p) al\n\ngoal (1 subgoal):\n 1. I_intP p al = intP p al", "unfolding I_intP_def"], ["proof (prove)\nusing this:\n  list_all2 intT (parOf p) al\n\ngoal (1 subgoal):\n 1. (case polC p of Cext \\<Rightarrow> intP p (map2 proj (parOf p) al)\n     | Text \\<Rightarrow>\n         if list_all2 intT (parOf p) al then intP p al else True\n     | Fext \\<Rightarrow>\n         if list_all2 intT (parOf p) al then intP p al else False) =\n    intP p al", "by (cases \"polC p\") auto"], ["", "lemma I_intP_Text_not_intT[simp]:\nassumes \"polC p = Text\" and \"\\<not> list_all2 intT (parOf p) al\"\nshows \"I_intP p al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_intP p al", "using assms"], ["proof (prove)\nusing this:\n  polC p = Text\n  \\<not> list_all2 intT (parOf p) al\n\ngoal (1 subgoal):\n 1. I_intP p al", "unfolding I_intP_def"], ["proof (prove)\nusing this:\n  polC p = Text\n  \\<not> list_all2 intT (parOf p) al\n\ngoal (1 subgoal):\n 1. case polC p of Cext \\<Rightarrow> intP p (map2 proj (parOf p) al)\n    | Text \\<Rightarrow>\n        if list_all2 intT (parOf p) al then intP p al else True\n    | Fext \\<Rightarrow>\n        if list_all2 intT (parOf p) al then intP p al else False", "by auto"], ["", "lemma I_intP_Fext_not_intT[simp]:\nassumes \"polC p = Fext\" and \"\\<not> list_all2 intT (parOf p) al\"\nshows \"\\<not> I_intP p al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> I_intP p al", "using assms"], ["proof (prove)\nusing this:\n  polC p = Fext\n  \\<not> list_all2 intT (parOf p) al\n\ngoal (1 subgoal):\n 1. \\<not> I_intP p al", "unfolding I_intP_def"], ["proof (prove)\nusing this:\n  polC p = Fext\n  \\<not> list_all2 intT (parOf p) al\n\ngoal (1 subgoal):\n 1. \\<not> (case polC p of\n            Cext \\<Rightarrow> intP p (map2 proj (parOf p) al)\n            | Text \\<Rightarrow>\n                if list_all2 intT (parOf p) al then intP p al else True\n            | Fext \\<Rightarrow>\n                if list_all2 intT (parOf p) al then intP p al else False)", "by auto"], ["", "lemma I_intF:\nassumes f: \"wtFsym f\" and al: \"list_all2 I_intT (arOf f) al\"\nshows \"I_intT (resOf f) (I_intF f al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_intT (resOf f) (I_intF f al)", "unfolding I_intT_def I_intF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<longrightarrow>\n    intT (resOf f) (intF f (map2 proj (arOf f) al))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<Longrightarrow>\n    intT (resOf f) (intF f (map2 proj (arOf f) al))", "apply(rule intF[OF f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<Longrightarrow>\n    list_all2 intT (arOf f) (map2 proj (arOf f) al)", "using al"], ["proof (prove)\nusing this:\n  list_all2 I_intT (arOf f) al\n\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<Longrightarrow>\n    list_all2 intT (arOf f) (map2 proj (arOf f) al)", "unfolding list_all2_length"], ["proof (prove)\nusing this:\n  length (arOf f) = length al \\<and>\n  (\\<forall>i<length (arOf f). I_intT (arOf f ! i) (al ! i))\n\ngoal (1 subgoal):\n 1. infTp (resOf f) \\<Longrightarrow>\n    length (arOf f) = length (map2 proj (arOf f) al) \\<and>\n    (\\<forall>i<length (arOf f).\n        intT (arOf f ! i) (map2 proj (arOf f) al ! i))", "by auto"], ["", "lemma Tstruct_I_intT: \"Tstruct I_intT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Tstruct I_intT", "by standard (rule NE_I_intT)"], ["", "lemma inf_I_intT: \"infinite {a. I_intT \\<sigma> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {a. I_intT \\<sigma> a}", "by (cases \"infTp \\<sigma>\", auto)"], ["", "lemma InfStruct: \"IInfStruct I_intT I_intF I_intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfStruct I_intT I_intF I_intP", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. I_intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 I_intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> I_intT (resOf f) (I_intF f al)\n 3. I_intP = I_intP\n 4. \\<And>\\<sigma>. infinite {a. I_intT \\<sigma> a}", "using NE_I_intT I_intF Tstruct_I_intT inf_I_intT"], ["proof (prove)\nusing this:\n  \\<exists>a. I_intT ?\\<sigma> a\n  \\<lbrakk>wtFsym ?f; list_all2 I_intT (arOf ?f) ?al\\<rbrakk>\n  \\<Longrightarrow> I_intT (resOf ?f) (I_intF ?f ?al)\n  CM.Tstruct I_intT\n  infinite {a. I_intT ?\\<sigma> a}\n\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>. \\<exists>a. I_intT \\<sigma> a\n 2. \\<And>f al.\n       \\<lbrakk>wtFsym f; list_all2 I_intT (arOf f) al\\<rbrakk>\n       \\<Longrightarrow> I_intT (resOf f) (I_intF f al)\n 3. I_intP = I_intP\n 4. \\<And>\\<sigma>. infinite {a. I_intT \\<sigma> a}", "by auto"], ["", "end"], ["", "(* context ModelIkPolMcalc2C *)"], ["", "sublocale ModelIkPolMcalc2C < InfStruct where\nintT = I_intT and intF = I_intF and intP = I_intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfStruct I_intT I_intF I_intP", "using InfStruct"], ["proof (prove)\nusing this:\n  IInfStruct I_intT I_intF I_intP\n\ngoal (1 subgoal):\n 1. IInfStruct I_intT I_intF I_intP", "."], ["", "subsection\\<open>The soundness of the calculus\\<close>"], ["", "(* In what follows, ``Ik\" stands for the original\n(augmented with infiniteness-knowledge)\nand ``I\" for the infinite structure constructed from it\nthrough the above sublocale statement. *)"], ["", "context ModelIkPolMcalc2C begin"], ["", "(* The environment translation along the projection: *)"], ["", "definition \"transE \\<xi> \\<equiv> \\<lambda> x. proj (tpOfV x) (\\<xi> x)\""], ["", "lemma transE[simp]: \"transE \\<xi> x = proj (tpOfV x) (\\<xi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transE \\<xi> x = proj (tpOfV x) (\\<xi> x)", "unfolding transE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj (tpOfV x) (\\<xi> x) = proj (tpOfV x) (\\<xi> x)", "by simp"], ["", "lemma wtE_transE[simp]: \"I.wtE \\<xi> \\<Longrightarrow> Ik.wtE (transE \\<xi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.wtE \\<xi> \\<Longrightarrow> Ik.wtE (transE \\<xi>)", "unfolding Ik.wtE_def I.wtE_def transE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. I_intT (tpOfV x) (\\<xi> x) \\<Longrightarrow>\n    \\<forall>x. intT (tpOfV x) (proj (tpOfV x) (\\<xi> x))", "by auto"], ["", "abbreviation \"Ik_intT \\<equiv> intT\""], ["", "abbreviation \"Ik_intF \\<equiv> intF\""], ["", "abbreviation \"Ik_intP \\<equiv> intP\""], ["", "lemma Ik_intT_int:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\"\nand nv2T: \"infTp (Ik.tpOf T) \\<or> (\\<forall> x \\<in> nv2T T. tpOfV x \\<noteq> Ik.tpOf T)\"\nshows \"Ik_intT (Ik.tpOf T) (I.int \\<xi> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "proof(cases \"\\<exists> x. T = Var x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. T = Var x \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "case True"], ["proof (state)\nthis:\n  \\<exists>x. T = Var x\n\ngoal (2 subgoals):\n 1. \\<exists>x. T = Var x \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. T = Var x", "obtain x where T: \"T = Var x\""], ["proof (prove)\nusing this:\n  \\<exists>x. T = Var x\n\ngoal (1 subgoal):\n 1. (\\<And>x. T = Var x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  T = Var x\n\ngoal (2 subgoals):\n 1. \\<exists>x. T = Var x \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "proof(cases \"infTp (tpOf T)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "case True"], ["proof (state)\nthis:\n  infTp (tpOf T)\n\ngoal (2 subgoals):\n 1. infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)\n 2. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  infTp (tpOf T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "using T"], ["proof (prove)\nusing this:\n  infTp (tpOf T)\n  T = Var x\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "using wtE_transE[OF \\<xi>]"], ["proof (prove)\nusing this:\n  infTp (tpOf T)\n  T = Var x\n  Ik.wtE (transE \\<xi>)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "by (metis I.wt_int I_intT_def \\<xi> wt)"], ["proof (state)\nthis:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "case False"], ["proof (state)\nthis:\n  \\<not> infTp (tpOf T)\n\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "hence \"\\<forall> x \\<in> nv2T T. tpOfV x \\<noteq> tpOf T\""], ["proof (prove)\nusing this:\n  \\<not> infTp (tpOf T)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T", "using nv2T"], ["proof (prove)\nusing this:\n  \\<not> infTp (tpOf T)\n  infTp (tpOf T) \\<or> (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T\n\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "hence \"Ik.full (tpOf T)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T\n\ngoal (1 subgoal):\n 1. Ik.full (tpOf T)", "using T"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T\n  T = Var x\n\ngoal (1 subgoal):\n 1. Ik.full (tpOf T)", "by (cases T, simp_all)"], ["proof (state)\nthis:\n  Ik.full (tpOf T)\n\ngoal (1 subgoal):\n 1. \\<not> infTp (tpOf T) \\<Longrightarrow> Ik_intT (tpOf T) (I.int \\<xi> T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Ik.full (tpOf T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "unfolding Ik.full_def"], ["proof (prove)\nusing this:\n  \\<forall>d. Ik_intT (tpOf T) d\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "by simp"], ["proof (state)\nthis:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "case False"], ["proof (state)\nthis:\n  \\<nexists>x. T = Var x\n\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "hence nonVar: \"\\<not> (\\<exists> x. T = Var x)\""], ["proof (prove)\nusing this:\n  \\<nexists>x. T = Var x\n\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x", "by (cases T, auto)"], ["proof (state)\nthis:\n  \\<nexists>x. T = Var x\n\ngoal (1 subgoal):\n 1. \\<nexists>x. T = Var x \\<Longrightarrow>\n    Ik_intT (tpOf T) (I.int \\<xi> T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>x. T = Var x\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "using nonVar wt"], ["proof (prove)\nusing this:\n  \\<nexists>x. T = Var x\n  \\<nexists>x. T = Var x\n  wt T\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "apply(induct T, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik_intT (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "unfolding I_intF_def tpOf.simps int.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a)\n                      (Struct.int\n                        (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                        \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik_intT (resOf f)\n                          (Ik_intF f\n                            (map2 proj (arOf f)\n                              (map (Struct.int\n                                     (\\<lambda>f al.\n   Ik_intF f (map2 proj (arOf f) al))\n                                     \\<xi>)\n                                Tl)))", "apply(rule Ik.intF, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a)\n                      (Struct.int\n                        (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                        \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> list_all2 Ik_intT (arOf f)\n                          (map2 proj (arOf f)\n                            (map (Struct.int\n                                   (\\<lambda>f al.\n Ik_intF f (map2 proj (arOf f) al))\n                                   \\<xi>)\n                              Tl))", "apply(rule listAll2_map2I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a)\n                      (Struct.int\n                        (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                        \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> length (arOf f) =\n                         length\n                          (map (Struct.int\n                                 (\\<lambda>f al.\n                                     Ik_intF f (map2 proj (arOf f) al))\n                                 \\<xi>)\n                            Tl)\n 2. \\<And>f Tl i.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     (\\<nexists>x. a = Var x) \\<longrightarrow>\n                     wt a \\<longrightarrow>\n                     Ik_intT (tpOf a)\n                      (Struct.int\n                        (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                        \\<xi> a))\n                 Tl;\n        \\<nexists>x. Fn f Tl = Var x; \\<nexists>x. Fn f Tl = Var x;\n        wt (Fn f Tl); i < length (arOf f)\\<rbrakk>\n       \\<Longrightarrow> Ik_intT (arOf f ! i)\n                          (proj (arOf f ! i)\n                            (map (Struct.int\n                                   (\\<lambda>f al.\n Ik_intF f (map2 proj (arOf f) al))\n                                   \\<xi>)\n                              Tl !\n                             i))", "by auto"], ["proof (state)\nthis:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_transE_proj:\n  assumes wt: \"Ik.wt T\"\n  shows \"Ik.int (transE \\<xi>) T = proj (tpOf T) (I.int \\<xi> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = proj (tpOf T) (I.int \\<xi> T)", "using wt"], ["proof (prove)\nusing this:\n  wt T\n\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = proj (tpOf T) (I.int \\<xi> T)", "proof (induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     Ik.int (transE \\<xi>) a =\n                     proj (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik.int (transE \\<xi>) (Fn f Tl) =\n                         proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "case (Fn f Tl)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     Ik.int (transE \\<xi>) a =\n                     proj (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik.int (transE \\<xi>) (Fn f Tl) =\n                         proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "have 0: \"Ik_intT (resOf f) (I_intF f (map (int \\<xi>) Tl))\" (is \"Ik_intT ?\\<sigma> ?a\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (resOf f) (I_intF f (map (I.int \\<xi>) Tl))", "unfolding I_intF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (resOf f)\n     (Ik_intF f\n       (map2 proj (arOf f)\n         (map (Struct.int (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n                \\<xi>)\n           Tl)))", "apply(rule Ik.intF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wtFsym f\n 2. list_all2 Ik_intT (arOf f)\n     (map2 proj (arOf f)\n       (map (Struct.int (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n              \\<xi>)\n         Tl))", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (2 subgoals):\n 1. wtFsym f\n 2. list_all2 Ik_intT (arOf f)\n     (map2 proj (arOf f)\n       (map (Struct.int (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n              \\<xi>)\n         Tl))", "unfolding list_all2_length list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set Tl.\n     wt a \\<longrightarrow>\n     Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a)\n  wt (Fn f Tl)\n\ngoal (2 subgoals):\n 1. wtFsym f\n 2. length (arOf f) =\n    length\n     (map2 proj (arOf f)\n       (map (Struct.int (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al))\n              \\<xi>)\n         Tl)) \\<and>\n    (\\<forall>i<length (arOf f).\n        Ik_intT (arOf f ! i)\n         (map2 proj (arOf f)\n           (map (Struct.int\n                  (\\<lambda>f al. Ik_intF f (map2 proj (arOf f) al)) \\<xi>)\n             Tl) !\n          i))", "by auto"], ["proof (state)\nthis:\n  Ik_intT (resOf f) (I_intF f (map (I.int \\<xi>) Tl))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     Ik.int (transE \\<xi>) a =\n                     proj (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik.int (transE \\<xi>) (Fn f Tl) =\n                         proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "have 1: \"proj ?\\<sigma> ?a = ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj (resOf f) (I_intF f (map (I.int \\<xi>) Tl)) =\n    I_intF f (map (I.int \\<xi>) Tl)", "using proj_id[OF 0]"], ["proof (prove)\nusing this:\n  proj (resOf f) (I_intF f (map (I.int \\<xi>) Tl)) =\n  I_intF f (map (I.int \\<xi>) Tl)\n\ngoal (1 subgoal):\n 1. proj (resOf f) (I_intF f (map (I.int \\<xi>) Tl)) =\n    I_intF f (map (I.int \\<xi>) Tl)", "."], ["proof (state)\nthis:\n  proj (resOf f) (I_intF f (map (I.int \\<xi>) Tl)) =\n  I_intF f (map (I.int \\<xi>) Tl)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))\n 2. \\<And>f Tl.\n       \\<lbrakk>list_all\n                 (\\<lambda>a.\n                     wt a \\<longrightarrow>\n                     Ik.int (transE \\<xi>) a =\n                     proj (tpOf a) (I.int \\<xi> a))\n                 Tl;\n        wt (Fn f Tl)\\<rbrakk>\n       \\<Longrightarrow> Ik.int (transE \\<xi>) (Fn f Tl) =\n                         proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Fn f Tl) =\n    proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Fn f Tl) =\n    proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))", "unfolding Ik.int.simps int.simps tpOf.simps 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intF f (map (Ik.int (transE \\<xi>)) Tl) =\n    I_intF f (map (I.int \\<xi>) Tl)", "unfolding I_intF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intF f (map (Ik.int (transE \\<xi>)) Tl) =\n    Ik_intF f (map2 proj (arOf f) (map (I.int \\<xi>) Tl))", "apply(rule arg_cong[of _ _ \"intF f\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl =\n    map2 proj (arOf f) (map (I.int \\<xi>) Tl)", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "have l[simp]: \"length (arOf f) = length Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (arOf f) = length Tl", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. length (arOf f) = length Tl", "by simp"], ["proof (state)\nthis:\n  length (arOf f) = length Tl\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "assume \"i < length (map (Ik.int (transE \\<xi>)) Tl)\""], ["proof (state)\nthis:\n  i < length (map (Ik.int (transE \\<xi>)) Tl)\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "hence i[simp]: \"i < length Tl\""], ["proof (prove)\nusing this:\n  i < length (map (Ik.int (transE \\<xi>)) Tl)\n\ngoal (1 subgoal):\n 1. i < length Tl", "by simp"], ["proof (state)\nthis:\n  i < length Tl\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "have 0: \"arOf f ! i = tpOf (Tl ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arOf f ! i = tpOf (Tl ! i)", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. arOf f ! i = tpOf (Tl ! i)", "by simp"], ["proof (state)\nthis:\n  arOf f ! i = tpOf (Tl ! i)\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "have [simp]: \"Ik.int (transE \\<xi>) (Tl ! i) = proj (arOf f ! i) (I.int \\<xi> (Tl ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Tl ! i) =\n    proj (arOf f ! i) (I.int \\<xi> (Tl ! i))", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Tl ! i) =\n    proj (tpOf (Tl ! i)) (I.int \\<xi> (Tl ! i))", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Tl ! i) =\n    proj (tpOf (Tl ! i)) (I.int \\<xi> (Tl ! i))", "by (auto simp: list_all_length transE_def)"], ["proof (state)\nthis:\n  Ik.int (transE \\<xi>) (Tl ! i) = proj (arOf f ! i) (I.int \\<xi> (Tl ! i))\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "show \"map (Ik.int (transE \\<xi>)) Tl ! i =\n          map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl ! i =\n    map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "using Fn"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       wt a \\<longrightarrow>\n       Ik.int (transE \\<xi>) a = proj (tpOf a) (I.int \\<xi> a))\n   Tl\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl ! i =\n    map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  \\<forall>n<length Tl.\n     wt (Tl ! n) \\<longrightarrow>\n     Ik.int (transE \\<xi>) (Tl ! n) =\n     proj (tpOf (Tl ! n)) (I.int \\<xi> (Tl ! n))\n  wt (Fn f Tl)\n\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl ! i =\n    map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i", "by simp"], ["proof (state)\nthis:\n  map (Ik.int (transE \\<xi>)) Tl ! i =\n  map2 proj (arOf f) (map (I.int \\<xi>) Tl) ! i\n\ngoal (1 subgoal):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (arOf f) (map (I.int \\<xi>) Tl))", "qed(insert Fn, simp)"], ["proof (state)\nthis:\n  Ik.int (transE \\<xi>) (Fn f Tl) =\n  proj (tpOf (Fn f Tl)) (I.int \\<xi> (Fn f Tl))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       wt (Var x) \\<Longrightarrow>\n       Ik.int (transE \\<xi>) (Var x) =\n       proj (tpOf (Var x)) (I.int \\<xi> (Var x))", "qed simp"], ["", "lemma int_transE_nv2T:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\"\nand nv2T: \"infTp (Ik.tpOf T) \\<or> (\\<forall> x \\<in> nv2T T. tpOfV x \\<noteq> Ik.tpOf T)\"\nshows \"Ik.int (transE \\<xi>) T = I.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = I.int \\<xi> T", "unfolding int_transE_proj[OF wt]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj (tpOf T) (I.int \\<xi> T) = I.int \\<xi> T", "apply(rule proj_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "using Ik_intT_int[OF wt \\<xi> nv2T]"], ["proof (prove)\nusing this:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "."], ["", "lemma isGuard_not_satL_intT:\nassumes wtL: \"Ik.wtL l\"\nand (* crucial hypothesis--the essence of guarding:*) ns: \"\\<not> I.satL \\<xi> l\"\nand g: \"isGuard x l\" and \\<xi>: \"I.wtE \\<xi>\"\nshows \"Ik_intT (tpOfV x) (\\<xi> x)\" (is \"Ik_intT ?\\<sigma> (\\<xi> x)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "(* \"proj \\<sigma> (\\<xi> \\<sigma> x) = \\<xi> \\<sigma> x\" *)\n(* \"Ik.int (transE \\<xi>) (Var \\<sigma> x) = I.int \\<xi> (Var \\<sigma> x)\" *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "proof(cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. l = Pos x1 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x2. l = Neg x2 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "case (Pos at)"], ["proof (state)\nthis:\n  l = Pos at\n\ngoal (2 subgoals):\n 1. \\<And>x1. l = Pos x1 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x2. l = Neg x2 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "proof(cases at)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "case (Pr p Tl)"], ["proof (state)\nthis:\n  at = Pr p Tl\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "then"], ["proof (chain)\npicking this:\n  at = Pr p Tl", "obtain T where Tin: \"T \\<in> set Tl\" and x: \"x \\<in> nv2T T\" and pol: \"polC p = Text\""], ["proof (prove)\nusing this:\n  at = Pr p Tl\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<in> set Tl; x \\<in> nv2T T; polC p = Text\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using g"], ["proof (prove)\nusing this:\n  at = Pr p Tl\n  isGuard x l\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<in> set Tl; x \\<in> nv2T T; polC p = Text\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Pos Pr"], ["proof (prove)\nusing this:\n  Pr p Tl = Pr p Tl\n  isGuard x (Pos (Pr p Tl))\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<in> set Tl; x \\<in> nv2T T; polC p = Text\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T \\<in> set Tl\n  x \\<in> nv2T T\n  polC p = Text\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence T: \"T = Var x\""], ["proof (prove)\nusing this:\n  T \\<in> set Tl\n  x \\<in> nv2T T\n  polC p = Text\n\ngoal (1 subgoal):\n 1. T = Var x", "by (simp add: in_nv2T)"], ["proof (state)\nthis:\n  T = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "obtain i where i: \"i < length Tl\" and Ti: \"T = Tl!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length Tl; T = Tl ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Tin"], ["proof (prove)\nusing this:\n  T \\<in> set Tl\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length Tl; T = Tl ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length Tl\n  T = Tl ! i\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence 0 : \"wt T\" \"parOf p ! i = ?\\<sigma>\""], ["proof (prove)\nusing this:\n  i < length Tl\n  T = Tl ! i\n\ngoal (1 subgoal):\n 1. wt T &&& parOf p ! i = tpOfV x", "using wtL"], ["proof (prove)\nusing this:\n  i < length Tl\n  T = Tl ! i\n  wtL l\n\ngoal (1 subgoal):\n 1. wt T &&& parOf p ! i = tpOfV x", "unfolding Pos Pr T"], ["proof (prove)\nusing this:\n  i < length Tl\n  Var x = Tl ! i\n  wtL (Pos (Pr p Tl))\n\ngoal (1 subgoal):\n 1. wt (Var x) &&& parOf p ! i = tpOfV x", "apply (simp_all add: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length Tl; Var x = Tl ! i;\n     wtPsym p \\<and> Ball (set Tl) wt \\<and> parOf p = map tpOf Tl\\<rbrakk>\n    \\<Longrightarrow> tpOf (Tl ! i) = tpOfV x", "by (metis T x in_nv2T tpOf.simps)"], ["proof (state)\nthis:\n  wt T\n  parOf p ! i = tpOfV x\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "have \"list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\" (is ?phi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)", "using ns"], ["proof (prove)\nusing this:\n  \\<not> I.satL \\<xi> l\n\ngoal (1 subgoal):\n 1. list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)", "unfolding Pos Pr"], ["proof (prove)\nusing this:\n  \\<not> I.satL \\<xi> (Pos (Pr p Tl))\n\ngoal (1 subgoal):\n 1. list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)", "using pol"], ["proof (prove)\nusing this:\n  \\<not> I.satL \\<xi> (Pos (Pr p Tl))\n  polC p = Text\n\ngoal (1 subgoal):\n 1. list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)", "by (cases ?phi, auto)"], ["proof (state)\nthis:\n  list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence \"Ik_intT ?\\<sigma> (I.int \\<xi> T)\""], ["proof (prove)\nusing this:\n  list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (I.int \\<xi> T)", "using ns 0 i Ti"], ["proof (prove)\nusing this:\n  list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\n  \\<not> I.satL \\<xi> l\n  wt T\n  parOf p ! i = tpOfV x\n  i < length Tl\n  T = Tl ! i\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (I.int \\<xi> T)", "unfolding Pos Pr"], ["proof (prove)\nusing this:\n  list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\n  \\<not> I.satL \\<xi> (Pos (Pr p Tl))\n  wt T\n  parOf p ! i = tpOfV x\n  i < length Tl\n  T = Tl ! i\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (I.int \\<xi> T)", "by (auto simp add: list_all2_length nth_map)"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (I.int \\<xi> T)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Ik_intT (tpOfV x) (I.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "unfolding T"], ["proof (prove)\nusing this:\n  Ik_intT (tpOfV x) (I.int \\<xi> (Var x))\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "by simp"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (\\<xi> x)\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "qed(insert g, unfold Pos, simp)"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (\\<xi> x)\n\ngoal (1 subgoal):\n 1. \\<And>x2. l = Neg x2 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2. l = Neg x2 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "case (Neg at)"], ["proof (state)\nthis:\n  l = Neg at\n\ngoal (1 subgoal):\n 1. \\<And>x2. l = Neg x2 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "proof(cases at)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "case (Eq T1 T2)"], ["proof (state)\nthis:\n  at = Eq T1 T2\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence 0: \"T1 = Var x \\<or> T2 = Var x\""], ["proof (prove)\nusing this:\n  at = Eq T1 T2\n\ngoal (1 subgoal):\n 1. T1 = Var x \\<or> T2 = Var x", "using g"], ["proof (prove)\nusing this:\n  at = Eq T1 T2\n  isGuard x l\n\ngoal (1 subgoal):\n 1. T1 = Var x \\<or> T2 = Var x", "unfolding Neg"], ["proof (prove)\nusing this:\n  at = Eq T1 T2\n  isGuard x (Neg at)\n\ngoal (1 subgoal):\n 1. T1 = Var x \\<or> T2 = Var x", "by auto"], ["proof (state)\nthis:\n  T1 = Var x \\<or> T2 = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence wt1: \"Ik.wt T1\" \"Ik.tpOf T1 = tpOfV x\"\n    and wt2: \"Ik.wt T2\" \"Ik.tpOf T2 = tpOfV x\""], ["proof (prove)\nusing this:\n  T1 = Var x \\<or> T2 = Var x\n\ngoal (1 subgoal):\n 1. (wt T1 &&& tpOf T1 = tpOfV x) &&& wt T2 &&& tpOf T2 = tpOfV x", "using wtL"], ["proof (prove)\nusing this:\n  T1 = Var x \\<or> T2 = Var x\n  wtL l\n\ngoal (1 subgoal):\n 1. (wt T1 &&& tpOf T1 = tpOfV x) &&& wt T2 &&& tpOf T2 = tpOfV x", "unfolding Neg Eq"], ["proof (prove)\nusing this:\n  T1 = Var x \\<or> T2 = Var x\n  wtL (Neg (Eq T1 T2))\n\ngoal (1 subgoal):\n 1. (wt T1 &&& tpOf T1 = tpOfV x) &&& wt T2 &&& tpOf T2 = tpOfV x", "by auto"], ["proof (state)\nthis:\n  wt T1\n  tpOf T1 = tpOfV x\n  wt T2\n  tpOf T2 = tpOfV x\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "have eq: \"I.int \\<xi> T1 = I.int \\<xi> T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.int \\<xi> T1 = I.int \\<xi> T2", "using ns"], ["proof (prove)\nusing this:\n  \\<not> I.satL \\<xi> l\n\ngoal (1 subgoal):\n 1. I.int \\<xi> T1 = I.int \\<xi> T2", "unfolding Neg Eq"], ["proof (prove)\nusing this:\n  \\<not> I.satL \\<xi> (Neg (Eq T1 T2))\n\ngoal (1 subgoal):\n 1. I.int \\<xi> T1 = I.int \\<xi> T2", "by simp"], ["proof (state)\nthis:\n  I.int \\<xi> T1 = I.int \\<xi> T2\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       at = Eq x11 x12 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "proof(cases \"T1 = Var x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. T1 = Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "case True"], ["proof (state)\nthis:\n  T1 = Var x\n\ngoal (2 subgoals):\n 1. T1 = Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "note T1 = True"], ["proof (state)\nthis:\n  T1 = Var x\n\ngoal (2 subgoals):\n 1. T1 = Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "obtain f Tl where \"T2 = Fn f Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f Tl. T2 = Fn f Tl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using g T1 Eq"], ["proof (prove)\nusing this:\n  isGuard x l\n  T1 = Var x\n  at = Eq T1 T2\n\ngoal (1 subgoal):\n 1. (\\<And>f Tl. T2 = Fn f Tl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Neg"], ["proof (prove)\nusing this:\n  isGuard x (Neg at)\n  T1 = Var x\n  at = Eq T1 T2\n\ngoal (1 subgoal):\n 1. (\\<And>f Tl. T2 = Fn f Tl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T2 = Fn f Tl\n\ngoal (2 subgoals):\n 1. T1 = Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nv2T T2. tpOfV x \\<noteq> \\<sigma>)\""], ["proof (prove)\nusing this:\n  T2 = Fn f Tl\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       infTp \\<sigma> \\<or>\n       (\\<forall>x\\<in>nv2T T2. tpOfV x \\<noteq> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  infTp ?\\<sigma>7 \\<or>\n  (\\<forall>x\\<in>nv2T T2. tpOfV x \\<noteq> ?\\<sigma>7)\n\ngoal (2 subgoals):\n 1. T1 = Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence 1: \"I.int \\<xi> T2 = Ik.int (transE \\<xi>) T2\""], ["proof (prove)\nusing this:\n  infTp ?\\<sigma>7 \\<or>\n  (\\<forall>x\\<in>nv2T T2. tpOfV x \\<noteq> ?\\<sigma>7)\n\ngoal (1 subgoal):\n 1. I.int \\<xi> T2 = Ik.int (transE \\<xi>) T2", "using int_transE_nv2T wt2 \\<xi>"], ["proof (prove)\nusing this:\n  infTp ?\\<sigma>7 \\<or>\n  (\\<forall>x\\<in>nv2T T2. tpOfV x \\<noteq> ?\\<sigma>7)\n  \\<lbrakk>wt ?T; I.wtE ?\\<xi>;\n   infTp (tpOf ?T) \\<or>\n   (\\<forall>x\\<in>nv2T ?T. tpOfV x \\<noteq> tpOf ?T)\\<rbrakk>\n  \\<Longrightarrow> Ik.int (transE ?\\<xi>) ?T = I.int ?\\<xi> ?T\n  wt T2\n  tpOf T2 = tpOfV x\n  I.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. I.int \\<xi> T2 = Ik.int (transE \\<xi>) T2", "by auto"], ["proof (state)\nthis:\n  I.int \\<xi> T2 = Ik.int (transE \\<xi>) T2\n\ngoal (2 subgoals):\n 1. T1 = Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "have \"Ik_intT ?\\<sigma> (I.int \\<xi> T1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (I.int \\<xi> T1)", "unfolding eq 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (Ik.int (transE \\<xi>) T2)", "using wt2 \\<xi> Ik.wt_int"], ["proof (prove)\nusing this:\n  wt T2\n  tpOf T2 = tpOfV x\n  I.wtE \\<xi>\n  \\<lbrakk>Ik.wtE ?\\<xi>; wt ?T\\<rbrakk>\n  \\<Longrightarrow> Ik_intT (tpOf ?T) (Ik.int ?\\<xi> ?T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (Ik.int (transE \\<xi>) T2)", "by force"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (I.int \\<xi> T1)\n\ngoal (2 subgoals):\n 1. T1 = Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)\n 2. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Ik_intT (tpOfV x) (I.int \\<xi> T1)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "unfolding T1"], ["proof (prove)\nusing this:\n  Ik_intT (tpOfV x) (I.int \\<xi> (Var x))\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "by simp"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (\\<xi> x)\n\ngoal (1 subgoal):\n 1. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "case False"], ["proof (state)\nthis:\n  T1 \\<noteq> Var x\n\ngoal (1 subgoal):\n 1. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "then"], ["proof (chain)\npicking this:\n  T1 \\<noteq> Var x", "obtain f Tl where T2: \"T2 = Var x\" and \"T1 = Fn f Tl\""], ["proof (prove)\nusing this:\n  T1 \\<noteq> Var x\n\ngoal (1 subgoal):\n 1. (\\<And>f Tl.\n        \\<lbrakk>T2 = Var x; T1 = Fn f Tl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Eq Neg g"], ["proof (prove)\nusing this:\n  T1 \\<noteq> Var x\n  at = Eq T1 T2\n  l = Neg at\n  isGuard x l\n\ngoal (1 subgoal):\n 1. (\\<And>f Tl.\n        \\<lbrakk>T2 = Var x; T1 = Fn f Tl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T2 = Var x\n  T1 = Fn f Tl\n\ngoal (1 subgoal):\n 1. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence \"\\<And> \\<sigma>. infTp \\<sigma> \\<or> (\\<forall> x \\<in> nv2T T1. tpOfV x \\<noteq> \\<sigma>)\""], ["proof (prove)\nusing this:\n  T2 = Var x\n  T1 = Fn f Tl\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       infTp \\<sigma> \\<or>\n       (\\<forall>x\\<in>nv2T T1. tpOfV x \\<noteq> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  infTp ?\\<sigma>7 \\<or>\n  (\\<forall>x\\<in>nv2T T1. tpOfV x \\<noteq> ?\\<sigma>7)\n\ngoal (1 subgoal):\n 1. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence 1: \"I.int \\<xi> T1 = Ik.int (transE \\<xi>) T1\""], ["proof (prove)\nusing this:\n  infTp ?\\<sigma>7 \\<or>\n  (\\<forall>x\\<in>nv2T T1. tpOfV x \\<noteq> ?\\<sigma>7)\n\ngoal (1 subgoal):\n 1. I.int \\<xi> T1 = Ik.int (transE \\<xi>) T1", "using int_transE_nv2T wt1 \\<xi>"], ["proof (prove)\nusing this:\n  infTp ?\\<sigma>7 \\<or>\n  (\\<forall>x\\<in>nv2T T1. tpOfV x \\<noteq> ?\\<sigma>7)\n  \\<lbrakk>wt ?T; I.wtE ?\\<xi>;\n   infTp (tpOf ?T) \\<or>\n   (\\<forall>x\\<in>nv2T ?T. tpOfV x \\<noteq> tpOf ?T)\\<rbrakk>\n  \\<Longrightarrow> Ik.int (transE ?\\<xi>) ?T = I.int ?\\<xi> ?T\n  wt T1\n  tpOf T1 = tpOfV x\n  I.wtE \\<xi>\n\ngoal (1 subgoal):\n 1. I.int \\<xi> T1 = Ik.int (transE \\<xi>) T1", "by auto"], ["proof (state)\nthis:\n  I.int \\<xi> T1 = Ik.int (transE \\<xi>) T1\n\ngoal (1 subgoal):\n 1. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "have \"Ik_intT ?\\<sigma> (I.int \\<xi> T2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (I.int \\<xi> T2)", "unfolding eq[symmetric] 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (Ik.int (transE \\<xi>) T1)", "using wt1 \\<xi> Ik.wt_int"], ["proof (prove)\nusing this:\n  wt T1\n  tpOf T1 = tpOfV x\n  I.wtE \\<xi>\n  \\<lbrakk>Ik.wtE ?\\<xi>; wt ?T\\<rbrakk>\n  \\<Longrightarrow> Ik_intT (tpOf ?T) (Ik.int ?\\<xi> ?T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (Ik.int (transE \\<xi>) T1)", "by force"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (I.int \\<xi> T2)\n\ngoal (1 subgoal):\n 1. T1 \\<noteq> Var x \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Ik_intT (tpOfV x) (I.int \\<xi> T2)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "unfolding T2"], ["proof (prove)\nusing this:\n  Ik_intT (tpOfV x) (I.int \\<xi> (Var x))\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "by simp"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (\\<xi> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (\\<xi> x)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "case (Pr p Tl)"], ["proof (state)\nthis:\n  at = Pr p Tl\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "then"], ["proof (chain)\npicking this:\n  at = Pr p Tl", "obtain T where Tin: \"T \\<in> set Tl\" and x: \"x \\<in> nv2T T\" and pol: \"polC p = Fext\""], ["proof (prove)\nusing this:\n  at = Pr p Tl\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<in> set Tl; x \\<in> nv2T T; polC p = Fext\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using g"], ["proof (prove)\nusing this:\n  at = Pr p Tl\n  isGuard x l\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<in> set Tl; x \\<in> nv2T T; polC p = Fext\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Neg Pr"], ["proof (prove)\nusing this:\n  Pr p Tl = Pr p Tl\n  isGuard x (Neg (Pr p Tl))\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<in> set Tl; x \\<in> nv2T T; polC p = Fext\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T \\<in> set Tl\n  x \\<in> nv2T T\n  polC p = Fext\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence T: \"T = Var x\""], ["proof (prove)\nusing this:\n  T \\<in> set Tl\n  x \\<in> nv2T T\n  polC p = Fext\n\ngoal (1 subgoal):\n 1. T = Var x", "by (simp add: in_nv2T)"], ["proof (state)\nthis:\n  T = Var x\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "obtain i where i: \"i < length Tl\" and Ti: \"T = Tl!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length Tl; T = Tl ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Tin"], ["proof (prove)\nusing this:\n  T \\<in> set Tl\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length Tl; T = Tl ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length Tl\n  T = Tl ! i\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence 0 : \"wt T\" \"parOf p ! i = ?\\<sigma>\""], ["proof (prove)\nusing this:\n  i < length Tl\n  T = Tl ! i\n\ngoal (1 subgoal):\n 1. wt T &&& parOf p ! i = tpOfV x", "using wtL"], ["proof (prove)\nusing this:\n  i < length Tl\n  T = Tl ! i\n  wtL l\n\ngoal (1 subgoal):\n 1. wt T &&& parOf p ! i = tpOfV x", "unfolding Neg Pr T"], ["proof (prove)\nusing this:\n  i < length Tl\n  Var x = Tl ! i\n  wtL (Neg (Pr p Tl))\n\ngoal (1 subgoal):\n 1. wt (Var x) &&& parOf p ! i = tpOfV x", "apply (simp_all add: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length Tl; Var x = Tl ! i;\n     wtPsym p \\<and> Ball (set Tl) wt \\<and> parOf p = map tpOf Tl\\<rbrakk>\n    \\<Longrightarrow> tpOf (Tl ! i) = tpOfV x", "by (metis T x in_nv2T tpOf.simps)"], ["proof (state)\nthis:\n  wt T\n  parOf p ! i = tpOfV x\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "have \"list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\" (is ?phi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)", "using ns"], ["proof (prove)\nusing this:\n  \\<not> I.satL \\<xi> l\n\ngoal (1 subgoal):\n 1. list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)", "unfolding Neg Pr"], ["proof (prove)\nusing this:\n  \\<not> I.satL \\<xi> (Neg (Pr p Tl))\n\ngoal (1 subgoal):\n 1. list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)", "using pol"], ["proof (prove)\nusing this:\n  \\<not> I.satL \\<xi> (Neg (Pr p Tl))\n  polC p = Fext\n\ngoal (1 subgoal):\n 1. list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)", "by (cases ?phi, auto)"], ["proof (state)\nthis:\n  list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "hence \"Ik_intT ?\\<sigma> (I.int \\<xi> T)\""], ["proof (prove)\nusing this:\n  list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (I.int \\<xi> T)", "using ns 0 i Ti"], ["proof (prove)\nusing this:\n  list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\n  \\<not> I.satL \\<xi> l\n  wt T\n  parOf p ! i = tpOfV x\n  i < length Tl\n  T = Tl ! i\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (I.int \\<xi> T)", "unfolding Neg Pr"], ["proof (prove)\nusing this:\n  list_all2 Ik_intT (parOf p) (map (I.int \\<xi>) Tl)\n  \\<not> I.satL \\<xi> (Neg (Pr p Tl))\n  wt T\n  parOf p ! i = tpOfV x\n  i < length Tl\n  T = Tl ! i\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (I.int \\<xi> T)", "by (auto simp add: list_all2_length nth_map)"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (I.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       at = Pr x21 x22 \\<Longrightarrow> Ik_intT (tpOfV x) (\\<xi> x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Ik_intT (tpOfV x) (I.int \\<xi> T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "unfolding T"], ["proof (prove)\nusing this:\n  Ik_intT (tpOfV x) (I.int \\<xi> (Var x))\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOfV x) (\\<xi> x)", "by simp"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (\\<xi> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ik_intT (tpOfV x) (\\<xi> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_transE[simp]:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T: \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2T T\\<rbrakk> \\<Longrightarrow>\n           \\<exists> l. Ik.wtL l \\<and> \\<not> I.satL \\<xi> l \\<and> isGuard x l\"\nshows \"Ik.int (transE \\<xi>) T = I.int \\<xi> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = I.int \\<xi> T", "proof(cases \"infTp (Ik.tpOf T) \\<or> (\\<forall> x \\<in> nv2T T. tpOfV x \\<noteq> Ik.tpOf T)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. infTp (tpOf T) \\<or>\n    (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T\n 2. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "case True"], ["proof (state)\nthis:\n  infTp (tpOf T) \\<or> (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T)\n\ngoal (2 subgoals):\n 1. infTp (tpOf T) \\<or>\n    (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T\n 2. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  infTp (tpOf T) \\<or> (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T)\n\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = I.int \\<xi> T", "using int_transE_nv2T[OF wt \\<xi>]"], ["proof (prove)\nusing this:\n  infTp (tpOf T) \\<or> (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T)\n  infTp (tpOf T) \\<or>\n  (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T) \\<Longrightarrow>\n  Ik.int (transE \\<xi>) T = I.int \\<xi> T\n\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = I.int \\<xi> T", "by auto"], ["proof (state)\nthis:\n  Ik.int (transE \\<xi>) T = I.int \\<xi> T\n\ngoal (1 subgoal):\n 1. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "define \\<sigma> where \"\\<sigma> = Ik.tpOf T\""], ["proof (state)\nthis:\n  \\<sigma> = tpOf T\n\ngoal (1 subgoal):\n 1. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "case False"], ["proof (state)\nthis:\n  \\<not> (infTp (tpOf T) \\<or>\n          (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T))\n\ngoal (1 subgoal):\n 1. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "then"], ["proof (chain)\npicking this:\n  \\<not> (infTp (tpOf T) \\<or>\n          (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T))", "obtain x where i: \"\\<not> infTp \\<sigma>\" and x: \"x \\<in> nv2T T\""], ["proof (prove)\nusing this:\n  \\<not> (infTp (tpOf T) \\<or>\n          (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>\\<not> infTp \\<sigma>; x \\<in> nv2T T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<sigma>_def"], ["proof (prove)\nusing this:\n  \\<not> (infTp (tpOf T) \\<or>\n          (\\<forall>x\\<in>nv2T T. tpOfV x \\<noteq> tpOf T))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOf T); x \\<in> nv2T T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> infTp \\<sigma>\n  x \\<in> nv2T T\n\ngoal (1 subgoal):\n 1. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "hence T: \"T = Var x\""], ["proof (prove)\nusing this:\n  \\<not> infTp \\<sigma>\n  x \\<in> nv2T T\n\ngoal (1 subgoal):\n 1. T = Var x", "by (simp add: in_nv2T)"], ["proof (state)\nthis:\n  T = Var x\n\ngoal (1 subgoal):\n 1. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "hence \\<sigma>: \"\\<sigma> = tpOfV x\""], ["proof (prove)\nusing this:\n  T = Var x\n\ngoal (1 subgoal):\n 1. \\<sigma> = tpOfV x", "unfolding \\<sigma>_def"], ["proof (prove)\nusing this:\n  T = Var x\n\ngoal (1 subgoal):\n 1. tpOf T = tpOfV x", "by simp"], ["proof (state)\nthis:\n  \\<sigma> = tpOfV x\n\ngoal (1 subgoal):\n 1. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "obtain l where 0: \"Ik.wtL l\" \"\\<not> I.satL \\<xi> l\" \"isGuard x l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>wtL l; \\<not> I.satL \\<xi> l; isGuard x l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nv2T[OF i[unfolded \\<sigma>] x]"], ["proof (prove)\nusing this:\n  \\<exists>l. wtL l \\<and> \\<not> I.satL \\<xi> l \\<and> isGuard x l\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>wtL l; \\<not> I.satL \\<xi> l; isGuard x l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  wtL l\n  \\<not> I.satL \\<xi> l\n  isGuard x l\n\ngoal (1 subgoal):\n 1. \\<not> (infTp (tpOf T) \\<or>\n            (\\<forall>x\\<in>nv2T T.\n                tpOfV x \\<noteq> tpOf T)) \\<Longrightarrow>\n    Ik.int (transE \\<xi>) T = I.int \\<xi> T", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) T = I.int \\<xi> T", "unfolding T"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Var x) = I.int \\<xi> (Var x)", "using isGuard_not_satL_intT[OF 0 \\<xi>]"], ["proof (prove)\nusing this:\n  Ik_intT (tpOfV x) (\\<xi> x)\n\ngoal (1 subgoal):\n 1. Ik.int (transE \\<xi>) (Var x) = I.int \\<xi> (Var x)", "by simp"], ["proof (state)\nthis:\n  Ik.int (transE \\<xi>) T = I.int \\<xi> T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intT_int_transE[simp]:\nassumes wt: \"Ik.wt T\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T: \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2T T\\<rbrakk> \\<Longrightarrow>\n           \\<exists> l. Ik.wtL l \\<and> \\<not> I.satL \\<xi> l \\<and> isGuard x l\"\nshows \"Ik_intT (Ik.tpOf T) (I.int \\<xi> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "have 0: \"I.int \\<xi> T = Ik.int (transE \\<xi>) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.int \\<xi> T = Ik.int (transE \\<xi>) T", "using int_transE[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2T T\\<rbrakk>\n              \\<Longrightarrow> \\<not> infTp (tpOfV x);\n   \\<And>x.\n      \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2T T\\<rbrakk>\n      \\<Longrightarrow> x \\<in> nv2T T\\<rbrakk>\n  \\<Longrightarrow> Ik.int (transE \\<xi>) T = I.int \\<xi> T\n\ngoal (1 subgoal):\n 1. I.int \\<xi> T = Ik.int (transE \\<xi>) T", "by simp"], ["proof (state)\nthis:\n  I.int \\<xi> T = Ik.int (transE \\<xi>) T\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (I.int \\<xi> T)", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (Ik.int (transE \\<xi>) T)", "using Ik.wt_int[OF wtE_transE[OF \\<xi>] wt]"], ["proof (prove)\nusing this:\n  Ik_intT (tpOf T) (Ik.int (transE \\<xi>) T)\n\ngoal (1 subgoal):\n 1. Ik_intT (tpOf T) (Ik.int (transE \\<xi>) T)", "."], ["proof (state)\nthis:\n  Ik_intT (tpOf T) (I.int \\<xi> T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_int_transE_nv2T[simp]:\nassumes wt: \"list_all Ik.wt Tl\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T: \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); \\<exists>T\\<in>set Tl. x \\<in> nv2T T\\<rbrakk> \\<Longrightarrow>\n           \\<exists> l. Ik.wtL l \\<and> \\<not> I.satL \\<xi> l \\<and> isGuard x l\"\nshows \"map (Ik.int (transE \\<xi>)) Tl = map (I.int \\<xi>) Tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl = map (I.int \\<xi>) Tl", "apply(rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) = length (map (I.int \\<xi>) Tl)\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i = map (I.int \\<xi>) Tl ! i", "using assms"], ["proof (prove)\nusing this:\n  list_all wt Tl\n  I.wtE \\<xi>\n  \\<lbrakk>\\<not> infTp (tpOfV ?x7);\n   \\<exists>T\\<in>set Tl. ?x7 \\<in> nv2T T\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l.\n                       wtL l \\<and>\n                       \\<not> I.satL \\<xi> l \\<and> isGuard ?x7 l\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) = length (map (I.int \\<xi>) Tl)\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i = map (I.int \\<xi>) Tl ! i", "by (force simp: list_all_iff intro: int_transE)+"], ["", "lemma list_all2_intT_int_transE_nv2T[simp]:\nassumes wt: \"list_all Ik.wt Tl\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T: \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); \\<exists>T\\<in>set Tl. x \\<in> nv2T T\\<rbrakk> \\<Longrightarrow>\n           \\<exists> l. Ik.wtL l \\<and> \\<not> I.satL \\<xi> l \\<and> isGuard x l\"\nshows \"list_all2 Ik_intT (map Ik.tpOf Tl) (map (I.int \\<xi>) Tl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 Ik_intT (map tpOf Tl) (map (I.int \\<xi>) Tl)", "unfolding list_all2_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map tpOf Tl) = length (map (I.int \\<xi>) Tl) \\<and>\n    (\\<forall>i<length (map tpOf Tl).\n        Ik_intT (map tpOf Tl ! i) (map (I.int \\<xi>) Tl ! i))", "using assms"], ["proof (prove)\nusing this:\n  list_all wt Tl\n  I.wtE \\<xi>\n  \\<lbrakk>\\<not> infTp (tpOfV ?x7);\n   \\<exists>T\\<in>set Tl. ?x7 \\<in> nv2T T\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l.\n                       wtL l \\<and>\n                       \\<not> I.satL \\<xi> l \\<and> isGuard ?x7 l\n\ngoal (1 subgoal):\n 1. length (map tpOf Tl) = length (map (I.int \\<xi>) Tl) \\<and>\n    (\\<forall>i<length (map tpOf Tl).\n        Ik_intT (map tpOf Tl ! i) (map (I.int \\<xi>) Tl ! i))", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  Ball (set Tl) wt\n  I.wtE \\<xi>\n  \\<lbrakk>\\<not> infTp (tpOfV ?x7);\n   \\<exists>T\\<in>set Tl. ?x7 \\<in> nv2T T\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l.\n                       wtL l \\<and>\n                       \\<not> I.satL \\<xi> l \\<and> isGuard ?x7 l\n\ngoal (1 subgoal):\n 1. length (map tpOf Tl) = length (map (I.int \\<xi>) Tl) \\<and>\n    (\\<forall>i<length (map tpOf Tl).\n        Ik_intT (map tpOf Tl ! i) (map (I.int \\<xi>) Tl ! i))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball (set Tl) wt; I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         \\<exists>T\\<in>set Tl. x \\<in> nv2T T\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l.\n                             wtL l \\<and>\n                             \\<not> I.satL \\<xi> l \\<and>\n                             isGuard x l\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length Tl.\n                         Ik_intT (tpOf (Tl ! i)) (I.int \\<xi> (Tl ! i))", "by (metis intT_int_transE nth_mem)"], ["", "lemma map_proj_transE[simp]:\nassumes wt: \"list_all wt Tl\"\nshows \"map (Ik.int (transE \\<xi>)) Tl =\n       map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Ik.int (transE \\<xi>)) Tl =\n    map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl)", "apply(rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl) ! i", "using assms"], ["proof (prove)\nusing this:\n  list_all wt Tl\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl) ! i", "using int_transE_proj"], ["proof (prove)\nusing this:\n  list_all wt Tl\n  wt ?T \\<Longrightarrow>\n  Ik.int (transE ?\\<xi>) ?T = proj (tpOf ?T) (I.int ?\\<xi> ?T)\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl) ! i", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  \\<forall>n<length Tl. wt (Tl ! n)\n  wt ?T \\<Longrightarrow>\n  Ik.int (transE ?\\<xi>) ?T = proj (tpOf ?T) (I.int ?\\<xi> ?T)\n\ngoal (2 subgoals):\n 1. length (map (Ik.int (transE \\<xi>)) Tl) =\n    length (map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl))\n 2. \\<And>i.\n       i < length (map (Ik.int (transE \\<xi>)) Tl) \\<Longrightarrow>\n       map (Ik.int (transE \\<xi>)) Tl ! i =\n       map2 proj (map tpOf Tl) (map (I.int \\<xi>) Tl) ! i", "by auto"], ["", "lemma satL_transE[simp]:\nassumes wtL: \"Ik.wtL l\" and \\<xi>: \"I.wtE \\<xi>\" and\nnv2T:  \"\\<And> x. \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2L l\\<rbrakk> \\<Longrightarrow>\n             \\<exists> l'. Ik.wtL l' \\<and> \\<not> I.satL \\<xi> l' \\<and> isGuard x l'\"\nand \"Ik.satL (transE \\<xi>) l\"\nshows \"I.satL \\<xi> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "proof(cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. l = Pos x1 \\<Longrightarrow> I.satL \\<xi> l\n 2. \\<And>x2. l = Neg x2 \\<Longrightarrow> I.satL \\<xi> l", "case (Pos at)"], ["proof (state)\nthis:\n  l = Pos at\n\ngoal (2 subgoals):\n 1. \\<And>x1. l = Pos x1 \\<Longrightarrow> I.satL \\<xi> l\n 2. \\<And>x2. l = Neg x2 \\<Longrightarrow> I.satL \\<xi> l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "proof (cases at)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12. at = Eq x11 x12 \\<Longrightarrow> I.satL \\<xi> l\n 2. \\<And>x21 x22. at = Pr x21 x22 \\<Longrightarrow> I.satL \\<xi> l", "case (Pr p Tl)"], ["proof (state)\nthis:\n  at = Pr p Tl\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12. at = Eq x11 x12 \\<Longrightarrow> I.satL \\<xi> l\n 2. \\<And>x21 x22. at = Pr x21 x22 \\<Longrightarrow> I.satL \\<xi> l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "using assms"], ["proof (prove)\nusing this:\n  wtL l\n  I.wtE \\<xi>\n  \\<lbrakk>\\<not> infTp (tpOfV ?x7); ?x7 \\<in> nv2L l\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'.\n                       wtL l' \\<and>\n                       \\<not> I.satL \\<xi> l' \\<and> isGuard ?x7 l'\n  Ik.satL (transE \\<xi>) l\n\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "unfolding Pos Pr"], ["proof (prove)\nusing this:\n  wtL (Pos (Pr p Tl))\n  I.wtE \\<xi>\n  \\<lbrakk>\\<not> infTp (tpOfV ?x7); ?x7 \\<in> nv2L (Pos (Pr p Tl))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'.\n                       wtL l' \\<and>\n                       \\<not> I.satL \\<xi> l' \\<and> isGuard ?x7 l'\n  Ik.satL (transE \\<xi>) (Pos (Pr p Tl))\n\ngoal (1 subgoal):\n 1. I.satL \\<xi> (Pos (Pr p Tl))", "apply(cases \"polC p\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wtL (Pos (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Pos (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Pos (Pr p Tl)); polC p = Cext\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Pos (Pr p Tl))\n 2. \\<lbrakk>wtL (Pos (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Pos (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Pos (Pr p Tl)); polC p = Text\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Pos (Pr p Tl))\n 3. \\<lbrakk>wtL (Pos (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Pos (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Pos (Pr p Tl)); polC p = Fext\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Pos (Pr p Tl))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wtL (Pos (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Pos (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Pos (Pr p Tl)); polC p = Text\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Pos (Pr p Tl))\n 2. \\<lbrakk>wtL (Pos (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Pos (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Pos (Pr p Tl)); polC p = Fext\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Pos (Pr p Tl))", "apply(cases \"list_all2 intT (map Ik.tpOf Tl) (map (I.int \\<xi>) Tl)\", force, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtL (Pos (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Pos (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Pos (Pr p Tl)); polC p = Fext\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Pos (Pr p Tl))", "by simp"], ["proof (state)\nthis:\n  I.satL \\<xi> l\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12. at = Eq x11 x12 \\<Longrightarrow> I.satL \\<xi> l", "qed(insert assms, unfold Pos, simp)"], ["proof (state)\nthis:\n  I.satL \\<xi> l\n\ngoal (1 subgoal):\n 1. \\<And>x2. l = Neg x2 \\<Longrightarrow> I.satL \\<xi> l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2. l = Neg x2 \\<Longrightarrow> I.satL \\<xi> l", "case (Neg at)"], ["proof (state)\nthis:\n  l = Neg at\n\ngoal (1 subgoal):\n 1. \\<And>x2. l = Neg x2 \\<Longrightarrow> I.satL \\<xi> l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "proof (cases at)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12. at = Eq x11 x12 \\<Longrightarrow> I.satL \\<xi> l\n 2. \\<And>x21 x22. at = Pr x21 x22 \\<Longrightarrow> I.satL \\<xi> l", "case (Pr p Tl)"], ["proof (state)\nthis:\n  at = Pr p Tl\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12. at = Eq x11 x12 \\<Longrightarrow> I.satL \\<xi> l\n 2. \\<And>x21 x22. at = Pr x21 x22 \\<Longrightarrow> I.satL \\<xi> l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "using assms"], ["proof (prove)\nusing this:\n  wtL l\n  I.wtE \\<xi>\n  \\<lbrakk>\\<not> infTp (tpOfV ?x7); ?x7 \\<in> nv2L l\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'.\n                       wtL l' \\<and>\n                       \\<not> I.satL \\<xi> l' \\<and> isGuard ?x7 l'\n  Ik.satL (transE \\<xi>) l\n\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "unfolding Neg Pr"], ["proof (prove)\nusing this:\n  wtL (Neg (Pr p Tl))\n  I.wtE \\<xi>\n  \\<lbrakk>\\<not> infTp (tpOfV ?x7); ?x7 \\<in> nv2L (Neg (Pr p Tl))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'.\n                       wtL l' \\<and>\n                       \\<not> I.satL \\<xi> l' \\<and> isGuard ?x7 l'\n  Ik.satL (transE \\<xi>) (Neg (Pr p Tl))\n\ngoal (1 subgoal):\n 1. I.satL \\<xi> (Neg (Pr p Tl))", "apply(cases \"polC p\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wtL (Neg (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Neg (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Neg (Pr p Tl)); polC p = Cext\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Neg (Pr p Tl))\n 2. \\<lbrakk>wtL (Neg (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Neg (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Neg (Pr p Tl)); polC p = Text\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Neg (Pr p Tl))\n 3. \\<lbrakk>wtL (Neg (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Neg (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Neg (Pr p Tl)); polC p = Fext\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Neg (Pr p Tl))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wtL (Neg (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Neg (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Neg (Pr p Tl)); polC p = Text\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Neg (Pr p Tl))\n 2. \\<lbrakk>wtL (Neg (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Neg (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Neg (Pr p Tl)); polC p = Fext\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Neg (Pr p Tl))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wtL (Neg (Pr p Tl)); I.wtE \\<xi>;\n     \\<And>x.\n        \\<lbrakk>\\<not> infTp (tpOfV x);\n         x \\<in> nv2L (Neg (Pr p Tl))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             wtL l' \\<and>\n                             \\<not> I.satL \\<xi> l' \\<and> isGuard x l';\n     Ik.satL (transE \\<xi>) (Neg (Pr p Tl)); polC p = Fext\\<rbrakk>\n    \\<Longrightarrow> I.satL \\<xi> (Neg (Pr p Tl))", "by (cases \"list_all2 intT (map Ik.tpOf Tl) (map (I.int \\<xi>) Tl)\", force, force)"], ["proof (state)\nthis:\n  I.satL \\<xi> l\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12. at = Eq x11 x12 \\<Longrightarrow> I.satL \\<xi> l", "qed(insert assms int_transE_proj, unfold Neg, auto)"], ["proof (state)\nthis:\n  I.satL \\<xi> l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma satPB_transE[simp]:\nassumes \\<xi>: \"I.wtE \\<xi>\"  shows \"I.satPB \\<xi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satPB \\<xi> \\<Phi>", "unfolding I.satPB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<Phi>. I.satC \\<xi> c", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "assume cin: \"c \\<in> \\<Phi>\""], ["proof (state)\nthis:\n  c \\<in> \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "let ?thesis = \"I.satC \\<xi> c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "have mc: \"\\<And> \\<sigma>. \\<sigma> \\<turnstile>2 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. \\<sigma> \\<turnstile>2 c", "using mcalc2[OF cin]"], ["proof (prove)\nusing this:\n  ?\\<sigma> \\<turnstile>2 c\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. \\<sigma> \\<turnstile>2 c", "."], ["proof (state)\nthis:\n  ?\\<sigma>7 \\<turnstile>2 c\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "have c: \"Ik.satC (transE \\<xi>) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ik.satC (transE \\<xi>) c", "using sat_\\<Phi> wtE_transE[OF \\<xi>] cin"], ["proof (prove)\nusing this:\n  Ik.wtE ?\\<xi> \\<Longrightarrow> Ik.satPB ?\\<xi> \\<Phi>\n  Ik.wtE (transE \\<xi>)\n  c \\<in> \\<Phi>\n\ngoal (1 subgoal):\n 1. Ik.satC (transE \\<xi>) c", "unfolding Ik.satPB_def"], ["proof (prove)\nusing this:\n  Ik.wtE ?\\<xi> \\<Longrightarrow> \\<forall>c\\<in>\\<Phi>. Ik.satC ?\\<xi> c\n  Ik.wtE (transE \\<xi>)\n  c \\<in> \\<Phi>\n\ngoal (1 subgoal):\n 1. Ik.satC (transE \\<xi>) c", "by auto"], ["proof (state)\nthis:\n  Ik.satC (transE \\<xi>) c\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "have wtC: \"Ik.wtC c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtC c", "using wt_\\<Phi> cin"], ["proof (prove)\nusing this:\n  wtPB \\<Phi>\n  c \\<in> \\<Phi>\n\ngoal (1 subgoal):\n 1. wtC c", "unfolding wtPB_def"], ["proof (prove)\nusing this:\n  Ball \\<Phi> wtC\n  c \\<in> \\<Phi>\n\ngoal (1 subgoal):\n 1. wtC c", "by auto"], ["proof (state)\nthis:\n  wtC c\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "obtain l where lin: \"l \\<in> set c\" and l: \"Ik.satL (transE \\<xi>) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> set c; Ik.satL (transE \\<xi>) l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using c"], ["proof (prove)\nusing this:\n  Ik.satC (transE \\<xi>) c\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> set c; Ik.satL (transE \\<xi>) l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Ik.satC_iff_set"], ["proof (prove)\nusing this:\n  Bex (set c) (Ik.satL (transE \\<xi>))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> set c; Ik.satL (transE \\<xi>) l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l \\<in> set c\n  Ik.satL (transE \\<xi>) l\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "have wtL: \"Ik.wtL l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtL l", "using wtC"], ["proof (prove)\nusing this:\n  wtC c\n\ngoal (1 subgoal):\n 1. wtL l", "unfolding wtC_def"], ["proof (prove)\nusing this:\n  list_all wtL c\n\ngoal (1 subgoal):\n 1. wtL l", "by (metis (lifting) lin list_all_iff)"], ["proof (state)\nthis:\n  wtL l\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "{"], ["proof (state)\nthis:\n  wtL l\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> I.satC \\<xi> c\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "hence 0: \"\\<And> l'. l' \\<in> set c \\<Longrightarrow> \\<not> I.satL \\<xi> l'\""], ["proof (prove)\nusing this:\n  \\<not> I.satC \\<xi> c\n\ngoal (1 subgoal):\n 1. \\<And>l'. l' \\<in> set c \\<Longrightarrow> \\<not> I.satL \\<xi> l'", "unfolding I.satC_iff_set"], ["proof (prove)\nusing this:\n  \\<not> Bex (set c) (I.satL \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<And>l'. l' \\<in> set c \\<Longrightarrow> \\<not> I.satL \\<xi> l'", "by auto"], ["proof (state)\nthis:\n  ?l'7 \\<in> set c \\<Longrightarrow> \\<not> I.satL \\<xi> ?l'7\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "have \"I.satL \\<xi> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.satL \\<xi> l", "proof (rule satL_transE[OF wtL \\<xi> _ l])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2L l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            wtL l' \\<and>\n                            \\<not> I.satL \\<xi> l' \\<and> isGuard x l'", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2L l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            wtL l' \\<and>\n                            \\<not> I.satL \\<xi> l' \\<and> isGuard x l'", "let ?\\<sigma> = \"tpOfV x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2L l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            wtL l' \\<and>\n                            \\<not> I.satL \\<xi> l' \\<and> isGuard x l'", "assume \\<sigma>: \"\\<not> infTp ?\\<sigma>\" and x: \"x \\<in> nv2L l\""], ["proof (state)\nthis:\n  \\<not> infTp (tpOfV x)\n  x \\<in> nv2L l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2L l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            wtL l' \\<and>\n                            \\<not> I.satL \\<xi> l' \\<and> isGuard x l'", "hence g: \"isGuard x (grdOf c l x)\""], ["proof (prove)\nusing this:\n  \\<not> infTp (tpOfV x)\n  x \\<in> nv2L l\n\ngoal (1 subgoal):\n 1. isGuard x (grdOf c l x)", "using mc[of ?\\<sigma>] lin"], ["proof (prove)\nusing this:\n  \\<not> infTp (tpOfV x)\n  x \\<in> nv2L l\n  tpOfV x \\<turnstile>2 c\n  l \\<in> set c\n\ngoal (1 subgoal):\n 1. isGuard x (grdOf c l x)", "unfolding mcalc2_iff"], ["proof (prove)\nusing this:\n  \\<not> infTp (tpOfV x)\n  x \\<in> nv2L l\n  infTp (tpOfV x) \\<or>\n  (\\<forall>l xa.\n      l \\<in> set c \\<and>\n      xa \\<in> nv2L l \\<and> tpOfV xa = tpOfV x \\<longrightarrow>\n      isGuard xa (grdOf c l xa))\n  l \\<in> set c\n\ngoal (1 subgoal):\n 1. isGuard x (grdOf c l x)", "by simp"], ["proof (state)\nthis:\n  isGuard x (grdOf c l x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> infTp (tpOfV x); x \\<in> nv2L l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            wtL l' \\<and>\n                            \\<not> I.satL \\<xi> l' \\<and> isGuard x l'", "show \"\\<exists> l'. Ik.wtL l' \\<and> \\<not> I.satL \\<xi> l' \\<and> isGuard x l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l'. wtL l' \\<and> \\<not> I.satL \\<xi> l' \\<and> isGuard x l'", "apply(rule exI[of _ \"grdOf c l x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtL (grdOf c l x) \\<and>\n    \\<not> I.satL \\<xi> (grdOf c l x) \\<and> isGuard x (grdOf c l x)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. wtL (grdOf c l x)\n 2. I.satL \\<xi> (grdOf c l x) \\<Longrightarrow> False\n 3. isGuard x (grdOf c l x)", "using g \\<sigma> cin lin wtL_grdOf x 0 grdOf x"], ["proof (prove)\nusing this:\n  isGuard x (grdOf c l x)\n  \\<not> infTp (tpOfV x)\n  c \\<in> \\<Phi>\n  l \\<in> set c\n  \\<lbrakk>?c \\<in> \\<Phi>; ?l \\<in> set ?c; ?x \\<in> nv2L ?l;\n   \\<not> infTp (tpOfV ?x)\\<rbrakk>\n  \\<Longrightarrow> wtL (grdOf ?c ?l ?x)\n  x \\<in> nv2L l\n  ?l'7 \\<in> set c \\<Longrightarrow> \\<not> I.satL \\<xi> ?l'7\n  \\<lbrakk>?c \\<in> \\<Phi>; ?l \\<in> set ?c; ?x \\<in> nv2L ?l;\n   \\<not> infTp (tpOfV ?x)\\<rbrakk>\n  \\<Longrightarrow> grdOf ?c ?l ?x \\<in> set ?c\n  x \\<in> nv2L l\n\ngoal (3 subgoals):\n 1. wtL (grdOf c l x)\n 2. I.satL \\<xi> (grdOf c l x) \\<Longrightarrow> False\n 3. isGuard x (grdOf c l x)", "by auto"], ["proof (state)\nthis:\n  \\<exists>l'. wtL l' \\<and> \\<not> I.satL \\<xi> l' \\<and> isGuard x l'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I.satL \\<xi> l\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "hence False"], ["proof (prove)\nusing this:\n  I.satL \\<xi> l\n\ngoal (1 subgoal):\n 1. False", "using 0 lin"], ["proof (prove)\nusing this:\n  I.satL \\<xi> l\n  ?l'7 \\<in> set c \\<Longrightarrow> \\<not> I.satL \\<xi> ?l'7\n  l \\<in> set c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "hence ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. I.satC \\<xi> c", "by simp"], ["proof (state)\nthis:\n  I.satC \\<xi> c\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "}"], ["proof (state)\nthis:\n  \\<not> I.satC \\<xi> c \\<Longrightarrow> I.satC \\<xi> c\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> \\<Phi> \\<Longrightarrow> I.satC \\<xi> c", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> I.satC \\<xi> c \\<Longrightarrow> I.satC \\<xi> c\n\ngoal (1 subgoal):\n 1. I.satC \\<xi> c", "by auto"], ["proof (state)\nthis:\n  I.satC \\<xi> c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma I_SAT: \"I.SAT \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I.SAT \\<Phi>", "unfolding I.SAT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<xi>. I.wtE \\<xi> \\<longrightarrow> I.satPB \\<xi> \\<Phi>", "by simp"], ["", "lemma InfModel: \"IInfModel I_intT I_intF I_intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfModel I_intT I_intF I_intP", "by standard (rule I_SAT)"], ["", "end"], ["", "(* context ModelIkPolMcalc2C *)"], ["", "sublocale ModelIkPolMcalc2C < inf?: InfModel where\nintT = I_intT and intF = I_intF and intP = I_intP"], ["proof (prove)\ngoal (1 subgoal):\n 1. IInfModel I_intT I_intF I_intP", "using InfModel"], ["proof (prove)\nusing this:\n  IInfModel I_intT I_intF I_intP\n\ngoal (1 subgoal):\n 1. IInfModel I_intT I_intF I_intP", "."], ["", "context ProblemIkPolMcalc2C begin"], ["", "abbreviation\n\"MModelIkPolMcalc2C \\<equiv> ModelIkPolMcalc2C wtFsym wtPsym arOf resOf parOf \\<Phi> infTp pol grdOf\""], ["", "theorem monot: monot"], ["proof (prove)\ngoal (1 subgoal):\n 1. monot", "unfolding monot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>intT intF intP. MModel intT intF intP) \\<longrightarrow>\n    (\\<exists>intTI intFI intPI. IInfModel intTI intFI intPI)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>intT intF intP.\n       MModel intT intF intP \\<Longrightarrow>\n       \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "fix intT intF intP"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>intT intF intP.\n       MModel intT intF intP \\<Longrightarrow>\n       \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "assume \"MModel intT intF intP\""], ["proof (state)\nthis:\n  MModel intT intF intP\n\ngoal (1 subgoal):\n 1. \\<And>intT intF intP.\n       MModel intT intF intP \\<Longrightarrow>\n       \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "hence M: \"MModelIkPolMcalc2C intT intF intP\""], ["proof (prove)\nusing this:\n  MModel intT intF intP\n\ngoal (1 subgoal):\n 1. MModelIkPolMcalc2C intT intF intP", "unfolding ModelIkPolMcalc2C_def ModelIk_def"], ["proof (prove)\nusing this:\n  MModel intT intF intP\n\ngoal (1 subgoal):\n 1. (ProblemIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp \\<and>\n     MModel intT intF intP) \\<and>\n    ProblemIkPolMcalc2C wtFsym wtPsym arOf resOf parOf \\<Phi> infTp pol\n     grdOf", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. MModel intT intF intP \\<Longrightarrow>\n    ProblemIk wtFsym wtPsym arOf resOf parOf \\<Phi> infTp\n 2. MModel intT intF intP \\<Longrightarrow>\n    ProblemIkPolMcalc2C wtFsym wtPsym arOf resOf parOf \\<Phi> infTp pol\n     grdOf", ".."], ["proof (state)\nthis:\n  MModelIkPolMcalc2C intT intF intP\n\ngoal (1 subgoal):\n 1. \\<And>intT intF intP.\n       MModel intT intF intP \\<Longrightarrow>\n       \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "show \"\\<exists> intTI intFI intPI. IInfModel intTI intFI intPI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "using ModelIkPolMcalc2C.InfModel[OF M]"], ["proof (prove)\nusing this:\n  IInfModel (ModelIkPolMcalc2C.I_intT infTp intT)\n   (ModelIkPolMcalc2C.I_intF arOf intT intF)\n   (ModelIkPolMcalc2C.I_intP parOf pol intT intP)\n\ngoal (1 subgoal):\n 1. \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI", "by auto"], ["proof (state)\nthis:\n  \\<exists>intTI intFI intPI. IInfModel intTI intFI intPI\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ProblemIkPolMcalc2 *)"], ["", "text\\<open>Final theorem in sublocale form: Any problem that passes the\n  monotonicity calculus is monotonic:\\<close>"], ["", "sublocale ProblemIkPolMcalc2C < MonotProblem"], ["proof (prove)\ngoal (1 subgoal):\n 1. MonotProblem wtFsym wtPsym arOf resOf parOf \\<Phi>", "by standard (rule monot)"], ["", "end"]]}