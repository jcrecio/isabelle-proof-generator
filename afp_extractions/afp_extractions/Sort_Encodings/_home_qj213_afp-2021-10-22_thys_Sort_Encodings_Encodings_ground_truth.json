{"file_name": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings/Encodings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sort_Encodings", "problem_names": ["theorem tags_soundness:\nfixes wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\" and resOf :: \"'fsym \\<Rightarrow> 'tp\" and parOf :: \"'psym \\<Rightarrow> 'tp list\"\nand \\<Phi> :: \"('fsym, 'psym) prob\" and infTp :: \"'tp \\<Rightarrow> bool\"\nand tpD :: \"'tp \\<Rightarrow> bool\" and tpFD :: \"'tp \\<Rightarrow> bool\"\nand intT :: \"'tp \\<Rightarrow> univ \\<Rightarrow> bool\"\nand intF :: \"'fsym \\<Rightarrow> univ list \\<Rightarrow> univ\" and intP :: \"'psym \\<Rightarrow> univ list \\<Rightarrow> bool\"\n\\<comment> \\<open>The problem translation:\\<close>\n\\<comment> \\<open>First the addition of tags (``TE'' stands for ``tag encoding''):\\<close>\ndefines \"TE_wtFsym \\<equiv> ProblemIkTpart.TE_wtFsym wtFsym resOf\"\nand \"TE_arOf \\<equiv> ProblemIkTpart.TE_arOf arOf\"\nand \"TE_resOf \\<equiv> ProblemIkTpart.TE_resOf resOf\"\ndefines \"TE_\\<Phi> \\<equiv> ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD\"\n\\<comment> \\<open>Then the deletion of types (``U'' stands for ``untyped''):\\<close>\nand \"U_arOf \\<equiv> length \\<circ> TE_arOf\"\nand \"U_parOf \\<equiv> length \\<circ> parOf\"\ndefines \"U_\\<Phi> \\<equiv> TE_\\<Phi>\"\n\\<comment> \\<open>The forward model translation:\\<close>\n\\<comment> \\<open>First, using monotonicity, we build an infinite model of @{text\"\\<Phi>\"}\n  (``I'' stands for ``infinite''):\\<close>\ndefines \"intTI \\<equiv> MonotProblem.intTI TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi>\"\nand \"intFI \\<equiv> MonotProblem.intFI TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi>\"\nand \"intPI \\<equiv> MonotProblem.intPI TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi>\"\n\\<comment> \\<open>Then, by isomorphic transfer of the lattter model, we build a model of @{text\"\\<Phi>\"}\n that has all types interpeted as @{text \"univ\"} (``F'' stands for ``full\"):\\<close>\ndefines \"intFF \\<equiv> InfModel.intFF TE_arOf TE_resOf intTI intFI\"\nand \"intPF \\<equiv> InfModel.intPF parOf intTI intPI\"\n\\<comment> \\<open>Then we build a model of @{text \"U_\\<Phi>\"}:\\<close>\ndefines \"U_intT \\<equiv> InfModel.intTF (any::'tp)\"\n\n\\<comment> \\<open>Assumptions of the theorem:\\<close>\nassumes\nP: \"ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD\"\nand M: \"CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\"\n\n\\<comment> \\<open>Conclusion of the theorem:\\<close>\nshows \"CU.Model TE_wtFsym wtPsym U_arOf U_parOf U_\\<Phi> U_intT intFF intPF\"", "theorem guards_soundness:\nfixes wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\" and resOf :: \"'fsym \\<Rightarrow> 'tp\" and parOf :: \"'psym \\<Rightarrow> 'tp list\"\nand \\<Phi> :: \"('fsym, 'psym) prob\" and infTp :: \"'tp \\<Rightarrow> bool\"\nand tpD :: \"'tp \\<Rightarrow> bool\" and tpFD :: \"'tp \\<Rightarrow> bool\" and tpCD :: \"'tp \\<Rightarrow> bool\"\nand intT :: \"'tp \\<Rightarrow> univ \\<Rightarrow> bool\"\nand intF :: \"'fsym \\<Rightarrow> univ list \\<Rightarrow> univ\"\nand intP :: \"'psym \\<Rightarrow> univ list \\<Rightarrow> bool\"\n\\<comment> \\<open>The problem translation:\\<close>\ndefines \"GE_wtFsym \\<equiv> ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD\"\nand \"GE_wtPsym \\<equiv> ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD\"\nand \"GE_arOf \\<equiv> ProblemIkTpartG.GE_arOf arOf\"\nand \"GE_resOf \\<equiv> ProblemIkTpartG.GE_resOf resOf\"\nand \"GE_parOf \\<equiv> ProblemIkTpartG.GE_parOf parOf\"\n\ndefines \"GE_\\<Phi> \\<equiv> ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD\"\nand \"U_arOf \\<equiv> length \\<circ> GE_arOf\"\nand \"U_parOf \\<equiv> length \\<circ> GE_parOf\"\n\ndefines \"U_\\<Phi> \\<equiv> GE_\\<Phi>\"\n\n\\<comment> \\<open>The model forward translation:\\<close>\ndefines \"intTI \\<equiv> MonotProblem.intTI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi>\"\nand \"intFI \\<equiv> MonotProblem.intFI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi>\"\nand \"intPI \\<equiv> MonotProblem.intPI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi>\"\n\ndefines \"intFF \\<equiv> InfModel.intFF GE_arOf GE_resOf intTI intFI\"\nand \"intPF \\<equiv> InfModel.intPF GE_parOf intTI intPI\"\n\ndefines \"U_intT \\<equiv> InfModel.intTF (any::'tp)\"\n\nassumes\nP: \"ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD tpCD\"\nand M: \"CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\"\n\nshows \"CU.Model GE_wtFsym GE_wtPsym U_arOf U_parOf U_\\<Phi> U_intT intFF intPF\"", "theorem tags_completeness:\nfixes wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\" and resOf :: \"'fsym \\<Rightarrow> 'tp\" and parOf :: \"'psym \\<Rightarrow> 'tp list\"\nand \\<Phi> :: \"('fsym, 'psym) prob\" and infTp :: \"'tp \\<Rightarrow> bool\"\nand tpD :: \"'tp \\<Rightarrow> bool\" and tpFD :: \"'tp \\<Rightarrow> bool\"\n\nand D :: \"univ \\<Rightarrow> bool\"\nand eintF :: \"('fsym,'tp) T.efsym \\<Rightarrow> univ list \\<Rightarrow> univ\"\nand eintP :: \"'psym \\<Rightarrow> univ list \\<Rightarrow> bool\"\n\n\\<comment> \\<open>The problem translation (the same as in the case of soundness):\\<close>\ndefines \"TE_wtFsym \\<equiv> ProblemIkTpart.TE_wtFsym wtFsym resOf\"\nand \"TE_arOf \\<equiv> ProblemIkTpart.TE_arOf arOf\"\nand \"TE_resOf \\<equiv> ProblemIkTpart.TE_resOf resOf\"\ndefines \"TE_\\<Phi> \\<equiv> ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD\"\nand \"U_arOf \\<equiv> length \\<circ> TE_arOf\"\nand \"U_parOf \\<equiv> length \\<circ> parOf\"\ndefines \"U_\\<Phi> \\<equiv> TE_\\<Phi>\"\n\n\\<comment> \\<open>The backward model translation:\\<close>\ndefines \"intT \\<equiv> ProblemIkTpart_TEModel.intT tpD tpFD (\\<lambda>\\<sigma>::'tp. D) eintF\"\nand \"intF \\<equiv> ProblemIkTpart_TEModel.intF arOf resOf tpD tpFD (\\<lambda>\\<sigma>::'tp. D) eintF\"\nand \"intP \\<equiv> ProblemIkTpart_TEModel.intP parOf tpD tpFD (\\<lambda>\\<sigma>::'tp. D) eintF eintP\"\n\nassumes\nP: \"ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD\" and\nM: \"CU.Model TE_wtFsym wtPsym (length o TE_arOf)\n            (length o parOf) TE_\\<Phi> D eintF eintP\"\n\nshows \"CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\"", "theorem guards_completeness:\nfixes wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\" and resOf :: \"'fsym \\<Rightarrow> 'tp\" and parOf :: \"'psym \\<Rightarrow> 'tp list\"\nand \\<Phi> :: \"('fsym, 'psym) prob\" and infTp :: \"'tp \\<Rightarrow> bool\"\nand tpD :: \"'tp \\<Rightarrow> bool\" and tpFD :: \"'tp \\<Rightarrow> bool\" and tpCD :: \"'tp \\<Rightarrow> bool\"\n\nand D :: \"univ \\<Rightarrow> bool\"\nand eintF :: \"('fsym,'tp) G.efsym \\<Rightarrow> univ list \\<Rightarrow> univ\"\nand eintP :: \"('psym,'tp) G.epsym \\<Rightarrow> univ list \\<Rightarrow> bool\"\n\n\\<comment> \\<open>The problem translation (the same as in the case of soundness):\\<close>\ndefines \"GE_wtFsym \\<equiv> ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD\"\nand \"GE_wtPsym \\<equiv> ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD\"\nand \"GE_arOf \\<equiv> ProblemIkTpartG.GE_arOf arOf\"\nand \"GE_resOf \\<equiv> ProblemIkTpartG.GE_resOf resOf\"\nand \"GE_parOf \\<equiv> ProblemIkTpartG.GE_parOf parOf\"\ndefines \"GE_\\<Phi> \\<equiv> ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD\"\nand \"U_arOf \\<equiv> length \\<circ> GE_arOf\"\nand \"U_parOf \\<equiv> length \\<circ> GE_parOf\"\ndefines \"U_\\<Phi> \\<equiv> GE_\\<Phi>\"\n\n\\<comment> \\<open>The backward model translation:\\<close>\ndefines \"intT \\<equiv> ProblemIkTpartG_GEModel.intT tpD tpFD (\\<lambda>\\<sigma>::'tp. D) eintP\"\nand \"intF \\<equiv> ProblemIkTpartG_GEModel.intF eintF\"\nand \"intP \\<equiv> ProblemIkTpartG_GEModel.intP eintP\"\n\nassumes\nP: \"ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD tpCD\" and\nM: \"CU.Model GE_wtFsym GE_wtPsym (length o GE_arOf)\n            (length o GE_parOf) GE_\\<Phi> D eintF eintP\"\n\nshows \"CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\""], "translations": [["", "theorem tags_soundness:\nfixes wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\" and resOf :: \"'fsym \\<Rightarrow> 'tp\" and parOf :: \"'psym \\<Rightarrow> 'tp list\"\nand \\<Phi> :: \"('fsym, 'psym) prob\" and infTp :: \"'tp \\<Rightarrow> bool\"\nand tpD :: \"'tp \\<Rightarrow> bool\" and tpFD :: \"'tp \\<Rightarrow> bool\"\nand intT :: \"'tp \\<Rightarrow> univ \\<Rightarrow> bool\"\nand intF :: \"'fsym \\<Rightarrow> univ list \\<Rightarrow> univ\" and intP :: \"'psym \\<Rightarrow> univ list \\<Rightarrow> bool\"\n\\<comment> \\<open>The problem translation:\\<close>\n\\<comment> \\<open>First the addition of tags (``TE'' stands for ``tag encoding''):\\<close>\ndefines \"TE_wtFsym \\<equiv> ProblemIkTpart.TE_wtFsym wtFsym resOf\"\nand \"TE_arOf \\<equiv> ProblemIkTpart.TE_arOf arOf\"\nand \"TE_resOf \\<equiv> ProblemIkTpart.TE_resOf resOf\"\ndefines \"TE_\\<Phi> \\<equiv> ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD\"\n\\<comment> \\<open>Then the deletion of types (``U'' stands for ``untyped''):\\<close>\nand \"U_arOf \\<equiv> length \\<circ> TE_arOf\"\nand \"U_parOf \\<equiv> length \\<circ> parOf\"\ndefines \"U_\\<Phi> \\<equiv> TE_\\<Phi>\"\n\\<comment> \\<open>The forward model translation:\\<close>\n\\<comment> \\<open>First, using monotonicity, we build an infinite model of @{text\"\\<Phi>\"}\n  (``I'' stands for ``infinite''):\\<close>\ndefines \"intTI \\<equiv> MonotProblem.intTI TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi>\"\nand \"intFI \\<equiv> MonotProblem.intFI TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi>\"\nand \"intPI \\<equiv> MonotProblem.intPI TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi>\"\n\\<comment> \\<open>Then, by isomorphic transfer of the lattter model, we build a model of @{text\"\\<Phi>\"}\n that has all types interpeted as @{text \"univ\"} (``F'' stands for ``full\"):\\<close>\ndefines \"intFF \\<equiv> InfModel.intFF TE_arOf TE_resOf intTI intFI\"\nand \"intPF \\<equiv> InfModel.intPF parOf intTI intPI\"\n\\<comment> \\<open>Then we build a model of @{text \"U_\\<Phi>\"}:\\<close>\ndefines \"U_intT \\<equiv> InfModel.intTF (any::'tp)\"\n\n\\<comment> \\<open>Assumptions of the theorem:\\<close>\nassumes\nP: \"ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD\"\nand M: \"CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\"\n\n\\<comment> \\<open>Conclusion of the theorem:\\<close>\nshows \"CU.Model TE_wtFsym wtPsym U_arOf U_parOf U_\\<Phi> U_intT intFF intPF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CU.Model TE_wtFsym wtPsym U_arOf U_parOf U_\\<Phi> U_intT intFF intPF", "unfolding U_arOf_def U_parOf_def U_\\<Phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CU.Model TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n     (length \\<circ> parOf) TE_\\<Phi> U_intT intFF intPF", "unfolding U_intT_def intTI_def intFI_def intPI_def intFF_def intPF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CU.Model TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n     (length \\<circ> parOf) TE_\\<Phi> (InfModel.intTF any)\n     (InfModel.intFF TE_arOf TE_resOf\n       (MonotProblem.intTI TE_wtFsym wtPsym TE_arOf TE_resOf parOf\n         TE_\\<Phi>)\n       (MonotProblem.intFI TE_wtFsym wtPsym TE_arOf TE_resOf parOf\n         TE_\\<Phi>))\n     (InfModel.intPF parOf\n       (MonotProblem.intTI TE_wtFsym wtPsym TE_arOf TE_resOf parOf\n         TE_\\<Phi>)\n       (MonotProblem.intPI TE_wtFsym wtPsym TE_arOf TE_resOf parOf\n         TE_\\<Phi>))", "apply(rule M_MonotModel.M_U_soundness)"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_MonotModel TE_wtFsym wtPsym TE_arOf TE_resOf parOf ?intT ?intF ?intP\n     TE_\\<Phi>", "unfolding M_MonotModel_def MonotModel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MonotProblem TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> \\<and>\n    CM.Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> ?intT ?intF\n     ?intP", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. MonotProblem TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi>\n 2. CM.Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> ?intT ?intF\n     ?intP", "unfolding TE_wtFsym_def TE_arOf_def TE_resOf_def TE_\\<Phi>_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. MonotProblem (ProblemIkTpart.TE_wtFsym wtFsym resOf) wtPsym\n     (ProblemIkTpart.TE_arOf arOf) (ProblemIkTpart.TE_resOf resOf) parOf\n     (ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD)\n 2. CM.Model (ProblemIkTpart.TE_wtFsym wtFsym resOf) wtPsym\n     (ProblemIkTpart.TE_arOf arOf) (ProblemIkTpart.TE_resOf resOf) parOf\n     (ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD) ?intT ?intF\n     ?intP", "apply(rule ProblemIkTpart.T_monotonic)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp3 tpD tpFD\n 2. CM.Model (ProblemIkTpart.TE_wtFsym wtFsym resOf) wtPsym\n     (ProblemIkTpart.TE_arOf arOf) (ProblemIkTpart.TE_resOf resOf) parOf\n     (ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD) ?intT ?intF\n     ?intP", "apply(rule P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model (ProblemIkTpart.TE_wtFsym wtFsym resOf) wtPsym\n     (ProblemIkTpart.TE_arOf arOf) (ProblemIkTpart.TE_resOf resOf) parOf\n     (ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD) ?intT ?intF\n     ?intP", "apply(rule ModelIkTpart.T_soundness)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ModelIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp5 tpD tpFD\n     ?intT ?intF5 ?intP", "unfolding ModelIkTpart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp5 tpD\n     tpFD \\<and>\n    CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> ?intT ?intF5 ?intP", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp5 tpD tpFD\n 2. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> ?intT ?intF5 ?intP", "apply(rule P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> ?intT ?intF5 ?intP", "apply(rule M)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\\ \\\\ \\bf Soundness of the guard encodings: \\ \\\\\\<close>"], ["", "text\\<open>Here the assumptions and conclusion have a similar shapes as those\nfor the tag encodings. The difference is in the first assumption,\n\\<open>ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD tpCD\\<close>,\nwhich consists of \\<open>ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD\\<close> together\nwith the following assumptions about \\<open>tpCD\\<close>:\n\\\\-- \\<open>tpCD\\<close> is included in \\<open>tpD\\<close>\n\\\\-- if a result type of an operation symbol is in \\<open>tpD\\<close>, then so are all the types in its arity\n\\<close>"], ["", "text\\<open>We have the following particular cases of our parameterized guard encoding:\n\\\\-- if \\<open>tpD\\<close> and \\<open>tpCD\\<close> are taked to be everywhere true\n(hence \\<open>tpFD\\<close> becomes everywhere false),\nwe obtain the traditional guard encoding\n\\\\-- if \\<open>tpCD\\<close> is taken to be false and \\<open>tpD\\<close> is taken to be true precisely when the\nmonotonicity calculus fails,\nwe obtain the lightweight tag encoding\n\\\\-- if \\<open>tpFD\\<close> is taken to be true precisely when the monotonicity calculus fails,\nwe obtain the featherweight tag encoding\n\\<close>"], ["", "theorem guards_soundness:\nfixes wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\" and resOf :: \"'fsym \\<Rightarrow> 'tp\" and parOf :: \"'psym \\<Rightarrow> 'tp list\"\nand \\<Phi> :: \"('fsym, 'psym) prob\" and infTp :: \"'tp \\<Rightarrow> bool\"\nand tpD :: \"'tp \\<Rightarrow> bool\" and tpFD :: \"'tp \\<Rightarrow> bool\" and tpCD :: \"'tp \\<Rightarrow> bool\"\nand intT :: \"'tp \\<Rightarrow> univ \\<Rightarrow> bool\"\nand intF :: \"'fsym \\<Rightarrow> univ list \\<Rightarrow> univ\"\nand intP :: \"'psym \\<Rightarrow> univ list \\<Rightarrow> bool\"\n\\<comment> \\<open>The problem translation:\\<close>\ndefines \"GE_wtFsym \\<equiv> ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD\"\nand \"GE_wtPsym \\<equiv> ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD\"\nand \"GE_arOf \\<equiv> ProblemIkTpartG.GE_arOf arOf\"\nand \"GE_resOf \\<equiv> ProblemIkTpartG.GE_resOf resOf\"\nand \"GE_parOf \\<equiv> ProblemIkTpartG.GE_parOf parOf\"\n\ndefines \"GE_\\<Phi> \\<equiv> ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD\"\nand \"U_arOf \\<equiv> length \\<circ> GE_arOf\"\nand \"U_parOf \\<equiv> length \\<circ> GE_parOf\"\n\ndefines \"U_\\<Phi> \\<equiv> GE_\\<Phi>\"\n\n\\<comment> \\<open>The model forward translation:\\<close>\ndefines \"intTI \\<equiv> MonotProblem.intTI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi>\"\nand \"intFI \\<equiv> MonotProblem.intFI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi>\"\nand \"intPI \\<equiv> MonotProblem.intPI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi>\"\n\ndefines \"intFF \\<equiv> InfModel.intFF GE_arOf GE_resOf intTI intFI\"\nand \"intPF \\<equiv> InfModel.intPF GE_parOf intTI intPI\"\n\ndefines \"U_intT \\<equiv> InfModel.intTF (any::'tp)\"\n\nassumes\nP: \"ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD tpCD\"\nand M: \"CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\"\n\nshows \"CU.Model GE_wtFsym GE_wtPsym U_arOf U_parOf U_\\<Phi> U_intT intFF intPF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CU.Model GE_wtFsym GE_wtPsym U_arOf U_parOf U_\\<Phi> U_intT intFF intPF", "unfolding U_arOf_def U_parOf_def U_\\<Phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CU.Model GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n     (length \\<circ> GE_parOf) GE_\\<Phi> U_intT intFF intPF", "unfolding U_intT_def intTI_def intFI_def intPI_def intFF_def intPF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CU.Model GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n     (length \\<circ> GE_parOf) GE_\\<Phi> (InfModel.intTF any)\n     (InfModel.intFF GE_arOf GE_resOf\n       (MonotProblem.intTI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf\n         GE_\\<Phi>)\n       (MonotProblem.intFI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf\n         GE_\\<Phi>))\n     (InfModel.intPF GE_parOf\n       (MonotProblem.intTI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf\n         GE_\\<Phi>)\n       (MonotProblem.intPI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf\n         GE_\\<Phi>))", "apply(rule M_MonotModel.M_U_soundness)"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_MonotModel GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf ?intT ?intF\n     ?intP GE_\\<Phi>", "unfolding M_MonotModel_def MonotModel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MonotProblem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf\n     GE_\\<Phi> \\<and>\n    CM.Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi> ?intT\n     ?intF ?intP", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. MonotProblem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi>\n 2. CM.Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi> ?intT\n     ?intF ?intP", "unfolding GE_wtFsym_def GE_wtPsym_def GE_arOf_def GE_resOf_def GE_parOf_def GE_\\<Phi>_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. MonotProblem (ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD)\n     (ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD)\n     (ProblemIkTpartG.GE_arOf arOf) (ProblemIkTpartG.GE_resOf resOf)\n     (ProblemIkTpartG.GE_parOf parOf)\n     (ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD)\n 2. CM.Model (ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD)\n     (ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD)\n     (ProblemIkTpartG.GE_arOf arOf) (ProblemIkTpartG.GE_resOf resOf)\n     (ProblemIkTpartG.GE_parOf parOf)\n     (ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD) ?intT\n     ?intF ?intP", "apply(rule ProblemIkTpartG.G_monotonic)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp3 tpD tpFD\n     tpCD\n 2. CM.Model (ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD)\n     (ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD)\n     (ProblemIkTpartG.GE_arOf arOf) (ProblemIkTpartG.GE_resOf resOf)\n     (ProblemIkTpartG.GE_parOf parOf)\n     (ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD) ?intT\n     ?intF ?intP", "apply(rule P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model (ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD)\n     (ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD)\n     (ProblemIkTpartG.GE_arOf arOf) (ProblemIkTpartG.GE_resOf resOf)\n     (ProblemIkTpartG.GE_parOf parOf)\n     (ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD) ?intT\n     ?intF ?intP", "apply(rule ModelIkTpartG.G_soundness)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ModelIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp5 tpD tpFD\n     tpCD ?intT ?intF5 ?intP5", "unfolding ModelIkTpartG_def ModelIkTpart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp5 tpD tpFD\n     tpCD \\<and>\n    ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp5 tpD\n     tpFD \\<and>\n    CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> ?intT ?intF5 ?intP5", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp5 tpD tpFD\n     tpCD\n 2. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp5 tpD tpFD\n 3. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> ?intT ?intF5 ?intP5", "apply(rule P)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD\n 2. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> ?intT ?intF5 ?intP5", "using P"], ["proof (prove)\nusing this:\n  ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD tpCD\n\ngoal (2 subgoals):\n 1. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD\n 2. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> ?intT ?intF5 ?intP5", "unfolding ProblemIkTpartG_def"], ["proof (prove)\nusing this:\n  ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD \\<and>\n  ProblemIkTpartG_axioms arOf tpD tpCD\n\ngoal (2 subgoals):\n 1. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD\n 2. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> ?intT ?intF5 ?intP5", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> ?intT ?intF5 ?intP5", "apply(rule M)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Completeness\\<close>"], ["", "text\\<open>The setting is similar to the one for completeness, except for the following point:\n\n(3) The constitutive parts of a structure over the untyped signature\nresulted from the addition of the tags or guards followed by\nthe deletion of the types: \\<open>(D, eintF, eintP)\\<close>\n\\<close>"], ["", "text\\<open>\\ \\\\ \\bf Completeness of the tag encodings \\ \\\\\\<close>"], ["", "theorem tags_completeness:\nfixes wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\" and resOf :: \"'fsym \\<Rightarrow> 'tp\" and parOf :: \"'psym \\<Rightarrow> 'tp list\"\nand \\<Phi> :: \"('fsym, 'psym) prob\" and infTp :: \"'tp \\<Rightarrow> bool\"\nand tpD :: \"'tp \\<Rightarrow> bool\" and tpFD :: \"'tp \\<Rightarrow> bool\"\n\nand D :: \"univ \\<Rightarrow> bool\"\nand eintF :: \"('fsym,'tp) T.efsym \\<Rightarrow> univ list \\<Rightarrow> univ\"\nand eintP :: \"'psym \\<Rightarrow> univ list \\<Rightarrow> bool\"\n\n\\<comment> \\<open>The problem translation (the same as in the case of soundness):\\<close>\ndefines \"TE_wtFsym \\<equiv> ProblemIkTpart.TE_wtFsym wtFsym resOf\"\nand \"TE_arOf \\<equiv> ProblemIkTpart.TE_arOf arOf\"\nand \"TE_resOf \\<equiv> ProblemIkTpart.TE_resOf resOf\"\ndefines \"TE_\\<Phi> \\<equiv> ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD\"\nand \"U_arOf \\<equiv> length \\<circ> TE_arOf\"\nand \"U_parOf \\<equiv> length \\<circ> parOf\"\ndefines \"U_\\<Phi> \\<equiv> TE_\\<Phi>\"\n\n\\<comment> \\<open>The backward model translation:\\<close>\ndefines \"intT \\<equiv> ProblemIkTpart_TEModel.intT tpD tpFD (\\<lambda>\\<sigma>::'tp. D) eintF\"\nand \"intF \\<equiv> ProblemIkTpart_TEModel.intF arOf resOf tpD tpFD (\\<lambda>\\<sigma>::'tp. D) eintF\"\nand \"intP \\<equiv> ProblemIkTpart_TEModel.intP parOf tpD tpFD (\\<lambda>\\<sigma>::'tp. D) eintF eintP\"\n\nassumes\nP: \"ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD\" and\nM: \"CU.Model TE_wtFsym wtPsym (length o TE_arOf)\n            (length o parOf) TE_\\<Phi> D eintF eintP\"\n\nshows \"CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP", "have UM: \"UM_Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> D eintF eintP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UM_Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> D eintF eintP", "unfolding UM_Model_def UM_Struct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_Problem TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> \\<and>\n    (M_Signature TYPE('tp) TE_wtFsym wtPsym \\<and>\n     CU.Struct TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n      (length \\<circ> parOf) D eintF eintP) \\<and>\n    CU.Model TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n     (length \\<circ> parOf) TE_\\<Phi> D eintF eintP", "using M"], ["proof (prove)\nusing this:\n  CU.Model TE_wtFsym wtPsym (length \\<circ> TE_arOf) (length \\<circ> parOf)\n   TE_\\<Phi> D eintF eintP\n\ngoal (1 subgoal):\n 1. M_Problem TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> \\<and>\n    (M_Signature TYPE('tp) TE_wtFsym wtPsym \\<and>\n     CU.Struct TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n      (length \\<circ> parOf) D eintF eintP) \\<and>\n    CU.Model TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n     (length \\<circ> parOf) TE_\\<Phi> D eintF eintP", "unfolding CU.Model_def CU.Struct_def U.Model_def"], ["proof (prove)\nusing this:\n  U.Problem TE_wtFsym wtPsym (length \\<circ> TE_arOf) (length \\<circ> parOf)\n   TE_\\<Phi> \\<and>\n  U.Struct TE_wtFsym wtPsym (length \\<circ> TE_arOf) (length \\<circ> parOf)\n   D eintF eintP \\<and>\n  U.Model_axioms TE_\\<Phi> D eintF eintP\n\ngoal (1 subgoal):\n 1. M_Problem TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> \\<and>\n    (M_Signature TYPE('tp) TE_wtFsym wtPsym \\<and>\n     U.Struct TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n      (length \\<circ> parOf) D eintF eintP) \\<and>\n    U.Problem TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n     (length \\<circ> parOf) TE_\\<Phi> \\<and>\n    U.Struct TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n     (length \\<circ> parOf) D eintF eintP \\<and>\n    U.Model_axioms TE_\\<Phi> D eintF eintP", "using ProblemIkTpart.T_monotonic[OF P,\n  unfolded TE_wtFsym_def[symmetric] TE_arOf_def[symmetric]\n           TE_resOf_def[symmetric] TE_\\<Phi>_def[symmetric]]"], ["proof (prove)\nusing this:\n  U.Problem TE_wtFsym wtPsym (length \\<circ> TE_arOf) (length \\<circ> parOf)\n   TE_\\<Phi> \\<and>\n  U.Struct TE_wtFsym wtPsym (length \\<circ> TE_arOf) (length \\<circ> parOf)\n   D eintF eintP \\<and>\n  U.Model_axioms TE_\\<Phi> D eintF eintP\n  MonotProblem TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi>\n\ngoal (1 subgoal):\n 1. M_Problem TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> \\<and>\n    (M_Signature TYPE('tp) TE_wtFsym wtPsym \\<and>\n     U.Struct TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n      (length \\<circ> parOf) D eintF eintP) \\<and>\n    U.Problem TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n     (length \\<circ> parOf) TE_\\<Phi> \\<and>\n    U.Struct TE_wtFsym wtPsym (length \\<circ> TE_arOf)\n     (length \\<circ> parOf) D eintF eintP \\<and>\n    U.Model_axioms TE_\\<Phi> D eintF eintP", "by (auto simp: MonotProblem_def M_Problem_def M_Signature_def M.Problem_def)"], ["proof (state)\nthis:\n  UM_Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\\<Phi> D eintF eintP\n\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP", "unfolding intT_def intF_def intP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi>\n     (ProblemIkTpart_TEModel.intT tpD tpFD (\\<lambda>\\<sigma>. D) eintF)\n     (ProblemIkTpart_TEModel.intF arOf resOf tpD tpFD (\\<lambda>\\<sigma>. D)\n       eintF)\n     (ProblemIkTpart_TEModel.intP parOf tpD tpFD (\\<lambda>\\<sigma>. D)\n       eintF eintP)", "apply(rule ProblemIkTpart_TEModel.T_completeness)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkTpart_TEModel wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp tpD\n     tpFD (\\<lambda>\\<sigma>. D) eintF eintP", "unfolding ProblemIkTpart_TEModel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp tpD\n     tpFD \\<and>\n    CM.Model (ProblemIkTpart.TE_wtFsym wtFsym resOf) wtPsym\n     (ProblemIkTpart.TE_arOf arOf) (ProblemIkTpart.TE_resOf resOf) parOf\n     (ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD)\n     (\\<lambda>\\<sigma>. D) eintF eintP", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. ProblemIkTpart wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp tpD tpFD\n 2. CM.Model (ProblemIkTpart.TE_wtFsym wtFsym resOf) wtPsym\n     (ProblemIkTpart.TE_arOf arOf) (ProblemIkTpart.TE_resOf resOf) parOf\n     (ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD)\n     (\\<lambda>\\<sigma>. D) eintF eintP", "apply(rule P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model (ProblemIkTpart.TE_wtFsym wtFsym resOf) wtPsym\n     (ProblemIkTpart.TE_arOf arOf) (ProblemIkTpart.TE_resOf resOf) parOf\n     (ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD)\n     (\\<lambda>\\<sigma>. D) eintF eintP", "apply(rule UM_Model.M_U_completeness)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UM_Model (ProblemIkTpart.TE_wtFsym wtFsym resOf) wtPsym\n     (ProblemIkTpart.TE_arOf arOf) (ProblemIkTpart.TE_resOf resOf) parOf\n     (ProblemIkTpart.tPB wtFsym arOf resOf \\<Phi> tpD tpFD) D eintF eintP", "apply(rule UM[unfolded TE_wtFsym_def TE_arOf_def TE_resOf_def TE_\\<Phi>_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\\ \\\\ \\bf Completeness of the guard encodings \\ \\\\\\<close>"], ["", "theorem guards_completeness:\nfixes wtFsym :: \"'fsym \\<Rightarrow> bool\" and wtPsym :: \"'psym \\<Rightarrow> bool\"\nand arOf :: \"'fsym \\<Rightarrow> 'tp list\" and resOf :: \"'fsym \\<Rightarrow> 'tp\" and parOf :: \"'psym \\<Rightarrow> 'tp list\"\nand \\<Phi> :: \"('fsym, 'psym) prob\" and infTp :: \"'tp \\<Rightarrow> bool\"\nand tpD :: \"'tp \\<Rightarrow> bool\" and tpFD :: \"'tp \\<Rightarrow> bool\" and tpCD :: \"'tp \\<Rightarrow> bool\"\n\nand D :: \"univ \\<Rightarrow> bool\"\nand eintF :: \"('fsym,'tp) G.efsym \\<Rightarrow> univ list \\<Rightarrow> univ\"\nand eintP :: \"('psym,'tp) G.epsym \\<Rightarrow> univ list \\<Rightarrow> bool\"\n\n\\<comment> \\<open>The problem translation (the same as in the case of soundness):\\<close>\ndefines \"GE_wtFsym \\<equiv> ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD\"\nand \"GE_wtPsym \\<equiv> ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD\"\nand \"GE_arOf \\<equiv> ProblemIkTpartG.GE_arOf arOf\"\nand \"GE_resOf \\<equiv> ProblemIkTpartG.GE_resOf resOf\"\nand \"GE_parOf \\<equiv> ProblemIkTpartG.GE_parOf parOf\"\ndefines \"GE_\\<Phi> \\<equiv> ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD\"\nand \"U_arOf \\<equiv> length \\<circ> GE_arOf\"\nand \"U_parOf \\<equiv> length \\<circ> GE_parOf\"\ndefines \"U_\\<Phi> \\<equiv> GE_\\<Phi>\"\n\n\\<comment> \\<open>The backward model translation:\\<close>\ndefines \"intT \\<equiv> ProblemIkTpartG_GEModel.intT tpD tpFD (\\<lambda>\\<sigma>::'tp. D) eintP\"\nand \"intF \\<equiv> ProblemIkTpartG_GEModel.intF eintF\"\nand \"intP \\<equiv> ProblemIkTpartG_GEModel.intP eintP\"\n\nassumes\nP: \"ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> infTp tpD tpFD tpCD\" and\nM: \"CU.Model GE_wtFsym GE_wtPsym (length o GE_arOf)\n            (length o GE_parOf) GE_\\<Phi> D eintF eintP\"\n\nshows \"CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP", "have UM: \"UM_Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi> D eintF eintP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UM_Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi> D eintF\n     eintP", "unfolding UM_Model_def UM_Struct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_Problem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi> \\<and>\n    (M_Signature TYPE('tp) GE_wtFsym GE_wtPsym \\<and>\n     CU.Struct GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n      (length \\<circ> GE_parOf) D eintF eintP) \\<and>\n    CU.Model GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n     (length \\<circ> GE_parOf) GE_\\<Phi> D eintF eintP", "using M"], ["proof (prove)\nusing this:\n  CU.Model GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n   (length \\<circ> GE_parOf) GE_\\<Phi> D eintF eintP\n\ngoal (1 subgoal):\n 1. M_Problem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi> \\<and>\n    (M_Signature TYPE('tp) GE_wtFsym GE_wtPsym \\<and>\n     CU.Struct GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n      (length \\<circ> GE_parOf) D eintF eintP) \\<and>\n    CU.Model GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n     (length \\<circ> GE_parOf) GE_\\<Phi> D eintF eintP", "unfolding CU.Model_def CU.Struct_def U.Model_def"], ["proof (prove)\nusing this:\n  U.Problem GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n   (length \\<circ> GE_parOf) GE_\\<Phi> \\<and>\n  U.Struct GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n   (length \\<circ> GE_parOf) D eintF eintP \\<and>\n  U.Model_axioms GE_\\<Phi> D eintF eintP\n\ngoal (1 subgoal):\n 1. M_Problem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi> \\<and>\n    (M_Signature TYPE('tp) GE_wtFsym GE_wtPsym \\<and>\n     U.Struct GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n      (length \\<circ> GE_parOf) D eintF eintP) \\<and>\n    U.Problem GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n     (length \\<circ> GE_parOf) GE_\\<Phi> \\<and>\n    U.Struct GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n     (length \\<circ> GE_parOf) D eintF eintP \\<and>\n    U.Model_axioms GE_\\<Phi> D eintF eintP", "using ProblemIkTpartG.G_monotonic[OF P,\n  unfolded GE_wtFsym_def[symmetric] GE_arOf_def[symmetric]\n           GE_wtPsym_def[symmetric] GE_parOf_def[symmetric]\n           GE_resOf_def[symmetric] GE_\\<Phi>_def[symmetric]]"], ["proof (prove)\nusing this:\n  U.Problem GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n   (length \\<circ> GE_parOf) GE_\\<Phi> \\<and>\n  U.Struct GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n   (length \\<circ> GE_parOf) D eintF eintP \\<and>\n  U.Model_axioms GE_\\<Phi> D eintF eintP\n  MonotProblem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi>\n\ngoal (1 subgoal):\n 1. M_Problem GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi> \\<and>\n    (M_Signature TYPE('tp) GE_wtFsym GE_wtPsym \\<and>\n     U.Struct GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n      (length \\<circ> GE_parOf) D eintF eintP) \\<and>\n    U.Problem GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n     (length \\<circ> GE_parOf) GE_\\<Phi> \\<and>\n    U.Struct GE_wtFsym GE_wtPsym (length \\<circ> GE_arOf)\n     (length \\<circ> GE_parOf) D eintF eintP \\<and>\n    U.Model_axioms GE_\\<Phi> D eintF eintP", "by (auto simp: MonotProblem_def M_Problem_def M_Signature_def M.Problem_def)"], ["proof (state)\nthis:\n  UM_Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\\<Phi> D eintF\n   eintP\n\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP", "unfolding intT_def intF_def intP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi>\n     (ProblemIkTpartG_GEModel.intT tpD tpFD (\\<lambda>\\<sigma>. D) eintP)\n     (ProblemIkTpartG_GEModel.intF eintF)\n     (ProblemIkTpartG_GEModel.intP eintP)", "apply(rule ProblemIkTpartG_GEModel.G_completeness)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkTpartG_GEModel wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp tpD\n     tpFD ?protCl (\\<lambda>\\<sigma>. D) eintF eintP", "unfolding ProblemIkTpartG_GEModel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp tpD tpFD\n     ?protCl \\<and>\n    CM.Model (ProblemIkTpartG.GE_wtFsym wtFsym resOf ?protCl)\n     (ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD)\n     (ProblemIkTpartG.GE_arOf arOf) (ProblemIkTpartG.GE_resOf resOf)\n     (ProblemIkTpartG.GE_parOf parOf)\n     (ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD ?protCl)\n     (\\<lambda>\\<sigma>. D) eintF eintP", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \\<Phi> ?infTp tpD tpFD\n     ?protCl\n 2. CM.Model (ProblemIkTpartG.GE_wtFsym wtFsym resOf ?protCl)\n     (ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD)\n     (ProblemIkTpartG.GE_arOf arOf) (ProblemIkTpartG.GE_resOf resOf)\n     (ProblemIkTpartG.GE_parOf parOf)\n     (ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD ?protCl)\n     (\\<lambda>\\<sigma>. D) eintF eintP", "apply(rule P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CM.Model (ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD)\n     (ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD)\n     (ProblemIkTpartG.GE_arOf arOf) (ProblemIkTpartG.GE_resOf resOf)\n     (ProblemIkTpartG.GE_parOf parOf)\n     (ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD)\n     (\\<lambda>\\<sigma>. D) eintF eintP", "apply(rule UM_Model.M_U_completeness)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UM_Model (ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD)\n     (ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD)\n     (ProblemIkTpartG.GE_arOf arOf) (ProblemIkTpartG.GE_resOf resOf)\n     (ProblemIkTpartG.GE_parOf parOf)\n     (ProblemIkTpartG.gPB wtFsym arOf resOf \\<Phi> tpD tpFD tpCD) D eintF\n     eintP", "apply(rule UM[unfolded GE_wtFsym_def GE_wtPsym_def GE_parOf_def\n             GE_arOf_def GE_resOf_def GE_\\<Phi>_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  CM.Model wtFsym wtPsym arOf resOf parOf \\<Phi> intT intF intP\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}