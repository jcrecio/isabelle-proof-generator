{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Polygon.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma polychainI:\n  assumes \"\\<And>i. Suc i < length xs \\<Longrightarrow> snd (xs ! i) = fst (xs ! Suc i)\"\n  shows \"polychain xs\"", "lemma polychain_Nil[simp]: \"polychain [] = True\"\n  and polychain_singleton[simp]: \"polychain [x] = True\"", "lemma polychain_Cons:\n  \"polychain (y # ys) = (if ys = [] then True else snd y = fst (ys ! 0) \\<and> polychain ys)\"", "lemma polychain_appendI:\n  \"polychain xs \\<Longrightarrow> polychain ys \\<Longrightarrow> (xs \\<noteq> [] \\<Longrightarrow> ys \\<noteq> [] \\<Longrightarrow> snd (last xs) = fst (hd ys)) \\<Longrightarrow>\n    polychain (xs @ ys)\"", "lemma pairself_apply: \"pairself f x = (f (fst x), f (snd x))\"", "lemma polychain_map_pairself: \"polychain xs \\<Longrightarrow> polychain (map (pairself f) xs)\"", "lemma convex_polychain_Cons2[simp]:\n  \"convex_polychain (x#y#zs) \\<longleftrightarrow>\n    snd x = fst y \\<and> det3 (fst x) (fst y) (snd y) > 0 \\<and> convex_polychain (y#zs)\"", "lemma convex_polychain_ConsD:\n  assumes \"convex_polychain (x#xs)\"\n  shows \"convex_polychain xs\"", "lemma convex_polychain_Nil[simp]: \"convex_polychain [] = True\"\n  and convex_polychain_Cons[simp]: \"convex_polychain [x] = True\"", "lemma convex_polygon_Cons2[simp]:\n  \"convex_polygon (x#y#zs) \\<longleftrightarrow> fst x = snd (last (y#zs)) \\<and> convex_polychain (x#y#zs)\"", "lemma polychain_append_connected:\n  \"polychain (xs @ ys) \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> ys \\<noteq> [] \\<Longrightarrow> fst (hd ys) = snd (last xs)\"", "lemma convex_polychain_appendI:\n  assumes cxs: \"convex_polychain xs\"\n  assumes cys: \"convex_polychain ys\"\n  assumes pxy: \"polychain (xs @ ys)\"\n  assumes \"xs \\<noteq> [] \\<Longrightarrow> ys \\<noteq> [] \\<Longrightarrow> det3 (fst (last xs)) (snd (last xs)) (snd (hd ys)) > 0\"\n  shows \"convex_polychain (xs @ ys)\"", "lemma convex_polychainI:\n  assumes \"polychain xs\"\n  assumes \"\\<And>i. Suc i < length xs \\<Longrightarrow> det3 (fst (xs ! i)) (snd (xs ! i)) (snd (xs ! Suc i)) > 0\"\n  shows \"convex_polychain xs\"", "lemma convex_polygon_skip:\n  assumes \"convex_polygon (x # y # z # w # ws)\"\n  assumes \"ccw'.sortedP (fst x) (map snd (butlast (x # y # z # w # ws)))\"\n  shows \"convex_polygon ((fst x, snd y) # z # w # ws)\"", "lemma in_set_polychain_ofD: \"ab \\<in> set (polychain_of x xs) \\<Longrightarrow> (snd ab - fst ab) \\<in> set xs\"", "lemma fst_polychain_of_nth_0[simp]: \"xs \\<noteq> [] \\<Longrightarrow> fst ((polychain_of p xs) ! 0) = p\"", "lemma fst_hd_polychain_of: \"xs \\<noteq> [] \\<Longrightarrow> fst (hd (polychain_of x xs)) = x\"", "lemma length_polychain_of_eq[simp]:\n  shows \"length (polychain_of p qs) = length qs\"", "lemma\n  polychain_of_subsequent_eq:\n  assumes \"Suc i < length qs\"\n  shows \"snd (polychain_of p qs ! i) = fst (polychain_of p qs ! Suc i)\"", "lemma polychain_of_eq_empty_iff[simp]: \"polychain_of p xs = [] \\<longleftrightarrow> xs = []\"", "lemma in_set_polychain_of_imp_sum_list:\n  assumes \"z \\<in> set (polychain_of Pc Ps)\"\n  obtains d where \"z = (Pc + sum_list (take d Ps), Pc + sum_list (take (Suc d) Ps))\"", "lemma last_polychain_of: \"length xs > 0 \\<Longrightarrow> snd (last (polychain_of p xs)) = p + sum_list xs\"", "lemma polychain_of_singleton_iff: \"polychain_of p xs = [a] \\<longleftrightarrow> fst a = p \\<and> xs = [(snd a - p)]\"", "lemma polychain_of_add: \"polychain_of (x + y) xs = map (((+) (y, y))) (polychain_of x xs)\"", "lemma dirvec_minus: \"dirvec x = snd x - fst x\"", "lemma dirvec_nth_polychain_of: \"n < length xs \\<Longrightarrow> dirvec ((polychain_of p xs) ! n ) = (xs ! n)\"", "lemma dirvec_hd_polychain_of: \"xs \\<noteq> [] \\<Longrightarrow> dirvec (hd (polychain_of p xs)) = (hd xs)\"", "lemma dirvec_last_polychain_of: \"xs \\<noteq> [] \\<Longrightarrow> dirvec (last (polychain_of p xs)) = (last xs)\"", "lemma map_dirvec_polychain_of[simp]: \"map dirvec (polychain_of x xs) = xs\"", "lemma ccw'_sortedP_translateD:\n  \"linorder_list0.sortedP (ccw' x0) (map ((+) x \\<circ> g) xs) \\<Longrightarrow>\n    linorder_list0.sortedP (ccw' (x0 - x)) (map g xs)\"", "lemma ccw'_sortedP_translateI:\n  \"linorder_list0.sortedP (ccw' (x0 - x)) (map g xs) \\<Longrightarrow>\n    linorder_list0.sortedP (ccw' x0) (map ((+) x \\<circ> g) xs)\"", "lemma ccw'_sortedP_translate_comp[simp]:\n  \"linorder_list0.sortedP (ccw' x0) (map ((+) x \\<circ> g) xs) \\<longleftrightarrow>\n    linorder_list0.sortedP (ccw' (x0 - x)) (map g xs)\"", "lemma snd_plus_commute: \"snd \\<circ> (+) (x0, x0) = (+) x0 o snd\"", "lemma ccw'_sortedP_renormalize:\n  \"ccw'.sortedP a (map snd (polychain_of (x0 + x) xs)) \\<longleftrightarrow>\n   ccw'.sortedP (a - x0) (map snd (polychain_of x xs))\"", "lemma ccw'_sortedP_polychain_of01:\n  shows \"ccw'.sortedP 0 [u] \\<Longrightarrow> ccw'.sortedP x0 (map snd (polychain_of x0 [u]))\"\n    and \"ccw'.sortedP 0 [] \\<Longrightarrow> ccw'.sortedP x0 (map snd (polychain_of x0 []))\"", "lemma ccw'_sortedP_polychain_of2:\n  assumes \"ccw'.sortedP 0 [u, v]\"\n  shows \"ccw'.sortedP x0 (map snd (polychain_of x0 [u, v]))\"", "lemma ccw'_sortedP_polychain_of3:\n  assumes \"ccw'.sortedP 0 (u#v#w#xs)\"\n  shows \"ccw'.sortedP x0 (map snd (polychain_of x0 (u#v#w#xs)))\"", "lemma ccw'_sortedP_polychain_of_snd:\n  assumes \"ccw'.sortedP 0 xs\"\n  shows \"ccw'.sortedP x0 (map snd (polychain_of x0 xs))\"", "lemma ccw'_sortedP_implies_distinct:\n  assumes \"ccw'.sortedP x qs\"\n  shows \"distinct qs\"", "lemma ccw'_sortedP_implies_nonaligned:\n  assumes \"ccw'.sortedP x qs\"\n  assumes \"y \\<in> set qs\" \"z \\<in> set qs\" \"y \\<noteq> z\"\n  shows \"\\<not> coll x y z\"", "lemma list_all_mp: \"list_all P xs \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> P x \\<Longrightarrow> Q x) \\<Longrightarrow> list_all Q xs\"", "lemma\n  ccw'_scale_origin:\n  assumes \"e \\<in> UNIV \\<rightarrow> {0<..<1}\"\n  assumes \"x \\<in> set (polychain_of Pc (P # QRRs))\"\n  assumes \"ccw'.sortedP 0 (P # QRRs)\"\n  assumes \"ccw' (fst x) (snd x) (P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\"\n  shows \"ccw' (fst x) (snd x) (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\"", "lemma polychain_of_ccw_convex:\n  assumes \"e \\<in> UNIV \\<rightarrow> {0 <..< 1}\"\n  assumes sorted: \"linorder_list0.sortedP (ccw' 0) (P#Q#Ps)\"\n  shows \"list_all\n    (\\<lambda>(xi, xj). ccw' xi xj (Pc + (\\<Sum>P \\<in> set (P#Q#Ps). e P *\\<^sub>R P)))\n    (polychain_of Pc (P#Q#Ps))\"", "lemma polychain_of_ccw:\n  assumes \"e \\<in> UNIV \\<rightarrow> {0 <..< 1}\"\n  assumes sorted: \"ccw'.sortedP 0 qs\"\n  assumes qs: \"length qs \\<noteq> 1\"\n  shows \"list_all (\\<lambda>(xi, xj). ccw' xi xj (Pc + (\\<Sum>P \\<in> set qs. e P *\\<^sub>R P))) (polychain_of Pc qs)\"", "lemma in_polychain_of_ccw:\n  assumes \"e \\<in> UNIV \\<rightarrow> {0 <..< 1}\"\n  assumes \"ccw'.sortedP 0 qs\"\n  assumes \"length qs \\<noteq> 1\"\n  assumes \"seg \\<in> set (polychain_of Pc qs)\"\n  shows \"ccw' (fst seg) (snd seg) (Pc + (\\<Sum>P \\<in> set qs. e P *\\<^sub>R P))\"", "lemma distinct_butlast_ne_last: \"distinct xs \\<Longrightarrow> x \\<in> set (butlast xs) \\<Longrightarrow> x \\<noteq> last xs\"", "lemma\n  ccw'_sortedP_convex_rotate_aux:\n  assumes \"ccw'.sortedP 0 (zs)\" \"ccw'.sortedP x (map snd (polychain_of x (zs)))\"\n  shows \"ccw'.sortedP (snd (last (polychain_of x (zs)))) (map snd (butlast (polychain_of x (zs))))\"", "lemma ccw'_polychain_of_sorted_center_last:\n  assumes set_butlast: \"(c, d) \\<in> set (butlast (polychain_of x0 xs))\"\n  assumes sorted: \"ccw'.sortedP 0 xs\"\n  assumes ne: \"xs \\<noteq> []\"\n  shows \"ccw' x0 d (snd (last (polychain_of x0 xs)))\""], "translations": [["", "lemma polychainI:\n  assumes \"\\<And>i. Suc i < length xs \\<Longrightarrow> snd (xs ! i) = fst (xs ! Suc i)\"\n  shows \"polychain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polychain xs", "by (auto intro!: assms simp: polychain_def)"], ["", "lemma polychain_Nil[simp]: \"polychain [] = True\"\n  and polychain_singleton[simp]: \"polychain [x] = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polychain [] = True &&& polychain [x] = True", "by (auto simp: polychain_def)"], ["", "lemma polychain_Cons:\n  \"polychain (y # ys) = (if ys = [] then True else snd y = fst (ys ! 0) \\<and> polychain ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polychain (y # ys) =\n    (if ys = [] then True else snd y = fst (ys ! 0) \\<and> polychain ys)", "by (auto simp: polychain_def nth_Cons split: nat.split)"], ["", "lemma polychain_appendI:\n  \"polychain xs \\<Longrightarrow> polychain ys \\<Longrightarrow> (xs \\<noteq> [] \\<Longrightarrow> ys \\<noteq> [] \\<Longrightarrow> snd (last xs) = fst (hd ys)) \\<Longrightarrow>\n    polychain (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>polychain xs; polychain ys;\n     \\<lbrakk>xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> snd (last xs) = fst (hd ys)\\<rbrakk>\n    \\<Longrightarrow> polychain (xs @ ys)", "by (induct xs arbitrary: ys)\n    (auto simp add: polychain_Cons nth_append hd_conv_nth split: if_split_asm)"], ["", "fun pairself where \"pairself f (x, y) = (f x, f y)\""], ["", "lemma pairself_apply: \"pairself f x = (f (fst x), f (snd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairself f x = (f (fst x), f (snd x))", "by (cases x, simp)"], ["", "lemma polychain_map_pairself: \"polychain xs \\<Longrightarrow> polychain (map (pairself f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polychain xs \\<Longrightarrow> polychain (map (pairself f) xs)", "by (auto simp: polychain_def pairself_apply)"], ["", "definition \"convex_polychain xs \\<longleftrightarrow>\n  (polychain xs \\<and>\n  (\\<forall>i. Suc i < length xs \\<longrightarrow> det3 (fst (xs ! i)) (snd (xs ! i)) (snd (xs ! Suc i)) > 0))\""], ["", "lemma convex_polychain_Cons2[simp]:\n  \"convex_polychain (x#y#zs) \\<longleftrightarrow>\n    snd x = fst y \\<and> det3 (fst x) (fst y) (snd y) > 0 \\<and> convex_polychain (y#zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain (x # y # zs) =\n    (snd x = fst y \\<and>\n     0 < det3 (fst x) (fst y) (snd y) \\<and> convex_polychain (y # zs))", "by (auto simp add: convex_polychain_def polychain_def nth_Cons split: nat.split)"], ["", "lemma convex_polychain_ConsD:\n  assumes \"convex_polychain (x#xs)\"\n  shows \"convex_polychain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain xs", "using assms"], ["proof (prove)\nusing this:\n  convex_polychain (x # xs)\n\ngoal (1 subgoal):\n 1. convex_polychain xs", "by (auto simp: convex_polychain_def polychain_def nth_Cons split: nat.split)"], ["", "definition\n  \"convex_polygon xs \\<longleftrightarrow> (convex_polychain xs \\<and> (xs \\<noteq> [] \\<longrightarrow> fst (hd xs) = snd (last xs)))\""], ["", "lemma convex_polychain_Nil[simp]: \"convex_polychain [] = True\"\n  and convex_polychain_Cons[simp]: \"convex_polychain [x] = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain [] = True &&& convex_polychain [x] = True", "by (auto simp: convex_polychain_def)"], ["", "lemma convex_polygon_Cons2[simp]:\n  \"convex_polygon (x#y#zs) \\<longleftrightarrow> fst x = snd (last (y#zs)) \\<and> convex_polychain (x#y#zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polygon (x # y # zs) =\n    (fst x = snd (last (y # zs)) \\<and> convex_polychain (x # y # zs))", "by (auto simp: convex_polygon_def convex_polychain_def polychain_def nth_Cons)"], ["", "lemma polychain_append_connected:\n  \"polychain (xs @ ys) \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> ys \\<noteq> [] \\<Longrightarrow> fst (hd ys) = snd (last xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>polychain (xs @ ys); xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> fst (hd ys) = snd (last xs)", "by (auto simp: convex_polychain_def nth_append not_less polychain_def last_conv_nth hd_conv_nth\n    dest!: spec[where x = \"length xs - 1\"])"], ["", "lemma convex_polychain_appendI:\n  assumes cxs: \"convex_polychain xs\"\n  assumes cys: \"convex_polychain ys\"\n  assumes pxy: \"polychain (xs @ ys)\"\n  assumes \"xs \\<noteq> [] \\<Longrightarrow> ys \\<noteq> [] \\<Longrightarrow> det3 (fst (last xs)) (snd (last xs)) (snd (hd ys)) > 0\"\n  shows \"convex_polychain (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain (xs @ ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. convex_polychain (xs @ ys)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. convex_polychain (xs @ ys)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. convex_polychain (xs @ ys)", "assume \"i < length xs\" \"length xs \\<le> Suc i\" \"Suc i < length xs + length ys\""], ["proof (state)\nthis:\n  i < length xs\n  length xs \\<le> Suc i\n  Suc i < length xs + length ys\n\ngoal (1 subgoal):\n 1. convex_polychain (xs @ ys)", "hence \"xs \\<noteq> []\" \"ys \\<noteq> []\" \"i = length xs - 1\""], ["proof (prove)\nusing this:\n  i < length xs\n  length xs \\<le> Suc i\n  Suc i < length xs + length ys\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] &&& ys \\<noteq> [] &&& i = length xs - 1", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  i = length xs - 1\n\ngoal (1 subgoal):\n 1. convex_polychain (xs @ ys)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < length xs; length xs \\<le> Suc ?i2;\n   Suc ?i2 < length xs + length ys\\<rbrakk>\n  \\<Longrightarrow> xs \\<noteq> []\n  \\<lbrakk>?i2 < length xs; length xs \\<le> Suc ?i2;\n   Suc ?i2 < length xs + length ys\\<rbrakk>\n  \\<Longrightarrow> ys \\<noteq> []\n  \\<lbrakk>?i2 < length xs; length xs \\<le> Suc ?i2;\n   Suc ?i2 < length xs + length ys\\<rbrakk>\n  \\<Longrightarrow> ?i2 = length xs - 1\n\ngoal (1 subgoal):\n 1. convex_polychain (xs @ ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < length xs; length xs \\<le> Suc ?i2;\n   Suc ?i2 < length xs + length ys\\<rbrakk>\n  \\<Longrightarrow> xs \\<noteq> []\n  \\<lbrakk>?i2 < length xs; length xs \\<le> Suc ?i2;\n   Suc ?i2 < length xs + length ys\\<rbrakk>\n  \\<Longrightarrow> ys \\<noteq> []\n  \\<lbrakk>?i2 < length xs; length xs \\<le> Suc ?i2;\n   Suc ?i2 < length xs + length ys\\<rbrakk>\n  \\<Longrightarrow> ?i2 = length xs - 1\n\ngoal (1 subgoal):\n 1. convex_polychain (xs @ ys)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < length xs; length xs \\<le> Suc ?i2;\n   Suc ?i2 < length xs + length ys\\<rbrakk>\n  \\<Longrightarrow> xs \\<noteq> []\n  \\<lbrakk>?i2 < length xs; length xs \\<le> Suc ?i2;\n   Suc ?i2 < length xs + length ys\\<rbrakk>\n  \\<Longrightarrow> ys \\<noteq> []\n  \\<lbrakk>?i2 < length xs; length xs \\<le> Suc ?i2;\n   Suc ?i2 < length xs + length ys\\<rbrakk>\n  \\<Longrightarrow> ?i2 = length xs - 1\n  convex_polychain xs\n  convex_polychain ys\n  polychain (xs @ ys)\n  \\<lbrakk>xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> 0 < det3 (fst (last xs)) (snd (last xs)) (snd (hd ys))\n\ngoal (1 subgoal):\n 1. convex_polychain (xs @ ys)", "by (auto simp: hd_conv_nth convex_polychain_def nth_append Suc_diff_le last_conv_nth )"], ["proof (state)\nthis:\n  convex_polychain (xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convex_polychainI:\n  assumes \"polychain xs\"\n  assumes \"\\<And>i. Suc i < length xs \\<Longrightarrow> det3 (fst (xs ! i)) (snd (xs ! i)) (snd (xs ! Suc i)) > 0\"\n  shows \"convex_polychain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain xs", "by (auto intro!: assms simp: convex_polychain_def ccw'_def)"], ["", "lemma convex_polygon_skip:\n  assumes \"convex_polygon (x # y # z # w # ws)\"\n  assumes \"ccw'.sortedP (fst x) (map snd (butlast (x # y # z # w # ws)))\"\n  shows \"convex_polygon ((fst x, snd y) # z # w # ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polygon ((fst x, snd y) # z # w # ws)", "using assms"], ["proof (prove)\nusing this:\n  convex_polygon (x # y # z # w # ws)\n  ccw'.sortedP (fst x) (map snd (butlast (x # y # z # w # ws)))\n\ngoal (1 subgoal):\n 1. convex_polygon ((fst x, snd y) # z # w # ws)", "by (auto elim!: ccw'.sortedP_Cons simp: ccw'_def[symmetric])"], ["", "primrec polychain_of::\"'a::ab_group_add \\<Rightarrow> 'a list \\<Rightarrow> ('a*'a) list\" where\n  \"polychain_of xc [] = []\"\n| \"polychain_of xc (xm#xs) = (xc, xc + xm)#polychain_of (xc + xm) xs\""], ["", "lemma in_set_polychain_ofD: \"ab \\<in> set (polychain_of x xs) \\<Longrightarrow> (snd ab - fst ab) \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ab \\<in> set (polychain_of x xs) \\<Longrightarrow>\n    snd ab - fst ab \\<in> set xs", "by (induct xs arbitrary: x) auto"], ["", "lemma fst_polychain_of_nth_0[simp]: \"xs \\<noteq> [] \\<Longrightarrow> fst ((polychain_of p xs) ! 0) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst (polychain_of p xs ! 0) = p", "by (cases xs) (auto simp: Let_def)"], ["", "lemma fst_hd_polychain_of: \"xs \\<noteq> [] \\<Longrightarrow> fst (hd (polychain_of x xs)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst (hd (polychain_of x xs)) = x", "by (cases xs) (auto simp: )"], ["", "lemma length_polychain_of_eq[simp]:\n  shows \"length (polychain_of p qs) = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (polychain_of p qs) = length qs", "by (induct qs arbitrary: p) simp_all"], ["", "lemma\n  polychain_of_subsequent_eq:\n  assumes \"Suc i < length qs\"\n  shows \"snd (polychain_of p qs ! i) = fst (polychain_of p qs ! Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (polychain_of p qs ! i) = fst (polychain_of p qs ! Suc i)", "using assms"], ["proof (prove)\nusing this:\n  Suc i < length qs\n\ngoal (1 subgoal):\n 1. snd (polychain_of p qs ! i) = fst (polychain_of p qs ! Suc i)", "by (induct qs arbitrary: p i) (auto simp add: nth_Cons split: nat.split)"], ["", "lemma polychain_of_eq_empty_iff[simp]: \"polychain_of p xs = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (polychain_of p xs = []) = (xs = [])", "by (cases xs) (auto simp: Let_def)"], ["", "lemma in_set_polychain_of_imp_sum_list:\n  assumes \"z \\<in> set (polychain_of Pc Ps)\"\n  obtains d where \"z = (Pc + sum_list (take d Ps), Pc + sum_list (take (Suc d) Ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        z =\n        (Pc + sum_list (take d Ps),\n         Pc + sum_list (take (Suc d) Ps)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  z \\<in> set (polychain_of Pc Ps)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        z =\n        (Pc + sum_list (take d Ps),\n         Pc + sum_list (take (Suc d) Ps)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set (polychain_of Pc Ps) \\<Longrightarrow>\n    \\<exists>d.\n       z = (Pc + sum_list (take d Ps), Pc + sum_list (take (Suc d) Ps))", "proof (induction Ps arbitrary: Pc z)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       z \\<in> set (polychain_of Pc []) \\<Longrightarrow>\n       \\<exists>d.\n          z = (Pc + sum_list (take d []), Pc + sum_list (take (Suc d) []))\n 2. \\<And>a Ps Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   z \\<in> set (polychain_of Pc Ps) \\<Longrightarrow>\n                   \\<exists>d.\n                      z =\n                      (Pc + sum_list (take d Ps),\n                       Pc + sum_list (take (Suc d) Ps));\n        z \\<in> set (polychain_of Pc (a # Ps))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            z =\n                            (Pc + sum_list (take d (a # Ps)),\n                             Pc + sum_list (take (Suc d) (a # Ps)))", "case Nil"], ["proof (state)\nthis:\n  z \\<in> set (polychain_of Pc [])\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       z \\<in> set (polychain_of Pc []) \\<Longrightarrow>\n       \\<exists>d.\n          z = (Pc + sum_list (take d []), Pc + sum_list (take (Suc d) []))\n 2. \\<And>a Ps Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   z \\<in> set (polychain_of Pc Ps) \\<Longrightarrow>\n                   \\<exists>d.\n                      z =\n                      (Pc + sum_list (take d Ps),\n                       Pc + sum_list (take (Suc d) Ps));\n        z \\<in> set (polychain_of Pc (a # Ps))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            z =\n                            (Pc + sum_list (take d (a # Ps)),\n                             Pc + sum_list (take (Suc d) (a # Ps)))", "thus ?case"], ["proof (prove)\nusing this:\n  z \\<in> set (polychain_of Pc [])\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       z = (Pc + sum_list (take d []), Pc + sum_list (take (Suc d) []))", "by simp"], ["proof (state)\nthis:\n  \\<exists>d.\n     z = (Pc + sum_list (take d []), Pc + sum_list (take (Suc d) []))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   z \\<in> set (polychain_of Pc Ps) \\<Longrightarrow>\n                   \\<exists>d.\n                      z =\n                      (Pc + sum_list (take d Ps),\n                       Pc + sum_list (take (Suc d) Ps));\n        z \\<in> set (polychain_of Pc (a # Ps))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            z =\n                            (Pc + sum_list (take d (a # Ps)),\n                             Pc + sum_list (take (Suc d) (a # Ps)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Ps Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   z \\<in> set (polychain_of Pc Ps) \\<Longrightarrow>\n                   \\<exists>d.\n                      z =\n                      (Pc + sum_list (take d Ps),\n                       Pc + sum_list (take (Suc d) Ps));\n        z \\<in> set (polychain_of Pc (a # Ps))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            z =\n                            (Pc + sum_list (take d (a # Ps)),\n                             Pc + sum_list (take (Suc d) (a # Ps)))", "case (Cons P Ps)"], ["proof (state)\nthis:\n  ?z \\<in> set (polychain_of ?Pc Ps) \\<Longrightarrow>\n  \\<exists>d.\n     ?z = (?Pc + sum_list (take d Ps), ?Pc + sum_list (take (Suc d) Ps))\n  z \\<in> set (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   z \\<in> set (polychain_of Pc Ps) \\<Longrightarrow>\n                   \\<exists>d.\n                      z =\n                      (Pc + sum_list (take d Ps),\n                       Pc + sum_list (take (Suc d) Ps));\n        z \\<in> set (polychain_of Pc (a # Ps))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            z =\n                            (Pc + sum_list (take d (a # Ps)),\n                             Pc + sum_list (take (Suc d) (a # Ps)))", "hence \"z = (Pc, Pc + P) \\<or> z \\<in> set (polychain_of (Pc + P) Ps)\""], ["proof (prove)\nusing this:\n  ?z \\<in> set (polychain_of ?Pc Ps) \\<Longrightarrow>\n  \\<exists>d.\n     ?z = (?Pc + sum_list (take d Ps), ?Pc + sum_list (take (Suc d) Ps))\n  z \\<in> set (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. z = (Pc, Pc + P) \\<or> z \\<in> set (polychain_of (Pc + P) Ps)", "by auto"], ["proof (state)\nthis:\n  z = (Pc, Pc + P) \\<or> z \\<in> set (polychain_of (Pc + P) Ps)\n\ngoal (1 subgoal):\n 1. \\<And>a Ps Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   z \\<in> set (polychain_of Pc Ps) \\<Longrightarrow>\n                   \\<exists>d.\n                      z =\n                      (Pc + sum_list (take d Ps),\n                       Pc + sum_list (take (Suc d) Ps));\n        z \\<in> set (polychain_of Pc (a # Ps))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            z =\n                            (Pc + sum_list (take d (a # Ps)),\n                             Pc + sum_list (take (Suc d) (a # Ps)))", "thus ?case"], ["proof (prove)\nusing this:\n  z = (Pc, Pc + P) \\<or> z \\<in> set (polychain_of (Pc + P) Ps)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       z =\n       (Pc + sum_list (take d (P # Ps)),\n        Pc + sum_list (take (Suc d) (P # Ps)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    \\<exists>d.\n       z =\n       (Pc + sum_list (take d (P # Ps)),\n        Pc + sum_list (take (Suc d) (P # Ps)))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    \\<exists>d.\n       z =\n       (Pc + sum_list (take d (P # Ps)),\n        Pc + sum_list (take (Suc d) (P # Ps)))", "assume \"z \\<in> set ((polychain_of (Pc + P) Ps))\""], ["proof (state)\nthis:\n  z \\<in> set (polychain_of (Pc + P) Ps)\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    \\<exists>d.\n       z =\n       (Pc + sum_list (take d (P # Ps)),\n        Pc + sum_list (take (Suc d) (P # Ps)))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    \\<exists>d.\n       z =\n       (Pc + sum_list (take d (P # Ps)),\n        Pc + sum_list (take (Suc d) (P # Ps)))", "from Cons.IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>d.\n     z =\n     (Pc + P + sum_list (take d Ps), Pc + P + sum_list (take (Suc d) Ps))", "obtain d\n    where \"z = (Pc + P + sum_list (take d Ps), Pc + P + sum_list (take (Suc d) Ps))\""], ["proof (prove)\nusing this:\n  \\<exists>d.\n     z =\n     (Pc + P + sum_list (take d Ps), Pc + P + sum_list (take (Suc d) Ps))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        z =\n        (Pc + P + sum_list (take d Ps),\n         Pc + P + sum_list (take (Suc d) Ps)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = (Pc + P + sum_list (take d Ps), Pc + P + sum_list (take (Suc d) Ps))\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    \\<exists>d.\n       z =\n       (Pc + sum_list (take d (P # Ps)),\n        Pc + sum_list (take (Suc d) (P # Ps)))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    \\<exists>d.\n       z =\n       (Pc + sum_list (take d (P # Ps)),\n        Pc + sum_list (take (Suc d) (P # Ps)))", "thus ?case"], ["proof (prove)\nusing this:\n  z = (Pc + P + sum_list (take d Ps), Pc + P + sum_list (take (Suc d) Ps))\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       z =\n       (Pc + sum_list (take d (P # Ps)),\n        Pc + sum_list (take (Suc d) (P # Ps)))", "by (auto intro!: exI[where x=\"Suc d\"])"], ["proof (state)\nthis:\n  \\<exists>d.\n     z =\n     (Pc + sum_list (take d (P # Ps)),\n      Pc + sum_list (take (Suc d) (P # Ps)))\n\ngoal (1 subgoal):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    \\<exists>d.\n       z =\n       (Pc + sum_list (take d (P # Ps)),\n        Pc + sum_list (take (Suc d) (P # Ps)))", "qed (auto intro!: exI[where x=0])"], ["proof (state)\nthis:\n  \\<exists>d.\n     z =\n     (Pc + sum_list (take d (P # Ps)),\n      Pc + sum_list (take (Suc d) (P # Ps)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_polychain_of: \"length xs > 0 \\<Longrightarrow> snd (last (polychain_of p xs)) = p + sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs \\<Longrightarrow>\n    snd (last (polychain_of p xs)) = p + sum_list xs", "by (induct xs arbitrary: p) simp_all"], ["", "lemma polychain_of_singleton_iff: \"polychain_of p xs = [a] \\<longleftrightarrow> fst a = p \\<and> xs = [(snd a - p)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (polychain_of p xs = [a]) = (fst a = p \\<and> xs = [snd a - p])", "by (induct xs) auto"], ["", "lemma polychain_of_add: \"polychain_of (x + y) xs = map (((+) (y, y))) (polychain_of x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polychain_of (x + y) xs = map ((+) (y, y)) (polychain_of x xs)", "by (induct xs arbitrary: x y) (auto simp: algebra_simps)"], ["", "subsection \\<open>Dirvec: Inverse of Polychain\\<close>"], ["", "primrec dirvec where \"dirvec (x, y) = (y - x)\""], ["", "lemma dirvec_minus: \"dirvec x = snd x - fst x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dirvec x = snd x - fst x", "by (cases x) simp"], ["", "lemma dirvec_nth_polychain_of: \"n < length xs \\<Longrightarrow> dirvec ((polychain_of p xs) ! n ) = (xs ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow> dirvec (polychain_of p xs ! n) = xs ! n", "by (induct xs arbitrary: p n) (auto simp: nth_Cons split: nat.split)"], ["", "lemma dirvec_hd_polychain_of: \"xs \\<noteq> [] \\<Longrightarrow> dirvec (hd (polychain_of p xs)) = (hd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> dirvec (hd (polychain_of p xs)) = hd xs", "by (simp add: hd_conv_nth dirvec_nth_polychain_of)"], ["", "lemma dirvec_last_polychain_of: \"xs \\<noteq> [] \\<Longrightarrow> dirvec (last (polychain_of p xs)) = (last xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    dirvec (last (polychain_of p xs)) = last xs", "by (simp add: last_conv_nth dirvec_nth_polychain_of)"], ["", "lemma map_dirvec_polychain_of[simp]: \"map dirvec (polychain_of x xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map dirvec (polychain_of x xs) = xs", "by (induct xs arbitrary: x) simp_all"], ["", "subsection \\<open>Polychain of Sorted (@{term polychain_of}, @{term ccw'.sortedP})\\<close>"], ["", "lemma ccw'_sortedP_translateD:\n  \"linorder_list0.sortedP (ccw' x0) (map ((+) x \\<circ> g) xs) \\<Longrightarrow>\n    linorder_list0.sortedP (ccw' (x0 - x)) (map g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map ((+) x \\<circ> g) xs) \\<Longrightarrow>\n    ccw'.sortedP (x0 - x) (map g xs)", "proof (induct xs arbitrary: x0 x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x0 x.\n       ccw'.sortedP x0 (map ((+) x \\<circ> g) []) \\<Longrightarrow>\n       ccw'.sortedP (x0 - x) (map g [])\n 2. \\<And>a xs x0 x.\n       \\<lbrakk>\\<And>x0 x.\n                   ccw'.sortedP x0\n                    (map ((+) x \\<circ> g) xs) \\<Longrightarrow>\n                   ccw'.sortedP (x0 - x) (map g xs);\n        ccw'.sortedP x0 (map ((+) x \\<circ> g) (a # xs))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (x0 - x) (map g (a # xs))", "case Nil"], ["proof (state)\nthis:\n  ccw'.sortedP x0 (map ((+) x \\<circ> g) [])\n\ngoal (2 subgoals):\n 1. \\<And>x0 x.\n       ccw'.sortedP x0 (map ((+) x \\<circ> g) []) \\<Longrightarrow>\n       ccw'.sortedP (x0 - x) (map g [])\n 2. \\<And>a xs x0 x.\n       \\<lbrakk>\\<And>x0 x.\n                   ccw'.sortedP x0\n                    (map ((+) x \\<circ> g) xs) \\<Longrightarrow>\n                   ccw'.sortedP (x0 - x) (map g xs);\n        ccw'.sortedP x0 (map ((+) x \\<circ> g) (a # xs))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (x0 - x) (map g (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  ccw'.sortedP x0 (map ((+) x \\<circ> g) [])\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (x0 - x) (map g [])", "by (auto simp: linorder_list0.sortedP.Nil)"], ["proof (state)\nthis:\n  ccw'.sortedP (x0 - x) (map g [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0 x.\n       \\<lbrakk>\\<And>x0 x.\n                   ccw'.sortedP x0\n                    (map ((+) x \\<circ> g) xs) \\<Longrightarrow>\n                   ccw'.sortedP (x0 - x) (map g xs);\n        ccw'.sortedP x0 (map ((+) x \\<circ> g) (a # xs))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (x0 - x) (map g (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x0 x.\n       \\<lbrakk>\\<And>x0 x.\n                   ccw'.sortedP x0\n                    (map ((+) x \\<circ> g) xs) \\<Longrightarrow>\n                   ccw'.sortedP (x0 - x) (map g xs);\n        ccw'.sortedP x0 (map ((+) x \\<circ> g) (a # xs))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (x0 - x) (map g (a # xs))", "case (Cons a xs x0 x)"], ["proof (state)\nthis:\n  ccw'.sortedP ?x0.0 (map ((+) ?x \\<circ> g) xs) \\<Longrightarrow>\n  ccw'.sortedP (?x0.0 - ?x) (map g xs)\n  ccw'.sortedP x0 (map ((+) x \\<circ> g) (a # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0 x.\n       \\<lbrakk>\\<And>x0 x.\n                   ccw'.sortedP x0\n                    (map ((+) x \\<circ> g) xs) \\<Longrightarrow>\n                   ccw'.sortedP (x0 - x) (map g xs);\n        ccw'.sortedP x0 (map ((+) x \\<circ> g) (a # xs))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (x0 - x) (map g (a # xs))", "hence \"\\<forall>y\\<in>set xs. ccw' (x0 - x) (g a) (g y)\""], ["proof (prove)\nusing this:\n  ccw'.sortedP ?x0.0 (map ((+) ?x \\<circ> g) xs) \\<Longrightarrow>\n  ccw'.sortedP (?x0.0 - ?x) (map g xs)\n  ccw'.sortedP x0 (map ((+) x \\<circ> g) (a # xs))\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs. ccw' (x0 - x) (g a) (g y)", "by (auto elim!: linorder_list0.sortedP_Cons simp: ccw'.translate_origin algebra_simps)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set xs. ccw' (x0 - x) (g a) (g y)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0 x.\n       \\<lbrakk>\\<And>x0 x.\n                   ccw'.sortedP x0\n                    (map ((+) x \\<circ> g) xs) \\<Longrightarrow>\n                   ccw'.sortedP (x0 - x) (map g xs);\n        ccw'.sortedP x0 (map ((+) x \\<circ> g) (a # xs))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (x0 - x) (map g (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set xs. ccw' (x0 - x) (g a) (g y)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (x0 - x) (map g (a # xs))", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set xs. ccw' (x0 - x) (g a) (g y)\n  ccw'.sortedP x0 (map ((+) x \\<circ> g) (a # xs))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (x0 - x) (map g (a # xs))", "by (auto elim!: linorder_list0.sortedP_Cons intro!: linorder_list0.sortedP.Cons simp: Cons.hyps)"], ["proof (state)\nthis:\n  ccw'.sortedP (x0 - x) (map g (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccw'_sortedP_translateI:\n  \"linorder_list0.sortedP (ccw' (x0 - x)) (map g xs) \\<Longrightarrow>\n    linorder_list0.sortedP (ccw' x0) (map ((+) x \\<circ> g) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (x0 - x) (map g xs) \\<Longrightarrow>\n    ccw'.sortedP x0 (map ((+) x \\<circ> g) xs)", "using ccw'_sortedP_translateD[of \"x0 - x\" \"-x\" \"(+) x o g\" xs]"], ["proof (prove)\nusing this:\n  ccw'.sortedP (x0 - x)\n   (map ((+) (- x) \\<circ> ((+) x \\<circ> g)) xs) \\<Longrightarrow>\n  ccw'.sortedP (x0 - x - - x) (map ((+) x \\<circ> g) xs)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (x0 - x) (map g xs) \\<Longrightarrow>\n    ccw'.sortedP x0 (map ((+) x \\<circ> g) xs)", "by (simp add: o_def)"], ["", "lemma ccw'_sortedP_translate_comp[simp]:\n  \"linorder_list0.sortedP (ccw' x0) (map ((+) x \\<circ> g) xs) \\<longleftrightarrow>\n    linorder_list0.sortedP (ccw' (x0 - x)) (map g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map ((+) x \\<circ> g) xs) =\n    ccw'.sortedP (x0 - x) (map g xs)", "by (metis ccw'_sortedP_translateD ccw'_sortedP_translateI)"], ["", "lemma snd_plus_commute: \"snd \\<circ> (+) (x0, x0) = (+) x0 o snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd \\<circ> (+) (x0, x0) = (+) x0 \\<circ> snd", "by auto"], ["", "lemma ccw'_sortedP_renormalize:\n  \"ccw'.sortedP a (map snd (polychain_of (x0 + x) xs)) \\<longleftrightarrow>\n   ccw'.sortedP (a - x0) (map snd (polychain_of x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP a (map snd (polychain_of (x0 + x) xs)) =\n    ccw'.sortedP (a - x0) (map snd (polychain_of x xs))", "by (simp add: polychain_of_add add.commute snd_plus_commute)"], ["", "lemma ccw'_sortedP_polychain_of01:\n  shows \"ccw'.sortedP 0 [u] \\<Longrightarrow> ccw'.sortedP x0 (map snd (polychain_of x0 [u]))\"\n    and \"ccw'.sortedP 0 [] \\<Longrightarrow> ccw'.sortedP x0 (map snd (polychain_of x0 []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccw'.sortedP 0 [u] \\<Longrightarrow>\n     ccw'.sortedP x0 (map snd (polychain_of x0 [u]))) &&&\n    (ccw'.sortedP 0 [] \\<Longrightarrow>\n     ccw'.sortedP x0 (map snd (polychain_of x0 [])))", "by (auto intro!: linorder_list0.sortedP.Nil linorder_list0.sortedP.Cons  simp: ac_simps)"], ["", "lemma ccw'_sortedP_polychain_of2:\n  assumes \"ccw'.sortedP 0 [u, v]\"\n  shows \"ccw'.sortedP x0 (map snd (polychain_of x0 [u, v]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 [u, v]))", "using assms"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 [u, v]\n\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 [u, v]))", "by (auto intro!: linorder_list0.sortedP.Nil linorder_list0.sortedP.Cons\n    elim!: linorder_list0.sortedP_Cons simp: ac_simps ccw'.translate_origin)"], ["", "lemma ccw'_sortedP_polychain_of3:\n  assumes \"ccw'.sortedP 0 (u#v#w#xs)\"\n  shows \"ccw'.sortedP x0 (map snd (polychain_of x0 (u#v#w#xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 (u # v # w # xs)))", "using assms"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 (u # v # w # xs)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 (u # v # w # xs)))", "proof (induct xs arbitrary: x0 u v w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x0 u v w.\n       ccw'.sortedP 0 [u, v, w] \\<Longrightarrow>\n       ccw'.sortedP x0 (map snd (polychain_of x0 [u, v, w]))\n 2. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "case Nil"], ["proof (state)\nthis:\n  ccw'.sortedP 0 [u, v, w]\n\ngoal (2 subgoals):\n 1. \\<And>x0 u v w.\n       ccw'.sortedP 0 [u, v, w] \\<Longrightarrow>\n       ccw'.sortedP x0 (map snd (polychain_of x0 [u, v, w]))\n 2. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "then"], ["proof (chain)\npicking this:\n  ccw'.sortedP 0 [u, v, w]", "have *: \"ccw' 0 u v\" \"ccw' 0 v w\" \"ccw' 0 u w\""], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 [u, v, w]\n\ngoal (1 subgoal):\n 1. ccw' 0 u v &&& ccw' 0 v w &&& ccw' 0 u w", "by (auto intro!: linorder_list0.sortedP.Nil linorder_list0.sortedP.Cons\n      elim!: linorder_list0.sortedP_Cons simp: ac_simps)"], ["proof (state)\nthis:\n  ccw' 0 u v\n  ccw' 0 v w\n  ccw' 0 u w\n\ngoal (2 subgoals):\n 1. \\<And>x0 u v w.\n       ccw'.sortedP 0 [u, v, w] \\<Longrightarrow>\n       ccw'.sortedP x0 (map snd (polychain_of x0 [u, v, w]))\n 2. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "moreover"], ["proof (state)\nthis:\n  ccw' 0 u v\n  ccw' 0 v w\n  ccw' 0 u w\n\ngoal (2 subgoals):\n 1. \\<And>x0 u v w.\n       ccw'.sortedP 0 [u, v, w] \\<Longrightarrow>\n       ccw'.sortedP x0 (map snd (polychain_of x0 [u, v, w]))\n 2. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "have \"ccw' 0 (u + v) (u + (v + w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' 0 (u + v) (u + (v + w))", "by (metis add.assoc ccw'.add1 ccw'.add3_self *(2-))"], ["proof (state)\nthis:\n  ccw' 0 (u + v) (u + (v + w))\n\ngoal (2 subgoals):\n 1. \\<And>x0 u v w.\n       ccw'.sortedP 0 [u, v, w] \\<Longrightarrow>\n       ccw'.sortedP x0 (map snd (polychain_of x0 [u, v, w]))\n 2. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  ccw' 0 u v\n  ccw' 0 v w\n  ccw' 0 u w\n  ccw' 0 (u + v) (u + (v + w))", "show ?case"], ["proof (prove)\nusing this:\n  ccw' 0 u v\n  ccw' 0 v w\n  ccw' 0 u w\n  ccw' 0 (u + v) (u + (v + w))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 [u, v, w]))", "by (auto intro!: linorder_list0.sortedP.Nil linorder_list0.sortedP.Cons\n      elim!: linorder_list0.sortedP_Cons simp: ac_simps ccw'.translate_origin ccw'.add3)"], ["proof (state)\nthis:\n  ccw'.sortedP x0 (map snd (polychain_of x0 [u, v, w]))\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "case (Cons y ys)"], ["proof (state)\nthis:\n  ccw'.sortedP 0 (?u # ?v # ?w # ys) \\<Longrightarrow>\n  ccw'.sortedP ?x0.0 (map snd (polychain_of ?x0.0 (?u # ?v # ?w # ys)))\n  ccw'.sortedP 0 (u # v # w # y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "have s1: \"linorder_list0.sortedP (ccw' 0)  ((u + v)#w#y#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 ((u + v) # w # y # ys)", "using Cons.prems"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 (u # v # w # y # ys)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 ((u + v) # w # y # ys)", "by (auto intro!: linorder_list0.sortedP.Nil linorder_list0.sortedP.Cons\n      elim!: linorder_list0.sortedP_Cons simp: ccw'.add1)"], ["proof (state)\nthis:\n  ccw'.sortedP 0 ((u + v) # w # y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "have s2: \"linorder_list0.sortedP (ccw' 0)  (u#(v + w)#y#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 (u # (v + w) # y # ys)", "using Cons.prems"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 (u # v # w # y # ys)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 (u # (v + w) # y # ys)", "by (auto intro!: linorder_list0.sortedP.Nil linorder_list0.sortedP.Cons\n      elim!: linorder_list0.sortedP_Cons simp: ccw'.add3 ccw'.add1)"], ["proof (state)\nthis:\n  ccw'.sortedP 0 (u # (v + w) # y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "have s3: \"linorder_list0.sortedP (ccw' 0)  (u#v#(w + y)#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 (u # v # (w + y) # ys)", "using Cons.prems"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 (u # v # w # y # ys)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 (u # v # (w + y) # ys)", "by (auto intro!: linorder_list0.sortedP.Nil linorder_list0.sortedP.Cons\n      elim!: linorder_list0.sortedP_Cons simp: ccw'.add3 ccw'.add1)"], ["proof (state)\nthis:\n  ccw'.sortedP 0 (u # v # (w + y) # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0 u v w.\n       \\<lbrakk>\\<And>x0 u v w.\n                   ccw'.sortedP 0 (u # v # w # xs) \\<Longrightarrow>\n                   ccw'.sortedP x0\n                    (map snd (polychain_of x0 (u # v # w # xs)));\n        ccw'.sortedP 0 (u # v # w # a # xs)\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP x0\n                          (map snd (polychain_of x0 (u # v # w # a # xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 (u # v # w # y # ys)))", "using Cons.hyps[OF s1, of x0] Cons.hyps[OF s2, of x0] Cons.hyps[OF s3, of x0] Cons.prems"], ["proof (prove)\nusing this:\n  ccw'.sortedP x0 (map snd (polychain_of x0 ((u + v) # w # y # ys)))\n  ccw'.sortedP x0 (map snd (polychain_of x0 (u # (v + w) # y # ys)))\n  ccw'.sortedP x0 (map snd (polychain_of x0 (u # v # (w + y) # ys)))\n  ccw'.sortedP 0 (u # v # w # y # ys)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 (u # v # w # y # ys)))", "by (auto intro!: linorder_list0.sortedP.Nil linorder_list0.sortedP.Cons\n      elim!: linorder_list0.sortedP_Cons simp: ac_simps)"], ["proof (state)\nthis:\n  ccw'.sortedP x0 (map snd (polychain_of x0 (u # v # w # y # ys)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccw'_sortedP_polychain_of_snd:\n  assumes \"ccw'.sortedP 0 xs\"\n  shows \"ccw'.sortedP x0 (map snd (polychain_of x0 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 xs))", "using assms"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 xs\n\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 xs))", "by (metis ccw'_sortedP_polychain_of01 ccw'_sortedP_polychain_of2 ccw'_sortedP_polychain_of3\n    list.exhaust)"], ["", "lemma ccw'_sortedP_implies_distinct:\n  assumes \"ccw'.sortedP x qs\"\n  shows \"distinct qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct qs", "using assms"], ["proof (prove)\nusing this:\n  ccw'.sortedP x qs\n\ngoal (1 subgoal):\n 1. distinct qs", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct []\n 2. \\<And>ys xa.\n       \\<lbrakk>\\<forall>y\\<in>set ys. ccw' x xa y; ccw'.sortedP x ys;\n        distinct ys\\<rbrakk>\n       \\<Longrightarrow> distinct (xa # ys)", "case Cons"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ys_. ccw' x x_ y\n  ccw'.sortedP x ys_\n  distinct ys_\n\ngoal (2 subgoals):\n 1. distinct []\n 2. \\<And>ys xa.\n       \\<lbrakk>\\<forall>y\\<in>set ys. ccw' x xa y; ccw'.sortedP x ys;\n        distinct ys\\<rbrakk>\n       \\<Longrightarrow> distinct (xa # ys)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set ys_. ccw' x x_ y\n  ccw'.sortedP x ys_\n  distinct ys_\n\ngoal (1 subgoal):\n 1. distinct (x_ # ys_)", "by (meson ccw'_contra distinct.simps(2))"], ["proof (state)\nthis:\n  distinct (x_ # ys_)\n\ngoal (1 subgoal):\n 1. distinct []", "qed simp"], ["", "lemma ccw'_sortedP_implies_nonaligned:\n  assumes \"ccw'.sortedP x qs\"\n  assumes \"y \\<in> set qs\" \"z \\<in> set qs\" \"y \\<noteq> z\"\n  shows \"\\<not> coll x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 x y z \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  ccw'.sortedP x qs\n  y \\<in> set qs\n  z \\<in> set qs\n  y \\<noteq> z\n\ngoal (1 subgoal):\n 1. det3 x y z \\<noteq> 0", "by induct (force simp: ccw'_def det3_def' algebra_simps)+"], ["", "lemma list_all_mp: \"list_all P xs \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> P x \\<Longrightarrow> Q x) \\<Longrightarrow> list_all Q xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all P xs;\n     \\<And>x.\n        \\<lbrakk>x \\<in> set xs; P x\\<rbrakk> \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> list_all Q xs", "by (auto simp: list_all_iff)"], ["", "lemma\n  ccw'_scale_origin:\n  assumes \"e \\<in> UNIV \\<rightarrow> {0<..<1}\"\n  assumes \"x \\<in> set (polychain_of Pc (P # QRRs))\"\n  assumes \"ccw'.sortedP 0 (P # QRRs)\"\n  assumes \"ccw' (fst x) (snd x) (P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\"\n  shows \"ccw' (fst x) (snd x) (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "from assms(2)"], ["proof (chain)\npicking this:\n  x \\<in> set (polychain_of Pc (P # QRRs))", "have \"fst x = Pc \\<and> snd x = Pc + P \\<or> x \\<in> set (polychain_of (Pc + P) QRRs)\""], ["proof (prove)\nusing this:\n  x \\<in> set (polychain_of Pc (P # QRRs))\n\ngoal (1 subgoal):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<or>\n    x \\<in> set (polychain_of (Pc + P) QRRs)", "by auto"], ["proof (state)\nthis:\n  fst x = Pc \\<and> snd x = Pc + P \\<or>\n  x \\<in> set (polychain_of (Pc + P) QRRs)\n\ngoal (1 subgoal):\n 1. ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst x = Pc \\<and> snd x = Pc + P \\<or>\n  x \\<in> set (polychain_of (Pc + P) QRRs)\n\ngoal (1 subgoal):\n 1. ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "assume x: \"x \\<in> set (polychain_of (Pc + P) QRRs)\""], ["proof (state)\nthis:\n  x \\<in> set (polychain_of (Pc + P) QRRs)\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "define q where \"q = snd x - fst x\""], ["proof (state)\nthis:\n  q = snd x - fst x\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "from Polygon.in_set_polychain_of_imp_sum_list[OF x]"], ["proof (chain)\npicking this:\n  (\\<And>d.\n      x =\n      (Pc + P + sum_list (take d QRRs),\n       Pc + P + sum_list (take (Suc d) QRRs)) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain d where d: \"fst x = (Pc + P + sum_list (take d QRRs))\""], ["proof (prove)\nusing this:\n  (\\<And>d.\n      x =\n      (Pc + P + sum_list (take d QRRs),\n       Pc + P + sum_list (take (Suc d) QRRs)) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        fst x = Pc + P + sum_list (take d QRRs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: prod_eq_iff)"], ["proof (state)\nthis:\n  fst x = Pc + P + sum_list (take d QRRs)\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "from in_set_polychain_ofD[OF x]"], ["proof (chain)\npicking this:\n  snd x - fst x \\<in> set QRRs", "have q_in: \"q \\<in> set QRRs\""], ["proof (prove)\nusing this:\n  snd x - fst x \\<in> set QRRs\n\ngoal (1 subgoal):\n 1. q \\<in> set QRRs", "by (simp add: q_def)"], ["proof (state)\nthis:\n  q \\<in> set QRRs\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "define R where \"R = set QRRs - {q}\""], ["proof (state)\nthis:\n  R = set QRRs - {q}\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "hence QRRs: \"set QRRs = R \\<union> {q}\" \"q \\<notin> R\" \"finite R\""], ["proof (prove)\nusing this:\n  R = set QRRs - {q}\n\ngoal (1 subgoal):\n 1. set QRRs = R \\<union> {q} &&& q \\<notin> R &&& finite R", "using q_in"], ["proof (prove)\nusing this:\n  R = set QRRs - {q}\n  q \\<in> set QRRs\n\ngoal (1 subgoal):\n 1. set QRRs = R \\<union> {q} &&& q \\<notin> R &&& finite R", "by auto"], ["proof (state)\nthis:\n  set QRRs = R \\<union> {q}\n  q \\<notin> R\n  finite R\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "have \"ccw' 0 q (-P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' 0 q (- P)", "using assms(3)"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 (P # QRRs)\n\ngoal (1 subgoal):\n 1. ccw' 0 q (- P)", "by (auto simp: ccw'.sortedP_Cons_iff q_in)"], ["proof (state)\nthis:\n  ccw' 0 q (- P)\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "hence \"ccw' 0 q ((1 - e P) *\\<^sub>R (-P))\""], ["proof (prove)\nusing this:\n  ccw' 0 q (- P)\n\ngoal (1 subgoal):\n 1. ccw' 0 q ((1 - e P) *\\<^sub>R - P)", "using assms(1)"], ["proof (prove)\nusing this:\n  ccw' 0 q (- P)\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n\ngoal (1 subgoal):\n 1. ccw' 0 q ((1 - e P) *\\<^sub>R - P)", "by (subst ccw'.scaleR2_eq) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  ccw' 0 q ((1 - e P) *\\<^sub>R - P)\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "moreover"], ["proof (state)\nthis:\n  ccw' 0 q ((1 - e P) *\\<^sub>R - P)\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "from assms(4)"], ["proof (chain)\npicking this:\n  ccw' (fst x) (snd x) (P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "have \"ccw' 0 q ((\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P) - sum_list (take d QRRs))\""], ["proof (prove)\nusing this:\n  ccw' (fst x) (snd x) (P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n\ngoal (1 subgoal):\n 1. ccw' 0 q\n     ((\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P) - sum_list (take d QRRs))", "by (auto simp: q_def ccw'.translate_origin d)"], ["proof (state)\nthis:\n  ccw' 0 q\n   ((\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P) - sum_list (take d QRRs))\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "ultimately"], ["proof (chain)\npicking this:\n  ccw' 0 q ((1 - e P) *\\<^sub>R - P)\n  ccw' 0 q\n   ((\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P) - sum_list (take d QRRs))", "have \"ccw' 0 q ((1 - e P) *\\<^sub>R (-P) + ((\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P) - sum_list (take d QRRs)))\""], ["proof (prove)\nusing this:\n  ccw' 0 q ((1 - e P) *\\<^sub>R - P)\n  ccw' 0 q\n   ((\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P) - sum_list (take d QRRs))\n\ngoal (1 subgoal):\n 1. ccw' 0 q\n     ((1 - e P) *\\<^sub>R - P +\n      ((\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P) - sum_list (take d QRRs)))", "by (intro ccw'.add3) auto"], ["proof (state)\nthis:\n  ccw' 0 q\n   ((1 - e P) *\\<^sub>R - P +\n    ((\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P) - sum_list (take d QRRs)))\n\ngoal (2 subgoals):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n 2. x \\<in> set (polychain_of (Pc + P) QRRs) \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ccw' 0 q\n   ((1 - e P) *\\<^sub>R - P +\n    ((\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P) - sum_list (take d QRRs)))\n\ngoal (1 subgoal):\n 1. ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "by (auto simp: ccw'.translate_origin q_def algebra_simps d)"], ["proof (state)\nthis:\n  ccw' (fst x) (snd x)\n   (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n\ngoal (1 subgoal):\n 1. fst x = Pc \\<and> snd x = Pc + P \\<Longrightarrow>\n    ccw' (fst x) (snd x)\n     (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))", "qed (metis (no_types, lifting) add.left_commute assms(4) ccw'.add3_self ccw'.scale_add3\n    ccw'.translate)"], ["proof (state)\nthis:\n  ccw' (fst x) (snd x)\n   (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set QRRs. e P *\\<^sub>R P)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polychain_of_ccw_convex:\n  assumes \"e \\<in> UNIV \\<rightarrow> {0 <..< 1}\"\n  assumes sorted: \"linorder_list0.sortedP (ccw' 0) (P#Q#Ps)\"\n  shows \"list_all\n    (\\<lambda>(xi, xj). ccw' xi xj (Pc + (\\<Sum>P \\<in> set (P#Q#Ps). e P *\\<^sub>R P)))\n    (polychain_of Pc (P#Q#Ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n     (polychain_of Pc (P # Q # Ps))", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 (P # Q # Ps)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n     (polychain_of Pc (P # Q # Ps))", "proof (induct Ps arbitrary: P Q Pc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P Q Pc.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 [P, Q]\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set [P, Q]. e P *\\<^sub>R P)))\n                          (polychain_of Pc [P, Q])\n 2. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "case Nil"], ["proof (state)\nthis:\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 [P, Q]\n\ngoal (2 subgoals):\n 1. \\<And>P Q Pc.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 [P, Q]\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set [P, Q]. e P *\\<^sub>R P)))\n                          (polychain_of Pc [P, Q])\n 2. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "have eq: \"e P *\\<^sub>R P + e Q *\\<^sub>R Q - P = (1 - e P) *\\<^sub>R (- P) + e Q *\\<^sub>R Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e P *\\<^sub>R P + e Q *\\<^sub>R Q - P =\n    (1 - e P) *\\<^sub>R - P + e Q *\\<^sub>R Q", "using \\<open>e \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n\ngoal (1 subgoal):\n 1. e P *\\<^sub>R P + e Q *\\<^sub>R Q - P =\n    (1 - e P) *\\<^sub>R - P + e Q *\\<^sub>R Q", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  e P *\\<^sub>R P + e Q *\\<^sub>R Q - P =\n  (1 - e P) *\\<^sub>R - P + e Q *\\<^sub>R Q\n\ngoal (2 subgoals):\n 1. \\<And>P Q Pc.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 [P, Q]\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set [P, Q]. e P *\\<^sub>R P)))\n                          (polychain_of Pc [P, Q])\n 2. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "from Nil ccw'_sortedP_implies_distinct[OF Nil(2)]"], ["proof (chain)\npicking this:\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 [P, Q]\n  distinct [P, Q]", "have \"P \\<noteq> Q\" \"e P < 1\" \"0 < e Q\" \"ccw' 0 P Q\""], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 [P, Q]\n  distinct [P, Q]\n\ngoal (1 subgoal):\n 1. (P \\<noteq> Q &&& e P < 1) &&& 0 < e Q &&& ccw' 0 P Q", "by (auto elim!: linorder_list0.sortedP_Cons)"], ["proof (state)\nthis:\n  P \\<noteq> Q\n  e P < 1\n  0 < e Q\n  ccw' 0 P Q\n\ngoal (2 subgoals):\n 1. \\<And>P Q Pc.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 [P, Q]\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set [P, Q]. e P *\\<^sub>R P)))\n                          (polychain_of Pc [P, Q])\n 2. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<noteq> Q\n  e P < 1\n  0 < e Q\n  ccw' 0 P Q\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow>\n           ccw' xi xj (Pc + (\\<Sum>P\\<in>set [P, Q]. e P *\\<^sub>R P)))\n     (polychain_of Pc [P, Q])", "by (auto simp: ccw'_not_coll ccw'.translate_origin eq)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow>\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set [P, Q]. e P *\\<^sub>R P)))\n   (polychain_of Pc [P, Q])\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "case (Cons R Rs)"], ["proof (state)\nthis:\n  \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n   ccw'.sortedP 0 (?P # ?Q # Rs)\\<rbrakk>\n  \\<Longrightarrow> list_all\n                     (\\<lambda>a.\n                         case a of\n                         (xi, xj) \\<Rightarrow>\n                           ccw' xi xj\n                            (?Pc +\n                             (\\<Sum>P\\<in>set (?P # ?Q # Rs).\n                                e P *\\<^sub>R P)))\n                     (polychain_of ?Pc (?P # ?Q # Rs))\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 (P # Q # R # Rs)\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "hence \"ccw' 0 P Q\" \"P \\<noteq> Q\""], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n   ccw'.sortedP 0 (?P # ?Q # Rs)\\<rbrakk>\n  \\<Longrightarrow> list_all\n                     (\\<lambda>a.\n                         case a of\n                         (xi, xj) \\<Rightarrow>\n                           ccw' xi xj\n                            (?Pc +\n                             (\\<Sum>P\\<in>set (?P # ?Q # Rs).\n                                e P *\\<^sub>R P)))\n                     (polychain_of ?Pc (?P # ?Q # Rs))\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 (P # Q # R # Rs)\n\ngoal (1 subgoal):\n 1. ccw' 0 P Q &&& P \\<noteq> Q", "using ccw'_sortedP_implies_distinct[OF Cons(3)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n   ccw'.sortedP 0 (?P # ?Q # Rs)\\<rbrakk>\n  \\<Longrightarrow> list_all\n                     (\\<lambda>a.\n                         case a of\n                         (xi, xj) \\<Rightarrow>\n                           ccw' xi xj\n                            (?Pc +\n                             (\\<Sum>P\\<in>set (?P # ?Q # Rs).\n                                e P *\\<^sub>R P)))\n                     (polychain_of ?Pc (?P # ?Q # Rs))\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 (P # Q # R # Rs)\n  distinct (P # Q # R # Rs)\n\ngoal (1 subgoal):\n 1. ccw' 0 P Q &&& P \\<noteq> Q", "by (auto elim!: linorder_list0.sortedP_Cons)"], ["proof (state)\nthis:\n  ccw' 0 P Q\n  P \\<noteq> Q\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "have \"list_all (\\<lambda>(xi, xj). ccw' xi xj ((Pc + P) + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n    (polychain_of (Pc + P) (Q # R # Rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj\n          (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n     (polychain_of (Pc + P) (Q # R # Rs))", "using Cons(2-)"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 (P # Q # R # Rs)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj\n          (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n     (polychain_of (Pc + P) (Q # R # Rs))", "by (intro Cons(1)) (auto elim: linorder_list0.sortedP_Cons)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n   (polychain_of (Pc + P) (Q # R # Rs))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "also"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n   (polychain_of (Pc + P) (Q # R # Rs))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "have \"polychain_of (Pc + P) (Q # R # Rs) = tl (polychain_of Pc (P # Q # R # Rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polychain_of (Pc + P) (Q # R # Rs) =\n    tl (polychain_of Pc (P # Q # R # Rs))", "by simp"], ["proof (state)\nthis:\n  polychain_of (Pc + P) (Q # R # Rs) = tl (polychain_of Pc (P # Q # R # Rs))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "finally"], ["proof (chain)\npicking this:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow>\n         ccw' xi xj\n          (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n   (tl (polychain_of Pc (P # Q # R # Rs)))", "have \"list_all (\\<lambda>(xi, xj). ccw' xi xj (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n    (tl (polychain_of Pc (P # Q # R # Rs)))\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow>\n         ccw' xi xj\n          (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n   (tl (polychain_of Pc (P # Q # R # Rs)))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj\n          (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n     (tl (polychain_of Pc (P # Q # R # Rs)))", "."], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n   (tl (polychain_of Pc (P # Q # R # Rs)))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "moreover"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n   (tl (polychain_of Pc (P # Q # R # Rs)))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "have \"list_all\n      (\\<lambda>(xi, xj). ccw' xi xj (P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n      (polychain_of P (Q # R # Rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n     (polychain_of P (Q # R # Rs))", "using Cons(2-)"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 (P # Q # R # Rs)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n     (polychain_of P (Q # R # Rs))", "by (intro Cons(1)) (auto elim: linorder_list0.sortedP_Cons)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj (P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n   (polychain_of P (Q # R # Rs))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "have \"(\\<lambda>(xi, xj). ccw' xi xj (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n    (hd (polychain_of Pc (P # Q # R # Rs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case hd (polychain_of Pc (P # Q # R # Rs)) of\n    (xi, xj) \\<Rightarrow>\n      ccw' xi xj (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))", "using ccw'_sortedP_implies_nonaligned[OF Cons(3), of P Q]\n      ccw'_sortedP_implies_nonaligned[OF Cons(3), of Q R]\n      ccw'_sortedP_implies_nonaligned[OF Cons(3), of P R]\n      Cons(2,3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<in> set (P # Q # R # Rs); Q \\<in> set (P # Q # R # Rs);\n   P \\<noteq> Q\\<rbrakk>\n  \\<Longrightarrow> det3 0 P Q \\<noteq> 0\n  \\<lbrakk>Q \\<in> set (P # Q # R # Rs); R \\<in> set (P # Q # R # Rs);\n   Q \\<noteq> R\\<rbrakk>\n  \\<Longrightarrow> det3 0 Q R \\<noteq> 0\n  \\<lbrakk>P \\<in> set (P # Q # R # Rs); R \\<in> set (P # Q # R # Rs);\n   P \\<noteq> R\\<rbrakk>\n  \\<Longrightarrow> det3 0 P R \\<noteq> 0\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 (P # Q # R # Rs)\n\ngoal (1 subgoal):\n 1. case hd (polychain_of Pc (P # Q # R # Rs)) of\n    (xi, xj) \\<Rightarrow>\n      ccw' xi xj (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))", "by (auto simp add: Pi_iff add.assoc simp del: scaleR_Pair intro!: ccw'.sum\n        elim!: linorder_list0.sortedP_Cons)"], ["proof (state)\nthis:\n  case hd (polychain_of Pc (P # Q # R # Rs)) of\n  (xi, xj) \\<Rightarrow>\n    ccw' xi xj (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "ultimately"], ["proof (chain)\npicking this:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n   (tl (polychain_of Pc (P # Q # R # Rs)))\n  case hd (polychain_of Pc (P # Q # R # Rs)) of\n  (xi, xj) \\<Rightarrow>\n    ccw' xi xj (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))", "have \"list_all\n      (\\<lambda>(xi, xj). ccw' xi xj (P + (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n      (polychain_of Pc (P # Q # R # Rs))\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n   (tl (polychain_of Pc (P # Q # R # Rs)))\n  case hd (polychain_of Pc (P # Q # R # Rs)) of\n  (xi, xj) \\<Rightarrow>\n    ccw' xi xj (Pc + P + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj\n          (P + (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n     (polychain_of Pc (P # Q # R # Rs))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (P + (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n   (polychain_of Pc (P # Q # R # Rs))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "hence \"list_all\n      (\\<lambda>(xi, xj). ccw' xi xj (e P *\\<^sub>R P + (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n      (polychain_of Pc (P # Q # R # Rs))\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (P + (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n   (polychain_of Pc (P # Q # R # Rs))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj\n          (e P *\\<^sub>R P +\n           (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n     (polychain_of Pc (P # Q # R # Rs))", "unfolding split_beta'"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>x.\n       ccw' (fst x) (snd x)\n        (P + (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n   (polychain_of Pc (P # Q # R # Rs))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>x.\n         ccw' (fst x) (snd x)\n          (e P *\\<^sub>R P +\n           (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n     (polychain_of Pc (P # Q # R # Rs))", "by (rule list_all_mp, intro ccw'_scale_origin[OF assms(1)])\n      (auto intro!: ccw'_scale_origin Cons(3))"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (e P *\\<^sub>R P +\n         (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n   (polychain_of Pc (P # Q # R # Rs))\n\ngoal (1 subgoal):\n 1. \\<And>a Ps P Q Pc.\n       \\<lbrakk>\\<And>P Q Pc.\n                   \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n                    ccw'.sortedP 0 (P # Q # Ps)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj).\n    ccw' xi xj (Pc + (\\<Sum>P\\<in>set (P # Q # Ps). e P *\\<^sub>R P)))\n(polychain_of Pc (P # Q # Ps));\n        e \\<in> UNIV \\<rightarrow> {0<..<1};\n        ccw'.sortedP 0 (P # Q # a # Ps)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc +\n                                (\\<Sum>P\\<in>set (P # Q # a # Ps).\n                                   e P *\\<^sub>R P)))\n                          (polychain_of Pc (P # Q # a # Ps))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (e P *\\<^sub>R P +\n         (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n   (polychain_of Pc (P # Q # R # Rs))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow>\n           ccw' xi xj\n            (Pc + (\\<Sum>P\\<in>set (P # Q # R # Rs). e P *\\<^sub>R P)))\n     (polychain_of Pc (P # Q # R # Rs))", "using ccw'_sortedP_implies_distinct[OF Cons(3)] Cons"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj\n        (e P *\\<^sub>R P +\n         (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P))))\n   (polychain_of Pc (P # Q # R # Rs))\n  distinct (P # Q # R # Rs)\n  \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1};\n   ccw'.sortedP 0 (?P # ?Q # Rs)\\<rbrakk>\n  \\<Longrightarrow> list_all\n                     (\\<lambda>a.\n                         case a of\n                         (xi, xj) \\<Rightarrow>\n                           ccw' xi xj\n                            (?Pc +\n                             (\\<Sum>P\\<in>set (?P # ?Q # Rs).\n                                e P *\\<^sub>R P)))\n                     (polychain_of ?Pc (?P # ?Q # Rs))\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 (P # Q # R # Rs)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow>\n           ccw' xi xj\n            (Pc + (\\<Sum>P\\<in>set (P # Q # R # Rs). e P *\\<^sub>R P)))\n     (polychain_of Pc (P # Q # R # Rs))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow>\n         ccw' xi xj\n          (Pc + (\\<Sum>P\\<in>set (P # Q # R # Rs). e P *\\<^sub>R P)))\n   (polychain_of Pc (P # Q # R # Rs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polychain_of_ccw:\n  assumes \"e \\<in> UNIV \\<rightarrow> {0 <..< 1}\"\n  assumes sorted: \"ccw'.sortedP 0 qs\"\n  assumes qs: \"length qs \\<noteq> 1\"\n  shows \"list_all (\\<lambda>(xi, xj). ccw' xi xj (Pc + (\\<Sum>P \\<in> set qs. e P *\\<^sub>R P))) (polychain_of Pc qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n     (polychain_of Pc qs)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 qs\n  length qs \\<noteq> 1\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n     (polychain_of Pc qs)", "proof (cases qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n     length qs \\<noteq> 1; qs = []\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(xi, xj).\n                           ccw' xi xj\n                            (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                       (polychain_of Pc qs)\n 2. \\<And>a list.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n        length qs \\<noteq> 1; qs = a # list\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                          (polychain_of Pc qs)", "case (Cons Q Qs)"], ["proof (state)\nthis:\n  qs = Q # Qs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n     length qs \\<noteq> 1; qs = []\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(xi, xj).\n                           ccw' xi xj\n                            (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                       (polychain_of Pc qs)\n 2. \\<And>a list.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n        length qs \\<noteq> 1; qs = a # list\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                          (polychain_of Pc qs)", "note CQ = this"], ["proof (state)\nthis:\n  qs = Q # Qs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n     length qs \\<noteq> 1; qs = []\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(xi, xj).\n                           ccw' xi xj\n                            (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                       (polychain_of Pc qs)\n 2. \\<And>a list.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n        length qs \\<noteq> 1; qs = a # list\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                          (polychain_of Pc qs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n     (polychain_of Pc qs)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 qs\n  length qs \\<noteq> 1\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n     (polychain_of Pc qs)", "proof (cases Qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n     length qs \\<noteq> 1; Qs = []\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(xi, xj).\n                           ccw' xi xj\n                            (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                       (polychain_of Pc qs)\n 2. \\<And>a list.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n        length qs \\<noteq> 1; Qs = a # list\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                          (polychain_of Pc qs)", "case (Cons R Rs)"], ["proof (state)\nthis:\n  Qs = R # Rs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n     length qs \\<noteq> 1; Qs = []\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(xi, xj).\n                           ccw' xi xj\n                            (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                       (polychain_of Pc qs)\n 2. \\<And>a list.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n        length qs \\<noteq> 1; Qs = a # list\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw' xi xj\n                               (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                          (polychain_of Pc qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Qs = R # Rs\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n     (polychain_of Pc qs)", "using assms"], ["proof (prove)\nusing this:\n  Qs = R # Rs\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 qs\n  length qs \\<noteq> 1\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n     (polychain_of Pc qs)", "unfolding CQ Cons"], ["proof (prove)\nusing this:\n  R # Rs = R # Rs\n  e \\<in> UNIV \\<rightarrow> {0<..<1}\n  ccw'.sortedP 0 (Q # R # Rs)\n  length (Q # R # Rs) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw' xi xj (Pc + (\\<Sum>P\\<in>set (Q # R # Rs). e P *\\<^sub>R P)))\n     (polychain_of Pc (Q # R # Rs))", "by (intro polychain_of_ccw_convex) (auto simp: CQ Cons intro!: polychain_of_ccw_convex)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n   (polychain_of Pc qs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n     length qs \\<noteq> 1; Qs = []\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(xi, xj).\n                           ccw' xi xj\n                            (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                       (polychain_of Pc qs)", "qed (auto simp: CQ)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n   (polychain_of Pc qs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {0<..<1}; ccw'.sortedP 0 qs;\n     length qs \\<noteq> 1; qs = []\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(xi, xj).\n                           ccw' xi xj\n                            (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n                       (polychain_of Pc qs)", "qed simp"], ["", "lemma in_polychain_of_ccw:\n  assumes \"e \\<in> UNIV \\<rightarrow> {0 <..< 1}\"\n  assumes \"ccw'.sortedP 0 qs\"\n  assumes \"length qs \\<noteq> 1\"\n  assumes \"seg \\<in> set (polychain_of Pc qs)\"\n  shows \"ccw' (fst seg) (snd seg) (Pc + (\\<Sum>P \\<in> set qs. e P *\\<^sub>R P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (fst seg) (snd seg) (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P))", "using polychain_of_ccw[OF assms(1,2,3)] assms(4)"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(xi, xj).\n       ccw' xi xj (?Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P)))\n   (polychain_of ?Pc qs)\n  seg \\<in> set (polychain_of Pc qs)\n\ngoal (1 subgoal):\n 1. ccw' (fst seg) (snd seg) (Pc + (\\<Sum>P\\<in>set qs. e P *\\<^sub>R P))", "by (simp add: list_all_iff split_beta)"], ["", "lemma distinct_butlast_ne_last: \"distinct xs \\<Longrightarrow> x \\<in> set (butlast xs) \\<Longrightarrow> x \\<noteq> last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x \\<in> set (butlast xs)\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> last xs", "by (metis append_butlast_last_id distinct_butlast empty_iff in_set_butlastD list.set(1)\n    not_distinct_conv_prefix)"], ["", "lemma\n  ccw'_sortedP_convex_rotate_aux:\n  assumes \"ccw'.sortedP 0 (zs)\" \"ccw'.sortedP x (map snd (polychain_of x (zs)))\"\n  shows \"ccw'.sortedP (snd (last (polychain_of x (zs)))) (map snd (butlast (polychain_of x (zs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (snd (last (polychain_of x zs)))\n     (map snd (butlast (polychain_of x zs)))", "using assms"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 zs\n  ccw'.sortedP x (map snd (polychain_of x zs))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (snd (last (polychain_of x zs)))\n     (map snd (butlast (polychain_of x zs)))", "proof (induct zs arbitrary: x rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ccw'.sortedP 0 [];\n        ccw'.sortedP x (map snd (polychain_of x []))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of x [])))\n                          (map snd (butlast (polychain_of x [])))\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    ccw'.sortedP x (map snd (polychain_of x x2))\\<rbrakk>\n                   \\<Longrightarrow> ccw'.sortedP\n(snd (last (polychain_of x x2))) (map snd (butlast (polychain_of x x2)));\n        ccw'.sortedP 0 (x1 # x2);\n        ccw'.sortedP x (map snd (polychain_of x (x1 # x2)))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP\n                          (snd (last (polychain_of x (x1 # x2))))\n                          (map snd (butlast (polychain_of x (x1 # x2))))", "case (Cons z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>ccw'.sortedP 0 zs;\n   ccw'.sortedP ?x (map snd (polychain_of ?x zs))\\<rbrakk>\n  \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of ?x zs)))\n                     (map snd (butlast (polychain_of ?x zs)))\n  ccw'.sortedP 0 (z # zs)\n  ccw'.sortedP x (map snd (polychain_of x (z # zs)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ccw'.sortedP 0 [];\n        ccw'.sortedP x (map snd (polychain_of x []))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of x [])))\n                          (map snd (butlast (polychain_of x [])))\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    ccw'.sortedP x (map snd (polychain_of x x2))\\<rbrakk>\n                   \\<Longrightarrow> ccw'.sortedP\n(snd (last (polychain_of x x2))) (map snd (butlast (polychain_of x x2)));\n        ccw'.sortedP 0 (x1 # x2);\n        ccw'.sortedP x (map snd (polychain_of x (x1 # x2)))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP\n                          (snd (last (polychain_of x (x1 # x2))))\n                          (map snd (butlast (polychain_of x (x1 # x2))))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>ccw'.sortedP 0 zs;\n   ccw'.sortedP ?x (map snd (polychain_of ?x zs))\\<rbrakk>\n  \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of ?x zs)))\n                     (map snd (butlast (polychain_of ?x zs)))\n  ccw'.sortedP 0 (z # zs)\n  ccw'.sortedP x (map snd (polychain_of x (z # zs)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ccw'.sortedP 0 [];\n        ccw'.sortedP x (map snd (polychain_of x []))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of x [])))\n                          (map snd (butlast (polychain_of x [])))\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    ccw'.sortedP x (map snd (polychain_of x x2))\\<rbrakk>\n                   \\<Longrightarrow> ccw'.sortedP\n(snd (last (polychain_of x x2))) (map snd (butlast (polychain_of x x2)));\n        ccw'.sortedP 0 (x1 # x2);\n        ccw'.sortedP x (map snd (polychain_of x (x1 # x2)))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP\n                          (snd (last (polychain_of x (x1 # x2))))\n                          (map snd (butlast (polychain_of x (x1 # x2))))", "assume \"zs \\<noteq> []\""], ["proof (state)\nthis:\n  zs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ccw'.sortedP 0 [];\n        ccw'.sortedP x (map snd (polychain_of x []))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of x [])))\n                          (map snd (butlast (polychain_of x [])))\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    ccw'.sortedP x (map snd (polychain_of x x2))\\<rbrakk>\n                   \\<Longrightarrow> ccw'.sortedP\n(snd (last (polychain_of x x2))) (map snd (butlast (polychain_of x x2)));\n        ccw'.sortedP 0 (x1 # x2);\n        ccw'.sortedP x (map snd (polychain_of x (x1 # x2)))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP\n                          (snd (last (polychain_of x (x1 # x2))))\n                          (map snd (butlast (polychain_of x (x1 # x2))))", "have \"ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n      (map snd (butlast (polychain_of (x + z) zs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n     (map snd (butlast (polychain_of (x + z) zs)))", "using Cons.prems"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 (z # zs)\n  ccw'.sortedP x (map snd (polychain_of x (z # zs)))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n     (map snd (butlast (polychain_of (x + z) zs)))", "by (auto elim!: ccw'.sortedP_Cons intro!: ccw'_sortedP_polychain_of_snd Cons.hyps)"], ["proof (state)\nthis:\n  ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n   (map snd (butlast (polychain_of (x + z) zs)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ccw'.sortedP 0 [];\n        ccw'.sortedP x (map snd (polychain_of x []))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of x [])))\n                          (map snd (butlast (polychain_of x [])))\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    ccw'.sortedP x (map snd (polychain_of x x2))\\<rbrakk>\n                   \\<Longrightarrow> ccw'.sortedP\n(snd (last (polychain_of x x2))) (map snd (butlast (polychain_of x x2)));\n        ccw'.sortedP 0 (x1 # x2);\n        ccw'.sortedP x (map snd (polychain_of x (x1 # x2)))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP\n                          (snd (last (polychain_of x (x1 # x2))))\n                          (map snd (butlast (polychain_of x (x1 # x2))))", "from _ this"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n   (map snd (butlast (polychain_of (x + z) zs)))", "have \"linorder_list0.sortedP (ccw' (snd (last (polychain_of (x + z) zs))))\n       ((x + z) # map snd (butlast (polychain_of (x + z) zs)))\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n   (map snd (butlast (polychain_of (x + z) zs)))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n     ((x + z) # map snd (butlast (polychain_of (x + z) zs)))", "proof (rule ccw'.sortedP.Cons, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>psi. PROP psi \\<Longrightarrow> PROP psi;\n        ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n         (map snd (butlast (polychain_of (x + z) zs)));\n        (a, b)\n        \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (snd (last (polychain_of (x + z) zs))) (x + z)\n                          (a, b)", "fix c d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>psi. PROP psi \\<Longrightarrow> PROP psi;\n        ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n         (map snd (butlast (polychain_of (x + z) zs)));\n        (a, b)\n        \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (snd (last (polychain_of (x + z) zs))) (x + z)\n                          (a, b)", "assume cd: \"(c, d) \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\""], ["proof (state)\nthis:\n  (c, d) \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>psi. PROP psi \\<Longrightarrow> PROP psi;\n        ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n         (map snd (butlast (polychain_of (x + z) zs)));\n        (a, b)\n        \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (snd (last (polychain_of (x + z) zs))) (x + z)\n                          (a, b)", "then"], ["proof (chain)\npicking this:\n  (c, d) \\<in> set (map snd (butlast (polychain_of (x + z) zs)))", "obtain a b where ab: \"((a, b), c, d) \\<in> set (butlast (polychain_of (x + z) zs))\""], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        ((a, b), c, d)\n        \\<in> set (butlast (polychain_of (x + z) zs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ((a, b), c, d) \\<in> set (butlast (polychain_of (x + z) zs))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>psi. PROP psi \\<Longrightarrow> PROP psi;\n        ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n         (map snd (butlast (polychain_of (x + z) zs)));\n        (a, b)\n        \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (snd (last (polychain_of (x + z) zs))) (x + z)\n                          (a, b)", "have cd': \"(c, d) \\<in> set (butlast (map snd (polychain_of (x + z) zs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, d) \\<in> set (butlast (map snd (polychain_of (x + z) zs)))", "using cd"], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\n\ngoal (1 subgoal):\n 1. (c, d) \\<in> set (butlast (map snd (polychain_of (x + z) zs)))", "by (auto simp: map_butlast)"], ["proof (state)\nthis:\n  (c, d) \\<in> set (butlast (map snd (polychain_of (x + z) zs)))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>psi. PROP psi \\<Longrightarrow> PROP psi;\n        ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n         (map snd (butlast (polychain_of (x + z) zs)));\n        (a, b)\n        \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (snd (last (polychain_of (x + z) zs))) (x + z)\n                          (a, b)", "have \"ccw' (x + z) (c, d) (last (map snd (polychain_of (x + z) zs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (x + z) (c, d) (last (map snd (polychain_of (x + z) zs)))", "proof (rule ccw'.sortedP_right_of_last)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccw'.sortedP (x + z) (map snd (polychain_of (x + z) zs))\n 2. (c, d) \\<in> set (map snd (polychain_of (x + z) zs))\n 3. (c, d) \\<noteq> last (map snd (polychain_of (x + z) zs))", "show \"ccw'.sortedP (x + z) (map snd (polychain_of (x + z) zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (x + z) (map snd (polychain_of (x + z) zs))", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>ccw'.sortedP 0 zs;\n   ccw'.sortedP ?x (map snd (polychain_of ?x zs))\\<rbrakk>\n  \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of ?x zs)))\n                     (map snd (butlast (polychain_of ?x zs)))\n  ccw'.sortedP 0 (z # zs)\n  ccw'.sortedP x (map snd (polychain_of x (z # zs)))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (x + z) (map snd (polychain_of (x + z) zs))", "by (force intro!: ccw'.sortedP.Cons ccw'.sortedP.Nil ccw'_sortedP_polychain_of_snd\n             elim!: ccw'.sortedP_Cons)"], ["proof (state)\nthis:\n  ccw'.sortedP (x + z) (map snd (polychain_of (x + z) zs))\n\ngoal (2 subgoals):\n 1. (c, d) \\<in> set (map snd (polychain_of (x + z) zs))\n 2. (c, d) \\<noteq> last (map snd (polychain_of (x + z) zs))", "show \"(c, d) \\<in> set (map snd (polychain_of (x + z) zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, d) \\<in> set (map snd (polychain_of (x + z) zs))", "using in_set_butlastD[OF ab]"], ["proof (prove)\nusing this:\n  ((a, b), c, d) \\<in> set (polychain_of (x + z) zs)\n\ngoal (1 subgoal):\n 1. (c, d) \\<in> set (map snd (polychain_of (x + z) zs))", "by force"], ["proof (state)\nthis:\n  (c, d) \\<in> set (map snd (polychain_of (x + z) zs))\n\ngoal (1 subgoal):\n 1. (c, d) \\<noteq> last (map snd (polychain_of (x + z) zs))", "from Cons(3) cd'"], ["proof (chain)\npicking this:\n  ccw'.sortedP x (map snd (polychain_of x (z # zs)))\n  (c, d) \\<in> set (butlast (map snd (polychain_of (x + z) zs)))", "show \"(c, d) \\<noteq> last (map snd (polychain_of (x + z) zs))\""], ["proof (prove)\nusing this:\n  ccw'.sortedP x (map snd (polychain_of x (z # zs)))\n  (c, d) \\<in> set (butlast (map snd (polychain_of (x + z) zs)))\n\ngoal (1 subgoal):\n 1. (c, d) \\<noteq> last (map snd (polychain_of (x + z) zs))", "by (intro distinct_butlast_ne_last ccw'_sortedP_implies_distinct[where x=x])\n            (auto elim!: ccw'.sortedP_Cons)"], ["proof (state)\nthis:\n  (c, d) \\<noteq> last (map snd (polychain_of (x + z) zs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccw' (x + z) (c, d) (last (map snd (polychain_of (x + z) zs)))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>psi. PROP psi \\<Longrightarrow> PROP psi;\n        ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n         (map snd (butlast (polychain_of (x + z) zs)));\n        (a, b)\n        \\<in> set (map snd (butlast (polychain_of (x + z) zs)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (snd (last (polychain_of (x + z) zs))) (x + z)\n                          (a, b)", "thus \"ccw' (snd (last (polychain_of (x + z) zs))) (x + z) (c, d)\""], ["proof (prove)\nusing this:\n  ccw' (x + z) (c, d) (last (map snd (polychain_of (x + z) zs)))\n\ngoal (1 subgoal):\n 1. ccw' (snd (last (polychain_of (x + z) zs))) (x + z) (c, d)", "by (auto simp: last_map[symmetric, where f= snd] \\<open>zs \\<noteq> []\\<close> intro: ccw'.cyclicI)"], ["proof (state)\nthis:\n  ccw' (snd (last (polychain_of (x + z) zs))) (x + z) (c, d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n   ((x + z) # map snd (butlast (polychain_of (x + z) zs)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ccw'.sortedP 0 [];\n        ccw'.sortedP x (map snd (polychain_of x []))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of x [])))\n                          (map snd (butlast (polychain_of x [])))\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    ccw'.sortedP x (map snd (polychain_of x x2))\\<rbrakk>\n                   \\<Longrightarrow> ccw'.sortedP\n(snd (last (polychain_of x x2))) (map snd (butlast (polychain_of x x2)));\n        ccw'.sortedP 0 (x1 # x2);\n        ccw'.sortedP x (map snd (polychain_of x (x1 # x2)))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP\n                          (snd (last (polychain_of x (x1 # x2))))\n                          (map snd (butlast (polychain_of x (x1 # x2))))", "}"], ["proof (state)\nthis:\n  zs \\<noteq> [] \\<Longrightarrow>\n  ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n   ((x + z) # map snd (butlast (polychain_of (x + z) zs)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ccw'.sortedP 0 [];\n        ccw'.sortedP x (map snd (polychain_of x []))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of x [])))\n                          (map snd (butlast (polychain_of x [])))\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    ccw'.sortedP x (map snd (polychain_of x x2))\\<rbrakk>\n                   \\<Longrightarrow> ccw'.sortedP\n(snd (last (polychain_of x x2))) (map snd (butlast (polychain_of x x2)));\n        ccw'.sortedP 0 (x1 # x2);\n        ccw'.sortedP x (map snd (polychain_of x (x1 # x2)))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP\n                          (snd (last (polychain_of x (x1 # x2))))\n                          (map snd (butlast (polychain_of x (x1 # x2))))", "thus ?case"], ["proof (prove)\nusing this:\n  zs \\<noteq> [] \\<Longrightarrow>\n  ccw'.sortedP (snd (last (polychain_of (x + z) zs)))\n   ((x + z) # map snd (butlast (polychain_of (x + z) zs)))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (snd (last (polychain_of x (z # zs))))\n     (map snd (butlast (polychain_of x (z # zs))))", "by (auto simp: ccw'.sortedP.Nil)"], ["proof (state)\nthis:\n  ccw'.sortedP (snd (last (polychain_of x (z # zs))))\n   (map snd (butlast (polychain_of x (z # zs))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ccw'.sortedP 0 [];\n        ccw'.sortedP x (map snd (polychain_of x []))\\<rbrakk>\n       \\<Longrightarrow> ccw'.sortedP (snd (last (polychain_of x [])))\n                          (map snd (butlast (polychain_of x [])))", "qed (simp add: ccw'.sortedP.Nil)"], ["", "lemma ccw'_polychain_of_sorted_center_last:\n  assumes set_butlast: \"(c, d) \\<in> set (butlast (polychain_of x0 xs))\"\n  assumes sorted: \"ccw'.sortedP 0 xs\"\n  assumes ne: \"xs \\<noteq> []\"\n  shows \"ccw' x0 d (snd (last (polychain_of x0 xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' x0 d (snd (last (polychain_of x0 xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ccw' x0 d (snd (last (polychain_of x0 xs)))", "from ccw'_sortedP_polychain_of_snd[OF sorted, of x0]"], ["proof (chain)\npicking this:\n  ccw'.sortedP x0 (map snd (polychain_of x0 xs))", "have \"ccw'.sortedP x0 (map snd (polychain_of x0 xs))\""], ["proof (prove)\nusing this:\n  ccw'.sortedP x0 (map snd (polychain_of x0 xs))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map snd (polychain_of x0 xs))", "."], ["proof (state)\nthis:\n  ccw'.sortedP x0 (map snd (polychain_of x0 xs))\n\ngoal (1 subgoal):\n 1. ccw' x0 d (snd (last (polychain_of x0 xs)))", "also"], ["proof (state)\nthis:\n  ccw'.sortedP x0 (map snd (polychain_of x0 xs))\n\ngoal (1 subgoal):\n 1. ccw' x0 d (snd (last (polychain_of x0 xs)))", "from set_butlast"], ["proof (chain)\npicking this:\n  (c, d) \\<in> set (butlast (polychain_of x0 xs))", "obtain ys zs where \"butlast (polychain_of x0 xs) = ys@((c, d)#zs)\""], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (butlast (polychain_of x0 xs))\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        butlast (polychain_of x0 xs) = ys @ (c, d) # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: in_set_conv_decomp)"], ["proof (state)\nthis:\n  butlast (polychain_of x0 xs) = ys @ (c, d) # zs\n\ngoal (1 subgoal):\n 1. ccw' x0 d (snd (last (polychain_of x0 xs)))", "hence \"polychain_of x0 xs = ys @ (c, d) # zs @ [last (polychain_of x0 xs)]\""], ["proof (prove)\nusing this:\n  butlast (polychain_of x0 xs) = ys @ (c, d) # zs\n\ngoal (1 subgoal):\n 1. polychain_of x0 xs = ys @ (c, d) # zs @ [last (polychain_of x0 xs)]", "by (metis append_Cons append_assoc append_butlast_last_id ne polychain_of_eq_empty_iff)"], ["proof (state)\nthis:\n  polychain_of x0 xs = ys @ (c, d) # zs @ [last (polychain_of x0 xs)]\n\ngoal (1 subgoal):\n 1. ccw' x0 d (snd (last (polychain_of x0 xs)))", "finally"], ["proof (chain)\npicking this:\n  ccw'.sortedP x0 (map snd (ys @ (c, d) # zs @ [last (polychain_of x0 xs)]))", "show ?thesis"], ["proof (prove)\nusing this:\n  ccw'.sortedP x0 (map snd (ys @ (c, d) # zs @ [last (polychain_of x0 xs)]))\n\ngoal (1 subgoal):\n 1. ccw' x0 d (snd (last (polychain_of x0 xs)))", "by (auto elim!: ccw'.sortedP_Cons simp: ccw'.sortedP_append_iff)"], ["proof (state)\nthis:\n  ccw' x0 d (snd (last (polychain_of x0 xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}