{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Print.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma show_law_float [show_law_intros]:\n  \"show_law showsp_float r\"", "lemma showsp_float_append [show_law_simps]:\n  \"showsp_float p r (x @ y) = showsp_float p r x @ y\"", "lemma compute_float_of[code]: \"float_of (real_of_float f) = f\"", "lemma prod_case_call_mono[partial_function_mono]:\n  \"mono_tailrec (\\<lambda>f. (let (d, e) = a in (\\<lambda>y. f (c d e y))) b)\"", "lemma show_law_float10_aux:\n  fixes m e\n  shows \"show_law showsp_float10 (Float10 m e)\"", "lemma show_law_float10 [show_law_intros]: \"show_law showsp_float10 r\"", "lemma showsp_float10_append [show_law_simps]:\n  \"showsp_float10 p r (x @ y) = showsp_float10 p r x @ y\"", "lemma show_law_real[show_law_intros]: \"show_law showsp_real x\""], "translations": [["", "lemma show_law_float [show_law_intros]:\n  \"show_law showsp_float r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_float r", "by (auto simp: showsp_float_def Let_def show_law_simps intro!: show_lawI)"], ["", "lemma showsp_float_append [show_law_simps]:\n  \"showsp_float p r (x @ y) = showsp_float p r x @ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. showsp_float p r (x @ y) = showsp_float p r x @ y", "by (intro show_lawD show_law_intros)"], ["", "local_setup \\<open>Show_Generator.register_foreign_showsp @{typ float} @{term \"showsp_float\"} @{thm show_law_float}\\<close>"], ["", "derive \"show\" float"], ["", "subsection \\<open>Convert Float to Decimal number\\<close>"], ["", "text \\<open>type for decimal floating point numbers\n  (currently just for printing, TODO? generalize theory Float for arbitrary base)\\<close>"], ["", "datatype float10 = Float10 (mantissa10: int) (exponent10: int)"], ["", "notation Float10 (infix \"\\<e>\" 999)"], ["", "partial_function (tailrec) normalize_float10\n  where [code]: \"normalize_float10 f =\n    (if mantissa10 f mod 10 \\<noteq> 0 \\<or> mantissa10 f = 0 then f\n    else normalize_float10 (Float10 (mantissa10 f div 20) (exponent10 f + 1)))\""], ["", "subsubsection \\<open>Version that should be easy to prove correct, but slow!\\<close>"], ["", "context includes floatarith_notation begin"], ["", "definition \"float_to_float10_approximation f = the\n  (do {\n    let (x, y) = (mantissa f * 1024, exponent f - 10);\n    let p = nat (bitlen (abs x) + bitlen (abs y) + 80); \\<comment> \\<open>FIXME: are there guarantees?\\<close>\n    y_log \\<leftarrow> approx p (Mult (Num (of_int y))\n      ((Mult (Ln (Num 2))\n        (Inverse (Ln (Num 10)))))) [];\n    let e_fl = floor_fl (lower y_log);\n    let e = int_floor_fl e_fl;\n    m \\<leftarrow> approx p (Mult (Num (of_int x)) (Powr (Num 10) (Add(Var 0) (Minus (Num e_fl))))) [Some y_log];\n    let ml = lower m;\n    let mu = upper m;\n    Some (normalize_float10 (Float10 (int_floor_fl ml) e), normalize_float10 (Float10 (- int_floor_fl (- mu)) e))\n  })\""], ["", "end"], ["", "lemma compute_float_of[code]: \"float_of (real_of_float f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. float_of (real_of_float f) = f", "by simp"], ["", "subsection \\<open>Trusted, but faster version\\<close>"], ["", "text \\<open>TODO: this is the HOL version of the SML-code in Approximation.thy\\<close>"], ["", "lemma prod_case_call_mono[partial_function_mono]:\n  \"mono_tailrec (\\<lambda>f. (let (d, e) = a in (\\<lambda>y. f (c d e y))) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tailrec.mono_body\n     (\\<lambda>f. (let (d, e) = a in (\\<lambda>y. f (c d e y))) b)", "by (simp add: split_beta' call_mono)"], ["", "definition divmod_int::\"int \\<Rightarrow> int \\<Rightarrow> int * int\"\nwhere \"divmod_int a b = (a div b, a mod b)\""], ["", "partial_function (tailrec) f2f10_frac where\n \"f2f10_frac c p r digits cnt e =\n    (if r = 0 then (digits, cnt, 0)\n    else if p = 0 then (digits, cnt, r)\n    else (let\n      (d, r) = divmod_int (r * 10) (power_int 2 (-e))\n    in f2f10_frac (c \\<or> d \\<noteq> 0) (if d \\<noteq> 0 \\<or> c then p - 1 else p) r\n      (digits * 10 + d) (cnt + 1)) e)\""], ["", "declare f2f10_frac.simps[code]"], ["", "definition float2_float10::\"int \\<Rightarrow> bool \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> (int * int)\" where\n  \"float2_float10 prec rd m e = (\n  let\n    (m, e) = (if e < 0 then (m,e) else (m * power_int 2 e, 0));\n    sgn = sgn m;\n    m = abs m;\n\n    round_down = (sgn = 1 \\<and> rd) \\<or> (sgn = -1 \\<and> \\<not> rd);\n\n    (x, r) = divmod_int m ((power_int 2 (-e)));\n\n    p = ((if x = 0 then prec else prec - (log2 x + 1)) * 3) div 10 + 1;\n\n    (digits, e10, r) = if p > 0 then f2f10_frac (x \\<noteq> 0) p r 0 0 e else (0,0,0);\n\n    digits = if round_down \\<or> r = 0 then digits else digits + 1\n\n  in (sgn * (digits + x * (power_int 10 e10)), -e10))\""], ["", "definition \"lfloat10 r = (let f = float_of r in case_prod Float10 (float2_float10 20 True (mantissa f) (exponent f)))\""], ["", "definition \"ufloat10 r = (let f = float_of r in case_prod Float10 (float2_float10 20 False (mantissa f) (exponent f)))\""], ["", "partial_function (tailrec) digits\n  where [code]: \"digits m ds = (if m = 0 then ds else digits (m div 10) (m mod 10 # ds))\""], ["", "primrec showsp_float10 :: \"float10 showsp\"\nwhere\n  \"showsp_float10 p (Float10 m e) = (\n    let\n      ds = digits (nat (abs m)) [];\n      d = int (length ds);\n      e = e + d - 1;\n      mp = take 1 ds;\n      ms = drop 1 ds;\n      ms = rev (dropWhile ((=) 0) (rev ms));\n      show_digits = shows_list_gen (showsp_nat p) ''0'' '''' '''' ''''\n    in (if m < 0 then shows_string ''-'' else (\\<lambda>x. x)) o\n        show_digits mp o\n        (if ms = [] then (\\<lambda>x. x) else shows_string ''.'' o show_digits ms) o\n        (if e = 0 then (\\<lambda>x. x) else shows_string ''e'' o showsp_int p e))\""], ["", "lemma show_law_float10_aux:\n  fixes m e\n  shows \"show_law showsp_float10 (Float10 m e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_float10 (m \\<e> e)", "apply (rule show_lawI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p y z.\n       showsp_float10 p (m \\<e> e) (y @ z) =\n       showsp_float10 p (m \\<e> e) y @ z", "unfolding showsp_float10.simps Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p y z.\n       ((if m < 0 then shows_string ''-'' else (\\<lambda>x. x)) \\<circ>\n        shows_list_gen (showsp_nat p) ''0'' [] [] []\n         (take 1 (digits (nat \\<bar>m\\<bar>) [])) \\<circ>\n        (if rev (dropWhile ((=) 0)\n                  (rev (drop 1 (digits (nat \\<bar>m\\<bar>) [])))) =\n            []\n         then \\<lambda>x. x\n         else shows_string ''.'' \\<circ>\n              shows_list_gen (showsp_nat p) ''0'' [] [] []\n               (rev (dropWhile ((=) 0)\n                      (rev (drop 1\n                             (digits (nat \\<bar>m\\<bar>) [])))))) \\<circ>\n        (if e + int (length (digits (nat \\<bar>m\\<bar>) [])) - 1 = 0\n         then \\<lambda>x. x\n         else shows_string ''e'' \\<circ>\n              showsp_int p\n               (e + int (length (digits (nat \\<bar>m\\<bar>) [])) - 1)))\n        (y @ z) =\n       ((if m < 0 then shows_string ''-'' else (\\<lambda>x. x)) \\<circ>\n        shows_list_gen (showsp_nat p) ''0'' [] [] []\n         (take 1 (digits (nat \\<bar>m\\<bar>) [])) \\<circ>\n        (if rev (dropWhile ((=) 0)\n                  (rev (drop 1 (digits (nat \\<bar>m\\<bar>) [])))) =\n            []\n         then \\<lambda>x. x\n         else shows_string ''.'' \\<circ>\n              shows_list_gen (showsp_nat p) ''0'' [] [] []\n               (rev (dropWhile ((=) 0)\n                      (rev (drop 1\n                             (digits (nat \\<bar>m\\<bar>) [])))))) \\<circ>\n        (if e + int (length (digits (nat \\<bar>m\\<bar>) [])) - 1 = 0\n         then \\<lambda>x. x\n         else shows_string ''e'' \\<circ>\n              showsp_int p\n               (e + int (length (digits (nat \\<bar>m\\<bar>) [])) - 1)))\n        y @\n       z", "apply (simp add: show_law_simps )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma show_law_float10 [show_law_intros]: \"show_law showsp_float10 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_float10 r", "by (cases r) (auto simp: show_law_float10_aux)"], ["", "lemma showsp_float10_append [show_law_simps]:\n  \"showsp_float10 p r (x @ y) = showsp_float10 p r x @ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. showsp_float10 p r (x @ y) = showsp_float10 p r x @ y", "by (intro show_lawD show_law_intros)"], ["", "local_setup \\<open>Show_Generator.register_foreign_showsp @{typ float10} @{term \"showsp_float10\"} @{thm show_law_float10}\\<close>"], ["", "derive \"show\" float10"], ["", "definition \"showsp_real p x = showsp_float10 p (lfloat10 x)\""], ["", "lemma show_law_real[show_law_intros]: \"show_law showsp_real x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_real x", "using show_law_float10[of \"lfloat10 x\"]"], ["proof (prove)\nusing this:\n  show_law showsp_float10 (lfloat10 x)\n\ngoal (1 subgoal):\n 1. show_law showsp_real x", "by (auto simp: showsp_real_def[abs_def] Let_def show_law_def\n      simp del: showsp_float10.simps intro!: show_law_intros)"], ["", "local_setup \\<open>Show_Generator.register_foreign_showsp @{typ real} @{term \"showsp_real\"} @{thm show_law_real}\\<close>"], ["", "derive \"show\" real"], ["", "subsection \\<open>gnuplot output\\<close>"], ["", "subsubsection \\<open>vector output of 2D zonotope\\<close>"], ["", "fun polychain_of_segments::\"((real \\<times> real) \\<times> (real \\<times> real)) list \\<Rightarrow> (real \\<times> real) list\"\n  where\n    \"polychain_of_segments [] = []\"\n  | \"polychain_of_segments (((x0, y0), z)#segs) = (x0, y0)#z#map snd segs\""], ["", "definition shows_segments_of_aform\n  where \"shows_segments_of_aform a b xs color =\n  shows_list_gen id '''' '''' ''\\<newline>'' ''\\<newline>'' (map (\\<lambda>(x0, y0).\n      shows_words (map lfloat10 [x0, y0]) o shows_space o shows_string color)\n    (polychain_of_segments (segments_of_aform (prod_of_aforms (xs ! a) (xs ! b)))))\""], ["", "abbreviation \"show_segments_of_aform a b x c \\<equiv> shows_segments_of_aform a b x c ''''\""], ["", "definition shows_box_of_aforms\\<comment> \\<open>box and some further information\\<close>\nwhere \"shows_box_of_aforms (XS::real aform list) = (let\n    RS = map (Radius' 20) XS;\n    l = map (Inf_aform' 20) XS;\n    u = map (Sup_aform' 20) XS\n    in shows_words\n      (l @ u @ RS) o shows_space o\n      shows (card (\\<Union>((\\<lambda>x. pdevs_domain (snd x)) ` (set XS))))\n    )\""], ["", "abbreviation \"show_box_of_aforms x \\<equiv> shows_box_of_aforms x ''''\""], ["", "definition \"pdevs_domains ((XS::real aform list)) = (\\<Union>((\\<lambda>x. pdevs_domain (snd x)) ` (set XS)))\""], ["", "definition \"generators XS =\n    (let\n      is = sorted_list_of_set (pdevs_domains XS);\n      rs = map (\\<lambda>i. (i, map (\\<lambda>x. pdevs_apply (snd x) i) XS)) is\n    in\n      (map fst XS, rs))\""], ["", "definition shows_box_of_aforms_hr\\<comment> \\<open>human readable\\<close>\nwhere \"shows_box_of_aforms_hr XS = (let\n    RS = map (Radius' 20) XS;\n    l = map (Inf_aform' 20) XS;\n    u = map (Sup_aform' 20) XS\n    in shows_paren (shows_words l) o shows_string '' .. '' o shows_paren (shows_words u) o\n      shows_string ''; devs: '' o shows (card (pdevs_domains XS)) o\n      shows_string ''; tdev: '' o shows_paren (shows_words RS)\n    )\""], ["", "abbreviation \"show_box_of_aforms_hr x \\<equiv> shows_box_of_aforms_hr x ''''\""], ["", "definition shows_aforms_hr\\<comment> \\<open>human readable\\<close>\nwhere \"shows_aforms_hr XS = shows (generators XS)\""], ["", "abbreviation \"show_aform_hr x \\<equiv> shows_aforms_hr x ''''\""], ["", "end"]]}