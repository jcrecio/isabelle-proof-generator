{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Counterclockwise.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma convex3_alt:\n  fixes x y z::\"'a::real_vector\"\n  assumes \"0 \\<le> a\" \"0 \\<le> b\" \"0 \\<le> c\" \"a + b + c = 1\"\n  obtains u v  where \"a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z = x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x)\"\n    and \"0 \\<le> u\" \"0 \\<le> v\" \"u + v \\<le> 1\"", "lemma (in ordered_ab_group_add) add_nonpos_eq_0_iff:\n  assumes x: \"0 \\<ge> x\" and y: \"0 \\<ge> y\"\n  shows \"x + y = 0 \\<longleftrightarrow> x = 0 \\<and> y = 0\"", "lemma sum_nonpos_eq_0_iff:\n  fixes f :: \"'a \\<Rightarrow> 'b::ordered_ab_group_add\"\n  shows \"\\<lbrakk>finite A; \\<forall>x\\<in>A. f x \\<le> 0\\<rbrakk> \\<Longrightarrow> sum f A = 0 \\<longleftrightarrow> (\\<forall>x\\<in>A. f x = 0)\"", "lemma fold_if_in_set:\n  \"fold (\\<lambda>x m. if P x m then x else m) xs x \\<in> set (x#xs)\"", "lemma min_for_in[simp]: \"x \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> min_for x y \\<in> S\"", "lemma fold_min_eqI1: \"fold min_for ys y \\<notin> set ys \\<Longrightarrow> fold min_for ys y = y\"", "lemma in_set_selsort_eq: \"x \\<in> set (selsort xs) \\<longleftrightarrow> x \\<in> (set xs)\"", "lemma set_selsort[simp]: \"set (selsort xs) = set xs\"", "lemma length_selsort[simp]: \"length (selsort xs) = length xs\"", "lemma distinct_selsort[simp]: \"distinct (selsort xs) = distinct xs\"", "lemma selsort_eq_empty_iff[simp]: \"selsort xs = [] \\<longleftrightarrow> xs = []\"", "lemma sortedP_append_iff:\n  \"sortedP (xs @ ys) = (sortedP xs & sortedP ys & (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. le x y))\"", "lemma sortedP_appendI:\n  \"sortedP xs \\<Longrightarrow> sortedP ys \\<Longrightarrow> (\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> le x y) \\<Longrightarrow> sortedP (xs @ ys)\"", "lemma sorted_nth_less: \"sortedP xs \\<Longrightarrow> i < j \\<Longrightarrow> j < length xs \\<Longrightarrow> le (xs ! i) (xs ! j)\"", "lemma sorted_butlastI[intro, simp]: \"sortedP xs \\<Longrightarrow> sortedP (butlast xs)\"", "lemma sortedP_right_of_append1:\n  assumes \"sortedP (zs@[z])\"\n  assumes \"y \\<in> set zs\"\n  shows \"le y z\"", "lemma sortedP_right_of_last:\n  assumes \"sortedP zs\"\n  assumes \"y \\<in> set zs\" \"y \\<noteq> last zs\"\n  shows \"le y (last zs)\"", "lemma selsort_singleton_iff: \"selsort xs = [x] \\<longleftrightarrow> xs = [x]\"", "lemma hd_last_sorted:\n  assumes \"sortedP xs\" \"length xs > 1\"\n  shows \"le (hd xs) (last xs)\"", "lemma (in comm_monoid_add) sum_list_distinct_selsort:\n  assumes \"distinct xs\"\n  shows \"sum_list (linorder_list0.selsort le xs) = sum_list xs\"", "lemma trans: \"a \\<in> S \\<Longrightarrow> b \\<in> S \\<Longrightarrow> c \\<in> S \\<Longrightarrow> le a b \\<Longrightarrow> le b c \\<Longrightarrow> le a c\"", "lemma linear: \"a \\<in> S \\<Longrightarrow> b \\<in> S \\<Longrightarrow> le a b \\<or> le b a\"", "lemma min_le1: \"w \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> le (min_for w y) y\"\n  and min_le2: \"w \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> le (min_for w y) w\"", "lemma fold_min:\n  assumes \"set xs \\<subseteq> S\"\n  shows \"list_all (\\<lambda>y. le (fold min_for (tl xs) (hd xs)) y) xs\"", "lemma\n  sortedP_selsort:\n  assumes \"set xs \\<subseteq> S\"\n  shows \"sortedP (selsort xs)\"", "lemma not_ccw_eq: \"distinct3 p q r \\<Longrightarrow> in3 S p q r \\<Longrightarrow> \\<not> ccw p q r \\<longleftrightarrow> ccw p r q\"", "lemma interior':\n  \"distinct4 p q r t \\<Longrightarrow> in4 S p q r t \\<Longrightarrow> ccw p q t \\<Longrightarrow> ccw q r t \\<Longrightarrow> ccw r p t \\<Longrightarrow> ccw p q r\"", "lemmas ccw_axioms = cyclic nondegenerate ccw_antisym transitive"], "translations": [["", "lemma convex3_alt:\n  fixes x y z::\"'a::real_vector\"\n  assumes \"0 \\<le> a\" \"0 \\<le> b\" \"0 \\<le> c\" \"a + b + c = 1\"\n  obtains u v  where \"a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z = x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x)\"\n    and \"0 \\<le> u\" \"0 \\<le> v\" \"u + v \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z =\n                 x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x);\n         0 \\<le> u; 0 \\<le> v; u + v \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z =\n                 x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x);\n         0 \\<le> u; 0 \\<le> v; u + v \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from convex_hull_3[of x y z]"], ["proof (chain)\npicking this:\n  convex hull {x, y, z} =\n  {u *\\<^sub>R x + v *\\<^sub>R y + w *\\<^sub>R z |u v w.\n   0 \\<le> u \\<and> 0 \\<le> v \\<and> 0 \\<le> w \\<and> u + v + w = 1}", "have \"a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z \\<in> convex hull {x, y, z}\""], ["proof (prove)\nusing this:\n  convex hull {x, y, z} =\n  {u *\\<^sub>R x + v *\\<^sub>R y + w *\\<^sub>R z |u v w.\n   0 \\<le> u \\<and> 0 \\<le> v \\<and> 0 \\<le> w \\<and> u + v + w = 1}\n\ngoal (1 subgoal):\n 1. a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z\n    \\<in> convex hull {x, y, z}", "using assms"], ["proof (prove)\nusing this:\n  convex hull {x, y, z} =\n  {u *\\<^sub>R x + v *\\<^sub>R y + w *\\<^sub>R z |u v w.\n   0 \\<le> u \\<and> 0 \\<le> v \\<and> 0 \\<le> w \\<and> u + v + w = 1}\n  0 \\<le> a\n  0 \\<le> b\n  0 \\<le> c\n  a + b + c = 1\n\ngoal (1 subgoal):\n 1. a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z\n    \\<in> convex hull {x, y, z}", "by auto"], ["proof (state)\nthis:\n  a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z \\<in> convex hull {x, y, z}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z =\n                 x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x);\n         0 \\<le> u; 0 \\<le> v; u + v \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z \\<in> convex hull {x, y, z}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z =\n                 x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x);\n         0 \\<le> u; 0 \\<le> v; u + v \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note convex_hull_3_alt"], ["proof (state)\nthis:\n  convex hull {?a, ?b, ?c} =\n  {?a + u *\\<^sub>R (?b - ?a) + v *\\<^sub>R (?c - ?a) |u v.\n   0 \\<le> u \\<and> 0 \\<le> v \\<and> u + v \\<le> 1}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z =\n                 x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x);\n         0 \\<le> u; 0 \\<le> v; u + v \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z\n  \\<in> {x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x) |u v.\n         0 \\<le> u \\<and> 0 \\<le> v \\<and> u + v \\<le> 1}", "obtain u v where \"a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z = x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x)\"\n    and uv: \"0 \\<le> u\" \"0 \\<le> v\" \"u + v \\<le> 1\""], ["proof (prove)\nusing this:\n  a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z\n  \\<in> {x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x) |u v.\n         0 \\<le> u \\<and> 0 \\<le> v \\<and> u + v \\<le> 1}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z =\n                 x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x);\n         0 \\<le> u; 0 \\<le> v; u + v \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z =\n  x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x)\n  0 \\<le> u\n  0 \\<le> v\n  u + v \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z =\n                 x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x);\n         0 \\<le> u; 0 \\<le> v; u + v \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  a *\\<^sub>R x + b *\\<^sub>R y + c *\\<^sub>R z =\n  x + u *\\<^sub>R (y - x) + v *\\<^sub>R (z - x)\n  0 \\<le> u\n  0 \\<le> v\n  u + v \\<le> 1\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ordered_ab_group_add) add_nonpos_eq_0_iff:\n  assumes x: \"0 \\<ge> x\" and y: \"0 \\<ge> y\"\n  shows \"x + y = 0 \\<longleftrightarrow> x = 0 \\<and> y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y = (0::'a)) = (x = (0::'a) \\<and> y = (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x + y = (0::'a)) = (x = (0::'a) \\<and> y = (0::'a))", "from add_nonneg_eq_0_iff[of \"-x\" \"-y\"] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>(0::'a) \\<le> - x; (0::'a) \\<le> - y\\<rbrakk>\n  \\<Longrightarrow> (- x + - y = (0::'a)) =\n                    (- x = (0::'a) \\<and> - y = (0::'a))\n  x \\<le> (0::'a)\n  y \\<le> (0::'a)", "have \"- (x + y) = 0 \\<longleftrightarrow> - x = 0 \\<and> - y = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::'a) \\<le> - x; (0::'a) \\<le> - y\\<rbrakk>\n  \\<Longrightarrow> (- x + - y = (0::'a)) =\n                    (- x = (0::'a) \\<and> - y = (0::'a))\n  x \\<le> (0::'a)\n  y \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. (- (x + y) = (0::'a)) = (- x = (0::'a) \\<and> - y = (0::'a))", "by simp"], ["proof (state)\nthis:\n  (- (x + y) = (0::'a)) = (- x = (0::'a) \\<and> - y = (0::'a))\n\ngoal (1 subgoal):\n 1. (x + y = (0::'a)) = (x = (0::'a) \\<and> y = (0::'a))", "also"], ["proof (state)\nthis:\n  (- (x + y) = (0::'a)) = (- x = (0::'a) \\<and> - y = (0::'a))\n\ngoal (1 subgoal):\n 1. (x + y = (0::'a)) = (x = (0::'a) \\<and> y = (0::'a))", "have \"(- (x + y) = 0) = (x + y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (x + y) = (0::'a)) = (x + y = (0::'a))", "unfolding neg_equal_0_iff_equal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y = (0::'a)) = (x + y = (0::'a))", ".."], ["proof (state)\nthis:\n  (- (x + y) = (0::'a)) = (x + y = (0::'a))\n\ngoal (1 subgoal):\n 1. (x + y = (0::'a)) = (x = (0::'a) \\<and> y = (0::'a))", "finally"], ["proof (chain)\npicking this:\n  (x + y = (0::'a)) = (- x = (0::'a) \\<and> - y = (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  (x + y = (0::'a)) = (- x = (0::'a) \\<and> - y = (0::'a))\n\ngoal (1 subgoal):\n 1. (x + y = (0::'a)) = (x = (0::'a) \\<and> y = (0::'a))", "by simp"], ["proof (state)\nthis:\n  (x + y = (0::'a)) = (x = (0::'a) \\<and> y = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_nonpos_eq_0_iff:\n  fixes f :: \"'a \\<Rightarrow> 'b::ordered_ab_group_add\"\n  shows \"\\<lbrakk>finite A; \\<forall>x\\<in>A. f x \\<le> 0\\<rbrakk> \\<Longrightarrow> sum f A = 0 \\<longleftrightarrow> (\\<forall>x\\<in>A. f x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; \\<forall>x\\<in>A. f x \\<le> (0::'b)\\<rbrakk>\n    \\<Longrightarrow> (sum f A = (0::'b)) =\n                      (\\<forall>x\\<in>A. f x = (0::'b))", "by (induct set: finite) (simp_all add: add_nonpos_eq_0_iff sum_nonpos)"], ["", "lemma fold_if_in_set:\n  \"fold (\\<lambda>x m. if P x m then x else m) xs x \\<in> set (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x m. if P x m then x else m) xs x \\<in> set (x # xs)", "by (induct xs arbitrary: x) auto"], ["", "subsection \\<open>Sort Elements of a List\\<close>"], ["", "locale linorder_list0 = fixes le::\"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\nbegin"], ["", "definition \"min_for a b = (if le a b then a else b)\""], ["", "lemma min_for_in[simp]: \"x \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> min_for x y \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> min_for x y \\<in> S", "by (auto simp: min_for_def)"], ["", "lemma fold_min_eqI1: \"fold min_for ys y \\<notin> set ys \\<Longrightarrow> fold min_for ys y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold min_for ys y \\<notin> set ys \\<Longrightarrow>\n    fold min_for ys y = y", "using fold_if_in_set[of _ ys y]"], ["proof (prove)\nusing this:\n  fold (\\<lambda>x m. if ?P x m then x else m) ys y \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. fold min_for ys y \\<notin> set ys \\<Longrightarrow>\n    fold min_for ys y = y", "by (auto simp: min_for_def[abs_def])"], ["", "function selsort where\n  \"selsort [] = []\"\n| \"selsort (y#ys) = (let\n      xm = fold min_for ys y;\n      xs' = List.remove1 xm (y#ys)\n    in (xm#selsort xs'))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>y ys. x = y # ys \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> [] = []\n 3. \\<And>y ys.\n       [] = y # ys \\<Longrightarrow>\n       [] =\n       (let xm = fold min_for ys y; xs' = remove1 xm (y # ys)\n        in xm # selsort_sumC xs')\n 4. \\<And>y ys ya ysa.\n       y # ys = ya # ysa \\<Longrightarrow>\n       (let xm = fold min_for ys y; xs' = remove1 xm (y # ys)\n        in xm # selsort_sumC xs') =\n       (let xm = fold min_for ysa ya; xs' = remove1 xm (ya # ysa)\n        in xm # selsort_sumC xs')", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All selsort_dom", "by (relation \"Wellfounded.measure length\")\n    (auto simp: length_remove1 intro!: fold_min_eqI1 dest!: length_pos_if_in_set)"], ["", "lemma in_set_selsort_eq: \"x \\<in> set (selsort xs) \\<longleftrightarrow> x \\<in> (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (selsort xs)) = (x \\<in> set xs)", "by (induct rule: selsort.induct) (auto simp: Let_def intro!: fold_min_eqI1)"], ["", "lemma set_selsort[simp]: \"set (selsort xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (selsort xs) = set xs", "using in_set_selsort_eq"], ["proof (prove)\nusing this:\n  (?x \\<in> set (selsort ?xs)) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. set (selsort xs) = set xs", "by blast"], ["", "lemma length_selsort[simp]: \"length (selsort xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (selsort xs) = length xs", "proof (induct xs rule: selsort.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (selsort []) = length []\n 2. \\<And>y ys.\n       (\\<And>x xa.\n           \\<lbrakk>x = fold min_for ys y; xa = remove1 x (y # ys)\\<rbrakk>\n           \\<Longrightarrow> length (selsort xa) =\n                             length xa) \\<Longrightarrow>\n       length (selsort (y # ys)) = length (y # ys)", "case (2 x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = fold min_for xs x; ?xa = remove1 ?x (x # xs)\\<rbrakk>\n  \\<Longrightarrow> length (selsort ?xa) = length ?xa\n\ngoal (2 subgoals):\n 1. length (selsort []) = length []\n 2. \\<And>y ys.\n       (\\<And>x xa.\n           \\<lbrakk>x = fold min_for ys y; xa = remove1 x (y # ys)\\<rbrakk>\n           \\<Longrightarrow> length (selsort xa) =\n                             length xa) \\<Longrightarrow>\n       length (selsort (y # ys)) = length (y # ys)", "from 2[OF refl refl]"], ["proof (chain)\npicking this:\n  length (selsort (remove1 (fold min_for xs x) (x # xs))) =\n  length (remove1 (fold min_for xs x) (x # xs))", "show ?case"], ["proof (prove)\nusing this:\n  length (selsort (remove1 (fold min_for xs x) (x # xs))) =\n  length (remove1 (fold min_for xs x) (x # xs))\n\ngoal (1 subgoal):\n 1. length (selsort (x # xs)) = length (x # xs)", "unfolding selsort.simps"], ["proof (prove)\nusing this:\n  length (selsort (remove1 (fold min_for xs x) (x # xs))) =\n  length (remove1 (fold min_for xs x) (x # xs))\n\ngoal (1 subgoal):\n 1. length\n     (let xm = fold min_for xs x; xs' = remove1 xm (x # xs)\n      in xm # selsort xs') =\n    length (x # xs)", "by (auto simp: Let_def length_remove1\n      simp del: selsort.simps split: if_split_asm\n      intro!: Suc_pred\n      dest!: fold_min_eqI1)"], ["proof (state)\nthis:\n  length (selsort (x # xs)) = length (x # xs)\n\ngoal (1 subgoal):\n 1. length (selsort []) = length []", "qed simp"], ["", "lemma distinct_selsort[simp]: \"distinct (selsort xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (selsort xs) = distinct xs", "by (auto intro!: card_distinct dest!: distinct_card)"], ["", "lemma selsort_eq_empty_iff[simp]: \"selsort xs = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (selsort xs = []) = (xs = [])", "by (cases xs) (auto simp: Let_def)"], ["", "inductive sortedP :: \"'a list \\<Rightarrow> bool\" where\n  Nil: \"sortedP []\"\n| Cons: \"\\<forall>y\\<in>set ys. le x y \\<Longrightarrow> sortedP ys \\<Longrightarrow> sortedP (x # ys)\""], ["", "inductive_cases\n  sortedP_Nil: \"sortedP []\" and\n  sortedP_Cons: \"sortedP (x#xs)\""], ["", "inductive_simps\n  sortedP_Nil_iff: \"sortedP Nil\" and\n  sortedP_Cons_iff: \"sortedP (Cons x xs)\""], ["", "lemma sortedP_append_iff:\n  \"sortedP (xs @ ys) = (sortedP xs & sortedP ys & (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. le x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sortedP (xs @ ys) =\n    (sortedP xs \\<and>\n     sortedP ys \\<and>\n     (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. le x y))", "by (induct xs) (auto intro!: Nil Cons elim!: sortedP_Cons)"], ["", "lemma sortedP_appendI:\n  \"sortedP xs \\<Longrightarrow> sortedP ys \\<Longrightarrow> (\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> le x y) \\<Longrightarrow> sortedP (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sortedP xs; sortedP ys;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> le x y\\<rbrakk>\n    \\<Longrightarrow> sortedP (xs @ ys)", "by (induct xs) (auto intro!: Nil Cons elim!: sortedP_Cons)"], ["", "lemma sorted_nth_less: \"sortedP xs \\<Longrightarrow> i < j \\<Longrightarrow> j < length xs \\<Longrightarrow> le (xs ! i) (xs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sortedP xs; i < j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> le (xs ! i) (xs ! j)", "by (induct xs arbitrary: i j) (auto simp: nth_Cons split: nat.split elim!: sortedP_Cons)"], ["", "lemma sorted_butlastI[intro, simp]: \"sortedP xs \\<Longrightarrow> sortedP (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sortedP xs \\<Longrightarrow> sortedP (butlast xs)", "by (induct xs) (auto simp: elim!: sortedP_Cons intro!: sortedP.Cons dest!: in_set_butlastD)"], ["", "lemma sortedP_right_of_append1:\n  assumes \"sortedP (zs@[z])\"\n  assumes \"y \\<in> set zs\"\n  shows \"le y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le y z", "using assms"], ["proof (prove)\nusing this:\n  sortedP (zs @ [z])\n  y \\<in> set zs\n\ngoal (1 subgoal):\n 1. le y z", "by (induct zs arbitrary: y z) (auto elim!: sortedP_Cons)"], ["", "lemma sortedP_right_of_last:\n  assumes \"sortedP zs\"\n  assumes \"y \\<in> set zs\" \"y \\<noteq> last zs\"\n  shows \"le y (last zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le y (last zs)", "using assms"], ["proof (prove)\nusing this:\n  sortedP zs\n  y \\<in> set zs\n  y \\<noteq> last zs\n\ngoal (1 subgoal):\n 1. le y (last zs)", "apply (intro sortedP_right_of_append1[of \"butlast zs\" \"last zs\" y])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sortedP zs; y \\<in> set zs; y \\<noteq> last zs\\<rbrakk>\n    \\<Longrightarrow> sortedP (butlast zs @ [last zs])\n 2. \\<lbrakk>sortedP zs; y \\<in> set zs; y \\<noteq> last zs\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set (butlast zs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sortedP zs; y \\<in> set zs; y \\<noteq> last zs\\<rbrakk>\n    \\<Longrightarrow> sortedP (butlast zs @ [last zs])", "by (metis append_is_Nil_conv list.distinct(1) snoc_eq_iff_butlast split_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sortedP zs; y \\<in> set zs; y \\<noteq> last zs\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set (butlast zs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sortedP zs; y \\<in> set zs; y \\<noteq> last zs\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set (butlast zs)", "by (metis List.insert_def append_butlast_last_id insert_Nil list.distinct(1) rotate1.simps(2)\n    set_ConsD set_rotate1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma selsort_singleton_iff: \"selsort xs = [x] \\<longleftrightarrow> xs = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (selsort xs = [x]) = (xs = [x])", "by (induct xs) (auto simp: Let_def)"], ["", "lemma hd_last_sorted:\n  assumes \"sortedP xs\" \"length xs > 1\"\n  shows \"le (hd xs) (last xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le (hd xs) (last xs)", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> le (hd xs) (last xs)\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> le (hd xs) (last xs)", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> le (hd xs) (last xs)\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> le (hd xs) (last xs)", "note ys = this"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> le (hd xs) (last xs)\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> le (hd xs) (last xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. le (hd xs) (last xs)", "using ys assms"], ["proof (prove)\nusing this:\n  xs = y # ys\n  xs = y # ys\n  sortedP xs\n  1 < length xs\n\ngoal (1 subgoal):\n 1. le (hd xs) (last xs)", "by (auto elim!: sortedP_Cons)"], ["proof (state)\nthis:\n  le (hd xs) (last xs)\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> le (hd xs) (last xs)", "qed (insert assms, simp)"], ["", "end"], ["", "lemma (in comm_monoid_add) sum_list_distinct_selsort:\n  assumes \"distinct xs\"\n  shows \"sum_list (linorder_list0.selsort le xs) = sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (linorder_list0.selsort le xs) = sum_list xs", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. sum_list (linorder_list0.selsort le xs) = sum_list xs", "apply (simp add: distinct_sum_list_conv_Sum linorder_list0.distinct_selsort)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow>\n    \\<Sum> (set (linorder_list0.selsort le xs)) = \\<Sum> (set xs)", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct xs \\<Longrightarrow>\n    set (linorder_list0.selsort le xs) = set xs\n 2. \\<And>x.\n       \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk> \\<Longrightarrow> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow>\n    set (linorder_list0.selsort le xs) = set xs", "by (simp add: linorder_list0.set_selsort)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk> \\<Longrightarrow> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x_ \\<in> set xs\\<rbrakk> \\<Longrightarrow> x_ = x_", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare linorder_list0.sortedP_Nil_iff[code]\n  linorder_list0.sortedP_Cons_iff[code]\n  linorder_list0.selsort.simps[code]\n  linorder_list0.min_for_def[code]"], ["", "locale linorder_list = linorder_list0 le for le::\"'a::ab_group_add \\<Rightarrow> _\" +\n  fixes S\n  assumes order_refl: \"a \\<in> S \\<Longrightarrow> le a a\"\n  assumes trans': \"a \\<in> S \\<Longrightarrow> b \\<in> S \\<Longrightarrow> c \\<in> S \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow> b \\<noteq> c \\<Longrightarrow> a \\<noteq> c \\<Longrightarrow>\n    le a b \\<Longrightarrow> le b c \\<Longrightarrow> le a c\"\n  assumes antisym: \"a \\<in> S \\<Longrightarrow> b \\<in> S \\<Longrightarrow> le a b \\<Longrightarrow> le b a \\<Longrightarrow> a = b\"\n  assumes linear': \"a \\<in> S \\<Longrightarrow> b \\<in> S \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow> le a b \\<or> le b a\"\nbegin"], ["", "lemma trans: \"a \\<in> S \\<Longrightarrow> b \\<in> S \\<Longrightarrow> c \\<in> S \\<Longrightarrow> le a b \\<Longrightarrow> le b c \\<Longrightarrow> le a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S; c \\<in> S; le a b; le b c\\<rbrakk>\n    \\<Longrightarrow> le a c", "by (cases \"a = b\" \"b = c\" \"a = c\"\n    rule: bool.exhaust[case_product bool.exhaust[case_product bool.exhaust]])\n    (auto simp: order_refl intro: trans')"], ["", "lemma linear: \"a \\<in> S \\<Longrightarrow> b \\<in> S \\<Longrightarrow> le a b \\<or> le b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S\\<rbrakk>\n    \\<Longrightarrow> le a b \\<or> le b a", "by (cases \"a = b\") (auto simp: linear' order_refl)"], ["", "lemma min_le1: \"w \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> le (min_for w y) y\"\n  and min_le2: \"w \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> le (min_for w y) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>w \\<in> S; y \\<in> S\\<rbrakk>\n     \\<Longrightarrow> le (min_for w y) y) &&&\n    (\\<lbrakk>w \\<in> S; y \\<in> S\\<rbrakk>\n     \\<Longrightarrow> le (min_for w y) w)", "using linear"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> S; ?b \\<in> S\\<rbrakk>\n  \\<Longrightarrow> le ?a ?b \\<or> le ?b ?a\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>w \\<in> S; y \\<in> S\\<rbrakk>\n     \\<Longrightarrow> le (min_for w y) y) &&&\n    (\\<lbrakk>w \\<in> S; y \\<in> S\\<rbrakk>\n     \\<Longrightarrow> le (min_for w y) w)", "by (auto simp: min_for_def refl)"], ["", "lemma fold_min:\n  assumes \"set xs \\<subseteq> S\"\n  shows \"list_all (\\<lambda>y. le (fold min_for (tl xs) (hd xs)) y) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (le (fold min_for (tl xs) (hd xs))) xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    list_all (le (fold min_for (tl xs) (hd xs))) xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       list_all (le (fold min_for (tl xs) (hd xs))) xs", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    list_all (le (fold min_for (tl xs) (hd xs))) xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       list_all (le (fold min_for (tl xs) (hd xs))) xs", "hence subset: \"set (y#ys) \\<subseteq> S\""], ["proof (prove)\nusing this:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. set (y # ys) \\<subseteq> S", "using assms"], ["proof (prove)\nusing this:\n  xs = y # ys\n  set xs \\<subseteq> S\n\ngoal (1 subgoal):\n 1. set (y # ys) \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  set (y # ys) \\<subseteq> S\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    list_all (le (fold min_for (tl xs) (hd xs))) xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       list_all (le (fold min_for (tl xs) (hd xs))) xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (le (fold min_for (tl xs) (hd xs))) xs", "unfolding Cons list.sel"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (le (fold min_for ys y)) (y # ys)", "using subset"], ["proof (prove)\nusing this:\n  set (y # ys) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. list_all (le (fold min_for ys y)) (y # ys)", "proof (induct ys arbitrary: y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "case (Cons z zs)"], ["proof (state)\nthis:\n  set (?y # zs) \\<subseteq> S \\<Longrightarrow>\n  list_all (le (fold min_for zs ?y)) (?y # zs)\n  set (y # z # zs) \\<subseteq> S\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "hence IH: \"\\<And>y. y \\<in> S \\<Longrightarrow> list_all (le (fold min_for zs y)) (y # zs)\""], ["proof (prove)\nusing this:\n  set (?y # zs) \\<subseteq> S \\<Longrightarrow>\n  list_all (le (fold min_for zs ?y)) (?y # zs)\n  set (y # z # zs) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> S \\<Longrightarrow>\n       list_all (le (fold min_for zs y)) (y # zs)", "by simp"], ["proof (state)\nthis:\n  ?y \\<in> S \\<Longrightarrow> list_all (le (fold min_for zs ?y)) (?y # zs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "let ?f = \"fold min_for zs (min_for z y)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "have \"?f \\<in> set ((min_for z y)#zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold min_for zs (min_for z y) \\<in> set (min_for z y # zs)", "unfolding min_for_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>a b. if le a b then a else b) zs\n     (if le z y then z else y)\n    \\<in> set ((if le z y then z else y) # zs)", "by (rule fold_if_in_set)"], ["proof (state)\nthis:\n  fold min_for zs (min_for z y) \\<in> set (min_for z y # zs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "also"], ["proof (state)\nthis:\n  fold min_for zs (min_for z y) \\<in> set (min_for z y # zs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "have \"\\<dots> \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (min_for z y # zs) \\<subseteq> S", "using Cons.prems"], ["proof (prove)\nusing this:\n  set (y # z # zs) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. set (min_for z y # zs) \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  set (min_for z y # zs) \\<subseteq> S\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "finally"], ["proof (chain)\npicking this:\n  fold min_for zs (min_for z y) \\<in> S", "have \"?f \\<in> S\""], ["proof (prove)\nusing this:\n  fold min_for zs (min_for z y) \\<in> S\n\ngoal (1 subgoal):\n 1. fold min_for zs (min_for z y) \\<in> S", "."], ["proof (state)\nthis:\n  fold min_for zs (min_for z y) \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "have \"le ?f (min_for z y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le (fold min_for zs (min_for z y)) (min_for z y)", "using IH[of \"min_for z y\"] Cons.prems"], ["proof (prove)\nusing this:\n  min_for z y \\<in> S \\<Longrightarrow>\n  list_all (le (fold min_for zs (min_for z y))) (min_for z y # zs)\n  set (y # z # zs) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. le (fold min_for zs (min_for z y)) (min_for z y)", "by auto"], ["proof (state)\nthis:\n  le (fold min_for zs (min_for z y)) (min_for z y)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "moreover"], ["proof (state)\nthis:\n  le (fold min_for zs (min_for z y)) (min_for z y)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "have \"le (min_for z y) y\" \"le (min_for z y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le (min_for z y) y &&& le (min_for z y) z", "using Cons.prems"], ["proof (prove)\nusing this:\n  set (y # z # zs) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. le (min_for z y) y &&& le (min_for z y) z", "by (auto intro!: min_le1 min_le2)"], ["proof (state)\nthis:\n  le (min_for z y) y\n  le (min_for z y) z\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "ultimately"], ["proof (chain)\npicking this:\n  le (fold min_for zs (min_for z y)) (min_for z y)\n  le (min_for z y) y\n  le (min_for z y) z", "have \"le ?f y\" \"le ?f z\""], ["proof (prove)\nusing this:\n  le (fold min_for zs (min_for z y)) (min_for z y)\n  le (min_for z y) y\n  le (min_for z y) z\n\ngoal (1 subgoal):\n 1. le (fold min_for zs (min_for z y)) y &&&\n    le (fold min_for zs (min_for z y)) z", "using Cons.prems \\<open>?f \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  le (fold min_for zs (min_for z y)) (min_for z y)\n  le (min_for z y) y\n  le (min_for z y) z\n  set (y # z # zs) \\<subseteq> S\n  fold min_for zs (min_for z y) \\<in> S\n\ngoal (1 subgoal):\n 1. le (fold min_for zs (min_for z y)) y &&&\n    le (fold min_for zs (min_for z y)) z", "by (auto intro!: trans[of ?f \"min_for z y\"])"], ["proof (state)\nthis:\n  le (fold min_for zs (min_for z y)) y\n  le (fold min_for zs (min_for z y)) z\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]\n 2. \\<And>a ys y.\n       \\<lbrakk>\\<And>y.\n                   set (y # ys) \\<subseteq> S \\<Longrightarrow>\n                   list_all (le (fold min_for ys y)) (y # ys);\n        set (y # a # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> list_all (le (fold min_for (a # ys) y))\n                          (y # a # ys)", "thus ?case"], ["proof (prove)\nusing this:\n  le (fold min_for zs (min_for z y)) y\n  le (fold min_for zs (min_for z y)) z\n\ngoal (1 subgoal):\n 1. list_all (le (fold min_for (z # zs) y)) (y # z # zs)", "using IH[of \"min_for z y\"]"], ["proof (prove)\nusing this:\n  le (fold min_for zs (min_for z y)) y\n  le (fold min_for zs (min_for z y)) z\n  min_for z y \\<in> S \\<Longrightarrow>\n  list_all (le (fold min_for zs (min_for z y))) (min_for z y # zs)\n\ngoal (1 subgoal):\n 1. list_all (le (fold min_for (z # zs) y)) (y # z # zs)", "using Cons.prems"], ["proof (prove)\nusing this:\n  le (fold min_for zs (min_for z y)) y\n  le (fold min_for zs (min_for z y)) z\n  min_for z y \\<in> S \\<Longrightarrow>\n  list_all (le (fold min_for zs (min_for z y))) (min_for z y # zs)\n  set (y # z # zs) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. list_all (le (fold min_for (z # zs) y)) (y # z # zs)", "by auto"], ["proof (state)\nthis:\n  list_all (le (fold min_for (z # zs) y)) (y # z # zs)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       set [y] \\<subseteq> S \\<Longrightarrow>\n       list_all (le (fold min_for [] y)) [y]", "qed (simp add: order_refl)"], ["proof (state)\nthis:\n  list_all (le (fold min_for (tl xs) (hd xs))) xs\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    list_all (le (fold min_for (tl xs) (hd xs))) xs", "qed simp"], ["", "lemma\n  sortedP_selsort:\n  assumes \"set xs \\<subseteq> S\"\n  shows \"sortedP (selsort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sortedP (selsort xs)", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> S\n\ngoal (1 subgoal):\n 1. sortedP (selsort xs)", "proof (induction xs rule: selsort.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> S \\<Longrightarrow> sortedP (selsort [])\n 2. \\<And>y ys.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = fold min_for ys y; xa = remove1 x (y # ys);\n                    set xa \\<subseteq> S\\<rbrakk>\n                   \\<Longrightarrow> sortedP (selsort xa);\n        set (y # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> sortedP (selsort (y # ys))", "case (2 z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = fold min_for zs z; ?xa = remove1 ?x (z # zs);\n   set ?xa \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> sortedP (selsort ?xa)\n  set (z # zs) \\<subseteq> S\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> S \\<Longrightarrow> sortedP (selsort [])\n 2. \\<And>y ys.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = fold min_for ys y; xa = remove1 x (y # ys);\n                    set xa \\<subseteq> S\\<rbrakk>\n                   \\<Longrightarrow> sortedP (selsort xa);\n        set (y # ys) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> sortedP (selsort (y # ys))", "from this fold_min[of \"z#zs\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x = fold min_for zs z; ?xa = remove1 ?x (z # zs);\n   set ?xa \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> sortedP (selsort ?xa)\n  set (z # zs) \\<subseteq> S\n  set (z # zs) \\<subseteq> S \\<Longrightarrow>\n  list_all (le (fold min_for (tl (z # zs)) (hd (z # zs)))) (z # zs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x = fold min_for zs z; ?xa = remove1 ?x (z # zs);\n   set ?xa \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> sortedP (selsort ?xa)\n  set (z # zs) \\<subseteq> S\n  set (z # zs) \\<subseteq> S \\<Longrightarrow>\n  list_all (le (fold min_for (tl (z # zs)) (hd (z # zs)))) (z # zs)\n\ngoal (1 subgoal):\n 1. sortedP (selsort (z # zs))", "by (fastforce simp: list_all_iff Let_def\n        simp del: remove1.simps\n        intro: Cons intro!: 2(1)[OF refl refl]\n        dest!: rev_subsetD[OF _ set_remove1_subset])+"], ["proof (state)\nthis:\n  sortedP (selsort (z # zs))\n\ngoal (1 subgoal):\n 1. set [] \\<subseteq> S \\<Longrightarrow> sortedP (selsort [])", "qed (auto intro!: Nil)"], ["", "end"], ["", "subsection \\<open>Abstract CCW Systems\\<close>"], ["", "locale ccw_system0 =\n  fixes ccw::\"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n    and S::\"'a set\"\nbegin"], ["", "abbreviation \"indelta t p q r \\<equiv> ccw t q r \\<and> ccw p t r \\<and> ccw p q t\""], ["", "abbreviation \"insquare p q r s \\<equiv> ccw p q r \\<and> ccw q r s \\<and> ccw r s p \\<and> ccw s p q\""], ["", "end"], ["", "abbreviation \"distinct3 p q r \\<equiv> \\<not>(p = q \\<or> p = r \\<or> q = r)\""], ["", "abbreviation \"distinct4 p q r s \\<equiv> \\<not>(p = q \\<or> p = r \\<or> p = s \\<or> \\<not> distinct3 q r s)\""], ["", "abbreviation \"distinct5 p q r s t \\<equiv> \\<not>(p = q \\<or> p = r \\<or> p = s \\<or> p = t \\<or> \\<not> distinct4 q r s t)\""], ["", "abbreviation \"in3 S p q r \\<equiv> p \\<in> S \\<and> q \\<in> S \\<and> r \\<in> S\""], ["", "abbreviation \"in4 S p q r s \\<equiv> in3 S p q r \\<and> s \\<in> S\""], ["", "abbreviation \"in5 S p q r s t \\<equiv> in4 S p q r s \\<and> t \\<in> S\""], ["", "locale ccw_system12 = ccw_system0 +\n  assumes cyclic: \"ccw p q r \\<Longrightarrow> ccw q r p\"\n  assumes ccw_antisym: \"distinct3 p q r \\<Longrightarrow> in3 S p q r \\<Longrightarrow> ccw p q r \\<Longrightarrow> \\<not> ccw p r q\""], ["", "locale ccw_system123 = ccw_system12 +\n  assumes nondegenerate: \"distinct3 p q r \\<Longrightarrow> in3 S p q r \\<Longrightarrow> ccw p q r \\<or> ccw p r q\"\nbegin"], ["", "lemma not_ccw_eq: \"distinct3 p q r \\<Longrightarrow> in3 S p q r \\<Longrightarrow> \\<not> ccw p q r \\<longleftrightarrow> ccw p r q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct3 p q r; in3 S p q r\\<rbrakk>\n    \\<Longrightarrow> (\\<not> ccw p q r) = ccw p r q", "using ccw_antisym nondegenerate"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct3 ?p ?q ?r; in3 S ?p ?q ?r; ccw ?p ?q ?r\\<rbrakk>\n  \\<Longrightarrow> \\<not> ccw ?p ?r ?q\n  \\<lbrakk>distinct3 ?p ?q ?r; in3 S ?p ?q ?r\\<rbrakk>\n  \\<Longrightarrow> ccw ?p ?q ?r \\<or> ccw ?p ?r ?q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct3 p q r; in3 S p q r\\<rbrakk>\n    \\<Longrightarrow> (\\<not> ccw p q r) = ccw p r q", "by blast"], ["", "end"], ["", "locale ccw_system4 = ccw_system123 +\n  assumes interior:\n    \"distinct4 p q r t \\<Longrightarrow> in4 S p q r t \\<Longrightarrow> ccw t q r \\<Longrightarrow> ccw p t r \\<Longrightarrow> ccw p q t \\<Longrightarrow> ccw p q r\"\nbegin"], ["", "lemma interior':\n  \"distinct4 p q r t \\<Longrightarrow> in4 S p q r t \\<Longrightarrow> ccw p q t \\<Longrightarrow> ccw q r t \\<Longrightarrow> ccw r p t \\<Longrightarrow> ccw p q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct4 p q r t; in4 S p q r t; ccw p q t; ccw q r t;\n     ccw r p t\\<rbrakk>\n    \\<Longrightarrow> ccw p q r", "by (metis ccw_antisym cyclic interior nondegenerate)"], ["", "end"], ["", "locale ccw_system1235' = ccw_system123 +\n  assumes dual_transitive:\n    \"distinct5 p q r s t \\<Longrightarrow> in5 S p q r s t \\<Longrightarrow>\n      ccw s t p \\<Longrightarrow> ccw s t q \\<Longrightarrow> ccw s t r \\<Longrightarrow> ccw t p q \\<Longrightarrow> ccw t q r \\<Longrightarrow> ccw t p r\""], ["", "locale ccw_system1235 = ccw_system123 +\n  assumes transitive: \"distinct5 p q r s t \\<Longrightarrow> in5 S p q r s t \\<Longrightarrow>\n    ccw t s p \\<Longrightarrow> ccw t s q \\<Longrightarrow> ccw t s r \\<Longrightarrow> ccw t p q \\<Longrightarrow> ccw t q r \\<Longrightarrow> ccw t p r\"\nbegin"], ["", "lemmas ccw_axioms = cyclic nondegenerate ccw_antisym transitive"], ["", "sublocale ccw_system1235'"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw_system1235' ccw S", "proof (unfold_locales, rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r s t.\n       \\<lbrakk>distinct5 p q r s t; in5 S p q r s t; ccw s t p; ccw s t q;\n        ccw s t r; ccw t p q; ccw t q r; \\<not> ccw t p r\\<rbrakk>\n       \\<Longrightarrow> False", "case prems: (1 p q r s t)"], ["proof (state)\nthis:\n  distinct5 p q r s t\n  in5 S p q r s t\n  ccw s t p\n  ccw s t q\n  ccw s t r\n  ccw t p q\n  ccw t q r\n  \\<not> ccw t p r\n\ngoal (1 subgoal):\n 1. \\<And>p q r s t.\n       \\<lbrakk>distinct5 p q r s t; in5 S p q r s t; ccw s t p; ccw s t q;\n        ccw s t r; ccw t p q; ccw t q r; \\<not> ccw t p r\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"ccw s p q \\<Longrightarrow> ccw s r p\""], ["proof (prove)\nusing this:\n  distinct5 p q r s t\n  in5 S p q r s t\n  ccw s t p\n  ccw s t q\n  ccw s t r\n  ccw t p q\n  ccw t q r\n  \\<not> ccw t p r\n\ngoal (1 subgoal):\n 1. ccw s p q \\<Longrightarrow> ccw s r p", "by (metis ccw_axioms prems)"], ["proof (state)\nthis:\n  ccw s p q \\<Longrightarrow> ccw s r p\n\ngoal (1 subgoal):\n 1. \\<And>p q r s t.\n       \\<lbrakk>distinct5 p q r s t; in5 S p q r s t; ccw s t p; ccw s t q;\n        ccw s t r; ccw t p q; ccw t q r; \\<not> ccw t p r\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ccw s p q \\<Longrightarrow> ccw s r p\n\ngoal (1 subgoal):\n 1. \\<And>p q r s t.\n       \\<lbrakk>distinct5 p q r s t; in5 S p q r s t; ccw s t p; ccw s t q;\n        ccw s t r; ccw t p q; ccw t q r; \\<not> ccw t p r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"ccw s r p \\<Longrightarrow> ccw s q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw s r p \\<Longrightarrow> ccw s q r", "by (metis ccw_axioms prems)"], ["proof (state)\nthis:\n  ccw s r p \\<Longrightarrow> ccw s q r\n\ngoal (1 subgoal):\n 1. \\<And>p q r s t.\n       \\<lbrakk>distinct5 p q r s t; in5 S p q r s t; ccw s t p; ccw s t q;\n        ccw s t r; ccw t p q; ccw t q r; \\<not> ccw t p r\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ccw s r p \\<Longrightarrow> ccw s q r\n\ngoal (1 subgoal):\n 1. \\<And>p q r s t.\n       \\<lbrakk>distinct5 p q r s t; in5 S p q r s t; ccw s t p; ccw s t q;\n        ccw s t r; ccw t p q; ccw t q r; \\<not> ccw t p r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"ccw s q r \\<Longrightarrow> ccw s p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw s q r \\<Longrightarrow> ccw s p q", "by (metis ccw_axioms prems)"], ["proof (state)\nthis:\n  ccw s q r \\<Longrightarrow> ccw s p q\n\ngoal (1 subgoal):\n 1. \\<And>p q r s t.\n       \\<lbrakk>distinct5 p q r s t; in5 S p q r s t; ccw s t p; ccw s t q;\n        ccw s t r; ccw t p q; ccw t q r; \\<not> ccw t p r\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ccw s p q \\<Longrightarrow> ccw s r p\n  ccw s r p \\<Longrightarrow> ccw s q r\n  ccw s q r \\<Longrightarrow> ccw s p q", "have \"ccw s p q \\<and> ccw s r p \\<and> ccw s q r \\<or> ccw s q p \\<and> ccw s p r \\<and> ccw s r q\""], ["proof (prove)\nusing this:\n  ccw s p q \\<Longrightarrow> ccw s r p\n  ccw s r p \\<Longrightarrow> ccw s q r\n  ccw s q r \\<Longrightarrow> ccw s p q\n\ngoal (1 subgoal):\n 1. ccw s p q \\<and> ccw s r p \\<and> ccw s q r \\<or>\n    ccw s q p \\<and> ccw s p r \\<and> ccw s r q", "by (metis ccw_axioms prems)"], ["proof (state)\nthis:\n  ccw s p q \\<and> ccw s r p \\<and> ccw s q r \\<or>\n  ccw s q p \\<and> ccw s p r \\<and> ccw s r q\n\ngoal (1 subgoal):\n 1. \\<And>p q r s t.\n       \\<lbrakk>distinct5 p q r s t; in5 S p q r s t; ccw s t p; ccw s t q;\n        ccw s t r; ccw t p q; ccw t q r; \\<not> ccw t p r\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ccw s p q \\<and> ccw s r p \\<and> ccw s q r \\<or>\n  ccw s q p \\<and> ccw s p r \\<and> ccw s r q\n\ngoal (1 subgoal):\n 1. False", "by (metis ccw_axioms prems)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale ccw_system = ccw_system1235 + ccw_system4"], ["", "end"]]}