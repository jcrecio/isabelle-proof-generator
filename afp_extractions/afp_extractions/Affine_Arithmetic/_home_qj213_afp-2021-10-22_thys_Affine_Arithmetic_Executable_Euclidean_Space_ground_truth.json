{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Executable_Euclidean_Space.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma length_Basis_list:\n  \"length Basis_list = card Basis\"", "lemma eucl_truncate_down_zero[simp]: \"eucl_truncate_down p 0 = 0\"", "lemma eucl_truncate_up_zero[simp]: \"eucl_truncate_up p 0 = 0\"", "lemma eucl_truncate_down_Basis[simp]:\n  \"i \\<in> Basis \\<Longrightarrow> eucl_truncate_down e x \\<bullet> i = truncate_down e (x \\<bullet> i)\"", "lemma eucl_truncate_down_correct:\n  \"dist (x::'a::executable_euclidean_space) (eucl_down e x) \\<in>\n    {0..sqrt (DIM('a)) * 2 powr of_int (- e)}\"", "lemma eucl_down: \"eucl_down e (x::'a::executable_euclidean_space) \\<le> x\"", "lemma eucl_truncate_down: \"eucl_truncate_down e (x::'a::executable_euclidean_space) \\<le> x\"", "lemma eucl_truncate_down_le:\n  \"x \\<le> y \\<Longrightarrow> eucl_truncate_down w x \\<le> (y::'a::executable_euclidean_space)\"", "lemma eucl_truncate_up_Basis[simp]: \"i \\<in> Basis \\<Longrightarrow> eucl_truncate_up e x \\<bullet> i = truncate_up e (x \\<bullet> i)\"", "lemma eucl_truncate_up: \"x \\<le> eucl_truncate_up e (x::'a::executable_euclidean_space)\"", "lemma eucl_truncate_up_le: \"x \\<le> y \\<Longrightarrow> x \\<le> eucl_truncate_up e (y::'a::executable_euclidean_space)\"", "lemma eucl_truncate_down_mono:\n  fixes x::\"'a::executable_euclidean_space\"\n  shows \"x \\<le> y \\<Longrightarrow> eucl_truncate_down p x \\<le> eucl_truncate_down p y\"", "lemma eucl_truncate_up_mono:\n  fixes x::\"'a::executable_euclidean_space\"\n  shows \"x \\<le> y \\<Longrightarrow> eucl_truncate_up p x \\<le> eucl_truncate_up p y\"", "lemma infnorm[code]:\n  fixes x::\"'a::executable_euclidean_space\"\n  shows \"infnorm x = fold max (map (\\<lambda>i. abs (x \\<bullet> i)) Basis_list) 0\"", "lemma nth_Basis_list_in_Basis[simp]:\n  \"n < length (Basis_list::'a::executable_euclidean_space list) \\<Longrightarrow> Basis_list ! n \\<in> (Basis::'a set)\"", "lemma nth_eq_iff_index:\n  \"distinct xs \\<Longrightarrow> n < length xs \\<Longrightarrow> xs ! n = i \\<longleftrightarrow> n = index xs i\"", "lemma in_Basis_index_Basis_list: \"i \\<in> Basis \\<Longrightarrow> i = Basis_list ! index Basis_list i\"", "lemmas [simp] = length_Basis_list", "lemma sum_Basis_sum_nth_Basis_list:\n  \"(\\<Sum>i\\<in>Basis. f i) = (\\<Sum>i<DIM('a::executable_euclidean_space). f ((Basis_list::'a list) ! i))\"", "lemma eucl_of_list_nth:\n  assumes \"length xs = DIM('a)\"\n  shows \"eucl_of_list xs = (\\<Sum>i<DIM('a::executable_euclidean_space). (xs ! i) *\\<^sub>R ((Basis_list::'a list) ! i))\"", "lemma eucl_of_list_inner:\n  fixes i::\"'a::executable_euclidean_space\"\n  assumes i: \"i \\<in> Basis\"\n  assumes l: \"length xs = DIM('a)\"\n  shows \"eucl_of_list xs \\<bullet> i = xs ! (index Basis_list i)\"", "lemma inner_eucl_of_list:\n  fixes i::\"'a::executable_euclidean_space\"\n  assumes i: \"i \\<in> Basis\"\n  assumes l: \"length xs = DIM('a)\"\n  shows \"i \\<bullet> eucl_of_list xs = xs ! (index Basis_list i)\"", "lemma index_Basis_list_nth[simp]:\n  \"i < DIM('a::executable_euclidean_space) \\<Longrightarrow> index Basis_list ((Basis_list::'a list) ! i) = i\"", "lemma list_of_eucl_eucl_of_list[simp]:\n  \"length xs = DIM('a::executable_euclidean_space) \\<Longrightarrow> list_of_eucl (eucl_of_list xs::'a) = xs\"", "lemma eucl_of_list_list_of_eucl[simp]:\n  \"eucl_of_list (list_of_eucl x) = x\"", "lemma length_list_of_eucl[simp]: \"length (list_of_eucl (x::'a::executable_euclidean_space)) = DIM('a)\"", "lemma list_of_eucl_nth[simp]: \"n < DIM('a::executable_euclidean_space) \\<Longrightarrow> list_of_eucl x ! n = x \\<bullet> (Basis_list ! n::'a)\"", "lemma nth_ge_len: \"n \\<ge> length xs \\<Longrightarrow> xs ! n = [] ! (n - length xs)\"", "lemma list_of_eucl_nth_if: \"list_of_eucl x ! n = (if n < DIM('a::executable_euclidean_space) then x \\<bullet> (Basis_list ! n::'a) else [] ! (n - DIM('a)))\"", "lemma list_of_eucl_eq_iff:\n  \"list_of_eucl (x::'a::executable_euclidean_space) = list_of_eucl (y::'b::executable_euclidean_space) \\<longleftrightarrow>\n  (DIM('a) = DIM('b) \\<and> (\\<forall>i < DIM('b). x \\<bullet> Basis_list ! i = y \\<bullet> Basis_list ! i))\"", "lemma eucl_le_Basis_list_iff:\n  \"(x::'a::executable_euclidean_space) \\<le> y \\<longleftrightarrow>\n  (\\<forall>i<DIM('a). x \\<bullet> Basis_list ! i \\<le> y \\<bullet> Basis_list ! i)\"", "lemma eucl_of_list_inj: \"length xs = DIM('a::executable_euclidean_space) \\<Longrightarrow> length ys = DIM('a) \\<Longrightarrow>\n  (eucl_of_list xs::'a) = eucl_of_list (ys) \\<Longrightarrow> xs = ys\"", "lemma eucl_of_list_map_plus[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. f x + g x) xs)::'a) =\n    eucl_of_list (map f xs) + eucl_of_list (map g xs)\"", "lemma eucl_of_list_map_uminus[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. - f x) xs)::'a) = - eucl_of_list (map f xs)\"", "lemma eucl_of_list_map_mult_left[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. r * f x) xs)::'a) = r *\\<^sub>R eucl_of_list (map f xs)\"", "lemma eucl_of_list_map_mult_right[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. f x * r) xs)::'a) = r *\\<^sub>R eucl_of_list (map f xs)\"", "lemma eucl_of_list_map_divide_right[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. f x / r) xs)::'a) = eucl_of_list (map f xs) /\\<^sub>R r\"", "lemma eucl_of_list_map_const[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. c) xs)::'a) = c *\\<^sub>R One\"", "lemma replicate_eq_list_of_eucl_zero: \"replicate DIM('a::executable_euclidean_space) 0 = list_of_eucl (0::'a)\"", "lemma eucl_of_list_append_zeroes[simp]: \"eucl_of_list (xs @ replicate n 0) = eucl_of_list xs\"", "lemma Basis_prodD:\n  assumes \"(i, j) \\<in> Basis\"\n  shows \"i \\<in> Basis \\<and> j = 0 \\<or> i = 0 \\<and> j \\<in> Basis\"", "lemma eucl_of_list_take_DIM[simp]:\n  assumes \"d = DIM('b::executable_euclidean_space)\"\n  shows \"(eucl_of_list (take d xs)::'b) = (eucl_of_list xs)\"", "lemma eucl_of_list_eqI:\n  assumes \"take DIM('a) (xs @ replicate (DIM('a) - length xs) 0) =\n    take DIM('a) (ys @ replicate (DIM('a) - length ys) 0)\"\n  shows \"eucl_of_list xs = (eucl_of_list ys::'a::executable_euclidean_space)\"", "lemma eucl_of_list_replicate_zero[simp]: \"eucl_of_list (replicate E 0) = 0\"", "lemma eucl_of_list_Nil[simp]: \"eucl_of_list [] = 0\"", "lemma fst_eucl_of_list_prod:\n  shows \"fst (eucl_of_list xs::'b::executable_euclidean_space  \\<times> _) = (eucl_of_list (take DIM('b) xs)::'b)\"", "lemma index_zip_replicate1[simp]: \"index (zip (replicate d a) bs) (a, b) = index bs b\"\n  if \"d = length bs\"", "lemma index_zip_replicate2[simp]: \"index (zip as (replicate d b)) (a, b) = index as a\"\n  if \"d = length as\"", "lemma index_Basis_list_prod[simp]:\n  fixes a::\"'a::executable_euclidean_space\" and b::\"'b::executable_euclidean_space\"\n  shows \"a \\<in> Basis \\<Longrightarrow> index Basis_list (a, 0::'b) = index Basis_list a\"\n    \"b \\<in> Basis \\<Longrightarrow> index Basis_list (0::'a, b) = DIM('a) + index Basis_list b\"", "lemma eucl_of_list_eq_takeI:\n  assumes \"(eucl_of_list (take DIM('a::executable_euclidean_space) xs)::'a) = x\"\n  shows \"eucl_of_list xs = x\"", "lemma eucl_of_list_inner_le:\n  fixes i::\"'a::executable_euclidean_space\"\n  assumes i: \"i \\<in> Basis\"\n  assumes l: \"length xs \\<ge> DIM('a)\"\n  shows \"eucl_of_list xs \\<bullet> i = xs ! (index Basis_list i)\"", "lemma eucl_of_list_prod_if:\n  assumes \"length xs = DIM('a::executable_euclidean_space) + DIM('b::executable_euclidean_space)\"\n  shows \"eucl_of_list xs =\n    (eucl_of_list (take DIM('a) xs)::'a, eucl_of_list (drop DIM('a) xs)::'b)\"", "lemma snd_eucl_of_list_prod:\n  shows \"snd (eucl_of_list xs::'b::executable_euclidean_space  \\<times> 'c::executable_euclidean_space) =\n    (eucl_of_list (drop DIM('b) xs)::'c)\"", "lemma eucl_of_list_prod:\n  shows \"eucl_of_list xs = (eucl_of_list (take DIM('b) xs)::'b::executable_euclidean_space,\n    eucl_of_list (drop DIM('b) xs)::'c::executable_euclidean_space)\"", "lemma eucl_of_list_real[simp]: \"eucl_of_list [x] = (x::real)\"", "lemma eucl_of_list_append[simp]:\n  assumes \"length xs = DIM('i::executable_euclidean_space)\"\n  assumes \"length ys = DIM('j::executable_euclidean_space)\"\n  shows \"eucl_of_list (xs @ ys) = (eucl_of_list xs::'i, eucl_of_list ys::'j)\"", "lemma list_allI: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> P x) \\<Longrightarrow> list_all P xs\"", "lemma\n  concat_map_nthI:\n  assumes \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set (f x) \\<Longrightarrow> P y\"\n  assumes \"j < length (concat (map f xs))\"\n  shows \"P (concat (map f xs) ! j)\"", "lemma map_nth_append1:\n  assumes \"length xs = d\"\n  shows \"map ((!) (xs @ ys)) [0..<d] = xs\"", "lemma map_nth_append2:\n  assumes \"length ys = d\"\n  shows \"map ((!) (xs @ ys)) [length xs..<length xs + d] = ys\"", "lemma length_map2 [simp]: \"length (map2 f xs ys) = min (length xs) (length ys)\"", "lemma map2_nth [simp]: \"map2 f xs ys ! n = f (xs ! n) (ys ! n)\"\n  if \"n < length xs\" \"n < length ys\"", "lemma list_of_eucl_add: \"list_of_eucl (x + y) = map2 (+) (list_of_eucl x) (list_of_eucl y)\"", "lemma list_of_eucl_inj:\n  \"list_of_eucl z = list_of_eucl y \\<Longrightarrow> y = z\"", "lemma length_Basis_list_pos[simp]: \"length Basis_list > 0\"", "lemma Basis_list_nth_nonzero:\n  \"i < length (Basis_list::'a::executable_euclidean_space list) \\<Longrightarrow> (Basis_list::'a list) ! i \\<noteq> 0\"", "lemma nth_Basis_list_prod:\n  \"i < DIM('a) + DIM('b) \\<Longrightarrow> (Basis_list::('a::executable_euclidean_space \\<times> 'b::executable_euclidean_space) list) ! i =\n    (if i < DIM('a) then (Basis_list ! i, 0) else (0, Basis_list ! (i - DIM('a))))\"", "lemma eucl_of_list_if:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\" \"distinct xs\"\n  shows \"eucl_of_list (map (\\<lambda>xa. if xa = x then 1 else 0) (xs::nat list)) =\n    (if x \\<in> set xs then Basis_list ! index xs x else 0::'a)\"", "lemma take_append_take_minus_idem: \"take n XS @ map ((!) XS) [n..<length XS] = XS\"", "lemma sum_list_Basis_list[simp]: \"sum_list (map f Basis_list) = (\\<Sum>b\\<in>Basis. f b)\"", "lemma hd_Basis_list[simp]: \"hd Basis_list \\<in> Basis\"", "lemma eucl_of_list_inner_eq: \"(eucl_of_list xs::'a) \\<bullet> eucl_of_list ys = inner_lv_rel xs ys\"\n  if \"length xs = DIM('a::executable_euclidean_space)\" \"length ys = DIM('a)\"", "lemma euclidean_vec_componentwise:\n  \"(\\<Sum>(xa::'a::euclidean_space^'b::finite)\\<in>Basis. f xa) = (\\<Sum>a\\<in>Basis. (\\<Sum>b::'b\\<in>UNIV. f (axis b a)))\"", "lemma vec_nth_inner_scaleR_craziness:\n  \"f (x $ i \\<bullet> j) *\\<^sub>R j = (\\<Sum>xa\\<in>UNIV. f (x $ xa \\<bullet> j) *\\<^sub>R axis xa j) $ i\"", "lemma concat_same_lengths_nth:\n  assumes \"\\<And>xs. xs \\<in> set XS \\<Longrightarrow> length xs = N\"\n  assumes \"i < length XS * N\" \"N > 0\"\n  shows \"concat XS ! i = XS ! (i div N) ! (i mod N)\"", "lemma concat_map_map_index:\n  shows \"concat (map (\\<lambda>n. map (f n) xs) ys) =\n    map (\\<lambda>i. f (ys ! (i div length xs)) (xs ! (i mod length xs))) [0..<length xs * length ys]\"", "lemma\n  sum_list_zip_map:\n  assumes \"distinct xs\"\n  shows \"(\\<Sum>(x, y)\\<leftarrow>zip xs (map g xs). f x y) = (\\<Sum>x\\<in>set xs. f x (g x))\"", "lemma\n  sum_list_zip_map_of:\n  assumes \"distinct bs\"\n  assumes \"length xs = length bs\"\n  shows \"(\\<Sum>(x, y)\\<leftarrow>zip xs bs. f x y) = (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)\"", "lemma vec_nth_matrix:\n  \"vec_nth (vec_nth (matrix y) i) j = vec_nth (y (axis j 1)) i\"", "lemma matrix_eqI:\n  assumes \"\\<And>x. x \\<in> Basis \\<Longrightarrow> A *v x = B *v x\"\n  shows \"(A::real^'n^'n) = B\"", "lemma matrix_columnI:\n  assumes \"\\<And>i. column i A = column i B\"\n  shows \"(A::real^'n^'n) = B\"", "lemma\n  vec_nth_Basis:\n  fixes x::\"real^'n\"\n  shows \"x \\<in> Basis \\<Longrightarrow> vec_nth x i = (if x = axis i 1 then 1 else 0)\"", "lemma vec_nth_eucl_of_list_eq: \"length M = CARD('n) \\<Longrightarrow>\n  vec_nth (eucl_of_list M::real^'n::enum) i = M ! index Basis_list (axis i (1::real))\"", "lemma index_Basis_list_axis1: \"index Basis_list (axis i (1::real)) = index enum_class.enum i\"", "lemma vec_nth_eq_list_of_eucl1:\n  \"(vec_nth (M::real^'n::enum) i) = list_of_eucl M ! (index enum_class.enum i)\"", "lemma enum_3[simp]: \"(enum_class.enum::3 list) = [0, 1, 2]\"", "lemma three_eq_zero: \"(3::3) = 0\"", "lemma forall_3': \"(\\<forall>i::3. P i) \\<longleftrightarrow> P 0 \\<and> P 1 \\<and> P 2\"", "lemma euclidean_eq_list_of_euclI: \"x = y\" if \"list_of_eucl x = list_of_eucl y\"", "lemma axis_one_neq_zero[simp]: \"axis xa (1::'a::zero_neq_one) \\<noteq> 0\"", "lemma eucl_of_list_vec_nth3[simp]:\n  \"(eucl_of_list [g, h, i]::real^3) $ 0 = g\"\n  \"(eucl_of_list [g, h, i]::real^3) $ 1 = h\"\n  \"(eucl_of_list [g, h, i]::real^3) $ 2 = i\"\n  \"(eucl_of_list [g, h, i]::real^3) $ 3 = g\"", "lemma Basis_list_R3: \"Basis_list = [(1,0,0), (0, 1, 0), (0, 0, 1)::R3]\"", "lemma Basis_list_vec3: \"Basis_list = [axis 0 1::real^3, axis 1 1, axis 2 1]\"", "lemma eucl_of_list3[simp]: \"eucl_of_list [a, b, c] = (a, b, c)\"", "lemma bounded_linear_via_derivative:\n  fixes f::\"'a::real_normed_vector \\<Rightarrow> 'b::euclidean_space \\<Rightarrow>\\<^sub>L 'c::real_normed_vector\" \\<comment> \\<open>TODO: generalize?\\<close>\n  assumes \"\\<And>i. ((\\<lambda>x. blinfun_apply (f x) i) has_derivative (\\<lambda>x. f' y x i)) (at y)\"\n  shows \"bounded_linear (f' y x)\"", "lemma blinfun_scaleR_transfer[transfer_rule]:\n  \"rel_fun (pcr_blinfun (=) (=)) (rel_fun (=) (pcr_blinfun (=) (=)))\n    (\\<lambda>a b c. a c *\\<^sub>R b) blinfun_scaleR\"", "lemma blinfun_scaleR_rep_eq[simp]:\n  \"blinfun_scaleR a b c = a c *\\<^sub>R b\"", "lemma bounded_linear_blinfun_scaleR: \"bounded_linear (blinfun_scaleR a)\"", "lemma blinfun_scaleR_has_derivative[derivative_intros]:\n  assumes \"(f has_derivative f') (at x within s)\"\n  shows \"((\\<lambda>x. blinfun_scaleR a (f x)) has_derivative (\\<lambda>x. blinfun_scaleR a (f' x))) (at x within s)\"", "lemma blinfun_componentwise:\n  fixes f::\"'a::real_normed_vector \\<Rightarrow> 'b::euclidean_space \\<Rightarrow>\\<^sub>L 'c::real_normed_vector\"\n  shows \"f = (\\<lambda>x. \\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f x i))\"", "lemma\n  blinfun_has_derivative_componentwiseI:\n  fixes f::\"'a::real_normed_vector \\<Rightarrow> 'b::euclidean_space \\<Rightarrow>\\<^sub>L 'c::real_normed_vector\"\n  assumes \"\\<And>i. i \\<in> Basis \\<Longrightarrow> ((\\<lambda>x. f x i) has_derivative blinfun_apply (f' i)) (at x)\"\n  shows \"(f has_derivative (\\<lambda>x. \\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f' i x))) (at x)\"", "lemma\n  has_derivative_BlinfunI:\n  fixes f::\"'a::real_normed_vector \\<Rightarrow> 'b::euclidean_space \\<Rightarrow>\\<^sub>L 'c::real_normed_vector\"\n  assumes \"\\<And>i. ((\\<lambda>x. f x i) has_derivative (\\<lambda>x. f' y x i)) (at y)\"\n  shows \"(f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)\"", "lemma\n  has_derivative_Blinfun:\n  assumes \"(f has_derivative f') F\"\n  shows \"(f has_derivative Blinfun f') F\"", "lemma flip_blinfun_apply[simp]: \"flip_blinfun f a b = f b a\"", "lemma le_norm_blinfun:\n  shows \"norm (blinfun_apply f x) / norm x \\<le> norm f\"", "lemma norm_flip_blinfun[simp]: \"norm (flip_blinfun x) = norm x\" (is \"?l = ?r\")", "lemma bounded_linear_flip_blinfun[bounded_linear]: \"bounded_linear flip_blinfun\"", "lemma dist_swap2_swap2[simp]: \"dist (flip_blinfun f) (flip_blinfun g) = dist f g\"", "lemma matrix_blinfun_of_vmatrix[simp]: \"matrix (blinfun_of_vmatrix M) = M\"", "lemma blinfun_apply_componentwise:\n  \"B = (\\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (blinfun_apply B i))\"", "lemma blinfun_apply_eq_sum:\n  assumes [simp]: \"length v = CARD('n)\"\n  shows \"blinfun_apply (B::(real^'n::enum)\\<Rightarrow>\\<^sub>L(real^'m::enum)) (eucl_of_list v) =\n    (\\<Sum>i<CARD('m). \\<Sum>j<CARD('n). ((B (Basis_list ! j) \\<bullet> Basis_list ! i) * v ! j) *\\<^sub>R (Basis_list ! i))\"", "lemma in_square_lemma[intro, simp]: \"x * C + y < D * C\" if \"x < D\" \"y < C\" for x::nat", "lemma less_square_imp_div_less[intro, simp]: \"i < E * D \\<Longrightarrow>  i div E < D\" for i::nat", "lemma in_square_lemma'[intro, simp]: \"i < L \\<Longrightarrow> n < N \\<Longrightarrow> i * N + n < N * L\" for i n::nat", "lemma\n  distinct_nth_eq_iff:\n  \"distinct xs \\<Longrightarrow> x < length xs \\<Longrightarrow> y < length xs \\<Longrightarrow> xs ! x = xs ! y \\<longleftrightarrow> x = y\"", "lemma index_Basis_list_axis2:\n  \"index Basis_list (axis (j::'j::enum) (axis (i::'i::enum) (1::real))) =\n    (index enum_class.enum j) * CARD('i) + index enum_class.enum i\"", "lemma\n  vec_nth_Basis2:\n  fixes x::\"real^'n^'m\"\n  shows \"x \\<in> Basis \\<Longrightarrow> vec_nth (vec_nth x i) j = ((if x = axis i (axis j 1) then 1 else 0))\"", "lemma vec_nth_eucl_of_list_eq2: \"length M = CARD('n) * CARD('m) \\<Longrightarrow>\n  vec_nth (vec_nth (eucl_of_list M::real^'n::enum^'m::enum) i) j = M ! index Basis_list (axis i (axis j (1::real)))\"", "lemma vec_nth_eq_list_of_eucl2:\n  \"vec_nth (vec_nth (M::real^'n::enum^'m::enum) i) j =\n    list_of_eucl M ! (index enum_class.enum i * CARD('n) + index enum_class.enum j)\"", "theorem\n  eucl_of_list_matrix_vector_mult_eq_sum_nth_Basis_list:\n  assumes \"length M = CARD('n) * CARD('m)\"\n  assumes \"length v = CARD('n)\"\n  shows \"(eucl_of_list M::real^'n::enum^'m::enum) *v eucl_of_list v =\n    (\\<Sum>i<CARD('m).\n      (\\<Sum>j<CARD('n). M ! (i * CARD('n) + j) * v ! j) *\\<^sub>R Basis_list ! i)\"", "lemma index_enum_less[intro, simp]: \"index enum_class.enum (i::'n::enum) < CARD('n)\"", "lemmas [intro, simp] = enum_distinct", "lemmas [simp] = card_UNIV_length_enum[symmetric] enum_UNIV", "lemma sum_index_enum_eq:\n  \"(\\<Sum>(k::'n::enum)\\<in>UNIV. f (index enum_class.enum k)) = (\\<Sum>i<CARD('n). f i)\""], "translations": [["", "lemma length_Basis_list:\n  \"length Basis_list = card Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Basis_list = DIM('a)", "by (metis Basis_list distinct_Basis_list distinct_card)"], ["", "end"], ["", "lemma eucl_truncate_down_zero[simp]: \"eucl_truncate_down p 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_truncate_down p (0::'a) = (0::'a)", "by (auto simp: eucl_truncate_down_def truncate_down_zero)"], ["", "lemma eucl_truncate_up_zero[simp]: \"eucl_truncate_up p 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_truncate_up p (0::'a) = (0::'a)", "by (auto simp: eucl_truncate_up_def)"], ["", "subsection \\<open>Instantiations\\<close>"], ["", "instantiation real::executable_euclidean_space\nbegin"], ["", "definition Basis_list_real :: \"real list\" where\n  \"Basis_list_real = [1]\""], ["", "definition \"eucl_down prec b = round_down prec b\""], ["", "definition \"eucl_truncate_down prec b = truncate_down prec b\""], ["", "definition \"eucl_truncate_up prec b = truncate_up prec b\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real, executable_euclidean_space_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p b.\n       eucl_down p b =\n       (\\<Sum>i\\<in>Basis. round_down p (b \\<bullet> i) *\\<^sub>R i)\n 2. \\<And>q b.\n       eucl_truncate_down q b =\n       (\\<Sum>i\\<in>Basis. truncate_down q (b \\<bullet> i) *\\<^sub>R i)\n 3. \\<And>q b.\n       eucl_truncate_up q b =\n       (\\<Sum>i\\<in>Basis. truncate_up q (b \\<bullet> i) *\\<^sub>R i)\n 4. set Basis_list = Basis\n 5. distinct Basis_list", "qed (auto simp: Basis_list_real_def eucl_down_real_def eucl_truncate_down_real_def\n  eucl_truncate_up_real_def)"], ["", "end"], ["", "instantiation prod::(executable_euclidean_space, executable_euclidean_space)\n  executable_euclidean_space\nbegin"], ["", "definition Basis_list_prod :: \"('a \\<times> 'b) list\" where\n  \"Basis_list_prod =\n    zip Basis_list (replicate (length (Basis_list::'a list)) 0) @\n    zip (replicate (length (Basis_list::'b list)) 0) Basis_list\""], ["", "definition \"eucl_down p a = (eucl_down p (fst a), eucl_down p (snd a))\""], ["", "definition \"eucl_truncate_down p a = (eucl_truncate_down p (fst a), eucl_truncate_down p (snd a))\""], ["", "definition \"eucl_truncate_up p a = (eucl_truncate_up p (fst a), eucl_truncate_up p (snd a))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, executable_euclidean_space_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p b.\n       eucl_down p b =\n       (\\<Sum>i\\<in>Basis. round_down p (b \\<bullet> i) *\\<^sub>R i)\n 2. \\<And>q b.\n       eucl_truncate_down q b =\n       (\\<Sum>i\\<in>Basis. truncate_down q (b \\<bullet> i) *\\<^sub>R i)\n 3. \\<And>q b.\n       eucl_truncate_up q b =\n       (\\<Sum>i\\<in>Basis. truncate_up q (b \\<bullet> i) *\\<^sub>R i)\n 4. set Basis_list = Basis\n 5. distinct Basis_list", "show \"set Basis_list = (Basis::('a*'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set Basis_list = Basis", "by (auto simp: Basis_list_prod_def Basis_prod_def elim!: in_set_zipE)\n      (auto simp: Basis_list[symmetric] in_set_zip in_set_conv_nth simp del: Basis_list)"], ["proof (state)\nthis:\n  set Basis_list = Basis\n\ngoal (4 subgoals):\n 1. \\<And>p b.\n       eucl_down p b =\n       (\\<Sum>i\\<in>Basis. round_down p (b \\<bullet> i) *\\<^sub>R i)\n 2. \\<And>q b.\n       eucl_truncate_down q b =\n       (\\<Sum>i\\<in>Basis. truncate_down q (b \\<bullet> i) *\\<^sub>R i)\n 3. \\<And>q b.\n       eucl_truncate_up q b =\n       (\\<Sum>i\\<in>Basis. truncate_up q (b \\<bullet> i) *\\<^sub>R i)\n 4. distinct Basis_list", "show \"distinct (Basis_list::('a*'b)list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct Basis_list", "using distinct_Basis_list[where 'a='a] distinct_Basis_list[where 'a='b]"], ["proof (prove)\nusing this:\n  distinct Basis_list\n  distinct Basis_list\n\ngoal (1 subgoal):\n 1. distinct Basis_list", "by (auto simp: Basis_list_prod_def Basis_list intro: distinct_zipI1 distinct_zipI2\n      elim!: in_set_zipE)"], ["proof (state)\nthis:\n  distinct Basis_list\n\ngoal (3 subgoals):\n 1. \\<And>p b.\n       eucl_down p b =\n       (\\<Sum>i\\<in>Basis. round_down p (b \\<bullet> i) *\\<^sub>R i)\n 2. \\<And>q b.\n       eucl_truncate_down q b =\n       (\\<Sum>i\\<in>Basis. truncate_down q (b \\<bullet> i) *\\<^sub>R i)\n 3. \\<And>q b.\n       eucl_truncate_up q b =\n       (\\<Sum>i\\<in>Basis. truncate_up q (b \\<bullet> i) *\\<^sub>R i)", "qed\n  (auto simp: eucl_down_prod_def eucl_truncate_down_prod_def eucl_truncate_up_prod_def\n    sum_Basis_prod_eq inner_add_left inner_sum_left inner_Basis eucl_down_def\n    eucl_truncate_down_def eucl_truncate_up_def\n    intro!: euclidean_eqI[where 'a=\"'a*'b\"])"], ["", "end"], ["", "lemma eucl_truncate_down_Basis[simp]:\n  \"i \\<in> Basis \\<Longrightarrow> eucl_truncate_down e x \\<bullet> i = truncate_down e (x \\<bullet> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> Basis \\<Longrightarrow>\n    eucl_truncate_down e x \\<bullet> i = truncate_down e (x \\<bullet> i)", "by (simp add: eucl_truncate_down_def)"], ["", "lemma eucl_truncate_down_correct:\n  \"dist (x::'a::executable_euclidean_space) (eucl_down e x) \\<in>\n    {0..sqrt (DIM('a)) * 2 powr of_int (- e)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (eucl_down e x)\n    \\<in> {0..sqrt (real DIM('a)) * 2 powr real_of_int (- e)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist x (eucl_down e x)\n    \\<in> {0..sqrt (real DIM('a)) * 2 powr real_of_int (- e)}", "have \"dist x (eucl_down e x) = sqrt (\\<Sum>i\\<in>Basis. (dist (x \\<bullet> i) (eucl_down e x \\<bullet> i))\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (eucl_down e x) =\n    sqrt\n     (\\<Sum>i\\<in>Basis.\n        (dist (x \\<bullet> i) (eucl_down e x \\<bullet> i))\\<^sup>2)", "unfolding euclidean_dist_l2[where 'a='a] L2_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Sum>i\\<in>Basis.\n        (dist (x \\<bullet> i) (eucl_down e x \\<bullet> i))\\<^sup>2) =\n    sqrt\n     (\\<Sum>i\\<in>Basis.\n        (dist (x \\<bullet> i) (eucl_down e x \\<bullet> i))\\<^sup>2)", ".."], ["proof (state)\nthis:\n  dist x (eucl_down e x) =\n  sqrt\n   (\\<Sum>i\\<in>Basis.\n      (dist (x \\<bullet> i) (eucl_down e x \\<bullet> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist x (eucl_down e x)\n    \\<in> {0..sqrt (real DIM('a)) * 2 powr real_of_int (- e)}", "also"], ["proof (state)\nthis:\n  dist x (eucl_down e x) =\n  sqrt\n   (\\<Sum>i\\<in>Basis.\n      (dist (x \\<bullet> i) (eucl_down e x \\<bullet> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist x (eucl_down e x)\n    \\<in> {0..sqrt (real DIM('a)) * 2 powr real_of_int (- e)}", "have \"\\<dots> \\<le> sqrt (\\<Sum>i\\<in>(Basis::'a set). ((2 powr of_int (- e))\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Sum>i\\<in>Basis.\n        (dist (x \\<bullet> i) (eucl_down e x \\<bullet> i))\\<^sup>2)\n    \\<le> sqrt (\\<Sum>i\\<in>Basis. (2 powr real_of_int (- e))\\<^sup>2)", "by (intro real_sqrt_le_mono sum_mono power_mono)\n      (auto simp: dist_real_def eucl_down_def abs_round_down_le)"], ["proof (state)\nthis:\n  sqrt\n   (\\<Sum>i\\<in>Basis.\n      (dist (x \\<bullet> i) (eucl_down e x \\<bullet> i))\\<^sup>2)\n  \\<le> sqrt (\\<Sum>i\\<in>Basis. (2 powr real_of_int (- e))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist x (eucl_down e x)\n    \\<in> {0..sqrt (real DIM('a)) * 2 powr real_of_int (- e)}", "finally"], ["proof (chain)\npicking this:\n  dist x (eucl_down e x)\n  \\<le> sqrt (\\<Sum>i\\<in>Basis. (2 powr real_of_int (- e))\\<^sup>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x (eucl_down e x)\n  \\<le> sqrt (\\<Sum>i\\<in>Basis. (2 powr real_of_int (- e))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist x (eucl_down e x)\n    \\<in> {0..sqrt (real DIM('a)) * 2 powr real_of_int (- e)}", "by (simp add: real_sqrt_mult)"], ["proof (state)\nthis:\n  dist x (eucl_down e x)\n  \\<in> {0..sqrt (real DIM('a)) * 2 powr real_of_int (- e)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eucl_down: \"eucl_down e (x::'a::executable_euclidean_space) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_down e x \\<le> x", "by (auto simp add: eucl_le[where 'a='a] round_down eucl_down_def)"], ["", "lemma eucl_truncate_down: \"eucl_truncate_down e (x::'a::executable_euclidean_space) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_truncate_down e x \\<le> x", "by (auto simp add: eucl_le[where 'a='a] truncate_down)"], ["", "lemma eucl_truncate_down_le:\n  \"x \\<le> y \\<Longrightarrow> eucl_truncate_down w x \\<le> (y::'a::executable_euclidean_space)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> eucl_truncate_down w x \\<le> y", "using eucl_truncate_down"], ["proof (prove)\nusing this:\n  eucl_truncate_down ?e ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> eucl_truncate_down w x \\<le> y", "by (rule order.trans)"], ["", "lemma eucl_truncate_up_Basis[simp]: \"i \\<in> Basis \\<Longrightarrow> eucl_truncate_up e x \\<bullet> i = truncate_up e (x \\<bullet> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> Basis \\<Longrightarrow>\n    eucl_truncate_up e x \\<bullet> i = truncate_up e (x \\<bullet> i)", "by (simp add: eucl_truncate_up_def truncate_up_def)"], ["", "lemma eucl_truncate_up: \"x \\<le> eucl_truncate_up e (x::'a::executable_euclidean_space)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> eucl_truncate_up e x", "by (auto simp add: eucl_le[where 'a='a] round_up truncate_up_def)"], ["", "lemma eucl_truncate_up_le: \"x \\<le> y \\<Longrightarrow> x \\<le> eucl_truncate_up e (y::'a::executable_euclidean_space)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<le> eucl_truncate_up e y", "using _ eucl_truncate_up"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ?x \\<le> eucl_truncate_up ?e ?x\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<le> eucl_truncate_up e y", "by (rule order.trans)"], ["", "lemma eucl_truncate_down_mono:\n  fixes x::\"'a::executable_euclidean_space\"\n  shows \"x \\<le> y \\<Longrightarrow> eucl_truncate_down p x \\<le> eucl_truncate_down p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    eucl_truncate_down p x \\<le> eucl_truncate_down p y", "by (auto simp: eucl_le[where 'a='a] intro!: truncate_down_mono)"], ["", "lemma eucl_truncate_up_mono:\n  fixes x::\"'a::executable_euclidean_space\"\n  shows \"x \\<le> y \\<Longrightarrow> eucl_truncate_up p x \\<le> eucl_truncate_up p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    eucl_truncate_up p x \\<le> eucl_truncate_up p y", "by (auto simp: eucl_le[where 'a='a] intro!: truncate_up_mono)"], ["", "lemma infnorm[code]:\n  fixes x::\"'a::executable_euclidean_space\"\n  shows \"infnorm x = fold max (map (\\<lambda>i. abs (x \\<bullet> i)) Basis_list) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infnorm x =\n    fold max (map (\\<lambda>i. \\<bar>x \\<bullet> i\\<bar>) Basis_list) 0", "by (auto simp: Max.set_eq_fold[symmetric] infnorm_Max[symmetric] infnorm_pos_le\n    intro!: max.absorb2[symmetric])"], ["", "declare Inf_real_def[code del]"], ["", "declare Sup_real_def[code del]"], ["", "declare Inf_prod_def[code del]"], ["", "declare Sup_prod_def[code del]"], ["", "declare [[code abort: \"Inf::real set \\<Rightarrow> real\"]]"], ["", "declare [[code abort: \"Sup::real set \\<Rightarrow> real\"]]"], ["", "declare [[code abort: \"Inf::('a::Inf * 'b::Inf) set \\<Rightarrow> 'a * 'b\"]]"], ["", "declare [[code abort: \"Sup::('a::Sup * 'b::Sup) set \\<Rightarrow> 'a * 'b\"]]"], ["", "lemma nth_Basis_list_in_Basis[simp]:\n  \"n < length (Basis_list::'a::executable_euclidean_space list) \\<Longrightarrow> Basis_list ! n \\<in> (Basis::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length Basis_list \\<Longrightarrow> Basis_list ! n \\<in> Basis", "by (metis Basis_list nth_mem)"], ["", "subsection \\<open>Representation as list\\<close>"], ["", "lemma nth_eq_iff_index:\n  \"distinct xs \\<Longrightarrow> n < length xs \\<Longrightarrow> xs ! n = i \\<longleftrightarrow> n = index xs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n    \\<Longrightarrow> (xs ! n = i) = (n = index xs i)", "using index_nth_id"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?xs; ?n < length ?xs\\<rbrakk>\n  \\<Longrightarrow> index ?xs (?xs ! ?n) = ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n    \\<Longrightarrow> (xs ! n = i) = (n = index xs i)", "by fastforce"], ["", "lemma in_Basis_index_Basis_list: \"i \\<in> Basis \\<Longrightarrow> i = Basis_list ! index Basis_list i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> Basis \\<Longrightarrow> i = Basis_list ! index Basis_list i", "by simp"], ["", "lemmas [simp] = length_Basis_list"], ["", "lemma sum_Basis_sum_nth_Basis_list:\n  \"(\\<Sum>i\\<in>Basis. f i) = (\\<Sum>i<DIM('a::executable_euclidean_space). f ((Basis_list::'a list) ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f Basis = (\\<Sum>i<DIM('a). f (Basis_list ! i))", "apply (rule sum.reindex_cong[OF _ _ refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on ((!) Basis_list) {..<DIM('a)}\n 2. Basis = (!) Basis_list ` {..<DIM('a)}", "apply (auto intro!: inj_on_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow> x \\<in> (!) Basis_list ` {..<DIM('a)}", "by (metis Basis_list image_iff in_Basis_index_Basis_list index_less_size_conv length_Basis_list lessThan_iff)"], ["", "definition \"eucl_of_list xs = (\\<Sum>(x, i)\\<leftarrow>zip xs Basis_list. x *\\<^sub>R i)\""], ["", "lemma eucl_of_list_nth:\n  assumes \"length xs = DIM('a)\"\n  shows \"eucl_of_list xs = (\\<Sum>i<DIM('a::executable_euclidean_space). (xs ! i) *\\<^sub>R ((Basis_list::'a list) ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs = (\\<Sum>i<DIM('a). xs ! i *\\<^sub>R Basis_list ! i)", "by (auto simp: eucl_of_list_def sum_list_sum_nth length_Basis_list assms atLeast0LessThan)"], ["", "lemma eucl_of_list_inner:\n  fixes i::\"'a::executable_euclidean_space\"\n  assumes i: \"i \\<in> Basis\"\n  assumes l: \"length xs = DIM('a)\"\n  shows \"eucl_of_list xs \\<bullet> i = xs ! (index Basis_list i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs \\<bullet> i = xs ! index Basis_list i", "by (simp add: eucl_of_list_nth[OF l] inner_sum_left assms inner_Basis\n      nth_eq_iff_index sum.delta if_distrib cong: if_cong)"], ["", "lemma inner_eucl_of_list:\n  fixes i::\"'a::executable_euclidean_space\"\n  assumes i: \"i \\<in> Basis\"\n  assumes l: \"length xs = DIM('a)\"\n  shows \"i \\<bullet> eucl_of_list xs = xs ! (index Basis_list i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<bullet> eucl_of_list xs = xs ! index Basis_list i", "using eucl_of_list_inner[OF assms]"], ["proof (prove)\nusing this:\n  eucl_of_list xs \\<bullet> i = xs ! index Basis_list i\n\ngoal (1 subgoal):\n 1. i \\<bullet> eucl_of_list xs = xs ! index Basis_list i", "by (auto simp: inner_commute)"], ["", "definition \"list_of_eucl x = map ((\\<bullet>) x) Basis_list\""], ["", "lemma index_Basis_list_nth[simp]:\n  \"i < DIM('a::executable_euclidean_space) \\<Longrightarrow> index Basis_list ((Basis_list::'a list) ! i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < DIM('a) \\<Longrightarrow> index Basis_list (Basis_list ! i) = i", "by (simp add: index_nth_id)"], ["", "lemma list_of_eucl_eucl_of_list[simp]:\n  \"length xs = DIM('a::executable_euclidean_space) \\<Longrightarrow> list_of_eucl (eucl_of_list xs::'a) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = DIM('a) \\<Longrightarrow>\n    list_of_eucl (eucl_of_list xs) = xs", "by (auto simp: list_of_eucl_def eucl_of_list_inner intro!: nth_equalityI)"], ["", "lemma eucl_of_list_list_of_eucl[simp]:\n  \"eucl_of_list (list_of_eucl x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (list_of_eucl x) = x", "by (auto simp: list_of_eucl_def eucl_of_list_inner intro!: euclidean_eqI[where 'a='a])"], ["", "lemma length_list_of_eucl[simp]: \"length (list_of_eucl (x::'a::executable_euclidean_space)) = DIM('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_of_eucl x) = DIM('a)", "by (auto simp: list_of_eucl_def)"], ["", "lemma list_of_eucl_nth[simp]: \"n < DIM('a::executable_euclidean_space) \\<Longrightarrow> list_of_eucl x ! n = x \\<bullet> (Basis_list ! n::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < DIM('a) \\<Longrightarrow>\n    list_of_eucl x ! n = x \\<bullet> Basis_list ! n", "by (auto simp: list_of_eucl_def)"], ["", "lemma nth_ge_len: \"n \\<ge> length xs \\<Longrightarrow> xs ! n = [] ! (n - length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> n \\<Longrightarrow> xs ! n = [] ! (n - length xs)", "by (induction xs arbitrary: n) auto"], ["", "lemma list_of_eucl_nth_if: \"list_of_eucl x ! n = (if n < DIM('a::executable_euclidean_space) then x \\<bullet> (Basis_list ! n::'a) else [] ! (n - DIM('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_eucl x ! n =\n    (if n < DIM('a) then x \\<bullet> Basis_list ! n else [] ! (n - DIM('a)))", "apply (auto simp: list_of_eucl_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n < DIM('a) \\<Longrightarrow>\n    map ((\\<bullet>) x) Basis_list ! n = [] ! (n - DIM('a))", "apply (subst nth_ge_len)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> n < DIM('a) \\<Longrightarrow>\n    length (map ((\\<bullet>) x) Basis_list) \\<le> n\n 2. \\<not> n < DIM('a) \\<Longrightarrow>\n    [] ! (n - length (map ((\\<bullet>) x) Basis_list)) = [] ! (n - DIM('a))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_of_eucl_eq_iff:\n  \"list_of_eucl (x::'a::executable_euclidean_space) = list_of_eucl (y::'b::executable_euclidean_space) \\<longleftrightarrow>\n  (DIM('a) = DIM('b) \\<and> (\\<forall>i < DIM('b). x \\<bullet> Basis_list ! i = y \\<bullet> Basis_list ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_of_eucl x = list_of_eucl y) =\n    (DIM('a) = DIM('b) \\<and>\n     (\\<forall>i<DIM('b).\n         x \\<bullet> Basis_list ! i = y \\<bullet> Basis_list ! i))", "by (auto simp: list_eq_iff_nth_eq)"], ["", "lemma eucl_le_Basis_list_iff:\n  \"(x::'a::executable_euclidean_space) \\<le> y \\<longleftrightarrow>\n  (\\<forall>i<DIM('a). x \\<bullet> Basis_list ! i \\<le> y \\<bullet> Basis_list ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) =\n    (\\<forall>i<DIM('a).\n        x \\<bullet> Basis_list ! i \\<le> y \\<bullet> Basis_list ! i)", "apply (auto simp:  eucl_le[where 'a='a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i<DIM('a).\n                   x \\<bullet> Basis_list ! i\n                   \\<le> y \\<bullet> Basis_list ! i;\n        i \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> x \\<bullet> i \\<le> y \\<bullet> i", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<DIM('a).\n                x \\<bullet> Basis_list ! i \\<le> y \\<bullet> Basis_list ! i;\n     i \\<in> Basis\\<rbrakk>\n    \\<Longrightarrow> x \\<bullet> i \\<le> y \\<bullet> i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<DIM('a).\n                x \\<bullet> Basis_list ! i \\<le> y \\<bullet> Basis_list ! i;\n     i \\<in> Basis\\<rbrakk>\n    \\<Longrightarrow> x \\<bullet> i \\<le> y \\<bullet> i", "by (auto dest!: spec[where x=\"index Basis_list i\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eucl_of_list_inj: \"length xs = DIM('a::executable_euclidean_space) \\<Longrightarrow> length ys = DIM('a) \\<Longrightarrow>\n  (eucl_of_list xs::'a) = eucl_of_list (ys) \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = DIM('a); length ys = DIM('a);\n     eucl_of_list xs = eucl_of_list ys\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "apply (auto intro!: nth_equalityI simp: euclidean_eq_iff[where 'a=\"'a\"] eucl_of_list_inner)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>length xs = DIM('a); length ys = DIM('a);\n        \\<forall>b\\<in>Basis.\n           xs ! index Basis_list b = ys ! index Basis_list b;\n        i < DIM('a)\\<rbrakk>\n       \\<Longrightarrow> xs ! i = ys ! i", "using nth_Basis_list_in_Basis[where 'a=\"'a\"]"], ["proof (prove)\nusing this:\n  ?n < length Basis_list \\<Longrightarrow> Basis_list ! ?n \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>length xs = DIM('a); length ys = DIM('a);\n        \\<forall>b\\<in>Basis.\n           xs ! index Basis_list b = ys ! index Basis_list b;\n        i < DIM('a)\\<rbrakk>\n       \\<Longrightarrow> xs ! i = ys ! i", "by fastforce"], ["", "lemma eucl_of_list_map_plus[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. f x + g x) xs)::'a) =\n    eucl_of_list (map f xs) + eucl_of_list (map g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (map (\\<lambda>x. f x + g x) xs) =\n    eucl_of_list (map f xs) + eucl_of_list (map g xs)", "by (auto intro!: euclidean_eqI[where 'a='a] simp: algebra_simps eucl_of_list_inner)"], ["", "lemma eucl_of_list_map_uminus[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. - f x) xs)::'a) = - eucl_of_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (map (\\<lambda>x. - f x) xs) = - eucl_of_list (map f xs)", "by (auto intro!: euclidean_eqI[where 'a='a] simp: algebra_simps eucl_of_list_inner)"], ["", "lemma eucl_of_list_map_mult_left[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. r * f x) xs)::'a) = r *\\<^sub>R eucl_of_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (map (\\<lambda>x. r * f x) xs) =\n    r *\\<^sub>R eucl_of_list (map f xs)", "by (auto intro!: euclidean_eqI[where 'a='a] simp: algebra_simps eucl_of_list_inner)"], ["", "lemma eucl_of_list_map_mult_right[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. f x * r) xs)::'a) = r *\\<^sub>R eucl_of_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (map (\\<lambda>x. f x * r) xs) =\n    r *\\<^sub>R eucl_of_list (map f xs)", "by (auto intro!: euclidean_eqI[where 'a='a] simp: algebra_simps eucl_of_list_inner)"], ["", "lemma eucl_of_list_map_divide_right[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. f x / r) xs)::'a) = eucl_of_list (map f xs) /\\<^sub>R r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (map (\\<lambda>x. f x / r) xs) =\n    eucl_of_list (map f xs) /\\<^sub>R r", "by (auto intro!: euclidean_eqI[where 'a='a] simp: algebra_simps eucl_of_list_inner divide_simps)"], ["", "lemma eucl_of_list_map_const[simp]:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\"\n  shows \"(eucl_of_list (map (\\<lambda>x. c) xs)::'a) = c *\\<^sub>R One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (map (\\<lambda>x. c) xs) = c *\\<^sub>R One", "by (auto intro!: euclidean_eqI[where 'a='a] simp: algebra_simps eucl_of_list_inner)"], ["", "lemma replicate_eq_list_of_eucl_zero: \"replicate DIM('a::executable_euclidean_space) 0 = list_of_eucl (0::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate DIM('a) 0 = list_of_eucl (0::'a)", "by (auto intro!: nth_equalityI)"], ["", "lemma eucl_of_list_append_zeroes[simp]: \"eucl_of_list (xs @ replicate n 0) = eucl_of_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (xs @ replicate n 0) = eucl_of_list xs", "unfolding eucl_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (*\\<^sub>R) (xs @ replicate n 0) Basis_list) =\n    sum_list (map2 (*\\<^sub>R) xs Basis_list)", "apply (auto simp: sum_list_sum_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<min (length xs + n) DIM('a).\n        (xs @ replicate n 0) ! i *\\<^sub>R Basis_list ! i) =\n    (\\<Sum>i = 0..<min (length xs) DIM('a). xs ! i *\\<^sub>R Basis_list ! i)", "apply (rule sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {0..<min (length xs + n) DIM('a)}\n 2. {0..<min (length xs) DIM('a)}\n    \\<subseteq> {0..<min (length xs + n) DIM('a)}\n 3. \\<forall>i\\<in>{0..<min (length xs + n) DIM('a)} -\n                   {0..<min (length xs) DIM('a)}.\n       (xs @ replicate n 0) ! i *\\<^sub>R Basis_list ! i = (0::'a)\n 4. \\<And>x.\n       x \\<in> {0..<min (length xs) DIM('a)} \\<Longrightarrow>\n       (xs @ replicate n 0) ! x *\\<^sub>R Basis_list ! x =\n       xs ! x *\\<^sub>R Basis_list ! x", "by (auto simp: nth_append)"], ["", "lemma Basis_prodD:\n  assumes \"(i, j) \\<in> Basis\"\n  shows \"i \\<in> Basis \\<and> j = 0 \\<or> i = 0 \\<and> j \\<in> Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> Basis \\<and> j = (0::'b) \\<or> i = (0::'a) \\<and> j \\<in> Basis", "using assms"], ["proof (prove)\nusing this:\n  (i, j) \\<in> Basis\n\ngoal (1 subgoal):\n 1. i \\<in> Basis \\<and> j = (0::'b) \\<or> i = (0::'a) \\<and> j \\<in> Basis", "by (auto simp: Basis_prod_def)"], ["", "lemma eucl_of_list_take_DIM[simp]:\n  assumes \"d = DIM('b::executable_euclidean_space)\"\n  shows \"(eucl_of_list (take d xs)::'b) = (eucl_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (take d xs) = eucl_of_list xs", "by (auto simp: eucl_of_list_inner eucl_of_list_def fst_sum_list sum_list_sum_nth assms dest!: Basis_prodD)"], ["", "lemma eucl_of_list_eqI:\n  assumes \"take DIM('a) (xs @ replicate (DIM('a) - length xs) 0) =\n    take DIM('a) (ys @ replicate (DIM('a) - length ys) 0)\"\n  shows \"eucl_of_list xs = (eucl_of_list ys::'a::executable_euclidean_space)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs = eucl_of_list ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eucl_of_list xs = eucl_of_list ys", "have \"(eucl_of_list xs::'a) = eucl_of_list (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs =\n    eucl_of_list (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0))", "by (simp add: )"], ["proof (state)\nthis:\n  eucl_of_list xs =\n  eucl_of_list (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0))\n\ngoal (1 subgoal):\n 1. eucl_of_list xs = eucl_of_list ys", "also"], ["proof (state)\nthis:\n  eucl_of_list xs =\n  eucl_of_list (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0))\n\ngoal (1 subgoal):\n 1. eucl_of_list xs = eucl_of_list ys", "note assms"], ["proof (state)\nthis:\n  take DIM('a) (xs @ replicate (DIM('a) - length xs) 0) =\n  take DIM('a) (ys @ replicate (DIM('a) - length ys) 0)\n\ngoal (1 subgoal):\n 1. eucl_of_list xs = eucl_of_list ys", "also"], ["proof (state)\nthis:\n  take DIM('a) (xs @ replicate (DIM('a) - length xs) 0) =\n  take DIM('a) (ys @ replicate (DIM('a) - length ys) 0)\n\ngoal (1 subgoal):\n 1. eucl_of_list xs = eucl_of_list ys", "have \"eucl_of_list (take DIM('a) (ys @ replicate (DIM('a) - length ys) 0)) = (eucl_of_list ys::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (take DIM('a) (ys @ replicate (DIM('a) - length ys) 0)) =\n    eucl_of_list ys", "by simp"], ["proof (state)\nthis:\n  eucl_of_list (take DIM('a) (ys @ replicate (DIM('a) - length ys) 0)) =\n  eucl_of_list ys\n\ngoal (1 subgoal):\n 1. eucl_of_list xs = eucl_of_list ys", "finally"], ["proof (chain)\npicking this:\n  eucl_of_list xs = eucl_of_list ys", "show ?thesis"], ["proof (prove)\nusing this:\n  eucl_of_list xs = eucl_of_list ys\n\ngoal (1 subgoal):\n 1. eucl_of_list xs = eucl_of_list ys", "."], ["proof (state)\nthis:\n  eucl_of_list xs = eucl_of_list ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eucl_of_list_replicate_zero[simp]: \"eucl_of_list (replicate E 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0) = (0::'a)", "have \"eucl_of_list (replicate E 0) = (eucl_of_list (replicate E 0 @ replicate (DIM('a) - E) 0)::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0) =\n    eucl_of_list (replicate E 0 @ replicate (DIM('a) - E) 0)", "by simp"], ["proof (state)\nthis:\n  eucl_of_list (replicate E 0) =\n  eucl_of_list (replicate E 0 @ replicate (DIM('a) - E) 0)\n\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0) = (0::'a)", "also"], ["proof (state)\nthis:\n  eucl_of_list (replicate E 0) =\n  eucl_of_list (replicate E 0 @ replicate (DIM('a) - E) 0)\n\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0) = (0::'a)", "have \"\\<dots> = eucl_of_list (replicate DIM('a) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0 @ replicate (DIM('a) - E) 0) =\n    eucl_of_list (replicate DIM('a) 0)", "apply (rule eucl_of_list_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take DIM('a)\n     ((replicate E 0 @ replicate (DIM('a) - E) 0) @\n      replicate\n       (DIM('a) - length (replicate E 0 @ replicate (DIM('a) - E) 0)) 0) =\n    take DIM('a)\n     (replicate DIM('a) 0 @\n      replicate (DIM('a) - length (replicate DIM('a) 0)) 0)", "by (auto simp: min_def nth_append intro!: nth_equalityI)"], ["proof (state)\nthis:\n  eucl_of_list (replicate E 0 @ replicate (DIM('a) - E) 0) =\n  eucl_of_list (replicate DIM('a) 0)\n\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0) = (0::'a)", "also"], ["proof (state)\nthis:\n  eucl_of_list (replicate E 0 @ replicate (DIM('a) - E) 0) =\n  eucl_of_list (replicate DIM('a) 0)\n\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0) = (0::'a)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (replicate DIM('a) 0) = (0::'a)", "by (simp add: replicate_eq_list_of_eucl_zero)"], ["proof (state)\nthis:\n  eucl_of_list (replicate DIM('a) 0) = (0::'a)\n\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  eucl_of_list (replicate E 0) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  eucl_of_list (replicate E 0) = (0::'a)\n\ngoal (1 subgoal):\n 1. eucl_of_list (replicate E 0) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  eucl_of_list (replicate E 0) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eucl_of_list_Nil[simp]: \"eucl_of_list [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list [] = (0::'a)", "using eucl_of_list_replicate_zero[of 0]"], ["proof (prove)\nusing this:\n  eucl_of_list (replicate 0 0) = (0::?'a)\n\ngoal (1 subgoal):\n 1. eucl_of_list [] = (0::'a)", "by simp"], ["", "lemma fst_eucl_of_list_prod:\n  shows \"fst (eucl_of_list xs::'b::executable_euclidean_space  \\<times> _) = (eucl_of_list (take DIM('b) xs)::'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (eucl_of_list xs) = eucl_of_list (take DIM('b) xs)", "apply (auto simp: eucl_of_list_inner eucl_of_list_def fst_sum_list dest!: Basis_prodD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map (fst \\<circ> (\\<lambda>(x, y). x *\\<^sub>R y))\n       (zip xs Basis_list)) =\n    sum_list (map2 (*\\<^sub>R) (take DIM('b) xs) Basis_list)", "apply (simp add: sum_list_sum_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<min (length xs) (DIM('b) + DIM('a)).\n        xs ! i *\\<^sub>R fst (Basis_list ! i)) =\n    (\\<Sum>i = 0..<min (length xs) DIM('b). xs ! i *\\<^sub>R Basis_list ! i)", "apply (rule sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {0..<min (length xs) (DIM('b) + DIM('a))}\n 2. {0..<min (length xs) DIM('b)}\n    \\<subseteq> {0..<min (length xs) (DIM('b) + DIM('a))}\n 3. \\<forall>i\\<in>{0..<min (length xs) (DIM('b) + DIM('a))} -\n                   {0..<min (length xs) DIM('b)}.\n       xs ! i *\\<^sub>R fst (Basis_list ! i) = (0::'b)\n 4. \\<And>x.\n       x \\<in> {0..<min (length xs) DIM('b)} \\<Longrightarrow>\n       xs ! x *\\<^sub>R fst (Basis_list ! x) =\n       xs ! x *\\<^sub>R Basis_list ! x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..<min (length xs) (DIM('b) + DIM('a))}", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. {0..<min (length xs) DIM('b)}\n    \\<subseteq> {0..<min (length xs) (DIM('b) + DIM('a))}\n 2. \\<forall>i\\<in>{0..<min (length xs) (DIM('b) + DIM('a))} -\n                   {0..<min (length xs) DIM('b)}.\n       xs ! i *\\<^sub>R fst (Basis_list ! i) = (0::'b)\n 3. \\<And>x.\n       x \\<in> {0..<min (length xs) DIM('b)} \\<Longrightarrow>\n       xs ! x *\\<^sub>R fst (Basis_list ! x) =\n       xs ! x *\\<^sub>R Basis_list ! x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<min (length xs) DIM('b)}\n    \\<subseteq> {0..<min (length xs) (DIM('b) + DIM('a))}", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{0..<min (length xs) (DIM('b) + DIM('a))} -\n                   {0..<min (length xs) DIM('b)}.\n       xs ! i *\\<^sub>R fst (Basis_list ! i) = (0::'b)\n 2. \\<And>x.\n       x \\<in> {0..<min (length xs) DIM('b)} \\<Longrightarrow>\n       xs ! x *\\<^sub>R fst (Basis_list ! x) =\n       xs ! x *\\<^sub>R Basis_list ! x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..<min (length xs) (DIM('b) + DIM('a))} -\n                   {0..<min (length xs) DIM('b)}.\n       xs ! i *\\<^sub>R fst (Basis_list ! i) = (0::'b)", "by (auto simp: Basis_list_prod_def nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<min (length xs) DIM('b)} \\<Longrightarrow>\n       xs ! x *\\<^sub>R fst (Basis_list ! x) =\n       xs ! x *\\<^sub>R Basis_list ! x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {0..<min (length xs) DIM('b)} \\<Longrightarrow>\n    xs ! x_ *\\<^sub>R fst (Basis_list ! x_) =\n    xs ! x_ *\\<^sub>R Basis_list ! x_", "by (auto simp: Basis_list_prod_def nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma index_zip_replicate1[simp]: \"index (zip (replicate d a) bs) (a, b) = index bs b\"\n  if \"d = length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (zip (replicate d a) bs) (a, b) = index bs b", "using that"], ["proof (prove)\nusing this:\n  d = length bs\n\ngoal (1 subgoal):\n 1. index (zip (replicate d a) bs) (a, b) = index bs b", "by (induction bs arbitrary: d) auto"], ["", "lemma index_zip_replicate2[simp]: \"index (zip as (replicate d b)) (a, b) = index as a\"\n  if \"d = length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (zip as (replicate d b)) (a, b) = index as a", "using that"], ["proof (prove)\nusing this:\n  d = length as\n\ngoal (1 subgoal):\n 1. index (zip as (replicate d b)) (a, b) = index as a", "by (induction as arbitrary: d) auto"], ["", "lemma index_Basis_list_prod[simp]:\n  fixes a::\"'a::executable_euclidean_space\" and b::\"'b::executable_euclidean_space\"\n  shows \"a \\<in> Basis \\<Longrightarrow> index Basis_list (a, 0::'b) = index Basis_list a\"\n    \"b \\<in> Basis \\<Longrightarrow> index Basis_list (0::'a, b) = DIM('a) + index Basis_list b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> Basis \\<Longrightarrow>\n     index Basis_list (a, 0::'b) = index Basis_list a) &&&\n    (b \\<in> Basis \\<Longrightarrow>\n     index Basis_list (0::'a, b) = DIM('a) + index Basis_list b)", "by (auto simp: Basis_list_prod_def index_append\n      in_set_zip zip_replicate index_map_inj dest: spec[where x=\"index Basis_list a\"])"], ["", "lemma eucl_of_list_eq_takeI:\n  assumes \"(eucl_of_list (take DIM('a::executable_euclidean_space) xs)::'a) = x\"\n  shows \"eucl_of_list xs = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs = x", "using eucl_of_list_take_DIM[OF refl, of xs, where 'b='a] assms"], ["proof (prove)\nusing this:\n  eucl_of_list (take DIM('a) xs) = eucl_of_list xs\n  eucl_of_list (take DIM('a) xs) = x\n\ngoal (1 subgoal):\n 1. eucl_of_list xs = x", "by auto"], ["", "lemma eucl_of_list_inner_le:\n  fixes i::\"'a::executable_euclidean_space\"\n  assumes i: \"i \\<in> Basis\"\n  assumes l: \"length xs \\<ge> DIM('a)\"\n  shows \"eucl_of_list xs \\<bullet> i = xs ! (index Basis_list i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs \\<bullet> i = xs ! index Basis_list i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eucl_of_list xs \\<bullet> i = xs ! index Basis_list i", "have \"(eucl_of_list xs::'a) = eucl_of_list (take DIM('a) (xs @ (replicate (DIM('a) - length xs) 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs =\n    eucl_of_list (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0))", "by (rule eucl_of_list_eq_takeI) simp"], ["proof (state)\nthis:\n  eucl_of_list xs =\n  eucl_of_list (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0))\n\ngoal (1 subgoal):\n 1. eucl_of_list xs \\<bullet> i = xs ! index Basis_list i", "also"], ["proof (state)\nthis:\n  eucl_of_list xs =\n  eucl_of_list (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0))\n\ngoal (1 subgoal):\n 1. eucl_of_list xs \\<bullet> i = xs ! index Basis_list i", "have \"\\<dots> \\<bullet> i = xs ! (index Basis_list i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list\n     (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0)) \\<bullet>\n    i =\n    xs ! index Basis_list i", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> Basis\n  DIM('a) \\<le> length xs\n\ngoal (1 subgoal):\n 1. eucl_of_list\n     (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0)) \\<bullet>\n    i =\n    xs ! index Basis_list i", "by (subst eucl_of_list_inner) auto"], ["proof (state)\nthis:\n  eucl_of_list\n   (take DIM('a) (xs @ replicate (DIM('a) - length xs) 0)) \\<bullet>\n  i =\n  xs ! index Basis_list i\n\ngoal (1 subgoal):\n 1. eucl_of_list xs \\<bullet> i = xs ! index Basis_list i", "finally"], ["proof (chain)\npicking this:\n  eucl_of_list xs \\<bullet> i = xs ! index Basis_list i", "show ?thesis"], ["proof (prove)\nusing this:\n  eucl_of_list xs \\<bullet> i = xs ! index Basis_list i\n\ngoal (1 subgoal):\n 1. eucl_of_list xs \\<bullet> i = xs ! index Basis_list i", "."], ["proof (state)\nthis:\n  eucl_of_list xs \\<bullet> i = xs ! index Basis_list i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eucl_of_list_prod_if:\n  assumes \"length xs = DIM('a::executable_euclidean_space) + DIM('b::executable_euclidean_space)\"\n  shows \"eucl_of_list xs =\n    (eucl_of_list (take DIM('a) xs)::'a, eucl_of_list (drop DIM('a) xs)::'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs =\n    (eucl_of_list (take DIM('a) xs), eucl_of_list (drop DIM('a) xs))", "apply (rule euclidean_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow>\n       eucl_of_list xs \\<bullet> b =\n       (eucl_of_list (take DIM('a) xs),\n        eucl_of_list (drop DIM('a) xs)) \\<bullet>\n       b", "using assms"], ["proof (prove)\nusing this:\n  length xs = DIM('a) + DIM('b)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow>\n       eucl_of_list xs \\<bullet> b =\n       (eucl_of_list (take DIM('a) xs),\n        eucl_of_list (drop DIM('a) xs)) \\<bullet>\n       b", "apply (auto simp: eucl_of_list_inner dest!: Basis_prodD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length xs = DIM('a) + DIM('b); a \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> xs ! index Basis_list a =\n                         eucl_of_list xs \\<bullet> a", "apply (subst eucl_of_list_inner_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>length xs = DIM('a) + DIM('b); a \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> a \\<in> Basis\n 2. \\<And>a.\n       \\<lbrakk>length xs = DIM('a) + DIM('b); a \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> DIM('a) \\<le> length xs\n 3. \\<And>a.\n       \\<lbrakk>length xs = DIM('a) + DIM('b); a \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> xs ! index Basis_list a = xs ! index Basis_list a", "apply (auto simp: Basis_list_prod_def index_append in_set_zip)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma snd_eucl_of_list_prod:\n  shows \"snd (eucl_of_list xs::'b::executable_euclidean_space  \\<times> 'c::executable_euclidean_space) =\n    (eucl_of_list (drop DIM('b) xs)::'c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "proof (cases \"length xs \\<le> DIM('b)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)\n 2. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "case True"], ["proof (state)\nthis:\n  length xs \\<le> DIM('b)\n\ngoal (2 subgoals):\n 1. length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)\n 2. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "then"], ["proof (chain)\npicking this:\n  length xs \\<le> DIM('b)", "show ?thesis"], ["proof (prove)\nusing this:\n  length xs \\<le> DIM('b)\n\ngoal (1 subgoal):\n 1. snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "by (auto simp: eucl_of_list_inner eucl_of_list_def snd_sum_list dest!: Basis_prodD)\n      (simp add: sum_list_sum_nth Basis_list_prod_def nth_append)"], ["proof (state)\nthis:\n  snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "case False"], ["proof (state)\nthis:\n  \\<not> length xs \\<le> DIM('b)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "have \"xs = take DIM('b) xs @ drop DIM('b) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = take DIM('b) xs @ drop DIM('b) xs", "by simp"], ["proof (state)\nthis:\n  xs = take DIM('b) xs @ drop DIM('b) xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "also"], ["proof (state)\nthis:\n  xs = take DIM('b) xs @ drop DIM('b) xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "have \"eucl_of_list \\<dots> = (eucl_of_list (\\<dots> @ replicate (length xs - DIM('c)) 0)::'b \\<times> 'c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (take DIM('b) xs @ drop DIM('b) xs) =\n    eucl_of_list\n     ((take DIM('b) xs @ drop DIM('b) xs) @\n      replicate (length xs - DIM('c)) 0)", "by simp"], ["proof (state)\nthis:\n  eucl_of_list (take DIM('b) xs @ drop DIM('b) xs) =\n  eucl_of_list\n   ((take DIM('b) xs @ drop DIM('b) xs) @ replicate (length xs - DIM('c)) 0)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "finally"], ["proof (chain)\npicking this:\n  eucl_of_list xs = eucl_of_list (xs @ replicate (length xs - DIM('c)) 0)", "have \"eucl_of_list xs = (eucl_of_list (xs @ replicate (DIM('b) + DIM('c) - length xs) 0)::'b \\<times> 'c)\""], ["proof (prove)\nusing this:\n  eucl_of_list xs = eucl_of_list (xs @ replicate (length xs - DIM('c)) 0)\n\ngoal (1 subgoal):\n 1. eucl_of_list xs =\n    eucl_of_list (xs @ replicate (DIM('b) + DIM('c) - length xs) 0)", "by simp"], ["proof (state)\nthis:\n  eucl_of_list xs =\n  eucl_of_list (xs @ replicate (DIM('b) + DIM('c) - length xs) 0)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "also"], ["proof (state)\nthis:\n  eucl_of_list xs =\n  eucl_of_list (xs @ replicate (DIM('b) + DIM('c) - length xs) 0)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "have \"\\<dots> = eucl_of_list (take (DIM ('b \\<times> 'c)) (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (xs @ replicate (DIM('b) + DIM('c) - length xs) 0) =\n    eucl_of_list\n     (take DIM('b \\<times> 'c)\n       (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))", "by (simp add: )"], ["proof (state)\nthis:\n  eucl_of_list (xs @ replicate (DIM('b) + DIM('c) - length xs) 0) =\n  eucl_of_list\n   (take DIM('b \\<times> 'c)\n     (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "finally"], ["proof (chain)\npicking this:\n  eucl_of_list xs =\n  eucl_of_list\n   (take DIM('b \\<times> 'c)\n     (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))", "have *: \"(eucl_of_list xs::'b\\<times>'c) = eucl_of_list (take DIM('b \\<times> 'c) (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))\""], ["proof (prove)\nusing this:\n  eucl_of_list xs =\n  eucl_of_list\n   (take DIM('b \\<times> 'c)\n     (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))\n\ngoal (1 subgoal):\n 1. eucl_of_list xs =\n    eucl_of_list\n     (take DIM('b \\<times> 'c)\n       (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))", "by simp"], ["proof (state)\nthis:\n  eucl_of_list xs =\n  eucl_of_list\n   (take DIM('b \\<times> 'c)\n     (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> DIM('b) \\<Longrightarrow>\n    snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (eucl_of_list\n          (take DIM('b \\<times> 'c)\n            (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))) =\n    eucl_of_list (drop DIM('b) xs)", "apply (subst eucl_of_list_prod_if)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length\n     (take DIM('b \\<times> 'c)\n       (xs @ replicate (DIM('b) + DIM('c) - length xs) 0)) =\n    DIM('b) + DIM('c)\n 2. snd (eucl_of_list\n          (take DIM('b)\n            (take DIM('b \\<times> 'c)\n              (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))),\n         eucl_of_list\n          (drop DIM('b)\n            (take DIM('b \\<times> 'c)\n              (xs @ replicate (DIM('b) + DIM('c) - length xs) 0)))) =\n    eucl_of_list (drop DIM('b) xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (take DIM('b \\<times> 'c)\n       (xs @ replicate (DIM('b) + DIM('c) - length xs) 0)) =\n    DIM('b) + DIM('c)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (eucl_of_list\n          (take DIM('b)\n            (take DIM('b \\<times> 'c)\n              (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))),\n         eucl_of_list\n          (drop DIM('b)\n            (take DIM('b \\<times> 'c)\n              (xs @ replicate (DIM('b) + DIM('c) - length xs) 0)))) =\n    eucl_of_list (drop DIM('b) xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (eucl_of_list\n          (take DIM('b)\n            (take DIM('b \\<times> 'c)\n              (xs @ replicate (DIM('b) + DIM('c) - length xs) 0))),\n         eucl_of_list\n          (drop DIM('b)\n            (take DIM('b \\<times> 'c)\n              (xs @ replicate (DIM('b) + DIM('c) - length xs) 0)))) =\n    eucl_of_list (drop DIM('b) xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (drop DIM('b) (take (DIM('b) + DIM('c)) xs)) =\n    eucl_of_list (drop DIM('b) xs)", "apply (subst (2) eucl_of_list_take_DIM[OF refl, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (drop DIM('b) (take (DIM('b) + DIM('c)) xs)) =\n    eucl_of_list (take DIM('c) (drop DIM('b) xs))", "apply (subst (2) eucl_of_list_take_DIM[OF refl, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (drop DIM('b) (take (DIM('b) + DIM('c)) xs)) =\n    eucl_of_list (take DIM('c) (take DIM('c) (drop DIM('b) xs)))", "apply (rule arg_cong[where f=eucl_of_list])"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop DIM('b) (take (DIM('b) + DIM('c)) xs) =\n    take DIM('c) (take DIM('c) (drop DIM('b) xs))", "by (auto intro!: nth_equalityI simp: nth_append min_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eucl_of_list_prod:\n  shows \"eucl_of_list xs = (eucl_of_list (take DIM('b) xs)::'b::executable_euclidean_space,\n    eucl_of_list (drop DIM('b) xs)::'c::executable_euclidean_space)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs =\n    (eucl_of_list (take DIM('b) xs), eucl_of_list (drop DIM('b) xs))", "using snd_eucl_of_list_prod[of xs, where 'b='b and 'c='c]"], ["proof (prove)\nusing this:\n  snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)\n\ngoal (1 subgoal):\n 1. eucl_of_list xs =\n    (eucl_of_list (take DIM('b) xs), eucl_of_list (drop DIM('b) xs))", "using fst_eucl_of_list_prod[of xs, where 'b='b and 'a='c]"], ["proof (prove)\nusing this:\n  snd (eucl_of_list xs) = eucl_of_list (drop DIM('b) xs)\n  fst (eucl_of_list xs) = eucl_of_list (take DIM('b) xs)\n\ngoal (1 subgoal):\n 1. eucl_of_list xs =\n    (eucl_of_list (take DIM('b) xs), eucl_of_list (drop DIM('b) xs))", "by (auto simp del: snd_eucl_of_list_prod fst_eucl_of_list_prod simp add: prod_eq_iff)"], ["", "lemma eucl_of_list_real[simp]: \"eucl_of_list [x] = (x::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list [x] = x", "by (auto simp: eucl_of_list_def Basis_list_real_def)"], ["", "lemma eucl_of_list_append[simp]:\n  assumes \"length xs = DIM('i::executable_euclidean_space)\"\n  assumes \"length ys = DIM('j::executable_euclidean_space)\"\n  shows \"eucl_of_list (xs @ ys) = (eucl_of_list xs::'i, eucl_of_list ys::'j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (xs @ ys) = (eucl_of_list xs, eucl_of_list ys)", "using assms"], ["proof (prove)\nusing this:\n  length xs = DIM('i)\n  length ys = DIM('j)\n\ngoal (1 subgoal):\n 1. eucl_of_list (xs @ ys) = (eucl_of_list xs, eucl_of_list ys)", "by (auto simp: eucl_of_list_prod)"], ["", "lemma list_allI: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> P x) \\<Longrightarrow> list_all P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set xs \\<Longrightarrow> P x) \\<Longrightarrow>\n    list_all P xs", "by (auto simp: list_all_iff)"], ["", "lemma\n  concat_map_nthI:\n  assumes \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set (f x) \\<Longrightarrow> P y\"\n  assumes \"j < length (concat (map f xs))\"\n  shows \"P (concat (map f xs) ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (concat (map f xs) ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (concat (map f xs) ! j)", "have \"list_all P (concat (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P (concat (map f xs))", "by (rule list_allI) (auto simp: assms)"], ["proof (state)\nthis:\n  list_all P (concat (map f xs))\n\ngoal (1 subgoal):\n 1. P (concat (map f xs) ! j)", "then"], ["proof (chain)\npicking this:\n  list_all P (concat (map f xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all P (concat (map f xs))\n\ngoal (1 subgoal):\n 1. P (concat (map f xs) ! j)", "by (auto simp: list_all_length assms)"], ["proof (state)\nthis:\n  P (concat (map f xs) ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_nth_append1:\n  assumes \"length xs = d\"\n  shows \"map ((!) (xs @ ys)) [0..<d] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (xs @ ys)) [0..<d] = xs", "using assms"], ["proof (prove)\nusing this:\n  length xs = d\n\ngoal (1 subgoal):\n 1. map ((!) (xs @ ys)) [0..<d] = xs", "by (auto simp: nth_append intro!: nth_equalityI)"], ["", "lemma map_nth_append2:\n  assumes \"length ys = d\"\n  shows \"map ((!) (xs @ ys)) [length xs..<length xs + d] = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (xs @ ys)) [length xs..<length xs + d] = ys", "using assms"], ["proof (prove)\nusing this:\n  length ys = d\n\ngoal (1 subgoal):\n 1. map ((!) (xs @ ys)) [length xs..<length xs + d] = ys", "by (auto simp: intro!: nth_equalityI)"], ["", "lemma length_map2 [simp]: \"length (map2 f xs ys) = min (length xs) (length ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map2 f xs ys) = min (length xs) (length ys)", "by simp"], ["", "lemma map2_nth [simp]: \"map2 f xs ys ! n = f (xs ! n) (ys ! n)\"\n  if \"n < length xs\" \"n < length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 f xs ys ! n = f (xs ! n) (ys ! n)", "using that"], ["proof (prove)\nusing this:\n  n < length xs\n  n < length ys\n\ngoal (1 subgoal):\n 1. map2 f xs ys ! n = f (xs ! n) (ys ! n)", "by simp"], ["", "lemma list_of_eucl_add: \"list_of_eucl (x + y) = map2 (+) (list_of_eucl x) (list_of_eucl y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_eucl (x + y) = map2 (+) (list_of_eucl x) (list_of_eucl y)", "by (auto intro!: nth_equalityI simp: inner_simps)"], ["", "lemma list_of_eucl_inj:\n  \"list_of_eucl z = list_of_eucl y \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_eucl z = list_of_eucl y \\<Longrightarrow> y = z", "by (metis eucl_of_list_list_of_eucl)"], ["", "lemma length_Basis_list_pos[simp]: \"length Basis_list > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length Basis_list", "by (metis length_pos_if_in_set Basis_list SOME_Basis)"], ["", "lemma Basis_list_nth_nonzero:\n  \"i < length (Basis_list::'a::executable_euclidean_space list) \\<Longrightarrow> (Basis_list::'a list) ! i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length Basis_list \\<Longrightarrow> Basis_list ! i \\<noteq> (0::'a)", "by (auto dest!: nth_mem simp: nonzero_Basis)"], ["", "lemma nth_Basis_list_prod:\n  \"i < DIM('a) + DIM('b) \\<Longrightarrow> (Basis_list::('a::executable_euclidean_space \\<times> 'b::executable_euclidean_space) list) ! i =\n    (if i < DIM('a) then (Basis_list ! i, 0) else (0, Basis_list ! (i - DIM('a))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < DIM('a) + DIM('b) \\<Longrightarrow>\n    Basis_list ! i =\n    (if i < DIM('a) then (Basis_list ! i, 0::'b)\n     else (0::'a, Basis_list ! (i - DIM('a))))", "by (auto simp: Basis_list_nth_nonzero prod_eq_iff Basis_list_prod_def nth_append not_less)"], ["", "lemma eucl_of_list_if:\n  assumes [simp]: \"length xs = DIM('a::executable_euclidean_space)\" \"distinct xs\"\n  shows \"eucl_of_list (map (\\<lambda>xa. if xa = x then 1 else 0) (xs::nat list)) =\n    (if x \\<in> set xs then Basis_list ! index xs x else 0::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (map (\\<lambda>xa. if xa = x then 1 else 0) xs) =\n    (if x \\<in> set xs then Basis_list ! index xs x else (0::'a))", "by (rule euclidean_eqI) (auto simp: eucl_of_list_inner inner_Basis index_nth_id)"], ["", "lemma take_append_take_minus_idem: \"take n XS @ map ((!) XS) [n..<length XS] = XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n XS @ map ((!) XS) [n..<length XS] = XS", "by (auto intro!: nth_equalityI simp: nth_append min_def)"], ["", "lemma sum_list_Basis_list[simp]: \"sum_list (map f Basis_list) = (\\<Sum>b\\<in>Basis. f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f Basis_list) = sum f Basis", "by (subst sum_list_distinct_conv_sum_set) (auto simp: Basis_list distinct_Basis_list)"], ["", "lemma hd_Basis_list[simp]: \"hd Basis_list \\<in> Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd Basis_list \\<in> Basis", "unfolding Basis_list[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd Basis_list \\<in> set Basis_list", "by (rule hd_in_set) (auto simp: set_empty[symmetric])"], ["", "definition \"inner_lv_rel a b = sum_list (map2 (*) a b)\""], ["", "lemma eucl_of_list_inner_eq: \"(eucl_of_list xs::'a) \\<bullet> eucl_of_list ys = inner_lv_rel xs ys\"\n  if \"length xs = DIM('a::executable_euclidean_space)\" \"length ys = DIM('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list xs \\<bullet> eucl_of_list ys = inner_lv_rel xs ys", "using that"], ["proof (prove)\nusing this:\n  length xs = DIM('a)\n  length ys = DIM('a)\n\ngoal (1 subgoal):\n 1. eucl_of_list xs \\<bullet> eucl_of_list ys = inner_lv_rel xs ys", "by (subst euclidean_inner[abs_def], subst sum_list_Basis_list[symmetric])\n      (auto simp: eucl_of_list_inner sum_list_sum_nth index_nth_id inner_lv_rel_def)"], ["", "lemma euclidean_vec_componentwise:\n  \"(\\<Sum>(xa::'a::euclidean_space^'b::finite)\\<in>Basis. f xa) = (\\<Sum>a\\<in>Basis. (\\<Sum>b::'b\\<in>UNIV. f (axis b a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f Basis = (\\<Sum>a\\<in>Basis. \\<Sum>b\\<in>UNIV. f (axis b a))", "apply (auto simp: Basis_vec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (\\<Union>i. \\<Union>u\\<in>Basis. {axis i u}) =\n    (\\<Sum>a\\<in>Basis. \\<Sum>b\\<in>UNIV. f (axis b a))", "apply (subst sum.swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (\\<Union>i. \\<Union>u\\<in>Basis. {axis i u}) =\n    (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>Basis. f (axis j i))", "apply (subst sum.Union_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Ball (range (\\<lambda>i. \\<Union>u\\<in>Basis. {axis i u})) finite\n 2. \\<forall>A\\<in>range (\\<lambda>i. \\<Union>u\\<in>Basis. {axis i u}).\n       \\<forall>B\\<in>range (\\<lambda>i. \\<Union>u\\<in>Basis. {axis i u}).\n          A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}\n 3. (sum \\<circ> sum) f\n     (range (\\<lambda>i. \\<Union>u\\<in>Basis. {axis i u})) =\n    (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>Basis. f (axis j i))", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A B u ua ub.\n       \\<lbrakk>u \\<in> Basis;\n        \\<forall>x\\<in>Basis. axis A u \\<noteq> axis B x; ua \\<in> Basis;\n        ub \\<in> Basis; axis A ua = axis B ub\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>A B u ua ub.\n       \\<lbrakk>u \\<in> Basis;\n        \\<forall>x\\<in>Basis. axis B u \\<noteq> axis A x; ua \\<in> Basis;\n        ub \\<in> Basis; axis A ua = axis B ub\\<rbrakk>\n       \\<Longrightarrow> False\n 3. sum (sum f) (range (\\<lambda>i. \\<Union>u\\<in>Basis. {axis i u})) =\n    (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>Basis. f (axis j i))", "apply (simp add: axis_eq_axis nonzero_Basis)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A B u ua ub.\n       \\<lbrakk>u \\<in> Basis;\n        \\<forall>x\\<in>Basis. axis B u \\<noteq> axis A x; ua \\<in> Basis;\n        ub \\<in> Basis; axis A ua = axis B ub\\<rbrakk>\n       \\<Longrightarrow> False\n 2. sum (sum f) (range (\\<lambda>i. \\<Union>u\\<in>Basis. {axis i u})) =\n    (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>Basis. f (axis j i))", "apply (simp add: axis_eq_axis nonzero_Basis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sum f) (range (\\<lambda>i. \\<Union>u\\<in>Basis. {axis i u})) =\n    (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>Basis. f (axis j i))", "apply (subst sum.reindex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj (\\<lambda>i. \\<Union>u\\<in>Basis. {axis i u})\n 2. sum (sum f \\<circ> (\\<lambda>i. \\<Union>u\\<in>Basis. {axis i u})) UNIV =\n    (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>Basis. f (axis j i))", "apply (auto intro!: injI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (\\<Union>u\\<in>Basis. {axis x u}) =\n       (\\<Union>u\\<in>Basis. {axis y u}) \\<Longrightarrow>\n       x = y\n 2. (\\<Sum>x\\<in>UNIV. sum f (\\<Union>u\\<in>Basis. {axis x u})) =\n    (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>Basis. f (axis j i))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>u\\<in>Basis. {axis x_ u}) =\n    (\\<Union>u\\<in>Basis. {axis y_ u}) \\<Longrightarrow>\n    x_ = y_", "apply (auto simp: set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (\\<exists>xb\\<in>Basis. xa = axis x_ xb) =\n       (\\<exists>x\\<in>Basis. xa = axis y_ x) \\<Longrightarrow>\n    x_ = y_", "by (metis (full_types) all_not_in_conv inner_axis_axis inner_eq_zero_iff nonempty_Basis nonzero_Basis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV. sum f (\\<Union>u\\<in>Basis. {axis x u})) =\n    (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>Basis. f (axis j i))", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       sum f (\\<Union>u\\<in>Basis. {axis x u}) =\n       (\\<Sum>i\\<in>Basis. f (axis x i))", "apply (auto )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sum f (\\<Union>u\\<in>Basis. {axis x u}) =\n       (\\<Sum>i\\<in>Basis. f (axis x i))", "apply (rule sum.reindex_cong[OF _ _ refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. inj_on (axis x) Basis\n 2. \\<And>x. (\\<Union>u\\<in>Basis. {axis x u}) = axis x ` Basis", "apply (auto intro!: inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y.\n       \\<lbrakk>xa \\<in> Basis; y \\<in> Basis; axis x xa = axis x y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "using axis_eq_axis"], ["proof (prove)\nusing this:\n  (axis ?i ?x = axis ?j ?y) =\n  (?x = ?y \\<and> ?i = ?j \\<or> ?x = (0::?'a) \\<and> ?y = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<And>x xa y.\n       \\<lbrakk>xa \\<in> Basis; y \\<in> Basis; axis x xa = axis x y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "by blast"], ["", "lemma vec_nth_inner_scaleR_craziness:\n  \"f (x $ i \\<bullet> j) *\\<^sub>R j = (\\<Sum>xa\\<in>UNIV. f (x $ xa \\<bullet> j) *\\<^sub>R axis xa j) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x $ i \\<bullet> j) *\\<^sub>R j =\n    (\\<Sum>xa\\<in>UNIV. f (x $ xa \\<bullet> j) *\\<^sub>R axis xa j) $ i", "by vector (auto simp: axis_def if_distrib scaleR_vec_def sum.delta' cong: if_cong)"], ["", "instantiation vec :: (\"{executable_euclidean_space}\", enum) executable_euclidean_space\nbegin"], ["", "definition Basis_list_vec :: \"('a, 'b) vec list\" where\n  \"Basis_list_vec = concat (map (\\<lambda>n. map (axis n) Basis_list) enum_class.enum)\""], ["", "definition eucl_down_vec :: \"int \\<Rightarrow> ('a, 'b) vec \\<Rightarrow> ('a, 'b) vec\" where\n  \"eucl_down_vec p x = (\\<chi> i. eucl_down p (x $ i))\""], ["", "definition eucl_truncate_down_vec :: \"nat \\<Rightarrow> ('a, 'b) vec \\<Rightarrow> ('a, 'b) vec\" where\n  \"eucl_truncate_down_vec p x = (\\<chi> i. eucl_truncate_down p (x $ i))\""], ["", "definition eucl_truncate_up_vec :: \"nat \\<Rightarrow> ('a, 'b) vec \\<Rightarrow> ('a, 'b) vec\" where\n  \"eucl_truncate_up_vec p x = (\\<chi> i. eucl_truncate_up p (x $ i))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) vec, executable_euclidean_space_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p b.\n       eucl_down p b =\n       (\\<Sum>i\\<in>Basis. round_down p (b \\<bullet> i) *\\<^sub>R i)\n 2. \\<And>q b.\n       eucl_truncate_down q b =\n       (\\<Sum>i\\<in>Basis. truncate_down q (b \\<bullet> i) *\\<^sub>R i)\n 3. \\<And>q b.\n       eucl_truncate_up q b =\n       (\\<Sum>i\\<in>Basis. truncate_up q (b \\<bullet> i) *\\<^sub>R i)\n 4. set Basis_list = Basis\n 5. distinct Basis_list", "show *: \"set (Basis_list::('a, 'b) vec list) = Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set Basis_list = Basis", "unfolding Basis_list_vec_def Basis_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>n. map (axis n) Basis_list) enum_class.enum)) =\n    (\\<Union>i. \\<Union>u\\<in>Basis. {axis i u})", "apply (auto simp: Basis_list_vec_def vec_eq_iff distinct_map Basis_vec_def\n        intro!: distinct_concat inj_onI split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i u.\n       u \\<in> Basis \\<Longrightarrow>\n       \\<exists>x\\<in>set enum_class.enum. axis i u \\<in> axis x ` Basis", "apply (auto simp: Basis_list_vec_def vec_eq_iff distinct_map enum_distinct\n        UNIV_enum[symmetric]\n        intro!: distinct_concat inj_onI split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set Basis_list = Basis\n\ngoal (4 subgoals):\n 1. \\<And>p b.\n       eucl_down p b =\n       (\\<Sum>i\\<in>Basis. round_down p (b \\<bullet> i) *\\<^sub>R i)\n 2. \\<And>q b.\n       eucl_truncate_down q b =\n       (\\<Sum>i\\<in>Basis. truncate_down q (b \\<bullet> i) *\\<^sub>R i)\n 3. \\<And>q b.\n       eucl_truncate_up q b =\n       (\\<Sum>i\\<in>Basis. truncate_up q (b \\<bullet> i) *\\<^sub>R i)\n 4. distinct Basis_list", "have \"length (Basis_list::('a, 'b) vec list) = CARD('b) * DIM('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Basis_list = CARD('b) * DIM('a)", "by (auto simp: Basis_list_vec_def length_concat o_def enum_distinct\n        sum_list_distinct_conv_sum_set UNIV_enum[symmetric])"], ["proof (state)\nthis:\n  length Basis_list = CARD('b) * DIM('a)\n\ngoal (4 subgoals):\n 1. \\<And>p b.\n       eucl_down p b =\n       (\\<Sum>i\\<in>Basis. round_down p (b \\<bullet> i) *\\<^sub>R i)\n 2. \\<And>q b.\n       eucl_truncate_down q b =\n       (\\<Sum>i\\<in>Basis. truncate_down q (b \\<bullet> i) *\\<^sub>R i)\n 3. \\<And>q b.\n       eucl_truncate_up q b =\n       (\\<Sum>i\\<in>Basis. truncate_up q (b \\<bullet> i) *\\<^sub>R i)\n 4. distinct Basis_list", "then"], ["proof (chain)\npicking this:\n  length Basis_list = CARD('b) * DIM('a)", "show \"distinct (Basis_list::('a, 'b) vec list)\""], ["proof (prove)\nusing this:\n  length Basis_list = CARD('b) * DIM('a)\n\ngoal (1 subgoal):\n 1. distinct Basis_list", "using *"], ["proof (prove)\nusing this:\n  length Basis_list = CARD('b) * DIM('a)\n  set Basis_list = Basis\n\ngoal (1 subgoal):\n 1. distinct Basis_list", "by (auto intro!: card_distinct)"], ["proof (state)\nthis:\n  distinct Basis_list\n\ngoal (3 subgoals):\n 1. \\<And>p b.\n       eucl_down p b =\n       (\\<Sum>i\\<in>Basis. round_down p (b \\<bullet> i) *\\<^sub>R i)\n 2. \\<And>q b.\n       eucl_truncate_down q b =\n       (\\<Sum>i\\<in>Basis. truncate_down q (b \\<bullet> i) *\\<^sub>R i)\n 3. \\<And>q b.\n       eucl_truncate_up q b =\n       (\\<Sum>i\\<in>Basis. truncate_up q (b \\<bullet> i) *\\<^sub>R i)", "qed (simp_all only: vector_cart[symmetric] vec_eq_iff\n    eucl_down_vec_def eucl_down_def\n    eucl_truncate_down_vec_def eucl_truncate_down_def\n    eucl_truncate_up_vec_def eucl_truncate_up_def,\n    auto simp: euclidean_vec_componentwise inner_axis Basis_list_vec_def\n    vec_nth_inner_scaleR_craziness\n    intro!: sum.cong[OF refl])"], ["", "end"], ["", "lemma concat_same_lengths_nth:\n  assumes \"\\<And>xs. xs \\<in> set XS \\<Longrightarrow> length xs = N\"\n  assumes \"i < length XS * N\" \"N > 0\"\n  shows \"concat XS ! i = XS ! (i div N) ! (i mod N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat XS ! i = XS ! (i div N) ! (i mod N)", "using assms"], ["proof (prove)\nusing this:\n  ?xs \\<in> set XS \\<Longrightarrow> length ?xs = N\n  i < length XS * N\n  0 < N\n\ngoal (1 subgoal):\n 1. concat XS ! i = XS ! (i div N) ! (i mod N)", "apply (induction XS arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>xs. xs \\<in> set [] \\<Longrightarrow> length xs = N;\n        i < length [] * N; 0 < N\\<rbrakk>\n       \\<Longrightarrow> concat [] ! i = [] ! (i div N) ! (i mod N)\n 2. \\<And>a XS i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>xs.\n                               xs \\<in> set XS \\<Longrightarrow>\n                               length xs = N;\n                    i < length XS * N; 0 < N\\<rbrakk>\n                   \\<Longrightarrow> concat XS ! i =\n                                     XS ! (i div N) ! (i mod N);\n        \\<And>xs. xs \\<in> set (a # XS) \\<Longrightarrow> length xs = N;\n        i < length (a # XS) * N; 0 < N\\<rbrakk>\n       \\<Longrightarrow> concat (a # XS) ! i =\n                         (a # XS) ! (i div N) ! (i mod N)", "apply (auto simp: nth_append nth_Cons split: nat.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a XS i.\n       \\<lbrakk>\\<And>i.\n                   i < length XS * N \\<Longrightarrow>\n                   concat XS ! i = XS ! (i div N) ! (i mod N);\n        \\<And>xs.\n           xs = a \\<or> xs \\<in> set XS \\<Longrightarrow> length xs = N;\n        i < N + length XS * N; 0 < N; i div N = 0; \\<not> i < N\\<rbrakk>\n       \\<Longrightarrow> XS ! ((i - N) div N) ! ((i - N) mod N) =\n                         a ! (i mod N)\n 2. \\<And>a XS i x2.\n       \\<lbrakk>\\<And>i.\n                   i < length XS * N \\<Longrightarrow>\n                   concat XS ! i = XS ! (i div N) ! (i mod N);\n        \\<And>xs.\n           xs = a \\<or> xs \\<in> set XS \\<Longrightarrow> length xs = N;\n        i < N + length XS * N; 0 < N; i div N = Suc x2;\n        \\<not> i < N\\<rbrakk>\n       \\<Longrightarrow> XS ! ((i - N) div N) ! ((i - N) mod N) =\n                         XS ! x2 ! (i mod N)", "apply (simp add: div_eq_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a XS i x2.\n       \\<lbrakk>\\<And>i.\n                   i < length XS * N \\<Longrightarrow>\n                   concat XS ! i = XS ! (i div N) ! (i mod N);\n        \\<And>xs.\n           xs = a \\<or> xs \\<in> set XS \\<Longrightarrow> length xs = N;\n        i < N + length XS * N; 0 < N; i div N = Suc x2;\n        \\<not> i < N\\<rbrakk>\n       \\<Longrightarrow> XS ! ((i - N) div N) ! ((i - N) mod N) =\n                         XS ! x2 ! (i mod N)", "by (metis Suc_inject div_geq mod_geq)"], ["", "lemma concat_map_map_index:\n  shows \"concat (map (\\<lambda>n. map (f n) xs) ys) =\n    map (\\<lambda>i. f (ys ! (i div length xs)) (xs ! (i mod length xs))) [0..<length xs * length ys]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. map (f n) xs) ys) =\n    map (\\<lambda>i. f (ys ! (i div length xs)) (xs ! (i mod length xs)))\n     [0..<length xs * length ys]", "apply (auto intro!: nth_equalityI simp: length_concat o_def sum_list_sum_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       concat (map (\\<lambda>n. map (f n) xs) ys) ! i =\n       map (\\<lambda>i. f (ys ! (i div length xs)) (xs ! (i mod length xs)))\n        [0..<length xs * length ys] !\n       i", "apply (subst concat_same_lengths_nth)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i xsa.\n       \\<lbrakk>i < length ys * length xs;\n        xsa \\<in> set (map (\\<lambda>n. map (f n) xs) ys)\\<rbrakk>\n       \\<Longrightarrow> length xsa = ?N7 i\n 2. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       i < length (map (\\<lambda>n. map (f n) xs) ys) * ?N7 i\n 3. \\<And>i. i < length ys * length xs \\<Longrightarrow> 0 < ?N7 i\n 4. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       map (\\<lambda>n. map (f n) xs) ys ! (i div ?N7 i) ! (i mod ?N7 i) =\n       map (\\<lambda>i. f (ys ! (i div length xs)) (xs ! (i mod length xs)))\n        [0..<length xs * length ys] !\n       i", "apply (auto simp: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       map (\\<lambda>n. map (f n) xs) ys ! (i div length xs) !\n       (i mod length xs) =\n       map (\\<lambda>i. f (ys ! (i div length xs)) (xs ! (i mod length xs)))\n        [0..<length xs * length ys] !\n       i", "apply (subst nth_map_upt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       i < length xs * length ys - 0\n 2. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       map (\\<lambda>n. map (f n) xs) ys ! (i div length xs) !\n       (i mod length xs) =\n       f (ys ! ((0 + i) div length xs)) (xs ! ((0 + i) mod length xs))", "apply (auto simp: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       map (\\<lambda>n. map (f n) xs) ys ! (i div length xs) !\n       (i mod length xs) =\n       f (ys ! (i div length xs)) (xs ! (i mod length xs))", "apply (subst nth_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       i div length xs < length ys\n 2. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       map (f (ys ! (i div length xs))) xs ! (i mod length xs) =\n       f (ys ! (i div length xs)) (xs ! (i mod length xs))", "apply (metis div_eq_0_iff div_mult2_eq mult.commute mult_0 not_less0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       map (f (ys ! (i div length xs))) xs ! (i mod length xs) =\n       f (ys ! (i div length xs)) (xs ! (i mod length xs))", "apply (subst nth_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       i mod length xs < length xs\n 2. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       f (ys ! (i div length xs)) (xs ! (i mod length xs)) =\n       f (ys ! (i div length xs)) (xs ! (i mod length xs))", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ys * length xs \\<Longrightarrow> i mod length xs < length xs", "using gr_implies_not_zero"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. i < length ys * length xs \\<Longrightarrow> i mod length xs < length xs", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys * length xs \\<Longrightarrow>\n       f (ys ! (i div length xs)) (xs ! (i mod length xs)) =\n       f (ys ! (i div length xs)) (xs ! (i mod length xs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. i_ < length ys * length xs \\<Longrightarrow>\n    f (ys ! (i_ div length xs)) (xs ! (i_ mod length xs)) =\n    f (ys ! (i_ div length xs)) (xs ! (i_ mod length xs))", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  sum_list_zip_map:\n  assumes \"distinct xs\"\n  shows \"(\\<Sum>(x, y)\\<leftarrow>zip xs (map g xs). f x y) = (\\<Sum>x\\<in>set xs. f x (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 f xs (map g xs)) = (\\<Sum>x\\<in>set xs. f x (g x))", "by (force simp add: sum_list_distinct_conv_sum_set assms distinct_zipI1 split_beta'\n    in_set_zip in_set_conv_nth inj_on_convol_ident\n    intro!: sum.reindex_cong[where l=\"\\<lambda>x. (x, g x)\"])"], ["", "lemma\n  sum_list_zip_map_of:\n  assumes \"distinct bs\"\n  assumes \"length xs = length bs\"\n  shows \"(\\<Sum>(x, y)\\<leftarrow>zip xs bs. f x y) = (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 f xs bs) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (map2 f xs bs) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "have \"(\\<Sum>(x, y)\\<leftarrow>zip xs bs. f x y) = (\\<Sum>(y, x)\\<leftarrow>zip bs xs. f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 f xs bs) = sum_list (map2 (\\<lambda>y x. f x y) bs xs)", "by (subst zip_commute) (auto simp: o_def split_beta')"], ["proof (state)\nthis:\n  sum_list (map2 f xs bs) = sum_list (map2 (\\<lambda>y x. f x y) bs xs)\n\ngoal (1 subgoal):\n 1. sum_list (map2 f xs bs) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "also"], ["proof (state)\nthis:\n  sum_list (map2 f xs bs) = sum_list (map2 (\\<lambda>y x. f x y) bs xs)\n\ngoal (1 subgoal):\n 1. sum_list (map2 f xs bs) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "have \"\\<dots> = (\\<Sum>(x, y)\\<leftarrow>zip bs (map (the o map_of (zip bs xs)) bs). f y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (\\<lambda>y x. f x y) bs xs) =\n    sum_list\n     (map2 (\\<lambda>x y. f y x) bs\n       (map (the \\<circ> map_of (zip bs xs)) bs))", "proof (rule arg_cong, rule map_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. zip bs xs = zip bs (map (the \\<circ> map_of (zip bs xs)) bs)\n 2. \\<And>x.\n       x \\<in> set (zip bs\n                     (map (the \\<circ> map_of (zip bs xs))\n                       bs)) \\<Longrightarrow>\n       (case x of (y, x) \\<Rightarrow> f x y) =\n       (case x of (x, y) \\<Rightarrow> f y x)", "have \"xs = (map (the \\<circ> map_of (zip bs xs)) bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map (the \\<circ> map_of (zip bs xs)) bs", "using assms"], ["proof (prove)\nusing this:\n  distinct bs\n  length xs = length bs\n\ngoal (1 subgoal):\n 1. xs = map (the \\<circ> map_of (zip bs xs)) bs", "by (auto intro!: nth_equalityI simp: map_nth map_of_zip_nth)"], ["proof (state)\nthis:\n  xs = map (the \\<circ> map_of (zip bs xs)) bs\n\ngoal (2 subgoals):\n 1. zip bs xs = zip bs (map (the \\<circ> map_of (zip bs xs)) bs)\n 2. \\<And>x.\n       x \\<in> set (zip bs\n                     (map (the \\<circ> map_of (zip bs xs))\n                       bs)) \\<Longrightarrow>\n       (case x of (y, x) \\<Rightarrow> f x y) =\n       (case x of (x, y) \\<Rightarrow> f y x)", "then"], ["proof (chain)\npicking this:\n  xs = map (the \\<circ> map_of (zip bs xs)) bs", "show \"zip bs xs = zip bs (map (the \\<circ> map_of (zip bs xs)) bs)\""], ["proof (prove)\nusing this:\n  xs = map (the \\<circ> map_of (zip bs xs)) bs\n\ngoal (1 subgoal):\n 1. zip bs xs = zip bs (map (the \\<circ> map_of (zip bs xs)) bs)", "by simp"], ["proof (state)\nthis:\n  zip bs xs = zip bs (map (the \\<circ> map_of (zip bs xs)) bs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (zip bs\n                     (map (the \\<circ> map_of (zip bs xs))\n                       bs)) \\<Longrightarrow>\n       (case x of (y, x) \\<Rightarrow> f x y) =\n       (case x of (x, y) \\<Rightarrow> f y x)", "qed auto"], ["proof (state)\nthis:\n  sum_list (map2 (\\<lambda>y x. f x y) bs xs) =\n  sum_list\n   (map2 (\\<lambda>x y. f y x) bs (map (the \\<circ> map_of (zip bs xs)) bs))\n\ngoal (1 subgoal):\n 1. sum_list (map2 f xs bs) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "also"], ["proof (state)\nthis:\n  sum_list (map2 (\\<lambda>y x. f x y) bs xs) =\n  sum_list\n   (map2 (\\<lambda>x y. f y x) bs (map (the \\<circ> map_of (zip bs xs)) bs))\n\ngoal (1 subgoal):\n 1. sum_list (map2 f xs bs) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "have \"\\<dots> = (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (\\<lambda>x y. f y x) bs\n       (map (the \\<circ> map_of (zip bs xs)) bs)) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "using assms(1)"], ["proof (prove)\nusing this:\n  distinct bs\n\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (\\<lambda>x y. f y x) bs\n       (map (the \\<circ> map_of (zip bs xs)) bs)) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "by (subst sum_list_zip_map) (auto simp: o_def)"], ["proof (state)\nthis:\n  sum_list\n   (map2 (\\<lambda>x y. f y x) bs\n     (map (the \\<circ> map_of (zip bs xs)) bs)) =\n  (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)\n\ngoal (1 subgoal):\n 1. sum_list (map2 f xs bs) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "finally"], ["proof (chain)\npicking this:\n  sum_list (map2 f xs bs) =\n  (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map2 f xs bs) =\n  (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)\n\ngoal (1 subgoal):\n 1. sum_list (map2 f xs bs) =\n    (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)", "."], ["proof (state)\nthis:\n  sum_list (map2 f xs bs) =\n  (\\<Sum>x\\<in>set bs. f (the (map_of (zip bs xs) x)) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_nth_matrix:\n  \"vec_nth (vec_nth (matrix y) i) j = vec_nth (y (axis j 1)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix y $ i $ j = y (axis j (1::'a)) $ i", "unfolding matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. y (axis j (1::'a)) $ i) $ i $ j = y (axis j (1::'a)) $ i", "by simp"], ["", "lemma matrix_eqI:\n  assumes \"\\<And>x. x \\<in> Basis \\<Longrightarrow> A *v x = B *v x\"\n  shows \"(A::real^'n^'n) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "apply vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia. A $ i $ ia = B $ i $ ia", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> Basis \\<Longrightarrow> A *v ?x = B *v ?x\n\ngoal (1 subgoal):\n 1. \\<forall>i ia. A $ i $ ia = B $ i $ ia", "apply (auto simp: Basis_vec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       (\\<And>x.\n           \\<exists>xa. x = axis xa 1 \\<Longrightarrow>\n           A *v x = B *v x) \\<Longrightarrow>\n       A $ i $ ia = B $ i $ ia", "by (metis cart_eq_inner_axis matrix_vector_mul_component)"], ["", "lemma matrix_columnI:\n  assumes \"\\<And>i. column i A = column i B\"\n  shows \"(A::real^'n^'n) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "using assms"], ["proof (prove)\nusing this:\n  column ?i A = column ?i B\n\ngoal (1 subgoal):\n 1. A = B", "apply vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. column i A = column i B) \\<Longrightarrow>\n    \\<forall>i ia. A $ i $ ia = B $ i $ ia", "apply (auto simp: column_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       (\\<And>i.\n           (\\<lambda>ia. A $ ia $ i) =\n           (\\<lambda>ia. B $ ia $ i)) \\<Longrightarrow>\n       A $ i $ ia = B $ i $ ia", "apply vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       (\\<And>i.\n           (\\<lambda>ia. A $ ia $ i) =\n           (\\<lambda>ia. B $ ia $ i)) \\<Longrightarrow>\n       A $ i $ ia = B $ i $ ia", "by (metis iso_tuple_UNIV_I vec_lambda_inject)"], ["", "lemma\n  vec_nth_Basis:\n  fixes x::\"real^'n\"\n  shows \"x \\<in> Basis \\<Longrightarrow> vec_nth x i = (if x = axis i 1 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Basis \\<Longrightarrow> x $ i = (if x = axis i 1 then 1 else 0)", "apply (auto simp: Basis_vec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x = axis xa 1; axis xa 1 \\<noteq> axis i 1\\<rbrakk>\n       \\<Longrightarrow> axis xa 1 $ i = 0", "by (metis cart_eq_inner_axis inner_axis_axis)"], ["", "lemma vec_nth_eucl_of_list_eq: \"length M = CARD('n) \\<Longrightarrow>\n  vec_nth (eucl_of_list M::real^'n::enum) i = M ! index Basis_list (axis i (1::real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) \\<Longrightarrow>\n    eucl_of_list M $ i = M ! index Basis_list (axis i 1)", "apply (auto simp: eucl_of_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) \\<Longrightarrow>\n    sum_list (map2 (*\\<^sub>R) M Basis_list) $ i =\n    M ! index Basis_list (axis i 1)", "apply (subst sum_list_zip_map_of)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length M = CARD('n) \\<Longrightarrow> distinct Basis_list\n 2. length M = CARD('n) \\<Longrightarrow> length M = length Basis_list\n 3. length M = CARD('n) \\<Longrightarrow>\n    (\\<Sum>x\\<in>set Basis_list.\n       the (map_of (zip Basis_list M) x) *\\<^sub>R x) $\n    i =\n    M ! index Basis_list (axis i 1)", "apply (auto intro!: distinct_zipI2 simp: split_beta')"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Basis. the (map_of (zip Basis_list M) x) * x $ i) =\n    M ! index Basis_list (axis i 1)", "apply (subst sum.cong[OF refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length M = CARD('n); x \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M) x) * x $ i = ?h8 x\n 2. length M = CARD('n) \\<Longrightarrow>\n    sum ?h8 Basis = M ! index Basis_list (axis i 1)", "apply (subst vec_nth_Basis)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length M = CARD('n); x \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Basis\n 2. \\<And>x.\n       \\<lbrakk>length M = CARD('n); x \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M) x) *\n                         (if x = axis i 1 then 1 else 0) =\n                         ?h10 x x\n 3. length M = CARD('n) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Basis. ?h10 x x) = M ! index Basis_list (axis i 1)", "apply (force simp: set_zip)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length M = CARD('n); x \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M) x) *\n                         (if x = axis i 1 then 1 else 0) =\n                         ?h10 x x\n 2. length M = CARD('n) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Basis. ?h10 x x) = M ! index Basis_list (axis i 1)", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Basis.\n       the (map_of (zip Basis_list M) x) *\n       (if x = axis i 1 then 1 else 0)) =\n    M ! index Basis_list (axis i 1)", "apply (auto simp: if_distrib sum.delta cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) \\<Longrightarrow>\n    the (map_of (zip Basis_list M) (axis i 1)) =\n    M ! index Basis_list (axis i 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) \\<Longrightarrow>\n    the (map_of (zip Basis_list M) (axis i 1)) =\n    M ! index Basis_list (axis i 1)", "apply (cases \"map_of (zip Basis_list M) (axis i 1::real^'n::enum)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length M = CARD('n);\n     map_of (zip Basis_list M) (axis i 1) = None\\<rbrakk>\n    \\<Longrightarrow> the (map_of (zip Basis_list M) (axis i 1)) =\n                      M ! index Basis_list (axis i 1)\n 2. \\<And>a.\n       \\<lbrakk>length M = CARD('n);\n        map_of (zip Basis_list M) (axis i 1) = Some a\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M) (axis i 1)) =\n                         M ! index Basis_list (axis i 1)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i 1)) =\n    M ! index Basis_list (axis i 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i 1)) =\n    M ! index Basis_list (axis i 1)", "have \"fst ` set (zip Basis_list M) = (Basis::(real^'n::enum) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (zip Basis_list M) = Basis", "using prems"], ["proof (prove)\nusing this:\n  length M = CARD('n)\n  map_of (zip Basis_list M) (axis i 1) = None\n\ngoal (1 subgoal):\n 1. fst ` set (zip Basis_list M) = Basis", "by (auto simp: in_set_zip)"], ["proof (state)\nthis:\n  fst ` set (zip Basis_list M) = Basis\n\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i 1)) =\n    M ! index Basis_list (axis i 1)", "then"], ["proof (chain)\npicking this:\n  fst ` set (zip Basis_list M) = Basis", "show ?thesis"], ["proof (prove)\nusing this:\n  fst ` set (zip Basis_list M) = Basis\n\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i 1)) =\n    M ! index Basis_list (axis i 1)", "using prems"], ["proof (prove)\nusing this:\n  fst ` set (zip Basis_list M) = Basis\n  length M = CARD('n)\n  map_of (zip Basis_list M) (axis i 1) = None\n\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i 1)) =\n    M ! index Basis_list (axis i 1)", "by (subst (asm) map_of_eq_None_iff) simp"], ["proof (state)\nthis:\n  the (map_of (zip Basis_list M) (axis i 1)) =\n  M ! index Basis_list (axis i 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length M = CARD('n);\n        map_of (zip Basis_list M) (axis i 1) = Some a\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M) (axis i 1)) =\n                         M ! index Basis_list (axis i 1)", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length M = CARD('n);\n     map_of (zip Basis_list M) (axis i 1) = Some a\\<rbrakk>\n    \\<Longrightarrow> the (map_of (zip Basis_list M) (axis i 1)) =\n                      M ! index Basis_list (axis i 1)", "apply (auto simp: in_set_zip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>length M = CARD('n); Basis_list ! n = axis i 1;\n        n < CARD('n); a = M ! n\\<rbrakk>\n       \\<Longrightarrow> M ! n = M ! index Basis_list (axis i 1)", "subgoal premises prems for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. M ! n = M ! index Basis_list (axis i 1)", "by (metis DIM_cart DIM_real index_Basis_list_nth mult.right_neutral prems(2) prems(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma index_Basis_list_axis1: \"index Basis_list (axis i (1::real)) = index enum_class.enum i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index Basis_list (axis i 1) = index enum_class.enum i", "apply (auto simp: Basis_list_vec_def Basis_list_real_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (map (\\<lambda>n. axis n 1) enum_class.enum) (axis i 1) =\n    index enum_class.enum i", "apply (subst index_map_inj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj (\\<lambda>n. axis n 1)\n 2. index enum_class.enum i = index enum_class.enum i", "by (auto intro!: injI simp: axis_eq_axis)"], ["", "lemma vec_nth_eq_list_of_eucl1:\n  \"(vec_nth (M::real^'n::enum) i) = list_of_eucl M ! (index enum_class.enum i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ i = list_of_eucl M ! index enum_class.enum i", "apply (subst eucl_of_list_list_of_eucl[of M, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (list_of_eucl M) $ i =\n    list_of_eucl M ! index enum_class.enum i", "apply (subst vec_nth_eucl_of_list_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (list_of_eucl M) = CARD('n)\n 2. list_of_eucl M ! index Basis_list (axis i 1) =\n    list_of_eucl M ! index enum_class.enum i", "unfolding index_Basis_list_axis1"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (list_of_eucl M) = CARD('n)\n 2. list_of_eucl M ! index enum_class.enum i =\n    list_of_eucl M ! index enum_class.enum i", "by auto"], ["", "lemma enum_3[simp]: \"(enum_class.enum::3 list) = [0, 1, 2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_class.enum = [0, 1, 2]", "by code_simp+"], ["", "lemma three_eq_zero: \"(3::3) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 = 0", "by simp"], ["", "lemma forall_3': \"(\\<forall>i::3. P i) \\<longleftrightarrow> P 0 \\<and> P 1 \\<and> P 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. P i) = (P 0 \\<and> P 1 \\<and> P 2)", "using forall_3 three_eq_zero"], ["proof (prove)\nusing this:\n  (\\<forall>i. ?P i) = (?P 1 \\<and> ?P 2 \\<and> ?P 3)\n  3 = 0\n\ngoal (1 subgoal):\n 1. (\\<forall>i. P i) = (P 0 \\<and> P 1 \\<and> P 2)", "by auto"], ["", "lemma euclidean_eq_list_of_euclI: \"x = y\" if \"list_of_eucl x = list_of_eucl y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  list_of_eucl x = list_of_eucl y\n\ngoal (1 subgoal):\n 1. x = y", "by (metis eucl_of_list_list_of_eucl)"], ["", "lemma axis_one_neq_zero[simp]: \"axis xa (1::'a::zero_neq_one) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. axis xa (1::'a) \\<noteq> 0", "by (auto simp: axis_def vec_eq_iff)"], ["", "lemma eucl_of_list_vec_nth3[simp]:\n  \"(eucl_of_list [g, h, i]::real^3) $ 0 = g\"\n  \"(eucl_of_list [g, h, i]::real^3) $ 1 = h\"\n  \"(eucl_of_list [g, h, i]::real^3) $ 2 = i\"\n  \"(eucl_of_list [g, h, i]::real^3) $ 3 = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eucl_of_list [g, h, i] $ 0 = g &&& eucl_of_list [g, h, i] $ 1 = h) &&&\n    eucl_of_list [g, h, i] $ 2 = i &&& eucl_of_list [g, h, i] $ 3 = g", "by (auto simp: cart_eq_inner_axis eucl_of_list_inner vec_nth_eq_list_of_eucl1 index_Basis_list_axis1)"], ["", "type_synonym R3 = \"real*real*real\""], ["", "lemma Basis_list_R3: \"Basis_list = [(1,0,0), (0, 1, 0), (0, 0, 1)::R3]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Basis_list = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]", "by (auto simp: Basis_list_prod_def Basis_list_real_def zero_prod_def)"], ["", "lemma Basis_list_vec3: \"Basis_list = [axis 0 1::real^3, axis 1 1, axis 2 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Basis_list = [axis 0 1, axis 1 1, axis 2 1]", "by (auto simp: Basis_list_vec_def Basis_list_real_def)"], ["", "lemma eucl_of_list3[simp]: \"eucl_of_list [a, b, c] = (a, b, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list [a, b, c] = (a, b, c)", "by (auto simp: eucl_of_list_inner Basis_list_vec_def zero_prod_def\n      Basis_prod_def Basis_list_vec3 Basis_list_R3\n      intro!: euclidean_eqI[where 'a=R3])"], ["", "subsection \\<open>Bounded Linear Functions\\<close>"], ["", "subsection \\<open>bounded linear functions\\<close>"], ["", "locale blinfun_syntax\nbegin"], ["", "no_notation vec_nth (infixl \"$\" 90)"], ["", "notation blinfun_apply (infixl \"$\" 999)"], ["", "end"], ["", "lemma bounded_linear_via_derivative:\n  fixes f::\"'a::real_normed_vector \\<Rightarrow> 'b::euclidean_space \\<Rightarrow>\\<^sub>L 'c::real_normed_vector\" \\<comment> \\<open>TODO: generalize?\\<close>\n  assumes \"\\<And>i. ((\\<lambda>x. blinfun_apply (f x) i) has_derivative (\\<lambda>x. f' y x i)) (at y)\"\n  shows \"bounded_linear (f' y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "interpret linear \"f' y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (f' y x)", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b1 b2. f' y x (b1 + b2) = f' y x b1 + f' y x b2\n 2. \\<And>r b. f' y x (r *\\<^sub>R b) = r *\\<^sub>R f' y x b", "case (1 v w)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>b1 b2. f' y x (b1 + b2) = f' y x b1 + f' y x b2\n 2. \\<And>r b. f' y x (r *\\<^sub>R b) = r *\\<^sub>R f' y x b", "from has_derivative_unique[OF assms[of \"v + w\", unfolded blinfun.bilinear_simps]\n      has_derivative_add[OF assms[of v] assms[of w]], THEN fun_cong, of x]"], ["proof (chain)\npicking this:\n  f' y x (v + w) = f' y x v + f' y x w", "show ?case"], ["proof (prove)\nusing this:\n  f' y x (v + w) = f' y x v + f' y x w\n\ngoal (1 subgoal):\n 1. f' y x (v + w) = f' y x v + f' y x w", "."], ["proof (state)\nthis:\n  f' y x (v + w) = f' y x v + f' y x w\n\ngoal (1 subgoal):\n 1. \\<And>r b. f' y x (r *\\<^sub>R b) = r *\\<^sub>R f' y x b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r b. f' y x (r *\\<^sub>R b) = r *\\<^sub>R f' y x b", "case (2 r v)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>r b. f' y x (r *\\<^sub>R b) = r *\\<^sub>R f' y x b", "from has_derivative_unique[OF assms[of \"r *\\<^sub>R v\", unfolded blinfun.bilinear_simps]\n      has_derivative_scaleR_right[OF assms[of v], of r], THEN fun_cong, of x]"], ["proof (chain)\npicking this:\n  f' y x (r *\\<^sub>R v) = r *\\<^sub>R f' y x v", "show ?case"], ["proof (prove)\nusing this:\n  f' y x (r *\\<^sub>R v) = r *\\<^sub>R f' y x v\n\ngoal (1 subgoal):\n 1. f' y x (r *\\<^sub>R v) = r *\\<^sub>R f' y x v", "."], ["proof (state)\nthis:\n  f' y x (r *\\<^sub>R v) = r *\\<^sub>R f' y x v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "let ?bnd = \"\\<Sum>i\\<in>Basis. norm (f' y x i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "have \"f' y x v = (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R f' y x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' y x v = (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R f' y x i)", "by (subst euclidean_representation[symmetric]) (simp add: sum scaleR)"], ["proof (state)\nthis:\n  f' y x v = (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R f' y x i)\n\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "also"], ["proof (state)\nthis:\n  f' y x v = (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R f' y x i)\n\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "have \"norm \\<dots> \\<le> norm v * ?bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R f' y x i)\n    \\<le> norm v * (\\<Sum>i\\<in>Basis. norm (f' y x i))", "by (auto intro!: order.trans[OF norm_sum] sum_mono mult_right_mono\n        simp: sum_distrib_left Basis_le_norm)"], ["proof (state)\nthis:\n  norm (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R f' y x i)\n  \\<le> norm v * (\\<Sum>i\\<in>Basis. norm (f' y x i))\n\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "finally"], ["proof (chain)\npicking this:\n  norm (f' y x v) \\<le> norm v * (\\<Sum>i\\<in>Basis. norm (f' y x i))", "have \"norm (f' y x v) \\<le> norm v * ?bnd\""], ["proof (prove)\nusing this:\n  norm (f' y x v) \\<le> norm v * (\\<Sum>i\\<in>Basis. norm (f' y x i))\n\ngoal (1 subgoal):\n 1. norm (f' y x v) \\<le> norm v * (\\<Sum>i\\<in>Basis. norm (f' y x i))", "."], ["proof (state)\nthis:\n  norm (f' y x v) \\<le> norm v * (\\<Sum>i\\<in>Basis. norm (f' y x i))\n\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "}"], ["proof (state)\nthis:\n  norm (f' y x ?v2) \\<le> norm ?v2 * (\\<Sum>i\\<in>Basis. norm (f' y x i))\n\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "then"], ["proof (chain)\npicking this:\n  norm (f' y x ?v2) \\<le> norm ?v2 * (\\<Sum>i\\<in>Basis. norm (f' y x i))", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (f' y x ?v2) \\<le> norm ?v2 * (\\<Sum>i\\<in>Basis. norm (f' y x i))\n\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "by unfold_locales auto"], ["proof (state)\nthis:\n  bounded_linear (f' y x)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition blinfun_scaleR::\"('a::real_normed_vector \\<Rightarrow>\\<^sub>L real) \\<Rightarrow> 'b::real_normed_vector \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>L 'b)\"\n  where \"blinfun_scaleR a b = blinfun_scaleR_left b o\\<^sub>L a\""], ["", "lemma blinfun_scaleR_transfer[transfer_rule]:\n  \"rel_fun (pcr_blinfun (=) (=)) (rel_fun (=) (pcr_blinfun (=) (=)))\n    (\\<lambda>a b c. a c *\\<^sub>R b) blinfun_scaleR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (pcr_blinfun (=) (=)) (rel_fun (=) (pcr_blinfun (=) (=)))\n     (\\<lambda>a b c. a c *\\<^sub>R b) blinfun_scaleR", "by (auto simp: blinfun_scaleR_def rel_fun_def pcr_blinfun_def cr_blinfun_def OO_def)"], ["", "lemma blinfun_scaleR_rep_eq[simp]:\n  \"blinfun_scaleR a b c = a c *\\<^sub>R b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_apply (blinfun_scaleR a b) c = blinfun_apply a c *\\<^sub>R b", "by (simp add: blinfun_scaleR_def)"], ["", "lemma bounded_linear_blinfun_scaleR: \"bounded_linear (blinfun_scaleR a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (blinfun_scaleR a)", "unfolding blinfun_scaleR_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (\\<lambda>b. blinfun_scaleR_left b o\\<^sub>L a)", "by (auto intro!: bounded_linear_intros)"], ["", "lemma blinfun_scaleR_has_derivative[derivative_intros]:\n  assumes \"(f has_derivative f') (at x within s)\"\n  shows \"((\\<lambda>x. blinfun_scaleR a (f x)) has_derivative (\\<lambda>x. blinfun_scaleR a (f' x))) (at x within s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. blinfun_scaleR a (f x)) has_derivative\n     (\\<lambda>x. blinfun_scaleR a (f' x)))\n     (at x within s)", "using bounded_linear_blinfun_scaleR assms"], ["proof (prove)\nusing this:\n  bounded_linear (blinfun_scaleR ?a)\n  (f has_derivative f') (at x within s)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. blinfun_scaleR a (f x)) has_derivative\n     (\\<lambda>x. blinfun_scaleR a (f' x)))\n     (at x within s)", "by (rule bounded_linear.has_derivative)"], ["", "lemma blinfun_componentwise:\n  fixes f::\"'a::real_normed_vector \\<Rightarrow> 'b::euclidean_space \\<Rightarrow>\\<^sub>L 'c::real_normed_vector\"\n  shows \"f = (\\<lambda>x. \\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f =\n    (\\<lambda>x.\n        \\<Sum>i\\<in>Basis.\n          blinfun_scaleR (blinfun_inner_left i) (blinfun_apply (f x) i))", "by (auto intro!: blinfun_eqI\n    simp: blinfun.sum_left euclidean_representation blinfun.scaleR_right[symmetric]\n      blinfun.sum_right[symmetric])"], ["", "lemma\n  blinfun_has_derivative_componentwiseI:\n  fixes f::\"'a::real_normed_vector \\<Rightarrow> 'b::euclidean_space \\<Rightarrow>\\<^sub>L 'c::real_normed_vector\"\n  assumes \"\\<And>i. i \\<in> Basis \\<Longrightarrow> ((\\<lambda>x. f x i) has_derivative blinfun_apply (f' i)) (at x)\"\n  shows \"(f has_derivative (\\<lambda>x. \\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f' i x))) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_derivative\n     (\\<lambda>x.\n         \\<Sum>i\\<in>Basis.\n           blinfun_scaleR (blinfun_inner_left i) (blinfun_apply (f' i) x)))\n     (at x)", "by (subst blinfun_componentwise) (force intro: derivative_eq_intros assms simp: blinfun.bilinear_simps)"], ["", "lemma\n  has_derivative_BlinfunI:\n  fixes f::\"'a::real_normed_vector \\<Rightarrow> 'b::euclidean_space \\<Rightarrow>\\<^sub>L 'c::real_normed_vector\"\n  assumes \"\\<And>i. ((\\<lambda>x. f x i) has_derivative (\\<lambda>x. f' y x i)) (at y)\"\n  shows \"(f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "have 1: \"f = (\\<lambda>x. \\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f =\n    (\\<lambda>x.\n        \\<Sum>i\\<in>Basis.\n          blinfun_scaleR (blinfun_inner_left i) (blinfun_apply (f x) i))", "by (rule blinfun_componentwise)"], ["proof (state)\nthis:\n  f =\n  (\\<lambda>x.\n      \\<Sum>i\\<in>Basis.\n        blinfun_scaleR (blinfun_inner_left i) (blinfun_apply (f x) i))\n\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "moreover"], ["proof (state)\nthis:\n  f =\n  (\\<lambda>x.\n      \\<Sum>i\\<in>Basis.\n        blinfun_scaleR (blinfun_inner_left i) (blinfun_apply (f x) i))\n\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "have 2: \"(\\<dots> has_derivative (\\<lambda>x. \\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f' y x i))) (at y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>i\\<in>Basis.\n           blinfun_scaleR (blinfun_inner_left i)\n            (blinfun_apply (f x) i)) has_derivative\n     (\\<lambda>x.\n         \\<Sum>i\\<in>Basis.\n           blinfun_scaleR (blinfun_inner_left i) (f' y x i)))\n     (at y)", "by (force intro: assms derivative_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>i\\<in>Basis.\n         blinfun_scaleR (blinfun_inner_left i)\n          (blinfun_apply (f x) i)) has_derivative\n   (\\<lambda>x.\n       \\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f' y x i)))\n   (at y)\n\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>i\\<in>Basis.\n         blinfun_scaleR (blinfun_inner_left i)\n          (blinfun_apply (f x) i)) has_derivative\n   (\\<lambda>x.\n       \\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f' y x i)))\n   (at y)\n\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "interpret f': bounded_linear \"f' y x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "by (rule bounded_linear_via_derivative) (rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "have 3: \"(\\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f' y x i)) i = f' y x i\" for x i"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_apply\n     (\\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f' y x i))\n     i =\n    f' y x i", "by (auto simp: if_distrib if_distribR blinfun.bilinear_simps\n      f'.scaleR[symmetric] f'.sum[symmetric] euclidean_representation\n      intro!: blinfun_euclidean_eqI)"], ["proof (state)\nthis:\n  blinfun_apply\n   (\\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (f' y ?x i))\n   ?i =\n  f' y ?x ?i\n\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "have 4: \"blinfun_apply (Blinfun (f' y x)) = f' y x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_apply (Blinfun (f' y x)) = f' y x", "apply (subst bounded_linear_Blinfun_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bounded_linear (f' y x)\n 2. f' y x = f' y x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (f' y x)", "by unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. f' y x = f' y x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. f' y x = f' y x", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  blinfun_apply (Blinfun (f' y ?x)) = f' y ?x\n\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)", "apply (subst 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>i\\<in>Basis.\n           blinfun_scaleR (blinfun_inner_left i)\n            (blinfun_apply (f x) i)) has_derivative\n     (\\<lambda>x. Blinfun (f' y x)))\n     (at y)", "apply (rule 2[THEN has_derivative_eq_rhs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>i\\<in>Basis.\n          blinfun_scaleR (blinfun_inner_left i) (f' y x i)) =\n    (\\<lambda>x. Blinfun (f' y x))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>i\\<in>Basis.\n          blinfun_scaleR (blinfun_inner_left i) (f' y x i)) =\n       Blinfun (f' y x)", "apply (rule blinfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       blinfun_apply\n        (\\<Sum>i\\<in>Basis.\n           blinfun_scaleR (blinfun_inner_left i) (f' y x i))\n        i =\n       blinfun_apply (Blinfun (f' y x)) i", "apply (subst 3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i. f' y x i = blinfun_apply (Blinfun (f' y x)) i", "apply (subst 4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i. f' y x i = f' y x i", "apply (rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (f has_derivative (\\<lambda>x. Blinfun (f' y x))) (at y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  has_derivative_Blinfun:\n  assumes \"(f has_derivative f') F\"\n  shows \"(f has_derivative Blinfun f') F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_derivative blinfun_apply (Blinfun f')) F", "using assms"], ["proof (prove)\nusing this:\n  (f has_derivative f') F\n\ngoal (1 subgoal):\n 1. (f has_derivative blinfun_apply (Blinfun f')) F", "by (subst bounded_linear_Blinfun_apply) auto"], ["", "lift_definition flip_blinfun::\n  \"('a::real_normed_vector \\<Rightarrow>\\<^sub>L 'b::real_normed_vector \\<Rightarrow>\\<^sub>L 'c::real_normed_vector) \\<Rightarrow> 'b \\<Rightarrow>\\<^sub>L 'a \\<Rightarrow>\\<^sub>L 'c\" is\n  \"\\<lambda>f x y. f y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       inf (pred_fun top bounded_linear) bounded_bilinear\n        fun \\<Longrightarrow>\n       inf (pred_fun top bounded_linear) bounded_bilinear\n        (\\<lambda>x y. fun y x)", "using bounded_bilinear.bounded_linear_left bounded_bilinear.bounded_linear_right bounded_bilinear.flip"], ["proof (prove)\nusing this:\n  bounded_bilinear ?prod \\<Longrightarrow>\n  bounded_linear (\\<lambda>a. ?prod a ?b)\n  bounded_bilinear ?prod \\<Longrightarrow> bounded_linear (?prod ?a)\n  bounded_bilinear ?prod \\<Longrightarrow>\n  bounded_bilinear (\\<lambda>x y. ?prod y x)\n\ngoal (1 subgoal):\n 1. \\<And>fun.\n       inf (pred_fun top bounded_linear) bounded_bilinear\n        fun \\<Longrightarrow>\n       inf (pred_fun top bounded_linear) bounded_bilinear\n        (\\<lambda>x y. fun y x)", "by auto"], ["", "lemma flip_blinfun_apply[simp]: \"flip_blinfun f a b = f b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_apply (blinfun_apply (flip_blinfun f) a) b =\n    blinfun_apply (blinfun_apply f b) a", "by transfer simp"], ["", "lemma le_norm_blinfun:\n  shows \"norm (blinfun_apply f x) / norm x \\<le> norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (blinfun_apply f x) / norm x \\<le> norm f", "by transfer (rule le_onorm)"], ["", "lemma norm_flip_blinfun[simp]: \"norm (flip_blinfun x) = norm x\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (flip_blinfun x) = norm x", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. norm (flip_blinfun x) \\<le> norm x\n 2. norm x \\<le> norm (flip_blinfun x)", "from order_trans[OF norm_blinfun, OF mult_right_mono, OF norm_blinfun, OF norm_ge_zero, of x]"], ["proof (chain)\npicking this:\n  norm (blinfun_apply (blinfun_apply x ?x3) ?x1)\n  \\<le> norm x * norm ?x3 * norm ?x1", "show \"?l \\<le> ?r\""], ["proof (prove)\nusing this:\n  norm (blinfun_apply (blinfun_apply x ?x3) ?x1)\n  \\<le> norm x * norm ?x3 * norm ?x1\n\ngoal (1 subgoal):\n 1. norm (flip_blinfun x) \\<le> norm x", "by (auto intro!: norm_blinfun_bound simp: ac_simps)"], ["proof (state)\nthis:\n  norm (flip_blinfun x) \\<le> norm x\n\ngoal (1 subgoal):\n 1. norm x \\<le> norm (flip_blinfun x)", "have \"norm (x a b) \\<le> norm (flip_blinfun x) * norm a * norm b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (blinfun_apply (blinfun_apply x a) b)\n    \\<le> norm (flip_blinfun x) * norm a * norm b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (blinfun_apply (blinfun_apply x a) b)\n    \\<le> norm (flip_blinfun x) * norm a * norm b", "have \"norm (x a b) / norm a \\<le> norm (flip_blinfun x b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (blinfun_apply (blinfun_apply x a) b) / norm a\n    \\<le> norm (blinfun_apply (flip_blinfun x) b)", "by (rule order_trans[OF _ le_norm_blinfun]) auto"], ["proof (state)\nthis:\n  norm (blinfun_apply (blinfun_apply x a) b) / norm a\n  \\<le> norm (blinfun_apply (flip_blinfun x) b)\n\ngoal (1 subgoal):\n 1. norm (blinfun_apply (blinfun_apply x a) b)\n    \\<le> norm (flip_blinfun x) * norm a * norm b", "also"], ["proof (state)\nthis:\n  norm (blinfun_apply (blinfun_apply x a) b) / norm a\n  \\<le> norm (blinfun_apply (flip_blinfun x) b)\n\ngoal (1 subgoal):\n 1. norm (blinfun_apply (blinfun_apply x a) b)\n    \\<le> norm (flip_blinfun x) * norm a * norm b", "have \"\\<dots> \\<le> norm (flip_blinfun x) * norm b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (blinfun_apply (flip_blinfun x) b)\n    \\<le> norm (flip_blinfun x) * norm b", "by (rule norm_blinfun)"], ["proof (state)\nthis:\n  norm (blinfun_apply (flip_blinfun x) b)\n  \\<le> norm (flip_blinfun x) * norm b\n\ngoal (1 subgoal):\n 1. norm (blinfun_apply (blinfun_apply x a) b)\n    \\<le> norm (flip_blinfun x) * norm a * norm b", "finally"], ["proof (chain)\npicking this:\n  norm (blinfun_apply (blinfun_apply x a) b) / norm a\n  \\<le> norm (flip_blinfun x) * norm b", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (blinfun_apply (blinfun_apply x a) b) / norm a\n  \\<le> norm (flip_blinfun x) * norm b\n\ngoal (1 subgoal):\n 1. norm (blinfun_apply (blinfun_apply x a) b)\n    \\<le> norm (flip_blinfun x) * norm a * norm b", "by (auto simp add: divide_simps blinfun.bilinear_simps algebra_simps split: if_split_asm)"], ["proof (state)\nthis:\n  norm (blinfun_apply (blinfun_apply x a) b)\n  \\<le> norm (flip_blinfun x) * norm a * norm b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (blinfun_apply (blinfun_apply x ?a) ?b)\n  \\<le> norm (flip_blinfun x) * norm ?a * norm ?b\n\ngoal (1 subgoal):\n 1. norm x \\<le> norm (flip_blinfun x)", "then"], ["proof (chain)\npicking this:\n  norm (blinfun_apply (blinfun_apply x ?a) ?b)\n  \\<le> norm (flip_blinfun x) * norm ?a * norm ?b", "show \"?r \\<le> ?l\""], ["proof (prove)\nusing this:\n  norm (blinfun_apply (blinfun_apply x ?a) ?b)\n  \\<le> norm (flip_blinfun x) * norm ?a * norm ?b\n\ngoal (1 subgoal):\n 1. norm x \\<le> norm (flip_blinfun x)", "by (auto intro!: norm_blinfun_bound)"], ["proof (state)\nthis:\n  norm x \\<le> norm (flip_blinfun x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_linear_flip_blinfun[bounded_linear]: \"bounded_linear flip_blinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear flip_blinfun", "by unfold_locales (auto simp: blinfun.bilinear_simps intro!: blinfun_eqI exI[where x=1])"], ["", "lemma dist_swap2_swap2[simp]: \"dist (flip_blinfun f) (flip_blinfun g) = dist f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (flip_blinfun f) (flip_blinfun g) = dist f g", "by (metis (no_types) bounded_linear_flip_blinfun dist_blinfun_def linear_simps(2)\n    norm_flip_blinfun)"], ["", "context includes blinfun.lifting begin"], ["", "lift_definition blinfun_of_vmatrix::\"(real^'m^'n) \\<Rightarrow> ((real^('m::finite)) \\<Rightarrow>\\<^sub>L (real^('n::finite)))\" is\n  \"matrix_vector_mult:: ((real, 'm) vec, 'n) vec \\<Rightarrow> ((real, 'm) vec \\<Rightarrow> (real, 'n) vec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vec. bounded_linear ((*v) vec)", "unfolding linear_linear"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vec. linear ((*v) vec)", "by (rule matrix_vector_mul_linear)"], ["", "lemma matrix_blinfun_of_vmatrix[simp]: \"matrix (blinfun_of_vmatrix M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix (blinfun_apply (blinfun_of_vmatrix M)) = M", "apply vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       matrix (blinfun_apply (blinfun_of_vmatrix M)) $ i $ ia = M $ i $ ia", "apply (auto simp: matrix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       blinfun_apply (blinfun_of_vmatrix M) (axis ia 1) $ i = M $ i $ ia", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia M. (M *v axis ia 1) $ i = M $ i $ ia", "by (metis cart_eq_inner_axis matrix_vector_mul_component)"], ["", "end"], ["", "lemma blinfun_apply_componentwise:\n  \"B = (\\<Sum>i\\<in>Basis. blinfun_scaleR (blinfun_inner_left i) (blinfun_apply B i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    (\\<Sum>i\\<in>Basis.\n       blinfun_scaleR (blinfun_inner_left i) (blinfun_apply B i))", "using blinfun_componentwise[of \"\\<lambda>x. B\", unfolded fun_eq_iff]"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     B =\n     (\\<Sum>i\\<in>Basis.\n        blinfun_scaleR (blinfun_inner_left i) (blinfun_apply B i))\n\ngoal (1 subgoal):\n 1. B =\n    (\\<Sum>i\\<in>Basis.\n       blinfun_scaleR (blinfun_inner_left i) (blinfun_apply B i))", "by blast"], ["", "lemma blinfun_apply_eq_sum:\n  assumes [simp]: \"length v = CARD('n)\"\n  shows \"blinfun_apply (B::(real^'n::enum)\\<Rightarrow>\\<^sub>L(real^'m::enum)) (eucl_of_list v) =\n    (\\<Sum>i<CARD('m). \\<Sum>j<CARD('n). ((B (Basis_list ! j) \\<bullet> Basis_list ! i) * v ! j) *\\<^sub>R (Basis_list ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_apply B (eucl_of_list v) =\n    (\\<Sum>i<CARD('m).\n        \\<Sum>j<CARD('n).\n           (blinfun_apply B (Basis_list ! j) \\<bullet> Basis_list ! i *\n            v ! j) *\\<^sub>R\n           Basis_list ! i)", "apply (subst blinfun_apply_componentwise[of B])"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_apply\n     (\\<Sum>i\\<in>Basis.\n        blinfun_scaleR (blinfun_inner_left i) (blinfun_apply B i))\n     (eucl_of_list v) =\n    (\\<Sum>i<CARD('m).\n        \\<Sum>j<CARD('n).\n           (blinfun_apply B (Basis_list ! j) \\<bullet> Basis_list ! i *\n            v ! j) *\\<^sub>R\n           Basis_list ! i)", "apply (auto intro!: euclidean_eqI[where 'a=\"(real,'m) vec\"]\n      simp: blinfun.bilinear_simps eucl_of_list_inner inner_sum_left inner_Basis if_distrib\n        sum_Basis_sum_nth_Basis_list nth_eq_iff_index if_distribR\n        cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow>\n       (\\<Sum>i<CARD('n).\n           v ! i * (blinfun_apply B (Basis_list ! i) \\<bullet> b)) =\n       (\\<Sum>i<CARD('m).\n           \\<Sum>j<CARD('n).\n              if i = index Basis_list b\n              then blinfun_apply B (Basis_list ! j) \\<bullet> b * v ! j\n              else 0)", "apply (subst sum.swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow>\n       (\\<Sum>i<CARD('n).\n           v ! i * (blinfun_apply B (Basis_list ! i) \\<bullet> b)) =\n       (\\<Sum>j<CARD('n).\n           \\<Sum>i<CARD('m).\n              if i = index Basis_list b\n              then blinfun_apply B (Basis_list ! j) \\<bullet> b * v ! j\n              else 0)", "by (auto simp: sum.delta algebra_simps)"], ["", "lemma in_square_lemma[intro, simp]: \"x * C + y < D * C\" if \"x < D\" \"y < C\" for x::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * C + y < D * C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * C + y < D * C", "have \"x * C + y < (D - 1) * C + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * C + y < (D - 1) * C + C", "apply (rule add_le_less_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * C \\<le> (D - 1) * C\n 2. y < C", "apply (rule mult_right_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<le> D - 1\n 2. 0 \\<le> C\n 3. y < C", "using that"], ["proof (prove)\nusing this:\n  x < D\n  y < C\n\ngoal (3 subgoals):\n 1. x \\<le> D - 1\n 2. 0 \\<le> C\n 3. y < C", "by auto"], ["proof (state)\nthis:\n  x * C + y < (D - 1) * C + C\n\ngoal (1 subgoal):\n 1. x * C + y < D * C", "also"], ["proof (state)\nthis:\n  x * C + y < (D - 1) * C + C\n\ngoal (1 subgoal):\n 1. x * C + y < D * C", "have \"\\<dots> \\<le> D * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D - 1) * C + C \\<le> D * C", "using that"], ["proof (prove)\nusing this:\n  x < D\n  y < C\n\ngoal (1 subgoal):\n 1. (D - 1) * C + C \\<le> D * C", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (D - 1) * C + C \\<le> D * C\n\ngoal (1 subgoal):\n 1. x * C + y < D * C", "finally"], ["proof (chain)\npicking this:\n  x * C + y < D * C", "show ?thesis"], ["proof (prove)\nusing this:\n  x * C + y < D * C\n\ngoal (1 subgoal):\n 1. x * C + y < D * C", "."], ["proof (state)\nthis:\n  x * C + y < D * C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_square_imp_div_less[intro, simp]: \"i < E * D \\<Longrightarrow>  i div E < D\" for i::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < E * D \\<Longrightarrow> i div E < D", "by (metis div_eq_0_iff div_mult2_eq gr_implies_not0 mult_not_zero)"], ["", "lemma in_square_lemma'[intro, simp]: \"i < L \\<Longrightarrow> n < N \\<Longrightarrow> i * N + n < N * L\" for i n::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < L; n < N\\<rbrakk> \\<Longrightarrow> i * N + n < N * L", "by (metis in_square_lemma mult.commute)"], ["", "lemma\n  distinct_nth_eq_iff:\n  \"distinct xs \\<Longrightarrow> x < length xs \\<Longrightarrow> y < length xs \\<Longrightarrow> xs ! x = xs ! y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x < length xs; y < length xs\\<rbrakk>\n    \\<Longrightarrow> (xs ! x = xs ! y) = (x = y)", "by (drule inj_on_nth[where I=\"{..<length xs}\"]) (auto simp: inj_onD)"], ["", "lemma index_Basis_list_axis2:\n  \"index Basis_list (axis (j::'j::enum) (axis (i::'i::enum) (1::real))) =\n    (index enum_class.enum j) * CARD('i) + index enum_class.enum i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index Basis_list (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "apply (auto simp: Basis_list_vec_def Basis_list_real_def o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (concat\n       (map (\\<lambda>n.\n                map (\\<lambda>x. axis n (axis x 1)) enum_class.enum)\n         enum_class.enum))\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "apply (subst concat_map_map_index)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div length enum_class.enum))\n               (axis (enum_class.enum ! (i mod length enum_class.enum)) 1))\n       [0..<length enum_class.enum * length enum_class.enum])\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "unfolding card_UNIV_length_enum[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div CARD('i)))\n               (axis (enum_class.enum ! (i mod CARD('i))) 1))\n       [0..<CARD('i) * CARD('j)])\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div CARD('i)))\n               (axis (enum_class.enum ! (i mod CARD('i))) 1))\n       [0..<CARD('i) * CARD('j)])\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div CARD('i)))\n               (axis (enum_class.enum ! (i mod CARD('i))) 1))\n       [0..<CARD('i) * CARD('j)])\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "have index_less_cardi: \"index enum_class.enum k < CARD('i)\" for k::'i"], ["proof (prove)\ngoal (1 subgoal):\n 1. index enum_class.enum k < CARD('i)", "by (rule index_less) (auto simp: enum_UNIV card_UNIV_length_enum)"], ["proof (state)\nthis:\n  index enum_class.enum ?k < CARD('i)\n\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div CARD('i)))\n               (axis (enum_class.enum ! (i mod CARD('i))) 1))\n       [0..<CARD('i) * CARD('j)])\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "have index_less_cardj: \"index enum_class.enum k < CARD('j)\" for k::'j"], ["proof (prove)\ngoal (1 subgoal):\n 1. index enum_class.enum k < CARD('j)", "by (rule index_less) (auto simp: enum_UNIV card_UNIV_length_enum)"], ["proof (state)\nthis:\n  index enum_class.enum ?k < CARD('j)\n\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div CARD('i)))\n               (axis (enum_class.enum ! (i mod CARD('i))) 1))\n       [0..<CARD('i) * CARD('j)])\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "have *: \"axis j (axis i 1) =\n      (\\<lambda>i. axis (enum_class.enum ! (i div CARD('i)))\n                      (axis (enum_class.enum ! (i mod CARD('i))) 1))\n      ((index enum_class.enum j) * CARD('i) + index enum_class.enum i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. axis j (axis i (1::'a)) =\n    axis\n     (enum_class.enum !\n      ((index enum_class.enum j * CARD('i) + index enum_class.enum i) div\n       CARD('i)))\n     (axis\n       (enum_class.enum !\n        ((index enum_class.enum j * CARD('i) + index enum_class.enum i) mod\n         CARD('i)))\n       (1::'a))", "by (auto simp: index_less_cardi enum_UNIV)"], ["proof (state)\nthis:\n  axis j (axis i (1::?'a1)) =\n  axis\n   (enum_class.enum !\n    ((index enum_class.enum j * CARD('i) + index enum_class.enum i) div\n     CARD('i)))\n   (axis\n     (enum_class.enum !\n      ((index enum_class.enum j * CARD('i) + index enum_class.enum i) mod\n       CARD('i)))\n     (1::?'a1))\n\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div CARD('i)))\n               (axis (enum_class.enum ! (i mod CARD('i))) 1))\n       [0..<CARD('i) * CARD('j)])\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "note less=in_square_lemma[OF index_less_cardj index_less_cardi, of j i]"], ["proof (state)\nthis:\n  index enum_class.enum j * CARD('i) + index enum_class.enum i\n  < CARD('j) * CARD('i)\n\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div CARD('i)))\n               (axis (enum_class.enum ! (i mod CARD('i))) 1))\n       [0..<CARD('i) * CARD('j)])\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div CARD('i)))\n               (axis (enum_class.enum ! (i mod CARD('i))) 1))\n       [0..<CARD('i) * CARD('j)])\n     (axis j (axis i 1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (map (\\<lambda>i.\n              axis (enum_class.enum ! (i div CARD('i)))\n               (axis (enum_class.enum ! (i mod CARD('i))) 1))\n       [0..<CARD('i) * CARD('j)])\n     (axis\n       (enum_class.enum !\n        ((index enum_class.enum j * CARD('i) + index enum_class.enum i) div\n         CARD('i)))\n       (axis\n         (enum_class.enum !\n          ((index enum_class.enum j * CARD('i) +\n            index enum_class.enum i) mod\n           CARD('i)))\n         1)) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "apply (subst index_map_inj_on[where S=\"{..<CARD('j)*CARD('i)}\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. inj_on\n     (\\<lambda>i.\n         axis (enum_class.enum ! (i div CARD('i)))\n          (axis (enum_class.enum ! (i mod CARD('i))) 1))\n     {..<CARD('j) * CARD('i)}\n 2. index enum_class.enum j * CARD('i) + index enum_class.enum i\n    \\<in> {..<CARD('j) * CARD('i)}\n 3. set [0..<CARD('i) * CARD('j)] \\<subseteq> {..<CARD('j) * CARD('i)}\n 4. index [0..<CARD('i) * CARD('j)]\n     (index enum_class.enum j * CARD('i) + index enum_class.enum i) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>i.\n         axis (enum_class.enum ! (i div CARD('i)))\n          (axis (enum_class.enum ! (i mod CARD('i))) 1))\n     {..<CARD('j) * CARD('i)}", "apply (auto intro!: inj_onI simp: axis_eq_axis )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('j) * CARD('i); y < CARD('j) * CARD('i);\n        enum_class.enum ! (x mod CARD('i)) =\n        enum_class.enum ! (y mod CARD('i));\n        enum_class.enum ! (x div CARD('i)) =\n        enum_class.enum ! (y div CARD('i))\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (subst (asm) distinct_nth_eq_iff)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>enum_class.enum ! (x div CARD('i)) =\n                enum_class.enum ! (y div CARD('i));\n        x < CARD('j) * CARD('i); y < CARD('j) * CARD('i)\\<rbrakk>\n       \\<Longrightarrow> distinct enum_class.enum\n 2. \\<And>x y.\n       \\<lbrakk>enum_class.enum ! (x div CARD('i)) =\n                enum_class.enum ! (y div CARD('i));\n        x < CARD('j) * CARD('i); y < CARD('j) * CARD('i)\\<rbrakk>\n       \\<Longrightarrow> x mod CARD('i) < length enum_class.enum\n 3. \\<And>x y.\n       \\<lbrakk>enum_class.enum ! (x div CARD('i)) =\n                enum_class.enum ! (y div CARD('i));\n        x < CARD('j) * CARD('i); y < CARD('j) * CARD('i)\\<rbrakk>\n       \\<Longrightarrow> y mod CARD('i) < length enum_class.enum\n 4. \\<And>x y.\n       \\<lbrakk>x < CARD('j) * CARD('i); y < CARD('j) * CARD('i);\n        x mod CARD('i) = y mod CARD('i);\n        enum_class.enum ! (x div CARD('i)) =\n        enum_class.enum ! (y div CARD('i))\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto simp: enum_distinct card_UNIV_length_enum)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>enum_class.enum ! (x div length enum_class.enum) =\n                enum_class.enum ! (y div length enum_class.enum);\n        x < length enum_class.enum * length enum_class.enum;\n        y < length enum_class.enum * length enum_class.enum\\<rbrakk>\n       \\<Longrightarrow> x mod length enum_class.enum\n                         < length enum_class.enum\n 2. \\<And>x y.\n       \\<lbrakk>enum_class.enum ! (x div length enum_class.enum) =\n                enum_class.enum ! (y div length enum_class.enum);\n        x < length enum_class.enum * length enum_class.enum;\n        y < length enum_class.enum * length enum_class.enum\\<rbrakk>\n       \\<Longrightarrow> y mod length enum_class.enum\n                         < length enum_class.enum\n 3. \\<And>x y.\n       \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n        y < length enum_class.enum * length enum_class.enum;\n        x mod length enum_class.enum = y mod length enum_class.enum;\n        enum_class.enum ! (x div length enum_class.enum) =\n        enum_class.enum ! (y div length enum_class.enum)\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enum_class.enum ! (x div length enum_class.enum) =\n             enum_class.enum ! (y div length enum_class.enum);\n     x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> x mod length enum_class.enum < length enum_class.enum", "using gr_implies_not0"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enum_class.enum ! (x div length enum_class.enum) =\n             enum_class.enum ! (y div length enum_class.enum);\n     x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> x mod length enum_class.enum < length enum_class.enum", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>enum_class.enum ! (x div length enum_class.enum) =\n                enum_class.enum ! (y div length enum_class.enum);\n        x < length enum_class.enum * length enum_class.enum;\n        y < length enum_class.enum * length enum_class.enum\\<rbrakk>\n       \\<Longrightarrow> y mod length enum_class.enum\n                         < length enum_class.enum\n 2. \\<And>x y.\n       \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n        y < length enum_class.enum * length enum_class.enum;\n        x mod length enum_class.enum = y mod length enum_class.enum;\n        enum_class.enum ! (x div length enum_class.enum) =\n        enum_class.enum ! (y div length enum_class.enum)\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enum_class.enum ! (x div length enum_class.enum) =\n             enum_class.enum ! (y div length enum_class.enum);\n     x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> y mod length enum_class.enum < length enum_class.enum", "using gr_implies_not0"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enum_class.enum ! (x div length enum_class.enum) =\n             enum_class.enum ! (y div length enum_class.enum);\n     x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> y mod length enum_class.enum < length enum_class.enum", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n        y < length enum_class.enum * length enum_class.enum;\n        x mod length enum_class.enum = y mod length enum_class.enum;\n        enum_class.enum ! (x div length enum_class.enum) =\n        enum_class.enum ! (y div length enum_class.enum)\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum;\n     x mod length enum_class.enum = y mod length enum_class.enum;\n     enum_class.enum ! (x div length enum_class.enum) =\n     enum_class.enum ! (y div length enum_class.enum)\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply (drule inj_onD[OF inj_on_nth[OF enum_distinct[where 'a='j], where I = \"{..<CARD('j)}\"], rotated])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum;\n     x mod length enum_class.enum = y mod length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> x div length enum_class.enum \\<in> {..<CARD('j)}\n 2. \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum;\n     x mod length enum_class.enum = y mod length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> y div length enum_class.enum \\<in> {..<CARD('j)}\n 3. \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum;\n     x mod length enum_class.enum = y mod length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>{..<CARD('j)}.\n                         i < length enum_class.enum\n 4. \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum;\n     x mod length enum_class.enum = y mod length enum_class.enum;\n     x div length enum_class.enum = y div length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply (auto simp: card_UNIV_length_enum mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum;\n     x mod length enum_class.enum = y mod length enum_class.enum;\n     x div length enum_class.enum = y div length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> x = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < length enum_class.enum * length enum_class.enum;\n     y < length enum_class.enum * length enum_class.enum;\n     x mod length enum_class.enum = y mod length enum_class.enum;\n     x div length enum_class.enum = y div length enum_class.enum\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (metis mod_mult_div_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. index enum_class.enum j * CARD('i) + index enum_class.enum i\n    \\<in> {..<CARD('j) * CARD('i)}\n 2. set [0..<CARD('i) * CARD('j)] \\<subseteq> {..<CARD('j) * CARD('i)}\n 3. index [0..<CARD('i) * CARD('j)]\n     (index enum_class.enum j * CARD('i) + index enum_class.enum i) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. index enum_class.enum j * CARD('i) + index enum_class.enum i\n    \\<in> {..<CARD('j) * CARD('i)}", "using less"], ["proof (prove)\nusing this:\n  index enum_class.enum j * CARD('i) + index enum_class.enum i\n  < CARD('j) * CARD('i)\n\ngoal (1 subgoal):\n 1. index enum_class.enum j * CARD('i) + index enum_class.enum i\n    \\<in> {..<CARD('j) * CARD('i)}", "by (auto simp: )"], ["proof (prove)\ngoal (2 subgoals):\n 1. set [0..<CARD('i) * CARD('j)] \\<subseteq> {..<CARD('j) * CARD('i)}\n 2. index [0..<CARD('i) * CARD('j)]\n     (index enum_class.enum j * CARD('i) + index enum_class.enum i) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [0..<CARD('i) * CARD('j)] \\<subseteq> {..<CARD('j) * CARD('i)}", "by (auto simp: card_UNIV_length_enum ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index [0..<CARD('i) * CARD('j)]\n     (index enum_class.enum j * CARD('i) + index enum_class.enum i) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. index [0..<CARD('i) * CARD('j)]\n     (index enum_class.enum j * CARD('i) + index enum_class.enum i) =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "apply (subst index_upt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> index enum_class.enum j * CARD('i) + index enum_class.enum i\n 2. index enum_class.enum j * CARD('i) + index enum_class.enum i\n    < CARD('i) * CARD('j)\n 3. index enum_class.enum j * CARD('i) + index enum_class.enum i - 0 =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> index enum_class.enum j * CARD('i) + index enum_class.enum i", "using less"], ["proof (prove)\nusing this:\n  index enum_class.enum j * CARD('i) + index enum_class.enum i\n  < CARD('j) * CARD('i)\n\ngoal (1 subgoal):\n 1. 0 \\<le> index enum_class.enum j * CARD('i) + index enum_class.enum i", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. index enum_class.enum j * CARD('i) + index enum_class.enum i\n    < CARD('i) * CARD('j)\n 2. index enum_class.enum j * CARD('i) + index enum_class.enum i - 0 =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. index enum_class.enum j * CARD('i) + index enum_class.enum i\n    < CARD('i) * CARD('j)", "using less"], ["proof (prove)\nusing this:\n  index enum_class.enum j * CARD('i) + index enum_class.enum i\n  < CARD('j) * CARD('i)\n\ngoal (1 subgoal):\n 1. index enum_class.enum j * CARD('i) + index enum_class.enum i\n    < CARD('i) * CARD('j)", "by (auto simp: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index enum_class.enum j * CARD('i) + index enum_class.enum i - 0 =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. index enum_class.enum j * CARD('i) + index enum_class.enum i - 0 =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "using less"], ["proof (prove)\nusing this:\n  index enum_class.enum j * CARD('i) + index enum_class.enum i\n  < CARD('j) * CARD('i)\n\ngoal (1 subgoal):\n 1. index enum_class.enum j * CARD('i) + index enum_class.enum i - 0 =\n    index enum_class.enum j * CARD('i) + index enum_class.enum i", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  index\n   (map (\\<lambda>i.\n            axis (enum_class.enum ! (i div CARD('i)))\n             (axis (enum_class.enum ! (i mod CARD('i))) 1))\n     [0..<CARD('i) * CARD('j)])\n   (axis j (axis i 1)) =\n  index enum_class.enum j * CARD('i) + index enum_class.enum i\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  vec_nth_Basis2:\n  fixes x::\"real^'n^'m\"\n  shows \"x \\<in> Basis \\<Longrightarrow> vec_nth (vec_nth x i) j = ((if x = axis i (axis j 1) then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Basis \\<Longrightarrow>\n    x $ i $ j = (if x = axis i (axis j 1) then 1 else 0)", "by (auto simp: Basis_vec_def axis_def)"], ["", "lemma vec_nth_eucl_of_list_eq2: \"length M = CARD('n) * CARD('m) \\<Longrightarrow>\n  vec_nth (vec_nth (eucl_of_list M::real^'n::enum^'m::enum) i) j = M ! index Basis_list (axis i (axis j (1::real)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    eucl_of_list M $ i $ j = M ! index Basis_list (axis i (axis j 1))", "apply (auto simp: eucl_of_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    sum_list (map2 (*\\<^sub>R) M Basis_list) $ i $ j =\n    M ! index Basis_list (axis i (axis j 1))", "apply (subst sum_list_zip_map_of)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length M = CARD('n) * CARD('m) \\<Longrightarrow> distinct Basis_list\n 2. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    length M = length Basis_list\n 3. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    (\\<Sum>x\\<in>set Basis_list.\n       the (map_of (zip Basis_list M) x) *\\<^sub>R x) $\n    i $\n    j =\n    M ! index Basis_list (axis i (axis j 1))", "apply (auto intro!: distinct_zipI2 simp: split_beta')"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Basis. the (map_of (zip Basis_list M) x) * x $ i $ j) =\n    M ! index Basis_list (axis i (axis j 1))", "apply (subst sum.cong[OF refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length M = CARD('n) * CARD('m); x \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M) x) * x $ i $ j =\n                         ?h11 x\n 2. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    sum ?h11 Basis = M ! index Basis_list (axis i (axis j 1))", "apply (subst vec_nth_Basis2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length M = CARD('n) * CARD('m); x \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Basis\n 2. \\<And>x.\n       \\<lbrakk>length M = CARD('n) * CARD('m); x \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M) x) *\n                         (if x = axis i (axis j 1) then 1 else 0) =\n                         ?h13 x x\n 3. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Basis. ?h13 x x) = M ! index Basis_list (axis i (axis j 1))", "apply (force simp: set_zip)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length M = CARD('n) * CARD('m); x \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M) x) *\n                         (if x = axis i (axis j 1) then 1 else 0) =\n                         ?h13 x x\n 2. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Basis. ?h13 x x) = M ! index Basis_list (axis i (axis j 1))", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Basis.\n       the (map_of (zip Basis_list M) x) *\n       (if x = axis i (axis j 1) then 1 else 0)) =\n    M ! index Basis_list (axis i (axis j 1))", "apply (auto simp: if_distrib sum.delta cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n    M ! index Basis_list (axis i (axis j 1))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. length M = CARD('n) * CARD('m) \\<Longrightarrow>\n    the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n    M ! index Basis_list (axis i (axis j 1))", "apply (cases \"map_of (zip Basis_list M) (axis i (axis j 1)::real^'n::enum^'m::enum)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length M = CARD('n) * CARD('m);\n     map_of (zip Basis_list M) (axis i (axis j 1)) = None\\<rbrakk>\n    \\<Longrightarrow> the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n                      M ! index Basis_list (axis i (axis j 1))\n 2. \\<And>a.\n       \\<lbrakk>length M = CARD('n) * CARD('m);\n        map_of (zip Basis_list M) (axis i (axis j 1)) = Some a\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M)\n                               (axis i (axis j 1))) =\n                         M ! index Basis_list (axis i (axis j 1))", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n    M ! index Basis_list (axis i (axis j 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n    M ! index Basis_list (axis i (axis j 1))", "have \"fst ` set (zip Basis_list M) = (Basis::(real^'n::enum^'m::enum) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (zip Basis_list M) = Basis", "using prems"], ["proof (prove)\nusing this:\n  length M = CARD('n) * CARD('m)\n  map_of (zip Basis_list M) (axis i (axis j 1)) = None\n\ngoal (1 subgoal):\n 1. fst ` set (zip Basis_list M) = Basis", "by (auto simp: in_set_zip)"], ["proof (state)\nthis:\n  fst ` set (zip Basis_list M) = Basis\n\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n    M ! index Basis_list (axis i (axis j 1))", "then"], ["proof (chain)\npicking this:\n  fst ` set (zip Basis_list M) = Basis", "show ?thesis"], ["proof (prove)\nusing this:\n  fst ` set (zip Basis_list M) = Basis\n\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n    M ! index Basis_list (axis i (axis j 1))", "using prems"], ["proof (prove)\nusing this:\n  fst ` set (zip Basis_list M) = Basis\n  length M = CARD('n) * CARD('m)\n  map_of (zip Basis_list M) (axis i (axis j 1)) = None\n\ngoal (1 subgoal):\n 1. the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n    M ! index Basis_list (axis i (axis j 1))", "by (subst (asm) map_of_eq_None_iff) auto"], ["proof (state)\nthis:\n  the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n  M ! index Basis_list (axis i (axis j 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length M = CARD('n) * CARD('m);\n        map_of (zip Basis_list M) (axis i (axis j 1)) = Some a\\<rbrakk>\n       \\<Longrightarrow> the (map_of (zip Basis_list M)\n                               (axis i (axis j 1))) =\n                         M ! index Basis_list (axis i (axis j 1))", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length M = CARD('n) * CARD('m);\n     map_of (zip Basis_list M) (axis i (axis j 1)) = Some a\\<rbrakk>\n    \\<Longrightarrow> the (map_of (zip Basis_list M) (axis i (axis j 1))) =\n                      M ! index Basis_list (axis i (axis j 1))", "apply (auto simp: in_set_zip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>length M = CARD('n) * CARD('m);\n        Basis_list ! n = axis i (axis j 1); a = M ! n;\n        n < CARD('m) * CARD('n); n < CARD('n) * CARD('m)\\<rbrakk>\n       \\<Longrightarrow> M ! n = M ! index Basis_list (axis i (axis j 1))", "subgoal premises prems for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. M ! n = M ! index Basis_list (axis i (axis j 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M ! n = M ! index Basis_list (axis i (axis j 1))", "have \"n < card (Basis::(real^'n::_^'m::_) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < DIM(((real, 'n) vec, 'm) vec)", "by (simp add: prems(4))"], ["proof (state)\nthis:\n  n < DIM(((real, 'n) vec, 'm) vec)\n\ngoal (1 subgoal):\n 1. M ! n = M ! index Basis_list (axis i (axis j 1))", "then"], ["proof (chain)\npicking this:\n  n < DIM(((real, 'n) vec, 'm) vec)", "show ?thesis"], ["proof (prove)\nusing this:\n  n < DIM(((real, 'n) vec, 'm) vec)\n\ngoal (1 subgoal):\n 1. M ! n = M ! index Basis_list (axis i (axis j 1))", "by (metis index_Basis_list_nth prems(2))"], ["proof (state)\nthis:\n  M ! n = M ! index Basis_list (axis i (axis j 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma vec_nth_eq_list_of_eucl2:\n  \"vec_nth (vec_nth (M::real^'n::enum^'m::enum) i) j =\n    list_of_eucl M ! (index enum_class.enum i * CARD('n) + index enum_class.enum j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ i $ j =\n    list_of_eucl M !\n    (index enum_class.enum i * CARD('n) + index enum_class.enum j)", "apply (subst eucl_of_list_list_of_eucl[of M, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list (list_of_eucl M) $ i $ j =\n    list_of_eucl M !\n    (index enum_class.enum i * CARD('n) + index enum_class.enum j)", "apply (subst vec_nth_eucl_of_list_eq2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (list_of_eucl M) = CARD('n) * CARD('m)\n 2. list_of_eucl M ! index Basis_list (axis i (axis j 1)) =\n    list_of_eucl M !\n    (index enum_class.enum i * CARD('n) + index enum_class.enum j)", "unfolding index_Basis_list_axis2"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (list_of_eucl M) = CARD('n) * CARD('m)\n 2. list_of_eucl M !\n    (index enum_class.enum i * CARD('n) + index enum_class.enum j) =\n    list_of_eucl M !\n    (index enum_class.enum i * CARD('n) + index enum_class.enum j)", "by auto"], ["", "theorem\n  eucl_of_list_matrix_vector_mult_eq_sum_nth_Basis_list:\n  assumes \"length M = CARD('n) * CARD('m)\"\n  assumes \"length v = CARD('n)\"\n  shows \"(eucl_of_list M::real^'n::enum^'m::enum) *v eucl_of_list v =\n    (\\<Sum>i<CARD('m).\n      (\\<Sum>j<CARD('n). M ! (i * CARD('n) + j) * v ! j) *\\<^sub>R Basis_list ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_of_list M *v eucl_of_list v =\n    (\\<Sum>i<CARD('m).\n        (\\<Sum>j<CARD('n). M ! (i * CARD('n) + j) * v ! j) *\\<^sub>R\n        Basis_list ! i)", "apply (vector matrix_vector_mult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<Sum>j\\<in>UNIV. eucl_of_list M $ i $ j * eucl_of_list v $ j) =\n       (\\<Sum>i<CARD('m).\n           \\<chi>ia.\n              (\\<Sum>j<CARD('n). M ! (i * CARD('n) + j) * v ! j) *\n              Basis_list ! i $ ia) $\n       i", "apply (auto simp: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>j\\<in>UNIV. eucl_of_list M $ i $ j * eucl_of_list v $ j) =\n       (\\<Sum>x<CARD('m).\n           (\\<Sum>j<CARD('n). M ! (x * CARD('n) + j) * v ! j) *\n           Basis_list ! x $ i)", "apply (subst vec_nth_eucl_of_list_eq2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j. length M = CARD('n) * CARD('m)\n 2. \\<And>i.\n       (\\<Sum>j\\<in>UNIV.\n          M ! index Basis_list (axis i (axis j 1)) * eucl_of_list v $ j) =\n       (\\<Sum>x<CARD('m).\n           (\\<Sum>j<CARD('n). M ! (x * CARD('n) + j) * v ! j) *\n           Basis_list ! x $ i)", "apply (auto simp: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>j\\<in>UNIV.\n          M ! index Basis_list (axis i (axis j 1)) * eucl_of_list v $ j) =\n       (\\<Sum>x<CARD('m).\n           (\\<Sum>j<CARD('n). M ! (x * CARD('n) + j) * v ! j) *\n           Basis_list ! x $ i)", "apply (subst vec_nth_eucl_of_list_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j. length v = CARD('n)\n 2. \\<And>i.\n       (\\<Sum>j\\<in>UNIV.\n          M ! index Basis_list (axis i (axis j 1)) *\n          v ! index Basis_list (axis j 1)) =\n       (\\<Sum>x<CARD('m).\n           (\\<Sum>j<CARD('n). M ! (x * CARD('n) + j) * v ! j) *\n           Basis_list ! x $ i)", "apply (auto simp: assms index_Basis_list_axis2 index_Basis_list_axis1 vec_nth_Basis sum.delta\n      nth_eq_iff_index\n      if_distrib cong: if_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       index enum_class.enum i < CARD('m) \\<Longrightarrow>\n       (\\<Sum>j\\<in>UNIV.\n          M !\n          (index enum_class.enum i * CARD('n) + index enum_class.enum j) *\n          v ! index enum_class.enum j) =\n       (\\<Sum>j<CARD('n).\n           M ! (index enum_class.enum i * CARD('n) + j) * v ! j)\n 2. \\<And>i.\n       \\<not> index enum_class.enum i < CARD('m) \\<Longrightarrow>\n       (\\<Sum>j\\<in>UNIV.\n          M !\n          (index enum_class.enum i * CARD('n) + index enum_class.enum j) *\n          v ! index enum_class.enum j) =\n       0", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. index enum_class.enum i < CARD('m) \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       M ! (index enum_class.enum i * CARD('n) + index enum_class.enum j) *\n       v ! index enum_class.enum j) =\n    (\\<Sum>j<CARD('n). M ! (index enum_class.enum i * CARD('n) + j) * v ! j)", "apply (rule sum.reindex_cong[where l=\"nth enum_class.enum\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. index enum_class.enum i < CARD('m) \\<Longrightarrow>\n    inj_on ((!) enum_class.enum) {..<CARD('n)}\n 2. index enum_class.enum i < CARD('m) \\<Longrightarrow>\n    UNIV = (!) enum_class.enum ` {..<CARD('n)}\n 3. \\<And>x.\n       \\<lbrakk>index enum_class.enum i < CARD('m);\n        x \\<in> {..<CARD('n)}\\<rbrakk>\n       \\<Longrightarrow> M !\n                         (index enum_class.enum i * CARD('n) +\n                          index enum_class.enum (enum_class.enum ! x)) *\n                         v ! index enum_class.enum (enum_class.enum ! x) =\n                         M ! (index enum_class.enum i * CARD('n) + x) *\n                         v ! x", "apply (auto simp: enum_distinct card_UNIV_length_enum distinct_nth_eq_iff intro!: inj_onI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       index enum_class.enum i < length enum_class.enum \\<Longrightarrow>\n       x \\<in> (!) enum_class.enum ` {..<length enum_class.enum}\n 2. \\<And>x.\n       \\<lbrakk>index enum_class.enum i < length enum_class.enum;\n        x < length enum_class.enum\\<rbrakk>\n       \\<Longrightarrow> M !\n                         (index enum_class.enum i * length enum_class.enum +\n                          index enum_class.enum (enum_class.enum ! x)) *\n                         v ! index enum_class.enum (enum_class.enum ! x) =\n                         M !\n                         (index enum_class.enum i * length enum_class.enum +\n                          x) *\n                         v ! x", "apply (rule image_eqI[OF ])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       index enum_class.enum i < length enum_class.enum \\<Longrightarrow>\n       x = enum_class.enum ! ?x24 x\n 2. \\<And>x.\n       index enum_class.enum i < length enum_class.enum \\<Longrightarrow>\n       ?x24 x \\<in> {..<length enum_class.enum}\n 3. \\<And>x.\n       \\<lbrakk>index enum_class.enum i < length enum_class.enum;\n        x < length enum_class.enum\\<rbrakk>\n       \\<Longrightarrow> M !\n                         (index enum_class.enum i * length enum_class.enum +\n                          index enum_class.enum (enum_class.enum ! x)) *\n                         v ! index enum_class.enum (enum_class.enum ! x) =\n                         M !\n                         (index enum_class.enum i * length enum_class.enum +\n                          x) *\n                         v ! x", "apply (rule nth_index[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       index enum_class.enum i < length enum_class.enum \\<Longrightarrow>\n       x \\<in> set enum_class.enum\n 2. \\<And>x.\n       index enum_class.enum i < length enum_class.enum \\<Longrightarrow>\n       index enum_class.enum x \\<in> {..<length enum_class.enum}\n 3. \\<And>x.\n       \\<lbrakk>index enum_class.enum i < length enum_class.enum;\n        x < length enum_class.enum\\<rbrakk>\n       \\<Longrightarrow> M !\n                         (index enum_class.enum i * length enum_class.enum +\n                          index enum_class.enum (enum_class.enum ! x)) *\n                         v ! index enum_class.enum (enum_class.enum ! x) =\n                         M !\n                         (index enum_class.enum i * length enum_class.enum +\n                          x) *\n                         v ! x", "apply (auto simp: enum_UNIV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length enum_class.enum \\<Longrightarrow>\n       M !\n       (index enum_class.enum i * length enum_class.enum +\n        index enum_class.enum (enum_class.enum ! x)) *\n       v ! index enum_class.enum (enum_class.enum ! x) =\n       M ! (index enum_class.enum i * length enum_class.enum + x) * v ! x", "by (auto simp: algebra_simps enum_UNIV enum_distinct index_nth_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> index enum_class.enum i < CARD('m) \\<Longrightarrow>\n       (\\<Sum>j\\<in>UNIV.\n          M !\n          (index enum_class.enum i * CARD('n) + index enum_class.enum j) *\n          v ! index enum_class.enum j) =\n       0", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> index enum_class.enum i < CARD('m) \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       M ! (index enum_class.enum i * CARD('n) + index enum_class.enum j) *\n       v ! index enum_class.enum j) =\n    0", "using index_less[of i \"enum_class.enum\" \"CARD('n)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<in> set enum_class.enum;\n   length enum_class.enum \\<le> CARD('n)\\<rbrakk>\n  \\<Longrightarrow> index enum_class.enum i < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<not> index enum_class.enum i < CARD('m) \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       M ! (index enum_class.enum i * CARD('n) + index enum_class.enum j) *\n       v ! index enum_class.enum j) =\n    0", "by (auto simp: enum_UNIV card_UNIV_length_enum)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma index_enum_less[intro, simp]: \"index enum_class.enum (i::'n::enum) < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index enum_class.enum i < CARD('n)", "by (auto intro!: index_less simp: enum_UNIV card_UNIV_length_enum)"], ["", "lemmas [intro, simp] = enum_distinct"], ["", "lemmas [simp] = card_UNIV_length_enum[symmetric] enum_UNIV"], ["", "lemma sum_index_enum_eq:\n  \"(\\<Sum>(k::'n::enum)\\<in>UNIV. f (index enum_class.enum k)) = (\\<Sum>i<CARD('n). f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. f (index enum_class.enum k)) = sum f {..<CARD('n)}", "by (rule sum.reindex_cong[where l=\"nth enum_class.enum\"])\n    (force intro!: inj_onI simp: distinct_nth_eq_iff index_nth_id)+"], ["", "end"]]}