{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Intersection.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma polychain_of_ccw_conjunction:\n  assumes sorted: \"ccw'.sortedP 0 Ps\"\n  assumes z: \"z \\<in> set (polychain_of Pc Ps)\"\n  shows \"list_all (\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z)) (polychain_of Pc Ps)\"", "lemma lex_polychain_of_center:\n  \"d \\<in> set (polychain_of x0 xs) \\<Longrightarrow> list_all (\\<lambda>x. lex x 0) xs \\<Longrightarrow> lex (snd d) x0\"", "lemma lex_polychain_of_last:\n  \"(c, d) \\<in> set (polychain_of x0 xs) \\<Longrightarrow> list_all (\\<lambda>x. lex x 0) xs \\<Longrightarrow>\n    lex (snd (last (polychain_of x0 xs))) d\"", "lemma distinct_fst_polychain_of:\n  assumes \"list_all (\\<lambda>x. x \\<noteq> 0) xs\"\n  assumes \"list_all (\\<lambda>x. lex x 0) xs\"\n  shows \"distinct (map fst (polychain_of x0 xs))\"", "lemma distinct_snd_polychain_of:\n  assumes \"list_all (\\<lambda>x. x \\<noteq> 0) xs\"\n  assumes \"list_all (\\<lambda>x. lex x 0) xs\"\n  shows \"distinct (map snd (polychain_of x0 xs))\"", "lemma pdevs_apply_nlex_pdevs[simp]: \"pdevs_apply (nlex_pdevs x) n =\n  (if lex 0 (pdevs_apply x n) then - pdevs_apply x n else pdevs_apply x n)\"", "lemma nlex_pdevs_zero_pdevs[simp]: \"nlex_pdevs zero_pdevs = zero_pdevs\"", "lemma pdevs_domain_nlex_pdevs[simp]: \"pdevs_domain (nlex_pdevs x) = pdevs_domain x\"", "lemma degree_nlex_pdevs[simp]: \"degree (nlex_pdevs x) = degree x\"", "lemma\n  pdevs_val_nlex_pdevs:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\" \"uminus ` I = I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\" \"pdevs_val e x = pdevs_val e' (nlex_pdevs x)\"", "lemma\n  pdevs_val_nlex_pdevs2:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\" \"uminus ` I = I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\" \"pdevs_val e (nlex_pdevs x) = pdevs_val e' x\"", "lemma\n  pdevs_val_selsort_ccw:\n  assumes \"distinct xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n    \"pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\"", "lemma\n  pdevs_val_selsort_ccw2:\n  assumes \"distinct xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n    \"pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) = pdevs_val e' (pdevs_of_list xs)\"", "lemma lex_nlex_pdevs: \"lex (pdevs_apply (nlex_pdevs x) i) 0\"", "lemma snd_abs: \"snd (abs x) = abs (snd x)\"", "lemma lowest_vertex:\n  fixes X Y::\"(real*real) aform\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"\\<And>i. snd (pdevs_apply (snd X) i) \\<ge> 0\"\n  assumes \"\\<And>i. abs (snd (pdevs_apply (snd Y) i)) = abs (snd (pdevs_apply (snd X) i))\"\n  assumes \"degree_aform Y = degree_aform X\"\n  assumes \"fst Y = fst X\"\n  shows \"snd (lowest_vertex X) \\<le> snd (aform_val e Y)\"", "lemma sum_list_nonposI:\n  fixes xs::\"'a::ordered_comm_monoid_add list\"\n  shows \"list_all (\\<lambda>x. x \\<le> 0) xs \\<Longrightarrow> sum_list xs \\<le> 0\"", "lemma center_le_lowest:\n  \"fst (fst X) \\<le> fst (lowest_vertex (fst X, nlex_pdevs (snd X)))\"", "lemma lowest_vertex_eq_center_iff:\n  \"lowest_vertex (x0, nlex_pdevs (snd X)) = x0 \\<longleftrightarrow> snd X = zero_pdevs\"", "lemma scaleR_le_self_cancel:\n  fixes c::\"'a::ordered_real_vector\"\n  shows \"a *\\<^sub>R c \\<le> c \\<longleftrightarrow> (1 < a \\<and> c \\<le> 0 \\<or> a < 1 \\<and> 0 \\<le> c \\<or> a = 1)\"", "lemma pdevs_val_coll:\n  assumes coll: \"list_all (coll 0 x) xs\"\n  assumes nlex: \"list_all (\\<lambda>x. lex x 0) xs\"\n  assumes \"x \\<noteq> 0\"\n  assumes \"f \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  obtains e where \"e \\<in> {-1 .. 1}\" \"pdevs_val f (pdevs_of_list xs) = e *\\<^sub>R (sum_list xs)\"", "lemma scaleR_eq_self_cancel:\n  fixes x::\"'a::real_vector\"\n  shows \"a *\\<^sub>R x = x \\<longleftrightarrow> a = 1 \\<or> x = 0\"", "lemma abs_pdevs_val_less_tdev:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\" \"degree x > 0\"\n  shows \"\\<bar>pdevs_val e x\\<bar> < tdev x\"", "lemma pdevs_val_coll_strict:\n  assumes coll: \"list_all (coll 0 x) xs\"\n  assumes nlex: \"list_all (\\<lambda>x. lex x 0) xs\"\n  assumes \"x \\<noteq> 0\"\n  assumes \"f \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  obtains e where \"e \\<in> {-1 <..< 1}\" \"pdevs_val f (pdevs_of_list xs) = e *\\<^sub>R (sum_list xs)\"", "lemma in_set_independent_pdevsE:\n  assumes \"y \\<in> set (independent_pdevs xs)\"\n  obtains x where \"x\\<in>set xs\" \"coll 0 x y\"", "lemma in_set_independent_pdevs_nonzero: \"x \\<in> set (independent_pdevs xs) \\<Longrightarrow> x \\<noteq> 0\"", "lemma independent_pdevs_pairwise_non_coll:\n  assumes \"x \\<in> set (independent_pdevs xs)\"\n  assumes \"y \\<in> set (independent_pdevs xs)\"\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0\"\n  assumes \"x \\<noteq> y\"\n  shows \"\\<not> coll 0 x y\"", "lemma distinct_independent_pdevs[simp]:\n  shows \"distinct (independent_pdevs xs)\"", "lemma in_set_independent_pdevs_invariant_nlex:\n  \"x \\<in> set (independent_pdevs xs) \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> lex x 0) \\<Longrightarrow>\n  (\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0) \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex x 0\"", "lemma\n  pdevs_val_independent_pdevs2:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  shows \"\\<exists>e'. e' \\<in> UNIV \\<rightarrow> I \\<and>\n    pdevs_val e (pdevs_of_list (independent_pdevs xs)) = pdevs_val e' (pdevs_of_list xs)\"", "lemma list_all_filter: \"list_all p (filter p xs)\"", "lemma pdevs_val_independent_pdevs:\n  assumes \"list_all (\\<lambda>x. lex x 0) xs\"\n  assumes \"list_all (\\<lambda>x. x \\<noteq> 0) xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"\\<exists>e'. e' \\<in> UNIV \\<rightarrow> {-1 .. 1} \\<and> pdevs_val e (pdevs_of_list xs) =\n    pdevs_val e' (pdevs_of_list (independent_pdevs xs))\"", "lemma\n  pdevs_val_independent_pdevs_strict:\n  assumes \"list_all (\\<lambda>x. lex x 0) xs\"\n  assumes \"list_all (\\<lambda>x. x \\<noteq> 0) xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  shows \"\\<exists>e'. e' \\<in> UNIV \\<rightarrow> {-1 <..< 1} \\<and> pdevs_val e (pdevs_of_list xs) =\n    pdevs_val e' (pdevs_of_list (independent_pdevs xs))\"", "lemma sum_list_independent_pdevs: \"sum_list (independent_pdevs xs) = sum_list xs\"", "lemma independent_pdevs_eq_Nil_iff:\n  \"list_all (\\<lambda>x. lex x 0) xs \\<Longrightarrow> list_all (\\<lambda>x. x \\<noteq> 0) xs \\<Longrightarrow> independent_pdevs xs = [] \\<longleftrightarrow> xs = []\"", "lemma distinct_inl[simp]: \"distinct (inl (snd X))\"", "lemma in_set_inl_nonzero: \"x \\<in> set (inl xs) \\<Longrightarrow> x \\<noteq> 0\"", "lemma\n  inl_ncoll: \"y \\<in> set (inl (snd X)) \\<Longrightarrow> z \\<in> set (inl (snd X)) \\<Longrightarrow> y \\<noteq> z \\<Longrightarrow> \\<not>coll 0 y z\"", "lemma in_set_inl_lex: \"x \\<in> set (inl xs) \\<Longrightarrow> lex x 0\"", "lemma sorted_inl: \"ccw.sortedP 0 (ccw.selsort 0 (inl (snd X)))\"", "lemma sorted_scaled_inl: \"ccw.sortedP 0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))\"", "lemma distinct_selsort_inl: \"distinct (ccw.selsort 0 (inl (snd X)))\"", "lemma distinct_map_scaleRI:\n  fixes xs::\"'a::real_vector list\"\n  shows \"distinct xs \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> distinct (map ((*\\<^sub>R) c) xs)\"", "lemma distinct_scaled_inl: \"distinct (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))\"", "lemma ccw'_sortedP_scaled_inl:\n  \"ccw'.sortedP 0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))\"", "lemma pdevs_val_pdevs_of_list_inl2E:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  obtains e' where \"pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X))\" \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma pdevs_val_pdevs_of_list_inlE:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\" \"uminus ` I = I\" \"0 \\<in> I\"\n  obtains e' where \"pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X\" \"e' \\<in> UNIV \\<rightarrow> I\"", "lemma sum_list_nlex_eq_sum_list_inl:\n  \"sum_list (map snd (list_of_pdevs (nlex_pdevs X))) = sum_list (inl X)\"", "lemma Affine_inl: \"Affine (fst X, pdevs_of_list (inl (snd X))) = Affine X\"", "lemma subsequent_half_segments:\n  fixes X\n  assumes \"Suc i < length (half_segments_of_aform X)\"\n  shows \"snd (half_segments_of_aform X ! i) = fst (half_segments_of_aform X ! Suc i)\"", "lemma polychain_half_segments_of_aform: \"polychain (half_segments_of_aform X)\"", "lemma fst_half_segments:\n  \"half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    fst (half_segments_of_aform X ! 0) = lowest_vertex (fst X, nlex_pdevs (snd X))\"", "lemma nlex_half_segments_of_aform: \"(a, b) \\<in> set (half_segments_of_aform X) \\<Longrightarrow> lex b a\"", "lemma ccw_half_segments_of_aform_all:\n  assumes cd: \"(c, d) \\<in> set (half_segments_of_aform X)\"\n  shows \"list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d) (half_segments_of_aform X)\"", "lemma ccw_half_segments_of_aform:\n  assumes ij: \"(xi, xj) \\<in> set (half_segments_of_aform X)\"\n  assumes c: \"(c, d) \\<in> set (half_segments_of_aform X)\"\n  shows \"ccw xi xj c\" \"ccw xi xj d\"", "lemma half_segments_of_aform1:\n  assumes ch: \"x \\<in> convex hull set (map fst (half_segments_of_aform X))\"\n  assumes ab: \"(a, b) \\<in> set (half_segments_of_aform X)\"\n  shows \"ccw a b x\"", "lemma half_segments_of_aform2:\n  assumes ch: \"x \\<in> convex hull set (map snd (half_segments_of_aform X))\"\n  assumes ab: \"(a, b) \\<in> set (half_segments_of_aform X)\"\n  shows \"ccw a b x\"", "lemma\n  in_set_half_segments_of_aform_aform_valE:\n  assumes \"(x2, y2) \\<in> set (half_segments_of_aform X)\"\n  obtains e where \"y2 = aform_val e X\" \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma fst_hd_half_segments_of_aform:\n  assumes \"half_segments_of_aform X \\<noteq> []\"\n  shows \"fst (hd (half_segments_of_aform X)) = lowest_vertex (fst X, (nlex_pdevs (snd X)))\"", "lemma\n  \"linorder_list0.sortedP (ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))))\n    (map snd (half_segments_of_aform X))\"\n  (is \"linorder_list0.sortedP (ccw' ?x0) ?ms\")", "lemma rev_zip: \"length xs = length ys \\<Longrightarrow> rev (zip xs ys) = zip (rev xs) (rev ys)\"", "lemma zip_upt_self_aux: \"zip [0..<length xs] xs = map (\\<lambda>i. (i, xs ! i)) [0..<length xs]\"", "lemma half_segments_of_aform_strict:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"seg \\<in> set (half_segments_of_aform X)\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"ccw' (fst seg) (snd seg) (aform_val e X)\"", "lemma half_segments_of_aform_strict_all:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X)) (half_segments_of_aform X)\"", "lemma list_allD: \"list_all P xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> P x\"", "lemma minus_one_less_multI:\n  fixes e x::real\n  shows \"- 1 \\<le> e \\<Longrightarrow> 0 < x \\<Longrightarrow> x < 1 \\<Longrightarrow> - 1 < e * x\"", "lemma less_one_multI:\n  fixes e x::real\n  shows \"e \\<le> 1 \\<Longrightarrow> 0 < x \\<Longrightarrow> x < 1 \\<Longrightarrow> e * x < 1\"", "lemma ccw_half_segments_of_aform_strictI:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"(s1, s2) \\<in> set (half_segments_of_aform X)\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  assumes \"x = (aform_val e X)\"\n  shows \"ccw' s1 s2 x\"", "lemma\n  ccw'_sortedP_subsequent:\n  assumes \"Suc i < length xs\" \"ccw'.sortedP 0 (map dirvec xs)\" \"fst (xs ! Suc i) = snd (xs ! i)\"\n  shows \"ccw' (fst (xs ! i)) (snd (xs ! i)) (snd (xs ! Suc i))\"", "lemma ccw'_sortedP_uminus: \"ccw'.sortedP 0 xs \\<Longrightarrow> ccw'.sortedP 0 (map uminus xs)\"", "lemma subsequent_half_segments_ccw:\n  fixes X\n  assumes \"Suc i < length (half_segments_of_aform X)\"\n  shows \"ccw' (fst (half_segments_of_aform X ! i)) (snd (half_segments_of_aform X ! i))\n    (snd (half_segments_of_aform X ! Suc i))\"", "lemma convex_polychain_half_segments_of_aform: \"convex_polychain (half_segments_of_aform X)\"", "lemma hd_distinct_neq_last: \"distinct xs \\<Longrightarrow> length xs > 1 \\<Longrightarrow> hd xs \\<noteq> last xs\"", "lemma ccw_hd_last_half_segments_dirvec:\n  assumes \"length (half_segments_of_aform X) > 1\"\n  shows \"ccw' 0 (dirvec (hd (half_segments_of_aform X))) (dirvec (last (half_segments_of_aform X)))\"", "lemma map_fst_half_segments_aux_eq: \"[] \\<noteq> half_segments_of_aform X \\<Longrightarrow>\n    map fst (half_segments_of_aform X) =\n      fst (hd (half_segments_of_aform X))#butlast (map snd (half_segments_of_aform X))\"", "lemma le_less_Suc_eq: \"x - Suc 0 \\<le> (i::nat) \\<Longrightarrow> i < x \\<Longrightarrow> x - Suc 0 = i\"", "lemma map_snd_half_segments_aux_eq: \"half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    map snd (half_segments_of_aform X) =\n      tl (map fst (half_segments_of_aform X)) @ [snd (last (half_segments_of_aform X))]\"", "lemma ccw'_sortedP_snd_half_segments_of_aform:\n  \"ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X))) (map snd (half_segments_of_aform X))\"", "lemma\n  lex_half_segments_lowest_vertex:\n  assumes \"(c, d) \\<in> set (half_segments_of_aform X)\"\n  shows \"lex d (lowest_vertex (fst X, nlex_pdevs (snd X)))\"", "lemma\n  lex_half_segments_lowest_vertex':\n  assumes \"d \\<in> set (map snd (half_segments_of_aform X))\"\n  shows \"lex d (lowest_vertex (fst X, nlex_pdevs (snd X)))\"", "lemma\n  lex_half_segments_last:\n  assumes \"(c, d) \\<in> set (half_segments_of_aform X)\"\n  shows \"lex (snd (last (half_segments_of_aform X))) d\"", "lemma\n  lex_half_segments_last':\n  assumes \"d \\<in> set (map snd (half_segments_of_aform X))\"\n  shows \"lex (snd (last (half_segments_of_aform X))) d\"", "lemma\n  ccw'_half_segments_lowest_last:\n  assumes set_butlast: \"(c, d) \\<in> set (butlast (half_segments_of_aform X))\"\n  assumes ne: \"inl (snd X) \\<noteq> []\"\n  shows \"ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) d (snd (last (half_segments_of_aform X)))\"", "lemma distinct_fst_half_segments:\n  \"distinct (map fst (half_segments_of_aform X))\"", "lemma distinct_snd_half_segments:\n  \"distinct (map snd (half_segments_of_aform X))\"", "lemma ccw'_mirror_point3[simp]:\n  \"ccw' (mirror_point x y) (mirror_point x z) (mirror_point x w) \\<longleftrightarrow> ccw' y z w \"", "lemma mirror_point_self_inverse[simp]:\n  fixes x::\"'a::real_vector\"\n  shows \"mirror_point p (mirror_point p x) = x\"", "lemma mirror_half_segments_of_aform:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X))\n      (map (pairself (mirror_point (fst X))) (half_segments_of_aform X))\"", "lemma last_half_segments:\n  assumes \"half_segments_of_aform X \\<noteq> []\"\n  shows \"snd (last (half_segments_of_aform X)) =\n    mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\"", "lemma convex_polychain_map_mirror:\n  assumes \"convex_polychain hs\"\n  shows \"convex_polychain (map (pairself (mirror_point x)) hs)\"", "lemma ccw'_mirror_point0:\n  \"ccw' (mirror_point x y) z w \\<longleftrightarrow> ccw' y (mirror_point x z) (mirror_point x w)\"", "lemma ccw'_sortedP_mirror:\n  \"ccw'.sortedP x0 (map (mirror_point p0) xs) \\<longleftrightarrow> ccw'.sortedP (mirror_point p0 x0) xs\"", "lemma ccw'_sortedP_mirror2:\n  \"ccw'.sortedP (mirror_point p0 x0) (map (mirror_point p0) xs) \\<longleftrightarrow> ccw'.sortedP x0 xs\"", "lemma map_mirror_o_snd_polychain_of_eq: \"map (mirror_point x0 \\<circ> snd) (polychain_of y xs) =\n  map snd (polychain_of (mirror_point x0 y) (map uminus xs))\"", "lemma lowest_vertex_eq_mirror_last:\n  \"half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    (lowest_vertex (fst X, nlex_pdevs (snd X))) =\n    mirror_point (fst X) (snd (last (half_segments_of_aform X)))\"", "lemma snd_last: \"xs \\<noteq> [] \\<Longrightarrow> snd (last xs) = last (map snd xs)\"", "lemma mirror_point_snd_last_eq_lowest:\n  \"half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    mirror_point (fst X) (last (map snd (half_segments_of_aform X))) =\n      lowest_vertex (fst X, nlex_pdevs (snd X))\"", "lemma lex_mirror_point: \"lex (mirror_point x0 a) (mirror_point x0 b) \\<Longrightarrow> lex b a\"", "lemma ccw'_mirror_point:\n  \"ccw' (mirror_point x0 a) (mirror_point x0 b)  (mirror_point x0 c) \\<Longrightarrow> ccw' a b c\"", "lemma inj_mirror_point: \"inj (mirror_point (x::'a::real_vector))\"", "lemma\n  distinct_map_mirror_point_eq:\n  \"distinct (map (mirror_point (x::'a::real_vector)) xs) = distinct xs\"", "lemma eq_self_mirror_iff: fixes x::\"'a::real_vector\" shows \"x = mirror_point y x \\<longleftrightarrow> x = y\"", "lemma segments_of_aform_strict:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X)) (segments_of_aform X)\"", "lemma mirror_point_aform_val[simp]: \"mirror_point (fst X) (aform_val e X) = aform_val (- e) X\"", "lemma\n  in_set_segments_of_aform_aform_valE:\n  assumes \"(x2, y2) \\<in> set (segments_of_aform X)\"\n  obtains e where \"y2 = aform_val e X\" \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma\n  last_half_segments_eq_mirror_hd:\n  assumes \"half_segments_of_aform X \\<noteq> []\"\n  shows \"snd (last (half_segments_of_aform X)) = mirror_point (fst X) (fst (hd (half_segments_of_aform X)))\"", "lemma polychain_segments_of_aform: \"polychain (segments_of_aform X)\"", "lemma segments_of_aform_closed:\n  assumes \"segments_of_aform X \\<noteq> []\"\n  shows \"fst (hd (segments_of_aform X)) = snd (last (segments_of_aform X))\"", "lemma convex_polychain_segments_of_aform:\n  assumes \"1 < length (half_segments_of_aform X)\"\n  shows \"convex_polychain (segments_of_aform X)\"", "lemma convex_polygon_segments_of_aform:\n  assumes \"1 < length (half_segments_of_aform X)\"\n  shows \"convex_polygon (segments_of_aform X)\"", "lemma\n  previous_segments_of_aformE:\n  assumes \"(y, z) \\<in> set (segments_of_aform X)\"\n  obtains x where \"(x, y) \\<in> set (segments_of_aform X)\"", "lemma fst_compose_pairself: \"fst o pairself f = f o fst\"\n  and snd_compose_pairself: \"snd o pairself f = f o snd\"", "lemma in_set_butlastI: \"xs \\<noteq> [] \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> x \\<noteq> last xs \\<Longrightarrow> x \\<in> set (butlast xs)\"", "lemma distinct_in_set_butlastD:\n  \"x \\<in> set (butlast xs) \\<Longrightarrow> distinct xs \\<Longrightarrow> x \\<noteq> last xs\"", "lemma distinct_in_set_tlD:\n  \"x \\<in> set (tl xs) \\<Longrightarrow> distinct xs \\<Longrightarrow> x \\<noteq> hd xs\"", "lemma ccw'_sortedP_snd_segments_of_aform:\n  assumes \"length (inl (snd X)) > 1\"\n  shows\n    \"ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n      (butlast (map snd (segments_of_aform X)))\"", "lemma polychain_of_segments_of_aform1:\n  assumes \"length (segments_of_aform X) = 1\"\n  shows \"False\"", "lemma polychain_of_segments_of_aform2:\n  assumes \"segments_of_aform X = [x, y]\"\n  assumes \"between (fst x, snd x) p\"\n  shows \"p \\<in> convex hull set (map fst (segments_of_aform X))\"", "lemma append_eq_2:\n  assumes \"length xs = length ys\"\n  shows \"xs @ ys = [x, y] \\<longleftrightarrow> xs = [x] \\<and> ys = [y]\"", "lemma segments_of_aform_line_segment:\n  assumes \"segments_of_aform X = [x, y]\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"aform_val e X \\<in> closed_segment (fst x) (snd x)\"", "lemma LIMSEQ_minus_fract_mult:\n  \"(\\<lambda>n. r * (1 - 1 / real (Suc (Suc n)))) \\<longlonglongrightarrow> r\"", "lemma det3_nonneg_segments_of_aform:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"list_all (\\<lambda>seg. det3 (fst seg) (snd seg) (aform_val e X) \\<ge> 0) (segments_of_aform X)\"", "lemma det3_nonneg_segments_of_aformI:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  assumes \"seg \\<in> set (segments_of_aform X)\"\n  shows \"det3 (fst seg) (snd seg) (aform_val e X) \\<ge> 0\"", "lemma norm_pair_fst0[simp]: \"norm (0, x) = norm x\"", "lemmas add_right_mono_le = order_trans[OF add_right_mono]", "lemmas mult_right_mono_le = order_trans[OF mult_right_mono]", "lemmas add_right_mono_ge = order_trans[OF _ add_right_mono]", "lemmas mult_right_mono_ge = order_trans[OF _ mult_right_mono]", "lemma dest_segment:\n  fixes x b::real\n  assumes \"(x, b) \\<in> closed_segment (x0, y0) (x1, y1)\"\n  assumes \"x0 \\<noteq> x1\"\n  shows \"b = (y1 - y0) * (x - x0) / (x1 - x0) + y0\"", "lemma intersect_segment_xline':\n  assumes \"intersect_segment_xline' prec (p0, p1) x = Some (m, M)\"\n  shows \"closed_segment p0 p1 \\<inter> {p. fst p = x} \\<subseteq> {(x, m) .. (x, M)}\"", "lemma\n  in_segment_fst_le:\n  fixes x0 x1 b::real\n  assumes \"x0 \\<le> x1\" \"(x, b) \\<in> closed_segment (x0, y0) (x1, y1)\"\n  shows \"x \\<le> x1\"", "lemma\n  in_segment_fst_ge:\n  fixes x0 x1 b::real\n  assumes \"x0 \\<le> x1\" \"(x, b) \\<in> closed_segment (x0, y0) (x1, y1)\"\n  shows \"x0 \\<le> x\"", "lemma intersect_segment_xline'_eq_None:\n  assumes \"intersect_segment_xline' prec (p0, p1) x = None\"\n  assumes \"fst p0 \\<le> fst p1\"\n  shows \"closed_segment p0 p1 \\<inter> {p. fst p = x} = {}\"", "lemma closed_segment_commute: \"closed_segment a b = closed_segment b a\"", "lemma intersect_segment_xline:\n  assumes \"intersect_segment_xline prec (p0, p1) x = Some (m, M)\"\n  shows \"closed_segment p0 p1 \\<inter> {p. fst p = x} \\<subseteq> {(x, m) .. (x, M)}\"", "lemma intersect_segment_xline_fst_snd:\n  assumes \"intersect_segment_xline prec seg x = Some (m, M)\"\n  shows \"closed_segment (fst seg) (snd seg) \\<inter> {p. fst p = x} \\<subseteq> {(x, m) .. (x, M)}\"", "lemma intersect_segment_xline_eq_None:\n  assumes \"intersect_segment_xline prec (p0, p1) x = None\"\n  shows \"closed_segment p0 p1 \\<inter> {p. fst p = x} = {}\"", "lemma inter_image_empty_iff: \"(X \\<inter> {p. f p = x} = {}) \\<longleftrightarrow> (x \\<notin> f ` X)\"", "lemma fst_closed_segment[simp]: \"fst ` closed_segment a b = closed_segment (fst a) (fst b)\"", "lemma intersect_segment_xline_eq_empty:\n  fixes p0 p1::\"real * real\"\n  assumes \"closed_segment p0 p1 \\<inter> {p. fst p = x} = {}\"\n  shows \"intersect_segment_xline prec (p0, p1) x = None\"", "lemma intersect_segment_xline_le:\n  assumes \"intersect_segment_xline prec y xl = Some (m0, M0)\"\n  shows \"m0 \\<le> M0\"", "lemma intersect_segment_xline_None_iff:\n  fixes p0 p1::\"real * real\"\n  shows \"intersect_segment_xline prec (p0, p1) x = None \\<longleftrightarrow> closed_segment p0 p1 \\<inter> {p. fst p = x} = {}\"", "lemma\n  bound_intersect_2d_eq_None:\n  assumes \"bound_intersect_2d prec Xs x = None\"\n  assumes \"X \\<in> set Xs\"\n  shows \"intersect_segment_xline prec X x = None\"", "lemma bound_intersect_2d_upper:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\"\n  obtains X m' where \"X \\<in> set Xs\" \"intersect_segment_xline prec X x = Some (m', M)\"\n    \"\\<And>X m' M' . X \\<in> set Xs \\<Longrightarrow> intersect_segment_xline prec X x = Some (m', M') \\<Longrightarrow> M' \\<le> M\"", "lemma bound_intersect_2d_lower:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\"\n  obtains X M' where \"X \\<in> set Xs\" \"intersect_segment_xline prec X x = Some (m, M')\"\n    \"\\<And>X m' M' . X \\<in> set Xs \\<Longrightarrow> intersect_segment_xline prec X x = Some (m', M') \\<Longrightarrow> m \\<le> m'\"", "lemma bound_intersect_2d:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\"\n  shows \"(\\<Union>(p1, p2) \\<in> set Xs. closed_segment p1 p2) \\<inter> {p. fst p = x} \\<subseteq> {(x, m) .. (x, M)}\"", "lemma bound_intersect_2d_eq_None_iff:\n  \"bound_intersect_2d prec Xs x = None \\<longleftrightarrow> (\\<forall>X\\<in>set Xs. intersect_segment_xline prec X x = None)\"", "lemma bound_intersect_2d_nonempty:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\"\n  shows \"(\\<Union>(p1, p2) \\<in> set Xs. closed_segment p1 p2) \\<inter> {p. fst p = x} \\<noteq> {}\"", "lemma bound_intersect_2d_le:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\" shows \"m \\<le> M\"", "lemma list_cases4:\n  \"\\<And>x P. (x = [] \\<Longrightarrow> P) \\<Longrightarrow> (\\<And>y. x = [y] \\<Longrightarrow> P) \\<Longrightarrow>\n    (\\<And>y z. x = [y, z] \\<Longrightarrow> P) \\<Longrightarrow>\n    (\\<And>w y z zs. x = w # y # z # zs \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma bound_intersect_2d_ud_segments_of_aform_le:\n  \"bound_intersect_2d_ud prec X xl = Some (m0, M0) \\<Longrightarrow> m0 \\<le> M0\"", "lemma pdevs_domain_eq_empty_iff[simp]: \"pdevs_domain (snd X) = {} \\<longleftrightarrow> snd X = zero_pdevs\"", "lemma ccw_contr_on_line_left:\n  assumes \"det3 (a, b) (x, c) (x, d) \\<ge> 0\" \"a > x\"\n  shows \"d \\<le> c\"", "lemma ccw_contr_on_line_right:\n  assumes \"det3 (a, b) (x, c) (x, d) \\<ge> 0\" \"a < x\"\n  shows \"d \\<ge> c\"", "lemma singleton_contrE:\n  assumes \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> False\"\n  assumes \"X \\<noteq> {}\"\n  obtains x where \"X = {x}\"", "lemma segment_intersection_singleton:\n  fixes xl and a b::\"real * real\"\n  defines \"i \\<equiv> closed_segment a b \\<inter> {p. fst p = xl}\"\n  assumes ne1: \"fst a \\<noteq> fst b\"\n  assumes upper: \"i \\<noteq> {}\"\n  obtains p1 where \"i = {p1}\"", "lemma bound_intersect_2d_ud_segments_of_aform:\n  assumes \"bound_intersect_2d_ud prec X xl = Some (m0, M0)\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"{aform_val e X} \\<inter> {x. fst x = xl} \\<subseteq> {(xl, m0) .. (xl, M0)}\"", "lemma\n  those_eq_SomeD:\n  assumes \"those (map f xs) = Some ys\"\n  shows \"ys = map (the o f) xs \\<and> (\\<forall>i.\\<exists>y. i < length xs \\<longrightarrow> f (xs ! i) = Some y)\"", "lemma\n  sum_list_zip_map:\n  assumes \"distinct xs\"\n  shows \"(\\<Sum>(x, y)\\<leftarrow>zip xs (map g xs). f x y) = (\\<Sum>x\\<in>set xs. f x (g x))\"", "lemma\n  inter_aform_plane_ortho_overappr:\n  assumes \"inter_aform_plane_ortho p Z n g = Some X\"\n  shows \"{x. \\<forall>i \\<in> Basis. x \\<bullet> i \\<in> {y. (g, y) \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Affine Z}} \\<subseteq> Affine X\"", "lemma inter_proj_eq:\n  fixes n g l\n  defines \"G \\<equiv> {x. x \\<bullet> n = g}\"\n  shows \"(\\<lambda>x. x \\<bullet> l) ` (Z \\<inter> G) =\n    {y. (g, y) \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> l)) ` Z}\"", "lemma\n  inter_overappr:\n  fixes n \\<gamma> l\n  shows \"Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> {x. \\<forall>i \\<in> Basis. x \\<bullet> i \\<in> {y. (g, y) \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Z}}\"", "lemma inter_inter_aform_plane_ortho:\n  assumes \"inter_aform_plane_ortho p Z n g = Some X\"\n  shows \"Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X\"", "lemma encompasses_cases:\n  \"encompasses x seg \\<or> encompasses x (snd seg, fst seg)\"", "lemma list_all_encompasses_cases:\n  assumes \"list_all (encompasses p) (x # y # zs)\"\n  obtains \"list_all (encompasses p) [x, y, (snd y, fst x)]\"\n    | \"list_all (encompasses p) ((fst x, snd y)#zs)\"", "lemma triangle_encompassing_polychain_of:\n  assumes \"det3 p a b \\<ge> 0\" \"det3 p b c \\<ge> 0\" \"det3 p c a \\<ge> 0\"\n  assumes \"ccw' a b c\"\n  shows \"p \\<in> convex hull {a, b, c}\"", "lemma encompasses_convex_polygon3:\n  assumes \"list_all (encompasses p) (x#y#z#zs)\"\n  assumes \"convex_polygon (x#y#z#zs)\"\n  assumes \"ccw'.sortedP (fst x) (map snd (butlast (x#y#z#zs)))\"\n  shows \"p \\<in> convex hull (set (map fst (x#y#z#zs)))\"", "lemma segments_of_aform_empty_Affine_eq:\n  assumes \"segments_of_aform X = []\"\n  shows \"Affine X = {fst X}\"", "lemma not_segments_of_aform_singleton: \"segments_of_aform X \\<noteq> [x]\"", "lemma encompasses_segments_of_aform_in_AffineI:\n  assumes \"length (segments_of_aform X) > 2\"\n  assumes \"list_all (encompasses p) (segments_of_aform X)\"\n  shows \"p \\<in> Affine X\""], "translations": [["", "lemma polychain_of_ccw_conjunction:\n  assumes sorted: \"ccw'.sortedP 0 Ps\"\n  assumes z: \"z \\<in> set (polychain_of Pc Ps)\"\n  shows \"list_all (\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z)) (polychain_of Pc Ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc Ps)", "using assms"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 Ps\n  z \\<in> set (polychain_of Pc Ps)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc Ps)", "proof (induction Ps arbitrary: Pc z rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "case (Cons P Ps)"], ["proof (state)\nthis:\n  \\<lbrakk>ccw'.sortedP 0 Ps; ?z \\<in> set (polychain_of ?Pc Ps)\\<rbrakk>\n  \\<Longrightarrow> list_all\n                     (\\<lambda>a.\n                         case a of\n                         (xi, xj) \\<Rightarrow>\n                           ccw xi xj (fst ?z) \\<and> ccw xi xj (snd ?z))\n                     (polychain_of ?Pc Ps)\n  ccw'.sortedP 0 (P # Ps)\n  z \\<in> set (polychain_of Pc (P # Ps))\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>ccw'.sortedP 0 Ps; ?z \\<in> set (polychain_of ?Pc Ps)\\<rbrakk>\n  \\<Longrightarrow> list_all\n                     (\\<lambda>a.\n                         case a of\n                         (xi, xj) \\<Rightarrow>\n                           ccw xi xj (fst ?z) \\<and> ccw xi xj (snd ?z))\n                     (polychain_of ?Pc Ps)\n  ccw'.sortedP 0 (P # Ps)\n  z \\<in> set (polychain_of Pc (P # Ps))\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "assume \"set Ps = {}\""], ["proof (state)\nthis:\n  set Ps = {}\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "hence ?case"], ["proof (prove)\nusing this:\n  set Ps = {}\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "using Cons"], ["proof (prove)\nusing this:\n  set Ps = {}\n  \\<lbrakk>ccw'.sortedP 0 Ps; ?z \\<in> set (polychain_of ?Pc Ps)\\<rbrakk>\n  \\<Longrightarrow> list_all\n                     (\\<lambda>a.\n                         case a of\n                         (xi, xj) \\<Rightarrow>\n                           ccw xi xj (fst ?z) \\<and> ccw xi xj (snd ?z))\n                     (polychain_of ?Pc Ps)\n  ccw'.sortedP 0 (P # Ps)\n  z \\<in> set (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "by simp"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "}"], ["proof (state)\nthis:\n  set Ps = {} \\<Longrightarrow>\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "moreover"], ["proof (state)\nthis:\n  set Ps = {} \\<Longrightarrow>\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "{"], ["proof (state)\nthis:\n  set Ps = {} \\<Longrightarrow>\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "assume \"set Ps \\<noteq> {}\""], ["proof (state)\nthis:\n  set Ps \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "hence \"Ps \\<noteq> []\""], ["proof (prove)\nusing this:\n  set Ps \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Ps \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  Ps \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "{"], ["proof (state)\nthis:\n  Ps \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "assume \"a \\<in> set Ps\""], ["proof (state)\nthis:\n  a \\<in> set Ps\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "hence \"ccw' 0 P a\""], ["proof (prove)\nusing this:\n  a \\<in> set Ps\n\ngoal (1 subgoal):\n 1. ccw' 0 P a", "using Cons.prems"], ["proof (prove)\nusing this:\n  a \\<in> set Ps\n  ccw'.sortedP 0 (P # Ps)\n  z \\<in> set (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. ccw' 0 P a", "by (auto elim!: linorder_list0.sortedP_Cons)"], ["proof (state)\nthis:\n  ccw' 0 P a\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "}"], ["proof (state)\nthis:\n  ?a2 \\<in> set Ps \\<Longrightarrow> ccw' 0 P ?a2\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "note ccw' = this"], ["proof (state)\nthis:\n  ?a2 \\<in> set Ps \\<Longrightarrow> ccw' 0 P ?a2\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "have sorted': \"linorder_list0.sortedP (ccw' 0) Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 Ps", "using Cons.prems"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 (P # Ps)\n  z \\<in> set (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 Ps", "by (auto elim!: linorder_list0.sortedP_Cons)"], ["proof (state)\nthis:\n  ccw'.sortedP 0 Ps\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "from in_set_polychain_of_imp_sum_list[OF Cons(3)]"], ["proof (chain)\npicking this:\n  (\\<And>d.\n      z =\n      (Pc + sum_list (take d (P # Ps)),\n       Pc + sum_list (take (Suc d) (P # Ps))) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain d\n    where d: \"z = (Pc + sum_list (take d (P # Ps)), Pc + sum_list (take (Suc d) (P # Ps)))\""], ["proof (prove)\nusing this:\n  (\\<And>d.\n      z =\n      (Pc + sum_list (take d (P # Ps)),\n       Pc + sum_list (take (Suc d) (P # Ps))) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        z =\n        (Pc + sum_list (take d (P # Ps)),\n         Pc + sum_list (take (Suc d) (P # Ps))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  z =\n  (Pc + sum_list (take d (P # Ps)), Pc + sum_list (take (Suc d) (P # Ps)))\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "from Cons(3)"], ["proof (chain)\npicking this:\n  z \\<in> set (polychain_of Pc (P # Ps))", "have disj: \"z = (Pc, Pc + P) \\<or> z \\<in> set (polychain_of (Pc + P) Ps)\""], ["proof (prove)\nusing this:\n  z \\<in> set (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. z = (Pc, Pc + P) \\<or> z \\<in> set (polychain_of (Pc + P) Ps)", "by auto"], ["proof (state)\nthis:\n  z = (Pc, Pc + P) \\<or> z \\<in> set (polychain_of (Pc + P) Ps)\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "let ?th = \"\\<lambda>(xi, xj). ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "have la: \"list_all ?th (polychain_of (Pc + P) Ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xi, xj). ccw xi xj Pc \\<and> ccw xi xj (Pc + P))\n     (polychain_of (Pc + P) Ps)", "proof (rule list_allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "assume x: \"x \\<in> set (polychain_of (Pc + P) Ps)\""], ["proof (state)\nthis:\n  x \\<in> set (polychain_of (Pc + P) Ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "from in_set_polychain_of_imp_sum_list[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>d.\n      x =\n      (Pc + P + sum_list (take d Ps),\n       Pc + P + sum_list (take (Suc d) Ps)) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e where e: \"x = (Pc + P + sum_list (take e Ps), Pc + P + sum_list (take (Suc e) Ps))\""], ["proof (prove)\nusing this:\n  (\\<And>d.\n      x =\n      (Pc + P + sum_list (take d Ps),\n       Pc + P + sum_list (take (Suc d) Ps)) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        x =\n        (Pc + P + sum_list (take e Ps),\n         Pc + P + sum_list (take (Suc e) Ps)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = (Pc + P + sum_list (take e Ps), Pc + P + sum_list (take (Suc e) Ps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "{"], ["proof (state)\nthis:\n  x = (Pc + P + sum_list (take e Ps), Pc + P + sum_list (take (Suc e) Ps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "assume \"e \\<ge> length Ps\""], ["proof (state)\nthis:\n  length Ps \\<le> e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "hence \"?th x\""], ["proof (prove)\nusing this:\n  length Ps \\<le> e\n\ngoal (1 subgoal):\n 1. case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "by (auto simp: e)"], ["proof (state)\nthis:\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "}"], ["proof (state)\nthis:\n  length Ps \\<le> e \\<Longrightarrow>\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "moreover"], ["proof (state)\nthis:\n  length Ps \\<le> e \\<Longrightarrow>\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "{"], ["proof (state)\nthis:\n  length Ps \\<le> e \\<Longrightarrow>\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "assume \"e < length Ps\""], ["proof (state)\nthis:\n  e < length Ps\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "have 0: \"\\<And>e. e < length Ps \\<Longrightarrow> ccw' 0 P (Ps ! e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e. e < length Ps \\<Longrightarrow> ccw' 0 P (Ps ! e)", "by (rule ccw') (simp add: )"], ["proof (state)\nthis:\n  ?e < length Ps \\<Longrightarrow> ccw' 0 P (Ps ! ?e)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "have 2: \"0 < e \\<Longrightarrow> ccw' 0 (P + sum_list (take e Ps)) (Ps ! e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e \\<Longrightarrow> ccw' 0 (P + sum_list (take e Ps)) (Ps ! e)", "using \\<open>e < length Ps\\<close>"], ["proof (prove)\nusing this:\n  e < length Ps\n\ngoal (1 subgoal):\n 1. 0 < e \\<Longrightarrow> ccw' 0 (P + sum_list (take e Ps)) (Ps ! e)", "by (auto intro!: ccw'.add1 0 ccw'.sum2 sorted' ccw'.sorted_nth_less\n            simp: sum_list_sum_nth)"], ["proof (state)\nthis:\n  0 < e \\<Longrightarrow> ccw' 0 (P + sum_list (take e Ps)) (Ps ! e)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "have \"ccw Pc (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw Pc (Pc + P + sum_list (take e Ps))\n     (Pc + P + sum_list (take (Suc e) Ps))", "by (cases \"e = 0\")\n            (auto simp add: ccw_translate_origin take_Suc_eq add.assoc[symmetric] 0 2\n              intro!: ccw'_imp_ccw intro: cyclic)"], ["proof (state)\nthis:\n  ccw Pc (Pc + P + sum_list (take e Ps))\n   (Pc + P + sum_list (take (Suc e) Ps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "hence \"ccw (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps)) Pc\""], ["proof (prove)\nusing this:\n  ccw Pc (Pc + P + sum_list (take e Ps))\n   (Pc + P + sum_list (take (Suc e) Ps))\n\ngoal (1 subgoal):\n 1. ccw (Pc + P + sum_list (take e Ps))\n     (Pc + P + sum_list (take (Suc e) Ps)) Pc", "by (rule cyclic)"], ["proof (state)\nthis:\n  ccw (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps))\n   Pc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "moreover"], ["proof (state)\nthis:\n  ccw (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps))\n   Pc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "have \"0 < e \\<Longrightarrow> ccw 0 (Ps ! e) (- sum_list (take e Ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e \\<Longrightarrow> ccw 0 (Ps ! e) (- sum_list (take e Ps))", "using \\<open>e < length Ps\\<close>"], ["proof (prove)\nusing this:\n  e < length Ps\n\ngoal (1 subgoal):\n 1. 0 < e \\<Longrightarrow> ccw 0 (Ps ! e) (- sum_list (take e Ps))", "by (auto simp add: take_Suc_eq add.assoc[symmetric]\n              sum_list_sum_nth\n            intro!: ccw'_imp_ccw ccw'.sum2 sorted' ccw'.sorted_nth_less)"], ["proof (state)\nthis:\n  0 < e \\<Longrightarrow> ccw 0 (Ps ! e) (- sum_list (take e Ps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "hence \"ccw (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps)) (Pc + P)\""], ["proof (prove)\nusing this:\n  0 < e \\<Longrightarrow> ccw 0 (Ps ! e) (- sum_list (take e Ps))\n\ngoal (1 subgoal):\n 1. ccw (Pc + P + sum_list (take e Ps))\n     (Pc + P + sum_list (take (Suc e) Ps)) (Pc + P)", "by (cases \"e = 0\") (simp_all add: ccw_translate_origin take_Suc_eq)"], ["proof (state)\nthis:\n  ccw (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps))\n   (Pc + P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "ultimately"], ["proof (chain)\npicking this:\n  ccw (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps))\n   Pc\n  ccw (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps))\n   (Pc + P)", "have \"?th x\""], ["proof (prove)\nusing this:\n  ccw (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps))\n   Pc\n  ccw (Pc + P + sum_list (take e Ps)) (Pc + P + sum_list (take (Suc e) Ps))\n   (Pc + P)\n\ngoal (1 subgoal):\n 1. case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "by (auto simp add: e)"], ["proof (state)\nthis:\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "}"], ["proof (state)\nthis:\n  e < length Ps \\<Longrightarrow>\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n       case x of\n       (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "ultimately"], ["proof (chain)\npicking this:\n  length Ps \\<le> e \\<Longrightarrow>\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n  e < length Ps \\<Longrightarrow>\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "show \"?th x\""], ["proof (prove)\nusing this:\n  length Ps \\<le> e \\<Longrightarrow>\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n  e < length Ps \\<Longrightarrow>\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n\ngoal (1 subgoal):\n 1. case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)", "by arith"], ["proof (state)\nthis:\n  case x of (xi, xj) \\<Rightarrow> ccw xi xj Pc \\<and> ccw xi xj (Pc + P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all (\\<lambda>(xi, xj). ccw xi xj Pc \\<and> ccw xi xj (Pc + P))\n   (polychain_of (Pc + P) Ps)\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "from disj"], ["proof (chain)\npicking this:\n  z = (Pc, Pc + P) \\<or> z \\<in> set (polychain_of (Pc + P) Ps)", "have ?case"], ["proof (prove)\nusing this:\n  z = (Pc, Pc + P) \\<or> z \\<in> set (polychain_of (Pc + P) Ps)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "assume z: \"z \\<in> set (polychain_of (Pc + P) Ps)\""], ["proof (state)\nthis:\n  z \\<in> set (polychain_of (Pc + P) Ps)\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "have \"ccw 0 P (sum_list (take d (P # Ps)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw 0 P (sum_list (take d (P # Ps)))", "proof (cases d)"], ["proof (state)\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))\n 2. \\<And>nat.\n       d = Suc nat \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))", "case (Suc e)"], ["proof (state)\nthis:\n  d = Suc e\n\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))\n 2. \\<And>nat.\n       d = Suc nat \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))", "note e = this"], ["proof (state)\nthis:\n  d = Suc e\n\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))\n 2. \\<And>nat.\n       d = Suc nat \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw 0 P (sum_list (take d (P # Ps)))", "proof (cases e)"], ["proof (state)\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))\n 2. \\<And>nat.\n       e = Suc nat \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))", "case (Suc f)"], ["proof (state)\nthis:\n  e = Suc f\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))\n 2. \\<And>nat.\n       e = Suc nat \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))", "have \"ccw 0 P (P + sum_list (take (Suc f) Ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw 0 P (P + sum_list (take (Suc f) Ps))", "using z"], ["proof (prove)\nusing this:\n  z \\<in> set (polychain_of (Pc + P) Ps)\n\ngoal (1 subgoal):\n 1. ccw 0 P (P + sum_list (take (Suc f) Ps))", "by (force simp add: sum_list_sum_nth intro!: ccw'.sum intro: ccw' ccw'_imp_ccw)"], ["proof (state)\nthis:\n  ccw 0 P (P + sum_list (take (Suc f) Ps))\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))\n 2. \\<And>nat.\n       e = Suc nat \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ccw 0 P (P + sum_list (take (Suc f) Ps))\n\ngoal (1 subgoal):\n 1. ccw 0 P (sum_list (take d (P # Ps)))", "by (simp add: e Suc)"], ["proof (state)\nthis:\n  ccw 0 P (sum_list (take d (P # Ps)))\n\ngoal (1 subgoal):\n 1. e = 0 \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))", "qed (simp add: e)"], ["proof (state)\nthis:\n  ccw 0 P (sum_list (take d (P # Ps)))\n\ngoal (1 subgoal):\n 1. d = 0 \\<Longrightarrow> ccw 0 P (sum_list (take d (P # Ps)))", "qed simp"], ["proof (state)\nthis:\n  ccw 0 P (sum_list (take d (P # Ps)))\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "hence \"ccw Pc (Pc + P) (fst z)\""], ["proof (prove)\nusing this:\n  ccw 0 P (sum_list (take d (P # Ps)))\n\ngoal (1 subgoal):\n 1. ccw Pc (Pc + P) (fst z)", "by (simp add: d ccw_translate_origin)"], ["proof (state)\nthis:\n  ccw Pc (Pc + P) (fst z)\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "moreover"], ["proof (state)\nthis:\n  ccw Pc (Pc + P) (fst z)\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "from z"], ["proof (chain)\npicking this:\n  z \\<in> set (polychain_of (Pc + P) Ps)", "have \"ccw 0 P (P + sum_list (take d Ps))\""], ["proof (prove)\nusing this:\n  z \\<in> set (polychain_of (Pc + P) Ps)\n\ngoal (1 subgoal):\n 1. ccw 0 P (P + sum_list (take d Ps))", "by (cases d, force)\n          (force simp add: sum_list_sum_nth intro!: ccw'_imp_ccw ccw'.sum intro: ccw')+"], ["proof (state)\nthis:\n  ccw 0 P (P + sum_list (take d Ps))\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "hence \"ccw Pc (Pc + P) (snd z)\""], ["proof (prove)\nusing this:\n  ccw 0 P (P + sum_list (take d Ps))\n\ngoal (1 subgoal):\n 1. ccw Pc (Pc + P) (snd z)", "by (simp add: d ccw_translate_origin)"], ["proof (state)\nthis:\n  ccw Pc (Pc + P) (snd z)\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "moreover"], ["proof (state)\nthis:\n  ccw Pc (Pc + P) (snd z)\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "from z Cons.prems"], ["proof (chain)\npicking this:\n  z \\<in> set (polychain_of (Pc + P) Ps)\n  ccw'.sortedP 0 (P # Ps)\n  z \\<in> set (polychain_of Pc (P # Ps))", "have \"list_all (\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n        (polychain_of (Pc + P) Ps)\""], ["proof (prove)\nusing this:\n  z \\<in> set (polychain_of (Pc + P) Ps)\n  ccw'.sortedP 0 (P # Ps)\n  z \\<in> set (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of (Pc + P) Ps)", "by (intro Cons.IH) (auto elim!: linorder_list0.sortedP_Cons)"], ["proof (state)\nthis:\n  list_all (\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of (Pc + P) Ps)\n\ngoal (2 subgoals):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))\n 2. z \\<in> set (polychain_of (Pc + P) Ps) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "ultimately"], ["proof (chain)\npicking this:\n  ccw Pc (Pc + P) (fst z)\n  ccw Pc (Pc + P) (snd z)\n  list_all (\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of (Pc + P) Ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  ccw Pc (Pc + P) (fst z)\n  ccw Pc (Pc + P) (snd z)\n  list_all (\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of (Pc + P) Ps)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "by simp"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. z = (Pc, Pc + P) \\<Longrightarrow>\n    list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "qed (simp add: la)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "}"], ["proof (state)\nthis:\n  set Ps \\<noteq> {} \\<Longrightarrow>\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n\ngoal (2 subgoals):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])\n 2. \\<And>x1 x2 Pc z.\n       \\<lbrakk>\\<And>Pc z.\n                   \\<lbrakk>ccw'.sortedP 0 x2;\n                    z \\<in> set (polychain_of Pc x2)\\<rbrakk>\n                   \\<Longrightarrow> list_all\n(\\<lambda>(xi, xj). ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n(polychain_of Pc x2);\n        ccw'.sortedP 0 (x1 # x2);\n        z \\<in> set (polychain_of Pc (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc (x1 # x2))", "ultimately"], ["proof (chain)\npicking this:\n  set Ps = {} \\<Longrightarrow>\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n  set Ps \\<noteq> {} \\<Longrightarrow>\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))", "show ?case"], ["proof (prove)\nusing this:\n  set Ps = {} \\<Longrightarrow>\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n  set Ps \\<noteq> {} \\<Longrightarrow>\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>a.\n         case a of\n         (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n     (polychain_of Pc (P # Ps))", "by blast"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (xi, xj) \\<Rightarrow> ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n   (polychain_of Pc (P # Ps))\n\ngoal (1 subgoal):\n 1. \\<And>Pc z.\n       \\<lbrakk>ccw'.sortedP 0 []; z \\<in> set (polychain_of Pc [])\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(xi, xj).\n                              ccw xi xj (fst z) \\<and> ccw xi xj (snd z))\n                          (polychain_of Pc [])", "qed simp"], ["", "lemma lex_polychain_of_center:\n  \"d \\<in> set (polychain_of x0 xs) \\<Longrightarrow> list_all (\\<lambda>x. lex x 0) xs \\<Longrightarrow> lex (snd d) x0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d \\<in> set (polychain_of x0 xs);\n     list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n      xs\\<rbrakk>\n    \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex (snd d) x0", "proof (induction xs arbitrary: x0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x0.\n       \\<lbrakk>d \\<in> set (polychain_of x0 []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex (snd d) x0\n 2. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>d \\<in> set (polychain_of x0 xs);\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n(snd d) x0;\n        d \\<in> set (polychain_of x0 (a # xs));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex (snd d) x0", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>d \\<in> set (polychain_of ?x0.0 xs);\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\\<rbrakk>\n  \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex (snd d) ?x0.0\n  d \\<in> set (polychain_of x0 (x # xs))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>x0.\n       \\<lbrakk>d \\<in> set (polychain_of x0 []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex (snd d) x0\n 2. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>d \\<in> set (polychain_of x0 xs);\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n(snd d) x0;\n        d \\<in> set (polychain_of x0 (a # xs));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex (snd d) x0", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>d \\<in> set (polychain_of ?x0.0 xs);\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\\<rbrakk>\n  \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex (snd d) ?x0.0\n  d \\<in> set (polychain_of x0 (x # xs))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex (snd d) x0", "by (auto simp add: lex_def lex_translate_origin dest!: Cons.IH)"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex (snd d) x0\n\ngoal (1 subgoal):\n 1. \\<And>x0.\n       \\<lbrakk>d \\<in> set (polychain_of x0 []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex (snd d) x0", "qed (auto simp: lex_translate_origin)"], ["", "lemma lex_polychain_of_last:\n  \"(c, d) \\<in> set (polychain_of x0 xs) \\<Longrightarrow> list_all (\\<lambda>x. lex x 0) xs \\<Longrightarrow>\n    lex (snd (last (polychain_of x0 xs))) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, d) \\<in> set (polychain_of x0 xs);\n     list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n      xs\\<rbrakk>\n    \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                       (snd (last (polychain_of x0 xs))) d", "proof (induction xs arbitrary: x0 c d)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x0 c d.\n       \\<lbrakk>(c, d) \\<in> set (polychain_of x0 []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 []))) d\n 2. \\<And>a xs x0 c d.\n       \\<lbrakk>\\<And>x0 c d.\n                   \\<lbrakk>(c, d) \\<in> set (polychain_of x0 xs);\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n(snd (last (polychain_of x0 xs))) d;\n        (c, d) \\<in> set (polychain_of x0 (a # xs));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 (a # xs)))) d", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?c, ?d) \\<in> set (polychain_of ?x0.0 xs);\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\\<rbrakk>\n  \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                     (snd (last (polychain_of ?x0.0 xs))) ?d\n  (c, d) \\<in> set (polychain_of x0 (x # xs))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>x0 c d.\n       \\<lbrakk>(c, d) \\<in> set (polychain_of x0 []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 []))) d\n 2. \\<And>a xs x0 c d.\n       \\<lbrakk>\\<And>x0 c d.\n                   \\<lbrakk>(c, d) \\<in> set (polychain_of x0 xs);\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n(snd (last (polychain_of x0 xs))) d;\n        (c, d) \\<in> set (polychain_of x0 (a # xs));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 (a # xs)))) d", "let ?c1 = \"c = x0 \\<and> d = x0 + x\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x0 c d.\n       \\<lbrakk>(c, d) \\<in> set (polychain_of x0 []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 []))) d\n 2. \\<And>a xs x0 c d.\n       \\<lbrakk>\\<And>x0 c d.\n                   \\<lbrakk>(c, d) \\<in> set (polychain_of x0 xs);\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n(snd (last (polychain_of x0 xs))) d;\n        (c, d) \\<in> set (polychain_of x0 (a # xs));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 (a # xs)))) d", "let ?c2 = \"(c, d) \\<in> set (polychain_of (x0 + x) xs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x0 c d.\n       \\<lbrakk>(c, d) \\<in> set (polychain_of x0 []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 []))) d\n 2. \\<And>a xs x0 c d.\n       \\<lbrakk>\\<And>x0 c d.\n                   \\<lbrakk>(c, d) \\<in> set (polychain_of x0 xs);\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n(snd (last (polychain_of x0 xs))) d;\n        (c, d) \\<in> set (polychain_of x0 (a # xs));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 (a # xs)))) d", "from Cons(2)"], ["proof (chain)\npicking this:\n  (c, d) \\<in> set (polychain_of x0 (x # xs))", "have \"?c1 \\<or> ?c2\""], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (polychain_of x0 (x # xs))\n\ngoal (1 subgoal):\n 1. c = x0 \\<and> d = x0 + x \\<or>\n    (c, d) \\<in> set (polychain_of (x0 + x) xs)", "by auto"], ["proof (state)\nthis:\n  c = x0 \\<and> d = x0 + x \\<or> (c, d) \\<in> set (polychain_of (x0 + x) xs)\n\ngoal (2 subgoals):\n 1. \\<And>x0 c d.\n       \\<lbrakk>(c, d) \\<in> set (polychain_of x0 []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 []))) d\n 2. \\<And>a xs x0 c d.\n       \\<lbrakk>\\<And>x0 c d.\n                   \\<lbrakk>(c, d) \\<in> set (polychain_of x0 xs);\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n(snd (last (polychain_of x0 xs))) d;\n        (c, d) \\<in> set (polychain_of x0 (a # xs));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 (a # xs)))) d", "thus ?case"], ["proof (prove)\nusing this:\n  c = x0 \\<and> d = x0 + x \\<or> (c, d) \\<in> set (polychain_of (x0 + x) xs)\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. c = x0 \\<and> d = x0 + x \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d\n 2. (c, d) \\<in> set (polychain_of (x0 + x) xs) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d", "assume ?c1"], ["proof (state)\nthis:\n  c = x0 \\<and> d = x0 + x\n\ngoal (2 subgoals):\n 1. c = x0 \\<and> d = x0 + x \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d\n 2. (c, d) \\<in> set (polychain_of (x0 + x) xs) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d", "with Cons.prems"], ["proof (chain)\npicking this:\n  (c, d) \\<in> set (polychain_of x0 (x # xs))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  c = x0 \\<and> d = x0 + x", "show ?thesis"], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (polychain_of x0 (x # xs))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  c = x0 \\<and> d = x0 + x\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d", "by (auto intro!: lex_polychain_of_center)"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex (snd (last (polychain_of x0 (x # xs))))\n   d\n\ngoal (1 subgoal):\n 1. (c, d) \\<in> set (polychain_of (x0 + x) xs) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (c, d) \\<in> set (polychain_of (x0 + x) xs) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d", "assume ?c2"], ["proof (state)\nthis:\n  (c, d) \\<in> set (polychain_of (x0 + x) xs)\n\ngoal (1 subgoal):\n 1. (c, d) \\<in> set (polychain_of (x0 + x) xs) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d", "from Cons.IH[OF this] Cons.prems"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   xs \\<Longrightarrow>\n  Counterclockwise_2D_Arbitrary.lex (snd (last (polychain_of (x0 + x) xs)))\n   d\n  (c, d) \\<in> set (polychain_of x0 (x # xs))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   xs \\<Longrightarrow>\n  Counterclockwise_2D_Arbitrary.lex (snd (last (polychain_of (x0 + x) xs)))\n   d\n  (c, d) \\<in> set (polychain_of x0 (x # xs))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (snd (last (polychain_of x0 (x # xs)))) d", "by auto"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex (snd (last (polychain_of x0 (x # xs))))\n   d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex (snd (last (polychain_of x0 (x # xs))))\n   d\n\ngoal (1 subgoal):\n 1. \\<And>x0 c d.\n       \\<lbrakk>(c, d) \\<in> set (polychain_of x0 []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex\n                          (snd (last (polychain_of x0 []))) d", "qed (auto simp: lex_translate_origin)"], ["", "lemma distinct_fst_polychain_of:\n  assumes \"list_all (\\<lambda>x. x \\<noteq> 0) xs\"\n  assumes \"list_all (\\<lambda>x. lex x 0) xs\"\n  shows \"distinct (map fst (polychain_of x0 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (polychain_of x0 xs))", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x \\<noteq> 0) xs\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\n\ngoal (1 subgoal):\n 1. distinct (map fst (polychain_of x0 xs))", "proof (induction xs arbitrary: x0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x0.\n       \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) [];\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (polychain_of x0 []))\n 2. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map fst (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (polychain_of x0 (a # xs)))", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n\ngoal (2 subgoals):\n 1. \\<And>x0.\n       \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) [];\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (polychain_of x0 []))\n 2. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map fst (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (polychain_of x0 (a # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n\ngoal (1 subgoal):\n 1. distinct (map fst (polychain_of x0 []))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (polychain_of x0 []))\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map fst (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (polychain_of x0 (a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map fst (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (polychain_of x0 (a # xs)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (polychain_of ?x0.0 xs))\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map fst (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (polychain_of x0 (a # xs)))", "hence \"\\<And>d. list_all (\\<lambda>x. lex x 0) (x # take d xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (polychain_of ?x0.0 xs))\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n        (x # take d xs)", "by (auto simp: list_all_iff dest!: in_set_takeD)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (x # take ?d xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map fst (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (polychain_of x0 (a # xs)))", "from sum_list_nlex_eq_zero_iff[OF this] Cons.prems"], ["proof (chain)\npicking this:\n  (sum_list (x # take ?d1 xs) = 0) = list_all ((=) 0) (x # take ?d1 xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  (sum_list (x # take ?d1 xs) = 0) = list_all ((=) 0) (x # take ?d1 xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (polychain_of x0 (x # xs)))", "by (cases \"xs = []\") (auto intro!: Cons.IH elim!: in_set_polychain_of_imp_sum_list)"], ["proof (state)\nthis:\n  distinct (map fst (polychain_of x0 (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_snd_polychain_of:\n  assumes \"list_all (\\<lambda>x. x \\<noteq> 0) xs\"\n  assumes \"list_all (\\<lambda>x. lex x 0) xs\"\n  shows \"distinct (map snd (polychain_of x0 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map snd (polychain_of x0 xs))", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x \\<noteq> 0) xs\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\n\ngoal (1 subgoal):\n 1. distinct (map snd (polychain_of x0 xs))", "proof (induction xs arbitrary: x0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x0.\n       \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) [];\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd (polychain_of x0 []))\n 2. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map snd (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd (polychain_of x0 (a # xs)))", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n\ngoal (2 subgoals):\n 1. \\<And>x0.\n       \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) [];\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         []\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd (polychain_of x0 []))\n 2. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map snd (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd (polychain_of x0 (a # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n\ngoal (1 subgoal):\n 1. distinct (map snd (polychain_of x0 []))", "by simp"], ["proof (state)\nthis:\n  distinct (map snd (polychain_of x0 []))\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map snd (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd (polychain_of x0 (a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map snd (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd (polychain_of x0 (a # xs)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (polychain_of ?x0.0 xs))\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map snd (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd (polychain_of x0 (a # xs)))", "have contra:\n    \"\\<And>d. xs \\<noteq> [] \\<Longrightarrow> list_all (\\<lambda>x. x \\<noteq> 0) xs \\<Longrightarrow> list_all ((=) 0) (take (Suc d) xs) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>xs \\<noteq> []; list_all (\\<lambda>x. x \\<noteq> 0) xs;\n        list_all ((=) 0) (take (Suc d) xs)\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<noteq> []; list_all (\\<lambda>x. x \\<noteq> 0) xs;\n   list_all ((=) 0) (take (Suc ?d) xs)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map snd (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd (polychain_of x0 (a # xs)))", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (polychain_of ?x0.0 xs))\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)", "have \"\\<And>d. list_all (\\<lambda>x. lex x 0) (take (Suc d) xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (polychain_of ?x0.0 xs))\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n        (take (Suc d) xs)", "by (auto simp: list_all_iff dest!: in_set_takeD)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (take (Suc ?d) xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x0.\n       \\<lbrakk>\\<And>x0.\n                   \\<lbrakk>list_all (\\<lambda>x. x \\<noteq> 0) xs;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                     xs\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(map snd (polychain_of x0 xs));\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd (polychain_of x0 (a # xs)))", "from sum_list_nlex_eq_zero_iff[OF this] Cons.prems contra"], ["proof (chain)\npicking this:\n  (sum_list (take (Suc ?d1) xs) = 0) = list_all ((=) 0) (take (Suc ?d1) xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  \\<lbrakk>xs \\<noteq> []; list_all (\\<lambda>x. x \\<noteq> 0) xs;\n   list_all ((=) 0) (take (Suc ?d) xs)\\<rbrakk>\n  \\<Longrightarrow> False", "show ?case"], ["proof (prove)\nusing this:\n  (sum_list (take (Suc ?d1) xs) = 0) = list_all ((=) 0) (take (Suc ?d1) xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  \\<lbrakk>xs \\<noteq> []; list_all (\\<lambda>x. x \\<noteq> 0) xs;\n   list_all ((=) 0) (take (Suc ?d) xs)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. distinct (map snd (polychain_of x0 (x # xs)))", "by (cases \"xs = []\") (auto intro!: Cons.IH elim!: in_set_polychain_of_imp_sum_list dest!: contra)"], ["proof (state)\nthis:\n  distinct (map snd (polychain_of x0 (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Orient all entries\\<close>"], ["", "lift_definition nlex_pdevs::\"point pdevs \\<Rightarrow> point pdevs\"\n  is \"\\<lambda>x n. if lex 0 (x n) then - x n else x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       finite {i. fun i \\<noteq> 0} \\<Longrightarrow>\n       finite\n        {i. (if Counterclockwise_2D_Arbitrary.lex 0 (fun i) then - fun i\n             else fun i) \\<noteq>\n            0}", "by simp"], ["", "lemma pdevs_apply_nlex_pdevs[simp]: \"pdevs_apply (nlex_pdevs x) n =\n  (if lex 0 (pdevs_apply x n) then - pdevs_apply x n else pdevs_apply x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (nlex_pdevs x) n =\n    (if Counterclockwise_2D_Arbitrary.lex 0 (pdevs_apply x n)\n     then - pdevs_apply x n else pdevs_apply x n)", "by transfer simp"], ["", "lemma nlex_pdevs_zero_pdevs[simp]: \"nlex_pdevs zero_pdevs = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nlex_pdevs zero_pdevs = zero_pdevs", "by (auto intro!: pdevs_eqI)"], ["", "lemma pdevs_domain_nlex_pdevs[simp]: \"pdevs_domain (nlex_pdevs x) = pdevs_domain x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain (nlex_pdevs x) = pdevs_domain x", "by (auto simp: pdevs_domain_def)"], ["", "lemma degree_nlex_pdevs[simp]: \"degree (nlex_pdevs x) = degree x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (nlex_pdevs x) = degree x", "by (rule degree_cong) auto"], ["", "lemma\n  pdevs_val_nlex_pdevs:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\" \"uminus ` I = I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\" \"pdevs_val e x = pdevs_val e' (nlex_pdevs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e x = pdevs_val e' (nlex_pdevs x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> I\n  uminus ` I = I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e x = pdevs_val e' (nlex_pdevs x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim, intro exI[where x=\"\\<lambda>n. if lex 0 (pdevs_apply x n) then - e n else e n\"])\n    (force simp: pdevs_val_pdevs_domain intro!: sum.cong)"], ["", "lemma\n  pdevs_val_nlex_pdevs2:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\" \"uminus ` I = I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\" \"pdevs_val e (nlex_pdevs x) = pdevs_val e' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (nlex_pdevs x) = pdevs_val e' x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> I\n  uminus ` I = I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (nlex_pdevs x) = pdevs_val e' x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim, intro exI[where x=\"\\<lambda>n. (if lex 0 (pdevs_apply x n) then - e n else e n)\"])\n    (force simp: pdevs_val_pdevs_domain intro!: sum.cong)"], ["", "lemma\n  pdevs_val_selsort_ccw:\n  assumes \"distinct xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n    \"pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"set xs = set (ccw.selsort 0 xs)\" \"distinct xs\" \"distinct (ccw.selsort 0 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set (ccw.selsort 0 xs) &&&\n    distinct xs &&& distinct (ccw.selsort 0 xs)", "by (simp_all add: assms)"], ["proof (state)\nthis:\n  set xs = set (ccw.selsort 0 xs)\n  distinct xs\n  distinct (ccw.selsort 0 xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this assms(2)"], ["proof (chain)\npicking this:\n  set xs = set (ccw.selsort 0 xs)\n  distinct xs\n  distinct (ccw.selsort 0 xs)\n  e \\<in> UNIV \\<rightarrow> I", "obtain e'\n  where \"e' \\<in> UNIV \\<rightarrow> I\"\n    \"pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\""], ["proof (prove)\nusing this:\n  set xs = set (ccw.selsort 0 xs)\n  distinct xs\n  distinct (ccw.selsort 0 xs)\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule pdevs_val_permute)"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val e (pdevs_of_list xs) =\n  pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val e (pdevs_of_list xs) =\n  pdevs_val e' (pdevs_of_list (ccw.selsort 0 xs))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  pdevs_val_selsort_ccw2:\n  assumes \"distinct xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n    \"pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) = pdevs_val e' (pdevs_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) =\n         pdevs_val e' (pdevs_of_list xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) =\n         pdevs_val e' (pdevs_of_list xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"set (ccw.selsort 0 xs) = set xs\" \"distinct (ccw.selsort 0 xs)\" \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ccw.selsort 0 xs) = set xs &&&\n    distinct (ccw.selsort 0 xs) &&& distinct xs", "by (simp_all add: assms)"], ["proof (state)\nthis:\n  set (ccw.selsort 0 xs) = set xs\n  distinct (ccw.selsort 0 xs)\n  distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) =\n         pdevs_val e' (pdevs_of_list xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this assms(2)"], ["proof (chain)\npicking this:\n  set (ccw.selsort 0 xs) = set xs\n  distinct (ccw.selsort 0 xs)\n  distinct xs\n  e \\<in> UNIV \\<rightarrow> I", "obtain e'\n  where \"e' \\<in> UNIV \\<rightarrow> I\"\n    \"pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) = pdevs_val e' (pdevs_of_list xs)\""], ["proof (prove)\nusing this:\n  set (ccw.selsort 0 xs) = set xs\n  distinct (ccw.selsort 0 xs)\n  distinct xs\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) =\n         pdevs_val e' (pdevs_of_list xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule pdevs_val_permute)"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) =\n  pdevs_val e' (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) =\n         pdevs_val e' (pdevs_of_list xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val e (pdevs_of_list (ccw.selsort 0 xs)) =\n  pdevs_val e' (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_nlex_pdevs: \"lex (pdevs_apply (nlex_pdevs x) i) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex (pdevs_apply (nlex_pdevs x) i) 0", "by (auto simp: lex_def algebra_simps prod_eq_iff)"], ["", "subsection \\<open>Lowest Vertex\\<close>"], ["", "definition lowest_vertex::\"'a::ordered_euclidean_space aform \\<Rightarrow> 'a\" where\n  \"lowest_vertex X = fst X - sum_list (map snd (list_of_pdevs (snd X)))\""], ["", "lemma snd_abs: \"snd (abs x) = abs (snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd \\<bar>x\\<bar> = \\<bar>snd x\\<bar>", "by (metis abs_prod_def snd_conv)"], ["", "lemma lowest_vertex:\n  fixes X Y::\"(real*real) aform\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"\\<And>i. snd (pdevs_apply (snd X) i) \\<ge> 0\"\n  assumes \"\\<And>i. abs (snd (pdevs_apply (snd Y) i)) = abs (snd (pdevs_apply (snd X) i))\"\n  assumes \"degree_aform Y = degree_aform X\"\n  assumes \"fst Y = fst X\"\n  shows \"snd (lowest_vertex X) \\<le> snd (aform_val e Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (lowest_vertex X) \\<le> snd (aform_val e Y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (lowest_vertex X) \\<le> snd (aform_val e Y)", "from abs_pdevs_val_le_tdev[OF assms(1), of \"snd Y\"]"], ["proof (chain)\npicking this:\n  \\<bar>pdevs_val e (snd Y)\\<bar> \\<le> tdev (snd Y)", "have \"snd \\<bar>pdevs_val e (snd Y)\\<bar> \\<le> (\\<Sum>i<degree_aform Y. \\<bar>snd (pdevs_apply (snd X) i)\\<bar>)\""], ["proof (prove)\nusing this:\n  \\<bar>pdevs_val e (snd Y)\\<bar> \\<le> tdev (snd Y)\n\ngoal (1 subgoal):\n 1. snd \\<bar>pdevs_val e (snd Y)\\<bar>\n    \\<le> (\\<Sum>i<degree_aform Y. \\<bar>snd (pdevs_apply (snd X) i)\\<bar>)", "unfolding lowest_vertex_def"], ["proof (prove)\nusing this:\n  \\<bar>pdevs_val e (snd Y)\\<bar> \\<le> tdev (snd Y)\n\ngoal (1 subgoal):\n 1. snd \\<bar>pdevs_val e (snd Y)\\<bar>\n    \\<le> (\\<Sum>i<degree_aform Y. \\<bar>snd (pdevs_apply (snd X) i)\\<bar>)", "by (auto simp: aform_val_def tdev_def less_eq_prod_def snd_sum snd_abs assms)"], ["proof (state)\nthis:\n  snd \\<bar>pdevs_val e (snd Y)\\<bar>\n  \\<le> (\\<Sum>i<degree_aform Y. \\<bar>snd (pdevs_apply (snd X) i)\\<bar>)\n\ngoal (1 subgoal):\n 1. snd (lowest_vertex X) \\<le> snd (aform_val e Y)", "also"], ["proof (state)\nthis:\n  snd \\<bar>pdevs_val e (snd Y)\\<bar>\n  \\<le> (\\<Sum>i<degree_aform Y. \\<bar>snd (pdevs_apply (snd X) i)\\<bar>)\n\ngoal (1 subgoal):\n 1. snd (lowest_vertex X) \\<le> snd (aform_val e Y)", "have \"\\<dots> = (\\<Sum>i<degree_aform X. snd (pdevs_apply (snd X) i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree_aform Y. \\<bar>snd (pdevs_apply (snd X) i)\\<bar>) =\n    (\\<Sum>i<degree_aform X. snd (pdevs_apply (snd X) i))", "by (simp add: assms)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree_aform Y. \\<bar>snd (pdevs_apply (snd X) i)\\<bar>) =\n  (\\<Sum>i<degree_aform X. snd (pdevs_apply (snd X) i))\n\ngoal (1 subgoal):\n 1. snd (lowest_vertex X) \\<le> snd (aform_val e Y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree_aform Y. \\<bar>snd (pdevs_apply (snd X) i)\\<bar>) =\n  (\\<Sum>i<degree_aform X. snd (pdevs_apply (snd X) i))\n\ngoal (1 subgoal):\n 1. snd (lowest_vertex X) \\<le> snd (aform_val e Y)", "have \"\\<dots> \\<le> snd (sum_list (map snd (list_of_pdevs (snd X))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree_aform X. snd (pdevs_apply (snd X) i))\n    \\<le> snd (sum_list (map snd (list_of_pdevs (snd X))))", "by (simp add: sum_list_list_of_pdevs dense_list_of_pdevs_def sum_list_distinct_conv_sum_set\n      snd_sum atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree_aform X. snd (pdevs_apply (snd X) i))\n  \\<le> snd (sum_list (map snd (list_of_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. snd (lowest_vertex X) \\<le> snd (aform_val e Y)", "finally"], ["proof (chain)\npicking this:\n  snd \\<bar>pdevs_val e (snd Y)\\<bar>\n  \\<le> snd (sum_list (map snd (list_of_pdevs (snd X))))", "show ?thesis"], ["proof (prove)\nusing this:\n  snd \\<bar>pdevs_val e (snd Y)\\<bar>\n  \\<le> snd (sum_list (map snd (list_of_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. snd (lowest_vertex X) \\<le> snd (aform_val e Y)", "by (auto simp: aform_val_def lowest_vertex_def minus_le_iff snd_abs abs_real_def assms\n      split: if_split_asm)"], ["proof (state)\nthis:\n  snd (lowest_vertex X) \\<le> snd (aform_val e Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_nonposI:\n  fixes xs::\"'a::ordered_comm_monoid_add list\"\n  shows \"list_all (\\<lambda>x. x \\<le> 0) xs \\<Longrightarrow> sum_list xs \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x \\<le> (0::'a)) xs \\<Longrightarrow>\n    sum_list xs \\<le> (0::'a)", "by (induct xs) (auto simp: intro!: add_nonpos_nonpos)"], ["", "lemma center_le_lowest:\n  \"fst (fst X) \\<le> fst (lowest_vertex (fst X, nlex_pdevs (snd X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst X) \\<le> fst (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by (auto simp: lowest_vertex_def fst_sum_list intro!: sum_list_nonposI)\n    (auto simp: lex_def list_all_iff list_of_pdevs_def dest!: in_set_butlastD split: if_split_asm)"], ["", "lemma lowest_vertex_eq_center_iff:\n  \"lowest_vertex (x0, nlex_pdevs (snd X)) = x0 \\<longleftrightarrow> snd X = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lowest_vertex (x0, nlex_pdevs (snd X)) = x0) = (snd X = zero_pdevs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lowest_vertex (x0, nlex_pdevs (snd X)) = x0 \\<Longrightarrow>\n    snd X = zero_pdevs\n 2. snd X = zero_pdevs \\<Longrightarrow>\n    lowest_vertex (x0, nlex_pdevs (snd X)) = x0", "assume \"lowest_vertex (x0, nlex_pdevs (snd X)) = x0\""], ["proof (state)\nthis:\n  lowest_vertex (x0, nlex_pdevs (snd X)) = x0\n\ngoal (2 subgoals):\n 1. lowest_vertex (x0, nlex_pdevs (snd X)) = x0 \\<Longrightarrow>\n    snd X = zero_pdevs\n 2. snd X = zero_pdevs \\<Longrightarrow>\n    lowest_vertex (x0, nlex_pdevs (snd X)) = x0", "then"], ["proof (chain)\npicking this:\n  lowest_vertex (x0, nlex_pdevs (snd X)) = x0", "have \"sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = 0\""], ["proof (prove)\nusing this:\n  lowest_vertex (x0, nlex_pdevs (snd X)) = x0\n\ngoal (1 subgoal):\n 1. sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = 0", "by (simp add: lowest_vertex_def)"], ["proof (state)\nthis:\n  sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = 0\n\ngoal (2 subgoals):\n 1. lowest_vertex (x0, nlex_pdevs (snd X)) = x0 \\<Longrightarrow>\n    snd X = zero_pdevs\n 2. snd X = zero_pdevs \\<Longrightarrow>\n    lowest_vertex (x0, nlex_pdevs (snd X)) = x0", "moreover"], ["proof (state)\nthis:\n  sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = 0\n\ngoal (2 subgoals):\n 1. lowest_vertex (x0, nlex_pdevs (snd X)) = x0 \\<Longrightarrow>\n    snd X = zero_pdevs\n 2. snd X = zero_pdevs \\<Longrightarrow>\n    lowest_vertex (x0, nlex_pdevs (snd X)) = x0", "have \"list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n    (map snd (list_of_pdevs (nlex_pdevs (snd X))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n     (map snd (list_of_pdevs (nlex_pdevs (snd X))))", "by (auto simp add: list_all_iff list_of_pdevs_def)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (map snd (list_of_pdevs (nlex_pdevs (snd X))))\n\ngoal (2 subgoals):\n 1. lowest_vertex (x0, nlex_pdevs (snd X)) = x0 \\<Longrightarrow>\n    snd X = zero_pdevs\n 2. snd X = zero_pdevs \\<Longrightarrow>\n    lowest_vertex (x0, nlex_pdevs (snd X)) = x0", "ultimately"], ["proof (chain)\npicking this:\n  sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = 0\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (map snd (list_of_pdevs (nlex_pdevs (snd X))))", "have \"\\<forall>x\\<in>set (list_of_pdevs (nlex_pdevs (snd X))). snd x = 0\""], ["proof (prove)\nusing this:\n  sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = 0\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (map snd (list_of_pdevs (nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (list_of_pdevs (nlex_pdevs (snd X))). snd x = 0", "by (simp add: sum_list_nlex_eq_zero_iff list_all_iff)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (list_of_pdevs (nlex_pdevs (snd X))). snd x = 0\n\ngoal (2 subgoals):\n 1. lowest_vertex (x0, nlex_pdevs (snd X)) = x0 \\<Longrightarrow>\n    snd X = zero_pdevs\n 2. snd X = zero_pdevs \\<Longrightarrow>\n    lowest_vertex (x0, nlex_pdevs (snd X)) = x0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (list_of_pdevs (nlex_pdevs (snd X))). snd x = 0", "have \"pdevs_apply (snd X) i = pdevs_apply zero_pdevs i\" for i"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (list_of_pdevs (nlex_pdevs (snd X))). snd x = 0\n\ngoal (1 subgoal):\n 1. pdevs_apply (snd X) i = pdevs_apply zero_pdevs i", "by (simp add: list_of_pdevs_def split: if_splits)"], ["proof (state)\nthis:\n  pdevs_apply (snd X) ?i = pdevs_apply zero_pdevs ?i\n\ngoal (2 subgoals):\n 1. lowest_vertex (x0, nlex_pdevs (snd X)) = x0 \\<Longrightarrow>\n    snd X = zero_pdevs\n 2. snd X = zero_pdevs \\<Longrightarrow>\n    lowest_vertex (x0, nlex_pdevs (snd X)) = x0", "then"], ["proof (chain)\npicking this:\n  pdevs_apply (snd X) ?i = pdevs_apply zero_pdevs ?i", "show \"snd X = zero_pdevs\""], ["proof (prove)\nusing this:\n  pdevs_apply (snd X) ?i = pdevs_apply zero_pdevs ?i\n\ngoal (1 subgoal):\n 1. snd X = zero_pdevs", "by (rule pdevs_eqI)"], ["proof (state)\nthis:\n  snd X = zero_pdevs\n\ngoal (1 subgoal):\n 1. snd X = zero_pdevs \\<Longrightarrow>\n    lowest_vertex (x0, nlex_pdevs (snd X)) = x0", "qed (simp add: lowest_vertex_def)"], ["", "subsection \\<open>Collinear Generators\\<close>"], ["", "lemma scaleR_le_self_cancel:\n  fixes c::\"'a::ordered_real_vector\"\n  shows \"a *\\<^sub>R c \\<le> c \\<longleftrightarrow> (1 < a \\<and> c \\<le> 0 \\<or> a < 1 \\<and> 0 \\<le> c \\<or> a = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a *\\<^sub>R c \\<le> c) =\n    (1 < a \\<and> c \\<le> (0::'a) \\<or>\n     a < 1 \\<and> (0::'a) \\<le> c \\<or> a = 1)", "using scaleR_le_0_iff[of \"a - 1\" c]"], ["proof (prove)\nusing this:\n  ((a - 1) *\\<^sub>R c \\<le> (0::'a)) =\n  (0 < a - 1 \\<and> c \\<le> (0::'a) \\<or>\n   a - 1 < 0 \\<and> (0::'a) \\<le> c \\<or> a - 1 = 0)\n\ngoal (1 subgoal):\n 1. (a *\\<^sub>R c \\<le> c) =\n    (1 < a \\<and> c \\<le> (0::'a) \\<or>\n     a < 1 \\<and> (0::'a) \\<le> c \\<or> a = 1)", "by (simp add: algebra_simps)"], ["", "lemma pdevs_val_coll:\n  assumes coll: \"list_all (coll 0 x) xs\"\n  assumes nlex: \"list_all (\\<lambda>x. lex x 0) xs\"\n  assumes \"x \\<noteq> 0\"\n  assumes \"f \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  obtains e where \"e \\<in> {-1 .. 1}\" \"pdevs_val f (pdevs_of_list xs) = e *\\<^sub>R (sum_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> {- 1..1};\n         pdevs_val f (pdevs_of_list xs) = e *\\<^sub>R sum_list xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sum_list xs = 0\""], ["proof (state)\nthis:\n  sum_list xs = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"pdevs_of_list xs = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_list xs = zero_pdevs", "by (auto intro!: pdevs_eqI sum_list_nlex_eq_zeroI[OF nlex \\<open>sum_list xs = 0\\<close>]\n      simp: pdevs_apply_pdevs_of_list list_all_iff dest!: nth_mem)"], ["proof (state)\nthis:\n  pdevs_of_list xs = zero_pdevs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"0 \\<in> {-1 .. 1::real}\" \"pdevs_val f (pdevs_of_list xs) = 0 *\\<^sub>R sum_list xs\""], ["proof (prove)\nusing this:\n  pdevs_of_list xs = zero_pdevs\n\ngoal (1 subgoal):\n 1. 0 \\<in> {- 1..1} &&&\n    pdevs_val f (pdevs_of_list xs) = 0 *\\<^sub>R sum_list xs", "by simp_all"], ["proof (state)\nthis:\n  0 \\<in> {- 1..1}\n  pdevs_val f (pdevs_of_list xs) = 0 *\\<^sub>R sum_list xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<in> {- 1..1}\n  pdevs_val f (pdevs_of_list xs) = 0 *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sum_list xs \\<noteq> 0\""], ["proof (state)\nthis:\n  sum_list xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"sum_list (map abs xs) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sum_list (map abs xs)", "by (auto intro!: sum_list_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence [simp]: \"\\<not>sum_list (map abs xs) \\<le> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs xs) \\<le> 0", "by (metis \\<open>sum_list xs \\<noteq> 0\\<close> abs_le_zero_iff antisym_conv sum_list_abs)"], ["proof (state)\nthis:\n  \\<not> sum_list (map abs xs) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have collist: \"list_all (coll 0 (sum_list xs)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (coll 0 (sum_list xs)) xs", "proof (rule list_allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "hence \"coll 0 x y\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. coll 0 x y", "using coll"], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  list_all (coll 0 x) xs\n\ngoal (1 subgoal):\n 1. coll 0 x y", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  coll 0 x y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "also"], ["proof (state)\nthis:\n  coll 0 x y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "have \"coll 0 x (sum_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 x (sum_list xs)", "using coll"], ["proof (prove)\nusing this:\n  list_all (coll 0 x) xs\n\ngoal (1 subgoal):\n 1. coll 0 x (sum_list xs)", "by (auto simp: list_all_iff intro!: coll_sum_list)"], ["proof (state)\nthis:\n  coll 0 x (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "finally (coll_trans)"], ["proof (chain)\npicking this:\n  x \\<noteq> 0 \\<Longrightarrow> coll 0 y (sum_list xs)", "show \"coll 0 (sum_list xs) y\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0 \\<Longrightarrow> coll 0 y (sum_list xs)\n\ngoal (1 subgoal):\n 1. coll 0 (sum_list xs) y", "by (simp add: coll_commute \\<open>x \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  coll 0 (sum_list xs) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all (coll 0 (sum_list xs)) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "{"], ["proof (state)\nthis:\n  list_all (coll 0 (sum_list xs)) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"i < length xs\""], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<exists>r. xs ! i = r *\\<^sub>R (sum_list xs)\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>r. xs ! i = r *\\<^sub>R sum_list xs", "by (metis (mono_tags) coll_scale nth_mem \\<open>sum_list xs \\<noteq> 0\\<close> list_all_iff collist)"], ["proof (state)\nthis:\n  \\<exists>r. xs ! i = r *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "}"], ["proof (state)\nthis:\n  ?i2 < length xs \\<Longrightarrow>\n  \\<exists>r. xs ! ?i2 = r *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ?i2 < length xs \\<Longrightarrow>\n  \\<exists>r. xs ! ?i2 = r *\\<^sub>R sum_list xs", "obtain r where r: \"\\<And>i. i < length xs \\<Longrightarrow> (xs ! i) = r i *\\<^sub>R (sum_list xs)\""], ["proof (prove)\nusing this:\n  ?i2 < length xs \\<Longrightarrow>\n  \\<exists>r. xs ! ?i2 = r *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            xs ! i = r i *\\<^sub>R sum_list xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow> xs ! ?i = r ?i *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "let ?coll = \"pdevs_of_list xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"pdevs_val f (pdevs_of_list xs) =\n      (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list xs) =\n    (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)", "unfolding pdevs_val_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_list xs).\n        f i *\\<^sub>R pdevs_apply (pdevs_of_list xs) i) =\n    (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)", "by (simp add: pdevs_apply_pdevs_of_list less_degree_pdevs_of_list_imp_less_length)"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<dots> = (\\<Sum>i<degree ?coll. (f i * r i) *\\<^sub>R (sum_list xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i) =\n    (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs)", "by (simp add: r less_degree_pdevs_of_list_imp_less_length)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i) =\n  (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i) =\n  (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<dots> = (\\<Sum>i<degree ?coll. f i * r i) *\\<^sub>R (sum_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs) =\n    (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs", "by (simp add: algebra_simps scaleR_sum_left)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs", "have eq: \"pdevs_val f ?coll = (\\<Sum>i<degree ?coll. f i * r i) *\\<^sub>R (sum_list xs)\"\n    (is \"_ = ?e *\\<^sub>R _\")"], ["proof (prove)\nusing this:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list xs) =\n    (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs", "."], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"abs (pdevs_val f ?coll) \\<le> tdev ?coll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val f (pdevs_of_list xs)\\<bar> \\<le> tdev (pdevs_of_list xs)", "using assms(4)"], ["proof (prove)\nusing this:\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val f (pdevs_of_list xs)\\<bar> \\<le> tdev (pdevs_of_list xs)", "by (intro abs_pdevs_val_le_tdev) (auto simp: Pi_iff less_imp_le)"], ["proof (state)\nthis:\n  \\<bar>pdevs_val f (pdevs_of_list xs)\\<bar> \\<le> tdev (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  \\<bar>pdevs_val f (pdevs_of_list xs)\\<bar> \\<le> tdev (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<dots> = sum_list (map abs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev (pdevs_of_list xs) = sum_list (map abs xs)", "using assms"], ["proof (prove)\nusing this:\n  list_all (coll 0 x) xs\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\n  x \\<noteq> 0\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_list xs) = sum_list (map abs xs)", "by simp"], ["proof (state)\nthis:\n  tdev (pdevs_of_list xs) = sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  tdev (pdevs_of_list xs) = sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "note eq"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  \\<bar>(\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R\n        sum_list xs\\<bar>\n  \\<le> sum_list (map abs xs)", "have less: \"\\<bar>?e\\<bar> *\\<^sub>R abs (sum_list xs) \\<le> sum_list (map abs xs)\""], ["proof (prove)\nusing this:\n  \\<bar>(\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R\n        sum_list xs\\<bar>\n  \\<le> sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n    \\<bar>sum_list xs\\<bar>\n    \\<le> sum_list (map abs xs)", "by (simp add: abs_scaleR)"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n  \\<bar>sum_list xs\\<bar>\n  \\<le> sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n  \\<bar>sum_list xs\\<bar>\n  \\<le> sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<bar>sum_list xs\\<bar> = sum_list (map abs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sum_list xs\\<bar> = sum_list (map abs xs)", "using coll \\<open>x \\<noteq> 0\\<close> nlex"], ["proof (prove)\nusing this:\n  list_all (coll 0 x) xs\n  x \\<noteq> 0\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\n\ngoal (1 subgoal):\n 1. \\<bar>sum_list xs\\<bar> = sum_list (map abs xs)", "by (rule abs_sum_list_coll)"], ["proof (state)\nthis:\n  \\<bar>sum_list xs\\<bar> = sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n  sum_list (map abs xs)\n  \\<le> sum_list (map abs xs)", "have \"?e \\<in> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n  sum_list (map abs xs)\n  \\<le> sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) \\<in> {- 1..1}", "by (auto simp add: less_le scaleR_le_self_cancel)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1..1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. thesis", "using eq"], ["proof (prove)\nusing this:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) \\<in> {- 1..1}\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scaleR_eq_self_cancel:\n  fixes x::\"'a::real_vector\"\n  shows \"a *\\<^sub>R x = x \\<longleftrightarrow> a = 1 \\<or> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a *\\<^sub>R x = x) = (a = 1 \\<or> x = (0::'a))", "using scaleR_cancel_right[of a x 1]"], ["proof (prove)\nusing this:\n  (a *\\<^sub>R x = 1 *\\<^sub>R x) = (a = 1 \\<or> x = (0::'a))\n\ngoal (1 subgoal):\n 1. (a *\\<^sub>R x = x) = (a = 1 \\<or> x = (0::'a))", "by simp"], ["", "lemma abs_pdevs_val_less_tdev:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\" \"degree x > 0\"\n  shows \"\\<bar>pdevs_val e x\\<bar> < tdev x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e x\\<bar> < tdev x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e x\\<bar> < tdev x", "have bnds: \"\\<And>i. \\<bar>e i\\<bar> < 1\" \"\\<And>i. \\<bar>e i\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. \\<bar>e i\\<bar> < 1) &&& (\\<And>i. \\<bar>e i\\<bar> \\<le> 1)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  0 < degree x\n\ngoal (1 subgoal):\n 1. (\\<And>i. \\<bar>e i\\<bar> < 1) &&& (\\<And>i. \\<bar>e i\\<bar> \\<le> 1)", "by (auto simp: Pi_iff abs_less_iff order.strict_implies_order)"], ["proof (state)\nthis:\n  \\<bar>e ?i\\<bar> < 1\n  \\<bar>e ?i\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e x\\<bar> < tdev x", "moreover"], ["proof (state)\nthis:\n  \\<bar>e ?i\\<bar> < 1\n  \\<bar>e ?i\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e x\\<bar> < tdev x", "let ?w = \"degree x - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e x\\<bar> < tdev x", "have witness: \"\\<bar>e ?w\\<bar> *\\<^sub>R \\<bar>pdevs_apply x ?w\\<bar> < \\<bar>pdevs_apply x ?w\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>e (degree x - 1)\\<bar> *\\<^sub>R\n    \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n    < \\<bar>pdevs_apply x (degree x - 1)\\<bar>", "using degree_least_nonzero[of x] assms bnds"], ["proof (prove)\nusing this:\n  degree x \\<noteq> 0 \\<Longrightarrow>\n  pdevs_apply x (degree x - 1) \\<noteq> (0::'a)\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  0 < degree x\n  \\<bar>e ?i\\<bar> < 1\n  \\<bar>e ?i\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>e (degree x - 1)\\<bar> *\\<^sub>R\n    \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n    < \\<bar>pdevs_apply x (degree x - 1)\\<bar>", "by (intro neq_le_trans) (auto simp: scaleR_eq_self_cancel Pi_iff\n      intro!: scaleR_left_le_one_le neq_le_trans\n      intro: abs_leI less_imp_le dest!: order.strict_implies_not_eq)"], ["proof (state)\nthis:\n  \\<bar>e (degree x - 1)\\<bar> *\\<^sub>R\n  \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n  < \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e x\\<bar> < tdev x", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>e ?i\\<bar> < 1\n  \\<bar>e ?i\\<bar> \\<le> 1\n  \\<bar>e (degree x - 1)\\<bar> *\\<^sub>R\n  \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n  < \\<bar>pdevs_apply x (degree x - 1)\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>e ?i\\<bar> < 1\n  \\<bar>e ?i\\<bar> \\<le> 1\n  \\<bar>e (degree x - 1)\\<bar> *\\<^sub>R\n  \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n  < \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e x\\<bar> < tdev x", "using assms witness bnds"], ["proof (prove)\nusing this:\n  \\<bar>e ?i\\<bar> < 1\n  \\<bar>e ?i\\<bar> \\<le> 1\n  \\<bar>e (degree x - 1)\\<bar> *\\<^sub>R\n  \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n  < \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  0 < degree x\n  \\<bar>e (degree x - 1)\\<bar> *\\<^sub>R\n  \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n  < \\<bar>pdevs_apply x (degree x - 1)\\<bar>\n  \\<bar>e ?i\\<bar> < 1\n  \\<bar>e ?i\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e x\\<bar> < tdev x", "by (auto simp: pdevs_val_sum tdev_def abs_scaleR\n      intro!: le_less_trans[OF sum_abs] sum_strict_mono_ex1 scaleR_left_le_one_le)"], ["proof (state)\nthis:\n  \\<bar>pdevs_val e x\\<bar> < tdev x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_val_coll_strict:\n  assumes coll: \"list_all (coll 0 x) xs\"\n  assumes nlex: \"list_all (\\<lambda>x. lex x 0) xs\"\n  assumes \"x \\<noteq> 0\"\n  assumes \"f \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  obtains e where \"e \\<in> {-1 <..< 1}\" \"pdevs_val f (pdevs_of_list xs) = e *\\<^sub>R (sum_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> {- 1<..<1};\n         pdevs_val f (pdevs_of_list xs) = e *\\<^sub>R sum_list xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sum_list xs = 0\""], ["proof (state)\nthis:\n  sum_list xs = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"pdevs_of_list xs = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_list xs = zero_pdevs", "by (auto intro!: pdevs_eqI sum_list_nlex_eq_zeroI[OF nlex \\<open>sum_list xs = 0\\<close>]\n      simp: pdevs_apply_pdevs_of_list list_all_iff dest!: nth_mem)"], ["proof (state)\nthis:\n  pdevs_of_list xs = zero_pdevs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"0 \\<in> {-1 <..< 1::real}\" \"pdevs_val f (pdevs_of_list xs) = 0 *\\<^sub>R sum_list xs\""], ["proof (prove)\nusing this:\n  pdevs_of_list xs = zero_pdevs\n\ngoal (1 subgoal):\n 1. 0 \\<in> {- 1<..<1} &&&\n    pdevs_val f (pdevs_of_list xs) = 0 *\\<^sub>R sum_list xs", "by simp_all"], ["proof (state)\nthis:\n  0 \\<in> {- 1<..<1}\n  pdevs_val f (pdevs_of_list xs) = 0 *\\<^sub>R sum_list xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<in> {- 1<..<1}\n  pdevs_val f (pdevs_of_list xs) = 0 *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sum_list xs \\<noteq> 0\""], ["proof (state)\nthis:\n  sum_list xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"sum_list (map abs xs) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sum_list (map abs xs)", "by (auto intro!: sum_list_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence [simp]: \"\\<not>sum_list (map abs xs) \\<le> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs xs) \\<le> 0", "by (metis \\<open>sum_list xs \\<noteq> 0\\<close> abs_le_zero_iff antisym_conv sum_list_abs)"], ["proof (state)\nthis:\n  \\<not> sum_list (map abs xs) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<exists>x \\<in> set xs. x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set xs. x \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>set xs. x \\<noteq> 0) \\<Longrightarrow> False", "assume \"\\<not> (\\<exists>x\\<in>set xs. x \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<in>set xs. x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>set xs. x \\<noteq> 0) \\<Longrightarrow> False", "hence \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x = 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x\\<in>set xs. x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x = 0", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> set xs \\<Longrightarrow> ?x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>set xs. x \\<noteq> 0) \\<Longrightarrow> False", "hence \"sum_list xs = 0\""], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x = 0\n\ngoal (1 subgoal):\n 1. sum_list xs = 0", "by (auto simp: sum_list_eq_0_iff_nonpos list_all_iff less_eq_prod_def prod_eq_iff fst_sum_list\n        snd_sum_list)"], ["proof (state)\nthis:\n  sum_list xs = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>set xs. x \\<noteq> 0) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  sum_list xs = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>sum_list xs \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  sum_list xs = 0\n  sum_list xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>set xs. x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>set xs. x \\<noteq> 0", "obtain i where i: \"i < length xs\" \"xs ! i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>set xs. x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; xs ! i \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length xs\n  xs ! i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"i < degree (pdevs_of_list xs)\""], ["proof (prove)\nusing this:\n  i < length xs\n  xs ! i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i < degree (pdevs_of_list xs)", "by (auto intro!: degree_gt simp: pdevs_apply_pdevs_of_list)"], ["proof (state)\nthis:\n  i < degree (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence deg_pos: \"0 < degree (pdevs_of_list xs)\""], ["proof (prove)\nusing this:\n  i < degree (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. 0 < degree (pdevs_of_list xs)", "by simp"], ["proof (state)\nthis:\n  0 < degree (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have collist: \"list_all (coll 0 (sum_list xs)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (coll 0 (sum_list xs)) xs", "proof (rule list_allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "hence \"coll 0 x y\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. coll 0 x y", "using coll"], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  list_all (coll 0 x) xs\n\ngoal (1 subgoal):\n 1. coll 0 x y", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  coll 0 x y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "also"], ["proof (state)\nthis:\n  coll 0 x y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "have \"coll 0 x (sum_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 x (sum_list xs)", "using coll"], ["proof (prove)\nusing this:\n  list_all (coll 0 x) xs\n\ngoal (1 subgoal):\n 1. coll 0 x (sum_list xs)", "by (auto simp: list_all_iff intro!: coll_sum_list)"], ["proof (state)\nthis:\n  coll 0 x (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 (sum_list xs) x", "finally (coll_trans)"], ["proof (chain)\npicking this:\n  x \\<noteq> 0 \\<Longrightarrow> coll 0 y (sum_list xs)", "show \"coll 0 (sum_list xs) y\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0 \\<Longrightarrow> coll 0 y (sum_list xs)\n\ngoal (1 subgoal):\n 1. coll 0 (sum_list xs) y", "by (simp add: coll_commute \\<open>x \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  coll 0 (sum_list xs) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all (coll 0 (sum_list xs)) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "{"], ["proof (state)\nthis:\n  list_all (coll 0 (sum_list xs)) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"i < length xs\""], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<exists>r. xs ! i = r *\\<^sub>R (sum_list xs)\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>r. xs ! i = r *\\<^sub>R sum_list xs", "by (metis (mono_tags, lifting) \\<open>sum_list xs \\<noteq> 0\\<close> coll_scale collist list_all_iff nth_mem)"], ["proof (state)\nthis:\n  \\<exists>r. xs ! i = r *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "}"], ["proof (state)\nthis:\n  ?ia2 < length xs \\<Longrightarrow>\n  \\<exists>r. xs ! ?ia2 = r *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ?ia2 < length xs \\<Longrightarrow>\n  \\<exists>r. xs ! ?ia2 = r *\\<^sub>R sum_list xs", "obtain r where r: \"\\<And>i. i < length xs \\<Longrightarrow> (xs ! i) = r i *\\<^sub>R (sum_list xs)\""], ["proof (prove)\nusing this:\n  ?ia2 < length xs \\<Longrightarrow>\n  \\<exists>r. xs ! ?ia2 = r *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            xs ! i = r i *\\<^sub>R sum_list xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow> xs ! ?i = r ?i *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "let ?coll = \"pdevs_of_list xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"pdevs_val f (pdevs_of_list xs) =\n      (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list xs) =\n    (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)", "unfolding pdevs_val_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_list xs).\n        f i *\\<^sub>R pdevs_apply (pdevs_of_list xs) i) =\n    (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)", "by (simp add: less_degree_pdevs_of_list_imp_less_length pdevs_apply_pdevs_of_list)"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<dots> = (\\<Sum>i<degree ?coll. (f i * r i) *\\<^sub>R (sum_list xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i) =\n    (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs)", "by (simp add: r less_degree_pdevs_of_list_imp_less_length)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i) =\n  (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i *\\<^sub>R xs ! i) =\n  (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<dots> = (\\<Sum>i<degree ?coll. f i * r i) *\\<^sub>R (sum_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs) =\n    (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs", "by (simp add: algebra_simps scaleR_sum_left)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_list xs). (f i * r i) *\\<^sub>R sum_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs", "have eq: \"pdevs_val f ?coll = (\\<Sum>i<degree ?coll. f i * r i) *\\<^sub>R (sum_list xs)\"\n    (is \"_ = ?e *\\<^sub>R _\")"], ["proof (prove)\nusing this:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list xs) =\n    (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs", "."], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"abs (pdevs_val f ?coll) < tdev ?coll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val f (pdevs_of_list xs)\\<bar> < tdev (pdevs_of_list xs)", "using assms(4)"], ["proof (prove)\nusing this:\n  f \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val f (pdevs_of_list xs)\\<bar> < tdev (pdevs_of_list xs)", "by (intro abs_pdevs_val_less_tdev) (auto simp: Pi_iff less_imp_le deg_pos)"], ["proof (state)\nthis:\n  \\<bar>pdevs_val f (pdevs_of_list xs)\\<bar> < tdev (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  \\<bar>pdevs_val f (pdevs_of_list xs)\\<bar> < tdev (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<dots> = sum_list (map abs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev (pdevs_of_list xs) = sum_list (map abs xs)", "using assms"], ["proof (prove)\nusing this:\n  list_all (coll 0 x) xs\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\n  x \\<noteq> 0\n  f \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_list xs) = sum_list (map abs xs)", "by simp"], ["proof (state)\nthis:\n  tdev (pdevs_of_list xs) = sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  tdev (pdevs_of_list xs) = sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "note eq"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  \\<bar>(\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R\n        sum_list xs\\<bar>\n  < sum_list (map abs xs)", "have less: \"\\<bar>?e\\<bar> *\\<^sub>R abs (sum_list xs) < sum_list (map abs xs)\""], ["proof (prove)\nusing this:\n  \\<bar>(\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R\n        sum_list xs\\<bar>\n  < sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n    \\<bar>sum_list xs\\<bar>\n    < sum_list (map abs xs)", "by (simp add: abs_scaleR)"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n  \\<bar>sum_list xs\\<bar>\n  < sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n  \\<bar>sum_list xs\\<bar>\n  < sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<bar>sum_list xs\\<bar> = sum_list (map abs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sum_list xs\\<bar> = sum_list (map abs xs)", "using coll \\<open>x \\<noteq> 0\\<close> nlex"], ["proof (prove)\nusing this:\n  list_all (coll 0 x) xs\n  x \\<noteq> 0\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\n\ngoal (1 subgoal):\n 1. \\<bar>sum_list xs\\<bar> = sum_list (map abs xs)", "by (rule abs_sum_list_coll)"], ["proof (state)\nthis:\n  \\<bar>sum_list xs\\<bar> = sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n  sum_list (map abs xs)\n  < sum_list (map abs xs)", "have \"?e \\<in> {-1 <..< 1}\""], ["proof (prove)\nusing this:\n  \\<bar>\\<Sum>i<degree (pdevs_of_list xs). f i * r i\\<bar> *\\<^sub>R\n  sum_list (map abs xs)\n  < sum_list (map abs xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) \\<in> {- 1<..<1}", "by (auto simp add: less_le scaleR_le_self_cancel)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) \\<in> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>e \\<in> {- 1<..<1};\n                 pdevs_val f (pdevs_of_list xs) =\n                 e *\\<^sub>R sum_list xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     sum_list xs \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) \\<in> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. thesis", "using eq"], ["proof (prove)\nusing this:\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) \\<in> {- 1<..<1}\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<degree (pdevs_of_list xs). f i * r i) *\\<^sub>R sum_list xs\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Independent Generators\\<close>"], ["", "fun independent_pdevs::\"point list \\<Rightarrow> point list\"\n  where\n  \"independent_pdevs [] = []\"\n| \"independent_pdevs (x#xs) =\n    (let\n      (cs, is) = List.partition (coll 0 x) xs;\n      s = x + sum_list cs\n    in (if s = 0 then [] else [s]) @ independent_pdevs is)\""], ["", "lemma in_set_independent_pdevsE:\n  assumes \"y \\<in> set (independent_pdevs xs)\"\n  obtains x where \"x\\<in>set xs\" \"coll 0 x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; coll 0 x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> set xs \\<and> coll 0 x y", "show \"\\<exists>x. x \\<in> set xs \\<and> coll 0 x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> set xs \\<and> coll 0 x y", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> set (independent_pdevs xs)\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> set xs \\<and> coll 0 x y", "proof (induct xs rule: independent_pdevs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> set (independent_pdevs []) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set [] \\<and> coll 0 x y\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa xb ya xaa.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, ya) = xa;\n                    xaa = x + sum_list xb;\n                    y \\<in> set (independent_pdevs ya)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x.\n  x \\<in> set ya \\<and> coll 0 x y;\n        y \\<in> set (independent_pdevs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> set (x # xs) \\<and> coll 0 xa y", "case 1"], ["proof (state)\nthis:\n  y \\<in> set (independent_pdevs [])\n\ngoal (2 subgoals):\n 1. y \\<in> set (independent_pdevs []) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set [] \\<and> coll 0 x y\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa xb ya xaa.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, ya) = xa;\n                    xaa = x + sum_list xb;\n                    y \\<in> set (independent_pdevs ya)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x.\n  x \\<in> set ya \\<and> coll 0 x y;\n        y \\<in> set (independent_pdevs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> set (x # xs) \\<and> coll 0 xa y", "thus ?case"], ["proof (prove)\nusing this:\n  y \\<in> set (independent_pdevs [])\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> set [] \\<and> coll 0 x y", "by simp"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> set [] \\<and> coll 0 x y\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa xb ya xaa.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, ya) = xa;\n                    xaa = x + sum_list xb;\n                    y \\<in> set (independent_pdevs ya)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x.\n  x \\<in> set ya \\<and> coll 0 x y;\n        y \\<in> set (independent_pdevs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> set (x # xs) \\<and> coll 0 xa y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa xb ya xaa.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, ya) = xa;\n                    xaa = x + sum_list xb;\n                    y \\<in> set (independent_pdevs ya)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x.\n  x \\<in> set ya \\<and> coll 0 x y;\n        y \\<in> set (independent_pdevs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> set (x # xs) \\<and> coll 0 xa y", "case (2 z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = partition (coll 0 z) zs; (?xb, ?y) = ?xa;\n   ?xaa = z + sum_list ?xb; y \\<in> set (independent_pdevs ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> set ?y \\<and> coll 0 x y\n  y \\<in> set (independent_pdevs (z # zs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa xb ya xaa.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, ya) = xa;\n                    xaa = x + sum_list xb;\n                    y \\<in> set (independent_pdevs ya)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x.\n  x \\<in> set ya \\<and> coll 0 x y;\n        y \\<in> set (independent_pdevs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> set (x # xs) \\<and> coll 0 xa y", "let ?c1 = \"y = z + sum_list (filter (coll 0 z) zs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa xb ya xaa.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, ya) = xa;\n                    xaa = x + sum_list xb;\n                    y \\<in> set (independent_pdevs ya)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x.\n  x \\<in> set ya \\<and> coll 0 x y;\n        y \\<in> set (independent_pdevs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> set (x # xs) \\<and> coll 0 xa y", "let ?c2 = \"y \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa xb ya xaa.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, ya) = xa;\n                    xaa = x + sum_list xb;\n                    y \\<in> set (independent_pdevs ya)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x.\n  x \\<in> set ya \\<and> coll 0 x y;\n        y \\<in> set (independent_pdevs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> set (x # xs) \\<and> coll 0 xa y", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xa = partition (coll 0 z) zs; (?xb, ?y) = ?xa;\n   ?xaa = z + sum_list ?xb; y \\<in> set (independent_pdevs ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> set ?y \\<and> coll 0 x y\n  y \\<in> set (independent_pdevs (z # zs))", "have \"?c1 \\<or> ?c2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa = partition (coll 0 z) zs; (?xb, ?y) = ?xa;\n   ?xaa = z + sum_list ?xb; y \\<in> set (independent_pdevs ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> set ?y \\<and> coll 0 x y\n  y \\<in> set (independent_pdevs (z # zs))\n\ngoal (1 subgoal):\n 1. y = z + sum_list (filter (coll 0 z) zs) \\<or>\n    y \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))", "by (auto simp: Let_def split: if_split_asm)"], ["proof (state)\nthis:\n  y = z + sum_list (filter (coll 0 z) zs) \\<or>\n  y \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa xb ya xaa.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, ya) = xa;\n                    xaa = x + sum_list xb;\n                    y \\<in> set (independent_pdevs ya)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x.\n  x \\<in> set ya \\<and> coll 0 x y;\n        y \\<in> set (independent_pdevs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> set (x # xs) \\<and> coll 0 xa y", "thus ?case"], ["proof (prove)\nusing this:\n  y = z + sum_list (filter (coll 0 z) zs) \\<or>\n  y \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. y = z + sum_list (filter (coll 0 z) zs) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y\n 2. y \\<in> set (independent_pdevs\n                  (filter (Not \\<circ> coll 0 z) zs)) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y", "assume ?c2"], ["proof (state)\nthis:\n  y \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (2 subgoals):\n 1. y = z + sum_list (filter (coll 0 z) zs) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y\n 2. y \\<in> set (independent_pdevs\n                  (filter (Not \\<circ> coll 0 z) zs)) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y", "hence \"y \\<in> set (independent_pdevs (snd (partition (coll 0 z) zs)))\""], ["proof (prove)\nusing this:\n  y \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. y \\<in> set (independent_pdevs (snd (partition (coll 0 z) zs)))", "by simp"], ["proof (state)\nthis:\n  y \\<in> set (independent_pdevs (snd (partition (coll 0 z) zs)))\n\ngoal (2 subgoals):\n 1. y = z + sum_list (filter (coll 0 z) zs) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y\n 2. y \\<in> set (independent_pdevs\n                  (filter (Not \\<circ> coll 0 z) zs)) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y", "from 2(1)[OF refl prod.collapse refl this]"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> set (snd (partition (coll 0 z) zs)) \\<and> coll 0 x y", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> set (snd (partition (coll 0 z) zs)) \\<and> coll 0 x y\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y\n\ngoal (1 subgoal):\n 1. y = z + sum_list (filter (coll 0 z) zs) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y = z + sum_list (filter (coll 0 z) zs) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y", "assume y: ?c1"], ["proof (state)\nthis:\n  y = z + sum_list (filter (coll 0 z) zs)\n\ngoal (1 subgoal):\n 1. y = z + sum_list (filter (coll 0 z) zs) \\<Longrightarrow>\n    \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y", "unfolding y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> set (z # zs) \\<and>\n       coll 0 x (z + sum_list (filter (coll 0 z) zs))", "by (rule exI[where x=\"z\"]) (auto intro!: coll_add coll_sum_list )"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> set (z # zs) \\<and> coll 0 x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> set xs \\<and> coll 0 x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_independent_pdevs_nonzero: \"x \\<in> set (independent_pdevs xs) \\<Longrightarrow> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (independent_pdevs xs) \\<Longrightarrow> x \\<noteq> 0", "proof (induct xs rule: independent_pdevs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set (independent_pdevs []) \\<Longrightarrow> x \\<noteq> 0\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb y xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, y) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs y)\\<rbrakk>\n                   \\<Longrightarrow> x \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs))\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> 0", "case (2 y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = partition (coll 0 y) ys; (?xb, ?y) = ?xa;\n   ?xaa = y + sum_list ?xb; x \\<in> set (independent_pdevs ?y)\\<rbrakk>\n  \\<Longrightarrow> x \\<noteq> 0\n  x \\<in> set (independent_pdevs (y # ys))\n\ngoal (2 subgoals):\n 1. x \\<in> set (independent_pdevs []) \\<Longrightarrow> x \\<noteq> 0\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb y xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, y) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs y)\\<rbrakk>\n                   \\<Longrightarrow> x \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs))\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> 0", "from 2(1)[OF refl prod.collapse refl] 2(2)"], ["proof (chain)\npicking this:\n  x \\<in> set (independent_pdevs\n                (snd (partition (coll 0 y) ys))) \\<Longrightarrow>\n  x \\<noteq> 0\n  x \\<in> set (independent_pdevs (y # ys))", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set (independent_pdevs\n                (snd (partition (coll 0 y) ys))) \\<Longrightarrow>\n  x \\<noteq> 0\n  x \\<in> set (independent_pdevs (y # ys))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by (auto simp: Let_def split: if_split_asm)"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> set (independent_pdevs []) \\<Longrightarrow> x \\<noteq> 0", "qed simp"], ["", "lemma independent_pdevs_pairwise_non_coll:\n  assumes \"x \\<in> set (independent_pdevs xs)\"\n  assumes \"y \\<in> set (independent_pdevs xs)\"\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0\"\n  assumes \"x \\<noteq> y\"\n  shows \"\\<not> coll 0 x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 0 x y \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set (independent_pdevs xs)\n  y \\<in> set (independent_pdevs xs)\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<noteq> 0\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. det3 0 x y \\<noteq> 0", "proof (induct xs rule: independent_pdevs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set (independent_pdevs []);\n     y \\<in> set (independent_pdevs []);\n     \\<And>x. x \\<in> set [] \\<Longrightarrow> x \\<noteq> 0;\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> det3 0 x y \\<noteq> 0\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "case 1"], ["proof (state)\nthis:\n  x \\<in> set (independent_pdevs [])\n  y \\<in> set (independent_pdevs [])\n  ?x \\<in> set [] \\<Longrightarrow> ?x \\<noteq> 0\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set (independent_pdevs []);\n     y \\<in> set (independent_pdevs []);\n     \\<And>x. x \\<in> set [] \\<Longrightarrow> x \\<noteq> 0;\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> det3 0 x y \\<noteq> 0\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> set (independent_pdevs [])\n  y \\<in> set (independent_pdevs [])\n  ?x \\<in> set [] \\<Longrightarrow> ?x \\<noteq> 0\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. det3 0 x y \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  det3 0 x y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "case (2 z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = partition (coll 0 z) zs; (?xb, ?y) = ?xa;\n   ?xaa = z + sum_list ?xb; x \\<in> set (independent_pdevs ?y);\n   y \\<in> set (independent_pdevs ?y);\n   \\<And>x. x \\<in> set ?y \\<Longrightarrow> x \\<noteq> 0;\n   x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> det3 0 x y \\<noteq> 0\n  x \\<in> set (independent_pdevs (z # zs))\n  y \\<in> set (independent_pdevs (z # zs))\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> 0\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xa = partition (coll 0 z) zs; (?xb, ?y) = ?xa;\n   ?xaa = z + sum_list ?xb; x \\<in> set (independent_pdevs ?y);\n   y \\<in> set (independent_pdevs ?y);\n   \\<And>x. x \\<in> set ?y \\<Longrightarrow> x \\<noteq> 0;\n   x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> det3 0 x y \\<noteq> 0\n  x \\<in> set (independent_pdevs (z # zs))\n  y \\<in> set (independent_pdevs (z # zs))\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> 0\n  x \\<noteq> y", "have \"z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa = partition (coll 0 z) zs; (?xb, ?y) = ?xa;\n   ?xaa = z + sum_list ?xb; x \\<in> set (independent_pdevs ?y);\n   y \\<in> set (independent_pdevs ?y);\n   \\<And>x. x \\<in> set ?y \\<Longrightarrow> x \\<noteq> 0;\n   x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> det3 0 x y \\<noteq> 0\n  x \\<in> set (independent_pdevs (z # zs))\n  y \\<in> set (independent_pdevs (z # zs))\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> 0\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "from 2(2)"], ["proof (chain)\npicking this:\n  x \\<in> set (independent_pdevs (z # zs))", "have \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> set (independent_pdevs (z # zs))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by (rule in_set_independent_pdevs_nonzero)"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "from 2(3)"], ["proof (chain)\npicking this:\n  y \\<in> set (independent_pdevs (z # zs))", "have \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<in> set (independent_pdevs (z # zs))\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by (rule in_set_independent_pdevs_nonzero)"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "let ?c = \"filter (coll 0 z) zs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "let ?nc = \"filter (Not \\<circ> coll 0 z) zs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "assume \"x \\<in> set (independent_pdevs ?nc)\" \"y \\<in> set (independent_pdevs ?nc)\""], ["proof (state)\nthis:\n  x \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\n  y \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "hence \"\\<not>coll 0 x y\""], ["proof (prove)\nusing this:\n  x \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\n  y \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. det3 0 x y \\<noteq> 0", "by (intro 2(1)[OF refl prod.collapse refl _ _ 2(4) 2(5)]) auto"], ["proof (state)\nthis:\n  det3 0 x y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> set (independent_pdevs\n                         (filter (Not \\<circ> coll 0 z) zs));\n   y \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 z) zs))\\<rbrakk>\n  \\<Longrightarrow> det3 0 x y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "note IH = this"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> set (independent_pdevs\n                         (filter (Not \\<circ> coll 0 z) zs));\n   y \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 z) zs))\\<rbrakk>\n  \\<Longrightarrow> det3 0 x y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "{"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> set (independent_pdevs\n                         (filter (Not \\<circ> coll 0 z) zs));\n   y \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 z) zs))\\<rbrakk>\n  \\<Longrightarrow> det3 0 x y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "assume \"x \\<noteq> 0\" \"z + sum_list ?c \\<noteq> 0\"\n      \"coll 0 x (z + sum_list ?c)\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n  z + sum_list (filter (coll 0 z) zs) \\<noteq> 0\n  coll 0 x (z + sum_list (filter (coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "hence \"x \\<notin> set (independent_pdevs ?nc)\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  z + sum_list (filter (coll 0 z) zs) \\<noteq> 0\n  coll 0 x (z + sum_list (filter (coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. x \\<notin> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))", "using sum_list_filter_coll_ex_scale[OF \\<open>z \\<noteq> 0\\<close>, of \"z#zs\"]"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  z + sum_list (filter (coll 0 z) zs) \\<noteq> 0\n  coll 0 x (z + sum_list (filter (coll 0 z) zs))\n  \\<exists>r. sum_list (filter (coll 0 z) (z # zs)) = r *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. x \\<notin> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))", "by (auto elim!: in_set_independent_pdevsE  simp: coll_commute)\n        (metis (no_types) \\<open>x \\<noteq> 0\\<close> coll_scale coll_scaleR)"], ["proof (state)\nthis:\n  x \\<notin> set (independent_pdevs (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> 0; z + sum_list (filter (coll 0 z) zs) \\<noteq> 0;\n   coll 0 ?xa2 (z + sum_list (filter (coll 0 z) zs))\\<rbrakk>\n  \\<Longrightarrow> ?xa2\n                    \\<notin> set (independent_pdevs\n                                   (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "note nc = this"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> 0; z + sum_list (filter (coll 0 z) zs) \\<noteq> 0;\n   coll 0 ?xa2 (z + sum_list (filter (coll 0 z) zs))\\<rbrakk>\n  \\<Longrightarrow> ?xa2\n                    \\<notin> set (independent_pdevs\n                                   (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa xb ya xaaa.\n                   \\<lbrakk>xaa = partition (coll 0 xa) xs; (xb, ya) = xaa;\n                    xaaa = xa + sum_list xb;\n                    x \\<in> set (independent_pdevs ya);\n                    y \\<in> set (independent_pdevs ya);\n                    \\<And>x. x \\<in> set ya \\<Longrightarrow> x \\<noteq> 0;\n                    x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> det3 0 x y \\<noteq> 0;\n        x \\<in> set (independent_pdevs (xa # xs));\n        y \\<in> set (independent_pdevs (xa # xs));\n        \\<And>x. x \\<in> set (xa # xs) \\<Longrightarrow> x \\<noteq> 0;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> det3 0 x y \\<noteq> 0", "from 2(2,3,4,5) nc[OF \\<open>x \\<noteq> 0\\<close>] nc[OF \\<open>y \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  x \\<in> set (independent_pdevs (z # zs))\n  y \\<in> set (independent_pdevs (z # zs))\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> 0\n  x \\<noteq> y\n  \\<lbrakk>z + sum_list (filter (coll 0 z) zs) \\<noteq> 0;\n   coll 0 x (z + sum_list (filter (coll 0 z) zs))\\<rbrakk>\n  \\<Longrightarrow> x \\<notin> set (independent_pdevs\n                                     (filter (Not \\<circ> coll 0 z) zs))\n  \\<lbrakk>z + sum_list (filter (coll 0 z) zs) \\<noteq> 0;\n   coll 0 y (z + sum_list (filter (coll 0 z) zs))\\<rbrakk>\n  \\<Longrightarrow> y \\<notin> set (independent_pdevs\n                                     (filter (Not \\<circ> coll 0 z) zs))", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set (independent_pdevs (z # zs))\n  y \\<in> set (independent_pdevs (z # zs))\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> 0\n  x \\<noteq> y\n  \\<lbrakk>z + sum_list (filter (coll 0 z) zs) \\<noteq> 0;\n   coll 0 x (z + sum_list (filter (coll 0 z) zs))\\<rbrakk>\n  \\<Longrightarrow> x \\<notin> set (independent_pdevs\n                                     (filter (Not \\<circ> coll 0 z) zs))\n  \\<lbrakk>z + sum_list (filter (coll 0 z) zs) \\<noteq> 0;\n   coll 0 y (z + sum_list (filter (coll 0 z) zs))\\<rbrakk>\n  \\<Longrightarrow> y \\<notin> set (independent_pdevs\n                                     (filter (Not \\<circ> coll 0 z) zs))\n\ngoal (1 subgoal):\n 1. det3 0 x y \\<noteq> 0", "by (auto simp: Let_def IH coll_commute split: if_split_asm)"], ["proof (state)\nthis:\n  det3 0 x y \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_independent_pdevs[simp]:\n  shows \"distinct (independent_pdevs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (independent_pdevs xs)", "proof (induct xs rule: independent_pdevs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (independent_pdevs [])\n 2. \\<And>x xs.\n       (\\<And>xa xb y xaa.\n           \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n            xaa = x + sum_list xb\\<rbrakk>\n           \\<Longrightarrow> distinct\n                              (independent_pdevs y)) \\<Longrightarrow>\n       distinct (independent_pdevs (x # xs))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. distinct (independent_pdevs [])\n 2. \\<And>x xs.\n       (\\<And>xa xb y xaa.\n           \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n            xaa = x + sum_list xb\\<rbrakk>\n           \\<Longrightarrow> distinct\n                              (independent_pdevs y)) \\<Longrightarrow>\n       distinct (independent_pdevs (x # xs))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (independent_pdevs [])", "by simp"], ["proof (state)\nthis:\n  distinct (independent_pdevs [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (\\<And>xa xb y xaa.\n           \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n            xaa = x + sum_list xb\\<rbrakk>\n           \\<Longrightarrow> distinct\n                              (independent_pdevs y)) \\<Longrightarrow>\n       distinct (independent_pdevs (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (\\<And>xa xb y xaa.\n           \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n            xaa = x + sum_list xb\\<rbrakk>\n           \\<Longrightarrow> distinct\n                              (independent_pdevs y)) \\<Longrightarrow>\n       distinct (independent_pdevs (x # xs))", "case (2 x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = partition (coll 0 x) xs; (?xb, ?y) = ?xa;\n   ?xaa = x + sum_list ?xb\\<rbrakk>\n  \\<Longrightarrow> distinct (independent_pdevs ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (\\<And>xa xb y xaa.\n           \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n            xaa = x + sum_list xb\\<rbrakk>\n           \\<Longrightarrow> distinct\n                              (independent_pdevs y)) \\<Longrightarrow>\n       distinct (independent_pdevs (x # xs))", "let ?is = \"independent_pdevs (filter (Not \\<circ> coll 0 x) xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (\\<And>xa xb y xaa.\n           \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n            xaa = x + sum_list xb\\<rbrakk>\n           \\<Longrightarrow> distinct\n                              (independent_pdevs y)) \\<Longrightarrow>\n       distinct (independent_pdevs (x # xs))", "have \"distinct ?is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))", "by (rule 2) (auto intro!: 2)"], ["proof (state)\nthis:\n  distinct (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (\\<And>xa xb y xaa.\n           \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n            xaa = x + sum_list xb\\<rbrakk>\n           \\<Longrightarrow> distinct\n                              (independent_pdevs y)) \\<Longrightarrow>\n       distinct (independent_pdevs (x # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))\n\ngoal (1 subgoal):\n 1. distinct (independent_pdevs (x # xs))", "proof (clarsimp simp add: Let_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "let ?s = \"x + sum_list (filter (coll 0 x) xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "assume s: \"?s \\<noteq> 0\" \"?s \\<in> set ?is\""], ["proof (state)\nthis:\n  x + sum_list (filter (coll 0 x) xs) \\<noteq> 0\n  x + sum_list (filter (coll 0 x) xs)\n  \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "from in_set_independent_pdevsE[OF s(2)]"], ["proof (chain)\npicking this:\n  (\\<And>xa.\n      \\<lbrakk>xa \\<in> set (filter (Not \\<circ> coll 0 x) xs);\n       coll 0 xa (x + sum_list (filter (coll 0 x) xs))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain y where y:\n      \"y \\<in> set (filter (Not \\<circ> coll 0 x) xs)\"\n      \"coll 0 y (x + sum_list (filter (coll 0 x) xs))\""], ["proof (prove)\nusing this:\n  (\\<And>xa.\n      \\<lbrakk>xa \\<in> set (filter (Not \\<circ> coll 0 x) xs);\n       coll 0 xa (x + sum_list (filter (coll 0 x) xs))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (filter (Not \\<circ> coll 0 x) xs);\n         coll 0 y (x + sum_list (filter (coll 0 x) xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> set (filter (Not \\<circ> coll 0 x) xs)\n  coll 0 y (x + sum_list (filter (coll 0 x) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  y \\<in> set (filter (Not \\<circ> coll 0 x) xs)\n  coll 0 y (x + sum_list (filter (coll 0 x) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"y = 0 \\<or> x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0\""], ["proof (state)\nthis:\n  y = 0 \\<or> x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "hence False"], ["proof (prove)\nusing this:\n  y = 0 \\<or> x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0\n\ngoal (1 subgoal):\n 1. False", "using s y"], ["proof (prove)\nusing this:\n  y = 0 \\<or> x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0\n  x + sum_list (filter (coll 0 x) xs) \\<noteq> 0\n  x + sum_list (filter (coll 0 x) xs)\n  \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))\n  y \\<in> set (filter (Not \\<circ> coll 0 x) xs)\n  coll 0 y (x + sum_list (filter (coll 0 x) xs))\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: coll_commute)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  y = 0 \\<or>\n  x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  y = 0 \\<or>\n  x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  y = 0 \\<or>\n  x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"y \\<noteq> 0\" \"x \\<noteq> 0\" \"sum_list (filter (coll 0 x) xs) \\<noteq> 0\"\n        \"sum_list (filter (coll 0 x) xs) + x \\<noteq> 0\""], ["proof (state)\nthis:\n  y \\<noteq> 0\n  x \\<noteq> 0\n  sum_list (filter (coll 0 x) xs) \\<noteq> 0\n  sum_list (filter (coll 0 x) xs) + x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "have *: \"coll 0 (sum_list (filter (coll 0 x) xs)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 (sum_list (filter (coll 0 x) xs)) x", "by (auto intro!: coll_sum_list simp: coll_commute)"], ["proof (state)\nthis:\n  coll 0 (sum_list (filter (coll 0 x) xs)) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "have \"coll 0 y (sum_list (filter (coll 0 x) xs) + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 y (sum_list (filter (coll 0 x) xs) + x)", "using s y"], ["proof (prove)\nusing this:\n  x + sum_list (filter (coll 0 x) xs) \\<noteq> 0\n  x + sum_list (filter (coll 0 x) xs)\n  \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))\n  y \\<in> set (filter (Not \\<circ> coll 0 x) xs)\n  coll 0 y (x + sum_list (filter (coll 0 x) xs))\n\ngoal (1 subgoal):\n 1. coll 0 y (sum_list (filter (coll 0 x) xs) + x)", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  coll 0 y (sum_list (filter (coll 0 x) xs) + x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"coll 0 y x\""], ["proof (prove)\nusing this:\n  coll 0 y (sum_list (filter (coll 0 x) xs) + x)\n\ngoal (1 subgoal):\n 1. coll 0 y x", "using *"], ["proof (prove)\nusing this:\n  coll 0 y (sum_list (filter (coll 0 x) xs) + x)\n  coll 0 (sum_list (filter (coll 0 x) xs)) x\n\ngoal (1 subgoal):\n 1. coll 0 y x", "by (rule coll_add_trans) fact+"], ["proof (state)\nthis:\n  coll 0 y x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "hence False"], ["proof (prove)\nusing this:\n  coll 0 y x\n\ngoal (1 subgoal):\n 1. False", "using s y"], ["proof (prove)\nusing this:\n  coll 0 y x\n  x + sum_list (filter (coll 0 x) xs) \\<noteq> 0\n  x + sum_list (filter (coll 0 x) xs)\n  \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))\n  y \\<in> set (filter (Not \\<circ> coll 0 x) xs)\n  coll 0 y (x + sum_list (filter (coll 0 x) xs))\n\ngoal (1 subgoal):\n 1. False", "by (simp add: coll_commute)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<noteq> 0; x \\<noteq> 0;\n   sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n   sum_list (filter (coll 0 x) xs) + x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct\n              (independent_pdevs (filter (Not \\<circ> coll 0 x) xs));\n     x + sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n     x + sum_list (filter (coll 0 x) xs)\n     \\<in> set (independent_pdevs\n                 (filter (Not \\<circ> coll 0 x) xs))\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  y = 0 \\<or>\n  x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0 \\<Longrightarrow>\n  False\n  \\<lbrakk>y \\<noteq> 0; x \\<noteq> 0;\n   sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n   sum_list (filter (coll 0 x) xs) + x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  y = 0 \\<or>\n  x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0 \\<Longrightarrow>\n  False\n  \\<lbrakk>y \\<noteq> 0; x \\<noteq> 0;\n   sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n   sum_list (filter (coll 0 x) xs) + x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "using s y"], ["proof (prove)\nusing this:\n  y = 0 \\<or>\n  x = 0 \\<or> sum_list (filter (coll 0 x) xs) = 0 \\<Longrightarrow>\n  False\n  \\<lbrakk>y \\<noteq> 0; x \\<noteq> 0;\n   sum_list (filter (coll 0 x) xs) \\<noteq> 0;\n   sum_list (filter (coll 0 x) xs) + x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False\n  x + sum_list (filter (coll 0 x) xs) \\<noteq> 0\n  x + sum_list (filter (coll 0 x) xs)\n  \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))\n  y \\<in> set (filter (Not \\<circ> coll 0 x) xs)\n  coll 0 y (x + sum_list (filter (coll 0 x) xs))\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: add.commute)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (independent_pdevs (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_independent_pdevs_invariant_nlex:\n  \"x \\<in> set (independent_pdevs xs) \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> lex x 0) \\<Longrightarrow>\n  (\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0) \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex x 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (independent_pdevs xs);\n     \\<And>x.\n        x \\<in> set xs \\<Longrightarrow>\n        Counterclockwise_2D_Arbitrary.lex x 0;\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex x 0", "proof (induction xs arbitrary: x rule: independent_pdevs.induct )"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (independent_pdevs []);\n        \\<And>x.\n           x \\<in> set [] \\<Longrightarrow>\n           Counterclockwise_2D_Arbitrary.lex x 0;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex x 0\n 2. \\<And>x xs xa.\n       \\<lbrakk>\\<And>xa xb y xaa xc.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    xc \\<in> set (independent_pdevs y);\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow>\n                       Counterclockwise_2D_Arbitrary.lex x 0;\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xc 0;\n        xa \\<in> set (independent_pdevs (x # xs));\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           Counterclockwise_2D_Arbitrary.lex xa 0;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xa 0", "case 1"], ["proof (state)\nthis:\n  x \\<in> set (independent_pdevs [])\n  ?x \\<in> set [] \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex ?x 0\n  ?x \\<in> set [] \\<Longrightarrow> ?x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (independent_pdevs []);\n        \\<And>x.\n           x \\<in> set [] \\<Longrightarrow>\n           Counterclockwise_2D_Arbitrary.lex x 0;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex x 0\n 2. \\<And>x xs xa.\n       \\<lbrakk>\\<And>xa xb y xaa xc.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    xc \\<in> set (independent_pdevs y);\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow>\n                       Counterclockwise_2D_Arbitrary.lex x 0;\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xc 0;\n        xa \\<in> set (independent_pdevs (x # xs));\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           Counterclockwise_2D_Arbitrary.lex xa 0;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xa 0", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> set (independent_pdevs [])\n  ?x \\<in> set [] \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex ?x 0\n  ?x \\<in> set [] \\<Longrightarrow> ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex x 0", "by simp"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex x 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>xa xb y xaa xc.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    xc \\<in> set (independent_pdevs y);\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow>\n                       Counterclockwise_2D_Arbitrary.lex x 0;\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xc 0;\n        xa \\<in> set (independent_pdevs (x # xs));\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           Counterclockwise_2D_Arbitrary.lex xa 0;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xa 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>xa xb y xaa xc.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    xc \\<in> set (independent_pdevs y);\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow>\n                       Counterclockwise_2D_Arbitrary.lex x 0;\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xc 0;\n        xa \\<in> set (independent_pdevs (x # xs));\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           Counterclockwise_2D_Arbitrary.lex xa 0;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xa 0", "case (2 y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = partition (coll 0 y) ys; (?xb, ?y) = ?xa;\n   ?xaa = y + sum_list ?xb; ?x \\<in> set (independent_pdevs ?y);\n   \\<And>x.\n      x \\<in> set ?y \\<Longrightarrow>\n      Counterclockwise_2D_Arbitrary.lex x 0;\n   \\<And>x. x \\<in> set ?y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex ?x 0\n  x \\<in> set (independent_pdevs (y # ys))\n  ?x \\<in> set (y # ys) \\<Longrightarrow>\n  Counterclockwise_2D_Arbitrary.lex ?x 0\n  ?x \\<in> set (y # ys) \\<Longrightarrow> ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>xa xb y xaa xc.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    xc \\<in> set (independent_pdevs y);\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow>\n                       Counterclockwise_2D_Arbitrary.lex x 0;\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xc 0;\n        xa \\<in> set (independent_pdevs (x # xs));\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           Counterclockwise_2D_Arbitrary.lex xa 0;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xa 0", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xa = partition (coll 0 y) ys; (?xb, ?y) = ?xa;\n   ?xaa = y + sum_list ?xb; ?x \\<in> set (independent_pdevs ?y);\n   \\<And>x.\n      x \\<in> set ?y \\<Longrightarrow>\n      Counterclockwise_2D_Arbitrary.lex x 0;\n   \\<And>x. x \\<in> set ?y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex ?x 0\n  x \\<in> set (independent_pdevs (y # ys))\n  ?x \\<in> set (y # ys) \\<Longrightarrow>\n  Counterclockwise_2D_Arbitrary.lex ?x 0\n  ?x \\<in> set (y # ys) \\<Longrightarrow> ?x \\<noteq> 0", "have \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa = partition (coll 0 y) ys; (?xb, ?y) = ?xa;\n   ?xaa = y + sum_list ?xb; ?x \\<in> set (independent_pdevs ?y);\n   \\<And>x.\n      x \\<in> set ?y \\<Longrightarrow>\n      Counterclockwise_2D_Arbitrary.lex x 0;\n   \\<And>x. x \\<in> set ?y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex ?x 0\n  x \\<in> set (independent_pdevs (y # ys))\n  ?x \\<in> set (y # ys) \\<Longrightarrow>\n  Counterclockwise_2D_Arbitrary.lex ?x 0\n  ?x \\<in> set (y # ys) \\<Longrightarrow> ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>xa xb y xaa xc.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    xc \\<in> set (independent_pdevs y);\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow>\n                       Counterclockwise_2D_Arbitrary.lex x 0;\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xc 0;\n        xa \\<in> set (independent_pdevs (x # xs));\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           Counterclockwise_2D_Arbitrary.lex xa 0;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xa 0", "from 2(2)"], ["proof (chain)\npicking this:\n  x \\<in> set (independent_pdevs (y # ys))", "have \"x \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 y) ys)) \\<or>\n    x = y + sum_list (filter (coll 0 y) ys)\""], ["proof (prove)\nusing this:\n  x \\<in> set (independent_pdevs (y # ys))\n\ngoal (1 subgoal):\n 1. x \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 y) ys)) \\<or>\n    x = y + sum_list (filter (coll 0 y) ys)", "by (auto simp: Let_def split: if_split_asm)"], ["proof (state)\nthis:\n  x \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 y) ys)) \\<or>\n  x = y + sum_list (filter (coll 0 y) ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>xa xb y xaa xc.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    xc \\<in> set (independent_pdevs y);\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow>\n                       Counterclockwise_2D_Arbitrary.lex x 0;\n                    \\<And>x.\n                       x \\<in> set y \\<Longrightarrow> x \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xc 0;\n        xa \\<in> set (independent_pdevs (x # xs));\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           Counterclockwise_2D_Arbitrary.lex xa 0;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex xa 0", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 y) ys)) \\<or>\n  x = y + sum_list (filter (coll 0 y) ys)\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex x 0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set (independent_pdevs\n                  (filter (Not \\<circ> coll 0 y) ys)) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0\n 2. x = y + sum_list (filter (coll 0 y) ys) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0", "assume \"x \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 y) ys))\""], ["proof (state)\nthis:\n  x \\<in> set (independent_pdevs (filter (Not \\<circ> coll 0 y) ys))\n\ngoal (2 subgoals):\n 1. x \\<in> set (independent_pdevs\n                  (filter (Not \\<circ> coll 0 y) ys)) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0\n 2. x = y + sum_list (filter (coll 0 y) ys) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0", "from 2(1)[OF refl prod.collapse refl, simplified, OF this 2(3,4)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x.\n              x \\<in> set ys \\<and> det3 0 y x \\<noteq> 0 \\<Longrightarrow>\n              x \\<in> set (y # ys);\n   \\<And>x.\n      x \\<in> set ys \\<and> det3 0 y x \\<noteq> 0 \\<Longrightarrow>\n      x \\<in> set (y # ys)\\<rbrakk>\n  \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex x 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x.\n              x \\<in> set ys \\<and> det3 0 y x \\<noteq> 0 \\<Longrightarrow>\n              x \\<in> set (y # ys);\n   \\<And>x.\n      x \\<in> set ys \\<and> det3 0 y x \\<noteq> 0 \\<Longrightarrow>\n      x \\<in> set (y # ys)\\<rbrakk>\n  \\<Longrightarrow> Counterclockwise_2D_Arbitrary.lex x 0\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex x 0", "by simp"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex x 0\n\ngoal (1 subgoal):\n 1. x = y + sum_list (filter (coll 0 y) ys) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y + sum_list (filter (coll 0 y) ys) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0", "assume \"x = y + sum_list (filter (coll 0 y) ys)\""], ["proof (state)\nthis:\n  x = y + sum_list (filter (coll 0 y) ys)\n\ngoal (1 subgoal):\n 1. x = y + sum_list (filter (coll 0 y) ys) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0", "also"], ["proof (state)\nthis:\n  x = y + sum_list (filter (coll 0 y) ys)\n\ngoal (1 subgoal):\n 1. x = y + sum_list (filter (coll 0 y) ys) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0", "have \"lex \\<dots> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex (y + sum_list (filter (coll 0 y) ys))\n     0", "by (force intro: nlex_add nlex_sum simp: sum_list_sum_nth\n        dest: nth_mem intro: 2(3))"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex (y + sum_list (filter (coll 0 y) ys)) 0\n\ngoal (1 subgoal):\n 1. x = y + sum_list (filter (coll 0 y) ys) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0", "finally"], ["proof (chain)\npicking this:\n  Counterclockwise_2D_Arbitrary.lex x 0", "show ?case"], ["proof (prove)\nusing this:\n  Counterclockwise_2D_Arbitrary.lex x 0\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex x 0", "."], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex x 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex x 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  pdevs_val_independent_pdevs2:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  shows \"\\<exists>e'. e' \\<in> UNIV \\<rightarrow> I \\<and>\n    pdevs_val e (pdevs_of_list (independent_pdevs xs)) = pdevs_val e' (pdevs_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list (independent_pdevs xs)) =\n       pdevs_val e' (pdevs_of_list xs)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list (independent_pdevs xs)) =\n       pdevs_val e' (pdevs_of_list xs)", "proof (induct xs arbitrary: e rule: independent_pdevs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (independent_pdevs [])) =\n          pdevs_val e' (pdevs_of_list [])\n 2. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "case 1"], ["proof (state)\nthis:\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (independent_pdevs [])) =\n          pdevs_val e' (pdevs_of_list [])\n 2. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list (independent_pdevs [])) =\n       pdevs_val e' (pdevs_of_list [])", "by force"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val e (pdevs_of_list (independent_pdevs [])) =\n     pdevs_val e' (pdevs_of_list [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "case (2 x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = partition (coll 0 x) xs; (?xb, ?y) = ?xa;\n   ?xaa = x + sum_list ?xb; ?e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'.\n                       e' \\<in> UNIV \\<rightarrow> I \\<and>\n                       pdevs_val ?e (pdevs_of_list (independent_pdevs ?y)) =\n                       pdevs_val e' (pdevs_of_list ?y)\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "let ?coll = \"(filter (coll 0 x) (x#xs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "let ?ncoll = \"(filter (Not o coll 0 x) (x#xs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "let ?e0 = \"if sum_list ?coll = 0 then e else e \\<circ> (+) (Suc 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "have \"pdevs_val e (pdevs_of_list (independent_pdevs (x#xs))) =\n    e 0 *\\<^sub>R (sum_list ?coll) + pdevs_val ?e0 (pdevs_of_list (independent_pdevs ?ncoll))\"\n    (is \"_ = ?vc + ?vnc\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (independent_pdevs (x # xs))) =\n    e 0 *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) +\n    pdevs_val\n     (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n      else e \\<circ> (+) (Suc 0))\n     (pdevs_of_list\n       (independent_pdevs (filter (Not \\<circ> coll 0 x) (x # xs))))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (independent_pdevs (x # xs))) =\n  e 0 *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) +\n  pdevs_val\n   (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n    else e \\<circ> (+) (Suc 0))\n   (pdevs_of_list\n     (independent_pdevs (filter (Not \\<circ> coll 0 x) (x # xs))))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (independent_pdevs (x # xs))) =\n  e 0 *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) +\n  pdevs_val\n   (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n    else e \\<circ> (+) (Suc 0))\n   (pdevs_of_list\n     (independent_pdevs (filter (Not \\<circ> coll 0 x) (x # xs))))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "have e_split: \"(\\<lambda>_. e 0) \\<in> UNIV \\<rightarrow> I\" \"?e0 \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. e 0) \\<in> UNIV \\<rightarrow> I &&&\n    (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n     else e \\<circ> (+) (Suc 0))\n    \\<in> UNIV \\<rightarrow> I", "using 2(2)"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. e 0) \\<in> UNIV \\<rightarrow> I &&&\n    (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n     else e \\<circ> (+) (Suc 0))\n    \\<in> UNIV \\<rightarrow> I", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>_. e 0) \\<in> UNIV \\<rightarrow> I\n  (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n   else e \\<circ> (+) (Suc 0))\n  \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "from 2(1)[OF refl prod.collapse refl e_split(2)]"], ["proof (chain)\npicking this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val\n      (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n       else e \\<circ> (+) (Suc 0))\n      (pdevs_of_list (independent_pdevs (snd (partition (coll 0 x) xs)))) =\n     pdevs_val e' (pdevs_of_list (snd (partition (coll 0 x) xs)))", "obtain e' where e': \"e' \\<in> UNIV \\<rightarrow> I\" and \"?vnc = pdevs_val e' (pdevs_of_list ?ncoll)\""], ["proof (prove)\nusing this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val\n      (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n       else e \\<circ> (+) (Suc 0))\n      (pdevs_of_list (independent_pdevs (snd (partition (coll 0 x) xs)))) =\n     pdevs_val e' (pdevs_of_list (snd (partition (coll 0 x) xs)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val\n          (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n           else e \\<circ> (+) (Suc 0))\n          (pdevs_of_list\n            (independent_pdevs (filter (Not \\<circ> coll 0 x) (x # xs)))) =\n         pdevs_val e'\n          (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: o_def)"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val\n   (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n    else e \\<circ> (+) (Suc 0))\n   (pdevs_of_list\n     (independent_pdevs (filter (Not \\<circ> coll 0 x) (x # xs)))) =\n  pdevs_val e' (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val\n   (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n    else e \\<circ> (+) (Suc 0))\n   (pdevs_of_list\n     (independent_pdevs (filter (Not \\<circ> coll 0 x) (x # xs)))) =\n  pdevs_val e' (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "also"], ["proof (state)\nthis:\n  pdevs_val\n   (if sum_list (filter (coll 0 x) (x # xs)) = 0 then e\n    else e \\<circ> (+) (Suc 0))\n   (pdevs_of_list\n     (independent_pdevs (filter (Not \\<circ> coll 0 x) (x # xs)))) =\n  pdevs_val e' (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "have \"?vc = pdevs_val (\\<lambda>_. e 0) (pdevs_of_list ?coll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e 0 *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) =\n    pdevs_val (\\<lambda>_. e 0) (pdevs_of_list (filter (coll 0 x) (x # xs)))", "by (simp add: pdevs_val_const_pdevs_of_list)"], ["proof (state)\nthis:\n  e 0 *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) =\n  pdevs_val (\\<lambda>_. e 0) (pdevs_of_list (filter (coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "also"], ["proof (state)\nthis:\n  e 0 *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) =\n  pdevs_val (\\<lambda>_. e 0) (pdevs_of_list (filter (coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "from pdevs_val_pdevs_of_list_append[OF e_split(1) e']"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>pdevs_val (\\<lambda>_. e 0) (pdevs_of_list ?xs) +\n               pdevs_val e' (pdevs_of_list ?ys) =\n               pdevs_val e (pdevs_of_list (?xs @ ?ys));\n       e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e'' where\n    e'': \"e'' \\<in> UNIV \\<rightarrow> I\"\n    and \"pdevs_val (\\<lambda>_. e 0) (pdevs_of_list ?coll) + pdevs_val e' (pdevs_of_list ?ncoll) =\n      pdevs_val e'' (pdevs_of_list (?coll @ ?ncoll))\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>pdevs_val (\\<lambda>_. e 0) (pdevs_of_list ?xs) +\n               pdevs_val e' (pdevs_of_list ?ys) =\n               pdevs_val e (pdevs_of_list (?xs @ ?ys));\n       e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>e'' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val (\\<lambda>_. e 0)\n          (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n         pdevs_val e'\n          (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs))) =\n         pdevs_val e''\n          (pdevs_of_list\n            (filter (coll 0 x) (x # xs) @\n             filter (Not \\<circ> coll 0 x) (x # xs)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  e'' \\<in> UNIV \\<rightarrow> I\n  pdevs_val (\\<lambda>_. e 0) (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n  pdevs_val e' (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs))) =\n  pdevs_val e''\n   (pdevs_of_list\n     (filter (coll 0 x) (x # xs) @ filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>_. e 0) (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n  pdevs_val e' (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs))) =\n  pdevs_val e''\n   (pdevs_of_list\n     (filter (coll 0 x) (x # xs) @ filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "also"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>_. e 0) (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n  pdevs_val e' (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs))) =\n  pdevs_val e''\n   (pdevs_of_list\n     (filter (coll 0 x) (x # xs) @ filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "from pdevs_val_perm[OF partition_permI e'', of \"coll 0 x\" \"x#xs\"]"], ["proof (chain)\npicking this:\n  (\\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n       pdevs_val e''\n        (pdevs_of_list\n          (filter (coll 0 x) (x # xs) @\n           filter (Not \\<circ> coll 0 x) (x # xs))) =\n       pdevs_val e' (pdevs_of_list (x # xs))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e''' where e''': \"e''' \\<in> UNIV \\<rightarrow> I\"\n    and \"\\<dots> = pdevs_val e''' (pdevs_of_list (x # xs))\""], ["proof (prove)\nusing this:\n  (\\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n       pdevs_val e''\n        (pdevs_of_list\n          (filter (coll 0 x) (x # xs) @\n           filter (Not \\<circ> coll 0 x) (x # xs))) =\n       pdevs_val e' (pdevs_of_list (x # xs))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e'''.\n        \\<lbrakk>e''' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e''\n          (pdevs_of_list\n            (filter (coll 0 x) (x # xs) @\n             filter (Not \\<circ> coll 0 x) (x # xs))) =\n         pdevs_val e''' (pdevs_of_list (x # xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  e''' \\<in> UNIV \\<rightarrow> I\n  pdevs_val e''\n   (pdevs_of_list\n     (filter (coll 0 x) (x # xs) @\n      filter (Not \\<circ> coll 0 x) (x # xs))) =\n  pdevs_val e''' (pdevs_of_list (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e''\n   (pdevs_of_list\n     (filter (coll 0 x) (x # xs) @\n      filter (Not \\<circ> coll 0 x) (x # xs))) =\n  pdevs_val e''' (pdevs_of_list (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> I \\<and>\n  pdevs_val e (pdevs_of_list (independent_pdevs y)) =\n  pdevs_val e' (pdevs_of_list y);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e\n                             (pdevs_of_list (independent_pdevs (x # xs))) =\n                            pdevs_val e' (pdevs_of_list (x # xs))", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list (independent_pdevs (x # xs))) =\n  pdevs_val e''' (pdevs_of_list (x # xs))", "show ?case"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (independent_pdevs (x # xs))) =\n  pdevs_val e''' (pdevs_of_list (x # xs))\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list (independent_pdevs (x # xs))) =\n       pdevs_val e' (pdevs_of_list (x # xs))", "using e'''"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (independent_pdevs (x # xs))) =\n  pdevs_val e''' (pdevs_of_list (x # xs))\n  e''' \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list (independent_pdevs (x # xs))) =\n       pdevs_val e' (pdevs_of_list (x # xs))", "by auto"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val e (pdevs_of_list (independent_pdevs (x # xs))) =\n     pdevs_val e' (pdevs_of_list (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_all_filter: \"list_all p (filter p xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all p (filter p xs)", "by (induct xs) auto"], ["", "lemma pdevs_val_independent_pdevs:\n  assumes \"list_all (\\<lambda>x. lex x 0) xs\"\n  assumes \"list_all (\\<lambda>x. x \\<noteq> 0) xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"\\<exists>e'. e' \\<in> UNIV \\<rightarrow> {-1 .. 1} \\<and> pdevs_val e (pdevs_of_list xs) =\n    pdevs_val e' (pdevs_of_list (independent_pdevs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       pdevs_val e (pdevs_of_list xs) =\n       pdevs_val e' (pdevs_of_list (independent_pdevs xs))", "using assms(1,2,3)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\n  list_all (\\<lambda>x. x \\<noteq> 0) xs\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       pdevs_val e (pdevs_of_list xs) =\n       pdevs_val e' (pdevs_of_list (independent_pdevs xs))", "proof (induct xs arbitrary: e rule: independent_pdevs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                 [];\n        list_all (\\<lambda>x. x \\<noteq> 0) [];\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list []) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs []))\n 2. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "case 1"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                 [];\n        list_all (\\<lambda>x. x \\<noteq> 0) [];\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list []) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs []))\n 2. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       pdevs_val e (pdevs_of_list []) =\n       pdevs_val e' (pdevs_of_list (independent_pdevs []))", "by force"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n     pdevs_val e (pdevs_of_list []) =\n     pdevs_val e' (pdevs_of_list (independent_pdevs []))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "case (2 x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = partition (coll 0 x) xs; (?xb, ?y) = ?xa;\n   ?xaa = x + sum_list ?xb;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) ?y;\n   list_all (\\<lambda>x. x \\<noteq> 0) ?y;\n   ?e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'.\n                       e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                       pdevs_val ?e (pdevs_of_list ?y) =\n                       pdevs_val e' (pdevs_of_list (independent_pdevs ?y))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "let ?coll = \"(filter (coll 0 x) (x#xs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "let ?ncoll = \"(filter (Not o coll 0 x) xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xa = partition (coll 0 x) xs; (?xb, ?y) = ?xa;\n   ?xaa = x + sum_list ?xb;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) ?y;\n   list_all (\\<lambda>x. x \\<noteq> 0) ?y;\n   ?e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'.\n                       e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                       pdevs_val ?e (pdevs_of_list ?y) =\n                       pdevs_val e' (pdevs_of_list (independent_pdevs ?y))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa = partition (coll 0 x) xs; (?xb, ?y) = ?xa;\n   ?xaa = x + sum_list ?xb;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) ?y;\n   list_all (\\<lambda>x. x \\<noteq> 0) ?y;\n   ?e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'.\n                       e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                       pdevs_val ?e (pdevs_of_list ?y) =\n                       pdevs_val e' (pdevs_of_list (independent_pdevs ?y))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from pdevs_val_partition[OF 2(4), of \"x#xs\" \"coll 0 x\"]"], ["proof (chain)\npicking this:\n  (\\<And>f g.\n      \\<lbrakk>pdevs_val e (pdevs_of_list (x # xs)) =\n               pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n               pdevs_val g\n                (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)));\n       f \\<in> UNIV \\<rightarrow> {- 1..1};\n       g \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain f g where part: \"pdevs_val e (pdevs_of_list (x # xs)) =\n      pdevs_val f (pdevs_of_list ?coll) +\n      pdevs_val g (pdevs_of_list (filter (Not o coll 0 x) (x#xs)))\"\n    and f: \"f \\<in> UNIV \\<rightarrow> {-1 .. 1}\" and g: \"g \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  (\\<And>f g.\n      \\<lbrakk>pdevs_val e (pdevs_of_list (x # xs)) =\n               pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n               pdevs_val g\n                (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)));\n       f \\<in> UNIV \\<rightarrow> {- 1..1};\n       g \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (x # xs)) =\n                 pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n                 pdevs_val g\n                  (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)));\n         f \\<in> UNIV \\<rightarrow> {- 1..1};\n         g \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n  g \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "note part"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "have \"list_all (\\<lambda>x. lex x 0) (filter (coll 0 x) (x#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n     (filter (coll 0 x) (x # xs))", "using 2(2)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n     (filter (coll 0 x) (x # xs))", "by (auto simp: inner_prod_def list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (filter (coll 0 x) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from pdevs_val_coll[OF list_all_filter this \\<open>x \\<noteq> 0\\<close> f]"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>e \\<in> {- 1..1};\n       pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n       e *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain f' where \"pdevs_val f (pdevs_of_list ?coll) = f' *\\<^sub>R sum_list (filter (coll 0 x) (x#xs))\"\n    and f': \"f' \\<in> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>e \\<in> {- 1..1};\n       pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n       e *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n                 f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs));\n         f' \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n  f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\n  f' \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n  f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "also"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n  f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "have \"filter (Not o coll 0 x) (x#xs) = ?ncoll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (Not \\<circ> coll 0 x) (x # xs) =\n    filter (Not \\<circ> coll 0 x) xs", "by simp"], ["proof (state)\nthis:\n  filter (Not \\<circ> coll 0 x) (x # xs) = filter (Not \\<circ> coll 0 x) xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "also"], ["proof (state)\nthis:\n  filter (Not \\<circ> coll 0 x) (x # xs) = filter (Not \\<circ> coll 0 x) xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from 2(2)"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)", "have \"list_all (\\<lambda>x. lex x 0) ?ncoll\" \"list_all (\\<lambda>x. x \\<noteq> 0) ?ncoll\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n     (filter (Not \\<circ> coll 0 x) xs) &&&\n    list_all (\\<lambda>x. x \\<noteq> 0) (filter (Not \\<circ> coll 0 x) xs)", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (filter (Not \\<circ> coll 0 x) xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (filter (Not \\<circ> coll 0 x) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from 2(1)[OF refl partition_filter_conv[symmetric] refl this g]"], ["proof (chain)\npicking this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n     pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n     pdevs_val e'\n      (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))", "obtain g'\n  where \"pdevs_val g (pdevs_of_list ?ncoll) =\n      pdevs_val g' (pdevs_of_list (independent_pdevs ?ncoll))\"\n    and g': \"g' \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n     pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n     pdevs_val e'\n      (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>pdevs_val g\n                  (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n                 pdevs_val g'\n                  (pdevs_of_list\n                    (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)));\n         g' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n  pdevs_val g'\n   (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))\n  g' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n  pdevs_val g'\n   (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "also"], ["proof (state)\nthis:\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n  pdevs_val g'\n   (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "define h where \"h = (if sum_list ?coll \\<noteq> 0 then rec_nat f' (\\<lambda>i _. g' i) else g')\""], ["proof (state)\nthis:\n  h =\n  (if sum_list (filter (coll 0 x) (x # xs)) \\<noteq> 0\n   then rec_nat f' (\\<lambda>i _. g' i) else g')\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "have \"f' *\\<^sub>R sum_list ?coll + pdevs_val g' (pdevs_of_list (independent_pdevs ?ncoll))\n      = pdevs_val h (pdevs_of_list (independent_pdevs (x#xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) +\n    pdevs_val g'\n     (pdevs_of_list\n       (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))) =\n    pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))", "by (simp add: h_def o_def Let_def)"], ["proof (state)\nthis:\n  f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) +\n  pdevs_val g'\n   (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))", "have \"pdevs_val e (pdevs_of_list (x # xs)) =\n      pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\""], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))", "."], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "moreover"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "have \"h \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> UNIV \\<rightarrow> {- 1..1}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> h x \\<in> {- 1..1}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> h x \\<in> {- 1..1}", "show \"h i \\<in> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i \\<in> {- 1..1}", "using f' g'"], ["proof (prove)\nusing this:\n  f' \\<in> {- 1..1}\n  g' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. h i \\<in> {- 1..1}", "by (cases i) (auto simp: h_def)"], ["proof (state)\nthis:\n  h i \\<in> {- 1..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n  h \\<in> UNIV \\<rightarrow> {- 1..1}", "show ?case"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n  h \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       pdevs_val e (pdevs_of_list (x # xs)) =\n       pdevs_val e' (pdevs_of_list (independent_pdevs (x # xs)))", "by blast"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n     pdevs_val e (pdevs_of_list (x # xs)) =\n     pdevs_val e' (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  pdevs_val_independent_pdevs_strict:\n  assumes \"list_all (\\<lambda>x. lex x 0) xs\"\n  assumes \"list_all (\\<lambda>x. x \\<noteq> 0) xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  shows \"\\<exists>e'. e' \\<in> UNIV \\<rightarrow> {-1 <..< 1} \\<and> pdevs_val e (pdevs_of_list xs) =\n    pdevs_val e' (pdevs_of_list (independent_pdevs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n       pdevs_val e (pdevs_of_list xs) =\n       pdevs_val e' (pdevs_of_list (independent_pdevs xs))", "using assms(1,2,3)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs\n  list_all (\\<lambda>x. x \\<noteq> 0) xs\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n       pdevs_val e (pdevs_of_list xs) =\n       pdevs_val e' (pdevs_of_list (independent_pdevs xs))", "proof (induct xs arbitrary: e rule: independent_pdevs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                 [];\n        list_all (\\<lambda>x. x \\<noteq> 0) [];\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list []) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs []))\n 2. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "case 1"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n                 [];\n        list_all (\\<lambda>x. x \\<noteq> 0) [];\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list []) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs []))\n 2. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n       pdevs_val e (pdevs_of_list []) =\n       pdevs_val e' (pdevs_of_list (independent_pdevs []))", "by force"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n     pdevs_val e (pdevs_of_list []) =\n     pdevs_val e' (pdevs_of_list (independent_pdevs []))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "case (2 x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = partition (coll 0 x) xs; (?xb, ?y) = ?xa;\n   ?xaa = x + sum_list ?xb;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) ?y;\n   list_all (\\<lambda>x. x \\<noteq> 0) ?y;\n   ?e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'.\n                       e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                       pdevs_val ?e (pdevs_of_list ?y) =\n                       pdevs_val e' (pdevs_of_list (independent_pdevs ?y))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "let ?coll = \"(filter (coll 0 x) (x#xs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "let ?ncoll = \"(filter (Not o coll 0 x) xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xa = partition (coll 0 x) xs; (?xb, ?y) = ?xa;\n   ?xaa = x + sum_list ?xb;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) ?y;\n   list_all (\\<lambda>x. x \\<noteq> 0) ?y;\n   ?e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'.\n                       e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                       pdevs_val ?e (pdevs_of_list ?y) =\n                       pdevs_val e' (pdevs_of_list (independent_pdevs ?y))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}", "have \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa = partition (coll 0 x) xs; (?xb, ?y) = ?xa;\n   ?xaa = x + sum_list ?xb;\n   list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) ?y;\n   list_all (\\<lambda>x. x \\<noteq> 0) ?y;\n   ?e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'.\n                       e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                       pdevs_val ?e (pdevs_of_list ?y) =\n                       pdevs_val e' (pdevs_of_list (independent_pdevs ?y))\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from pdevs_val_partition[OF 2(4), of \"x#xs\" \"coll 0 x\"]"], ["proof (chain)\npicking this:\n  (\\<And>f g.\n      \\<lbrakk>pdevs_val e (pdevs_of_list (x # xs)) =\n               pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n               pdevs_val g\n                (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)));\n       f \\<in> UNIV \\<rightarrow> {- 1<..<1};\n       g \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain f g\n  where part: \"pdevs_val e (pdevs_of_list (x # xs)) =\n      pdevs_val f (pdevs_of_list ?coll) +\n      pdevs_val g (pdevs_of_list (filter (Not o coll 0 x) (x#xs)))\"\n    and f: \"f \\<in> UNIV \\<rightarrow> {-1 <..< 1}\" and g: \"g \\<in> UNIV \\<rightarrow> {-1 <..< 1}\""], ["proof (prove)\nusing this:\n  (\\<And>f g.\n      \\<lbrakk>pdevs_val e (pdevs_of_list (x # xs)) =\n               pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n               pdevs_val g\n                (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)));\n       f \\<in> UNIV \\<rightarrow> {- 1<..<1};\n       g \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (x # xs)) =\n                 pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n                 pdevs_val g\n                  (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)));\n         f \\<in> UNIV \\<rightarrow> {- 1<..<1};\n         g \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\n  f \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  g \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "note part"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) +\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "have \"list_all (\\<lambda>x. lex x 0) (filter (coll 0 x) (x#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n     (filter (coll 0 x) (x # xs))", "using 2(2)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n     (filter (coll 0 x) (x # xs))", "by (auto simp: inner_prod_def list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (filter (coll 0 x) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from pdevs_val_coll_strict[OF list_all_filter this \\<open>x \\<noteq> 0\\<close> f]"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>e \\<in> {- 1<..<1};\n       pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n       e *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain f' where \"pdevs_val f (pdevs_of_list ?coll) = f' *\\<^sub>R sum_list (filter (coll 0 x) (x#xs))\"\n    and f': \"f' \\<in> {-1 <..< 1}\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>e \\<in> {- 1<..<1};\n       pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n       e *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n                 f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs));\n         f' \\<in> {- 1<..<1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n  f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\n  f' \\<in> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n  f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "also"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list (filter (coll 0 x) (x # xs))) =\n  f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "have \"filter (Not o coll 0 x) (x#xs) = ?ncoll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (Not \\<circ> coll 0 x) (x # xs) =\n    filter (Not \\<circ> coll 0 x) xs", "by simp"], ["proof (state)\nthis:\n  filter (Not \\<circ> coll 0 x) (x # xs) = filter (Not \\<circ> coll 0 x) xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "also"], ["proof (state)\nthis:\n  filter (Not \\<circ> coll 0 x) (x # xs) = filter (Not \\<circ> coll 0 x) xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from 2(2)"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)", "have \"list_all (\\<lambda>x. lex x 0) ?ncoll\" \"list_all (\\<lambda>x. x \\<noteq> 0) ?ncoll\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n     (filter (Not \\<circ> coll 0 x) xs) &&&\n    list_all (\\<lambda>x. x \\<noteq> 0) (filter (Not \\<circ> coll 0 x) xs)", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (filter (Not \\<circ> coll 0 x) xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (filter (Not \\<circ> coll 0 x) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "from 2(1)[OF refl partition_filter_conv[symmetric] refl this g]"], ["proof (chain)\npicking this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n     pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n     pdevs_val e'\n      (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))", "obtain g'\n  where \"pdevs_val g (pdevs_of_list ?ncoll) =\n      pdevs_val g' (pdevs_of_list (independent_pdevs ?ncoll))\"\n    and g': \"g' \\<in> UNIV \\<rightarrow> {-1 <..< 1}\""], ["proof (prove)\nusing this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n     pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n     pdevs_val e'\n      (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>pdevs_val g\n                  (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n                 pdevs_val g'\n                  (pdevs_of_list\n                    (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)));\n         g' \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n  pdevs_val g'\n   (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))\n  g' \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n  pdevs_val g'\n   (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "also"], ["proof (state)\nthis:\n  pdevs_val g (pdevs_of_list (filter (Not \\<circ> coll 0 x) xs)) =\n  pdevs_val g'\n   (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "define h where \"h = (if sum_list ?coll \\<noteq> 0 then rec_nat f' (\\<lambda>i _. g' i) else g')\""], ["proof (state)\nthis:\n  h =\n  (if sum_list (filter (coll 0 x) (x # xs)) \\<noteq> 0\n   then rec_nat f' (\\<lambda>i _. g' i) else g')\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "have \"f' *\\<^sub>R sum_list ?coll + pdevs_val g' (pdevs_of_list (independent_pdevs ?ncoll))\n      = pdevs_val h (pdevs_of_list (independent_pdevs (x#xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) +\n    pdevs_val g'\n     (pdevs_of_list\n       (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))) =\n    pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))", "by (simp add: h_def o_def Let_def)"], ["proof (state)\nthis:\n  f' *\\<^sub>R sum_list (filter (coll 0 x) (x # xs)) +\n  pdevs_val g'\n   (pdevs_of_list (independent_pdevs (filter (Not \\<circ> coll 0 x) xs))) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))", "have \"pdevs_val e (pdevs_of_list (x # xs)) =\n      pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\""], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))", "."], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "moreover"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "have \"h \\<in> UNIV \\<rightarrow> {-1 <..< 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> UNIV \\<rightarrow> {- 1<..<1}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> h x \\<in> {- 1<..<1}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> h x \\<in> {- 1<..<1}", "show \"h i \\<in> {-1 <..< 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i \\<in> {- 1<..<1}", "using f' g'"], ["proof (prove)\nusing this:\n  f' \\<in> {- 1<..<1}\n  g' \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. h i \\<in> {- 1<..<1}", "by (cases i) (auto simp: h_def)"], ["proof (state)\nthis:\n  h i \\<in> {- 1<..<1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs e.\n       \\<lbrakk>\\<And>xa xb y xaa e.\n                   \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n                    xaa = x + sum_list xb;\n                    list_all\n                     (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) y;\n                    list_all (\\<lambda>x. x \\<noteq> 0) y;\n                    e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'.\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n  pdevs_val e (pdevs_of_list y) =\n  pdevs_val e' (pdevs_of_list (independent_pdevs y));\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (x # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (x # xs);\n        e \\<in> UNIV \\<rightarrow> {- 1<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n                            pdevs_val e (pdevs_of_list (x # xs)) =\n                            pdevs_val e'\n                             (pdevs_of_list (independent_pdevs (x # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n  h \\<in> UNIV \\<rightarrow> {- 1<..<1}", "show ?case"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  pdevs_val h (pdevs_of_list (independent_pdevs (x # xs)))\n  h \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n       pdevs_val e (pdevs_of_list (x # xs)) =\n       pdevs_val e' (pdevs_of_list (independent_pdevs (x # xs)))", "by blast"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n     pdevs_val e (pdevs_of_list (x # xs)) =\n     pdevs_val e' (pdevs_of_list (independent_pdevs (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_independent_pdevs: \"sum_list (independent_pdevs xs) = sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (independent_pdevs xs) = sum_list xs", "proof (induct xs rule: independent_pdevs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (independent_pdevs []) = sum_list []\n 2. \\<And>x xs.\n       (\\<And>xa xb y xaa.\n           \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n            xaa = x + sum_list xb\\<rbrakk>\n           \\<Longrightarrow> sum_list (independent_pdevs y) =\n                             sum_list y) \\<Longrightarrow>\n       sum_list (independent_pdevs (x # xs)) = sum_list (x # xs)", "case (2 y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = partition (coll 0 y) ys; (?xb, ?y) = ?xa;\n   ?xaa = y + sum_list ?xb\\<rbrakk>\n  \\<Longrightarrow> sum_list (independent_pdevs ?y) = sum_list ?y\n\ngoal (2 subgoals):\n 1. sum_list (independent_pdevs []) = sum_list []\n 2. \\<And>x xs.\n       (\\<And>xa xb y xaa.\n           \\<lbrakk>xa = partition (coll 0 x) xs; (xb, y) = xa;\n            xaa = x + sum_list xb\\<rbrakk>\n           \\<Longrightarrow> sum_list (independent_pdevs y) =\n                             sum_list y) \\<Longrightarrow>\n       sum_list (independent_pdevs (x # xs)) = sum_list (x # xs)", "from 2[OF refl prod.collapse refl]"], ["proof (chain)\npicking this:\n  sum_list (independent_pdevs (snd (partition (coll 0 y) ys))) =\n  sum_list (snd (partition (coll 0 y) ys))", "show ?case"], ["proof (prove)\nusing this:\n  sum_list (independent_pdevs (snd (partition (coll 0 y) ys))) =\n  sum_list (snd (partition (coll 0 y) ys))\n\ngoal (1 subgoal):\n 1. sum_list (independent_pdevs (y # ys)) = sum_list (y # ys)", "using sum_list_partition[of \"coll 0 y\" ys, symmetric]"], ["proof (prove)\nusing this:\n  sum_list (independent_pdevs (snd (partition (coll 0 y) ys))) =\n  sum_list (snd (partition (coll 0 y) ys))\n  sum_list ys =\n  sum_list (filter (coll 0 y) ys) +\n  sum_list (filter (Not \\<circ> coll 0 y) ys)\n\ngoal (1 subgoal):\n 1. sum_list (independent_pdevs (y # ys)) = sum_list (y # ys)", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  sum_list (independent_pdevs (y # ys)) = sum_list (y # ys)\n\ngoal (1 subgoal):\n 1. sum_list (independent_pdevs []) = sum_list []", "qed simp"], ["", "lemma independent_pdevs_eq_Nil_iff:\n  \"list_all (\\<lambda>x. lex x 0) xs \\<Longrightarrow> list_all (\\<lambda>x. x \\<noteq> 0) xs \\<Longrightarrow> independent_pdevs xs = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n              xs;\n     list_all (\\<lambda>x. x \\<noteq> 0) xs\\<rbrakk>\n    \\<Longrightarrow> (independent_pdevs xs = []) = (xs = [])", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n              [];\n     list_all (\\<lambda>x. x \\<noteq> 0) []\\<rbrakk>\n    \\<Longrightarrow> (independent_pdevs [] = []) = ([] = [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list_all\n                          (\\<lambda>x.\n                              Counterclockwise_2D_Arbitrary.lex x 0)\n                          xs;\n                 list_all (\\<lambda>x. x \\<noteq> 0) xs\\<rbrakk>\n                \\<Longrightarrow> (independent_pdevs xs = []) = (xs = []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (independent_pdevs (a # xs) = []) = (a # xs = [])", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n              [];\n     list_all (\\<lambda>x. x \\<noteq> 0) []\\<rbrakk>\n    \\<Longrightarrow> (independent_pdevs [] = []) = ([] = [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list_all\n                          (\\<lambda>x.\n                              Counterclockwise_2D_Arbitrary.lex x 0)\n                          xs;\n                 list_all (\\<lambda>x. x \\<noteq> 0) xs\\<rbrakk>\n                \\<Longrightarrow> (independent_pdevs xs = []) = (xs = []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (independent_pdevs (a # xs) = []) = (a # xs = [])", "thus ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) []\n  list_all (\\<lambda>x. x \\<noteq> 0) []\n\ngoal (1 subgoal):\n 1. (independent_pdevs [] = []) = ([] = [])", "by simp"], ["proof (state)\nthis:\n  (independent_pdevs [] = []) = ([] = [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list_all\n                          (\\<lambda>x.\n                              Counterclockwise_2D_Arbitrary.lex x 0)\n                          xs;\n                 list_all (\\<lambda>x. x \\<noteq> 0) xs\\<rbrakk>\n                \\<Longrightarrow> (independent_pdevs xs = []) = (xs = []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (independent_pdevs (a # xs) = []) = (a # xs = [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list_all\n                          (\\<lambda>x.\n                              Counterclockwise_2D_Arbitrary.lex x 0)\n                          xs;\n                 list_all (\\<lambda>x. x \\<noteq> 0) xs\\<rbrakk>\n                \\<Longrightarrow> (independent_pdevs xs = []) = (xs = []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (independent_pdevs (a # xs) = []) = (a # xs = [])", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) xs;\n   list_all (\\<lambda>x. x \\<noteq> 0) xs\\<rbrakk>\n  \\<Longrightarrow> (independent_pdevs xs = []) = (xs = [])\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list_all\n                          (\\<lambda>x.\n                              Counterclockwise_2D_Arbitrary.lex x 0)\n                          xs;\n                 list_all (\\<lambda>x. x \\<noteq> 0) xs\\<rbrakk>\n                \\<Longrightarrow> (independent_pdevs xs = []) = (xs = []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (independent_pdevs (a # xs) = []) = (a # xs = [])", "from Cons(2)"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)", "have \"list_all (\\<lambda>x. lex x 0) (x # filter (coll 0 x) xs)\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) (x # xs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n     (x # filter (coll 0 x) xs)", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (x # filter (coll 0 x) xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list_all\n                          (\\<lambda>x.\n                              Counterclockwise_2D_Arbitrary.lex x 0)\n                          xs;\n                 list_all (\\<lambda>x. x \\<noteq> 0) xs\\<rbrakk>\n                \\<Longrightarrow> (independent_pdevs xs = []) = (xs = []);\n        list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n         (a # xs);\n        list_all (\\<lambda>x. x \\<noteq> 0) (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (independent_pdevs (a # xs) = []) = (a # xs = [])", "from sum_list_nlex_eq_zero_iff[OF this] Cons(3)"], ["proof (chain)\npicking this:\n  (sum_list (x # filter (coll 0 x) xs) = 0) =\n  list_all ((=) 0) (x # filter (coll 0 x) xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  (sum_list (x # filter (coll 0 x) xs) = 0) =\n  list_all ((=) 0) (x # filter (coll 0 x) xs)\n  list_all (\\<lambda>x. x \\<noteq> 0) (x # xs)\n\ngoal (1 subgoal):\n 1. (independent_pdevs (x # xs) = []) = (x # xs = [])", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  (independent_pdevs (x # xs) = []) = (x # xs = [])\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Independent Oriented Generators\\<close>"], ["", "definition \"inl p = independent_pdevs (map snd (list_of_pdevs (nlex_pdevs p)))\""], ["", "lemma distinct_inl[simp]: \"distinct (inl (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inl (snd X))", "by (auto simp: inl_def)"], ["", "lemma in_set_inl_nonzero: \"x \\<in> set (inl xs) \\<Longrightarrow> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (inl xs) \\<Longrightarrow> x \\<noteq> 0", "by (auto simp: inl_def in_set_independent_pdevs_nonzero)"], ["", "lemma\n  inl_ncoll: \"y \\<in> set (inl (snd X)) \\<Longrightarrow> z \\<in> set (inl (snd X)) \\<Longrightarrow> y \\<noteq> z \\<Longrightarrow> \\<not>coll 0 y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set (inl (snd X)); z \\<in> set (inl (snd X));\n     y \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> det3 0 y z \\<noteq> 0", "unfolding inl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set (independent_pdevs\n                           (map snd (list_of_pdevs (nlex_pdevs (snd X)))));\n     z \\<in> set (independent_pdevs\n                   (map snd (list_of_pdevs (nlex_pdevs (snd X)))));\n     y \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> det3 0 y z \\<noteq> 0", "by (rule independent_pdevs_pairwise_non_coll, assumption+)\n    (auto simp: inl_def list_of_pdevs_nonzero)"], ["", "lemma in_set_inl_lex: \"x \\<in> set (inl xs) \\<Longrightarrow> lex x 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (inl xs) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex x 0", "by (auto simp: inl_def list_of_pdevs_def dest!: in_set_independent_pdevs_invariant_nlex\n    split: if_split_asm)"], ["", "interpretation ccw0: linorder_list \"ccw 0\" \"set (inl (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_list (ccw 0) (set (inl (snd X)))", "proof unfold_locales"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. a \\<in> set (inl (snd X)) \\<Longrightarrow> ccw 0 a a\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        ccw 0 a b; ccw 0 b a\\<rbrakk>\n       \\<Longrightarrow> a = b\n 4. \\<And>a b.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a b \\<or> ccw 0 b a", "fix a b c"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. a \\<in> set (inl (snd X)) \\<Longrightarrow> ccw 0 a a\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        ccw 0 a b; ccw 0 b a\\<rbrakk>\n       \\<Longrightarrow> a = b\n 4. \\<And>a b.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a b \\<or> ccw 0 b a", "show \"a \\<noteq> b \\<Longrightarrow> ccw 0 a b \\<or> ccw 0 b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> ccw 0 a b \\<or> ccw 0 b a", "by (metis UNIV_I ccw_self(1) nondegenerate)"], ["proof (state)\nthis:\n  a \\<noteq> b \\<Longrightarrow> ccw 0 a b \\<or> ccw 0 b a\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> set (inl (snd X)) \\<Longrightarrow> ccw 0 a a\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        ccw 0 a b; ccw 0 b a\\<rbrakk>\n       \\<Longrightarrow> a = b", "assume a: \"a \\<in> set (inl (snd X))\""], ["proof (state)\nthis:\n  a \\<in> set (inl (snd X))\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> set (inl (snd X)) \\<Longrightarrow> ccw 0 a a\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        ccw 0 a b; ccw 0 b a\\<rbrakk>\n       \\<Longrightarrow> a = b", "show \"ccw 0 a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw 0 a a", "by simp"], ["proof (state)\nthis:\n  ccw 0 a a\n\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        ccw 0 a b; ccw 0 b a\\<rbrakk>\n       \\<Longrightarrow> a = b", "assume b: \"b \\<in> set (inl (snd X))\""], ["proof (state)\nthis:\n  b \\<in> set (inl (snd X))\n\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        ccw 0 a b; ccw 0 b a\\<rbrakk>\n       \\<Longrightarrow> a = b", "show \"ccw 0 a b \\<Longrightarrow> ccw 0 b a \\<Longrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ccw 0 a b; ccw 0 b a\\<rbrakk> \\<Longrightarrow> a = b", "by (metis ccw_self(1) in_set_inl_nonzero mem_Collect_eq not_ccw_eq a b)"], ["proof (state)\nthis:\n  \\<lbrakk>ccw 0 a b; ccw 0 b a\\<rbrakk> \\<Longrightarrow> a = b\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c", "assume c: \"c \\<in> set (inl (snd X))\""], ["proof (state)\nthis:\n  c \\<in> set (inl (snd X))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c", "assume distinct: \"a \\<noteq> b\" \"b \\<noteq> c\" \"a \\<noteq> c\""], ["proof (state)\nthis:\n  a \\<noteq> b\n  b \\<noteq> c\n  a \\<noteq> c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c", "assume ab: \"ccw 0 a b\" and bc: \"ccw 0 b c\""], ["proof (state)\nthis:\n  ccw 0 a b\n  ccw 0 b c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n        c \\<in> set (inl (snd X)); a \\<noteq> b; b \\<noteq> c; a \\<noteq> c;\n        ccw 0 a b; ccw 0 b c\\<rbrakk>\n       \\<Longrightarrow> ccw 0 a c", "show \"ccw 0 a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw 0 a c", "using a b c ab bc"], ["proof (prove)\nusing this:\n  a \\<in> set (inl (snd X))\n  b \\<in> set (inl (snd X))\n  c \\<in> set (inl (snd X))\n  ccw 0 a b\n  ccw 0 b c\n\ngoal (1 subgoal):\n 1. ccw 0 a c", "proof (cases \"a = (0, 1)\" \"b = (0, 1)\" \"c = (0, 1)\"\n      rule: case_split[case_product case_split[case_product case_split]])"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 7. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 8. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "assume nu: \"a \\<noteq> (0, 1)\" \"b \\<noteq> (0, 1)\" \"c \\<noteq> (0, 1)\""], ["proof (state)\nthis:\n  a \\<noteq> (0, 1)\n  b \\<noteq> (0, 1)\n  c \\<noteq> (0, 1)\n\ngoal (8 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 7. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 8. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "have \"distinct5 a b c (0, 1) 0\" \"in5 UNIV a b c (0, 1) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct5 a b c (0, 1) 0 &&& in5 UNIV a b c (0, 1) 0", "using a b c distinct nu"], ["proof (prove)\nusing this:\n  a \\<in> set (inl (snd X))\n  b \\<in> set (inl (snd X))\n  c \\<in> set (inl (snd X))\n  a \\<noteq> b\n  b \\<noteq> c\n  a \\<noteq> c\n  a \\<noteq> (0, 1)\n  b \\<noteq> (0, 1)\n  c \\<noteq> (0, 1)\n\ngoal (1 subgoal):\n 1. distinct5 a b c (0, 1) 0 &&& in5 UNIV a b c (0, 1) 0", "by (simp_all add: in_set_inl_nonzero)"], ["proof (state)\nthis:\n  distinct5 a b c (0, 1) 0\n  in5 UNIV a b c (0, 1) 0\n\ngoal (8 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 7. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 8. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "moreover"], ["proof (state)\nthis:\n  distinct5 a b c (0, 1) 0\n  in5 UNIV a b c (0, 1) 0\n\ngoal (8 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 7. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 8. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "have \"ccw 0 (0, 1) a\" \"ccw 0 (0, 1) b\" \"ccw 0 (0, 1) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw 0 (0, 1) a &&& ccw 0 (0, 1) b &&& ccw 0 (0, 1) c", "by (auto intro!: nlex_ccw_left in_set_inl_lex a b c)"], ["proof (state)\nthis:\n  ccw 0 (0, 1) a\n  ccw 0 (0, 1) b\n  ccw 0 (0, 1) c\n\ngoal (8 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 7. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 8. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "ultimately"], ["proof (chain)\npicking this:\n  distinct5 a b c (0, 1) 0\n  in5 UNIV a b c (0, 1) 0\n  ccw 0 (0, 1) a\n  ccw 0 (0, 1) b\n  ccw 0 (0, 1) c", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct5 a b c (0, 1) 0\n  in5 UNIV a b c (0, 1) 0\n  ccw 0 (0, 1) a\n  ccw 0 (0, 1) b\n  ccw 0 (0, 1) c\n\ngoal (1 subgoal):\n 1. ccw 0 a c", "using ab bc"], ["proof (prove)\nusing this:\n  distinct5 a b c (0, 1) 0\n  in5 UNIV a b c (0, 1) 0\n  ccw 0 (0, 1) a\n  ccw 0 (0, 1) b\n  ccw 0 (0, 1) c\n  ccw 0 a b\n  ccw 0 b c\n\ngoal (1 subgoal):\n 1. ccw 0 a c", "by (rule ccw.transitive[where S=UNIV and s=\"(0, 1)\"])"], ["proof (state)\nthis:\n  ccw 0 a c\n\ngoal (7 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 7. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 7. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "assume \"a \\<noteq> (0, 1)\" \"b = (0, 1)\" \"c \\<noteq> (0, 1)\""], ["proof (state)\nthis:\n  a \\<noteq> (0, 1)\n  b = (0, 1)\n  c \\<noteq> (0, 1)\n\ngoal (7 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 7. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> (0, 1)\n  b = (0, 1)\n  c \\<noteq> (0, 1)\n\ngoal (1 subgoal):\n 1. ccw 0 a c", "using ccw_switch23 in_set_inl_lex inl_ncoll nlex_ccw_left a b ab"], ["proof (prove)\nusing this:\n  a \\<noteq> (0, 1)\n  b = (0, 1)\n  c \\<noteq> (0, 1)\n  det3 0 ?P ?Q \\<noteq> 0 \\<Longrightarrow>\n  (\\<not> ccw 0 ?Q ?P) = ccw 0 ?P ?Q\n  ?x \\<in> set (inl ?xs) \\<Longrightarrow>\n  Counterclockwise_2D_Arbitrary.lex ?x 0\n  \\<lbrakk>?y \\<in> set (inl (snd ?X)); ?z \\<in> set (inl (snd ?X));\n   ?y \\<noteq> ?z\\<rbrakk>\n  \\<Longrightarrow> det3 0 ?y ?z \\<noteq> 0\n  Counterclockwise_2D_Arbitrary.lex ?x 0 \\<Longrightarrow> ccw 0 (0, 1) ?x\n  a \\<in> set (inl (snd X))\n  b \\<in> set (inl (snd X))\n  ccw 0 a b\n\ngoal (1 subgoal):\n 1. ccw 0 a c", "by blast"], ["proof (state)\nthis:\n  ccw 0 a c\n\ngoal (6 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "assume \"a \\<noteq> (0, 1)\" \"b \\<noteq> (0, 1)\" \"c = (0, 1)\""], ["proof (state)\nthis:\n  a \\<noteq> (0, 1)\n  b \\<noteq> (0, 1)\n  c = (0, 1)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 6. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> (0, 1)\n  b \\<noteq> (0, 1)\n  c = (0, 1)\n\ngoal (1 subgoal):\n 1. ccw 0 a c", "using ccw_switch23 in_set_inl_lex inl_ncoll nlex_ccw_left b c bc"], ["proof (prove)\nusing this:\n  a \\<noteq> (0, 1)\n  b \\<noteq> (0, 1)\n  c = (0, 1)\n  det3 0 ?P ?Q \\<noteq> 0 \\<Longrightarrow>\n  (\\<not> ccw 0 ?Q ?P) = ccw 0 ?P ?Q\n  ?x \\<in> set (inl ?xs) \\<Longrightarrow>\n  Counterclockwise_2D_Arbitrary.lex ?x 0\n  \\<lbrakk>?y \\<in> set (inl (snd ?X)); ?z \\<in> set (inl (snd ?X));\n   ?y \\<noteq> ?z\\<rbrakk>\n  \\<Longrightarrow> det3 0 ?y ?z \\<noteq> 0\n  Counterclockwise_2D_Arbitrary.lex ?x 0 \\<Longrightarrow> ccw 0 (0, 1) ?x\n  b \\<in> set (inl (snd X))\n  c \\<in> set (inl (snd X))\n  ccw 0 b c\n\ngoal (1 subgoal):\n 1. ccw 0 a c", "by blast"], ["proof (state)\nthis:\n  ccw 0 a c\n\ngoal (5 subgoals):\n 1. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 2. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b = (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 3. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 4. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a = (0, 1);\n     b \\<noteq> (0, 1); c \\<noteq> (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c\n 5. \\<lbrakk>a \\<in> set (inl (snd X)); b \\<in> set (inl (snd X));\n     c \\<in> set (inl (snd X)); ccw 0 a b; ccw 0 b c; a \\<noteq> (0, 1);\n     b = (0, 1); c = (0, 1)\\<rbrakk>\n    \\<Longrightarrow> ccw 0 a c", "qed (auto simp add: nlex_ccw_left in_set_inl_lex)"], ["proof (state)\nthis:\n  ccw 0 a c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_inl: \"ccw.sortedP 0 (ccw.selsort 0 (inl (snd X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw.sortedP 0 (ccw.selsort 0 (inl (snd X)))", "by (rule ccw0.sortedP_selsort) auto"], ["", "lemma sorted_scaled_inl: \"ccw.sortedP 0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw.sortedP 0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))", "using sorted_inl"], ["proof (prove)\nusing this:\n  ccw.sortedP 0 (ccw.selsort 0 (inl (snd ?X)))\n\ngoal (1 subgoal):\n 1. ccw.sortedP 0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))", "by (rule ccw_sorted_scaleR) simp"], ["", "lemma distinct_selsort_inl: \"distinct (ccw.selsort 0 (inl (snd X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ccw.selsort 0 (inl (snd X)))", "by simp"], ["", "lemma distinct_map_scaleRI:\n  fixes xs::\"'a::real_vector list\"\n  shows \"distinct xs \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> distinct (map ((*\\<^sub>R) c) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> distinct (map ((*\\<^sub>R) c) xs)", "by (induct xs) auto"], ["", "lemma distinct_scaled_inl: \"distinct (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))", "using distinct_selsort_inl"], ["proof (prove)\nusing this:\n  distinct (ccw.selsort 0 (inl (snd ?X)))\n\ngoal (1 subgoal):\n 1. distinct (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))", "by (rule distinct_map_scaleRI) simp"], ["", "lemma ccw'_sortedP_scaled_inl:\n  \"ccw'.sortedP 0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))", "using ccw_sorted_implies_ccw'_sortedP"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>y z.\n              \\<lbrakk>y \\<in> set ?Ps; z \\<in> set ?Ps;\n               y \\<noteq> z\\<rbrakk>\n              \\<Longrightarrow> det3 0 y z \\<noteq> 0;\n   ccw.sortedP 0 ?Ps; distinct ?Ps\\<rbrakk>\n  \\<Longrightarrow> ccw'.sortedP 0 ?Ps\n\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))", "by (rule ccw'_sorted_scaleR) (auto simp: sorted_inl inl_ncoll)"], ["", "lemma pdevs_val_pdevs_of_list_inl2E:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  obtains e' where \"pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X))\" \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?l = \"map snd (list_of_pdevs (nlex_pdevs X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have l: \"list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0) ?l\"\n    \"list_all (\\<lambda>x. x \\<noteq> 0) (map snd (list_of_pdevs (nlex_pdevs X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n     (map snd (list_of_pdevs (nlex_pdevs X))) &&&\n    list_all (\\<lambda>x. x \\<noteq> 0)\n     (map snd (list_of_pdevs (nlex_pdevs X)))", "by (auto simp: list_all_iff list_of_pdevs_def)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. Counterclockwise_2D_Arbitrary.lex x 0)\n   (map snd (list_of_pdevs (nlex_pdevs X)))\n  list_all (\\<lambda>x. x \\<noteq> 0)\n   (map snd (list_of_pdevs (nlex_pdevs X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_nlex_pdevs[OF assms(1)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>uminus ` {- 1..1} = {- 1..1};\n   \\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n       pdevs_val e ?x = pdevs_val e' (nlex_pdevs ?x)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain e' where \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\" \"pdevs_val e X = pdevs_val e' (nlex_pdevs X)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>uminus ` {- 1..1} = {- 1..1};\n   \\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n       pdevs_val e ?x = pdevs_val e' (nlex_pdevs ?x)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n         pdevs_val e X = pdevs_val e' (nlex_pdevs X)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  pdevs_val e X = pdevs_val e' (nlex_pdevs X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e X = pdevs_val e' (nlex_pdevs X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e X = pdevs_val e' (nlex_pdevs X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_of_list_of_pdevs2[OF \\<open>e' \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>e'a.\n      \\<lbrakk>pdevs_val e' ?X =\n               pdevs_val e'a (pdevs_of_list (map snd (list_of_pdevs ?X)));\n       e'a \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e'' where \"e'' \\<in> UNIV \\<rightarrow> {-1 .. 1}\" \"\\<dots> = pdevs_val e'' (pdevs_of_list ?l)\""], ["proof (prove)\nusing this:\n  (\\<And>e'a.\n      \\<lbrakk>pdevs_val e' ?X =\n               pdevs_val e'a (pdevs_of_list (map snd (list_of_pdevs ?X)));\n       e'a \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>e'' \\<in> UNIV \\<rightarrow> {- 1..1};\n         pdevs_val e' (nlex_pdevs X) =\n         pdevs_val e''\n          (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X))))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  e'' \\<in> UNIV \\<rightarrow> {- 1..1}\n  pdevs_val e' (nlex_pdevs X) =\n  pdevs_val e'' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e' (nlex_pdevs X) =\n  pdevs_val e'' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e' (nlex_pdevs X) =\n  pdevs_val e'' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_independent_pdevs[OF l \\<open>e'' \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n     pdevs_val e''\n      (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n     pdevs_val e'\n      (pdevs_of_list\n        (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X)))))", "obtain e'''\n  where \"e''' \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n    and \"\\<dots> = pdevs_val e''' (pdevs_of_list (independent_pdevs ?l))\""], ["proof (prove)\nusing this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n     pdevs_val e''\n      (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n     pdevs_val e'\n      (pdevs_of_list\n        (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'''.\n        \\<lbrakk>e''' \\<in> UNIV \\<rightarrow> {- 1..1};\n         pdevs_val e''\n          (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n         pdevs_val e'''\n          (pdevs_of_list\n            (independent_pdevs\n              (map snd (list_of_pdevs (nlex_pdevs X)))))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  e''' \\<in> UNIV \\<rightarrow> {- 1..1}\n  pdevs_val e'' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n  pdevs_val e'''\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e'' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n  pdevs_val e'''\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e'' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n  pdevs_val e'''\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = pdevs_val e''' (pdevs_of_list (inl X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e'''\n     (pdevs_of_list\n       (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X))))) =\n    pdevs_val e''' (pdevs_of_list (inl X))", "by (simp add: inl_def)"], ["proof (state)\nthis:\n  pdevs_val e'''\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X))))) =\n  pdevs_val e''' (pdevs_of_list (inl X))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e X = pdevs_val e''' (pdevs_of_list (inl X))", "have \"pdevs_val e X = pdevs_val e''' (pdevs_of_list (inl X))\""], ["proof (prove)\nusing this:\n  pdevs_val e X = pdevs_val e''' (pdevs_of_list (inl X))\n\ngoal (1 subgoal):\n 1. pdevs_val e X = pdevs_val e''' (pdevs_of_list (inl X))", "."], ["proof (state)\nthis:\n  pdevs_val e X = pdevs_val e''' (pdevs_of_list (inl X))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X = pdevs_val e' (pdevs_of_list (inl X));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  pdevs_val e X = pdevs_val e''' (pdevs_of_list (inl X))\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>e''' \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  pdevs_val e X = pdevs_val e''' (pdevs_of_list (inl X))\n  e''' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_val_pdevs_of_list_inlE:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\" \"uminus ` I = I\" \"0 \\<in> I\"\n  obtains e' where \"pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X\" \"e' \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?l = \"map snd (list_of_pdevs (nlex_pdevs X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e (pdevs_of_list (independent_pdevs ?l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (inl X)) =\n    pdevs_val e\n     (pdevs_of_list\n       (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X)))))", "by (simp add: inl_def)"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (inl X)) =\n  pdevs_val e\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (inl X)) =\n  pdevs_val e\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_independent_pdevs2[OF \\<open>e \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val e (pdevs_of_list (independent_pdevs ?xs)) =\n     pdevs_val e' (pdevs_of_list ?xs)", "obtain e'\n  where \"pdevs_val e (pdevs_of_list (independent_pdevs ?l)) = pdevs_val e' (pdevs_of_list ?l)\"\n    and \"e' \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\nusing this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val e (pdevs_of_list (independent_pdevs ?xs)) =\n     pdevs_val e' (pdevs_of_list ?xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e\n                  (pdevs_of_list\n                    (independent_pdevs\n                      (map snd (list_of_pdevs (nlex_pdevs X))))) =\n                 pdevs_val e'\n                  (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X))));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pdevs_val e\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X))))) =\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X))))\n  e' \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val e\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X))))) =\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs X))))) =\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_of_list_of_pdevs[OF \\<open>e' \\<in> _\\<close> \\<open>0 \\<in> I\\<close>, of \"nlex_pdevs X\"]"], ["proof (chain)\npicking this:\n  (\\<And>e'a.\n      \\<lbrakk>pdevs_val e'\n                (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n               pdevs_val e'a (nlex_pdevs X);\n       e'a \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e'' where \"pdevs_val e' (pdevs_of_list ?l) = pdevs_val e'' (nlex_pdevs X)\"\n    and \"e'' \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\nusing this:\n  (\\<And>e'a.\n      \\<lbrakk>pdevs_val e'\n                (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n               pdevs_val e'a (nlex_pdevs X);\n       e'a \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>pdevs_val e'\n                  (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n                 pdevs_val e'' (nlex_pdevs X);\n         e'' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n  pdevs_val e'' (nlex_pdevs X)\n  e'' \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n  pdevs_val e'' (nlex_pdevs X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs X)))) =\n  pdevs_val e'' (nlex_pdevs X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_nlex_pdevs2[OF \\<open>e'' \\<in> _\\<close> \\<open>_ = I\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n       pdevs_val e'' (nlex_pdevs ?x) = pdevs_val e' ?x\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e''' where \"pdevs_val e'' (nlex_pdevs X) = pdevs_val e''' X\" \"e''' \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\nusing this:\n  (\\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n       pdevs_val e'' (nlex_pdevs ?x) = pdevs_val e' ?x\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e'''.\n        \\<lbrakk>pdevs_val e'' (nlex_pdevs X) = pdevs_val e''' X;\n         e''' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  pdevs_val e'' (nlex_pdevs X) = pdevs_val e''' X\n  e''' \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val e'' (nlex_pdevs X) = pdevs_val e''' X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e''' X", "have \"pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e''' X\""], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e''' X\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e''' X", "."], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e''' X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e''' X\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>e''' \\<in> UNIV \\<rightarrow> I\\<close>"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (inl X)) = pdevs_val e''' X\n  e''' \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_nlex_eq_sum_list_inl:\n  \"sum_list (map snd (list_of_pdevs (nlex_pdevs X))) = sum_list (inl X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map snd (list_of_pdevs (nlex_pdevs X))) = sum_list (inl X)", "by (auto simp: inl_def sum_list_list_of_pdevs sum_list_independent_pdevs)"], ["", "lemma Affine_inl: \"Affine (fst X, pdevs_of_list (inl (snd X))) = Affine X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Affine (fst X, pdevs_of_list (inl (snd X))) = Affine X", "by (auto simp: Affine_def valuate_def aform_val_def\n    elim: pdevs_val_pdevs_of_list_inlE[of _ _ \"snd X\"] pdevs_val_pdevs_of_list_inl2E[of _ \"snd X\"])"], ["", "subsection \\<open>Half Segments\\<close>"], ["", "definition half_segments_of_aform::\"point aform \\<Rightarrow> (point*point) list\"\n  where \"half_segments_of_aform X =\n    (let\n      x0 = lowest_vertex (fst X, nlex_pdevs (snd X))\n    in\n      polychain_of x0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\""], ["", "lemma subsequent_half_segments:\n  fixes X\n  assumes \"Suc i < length (half_segments_of_aform X)\"\n  shows \"snd (half_segments_of_aform X ! i) = fst (half_segments_of_aform X ! Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (half_segments_of_aform X ! i) =\n    fst (half_segments_of_aform X ! Suc i)", "using assms"], ["proof (prove)\nusing this:\n  Suc i < length (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. snd (half_segments_of_aform X ! i) =\n    fst (half_segments_of_aform X ! Suc i)", "by (cases i) (auto simp: half_segments_of_aform_def Let_def polychain_of_subsequent_eq)"], ["", "lemma polychain_half_segments_of_aform: \"polychain (half_segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polychain (half_segments_of_aform X)", "by (auto simp: subsequent_half_segments intro!: polychainI)"], ["", "lemma fst_half_segments:\n  \"half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    fst (half_segments_of_aform X ! 0) = lowest_vertex (fst X, nlex_pdevs (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    fst (half_segments_of_aform X ! 0) =\n    lowest_vertex (fst X, nlex_pdevs (snd X))", "by (auto simp: half_segments_of_aform_def Let_def o_def split_beta')"], ["", "lemma nlex_half_segments_of_aform: \"(a, b) \\<in> set (half_segments_of_aform X) \\<Longrightarrow> lex b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set (half_segments_of_aform X) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex b a", "by (auto simp: half_segments_of_aform_def prod_eq_iff lex_def\n    dest!: in_set_polychain_ofD in_set_inl_lex)"], ["", "lemma ccw_half_segments_of_aform_all:\n  assumes cd: \"(c, d) \\<in> set (half_segments_of_aform X)\"\n  shows \"list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d) (half_segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d)\n     (half_segments_of_aform X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d)\n     (half_segments_of_aform X)", "have\n    \"list_all (\\<lambda>(xi, xj). ccw xi xj (fst (c, d)) \\<and> ccw xi xj (snd (c, d)))\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        ((map ((*\\<^sub>R) 2) (linorder_list0.selsort (ccw 0) (inl (snd X))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw xi xj (fst (c, d)) \\<and> ccw xi xj (snd (c, d)))\n     (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n       (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))", "using ccw'_sortedP_scaled_inl cd[unfolded half_segments_of_aform_def Let_def]"], ["proof (prove)\nusing this:\n  ccw'.sortedP 0 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd ?X))))\n  (c, d)\n  \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(xi, xj).\n         ccw xi xj (fst (c, d)) \\<and> ccw xi xj (snd (c, d)))\n     (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n       (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))", "by (rule polychain_of_ccw_conjunction)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(xi, xj). ccw xi xj (fst (c, d)) \\<and> ccw xi xj (snd (c, d)))\n   (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d)\n     (half_segments_of_aform X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(xi, xj). ccw xi xj (fst (c, d)) \\<and> ccw xi xj (snd (c, d)))\n   (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d)\n     (half_segments_of_aform X)", "unfolding half_segments_of_aform_def[unfolded Let_def, symmetric] fst_conv snd_conv"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d)\n   (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d)\n     (half_segments_of_aform X)", "."], ["proof (state)\nthis:\n  list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d)\n   (half_segments_of_aform X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccw_half_segments_of_aform:\n  assumes ij: \"(xi, xj) \\<in> set (half_segments_of_aform X)\"\n  assumes c: \"(c, d) \\<in> set (half_segments_of_aform X)\"\n  shows \"ccw xi xj c\" \"ccw xi xj d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw xi xj c &&& ccw xi xj d", "using ccw_half_segments_of_aform_all[OF c] ij"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(xi, xj). ccw xi xj c \\<and> ccw xi xj d)\n   (half_segments_of_aform X)\n  (xi, xj) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. ccw xi xj c &&& ccw xi xj d", "by (auto simp add: list_all_iff)"], ["", "lemma half_segments_of_aform1:\n  assumes ch: \"x \\<in> convex hull set (map fst (half_segments_of_aform X))\"\n  assumes ab: \"(a, b) \\<in> set (half_segments_of_aform X)\"\n  shows \"ccw a b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw a b x", "using finite_set _ ch"], ["proof (prove)\nusing this:\n  finite (set ?xs)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  x \\<in> convex hull set (map fst (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. ccw a b x", "proof (rule ccw.convex_hull)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set (map fst (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw a b c\n 2. Counterclockwise_2D_Arbitrary.lex b a", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set (map fst (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw a b c\n 2. Counterclockwise_2D_Arbitrary.lex b a", "assume \"c \\<in> set (map fst (half_segments_of_aform X))\""], ["proof (state)\nthis:\n  c \\<in> set (map fst (half_segments_of_aform X))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set (map fst (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw a b c\n 2. Counterclockwise_2D_Arbitrary.lex b a", "then"], ["proof (chain)\npicking this:\n  c \\<in> set (map fst (half_segments_of_aform X))", "obtain d where \"(c, d) \\<in> set (half_segments_of_aform X)\""], ["proof (prove)\nusing this:\n  c \\<in> set (map fst (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        (c, d) \\<in> set (half_segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (c, d) \\<in> set (half_segments_of_aform X)\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set (map fst (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw a b c\n 2. Counterclockwise_2D_Arbitrary.lex b a", "with ab"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set (half_segments_of_aform X)\n  (c, d) \\<in> set (half_segments_of_aform X)", "show \"ccw a b c\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> set (half_segments_of_aform X)\n  (c, d) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. ccw a b c", "by (rule ccw_half_segments_of_aform(1))"], ["proof (state)\nthis:\n  ccw a b c\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex b a", "qed (insert ab, simp add: nlex_half_segments_of_aform)"], ["", "lemma half_segments_of_aform2:\n  assumes ch: \"x \\<in> convex hull set (map snd (half_segments_of_aform X))\"\n  assumes ab: \"(a, b) \\<in> set (half_segments_of_aform X)\"\n  shows \"ccw a b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw a b x", "using finite_set _ ch"], ["proof (prove)\nusing this:\n  finite (set ?xs)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  x \\<in> convex hull set (map snd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. ccw a b x", "proof (rule ccw.convex_hull)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set (map snd (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw a b c\n 2. Counterclockwise_2D_Arbitrary.lex b a", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set (map snd (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw a b c\n 2. Counterclockwise_2D_Arbitrary.lex b a", "assume \"d \\<in> set (map snd (half_segments_of_aform X))\""], ["proof (state)\nthis:\n  d \\<in> set (map snd (half_segments_of_aform X))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set (map snd (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw a b c\n 2. Counterclockwise_2D_Arbitrary.lex b a", "then"], ["proof (chain)\npicking this:\n  d \\<in> set (map snd (half_segments_of_aform X))", "obtain c where \"(c, d) \\<in> set (half_segments_of_aform X)\""], ["proof (prove)\nusing this:\n  d \\<in> set (map snd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (c, d) \\<in> set (half_segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (c, d) \\<in> set (half_segments_of_aform X)\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set (map snd (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw a b c\n 2. Counterclockwise_2D_Arbitrary.lex b a", "with ab"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set (half_segments_of_aform X)\n  (c, d) \\<in> set (half_segments_of_aform X)", "show \"ccw a b d\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> set (half_segments_of_aform X)\n  (c, d) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. ccw a b d", "by (rule ccw_half_segments_of_aform(2))"], ["proof (state)\nthis:\n  ccw a b d\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex b a", "qed (insert ab, simp add: nlex_half_segments_of_aform)"], ["", "lemma\n  in_set_half_segments_of_aform_aform_valE:\n  assumes \"(x2, y2) \\<in> set (half_segments_of_aform X)\"\n  obtains e where \"y2 = aform_val e X\" \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  (x2, y2) \\<in> set (half_segments_of_aform X)", "obtain d where\n    \"y2 = lowest_vertex (fst X, nlex_pdevs (snd X)) +\n      sum_list (take (Suc d) (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\""], ["proof (prove)\nusing this:\n  (x2, y2) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        y2 =\n        lowest_vertex (fst X, nlex_pdevs (snd X)) +\n        sum_list\n         (take (Suc d)\n           (map ((*\\<^sub>R) 2)\n             (ccw.selsort 0 (inl (snd X))))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: half_segments_of_aform_def elim!: in_set_polychain_of_imp_sum_list)"], ["proof (state)\nthis:\n  y2 =\n  lowest_vertex (fst X, nlex_pdevs (snd X)) +\n  sum_list\n   (take (Suc d) (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  y2 =\n  lowest_vertex (fst X, nlex_pdevs (snd X)) +\n  sum_list\n   (take (Suc d) (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"lowest_vertex (fst X, nlex_pdevs (snd X)) =\n      fst X - sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowest_vertex (fst X, nlex_pdevs (snd X)) =\n    fst X - sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))", "by (simp add: lowest_vertex_def)"], ["proof (state)\nthis:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) =\n  fst X - sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) =\n  fst X - sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) =\n      pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) =\n    pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X))", "by (auto simp: pdevs_val_sum_list)"], ["proof (state)\nthis:\n  sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) =\n  pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  sum_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))) =\n  pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"sum_list (take (Suc d) (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) =\n      pdevs_val (\\<lambda>i. if i \\<le> d then 2 else 0) (pdevs_of_list (ccw.selsort 0 (inl (snd X))))\"\n    (is \"_ = pdevs_val ?e _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (take (Suc d) (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) =\n    pdevs_val (\\<lambda>i. if i \\<le> d then 2 else 0)\n     (pdevs_of_list (ccw.selsort 0 (inl (snd X))))", "by (subst sum_list_take_pdevs_val_eq)\n      (auto simp: pdevs_val_sum if_distrib pdevs_apply_pdevs_of_list\n        degree_pdevs_of_list_scaleR intro!: sum.cong )"], ["proof (state)\nthis:\n  sum_list\n   (take (Suc d) (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) =\n  pdevs_val (\\<lambda>i. if i \\<le> d then 2 else 0)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X))))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  sum_list\n   (take (Suc d) (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) =\n  pdevs_val (\\<lambda>i. if i \\<le> d then 2 else 0)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X))))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain e'' where \"\\<dots> = pdevs_val e'' (pdevs_of_list (inl (snd X)))\" \"e'' \\<in> UNIV \\<rightarrow> {0..2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>pdevs_val (\\<lambda>i. if i \\<le> d then 2 else 0)\n                  (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n                 pdevs_val e'' (pdevs_of_list (inl (snd X)));\n         e'' \\<in> UNIV \\<rightarrow> {0..2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: pdevs_val_selsort_ccw2[of \"inl (snd X)\" ?e \"{0 .. 2}\"])"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>i. if i \\<le> d then 2 else 0)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n  pdevs_val e'' (pdevs_of_list (inl (snd X)))\n  e'' \\<in> UNIV \\<rightarrow> {0..2}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>i. if i \\<le> d then 2 else 0)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n  pdevs_val e'' (pdevs_of_list (inl (snd X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>i. if i \\<le> d then 2 else 0)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n  pdevs_val e'' (pdevs_of_list (inl (snd X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note inl_def"], ["proof (state)\nthis:\n  inl ?p = independent_pdevs (map snd (list_of_pdevs (nlex_pdevs ?p)))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  inl ?p = independent_pdevs (map snd (list_of_pdevs (nlex_pdevs ?p)))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?l = \"map snd (list_of_pdevs (nlex_pdevs (snd X)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_independent_pdevs2[OF \\<open>e'' \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {0..2} \\<and>\n     pdevs_val e'' (pdevs_of_list (independent_pdevs ?xs)) =\n     pdevs_val e' (pdevs_of_list ?xs)", "obtain e'''\n  where \"pdevs_val e'' (pdevs_of_list (independent_pdevs ?l)) = pdevs_val e''' (pdevs_of_list ?l)\"\n    and \"e''' \\<in> UNIV \\<rightarrow> {0..2}\""], ["proof (prove)\nusing this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {0..2} \\<and>\n     pdevs_val e'' (pdevs_of_list (independent_pdevs ?xs)) =\n     pdevs_val e' (pdevs_of_list ?xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'''.\n        \\<lbrakk>pdevs_val e''\n                  (pdevs_of_list\n                    (independent_pdevs\n                      (map snd (list_of_pdevs (nlex_pdevs (snd X)))))) =\n                 pdevs_val e'''\n                  (pdevs_of_list\n                    (map snd (list_of_pdevs (nlex_pdevs (snd X)))));\n         e''' \\<in> UNIV \\<rightarrow> {0..2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pdevs_val e''\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))))) =\n  pdevs_val e'''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))))\n  e''' \\<in> UNIV \\<rightarrow> {0..2}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val e''\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))))) =\n  pdevs_val e'''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e''\n   (pdevs_of_list\n     (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))))) =\n  pdevs_val e'''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"0 \\<in> {0 .. 2::real}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {0..2}", "by simp"], ["proof (state)\nthis:\n  0 \\<in> {0..2}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_of_list_of_pdevs[OF \\<open>e''' \\<in> _\\<close> this, of \"nlex_pdevs (snd X)\"]"], ["proof (chain)\npicking this:\n  (\\<And>e'.\n      \\<lbrakk>pdevs_val e'''\n                (pdevs_of_list\n                  (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n               pdevs_val e' (nlex_pdevs (snd X));\n       e' \\<in> UNIV \\<rightarrow> {0..2}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e'''' where \"pdevs_val e''' (pdevs_of_list ?l) = pdevs_val e'''' (nlex_pdevs (snd X))\"\n    and \"e'''' \\<in> UNIV \\<rightarrow> {0 .. 2}\""], ["proof (prove)\nusing this:\n  (\\<And>e'.\n      \\<lbrakk>pdevs_val e'''\n                (pdevs_of_list\n                  (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n               pdevs_val e' (nlex_pdevs (snd X));\n       e' \\<in> UNIV \\<rightarrow> {0..2}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e''''.\n        \\<lbrakk>pdevs_val e'''\n                  (pdevs_of_list\n                    (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n                 pdevs_val e'''' (nlex_pdevs (snd X));\n         e'''' \\<in> UNIV \\<rightarrow> {0..2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  pdevs_val e'''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n  pdevs_val e'''' (nlex_pdevs (snd X))\n  e'''' \\<in> UNIV \\<rightarrow> {0..2}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val e'''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n  pdevs_val e'''' (nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  y2 =\n  fst X - pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)) +\n  pdevs_val e'''' (nlex_pdevs (snd X))", "have\n    \"y2 = fst X + (pdevs_val e'''' (nlex_pdevs (snd X)) - pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)))\""], ["proof (prove)\nusing this:\n  y2 =\n  fst X - pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)) +\n  pdevs_val e'''' (nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. y2 =\n    fst X +\n    (pdevs_val e'''' (nlex_pdevs (snd X)) -\n     pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)))", "by simp"], ["proof (state)\nthis:\n  y2 =\n  fst X +\n  (pdevs_val e'''' (nlex_pdevs (snd X)) -\n   pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  y2 =\n  fst X +\n  (pdevs_val e'''' (nlex_pdevs (snd X)) -\n   pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"pdevs_val e'''' (nlex_pdevs (snd X)) - pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)) =\n      pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e'''' (nlex_pdevs (snd X)) -\n    pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)) =\n    pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs (snd X))", "by (simp add: pdevs_val_minus)"], ["proof (state)\nthis:\n  pdevs_val e'''' (nlex_pdevs (snd X)) -\n  pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)) =\n  pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e'''' (nlex_pdevs (snd X)) -\n  pdevs_val (\\<lambda>_. 1) (nlex_pdevs (snd X)) =\n  pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<lambda>i. e'''' i - 1) \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. e'''' i - 1) \\<in> UNIV \\<rightarrow> {- 1..1}", "using \\<open>e'''' \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  e'''' \\<in> UNIV \\<rightarrow> {0..2}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. e'''' i - 1) \\<in> UNIV \\<rightarrow> {- 1..1}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>i. e'''' i - 1) \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_nlex_pdevs2[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>uminus ` {- 1..1} = {- 1..1};\n   \\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n       pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs ?x) =\n       pdevs_val e' ?x\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain f where \"f \\<in> UNIV \\<rightarrow>  {-1 .. 1}\"\n    and \"pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs (snd X)) = pdevs_val f (snd X)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>uminus ` {- 1..1} = {- 1..1};\n   \\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n       pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs ?x) =\n       pdevs_val e' ?x\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> UNIV \\<rightarrow> {- 1..1};\n         pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs (snd X)) =\n         pdevs_val f (snd X)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n  pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs (snd X)) =\n  pdevs_val f (snd X)\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>i. e'''' i - 1) (nlex_pdevs (snd X)) =\n  pdevs_val f (snd X)\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  y2 = fst X + pdevs_val f (snd X)", "have \"y2 = aform_val f X\""], ["proof (prove)\nusing this:\n  y2 = fst X + pdevs_val f (snd X)\n\ngoal (1 subgoal):\n 1. y2 = aform_val f X", "by (simp add: aform_val_def)"], ["proof (state)\nthis:\n  y2 = aform_val f X\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  y2 = aform_val f X\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>f \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  y2 = aform_val f X\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fst_hd_half_segments_of_aform:\n  assumes \"half_segments_of_aform X \\<noteq> []\"\n  shows \"fst (hd (half_segments_of_aform X)) = lowest_vertex (fst X, (nlex_pdevs (snd X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (hd (half_segments_of_aform X)) =\n    lowest_vertex (fst X, nlex_pdevs (snd X))", "using assms"], ["proof (prove)\nusing this:\n  half_segments_of_aform X \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst (hd (half_segments_of_aform X)) =\n    lowest_vertex (fst X, nlex_pdevs (snd X))", "by (auto simp: half_segments_of_aform_def Let_def fst_hd_polychain_of)"], ["", "lemma\n  \"linorder_list0.sortedP (ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))))\n    (map snd (half_segments_of_aform X))\"\n  (is \"linorder_list0.sortedP (ccw' ?x0) ?ms\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map snd (half_segments_of_aform X))", "unfolding half_segments_of_aform_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map snd\n       (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n         (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))", "by (rule ccw'_sortedP_polychain_of_snd) (rule ccw'_sortedP_scaled_inl)"], ["", "lemma rev_zip: \"length xs = length ys \\<Longrightarrow> rev (zip xs ys) = zip (rev xs) (rev ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    rev (zip xs ys) = zip (rev xs) (rev ys)", "by (induct xs ys rule: list_induct2) auto"], ["", "lemma zip_upt_self_aux: \"zip [0..<length xs] xs = map (\\<lambda>i. (i, xs ! i)) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip [0..<length xs] xs = map (\\<lambda>i. (i, xs ! i)) [0..<length xs]", "by (auto intro!: nth_equalityI)"], ["", "lemma half_segments_of_aform_strict:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"seg \\<in> set (half_segments_of_aform X)\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"ccw' (fst seg) (snd seg) (aform_val e X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (fst seg) (snd seg) (aform_val e X)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  seg \\<in> set (half_segments_of_aform X)\n  length (half_segments_of_aform X) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. ccw' (fst seg) (snd seg) (aform_val e X)", "unfolding half_segments_of_aform_def Let_def"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  seg\n  \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n  length\n   (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n  1\n\ngoal (1 subgoal):\n 1. ccw' (fst seg) (snd seg) (aform_val e X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "have len: \"length (map ((*\\<^sub>R) 2) (linorder_list0.selsort (ccw 0) (inl (snd X)))) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))) \\<noteq> 1", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  seg \\<in> set (half_segments_of_aform X)\n  length (half_segments_of_aform X) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. length (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))) \\<noteq> 1", "by (auto simp: half_segments_of_aform_def)"], ["proof (state)\nthis:\n  length (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "have \"aform_val e X = fst X + pdevs_val e (snd X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e X = fst X + pdevs_val e (snd X)", "by (simp add: aform_val_def)"], ["proof (state)\nthis:\n  aform_val e X = fst X + pdevs_val e (snd X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "also"], ["proof (state)\nthis:\n  aform_val e X = fst X + pdevs_val e (snd X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "obtain e' where \"e' \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n    \"pdevs_val e (snd X) = pdevs_val e' (nlex_pdevs (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1<..<1};\n         pdevs_val e (snd X) = pdevs_val e' (nlex_pdevs (snd X))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pdevs_val_nlex_pdevs[OF \\<open>e \\<in> _\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>uminus ` {- 1<..<1} = {- 1<..<1};\n   \\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1<..<1};\n       pdevs_val e ?x = pdevs_val e' (nlex_pdevs ?x)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1<..<1};\n         pdevs_val e (snd X) = pdevs_val e' (nlex_pdevs (snd X))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  pdevs_val e (snd X) = pdevs_val e' (nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e (snd X) = pdevs_val e' (nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "also"], ["proof (state)\nthis:\n  pdevs_val e (snd X) = pdevs_val e' (nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "obtain e'' where \"e'' \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n    \"\\<dots> = pdevs_val e'' (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>e'' \\<in> UNIV \\<rightarrow> {- 1<..<1};\n         pdevs_val e' (nlex_pdevs (snd X)) =\n         pdevs_val e''\n          (pdevs_of_list\n            (map snd (list_of_pdevs (nlex_pdevs (snd X)))))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis pdevs_val_of_list_of_pdevs2[OF \\<open>e' \\<in> _\\<close>])"], ["proof (state)\nthis:\n  e'' \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  pdevs_val e' (nlex_pdevs (snd X)) =\n  pdevs_val e''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e' (nlex_pdevs (snd X)) =\n  pdevs_val e''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "also"], ["proof (state)\nthis:\n  pdevs_val e' (nlex_pdevs (snd X)) =\n  pdevs_val e''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X)))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "obtain e''' where \"e''' \\<in> UNIV \\<rightarrow> {-1 <..< 1}\" \"\\<dots> = pdevs_val e''' (pdevs_of_list (inl (snd X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'''.\n        \\<lbrakk>e''' \\<in> UNIV \\<rightarrow> {- 1<..<1};\n         pdevs_val e''\n          (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n         pdevs_val e''' (pdevs_of_list (inl (snd X)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding inl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'''.\n        \\<lbrakk>e''' \\<in> UNIV \\<rightarrow> {- 1<..<1};\n         pdevs_val e''\n          (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n         pdevs_val e'''\n          (pdevs_of_list\n            (independent_pdevs\n              (map snd (list_of_pdevs (nlex_pdevs (snd X))))))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using\n      pdevs_val_independent_pdevs_strict[OF list_all_list_of_pdevsI,\n        OF lex_nlex_pdevs list_of_pdevs_all_nonzero \\<open>e'' \\<in> _\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> {- 1<..<1} \\<and>\n     pdevs_val e''\n      (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs ?x4)))) =\n     pdevs_val e'\n      (pdevs_of_list\n        (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs ?x4)))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'''.\n        \\<lbrakk>e''' \\<in> UNIV \\<rightarrow> {- 1<..<1};\n         pdevs_val e''\n          (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n         pdevs_val e'''\n          (pdevs_of_list\n            (independent_pdevs\n              (map snd (list_of_pdevs (nlex_pdevs (snd X))))))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  e''' \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  pdevs_val e''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n  pdevs_val e''' (pdevs_of_list (inl (snd X)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n  pdevs_val e''' (pdevs_of_list (inl (snd X)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "also"], ["proof (state)\nthis:\n  pdevs_val e''\n   (pdevs_of_list (map snd (list_of_pdevs (nlex_pdevs (snd X))))) =\n  pdevs_val e''' (pdevs_of_list (inl (snd X)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "from pdevs_val_selsort_ccw[OF distinct_inl \\<open>e''' \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1<..<1};\n       pdevs_val e''' (pdevs_of_list (inl (snd ?X1))) =\n       pdevs_val e' (pdevs_of_list (ccw.selsort 0 (inl (snd ?X1))))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain f where \"f \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n    \"\\<dots> = pdevs_val f (pdevs_of_list (linorder_list0.selsort (ccw 0) (inl (snd X))))\"\n    (is \"_ = pdevs_val _ (pdevs_of_list ?sl)\")"], ["proof (prove)\nusing this:\n  (\\<And>e'.\n      \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1<..<1};\n       pdevs_val e''' (pdevs_of_list (inl (snd ?X1))) =\n       pdevs_val e' (pdevs_of_list (ccw.selsort 0 (inl (snd ?X1))))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> UNIV \\<rightarrow> {- 1<..<1};\n         pdevs_val e''' (pdevs_of_list (inl (snd X))) =\n         pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X))))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  f \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  pdevs_val e''' (pdevs_of_list (inl (snd X))) =\n  pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e''' (pdevs_of_list (inl (snd X))) =\n  pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "also"], ["proof (state)\nthis:\n  pdevs_val e''' (pdevs_of_list (inl (snd X))) =\n  pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "have \"\\<dots> = pdevs_val (\\<lambda>i. f i + 1) (pdevs_of_list ?sl) +\n      lowest_vertex (fst X, nlex_pdevs (snd X)) - fst X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n    pdevs_val (\\<lambda>i. f i + 1)\n     (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) +\n    lowest_vertex (fst X, nlex_pdevs (snd X)) -\n    fst X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n    pdevs_val (\\<lambda>i. f i + 1)\n     (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) +\n    lowest_vertex (fst X, nlex_pdevs (snd X)) -\n    fst X", "have \"sum_list (dense_list_of_pdevs (nlex_pdevs (snd X))) =\n        sum_list (dense_list_of_pdevs (pdevs_of_list (ccw.selsort 0 (inl (snd X)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (dense_list_of_pdevs (nlex_pdevs (snd X))) =\n    sum_list\n     (dense_list_of_pdevs (pdevs_of_list (ccw.selsort 0 (inl (snd X)))))", "by (subst dense_list_of_pdevs_pdevs_of_list)\n        (auto simp: in_set_independent_pdevs_nonzero dense_list_of_pdevs_pdevs_of_list inl_def\n          sum_list_distinct_selsort sum_list_independent_pdevs sum_list_list_of_pdevs)"], ["proof (state)\nthis:\n  sum_list (dense_list_of_pdevs (nlex_pdevs (snd X))) =\n  sum_list\n   (dense_list_of_pdevs (pdevs_of_list (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n    pdevs_val (\\<lambda>i. f i + 1)\n     (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) +\n    lowest_vertex (fst X, nlex_pdevs (snd X)) -\n    fst X", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum_list (dense_list_of_pdevs (nlex_pdevs (snd X))) =\n  sum_list\n   (dense_list_of_pdevs (pdevs_of_list (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n    pdevs_val (\\<lambda>i. f i + 1)\n     (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) +\n    lowest_vertex (fst X, nlex_pdevs (snd X)) -\n    fst X", "by (auto simp add: pdevs_val_add lowest_vertex_def algebra_simps pdevs_val_sum_list\n        sum_list_list_of_pdevs in_set_inl_nonzero dense_list_of_pdevs_pdevs_of_list)"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n  pdevs_val (\\<lambda>i. f i + 1)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) +\n  lowest_vertex (fst X, nlex_pdevs (snd X)) -\n  fst X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n  pdevs_val (\\<lambda>i. f i + 1)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) +\n  lowest_vertex (fst X, nlex_pdevs (snd X)) -\n  fst X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "also"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n  pdevs_val (\\<lambda>i. f i + 1)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) +\n  lowest_vertex (fst X, nlex_pdevs (snd X)) -\n  fst X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "have \"pdevs_val (\\<lambda>i. f i + 1) (pdevs_of_list ?sl) =\n      pdevs_val (\\<lambda>i. 1/2 * (f i + 1)) (pdevs_of_list (map ((*\\<^sub>R) 2) ?sl))\"\n    (is \"_ = pdevs_val ?f' (pdevs_of_list ?ssl)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>i. f i + 1)\n     (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n    pdevs_val (\\<lambda>i. 1 / 2 * (f i + 1))\n     (pdevs_of_list (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))", "by (subst pdevs_val_cmul) (simp add: pdevs_of_list_map_scaleR)"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>i. f i + 1)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n  pdevs_val (\\<lambda>i. 1 / 2 * (f i + 1))\n   (pdevs_of_list (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "also"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>i. f i + 1)\n   (pdevs_of_list (ccw.selsort 0 (inl (snd X)))) =\n  pdevs_val (\\<lambda>i. 1 / 2 * (f i + 1))\n   (pdevs_of_list (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "have \"distinct ?ssl\" \"?f' \\<in> UNIV \\<rightarrow> {0<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))) &&&\n    (\\<lambda>i. 1 / 2 * (f i + 1)) \\<in> UNIV \\<rightarrow> {0<..<1}", "using \\<open>f \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  f \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. distinct (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))) &&&\n    (\\<lambda>i. 1 / 2 * (f i + 1)) \\<in> UNIV \\<rightarrow> {0<..<1}", "by (auto simp: distinct_map_scaleRI Pi_iff algebra_simps real_0_less_add_iff)"], ["proof (state)\nthis:\n  distinct (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))\n  (\\<lambda>i. 1 / 2 * (f i + 1)) \\<in> UNIV \\<rightarrow> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "from pdevs_of_list_sum[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>fa.\n      \\<lbrakk>fa \\<in> UNIV \\<rightarrow> {0<..<1};\n       pdevs_val (\\<lambda>i. 1 / 2 * (f i + 1))\n        (pdevs_of_list\n          (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) =\n       (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n          fa P *\\<^sub>R P)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain g where \"g \\<in> UNIV \\<rightarrow> {0<..<1}\"\n    \"pdevs_val ?f' (pdevs_of_list ?ssl) = (\\<Sum>P\\<in>set ?ssl. g P *\\<^sub>R P)\""], ["proof (prove)\nusing this:\n  (\\<And>fa.\n      \\<lbrakk>fa \\<in> UNIV \\<rightarrow> {0<..<1};\n       pdevs_val (\\<lambda>i. 1 / 2 * (f i + 1))\n        (pdevs_of_list\n          (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) =\n       (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n          fa P *\\<^sub>R P)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> UNIV \\<rightarrow> {0<..<1};\n         pdevs_val (\\<lambda>i. 1 / 2 * (f i + 1))\n          (pdevs_of_list\n            (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) =\n         (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2)\n                            (ccw.selsort 0 (inl (snd X)))).\n            g P *\\<^sub>R P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g \\<in> UNIV \\<rightarrow> {0<..<1}\n  pdevs_val (\\<lambda>i. 1 / 2 * (f i + 1))\n   (pdevs_of_list (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) =\n  (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n     g P *\\<^sub>R P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>i. 1 / 2 * (f i + 1))\n   (pdevs_of_list (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) =\n  (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n     g P *\\<^sub>R P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "finally"], ["proof (chain)\npicking this:\n  aform_val e X =\n  fst X +\n  ((\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n      g P *\\<^sub>R P) +\n   lowest_vertex (fst X, nlex_pdevs (snd X)) -\n   fst X)", "have \"aform_val e X = lowest_vertex (fst X, nlex_pdevs (snd X)) + (\\<Sum>P\\<in>set ?ssl. g P *\\<^sub>R P)\""], ["proof (prove)\nusing this:\n  aform_val e X =\n  fst X +\n  ((\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n      g P *\\<^sub>R P) +\n   lowest_vertex (fst X, nlex_pdevs (snd X)) -\n   fst X)\n\ngoal (1 subgoal):\n 1. aform_val e X =\n    lowest_vertex (fst X, nlex_pdevs (snd X)) +\n    (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n       g P *\\<^sub>R P)", "by simp"], ["proof (state)\nthis:\n  aform_val e X =\n  lowest_vertex (fst X, nlex_pdevs (snd X)) +\n  (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n     g P *\\<^sub>R P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "also"], ["proof (state)\nthis:\n  aform_val e X =\n  lowest_vertex (fst X, nlex_pdevs (snd X)) +\n  (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n     g P *\\<^sub>R P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "have \"ccw' (fst seg) (snd seg) \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (fst seg) (snd seg)\n     (lowest_vertex (fst X, nlex_pdevs (snd X)) +\n      (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n         g P *\\<^sub>R P))", "using \\<open>g \\<in> _\\<close> _ len \\<open>seg \\<in> _\\<close>[unfolded half_segments_of_aform_def Let_def]"], ["proof (prove)\nusing this:\n  g \\<in> UNIV \\<rightarrow> {0<..<1}\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  length (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))) \\<noteq> 1\n  seg\n  \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. ccw' (fst seg) (snd seg)\n     (lowest_vertex (fst X, nlex_pdevs (snd X)) +\n      (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n         g P *\\<^sub>R P))", "by (rule in_polychain_of_ccw) (simp add: ccw'_sortedP_scaled_inl)"], ["proof (state)\nthis:\n  ccw' (fst seg) (snd seg)\n   (lowest_vertex (fst X, nlex_pdevs (snd X)) +\n    (\\<Sum>P\\<in>set (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))).\n       g P *\\<^sub>R P))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1<..<1};\n     seg\n     \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                 (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))));\n     length\n      (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n        (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> ccw' (fst seg) (snd seg) (aform_val e X)", "finally"], ["proof (chain)\npicking this:\n  ccw' (fst seg) (snd seg) (aform_val e X)", "show ?thesis"], ["proof (prove)\nusing this:\n  ccw' (fst seg) (snd seg) (aform_val e X)\n\ngoal (1 subgoal):\n 1. ccw' (fst seg) (snd seg) (aform_val e X)", "."], ["proof (state)\nthis:\n  ccw' (fst seg) (snd seg) (aform_val e X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma half_segments_of_aform_strict_all:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X)) (half_segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X))\n     (half_segments_of_aform X)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  length (half_segments_of_aform X) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X))\n     (half_segments_of_aform X)", "by (auto intro!: half_segments_of_aform_strict simp: list_all_iff)"], ["", "lemma list_allD: \"list_all P xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all P xs; x \\<in> set xs\\<rbrakk> \\<Longrightarrow> P x", "by (auto simp: list_all_iff)"], ["", "lemma minus_one_less_multI:\n  fixes e x::real\n  shows \"- 1 \\<le> e \\<Longrightarrow> 0 < x \\<Longrightarrow> x < 1 \\<Longrightarrow> - 1 < e * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- 1 \\<le> e; 0 < x; x < 1\\<rbrakk>\n    \\<Longrightarrow> - 1 < e * x", "by (metis abs_add_one_gt_zero abs_real_def le_less_trans less_not_sym mult_less_0_iff\n    mult_less_cancel_left1 real_0_less_add_iff)"], ["", "lemma less_one_multI:\n  fixes e x::real\n  shows \"e \\<le> 1 \\<Longrightarrow> 0 < x \\<Longrightarrow> x < 1 \\<Longrightarrow> e * x < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<le> 1; 0 < x; x < 1\\<rbrakk> \\<Longrightarrow> e * x < 1", "by (metis (erased, hide_lams) less_eq_real_def monoid_mult_class.mult.left_neutral\n    mult_strict_mono zero_less_one)"], ["", "lemma ccw_half_segments_of_aform_strictI:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"(s1, s2) \\<in> set (half_segments_of_aform X)\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  assumes \"x = (aform_val e X)\"\n  shows \"ccw' s1 s2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' s1 s2 x", "using half_segments_of_aform_strict[OF assms(1-3)] assms(4)"], ["proof (prove)\nusing this:\n  ccw' (fst (s1, s2)) (snd (s1, s2)) (aform_val e X)\n  x = aform_val e X\n\ngoal (1 subgoal):\n 1. ccw' s1 s2 x", "by simp"], ["", "lemma\n  ccw'_sortedP_subsequent:\n  assumes \"Suc i < length xs\" \"ccw'.sortedP 0 (map dirvec xs)\" \"fst (xs ! Suc i) = snd (xs ! i)\"\n  shows \"ccw' (fst (xs ! i)) (snd (xs ! i)) (snd (xs ! Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (fst (xs ! i)) (snd (xs ! i)) (snd (xs ! Suc i))", "using assms"], ["proof (prove)\nusing this:\n  Suc i < length xs\n  ccw'.sortedP 0 (map dirvec xs)\n  fst (xs ! Suc i) = snd (xs ! i)\n\ngoal (1 subgoal):\n 1. ccw' (fst (xs ! i)) (snd (xs ! i)) (snd (xs ! Suc i))", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>Suc i < length []; ccw'.sortedP 0 (map dirvec []);\n        fst ([] ! Suc i) = snd ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> ccw' (fst ([] ! i)) (snd ([] ! i))\n                          (snd ([] ! Suc i))\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>Suc i < length xs;\n                    ccw'.sortedP 0 (map dirvec xs);\n                    fst (xs ! Suc i) = snd (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> ccw' (fst (xs ! i)) (snd (xs ! i))\n(snd (xs ! Suc i));\n        Suc i < length (a # xs); ccw'.sortedP 0 (map dirvec (a # xs));\n        fst ((a # xs) ! Suc i) = snd ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> ccw' (fst ((a # xs) ! i)) (snd ((a # xs) ! i))\n                          (snd ((a # xs) ! Suc i))", "case Nil"], ["proof (state)\nthis:\n  Suc i < length []\n  ccw'.sortedP 0 (map dirvec [])\n  fst ([] ! Suc i) = snd ([] ! i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>Suc i < length []; ccw'.sortedP 0 (map dirvec []);\n        fst ([] ! Suc i) = snd ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> ccw' (fst ([] ! i)) (snd ([] ! i))\n                          (snd ([] ! Suc i))\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>Suc i < length xs;\n                    ccw'.sortedP 0 (map dirvec xs);\n                    fst (xs ! Suc i) = snd (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> ccw' (fst (xs ! i)) (snd (xs ! i))\n(snd (xs ! Suc i));\n        Suc i < length (a # xs); ccw'.sortedP 0 (map dirvec (a # xs));\n        fst ((a # xs) ! Suc i) = snd ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> ccw' (fst ((a # xs) ! i)) (snd ((a # xs) ! i))\n                          (snd ((a # xs) ! Suc i))", "thus ?case"], ["proof (prove)\nusing this:\n  Suc i < length []\n  ccw'.sortedP 0 (map dirvec [])\n  fst ([] ! Suc i) = snd ([] ! i)\n\ngoal (1 subgoal):\n 1. ccw' (fst ([] ! i)) (snd ([] ! i)) (snd ([] ! Suc i))", "by simp"], ["proof (state)\nthis:\n  ccw' (fst ([] ! i)) (snd ([] ! i)) (snd ([] ! Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>Suc i < length xs;\n                    ccw'.sortedP 0 (map dirvec xs);\n                    fst (xs ! Suc i) = snd (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> ccw' (fst (xs ! i)) (snd (xs ! i))\n(snd (xs ! Suc i));\n        Suc i < length (a # xs); ccw'.sortedP 0 (map dirvec (a # xs));\n        fst ((a # xs) ! Suc i) = snd ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> ccw' (fst ((a # xs) ! i)) (snd ((a # xs) ! i))\n                          (snd ((a # xs) ! Suc i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>Suc i < length xs;\n                    ccw'.sortedP 0 (map dirvec xs);\n                    fst (xs ! Suc i) = snd (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> ccw' (fst (xs ! i)) (snd (xs ! i))\n(snd (xs ! Suc i));\n        Suc i < length (a # xs); ccw'.sortedP 0 (map dirvec (a # xs));\n        fst ((a # xs) ! Suc i) = snd ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> ccw' (fst ((a # xs) ! i)) (snd ((a # xs) ! i))\n                          (snd ((a # xs) ! Suc i))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>Suc ?i < length xs; ccw'.sortedP 0 (map dirvec xs);\n   fst (xs ! Suc ?i) = snd (xs ! ?i)\\<rbrakk>\n  \\<Longrightarrow> ccw' (fst (xs ! ?i)) (snd (xs ! ?i)) (snd (xs ! Suc ?i))\n  Suc i < length (x # xs)\n  ccw'.sortedP 0 (map dirvec (x # xs))\n  fst ((x # xs) ! Suc i) = snd ((x # xs) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>Suc i < length xs;\n                    ccw'.sortedP 0 (map dirvec xs);\n                    fst (xs ! Suc i) = snd (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> ccw' (fst (xs ! i)) (snd (xs ! i))\n(snd (xs ! Suc i));\n        Suc i < length (a # xs); ccw'.sortedP 0 (map dirvec (a # xs));\n        fst ((a # xs) ! Suc i) = snd ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> ccw' (fst ((a # xs) ! i)) (snd ((a # xs) ! i))\n                          (snd ((a # xs) ! Suc i))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc ?i < length xs; ccw'.sortedP 0 (map dirvec xs);\n   fst (xs ! Suc ?i) = snd (xs ! ?i)\\<rbrakk>\n  \\<Longrightarrow> ccw' (fst (xs ! ?i)) (snd (xs ! ?i)) (snd (xs ! Suc ?i))\n  Suc i < length (x # xs)\n  ccw'.sortedP 0 (map dirvec (x # xs))\n  fst ((x # xs) ! Suc i) = snd ((x # xs) ! i)\n\ngoal (1 subgoal):\n 1. ccw' (fst ((x # xs) ! i)) (snd ((x # xs) ! i)) (snd ((x # xs) ! Suc i))", "by (auto simp: nth_Cons dirvec_minus split: nat.split elim!: ccw'.sortedP_Cons)\n      (metis (no_types, lifting) ccw'.renormalize length_greater_0_conv nth_mem prod.case_eq_if)"], ["proof (state)\nthis:\n  ccw' (fst ((x # xs) ! i)) (snd ((x # xs) ! i)) (snd ((x # xs) ! Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccw'_sortedP_uminus: \"ccw'.sortedP 0 xs \\<Longrightarrow> ccw'.sortedP 0 (map uminus xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP 0 xs \\<Longrightarrow> ccw'.sortedP 0 (map uminus xs)", "by (induct xs) (auto intro!: ccw'.sortedP.Cons elim!: ccw'.sortedP_Cons simp del: uminus_Pair)"], ["", "lemma subsequent_half_segments_ccw:\n  fixes X\n  assumes \"Suc i < length (half_segments_of_aform X)\"\n  shows \"ccw' (fst (half_segments_of_aform X ! i)) (snd (half_segments_of_aform X ! i))\n    (snd (half_segments_of_aform X ! Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (fst (half_segments_of_aform X ! i))\n     (snd (half_segments_of_aform X ! i))\n     (snd (half_segments_of_aform X ! Suc i))", "using assms"], ["proof (prove)\nusing this:\n  Suc i < length (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. ccw' (fst (half_segments_of_aform X ! i))\n     (snd (half_segments_of_aform X ! i))\n     (snd (half_segments_of_aform X ! Suc i))", "by (intro ccw'_sortedP_subsequent )\n    (auto simp: subsequent_half_segments half_segments_of_aform_def\n      sorted_inl polychain_of_subsequent_eq intro!: ccw_sorted_implies_ccw'_sortedP[OF inl_ncoll]\n      ccw'_sorted_scaleR)"], ["", "lemma convex_polychain_half_segments_of_aform: \"convex_polychain (half_segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain (half_segments_of_aform X)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> convex_polychain (half_segments_of_aform X)\n 2. \\<not> ?P \\<Longrightarrow> convex_polychain (half_segments_of_aform X)", "assume \"length (half_segments_of_aform X) = 1\""], ["proof (state)\nthis:\n  length (half_segments_of_aform X) = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> convex_polychain (half_segments_of_aform X)\n 2. \\<not> ?P \\<Longrightarrow> convex_polychain (half_segments_of_aform X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (half_segments_of_aform X) = 1\n\ngoal (1 subgoal):\n 1. convex_polychain (half_segments_of_aform X)", "by (auto simp: length_Suc_conv convex_polychain_def polychain_def)"], ["proof (state)\nthis:\n  convex_polychain (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. length (half_segments_of_aform X) \\<noteq> 1 \\<Longrightarrow>\n    convex_polychain (half_segments_of_aform X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length (half_segments_of_aform X) \\<noteq> 1 \\<Longrightarrow>\n    convex_polychain (half_segments_of_aform X)", "assume len: \"length (half_segments_of_aform X) \\<noteq> 1\""], ["proof (state)\nthis:\n  length (half_segments_of_aform X) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. length (half_segments_of_aform X) \\<noteq> 1 \\<Longrightarrow>\n    convex_polychain (half_segments_of_aform X)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain (half_segments_of_aform X)", "by (rule convex_polychainI)\n      (simp_all add: polychain_half_segments_of_aform subsequent_half_segments_ccw\n        ccw'_def[symmetric])"], ["proof (state)\nthis:\n  convex_polychain (half_segments_of_aform X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hd_distinct_neq_last: \"distinct xs \\<Longrightarrow> length xs > 1 \\<Longrightarrow> hd xs \\<noteq> last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; 1 < length xs\\<rbrakk>\n    \\<Longrightarrow> hd xs \\<noteq> last xs", "by (metis One_nat_def add_Suc_right distinct.simps(2) last.simps last_in_set less_irrefl\n    list.exhaust list.sel(1) list.size(3) list.size(4) add.right_neutral nat_neq_iff not_less0)"], ["", "lemma ccw_hd_last_half_segments_dirvec:\n  assumes \"length (half_segments_of_aform X) > 1\"\n  shows \"ccw' 0 (dirvec (hd (half_segments_of_aform X))) (dirvec (last (half_segments_of_aform X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "let ?i = \"ccw.selsort 0 (inl (snd X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "let ?s = \"map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "from assms"], ["proof (chain)\npicking this:\n  1 < length (half_segments_of_aform X)", "have l: \"1 < length (inl (snd X))\" \"inl (snd X) \\<noteq> []\""], ["proof (prove)\nusing this:\n  1 < length (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. 1 < length (inl (snd X)) &&& inl (snd X) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  1 < length (half_segments_of_aform X)\n  1 < length (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. 1 < length (inl (snd X)) &&& inl (snd X) \\<noteq> []", "by (auto simp add: half_segments_of_aform_def)"], ["proof (state)\nthis:\n  1 < length (inl (snd X))\n  inl (snd X) \\<noteq> []\n\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "hence \"hd ?i \\<in> set ?i\" \"last ?i \\<in> set ?i\""], ["proof (prove)\nusing this:\n  1 < length (inl (snd X))\n  inl (snd X) \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (ccw.selsort 0 (inl (snd X)))\n    \\<in> set (ccw.selsort 0 (inl (snd X))) &&&\n    last (ccw.selsort 0 (inl (snd X)))\n    \\<in> set (ccw.selsort 0 (inl (snd X)))", "by (auto intro!: hd_in_set last_in_set simp del: ccw.set_selsort)"], ["proof (state)\nthis:\n  hd (ccw.selsort 0 (inl (snd X))) \\<in> set (ccw.selsort 0 (inl (snd X)))\n  last (ccw.selsort 0 (inl (snd X))) \\<in> set (ccw.selsort 0 (inl (snd X)))\n\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "hence \"\\<not>coll 0 (hd ?i) (last ?i)\""], ["proof (prove)\nusing this:\n  hd (ccw.selsort 0 (inl (snd X))) \\<in> set (ccw.selsort 0 (inl (snd X)))\n  last (ccw.selsort 0 (inl (snd X))) \\<in> set (ccw.selsort 0 (inl (snd X)))\n\ngoal (1 subgoal):\n 1. det3 0 (hd (ccw.selsort 0 (inl (snd X))))\n     (last (ccw.selsort 0 (inl (snd X)))) \\<noteq>\n    0", "using l"], ["proof (prove)\nusing this:\n  hd (ccw.selsort 0 (inl (snd X))) \\<in> set (ccw.selsort 0 (inl (snd X)))\n  last (ccw.selsort 0 (inl (snd X))) \\<in> set (ccw.selsort 0 (inl (snd X)))\n  1 < length (inl (snd X))\n  inl (snd X) \\<noteq> []\n\ngoal (1 subgoal):\n 1. det3 0 (hd (ccw.selsort 0 (inl (snd X))))\n     (last (ccw.selsort 0 (inl (snd X)))) \\<noteq>\n    0", "by (intro inl_ncoll[of _ X]) (auto simp: hd_distinct_neq_last)"], ["proof (state)\nthis:\n  det3 0 (hd (ccw.selsort 0 (inl (snd X))))\n   (last (ccw.selsort 0 (inl (snd X)))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "hence \"\\<not>coll 0 (hd ?s) (last ?s)\""], ["proof (prove)\nusing this:\n  det3 0 (hd (ccw.selsort 0 (inl (snd X))))\n   (last (ccw.selsort 0 (inl (snd X)))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. det3 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n     (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n    0", "using l"], ["proof (prove)\nusing this:\n  det3 0 (hd (ccw.selsort 0 (inl (snd X))))\n   (last (ccw.selsort 0 (inl (snd X)))) \\<noteq>\n  0\n  1 < length (inl (snd X))\n  inl (snd X) \\<noteq> []\n\ngoal (1 subgoal):\n 1. det3 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n     (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n    0", "by (auto simp: hd_map last_map)"], ["proof (state)\nthis:\n  det3 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n   (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "hence \"ccw' 0 (hd (map ((*\\<^sub>R) 2) (linorder_list0.selsort (ccw 0) (inl (snd X)))))\n     (last (map ((*\\<^sub>R) 2) (linorder_list0.selsort (ccw 0) (inl (snd X)))))\""], ["proof (prove)\nusing this:\n  det3 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n   (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. ccw' 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n     (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))", "using assms"], ["proof (prove)\nusing this:\n  det3 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n   (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))) \\<noteq>\n  0\n  1 < length (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. ccw' 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n     (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))", "by (auto simp add: half_segments_of_aform_def\n      intro!: sorted_inl ccw_sorted_scaleR ccw.hd_last_sorted ccw_ncoll_imp_ccw)"], ["proof (state)\nthis:\n  ccw' 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n   (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "with assms"], ["proof (chain)\npicking this:\n  1 < length (half_segments_of_aform X)\n  ccw' 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n   (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < length (half_segments_of_aform X)\n  ccw' 0 (hd (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n   (last (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n     (dirvec (last (half_segments_of_aform X)))", "by (auto simp add: half_segments_of_aform_def Let_def\n        dirvec_hd_polychain_of dirvec_last_polychain_of length_greater_0_conv[symmetric]\n      simp del: polychain_of.simps length_greater_0_conv\n      split: if_split_asm)"], ["proof (state)\nthis:\n  ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n   (dirvec (last (half_segments_of_aform X)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_fst_half_segments_aux_eq: \"[] \\<noteq> half_segments_of_aform X \\<Longrightarrow>\n    map fst (half_segments_of_aform X) =\n      fst (hd (half_segments_of_aform X))#butlast (map snd (half_segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> half_segments_of_aform X \\<Longrightarrow>\n    map fst (half_segments_of_aform X) =\n    fst (hd (half_segments_of_aform X)) #\n    butlast (map snd (half_segments_of_aform X))", "by (rule nth_equalityI)\n    (auto simp: nth_Cons hd_conv_nth nth_butlast subsequent_half_segments split: nat.split)"], ["", "lemma le_less_Suc_eq: \"x - Suc 0 \\<le> (i::nat) \\<Longrightarrow> i < x \\<Longrightarrow> x - Suc 0 = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x - Suc 0 \\<le> i; i < x\\<rbrakk>\n    \\<Longrightarrow> x - Suc 0 = i", "by simp"], ["", "lemma map_snd_half_segments_aux_eq: \"half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    map snd (half_segments_of_aform X) =\n      tl (map fst (half_segments_of_aform X)) @ [snd (last (half_segments_of_aform X))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    map snd (half_segments_of_aform X) =\n    tl (map fst (half_segments_of_aform X)) @\n    [snd (last (half_segments_of_aform X))]", "by (rule nth_equalityI)\n    (auto simp: nth_Cons hd_conv_nth nth_append nth_tl subsequent_half_segments\n      not_less last_conv_nth algebra_simps dest!: le_less_Suc_eq\n    split: nat.split)"], ["", "lemma ccw'_sortedP_snd_half_segments_of_aform:\n  \"ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X))) (map snd (half_segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map snd (half_segments_of_aform X))", "by (auto simp: half_segments_of_aform_def Let_def\n    intro!: ccw'.sortedP.Cons ccw'_sortedP_polychain_of_snd ccw'_sortedP_scaled_inl)"], ["", "lemma\n  lex_half_segments_lowest_vertex:\n  assumes \"(c, d) \\<in> set (half_segments_of_aform X)\"\n  shows \"lex d (lowest_vertex (fst X, nlex_pdevs (snd X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex d\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "unfolding half_segments_of_aform_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex d\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by (rule lex_polychain_of_center[OF assms[unfolded half_segments_of_aform_def Let_def],\n      unfolded snd_conv])\n    (auto simp: list_all_iff lex_def dest!: in_set_inl_lex)"], ["", "lemma\n  lex_half_segments_lowest_vertex':\n  assumes \"d \\<in> set (map snd (half_segments_of_aform X))\"\n  shows \"lex d (lowest_vertex (fst X, nlex_pdevs (snd X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex d\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "using assms"], ["proof (prove)\nusing this:\n  d \\<in> set (map snd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex d\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by (auto intro: lex_half_segments_lowest_vertex)"], ["", "lemma\n  lex_half_segments_last:\n  assumes \"(c, d) \\<in> set (half_segments_of_aform X)\"\n  shows \"lex (snd (last (half_segments_of_aform X))) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (snd (last (half_segments_of_aform X))) d", "using assms"], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (snd (last (half_segments_of_aform X))) d", "unfolding half_segments_of_aform_def Let_def"], ["proof (prove)\nusing this:\n  (c, d)\n  \\<in> set (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (snd (last\n            (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))\n     d", "by (rule lex_polychain_of_last) (auto simp: list_all_iff lex_def dest!: in_set_inl_lex)"], ["", "lemma\n  lex_half_segments_last':\n  assumes \"d \\<in> set (map snd (half_segments_of_aform X))\"\n  shows \"lex (snd (last (half_segments_of_aform X))) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (snd (last (half_segments_of_aform X))) d", "using assms"], ["proof (prove)\nusing this:\n  d \\<in> set (map snd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (snd (last (half_segments_of_aform X))) d", "by (auto intro: lex_half_segments_last)"], ["", "lemma\n  ccw'_half_segments_lowest_last:\n  assumes set_butlast: \"(c, d) \\<in> set (butlast (half_segments_of_aform X))\"\n  assumes ne: \"inl (snd X) \\<noteq> []\"\n  shows \"ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) d (snd (last (half_segments_of_aform X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) d\n     (snd (last (half_segments_of_aform X)))", "using set_butlast"], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (butlast (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) d\n     (snd (last (half_segments_of_aform X)))", "unfolding half_segments_of_aform_def Let_def"], ["proof (prove)\nusing this:\n  (c, d)\n  \\<in> set (butlast\n              (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n                (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))\n\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) d\n     (snd (last\n            (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))", "by (rule ccw'_polychain_of_sorted_center_last) (auto simp: ne ccw'_sortedP_scaled_inl)"], ["", "lemma distinct_fst_half_segments:\n  \"distinct (map fst (half_segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (half_segments_of_aform X))", "by (auto simp: half_segments_of_aform_def list_all_iff lex_scale1_zero\n    simp del: scaleR_Pair\n    intro!: distinct_fst_polychain_of\n    dest: in_set_inl_nonzero in_set_inl_lex)"], ["", "lemma distinct_snd_half_segments:\n  \"distinct (map snd (half_segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map snd (half_segments_of_aform X))", "by (auto simp: half_segments_of_aform_def list_all_iff lex_scale1_zero\n    simp del: scaleR_Pair\n    intro!: distinct_snd_polychain_of\n    dest: in_set_inl_nonzero in_set_inl_lex)"], ["", "subsection \\<open>Mirror\\<close>"], ["", "definition \"mirror_point x y = 2 *\\<^sub>R x - y\""], ["", "lemma ccw'_mirror_point3[simp]:\n  \"ccw' (mirror_point x y) (mirror_point x z) (mirror_point x w) \\<longleftrightarrow> ccw' y z w \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (mirror_point x y) (mirror_point x z) (mirror_point x w) =\n    ccw' y z w", "by (auto simp: mirror_point_def det3_def' ccw'_def algebra_simps)"], ["", "lemma mirror_point_self_inverse[simp]:\n  fixes x::\"'a::real_vector\"\n  shows \"mirror_point p (mirror_point p x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror_point p (mirror_point p x) = x", "by (auto simp: mirror_point_def scaleR_2)"], ["", "lemma mirror_half_segments_of_aform:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X))\n      (map (pairself (mirror_point (fst X))) (half_segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X))\n     (map (pairself (mirror_point (fst X))) (half_segments_of_aform X))", "unfolding list_all_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length\n                (map (pairself (mirror_point (fst X)))\n                  (half_segments_of_aform X)).\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (map (pairself (mirror_point (fst X)))\n              (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "let ?m = \"map (pairself (mirror_point (fst X))) (half_segments_of_aform X)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (map (pairself (mirror_point (fst X)))\n              (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (map (pairself (mirror_point (fst X)))\n              (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "assume \"n < length ?m\""], ["proof (state)\nthis:\n  n < length\n       (map (pairself (mirror_point (fst X))) (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (map (pairself (mirror_point (fst X)))\n              (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "hence \"ccw' (fst (half_segments_of_aform X ! n)) (snd (half_segments_of_aform X ! n))\n      (aform_val (- e) X)\""], ["proof (prove)\nusing this:\n  n < length\n       (map (pairself (mirror_point (fst X))) (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. ccw' (fst (half_segments_of_aform X ! n))\n     (snd (half_segments_of_aform X ! n)) (aform_val (- e) X)", "using assms"], ["proof (prove)\nusing this:\n  n < length\n       (map (pairself (mirror_point (fst X))) (half_segments_of_aform X))\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  length (half_segments_of_aform X) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. ccw' (fst (half_segments_of_aform X ! n))\n     (snd (half_segments_of_aform X ! n)) (aform_val (- e) X)", "by (auto dest!: nth_mem intro!: half_segments_of_aform_strict)"], ["proof (state)\nthis:\n  ccw' (fst (half_segments_of_aform X ! n))\n   (snd (half_segments_of_aform X ! n)) (aform_val (- e) X)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (map (pairself (mirror_point (fst X)))\n              (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "also"], ["proof (state)\nthis:\n  ccw' (fst (half_segments_of_aform X ! n))\n   (snd (half_segments_of_aform X ! n)) (aform_val (- e) X)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (map (pairself (mirror_point (fst X)))\n              (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "have \"aform_val (-e) X = 2 *\\<^sub>R fst X - aform_val e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val (- e) X = 2 *\\<^sub>R fst X - aform_val e X", "by (auto simp: aform_val_def pdevs_val_sum algebra_simps scaleR_2 sum_negf)"], ["proof (state)\nthis:\n  aform_val (- e) X = 2 *\\<^sub>R fst X - aform_val e X\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (map (pairself (mirror_point (fst X)))\n              (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "finally"], ["proof (chain)\npicking this:\n  ccw' (fst (half_segments_of_aform X ! n))\n   (snd (half_segments_of_aform X ! n)) (2 *\\<^sub>R fst X - aform_val e X)", "have le:\n    \"ccw' (fst (half_segments_of_aform X ! n)) (snd (half_segments_of_aform X ! n))\n      (2 *\\<^sub>R fst X - aform_val e X)\""], ["proof (prove)\nusing this:\n  ccw' (fst (half_segments_of_aform X ! n))\n   (snd (half_segments_of_aform X ! n)) (2 *\\<^sub>R fst X - aform_val e X)\n\ngoal (1 subgoal):\n 1. ccw' (fst (half_segments_of_aform X ! n))\n     (snd (half_segments_of_aform X ! n))\n     (2 *\\<^sub>R fst X - aform_val e X)", "."], ["proof (state)\nthis:\n  ccw' (fst (half_segments_of_aform X ! n))\n   (snd (half_segments_of_aform X ! n)) (2 *\\<^sub>R fst X - aform_val e X)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (map (pairself (mirror_point (fst X)))\n              (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "have eq: \"(map (pairself (mirror_point (fst X))) (half_segments_of_aform X) ! n) =\n    (2 *\\<^sub>R fst X - fst ((half_segments_of_aform X) ! n),\n     2 *\\<^sub>R fst X - snd ((half_segments_of_aform X) ! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (pairself (mirror_point (fst X))) (half_segments_of_aform X) ! n =\n    (2 *\\<^sub>R fst X - fst (half_segments_of_aform X ! n),\n     2 *\\<^sub>R fst X - snd (half_segments_of_aform X ! n))", "using \\<open>n < length ?m\\<close>"], ["proof (prove)\nusing this:\n  n < length\n       (map (pairself (mirror_point (fst X))) (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. map (pairself (mirror_point (fst X))) (half_segments_of_aform X) ! n =\n    (2 *\\<^sub>R fst X - fst (half_segments_of_aform X ! n),\n     2 *\\<^sub>R fst X - snd (half_segments_of_aform X ! n))", "by (cases \"half_segments_of_aform X ! n\") (auto simp add: mirror_point_def)"], ["proof (state)\nthis:\n  map (pairself (mirror_point (fst X))) (half_segments_of_aform X) ! n =\n  (2 *\\<^sub>R fst X - fst (half_segments_of_aform X ! n),\n   2 *\\<^sub>R fst X - snd (half_segments_of_aform X ! n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (map (pairself (mirror_point (fst X)))\n              (half_segments_of_aform X)) \\<Longrightarrow>\n       ccw'\n        (fst (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (snd (map (pairself (mirror_point (fst X)))\n               (half_segments_of_aform X) !\n              n))\n        (aform_val e X)", "show \"ccw' (fst (?m ! n)) (snd (?m ! n)) (aform_val e X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'\n     (fst (map (pairself (mirror_point (fst X)))\n            (half_segments_of_aform X) !\n           n))\n     (snd (map (pairself (mirror_point (fst X)))\n            (half_segments_of_aform X) !\n           n))\n     (aform_val e X)", "using le"], ["proof (prove)\nusing this:\n  ccw' (fst (half_segments_of_aform X ! n))\n   (snd (half_segments_of_aform X ! n)) (2 *\\<^sub>R fst X - aform_val e X)\n\ngoal (1 subgoal):\n 1. ccw'\n     (fst (map (pairself (mirror_point (fst X)))\n            (half_segments_of_aform X) !\n           n))\n     (snd (map (pairself (mirror_point (fst X)))\n            (half_segments_of_aform X) !\n           n))\n     (aform_val e X)", "unfolding eq"], ["proof (prove)\nusing this:\n  ccw' (fst (half_segments_of_aform X ! n))\n   (snd (half_segments_of_aform X ! n)) (2 *\\<^sub>R fst X - aform_val e X)\n\ngoal (1 subgoal):\n 1. ccw'\n     (fst (2 *\\<^sub>R fst X - fst (half_segments_of_aform X ! n),\n           2 *\\<^sub>R fst X - snd (half_segments_of_aform X ! n)))\n     (snd (2 *\\<^sub>R fst X - fst (half_segments_of_aform X ! n),\n           2 *\\<^sub>R fst X - snd (half_segments_of_aform X ! n)))\n     (aform_val e X)", "by (auto simp: algebra_simps ccw'_def det3_def')"], ["proof (state)\nthis:\n  ccw'\n   (fst (map (pairself (mirror_point (fst X))) (half_segments_of_aform X) !\n         n))\n   (snd (map (pairself (mirror_point (fst X))) (half_segments_of_aform X) !\n         n))\n   (aform_val e X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_half_segments:\n  assumes \"half_segments_of_aform X \\<noteq> []\"\n  shows \"snd (last (half_segments_of_aform X)) =\n    mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (last (half_segments_of_aform X)) =\n    mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))", "using assms"], ["proof (prove)\nusing this:\n  half_segments_of_aform X \\<noteq> []\n\ngoal (1 subgoal):\n 1. snd (last (half_segments_of_aform X)) =\n    mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by (auto simp add: half_segments_of_aform_def Let_def lowest_vertex_def mirror_point_def scaleR_2\n    scaleR_sum_list[symmetric] last_polychain_of sum_list_distinct_selsort inl_def\n    sum_list_independent_pdevs sum_list_list_of_pdevs)"], ["", "lemma convex_polychain_map_mirror:\n  assumes \"convex_polychain hs\"\n  shows \"convex_polychain (map (pairself (mirror_point x)) hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain (map (pairself (mirror_point x)) hs)", "proof (rule convex_polychainI)"], ["proof (state)\ngoal (2 subgoals):\n 1. polychain (map (pairself (mirror_point x)) hs)\n 2. \\<And>i.\n       Suc i < length (map (pairself (mirror_point x)) hs) \\<Longrightarrow>\n       0 < det3 (fst (map (pairself (mirror_point x)) hs ! i))\n            (snd (map (pairself (mirror_point x)) hs ! i))\n            (snd (map (pairself (mirror_point x)) hs ! Suc i))", "qed (insert assms, auto simp: convex_polychain_def polychain_map_pairself pairself_apply\n  mirror_point_def det3_def' algebra_simps)"], ["", "lemma ccw'_mirror_point0:\n  \"ccw' (mirror_point x y) z w \\<longleftrightarrow> ccw' y (mirror_point x z) (mirror_point x w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (mirror_point x y) z w =\n    ccw' y (mirror_point x z) (mirror_point x w)", "by (metis ccw'_mirror_point3 mirror_point_self_inverse)"], ["", "lemma ccw'_sortedP_mirror:\n  \"ccw'.sortedP x0 (map (mirror_point p0) xs) \\<longleftrightarrow> ccw'.sortedP (mirror_point p0 x0) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP x0 (map (mirror_point p0) xs) =\n    ccw'.sortedP (mirror_point p0 x0) xs", "by (induct xs)\n    (simp_all add: linorder_list0.sortedP.Nil linorder_list0.sortedP_Cons_iff ccw'_mirror_point0)"], ["", "lemma ccw'_sortedP_mirror2:\n  \"ccw'.sortedP (mirror_point p0 x0) (map (mirror_point p0) xs) \\<longleftrightarrow> ccw'.sortedP x0 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (mirror_point p0 x0) (map (mirror_point p0) xs) =\n    ccw'.sortedP x0 xs", "using ccw'_sortedP_mirror[of \"mirror_point p0 x0\" p0 xs]"], ["proof (prove)\nusing this:\n  ccw'.sortedP (mirror_point p0 x0) (map (mirror_point p0) xs) =\n  ccw'.sortedP (mirror_point p0 (mirror_point p0 x0)) xs\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (mirror_point p0 x0) (map (mirror_point p0) xs) =\n    ccw'.sortedP x0 xs", "by simp"], ["", "lemma map_mirror_o_snd_polychain_of_eq: \"map (mirror_point x0 \\<circ> snd) (polychain_of y xs) =\n  map snd (polychain_of (mirror_point x0 y) (map uminus xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (mirror_point x0 \\<circ> snd) (polychain_of y xs) =\n    map snd (polychain_of (mirror_point x0 y) (map uminus xs))", "by (induct xs arbitrary: x0 y) (auto simp: mirror_point_def o_def algebra_simps)"], ["", "lemma lowest_vertex_eq_mirror_last:\n  \"half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    (lowest_vertex (fst X, nlex_pdevs (snd X))) =\n    mirror_point (fst X) (snd (last (half_segments_of_aform X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    lowest_vertex (fst X, nlex_pdevs (snd X)) =\n    mirror_point (fst X) (snd (last (half_segments_of_aform X)))", "using last_half_segments[of X]"], ["proof (prove)\nusing this:\n  half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n  snd (last (half_segments_of_aform X)) =\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    lowest_vertex (fst X, nlex_pdevs (snd X)) =\n    mirror_point (fst X) (snd (last (half_segments_of_aform X)))", "by simp"], ["", "lemma snd_last: \"xs \\<noteq> [] \\<Longrightarrow> snd (last xs) = last (map snd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> snd (last xs) = last (map snd xs)", "by (induct xs) auto"], ["", "lemma mirror_point_snd_last_eq_lowest:\n  \"half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    mirror_point (fst X) (last (map snd (half_segments_of_aform X))) =\n      lowest_vertex (fst X, nlex_pdevs (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. half_segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n    mirror_point (fst X) (last (map snd (half_segments_of_aform X))) =\n    lowest_vertex (fst X, nlex_pdevs (snd X))", "by (simp add: lowest_vertex_eq_mirror_last snd_last)"], ["", "lemma lex_mirror_point: \"lex (mirror_point x0 a) (mirror_point x0 b) \\<Longrightarrow> lex b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex (mirror_point x0 a)\n     (mirror_point x0 b) \\<Longrightarrow>\n    Counterclockwise_2D_Arbitrary.lex b a", "by (auto simp: mirror_point_def lex_def)"], ["", "lemma ccw'_mirror_point:\n  \"ccw' (mirror_point x0 a) (mirror_point x0 b)  (mirror_point x0 c) \\<Longrightarrow> ccw' a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (mirror_point x0 a) (mirror_point x0 b)\n     (mirror_point x0 c) \\<Longrightarrow>\n    ccw' a b c", "by (auto simp: mirror_point_def)"], ["", "lemma inj_mirror_point: \"inj (mirror_point (x::'a::real_vector))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (mirror_point x)", "by (auto simp: mirror_point_def inj_on_def algebra_simps)"], ["", "lemma\n  distinct_map_mirror_point_eq:\n  \"distinct (map (mirror_point (x::'a::real_vector)) xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (mirror_point x) xs) = distinct xs", "by (auto simp: distinct_map intro!: subset_inj_on[OF inj_mirror_point])"], ["", "lemma eq_self_mirror_iff: fixes x::\"'a::real_vector\" shows \"x = mirror_point y x \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = mirror_point y x) = (x = y)", "by (auto simp: mirror_point_def algebra_simps scaleR_2[symmetric])"], ["", "subsection \\<open>Full Segments\\<close>"], ["", "definition segments_of_aform::\"point aform \\<Rightarrow> (point * point) list\"\n  where \"segments_of_aform X =\n    (let hs = half_segments_of_aform X in hs @ map (pairself (mirror_point (fst X))) hs)\""], ["", "lemma segments_of_aform_strict:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 <..< 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X)) (segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X))\n     (segments_of_aform X)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1<..<1}\n  length (half_segments_of_aform X) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. ccw' (fst seg) (snd seg) (aform_val e X))\n     (segments_of_aform X)", "by (auto simp: segments_of_aform_def Let_def mirror_half_segments_of_aform\n    half_segments_of_aform_strict_all)"], ["", "lemma mirror_point_aform_val[simp]: \"mirror_point (fst X) (aform_val e X) = aform_val (- e) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror_point (fst X) (aform_val e X) = aform_val (- e) X", "by (auto simp: mirror_point_def aform_val_def pdevs_val_sum algebra_simps scaleR_2 sum_negf)"], ["", "lemma\n  in_set_segments_of_aform_aform_valE:\n  assumes \"(x2, y2) \\<in> set (segments_of_aform X)\"\n  obtains e where \"y2 = aform_val e X\" \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (x2, y2) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (auto simp: segments_of_aform_def Let_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>y2 = aform_val e X;\n                 e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (x2, y2) \\<in> set (half_segments_of_aform X)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"(x2, y2) \\<in> set (half_segments_of_aform X)\""], ["proof (state)\nthis:\n  (x2, y2) \\<in> set (half_segments_of_aform X)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>y2 = aform_val e X;\n                 e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (x2, y2) \\<in> set (half_segments_of_aform X)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "from in_set_half_segments_of_aform_aform_valE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>y2 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e where \"y2 = aform_val e X\" \"e \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>y2 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>y2 = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y2 = aform_val e X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>y2 = aform_val e X;\n                 e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (x2, y2) \\<in> set (half_segments_of_aform X)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  y2 = aform_val e X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix a b aa ba"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"((a, b), aa, ba) \\<in> set (half_segments_of_aform X)\""], ["proof (state)\nthis:\n  ((a, b), aa, ba) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "from in_set_half_segments_of_aform_aform_valE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>(aa, ba) = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e where e: \"(aa, ba) = aform_val e X\" \"e \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>(aa, ba) = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>(aa, ba) = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (aa, ba) = aform_val e X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"y2 = mirror_point (fst X) (aa, ba)\""], ["proof (state)\nthis:\n  y2 = mirror_point (fst X) (aa, ba)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"y2 = aform_val (-e) X\" \"(-e) \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  y2 = mirror_point (fst X) (aa, ba)\n\ngoal (1 subgoal):\n 1. y2 = aform_val (- e) X &&& - e \\<in> UNIV \\<rightarrow> {- 1..1}", "using e"], ["proof (prove)\nusing this:\n  y2 = mirror_point (fst X) (aa, ba)\n  (aa, ba) = aform_val e X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. y2 = aform_val (- e) X &&& - e \\<in> UNIV \\<rightarrow> {- 1..1}", "by auto"], ["proof (state)\nthis:\n  y2 = aform_val (- e) X\n  - e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>mirror_point (fst X) (aa, ba) = aform_val e X;\n                    e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set (half_segments_of_aform X);\n        x2 = mirror_point (fst X) (a, b);\n        y2 = mirror_point (fst X) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  y2 = aform_val (- e) X\n  - e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  last_half_segments_eq_mirror_hd:\n  assumes \"half_segments_of_aform X \\<noteq> []\"\n  shows \"snd (last (half_segments_of_aform X)) = mirror_point (fst X) (fst (hd (half_segments_of_aform X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (last (half_segments_of_aform X)) =\n    mirror_point (fst X) (fst (hd (half_segments_of_aform X)))", "by (simp add: last_half_segments assms fst_hd_half_segments_of_aform)"], ["", "lemma polychain_segments_of_aform: \"polychain (segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polychain (segments_of_aform X)", "by (auto simp: segments_of_aform_def Let_def polychain_half_segments_of_aform\n    polychain_map_pairself last_half_segments_eq_mirror_hd hd_map pairself_apply\n    intro!: polychain_appendI)"], ["", "lemma segments_of_aform_closed:\n  assumes \"segments_of_aform X \\<noteq> []\"\n  shows \"fst (hd (segments_of_aform X)) = snd (last (segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (hd (segments_of_aform X)) = snd (last (segments_of_aform X))", "using assms"], ["proof (prove)\nusing this:\n  segments_of_aform X \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst (hd (segments_of_aform X)) = snd (last (segments_of_aform X))", "by (auto simp: segments_of_aform_def Let_def fst_hd_half_segments_of_aform last_map\n    pairself_apply last_half_segments mirror_point_def)"], ["", "lemma convex_polychain_segments_of_aform:\n  assumes \"1 < length (half_segments_of_aform X)\"\n  shows \"convex_polychain (segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain (segments_of_aform X)", "unfolding segments_of_aform_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polychain\n     (half_segments_of_aform X @\n      map (pairself (mirror_point (fst X))) (half_segments_of_aform X))", "using ccw_hd_last_half_segments_dirvec[OF assms]"], ["proof (prove)\nusing this:\n  ccw' 0 (dirvec (hd (half_segments_of_aform X)))\n   (dirvec (last (half_segments_of_aform X)))\n\ngoal (1 subgoal):\n 1. convex_polychain\n     (half_segments_of_aform X @\n      map (pairself (mirror_point (fst X))) (half_segments_of_aform X))", "by (intro convex_polychain_appendI)\n    (auto\n      simp: convex_polychain_half_segments_of_aform convex_polychain_map_mirror dirvec_minus hd_map\n        pairself_apply last_half_segments mirror_point_def fst_hd_half_segments_of_aform det3_def'\n        algebra_simps ccw'_def\n      intro!: polychain_appendI polychain_half_segments_of_aform polychain_map_pairself)"], ["", "lemma convex_polygon_segments_of_aform:\n  assumes \"1 < length (half_segments_of_aform X)\"\n  shows \"convex_polygon (segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polygon (segments_of_aform X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. convex_polygon (segments_of_aform X)", "from assms"], ["proof (chain)\npicking this:\n  1 < length (half_segments_of_aform X)", "have hne: \"half_segments_of_aform X \\<noteq> []\""], ["proof (prove)\nusing this:\n  1 < length (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. half_segments_of_aform X \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  half_segments_of_aform X \\<noteq> []\n\ngoal (1 subgoal):\n 1. convex_polygon (segments_of_aform X)", "from convex_polychain_segments_of_aform[OF assms]"], ["proof (chain)\npicking this:\n  convex_polychain (segments_of_aform X)", "have \"convex_polychain (segments_of_aform X)\""], ["proof (prove)\nusing this:\n  convex_polychain (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. convex_polychain (segments_of_aform X)", "."], ["proof (state)\nthis:\n  convex_polychain (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. convex_polygon (segments_of_aform X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  convex_polychain (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. convex_polygon (segments_of_aform X)", "by (auto simp: convex_polygon_def segments_of_aform_closed)"], ["proof (state)\nthis:\n  convex_polygon (segments_of_aform X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  previous_segments_of_aformE:\n  assumes \"(y, z) \\<in> set (segments_of_aform X)\"\n  obtains x where \"(x, y) \\<in> set (segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, y) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, y) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  (y, z) \\<in> set (segments_of_aform X)", "have ne[simp]: \"segments_of_aform X \\<noteq> []\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. segments_of_aform X \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  segments_of_aform X \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, y) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  (y, z) \\<in> set (segments_of_aform X)", "obtain i where i: \"i<length (segments_of_aform X)\" \"(segments_of_aform X) ! i = (y, z)\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (segments_of_aform X);\n         segments_of_aform X ! i = (y, z)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length (segments_of_aform X)\n  segments_of_aform X ! i = (y, z)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, y) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> thesis\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> thesis\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "with segments_of_aform_closed[of X] assms"], ["proof (chain)\npicking this:\n  segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n  fst (hd (segments_of_aform X)) = snd (last (segments_of_aform X))\n  (y, z) \\<in> set (segments_of_aform X)\n  i = 0", "have \"(fst (last (segments_of_aform X)), y) \\<in> set (segments_of_aform X)\""], ["proof (prove)\nusing this:\n  segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n  fst (hd (segments_of_aform X)) = snd (last (segments_of_aform X))\n  (y, z) \\<in> set (segments_of_aform X)\n  i = 0\n\ngoal (1 subgoal):\n 1. (fst (last (segments_of_aform X)), y) \\<in> set (segments_of_aform X)", "by (metis fst_conv hd_conv_nth i(2) last_in_set ne snd_conv surj_pair)"], ["proof (state)\nthis:\n  (fst (last (segments_of_aform X)), y) \\<in> set (segments_of_aform X)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> thesis\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fst (last (segments_of_aform X)), y) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "case (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "have \"(fst (segments_of_aform X ! j), snd (segments_of_aform X ! j)) \\<in>\n        set (segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (segments_of_aform X ! j), snd (segments_of_aform X ! j))\n    \\<in> set (segments_of_aform X)", "using Suc i(1)"], ["proof (prove)\nusing this:\n  i = Suc j\n  i < length (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. (fst (segments_of_aform X ! j), snd (segments_of_aform X ! j))\n    \\<in> set (segments_of_aform X)", "by auto"], ["proof (state)\nthis:\n  (fst (segments_of_aform X ! j), snd (segments_of_aform X ! j))\n  \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  (fst (segments_of_aform X ! j), snd (segments_of_aform X ! j))\n  \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "from i"], ["proof (chain)\npicking this:\n  i < length (segments_of_aform X)\n  segments_of_aform X ! i = (y, z)", "have \"y = fst (segments_of_aform X ! i)\""], ["proof (prove)\nusing this:\n  i < length (segments_of_aform X)\n  segments_of_aform X ! i = (y, z)\n\ngoal (1 subgoal):\n 1. y = fst (segments_of_aform X ! i)", "by auto"], ["proof (state)\nthis:\n  y = fst (segments_of_aform X ! i)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "hence \"snd (segments_of_aform X ! j) = y\""], ["proof (prove)\nusing this:\n  y = fst (segments_of_aform X ! i)\n\ngoal (1 subgoal):\n 1. snd (segments_of_aform X ! j) = y", "using polychain_segments_of_aform[of X] i(1) Suc"], ["proof (prove)\nusing this:\n  y = fst (segments_of_aform X ! i)\n  polychain (segments_of_aform X)\n  i < length (segments_of_aform X)\n  i = Suc j\n\ngoal (1 subgoal):\n 1. snd (segments_of_aform X ! j) = y", "by (auto simp: polychain_def Suc)"], ["proof (state)\nthis:\n  snd (segments_of_aform X ! j) = y\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  (fst (segments_of_aform X ! j), y) \\<in> set (segments_of_aform X)", "have \"(fst (segments_of_aform X ! j), y) \\<in> set (segments_of_aform X)\""], ["proof (prove)\nusing this:\n  (fst (segments_of_aform X ! j), y) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. (fst (segments_of_aform X ! j), y) \\<in> set (segments_of_aform X)", "."], ["proof (state)\nthis:\n  (fst (segments_of_aform X ! j), y) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fst (segments_of_aform X ! j), y) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fst_compose_pairself: \"fst o pairself f = f o fst\"\n  and snd_compose_pairself: \"snd o pairself f = f o snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst \\<circ> pairself f = f \\<circ> fst &&&\n    snd \\<circ> pairself f = f \\<circ> snd", "by (auto simp: pairself_apply)"], ["", "lemma in_set_butlastI: \"xs \\<noteq> [] \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> x \\<noteq> last xs \\<Longrightarrow> x \\<in> set (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; x \\<in> set xs; x \\<noteq> last xs\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (butlast xs)", "by (induct xs) (auto split: if_splits)"], ["", "lemma distinct_in_set_butlastD:\n  \"x \\<in> set (butlast xs) \\<Longrightarrow> distinct xs \\<Longrightarrow> x \\<noteq> last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (butlast xs); distinct xs\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> last xs", "by (induct xs) auto"], ["", "lemma distinct_in_set_tlD:\n  \"x \\<in> set (tl xs) \\<Longrightarrow> distinct xs \\<Longrightarrow> x \\<noteq> hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (tl xs); distinct xs\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> hd xs", "by (induct xs) auto"], ["", "lemma ccw'_sortedP_snd_segments_of_aform:\n  assumes \"length (inl (snd X)) > 1\"\n  shows\n    \"ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n      (butlast (map snd (segments_of_aform X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))\n 2. \\<not> ?P \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "assume \"[] = half_segments_of_aform X\""], ["proof (state)\nthis:\n  [] = half_segments_of_aform X\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))\n 2. \\<not> ?P \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "from this"], ["proof (chain)\npicking this:\n  [] = half_segments_of_aform X", "show ?thesis"], ["proof (prove)\nusing this:\n  [] = half_segments_of_aform X\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "by (simp add: segments_of_aform_def Let_def ccw'.sortedP.Nil)"], ["proof (state)\nthis:\n  ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (butlast (map snd (segments_of_aform X)))\n\ngoal (1 subgoal):\n 1. [] \\<noteq> half_segments_of_aform X \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<noteq> half_segments_of_aform X \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "assume H: \"[] \\<noteq> half_segments_of_aform X\""], ["proof (state)\nthis:\n  [] \\<noteq> half_segments_of_aform X\n\ngoal (1 subgoal):\n 1. [] \\<noteq> half_segments_of_aform X \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "let ?m = \"mirror_point (fst X)\""], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<noteq> half_segments_of_aform X \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "have ne: \"inl (snd X) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inl (snd X) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  1 < length (inl (snd X))\n\ngoal (1 subgoal):\n 1. inl (snd X) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  inl (snd X) \\<noteq> []\n\ngoal (1 subgoal):\n 1. [] \\<noteq> half_segments_of_aform X \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "have \"ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map snd (half_segments_of_aform X) @ butlast (map (?m \\<circ> snd)\n    (half_segments_of_aform X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map snd (half_segments_of_aform X) @\n      butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))", "proof (rule ccw'.sortedP_appendI)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map snd (half_segments_of_aform X))\n 2. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "show \"ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X))) (map snd (half_segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map snd (half_segments_of_aform X))", "by (rule ccw'_sortedP_snd_half_segments_of_aform)"], ["proof (state)\nthis:\n  ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (map snd (half_segments_of_aform X))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"butlast (map (?m \\<circ> snd) (half_segments_of_aform X)) =\n      butlast\n       (map (?m \\<circ> snd) (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n         (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast\n     (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)) =\n    butlast\n     (map (mirror_point (fst X) \\<circ> snd)\n       (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n         (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))", "by (simp add: half_segments_of_aform_def)"], ["proof (state)\nthis:\n  butlast\n   (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)) =\n  butlast\n   (map (mirror_point (fst X) \\<circ> snd)\n     (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n       (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "also"], ["proof (state)\nthis:\n  butlast\n   (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)) =\n  butlast\n   (map (mirror_point (fst X) \\<circ> snd)\n     (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n       (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"\\<dots> =\n       map snd\n        (butlast\n          (polychain_of (?m (lowest_vertex (fst X, nlex_pdevs (snd X))))\n            (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))\"\n      (is \"_ = map snd (butlast (polychain_of ?x ?xs))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast\n     (map (mirror_point (fst X) \\<circ> snd)\n       (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n         (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))) =\n    map snd\n     (butlast\n       (polychain_of\n         (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n         (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))", "by (simp add: map_mirror_o_snd_polychain_of_eq map_butlast)"], ["proof (state)\nthis:\n  butlast\n   (map (mirror_point (fst X) \\<circ> snd)\n     (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n       (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))) =\n  map snd\n   (butlast\n     (polychain_of\n       (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n       (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "also"], ["proof (state)\nthis:\n  butlast\n   (map (mirror_point (fst X) \\<circ> snd)\n     (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n       (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))) =\n  map snd\n   (butlast\n     (polychain_of\n       (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n       (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "{"], ["proof (state)\nthis:\n  butlast\n   (map (mirror_point (fst X) \\<circ> snd)\n     (polychain_of (lowest_vertex (fst X, nlex_pdevs (snd X)))\n       (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))) =\n  map snd\n   (butlast\n     (polychain_of\n       (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n       (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"ccw'.sortedP 0 ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP 0\n     (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))", "by (intro ccw'_sortedP_uminus ccw'_sortedP_scaled_inl)"], ["proof (state)\nthis:\n  ccw'.sortedP 0\n   (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  ccw'.sortedP 0\n   (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"ccw'.sortedP ?x (map snd (polychain_of ?x ?xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n     (map snd\n       (polychain_of\n         (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n         (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))", "unfolding ccw'_sortedP_mirror[symmetric] map_map map_mirror_o_snd_polychain_of_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (map snd\n       (polychain_of\n         (mirror_point (fst X)\n           (mirror_point (fst X)\n             (lowest_vertex (fst X, nlex_pdevs (snd X)))))\n         (map (uminus \\<circ> (uminus \\<circ> (*\\<^sub>R) 2))\n           (ccw.selsort 0 (inl (snd X))))))", "by (auto simp add: o_def intro!: ccw'_sortedP_polychain_of_snd ccw'_sortedP_scaled_inl)"], ["proof (state)\nthis:\n  ccw'.sortedP\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n   (map snd\n     (polychain_of\n       (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n       (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "ultimately"], ["proof (chain)\npicking this:\n  ccw'.sortedP 0\n   (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n  ccw'.sortedP\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n   (map snd\n     (polychain_of\n       (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n       (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))", "have \"ccw'.sortedP (snd (last (polychain_of ?x ?xs)))\n          (map snd (butlast (polychain_of ?x ?xs)))\""], ["proof (prove)\nusing this:\n  ccw'.sortedP 0\n   (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))\n  ccw'.sortedP\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n   (map snd\n     (polychain_of\n       (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n       (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X)))))))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP\n     (snd (last\n            (polychain_of\n              (mirror_point (fst X)\n                (lowest_vertex (fst X, nlex_pdevs (snd X))))\n              (map uminus\n                (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))))\n     (map snd\n       (butlast\n         (polychain_of\n           (mirror_point (fst X)\n             (lowest_vertex (fst X, nlex_pdevs (snd X))))\n           (map uminus\n             (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))))", "by (rule ccw'_sortedP_convex_rotate_aux)"], ["proof (state)\nthis:\n  ccw'.sortedP\n   (snd (last\n          (polychain_of\n            (mirror_point (fst X)\n              (lowest_vertex (fst X, nlex_pdevs (snd X))))\n            (map uminus\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))))\n   (map snd\n     (butlast\n       (polychain_of\n         (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n         (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "}"], ["proof (state)\nthis:\n  ccw'.sortedP\n   (snd (last\n          (polychain_of\n            (mirror_point (fst X)\n              (lowest_vertex (fst X, nlex_pdevs (snd X))))\n            (map uminus\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))))\n   (map snd\n     (butlast\n       (polychain_of\n         (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n         (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "also"], ["proof (state)\nthis:\n  ccw'.sortedP\n   (snd (last\n          (polychain_of\n            (mirror_point (fst X)\n              (lowest_vertex (fst X, nlex_pdevs (snd X))))\n            (map uminus\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))))\n   (map snd\n     (butlast\n       (polychain_of\n         (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n         (map uminus (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"(snd (last (polychain_of ?x ?xs))) =\n        ?m (last (map snd (half_segments_of_aform X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (last\n          (polychain_of\n            (mirror_point (fst X)\n              (lowest_vertex (fst X, nlex_pdevs (snd X))))\n            (map uminus\n              (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))) =\n    mirror_point (fst X) (last (map snd (half_segments_of_aform X)))", "by (simp add: half_segments_of_aform_def ne map_mirror_o_snd_polychain_of_eq\n         last_map[symmetric, where f=\"?m\"]\n         last_map[symmetric, where f=\"snd\"])"], ["proof (state)\nthis:\n  snd (last\n        (polychain_of\n          (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n          (map uminus\n            (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))) =\n  mirror_point (fst X) (last (map snd (half_segments_of_aform X)))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "also"], ["proof (state)\nthis:\n  snd (last\n        (polychain_of\n          (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n          (map uminus\n            (map ((*\\<^sub>R) 2) (ccw.selsort 0 (inl (snd X))))))) =\n  mirror_point (fst X) (last (map snd (half_segments_of_aform X)))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"\\<dots> = lowest_vertex (fst X, nlex_pdevs (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror_point (fst X) (last (map snd (half_segments_of_aform X))) =\n    lowest_vertex (fst X, nlex_pdevs (snd X))", "using ne H"], ["proof (prove)\nusing this:\n  inl (snd X) \\<noteq> []\n  [] \\<noteq> half_segments_of_aform X\n\ngoal (1 subgoal):\n 1. mirror_point (fst X) (last (map snd (half_segments_of_aform X))) =\n    lowest_vertex (fst X, nlex_pdevs (snd X))", "by (auto simp: lowest_vertex_eq_mirror_last snd_last)"], ["proof (state)\nthis:\n  mirror_point (fst X) (last (map snd (half_segments_of_aform X))) =\n  lowest_vertex (fst X, nlex_pdevs (snd X))\n\ngoal (2 subgoals):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "finally"], ["proof (chain)\npicking this:\n  ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (butlast\n     (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))", "show \"ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n       (butlast (map (?m \\<circ> snd) (half_segments_of_aform X)))\""], ["proof (prove)\nusing this:\n  ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (butlast\n     (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast\n       (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))", "."], ["proof (state)\nthis:\n  ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (butlast\n     (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "assume seg: \"x \\<in> set (map snd (half_segments_of_aform X))\"\n      and mseg: \"y \\<in> set (butlast (map (?m \\<circ> snd) (half_segments_of_aform X)))\""], ["proof (state)\nthis:\n  x \\<in> set (map snd (half_segments_of_aform X))\n  y \\<in> set (butlast\n                (map (mirror_point (fst X) \\<circ> snd)\n                  (half_segments_of_aform X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from seg assms"], ["proof (chain)\npicking this:\n  x \\<in> set (map snd (half_segments_of_aform X))\n  1 < length (inl (snd X))", "have neq_Nil: \"inl (snd X) \\<noteq> []\" \"half_segments_of_aform X \\<noteq> []\""], ["proof (prove)\nusing this:\n  x \\<in> set (map snd (half_segments_of_aform X))\n  1 < length (inl (snd X))\n\ngoal (1 subgoal):\n 1. inl (snd X) \\<noteq> [] &&& half_segments_of_aform X \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  inl (snd X) \\<noteq> []\n  half_segments_of_aform X \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from seg"], ["proof (chain)\npicking this:\n  x \\<in> set (map snd (half_segments_of_aform X))", "obtain a where a: \"(a, x) \\<in> set (half_segments_of_aform X)\""], ["proof (prove)\nusing this:\n  x \\<in> set (map snd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        (a, x) \\<in> set (half_segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a, x) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from mseg"], ["proof (chain)\npicking this:\n  y \\<in> set (butlast\n                (map (mirror_point (fst X) \\<circ> snd)\n                  (half_segments_of_aform X)))", "obtain b\n    where mirror_y: \"(b, ?m y) \\<in> set (butlast (half_segments_of_aform X))\""], ["proof (prove)\nusing this:\n  y \\<in> set (butlast\n                (map (mirror_point (fst X) \\<circ> snd)\n                  (half_segments_of_aform X)))\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        (b, mirror_point (fst X) y)\n        \\<in> set (butlast (half_segments_of_aform X)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: map_butlast[symmetric])"], ["proof (state)\nthis:\n  (b, mirror_point (fst X) y) \\<in> set (butlast (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "let ?l = \"lowest_vertex (fst X, nlex_pdevs (snd X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "let ?ml = \"?m ?l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have mirror_eq_last: \"?ml = snd (last (half_segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))) =\n    snd (last (half_segments_of_aform X))", "using seg H"], ["proof (prove)\nusing this:\n  x \\<in> set (map snd (half_segments_of_aform X))\n  [] \\<noteq> half_segments_of_aform X\n\ngoal (1 subgoal):\n 1. mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))) =\n    snd (last (half_segments_of_aform X))", "by (intro last_half_segments[symmetric]) simp"], ["proof (state)\nthis:\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))) =\n  snd (last (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "define r\n      where \"r = ?l + (0, abs (snd x - snd ?l) + abs (snd y - snd ?l) + abs (snd ?ml - snd ?l) + 1)\""], ["proof (state)\nthis:\n  r =\n  lowest_vertex (fst X, nlex_pdevs (snd X)) +\n  (0, \\<bar>snd x - snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n      \\<bar>snd y - snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n      \\<bar>snd (mirror_point (fst X)\n                  (lowest_vertex (fst X, nlex_pdevs (snd X)))) -\n            snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n      1)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have d1: \"x \\<noteq> r\" \"y \\<noteq> r\" \"?l \\<noteq> r\" \"?ml \\<noteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<noteq> r &&& y \\<noteq> r) &&&\n    lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> r &&&\n    mirror_point (fst X)\n     (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<noteq>\n    r", "by (auto simp: r_def plus_prod_def prod_eq_iff)"], ["proof (state)\nthis:\n  x \\<noteq> r\n  y \\<noteq> r\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> r\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<noteq>\n  r\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"distinct (map (?m \\<circ> snd) (half_segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X))", "unfolding map_comp_map[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     ((map (mirror_point (fst X)) \\<circ> map snd)\n       (half_segments_of_aform X))", "unfolding o_def distinct_map_mirror_point_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map snd (half_segments_of_aform X))", "by (rule distinct_snd_half_segments)"], ["proof (state)\nthis:\n  distinct\n   (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from distinct_in_set_butlastD[OF \\<open>y \\<in> _\\<close> this]"], ["proof (chain)\npicking this:\n  y \\<noteq>\n  last (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X))", "have \"?l \\<noteq> y\""], ["proof (prove)\nusing this:\n  y \\<noteq>\n  last (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> y", "by (simp add: neq_Nil lowest_vertex_eq_mirror_last last_map)"], ["proof (state)\nthis:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"?l \\<noteq> ?ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq>\n    mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))", "using neq_Nil"], ["proof (prove)\nusing this:\n  inl (snd X) \\<noteq> []\n  half_segments_of_aform X \\<noteq> []\n\ngoal (1 subgoal):\n 1. lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq>\n    mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by (auto simp add: eq_self_mirror_iff lowest_vertex_eq_center_iff inl_def)"], ["proof (state)\nthis:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "ultimately"], ["proof (chain)\npicking this:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> y\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))", "have d2: \"?l \\<noteq> y\" \"?l \\<noteq> ?ml\""], ["proof (prove)\nusing this:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> y\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> y &&&\n    lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq>\n    mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by auto"], ["proof (state)\nthis:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> y\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have *: \"ccw' ?l (?m y) ?ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (mirror_point (fst X) y)\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))", "by (metis mirror_eq_last ccw'_half_segments_lowest_last mirror_y neq_Nil(1))"], ["proof (state)\nthis:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) (mirror_point (fst X) y)\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"ccw' ?ml y ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n     y (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by (rule ccw'_mirror_point[of \"fst X\"]) (simp add: *)"], ["proof (state)\nthis:\n  ccw' (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence lmy: \"ccw' ?l ?ml y\""], ["proof (prove)\nusing this:\n  ccw' (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y", "by (simp add: ccw'_def det3_def' algebra_simps)"], ["proof (state)\nthis:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "let ?ccw = \"ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "assume \"x \\<noteq> ?ml\""], ["proof (state)\nthis:\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence x_butlast: \"(a, x) \\<in> set (butlast (half_segments_of_aform X))\""], ["proof (prove)\nusing this:\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. (a, x) \\<in> set (butlast (half_segments_of_aform X))", "unfolding mirror_eq_last"], ["proof (prove)\nusing this:\n  x \\<noteq> snd (last (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. (a, x) \\<in> set (butlast (half_segments_of_aform X))", "using a"], ["proof (prove)\nusing this:\n  x \\<noteq> snd (last (half_segments_of_aform X))\n  (a, x) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. (a, x) \\<in> set (butlast (half_segments_of_aform X))", "by (auto intro!: in_set_butlastI simp: prod_eq_iff)"], ["proof (state)\nthis:\n  (a, x) \\<in> set (butlast (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"ccw' ?l x ?ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))", "by (metis mirror_eq_last ccw'_half_segments_lowest_last x_butlast neq_Nil(1))"], ["proof (state)\nthis:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "}"], ["proof (state)\nthis:\n  x \\<noteq>\n  mirror_point (fst X)\n   (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<Longrightarrow>\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "note lxml = this"], ["proof (state)\nthis:\n  x \\<noteq>\n  mirror_point (fst X)\n   (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<Longrightarrow>\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "{"], ["proof (state)\nthis:\n  x \\<noteq>\n  mirror_point (fst X)\n   (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<Longrightarrow>\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "assume \"x = ?ml\""], ["proof (state)\nthis:\n  x = mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence ?ccw"], ["proof (prove)\nusing this:\n  x = mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y", "by (simp add: lmy)"], ["proof (state)\nthis:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "}"], ["proof (state)\nthis:\n  x =\n  mirror_point (fst X)\n   (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<Longrightarrow>\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  x =\n  mirror_point (fst X)\n   (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<Longrightarrow>\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "{"], ["proof (state)\nthis:\n  x =\n  mirror_point (fst X)\n   (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<Longrightarrow>\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "assume \"x \\<noteq> ?ml\" \"y = ?ml\""], ["proof (state)\nthis:\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  y = mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence ?ccw"], ["proof (prove)\nusing this:\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  y = mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y", "by (simp add: lxml)"], ["proof (state)\nthis:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<noteq>\n           mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)));\n   y =\n   mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<rbrakk>\n  \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<noteq>\n           mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)));\n   y =\n   mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<rbrakk>\n  \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "{"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<noteq>\n           mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)));\n   y =\n   mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<rbrakk>\n  \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "assume d3: \"x \\<noteq> ?ml\" \"y \\<noteq> ?ml\""], ["proof (state)\nthis:\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  y \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from \\<open>x \\<in> set _\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set (map snd (half_segments_of_aform X))", "have \"x \\<in> set (map snd (half_segments_of_aform X))\""], ["proof (prove)\nusing this:\n  x \\<in> set (map snd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. x \\<in> set (map snd (half_segments_of_aform X))", "by force"], ["proof (state)\nthis:\n  x \\<in> set (map snd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence \"x \\<in> set (tl (map fst (half_segments_of_aform X)))\""], ["proof (prove)\nusing this:\n  x \\<in> set (map snd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl (map fst (half_segments_of_aform X)))", "using d3"], ["proof (prove)\nusing this:\n  x \\<in> set (map snd (half_segments_of_aform X))\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  y \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl (map fst (half_segments_of_aform X)))", "unfolding map_snd_half_segments_aux_eq[OF neq_Nil(2)]"], ["proof (prove)\nusing this:\n  x \\<in> set (tl (map fst (half_segments_of_aform X)) @\n               [snd (last (half_segments_of_aform X))])\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  y \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl (map fst (half_segments_of_aform X)))", "by (auto simp: mirror_eq_last)"], ["proof (state)\nthis:\n  x \\<in> set (tl (map fst (half_segments_of_aform X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from distinct_in_set_tlD[OF this distinct_fst_half_segments]"], ["proof (chain)\npicking this:\n  x \\<noteq> hd (map fst (half_segments_of_aform X))", "have \"?l \\<noteq> x\""], ["proof (prove)\nusing this:\n  x \\<noteq> hd (map fst (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> x", "by (simp add: fst_hd_half_segments_of_aform neq_Nil hd_map)"], ["proof (state)\nthis:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from lxml[OF \\<open>x \\<noteq> ?ml\\<close>] \\<open>ccw' ?l ?ml y\\<close>"], ["proof (chain)\npicking this:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y", "have d4: \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by (rule neq_left_right_of lxml)"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"distinct5 x ?ml y r ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct5 x\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y r\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "using d1 d2 \\<open>?l \\<noteq> x\\<close> d3 d4"], ["proof (prove)\nusing this:\n  x \\<noteq> r\n  y \\<noteq> r\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> r\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<noteq>\n  r\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> y\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> x\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  y \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. distinct5 x\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y r\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by simp_all"], ["proof (state)\nthis:\n  distinct5 x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y r\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  distinct5 x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y r\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "note _"], ["proof (state)\nthis:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"lex x ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex x\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by (rule lex_half_segments_lowest_vertex) fact"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex x\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence \"ccw ?l r x\""], ["proof (prove)\nusing this:\n  Counterclockwise_2D_Arbitrary.lex x\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r x", "unfolding r_def"], ["proof (prove)\nusing this:\n  Counterclockwise_2D_Arbitrary.lex x\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (lowest_vertex (fst X, nlex_pdevs (snd X)) +\n      (0, \\<bar>snd x -\n                snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n          \\<bar>snd y -\n                snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n          \\<bar>snd (mirror_point (fst X)\n                      (lowest_vertex (fst X, nlex_pdevs (snd X)))) -\n                snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n          1))\n     x", "by (rule lex_ccw_left) simp"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"lex ?ml ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "using last_in_set[OF H[symmetric]]"], ["proof (prove)\nusing this:\n  last (half_segments_of_aform X) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by (auto simp: mirror_eq_last intro: lex_half_segments_lowest_vertex')"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence \"ccw ?l r ?ml\""], ["proof (prove)\nusing this:\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))", "unfolding r_def"], ["proof (prove)\nusing this:\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (lowest_vertex (fst X, nlex_pdevs (snd X)) +\n      (0, \\<bar>snd x -\n                snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n          \\<bar>snd y -\n                snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n          \\<bar>snd (mirror_point (fst X)\n                      (lowest_vertex (fst X, nlex_pdevs (snd X)))) -\n                snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n          1))\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))", "by (rule lex_ccw_left) simp"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"lex (?m (lowest_vertex (fst X, nlex_pdevs (snd X)))) (?m y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n     (mirror_point (fst X) y)", "using mirror_y"], ["proof (prove)\nusing this:\n  (b, mirror_point (fst X) y) \\<in> set (butlast (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n     (mirror_point (fst X) y)", "by (force dest!: in_set_butlastD intro: lex_half_segments_last' simp: mirror_eq_last )"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n   (mirror_point (fst X) y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence \"lex y ?l\""], ["proof (prove)\nusing this:\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n   (mirror_point (fst X) y)\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex y\n     (lowest_vertex (fst X, nlex_pdevs (snd X)))", "by (rule lex_mirror_point)"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex y\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence \"ccw ?l r y\""], ["proof (prove)\nusing this:\n  Counterclockwise_2D_Arbitrary.lex y\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r y", "unfolding r_def"], ["proof (prove)\nusing this:\n  Counterclockwise_2D_Arbitrary.lex y\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (lowest_vertex (fst X, nlex_pdevs (snd X)) +\n      (0, \\<bar>snd x -\n                snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n          \\<bar>snd y -\n                snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n          \\<bar>snd (mirror_point (fst X)\n                      (lowest_vertex (fst X, nlex_pdevs (snd X)))) -\n                snd (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<bar> +\n          1))\n     y", "by (rule lex_ccw_left) simp"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from \\<open>x \\<noteq> ?ml\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))", "have \"ccw ?l x ?ml\""], ["proof (prove)\nusing this:\n  x \\<noteq>\n  mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\n\ngoal (1 subgoal):\n 1. ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))", "by (simp add: ccw_def lxml)"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from lmy"], ["proof (chain)\npicking this:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y", "have \"ccw ?l ?ml y\""], ["proof (prove)\nusing this:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n\ngoal (1 subgoal):\n 1. ccw (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y", "by (simp add: ccw_def)"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "ultimately"], ["proof (chain)\npicking this:\n  distinct5 x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y r\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r x\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r y\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y", "have \"ccw ?l x y\""], ["proof (prove)\nusing this:\n  distinct5 x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y r\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r x\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) r y\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n\ngoal (1 subgoal):\n 1. ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x y", "by (rule ccw.transitive[where S=UNIV]) simp"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "{"], ["proof (state)\nthis:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"x \\<noteq> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> lowest_vertex (fst X, nlex_pdevs (snd X))", "using \\<open>?l \\<noteq> x\\<close>"], ["proof (prove)\nusing this:\n  lowest_vertex (fst X, nlex_pdevs (snd X)) \\<noteq> x\n\ngoal (1 subgoal):\n 1. x \\<noteq> lowest_vertex (fst X, nlex_pdevs (snd X))", "by simp"], ["proof (state)\nthis:\n  x \\<noteq> lowest_vertex (fst X, nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> lowest_vertex (fst X, nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "have \"lex (?m y) (?m ?ml)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex (mirror_point (fst X) y)\n     (mirror_point (fst X)\n       (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))))", "using mirror_y"], ["proof (prove)\nusing this:\n  (b, mirror_point (fst X) y) \\<in> set (butlast (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex (mirror_point (fst X) y)\n     (mirror_point (fst X)\n       (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))))", "by (force intro: lex_half_segments_lowest_vertex in_set_butlastD)"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex (mirror_point (fst X) y)\n   (mirror_point (fst X)\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "hence \"lex ?ml y\""], ["proof (prove)\nusing this:\n  Counterclockwise_2D_Arbitrary.lex (mirror_point (fst X) y)\n   (mirror_point (fst X)\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))))\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y", "by (rule lex_mirror_point)"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "from a"], ["proof (chain)\npicking this:\n  (a, x) \\<in> set (half_segments_of_aform X)", "have \"lex ?ml x\""], ["proof (prove)\nusing this:\n  (a, x) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) x", "unfolding mirror_eq_last"], ["proof (prove)\nusing this:\n  (a, x) \\<in> set (half_segments_of_aform X)\n\ngoal (1 subgoal):\n 1. Counterclockwise_2D_Arbitrary.lex\n     (snd (last (half_segments_of_aform X))) x", "by (rule lex_half_segments_last)"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "moreover"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "note \\<open>lex y ?l\\<close> \\<open>lex x ?l\\<close> \\<open>ccw' ?l x ?ml\\<close> \\<open>ccw' ?l ?ml y\\<close>"], ["proof (state)\nthis:\n  Counterclockwise_2D_Arbitrary.lex y\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  Counterclockwise_2D_Arbitrary.lex x\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> lowest_vertex (fst X, nlex_pdevs (snd X))\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) x\n  Counterclockwise_2D_Arbitrary.lex y\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  Counterclockwise_2D_Arbitrary.lex x\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y", "have ncoll: \"\\<not> coll ?l x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> lowest_vertex (fst X, nlex_pdevs (snd X))\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n  Counterclockwise_2D_Arbitrary.lex\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) x\n  Counterclockwise_2D_Arbitrary.lex y\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  Counterclockwise_2D_Arbitrary.lex x\n   (lowest_vertex (fst X, nlex_pdevs (snd X)))\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X))))\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))) y\n\ngoal (1 subgoal):\n 1. det3 (lowest_vertex (fst X, nlex_pdevs (snd X))) x y \\<noteq> 0", "by (rule not_coll_ordered_lexI)"], ["proof (state)\nthis:\n  det3 (lowest_vertex (fst X, nlex_pdevs (snd X))) x y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "}"], ["proof (state)\nthis:\n  det3 (lowest_vertex (fst X, nlex_pdevs (snd X))) x y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "ultimately"], ["proof (chain)\npicking this:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n  det3 (lowest_vertex (fst X, nlex_pdevs (snd X))) x y \\<noteq> 0", "have ?ccw"], ["proof (prove)\nusing this:\n  ccw (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n  det3 (lowest_vertex (fst X, nlex_pdevs (snd X))) x y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y", "by (simp add: ccw_def)"], ["proof (state)\nthis:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<noteq>\n           mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)));\n   y \\<noteq>\n   mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<rbrakk>\n  \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map snd (half_segments_of_aform X));\n        y \\<in> set (butlast\n                      (map (mirror_point (fst X) \\<circ> snd)\n                        (half_segments_of_aform X)))\\<rbrakk>\n       \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x\n                          y", "ultimately"], ["proof (chain)\npicking this:\n  x =\n  mirror_point (fst X)\n   (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<Longrightarrow>\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n  \\<lbrakk>x \\<noteq>\n           mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)));\n   y =\n   mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<rbrakk>\n  \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n  \\<lbrakk>x \\<noteq>\n           mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)));\n   y \\<noteq>\n   mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<rbrakk>\n  \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y", "show ?ccw"], ["proof (prove)\nusing this:\n  x =\n  mirror_point (fst X)\n   (lowest_vertex (fst X, nlex_pdevs (snd X))) \\<Longrightarrow>\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n  \\<lbrakk>x \\<noteq>\n           mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)));\n   y =\n   mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<rbrakk>\n  \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n  \\<lbrakk>x \\<noteq>\n           mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)));\n   y \\<noteq>\n   mirror_point (fst X) (lowest_vertex (fst X, nlex_pdevs (snd X)))\\<rbrakk>\n  \\<Longrightarrow> ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal (1 subgoal):\n 1. ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y", "by blast"], ["proof (state)\nthis:\n  ccw' (lowest_vertex (fst X, nlex_pdevs (snd X))) x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (map snd (half_segments_of_aform X) @\n    butlast\n     (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n\ngoal (1 subgoal):\n 1. [] \\<noteq> half_segments_of_aform X \\<Longrightarrow>\n    ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (map snd (half_segments_of_aform X) @\n    butlast\n     (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "using H"], ["proof (prove)\nusing this:\n  ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (map snd (half_segments_of_aform X) @\n    butlast\n     (map (mirror_point (fst X) \\<circ> snd) (half_segments_of_aform X)))\n  [] \\<noteq> half_segments_of_aform X\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "by (simp add: segments_of_aform_def Let_def butlast_append snd_compose_pairself)"], ["proof (state)\nthis:\n  ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n   (butlast (map snd (segments_of_aform X)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polychain_of_segments_of_aform1:\n  assumes \"length (segments_of_aform X) = 1\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  length (segments_of_aform X) = 1\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: segments_of_aform_def Let_def half_segments_of_aform_def add_is_1\n    split: if_split_asm)"], ["", "lemma polychain_of_segments_of_aform2:\n  assumes \"segments_of_aform X = [x, y]\"\n  assumes \"between (fst x, snd x) p\"\n  shows \"p \\<in> convex hull set (map fst (segments_of_aform X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (segments_of_aform X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (segments_of_aform X))", "from polychain_segments_of_aform[of X] segments_of_aform_closed[of X] assms"], ["proof (chain)\npicking this:\n  polychain (segments_of_aform X)\n  segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n  fst (hd (segments_of_aform X)) = snd (last (segments_of_aform X))\n  segments_of_aform X = [x, y]\n  between (fst x, snd x) p", "have \"fst y = snd x\" \"snd y = fst x\""], ["proof (prove)\nusing this:\n  polychain (segments_of_aform X)\n  segments_of_aform X \\<noteq> [] \\<Longrightarrow>\n  fst (hd (segments_of_aform X)) = snd (last (segments_of_aform X))\n  segments_of_aform X = [x, y]\n  between (fst x, snd x) p\n\ngoal (1 subgoal):\n 1. fst y = snd x &&& snd y = fst x", "by (simp_all add: polychain_def)"], ["proof (state)\nthis:\n  fst y = snd x\n  snd y = fst x\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (segments_of_aform X))", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst y = snd x\n  snd y = fst x\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (segments_of_aform X))", "using assms"], ["proof (prove)\nusing this:\n  fst y = snd x\n  snd y = fst x\n  segments_of_aform X = [x, y]\n  between (fst x, snd x) p\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (segments_of_aform X))", "by (cases x) (auto simp: between_mem_convex_hull)"], ["proof (state)\nthis:\n  p \\<in> convex hull set (map fst (segments_of_aform X))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma append_eq_2:\n  assumes \"length xs = length ys\"\n  shows \"xs @ ys = [x, y] \\<longleftrightarrow> xs = [x] \\<and> ys = [y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = length ys; xs = []\\<rbrakk>\n    \\<Longrightarrow> (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])\n 2. \\<And>a list.\n       \\<lbrakk>length xs = length ys; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])", "case (Cons z zs)"], ["proof (state)\nthis:\n  xs = z # zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = length ys; xs = []\\<rbrakk>\n    \\<Longrightarrow> (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])\n 2. \\<And>a list.\n       \\<lbrakk>length xs = length ys; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = z # zs\n\ngoal (1 subgoal):\n 1. (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])", "using assms"], ["proof (prove)\nusing this:\n  xs = z # zs\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])", "by (cases zs) auto"], ["proof (state)\nthis:\n  (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; xs = []\\<rbrakk>\n    \\<Longrightarrow> (xs @ ys = [x, y]) = (xs = [x] \\<and> ys = [y])", "qed simp"], ["", "lemma segments_of_aform_line_segment:\n  assumes \"segments_of_aform X = [x, y]\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"aform_val e X \\<in> closed_segment (fst x) (snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e X \\<in> closed_segment (fst x) (snd x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aform_val e X \\<in> closed_segment (fst x) (snd x)", "from pdevs_val_pdevs_of_list_inl2E[OF \\<open>e \\<in> _\\<close>, of \"snd X\"]"], ["proof (chain)\npicking this:\n  (\\<And>e'.\n      \\<lbrakk>pdevs_val e (snd X) =\n               pdevs_val e' (pdevs_of_list (inl (snd X)));\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e' where e': \"pdevs_val e (snd X) = pdevs_val e' (pdevs_of_list (inl (snd X)))\"\n    \"e' \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>e'.\n      \\<lbrakk>pdevs_val e (snd X) =\n               pdevs_val e' (pdevs_of_list (inl (snd X)));\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (snd X) =\n                 pdevs_val e' (pdevs_of_list (inl (snd X)));\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  pdevs_val e (snd X) = pdevs_val e' (pdevs_of_list (inl (snd X)))\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> closed_segment (fst x) (snd x)", "from e'"], ["proof (chain)\npicking this:\n  pdevs_val e (snd X) = pdevs_val e' (pdevs_of_list (inl (snd X)))\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"0 \\<le> 1 + e' 0\""], ["proof (prove)\nusing this:\n  pdevs_val e (snd X) = pdevs_val e' (pdevs_of_list (inl (snd X)))\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 + e' 0", "by (auto simp: Pi_iff dest!: spec[where x=0])"], ["proof (state)\nthis:\n  0 \\<le> 1 + e' 0\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> closed_segment (fst x) (snd x)", "with assms e'"], ["proof (chain)\npicking this:\n  segments_of_aform X = [x, y]\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  pdevs_val e (snd X) = pdevs_val e' (pdevs_of_list (inl (snd X)))\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  0 \\<le> 1 + e' 0", "show ?thesis"], ["proof (prove)\nusing this:\n  segments_of_aform X = [x, y]\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  pdevs_val e (snd X) = pdevs_val e' (pdevs_of_list (inl (snd X)))\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  0 \\<le> 1 + e' 0\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> closed_segment (fst x) (snd x)", "by (auto simp: segments_of_aform_def Let_def append_eq_2 half_segments_of_aform_def\n        polychain_of_singleton_iff mirror_point_def ccw.selsort_singleton_iff lowest_vertex_def\n        aform_val_def sum_list_nlex_eq_sum_list_inl closed_segment_def Pi_iff\n      intro!: exI[where x=\"(1 + e' 0) / 2\"])\n      (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  aform_val e X \\<in> closed_segment (fst x) (snd x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Continuous Generalization\\<close>"], ["", "lemma LIMSEQ_minus_fract_mult:\n  \"(\\<lambda>n. r * (1 - 1 / real (Suc (Suc n)))) \\<longlonglongrightarrow> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. r * (1 - 1 / real (Suc (Suc n))))\n    \\<longlonglongrightarrow> r", "by (rule tendsto_eq_rhs[OF tendsto_mult[where a=r and b = 1]])\n    (auto simp: inverse_eq_divide[symmetric] simp del: of_nat_Suc\n      intro: filterlim_compose[OF LIMSEQ_inverse_real_of_nat filterlim_Suc] tendsto_eq_intros)"], ["", "lemma det3_nonneg_segments_of_aform:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  shows \"list_all (\\<lambda>seg. det3 (fst seg) (snd seg) (aform_val e X) \\<ge> 0) (segments_of_aform X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) (aform_val e X))\n     (segments_of_aform X)", "unfolding list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>seg\\<in>set (segments_of_aform X).\n       0 \\<le> det3 (fst seg) (snd seg) (aform_val e X)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "fix a b c d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "assume seg: \"((a, b), c, d) \\<in> set (segments_of_aform X)\" (is \"?seg \\<in> _\")"], ["proof (state)\nthis:\n  ((a, b), c, d) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "define normal_of_segment\n    where \"normal_of_segment = (\\<lambda>((a0, a1), b0, b1). (b1 - a1, a0 - b0)::real*real)\""], ["proof (state)\nthis:\n  normal_of_segment = (\\<lambda>((a0, a1), b0, b1). (b1 - a1, a0 - b0))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "define support_of_segment\n    where \"support_of_segment = (\\<lambda>(a, b). normal_of_segment (a, b) \\<bullet> a)\""], ["proof (state)\nthis:\n  support_of_segment =\n  (\\<lambda>(a, b). normal_of_segment (a, b) \\<bullet> a)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "have \"closed ((\\<lambda>x. x \\<bullet> normal_of_segment ?seg) -` {..support_of_segment ?seg})\" (is \"closed ?cl\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\n     ((\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n      {..support_of_segment ((a, b), c, d)})", "by (auto intro!: continuous_intros closed_vimage)"], ["proof (state)\nthis:\n  closed\n   ((\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n    {..support_of_segment ((a, b), c, d)})\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "moreover"], ["proof (state)\nthis:\n  closed\n   ((\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n    {..support_of_segment ((a, b), c, d)})\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "define f where \"f n i = e i * ( 1 - 1 / (Suc (Suc n)))\" for n i"], ["proof (state)\nthis:\n  f ?n ?i = e ?i * (1 - 1 / real (Suc (Suc ?n)))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "have \"\\<forall>n. aform_val (f n) X \\<in> ?cl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       aform_val (f n) X\n       \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n             {..support_of_segment ((a, b), c, d)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       aform_val (f n) X\n       \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n             {..support_of_segment ((a, b), c, d)}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       aform_val (f n) X\n       \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n             {..support_of_segment ((a, b), c, d)}", "have \"f n \\<in> UNIV \\<rightarrow> {-1 <..< 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n \\<in> UNIV \\<rightarrow> {- 1<..<1}", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  length (half_segments_of_aform X) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. f n \\<in> UNIV \\<rightarrow> {- 1<..<1}", "by (auto simp: f_def Pi_iff intro!: less_one_multI minus_one_less_multI)"], ["proof (state)\nthis:\n  f n \\<in> UNIV \\<rightarrow> {- 1<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       aform_val (f n) X\n       \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n             {..support_of_segment ((a, b), c, d)}", "from list_allD[OF segments_of_aform_strict[OF this assms(2)] seg]"], ["proof (chain)\npicking this:\n  ccw' (fst ((a, b), c, d)) (snd ((a, b), c, d)) (aform_val (f n) X)", "show \"aform_val (f n) X \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n        {..support_of_segment ((a, b), c, d)}\""], ["proof (prove)\nusing this:\n  ccw' (fst ((a, b), c, d)) (snd ((a, b), c, d)) (aform_val (f n) X)\n\ngoal (1 subgoal):\n 1. aform_val (f n) X\n    \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n          {..support_of_segment ((a, b), c, d)}", "by (auto simp: list_all_iff normal_of_segment_def support_of_segment_def\n        det3_def' field_simps inner_prod_def ccw'_def)"], ["proof (state)\nthis:\n  aform_val (f n) X\n  \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n        {..support_of_segment ((a, b), c, d)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     aform_val (f n) X\n     \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n           {..support_of_segment ((a, b), c, d)}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "moreover"], ["proof (state)\nthis:\n  \\<forall>n.\n     aform_val (f n) X\n     \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n           {..support_of_segment ((a, b), c, d)}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "have \"\\<And>i. (\\<lambda>n. f n i) \\<longlonglongrightarrow> e i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. (\\<lambda>n. f n i) \\<longlonglongrightarrow> e i", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<lambda>n. e i * (1 - 1 / real (Suc (Suc n))))\n       \\<longlonglongrightarrow> e i", "by (rule LIMSEQ_minus_fract_mult)"], ["proof (state)\nthis:\n  (\\<lambda>n. f n ?i) \\<longlonglongrightarrow> e ?i\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "hence \"(\\<lambda>n. aform_val (f n) X) \\<longlonglongrightarrow> aform_val e X\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. f n ?i) \\<longlonglongrightarrow> e ?i\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. aform_val (f n) X) \\<longlonglongrightarrow> aform_val e X", "by (auto simp: aform_val_def pdevs_val_sum intro!: tendsto_intros)"], ["proof (state)\nthis:\n  (\\<lambda>n. aform_val (f n) X) \\<longlonglongrightarrow> aform_val e X\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "ultimately"], ["proof (chain)\npicking this:\n  closed\n   ((\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n    {..support_of_segment ((a, b), c, d)})\n  \\<forall>n.\n     aform_val (f n) X\n     \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n           {..support_of_segment ((a, b), c, d)}\n  (\\<lambda>n. aform_val (f n) X) \\<longlonglongrightarrow> aform_val e X", "have \"aform_val e X \\<in> ?cl\""], ["proof (prove)\nusing this:\n  closed\n   ((\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n    {..support_of_segment ((a, b), c, d)})\n  \\<forall>n.\n     aform_val (f n) X\n     \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n           {..support_of_segment ((a, b), c, d)}\n  (\\<lambda>n. aform_val (f n) X) \\<longlonglongrightarrow> aform_val e X\n\ngoal (1 subgoal):\n 1. aform_val e X\n    \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n          {..support_of_segment ((a, b), c, d)}", "by (rule closed_sequentially)"], ["proof (state)\nthis:\n  aform_val e X\n  \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n        {..support_of_segment ((a, b), c, d)}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       ((a, b), aa, ba) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n       0 \\<le> det3 (fst ((a, b), aa, ba)) (snd ((a, b), aa, ba))\n                (aform_val e X)", "thus \"det3 (fst ?seg) (snd ?seg) (aform_val e X) \\<ge> 0\""], ["proof (prove)\nusing this:\n  aform_val e X\n  \\<in> (\\<lambda>x. x \\<bullet> normal_of_segment ((a, b), c, d)) -`\n        {..support_of_segment ((a, b), c, d)}\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst ((a, b), c, d)) (snd ((a, b), c, d)) (aform_val e X)", "by (auto simp: list_all_iff normal_of_segment_def support_of_segment_def det3_def' field_simps\n      inner_prod_def)"], ["proof (state)\nthis:\n  0 \\<le> det3 (fst ((a, b), c, d)) (snd ((a, b), c, d)) (aform_val e X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det3_nonneg_segments_of_aformI:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"length (half_segments_of_aform X) \\<noteq> 1\"\n  assumes \"seg \\<in> set (segments_of_aform X)\"\n  shows \"det3 (fst seg) (snd seg) (aform_val e X) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst seg) (snd seg) (aform_val e X)", "using assms det3_nonneg_segments_of_aform"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  length (half_segments_of_aform X) \\<noteq> 1\n  seg \\<in> set (segments_of_aform X)\n  \\<lbrakk>?e \\<in> UNIV \\<rightarrow> {- 1..1};\n   length (half_segments_of_aform ?X) \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> list_all\n                     (\\<lambda>seg.\n                         0 \\<le> det3 (fst seg) (snd seg) (aform_val ?e ?X))\n                     (segments_of_aform ?X)\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst seg) (snd seg) (aform_val e X)", "by (auto simp: list_all_iff)"], ["", "subsection \\<open>Intersection of Vertical Line with Segment\\<close>"], ["", "fun intersect_segment_xline'::\"nat \\<Rightarrow> point * point \\<Rightarrow> real \\<Rightarrow> point option\"\n  where \"intersect_segment_xline' p ((x0, y0), (x1, y1)) xl =\n    (if x0 \\<le> xl \\<and> xl \\<le> x1 then\n      if x0 = x1 then Some ((min y0 y1), (max y0 y1))\n      else\n        let\n          yl = truncate_down p (truncate_down p (real_divl p (y1 - y0) (x1 - x0) * (xl - x0)) + y0);\n          yr = truncate_up p (truncate_up p (real_divr p (y1 - y0) (x1 - x0) * (xl - x0)) + y0)\n        in Some (yl, yr)\n    else None)\""], ["", "lemma norm_pair_fst0[simp]: \"norm (0, x) = norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (0::'a, x) = norm x", "by (auto simp: norm_prod_def)"], ["", "lemmas add_right_mono_le = order_trans[OF add_right_mono]"], ["", "lemmas mult_right_mono_le = order_trans[OF mult_right_mono]"], ["", "lemmas add_right_mono_ge = order_trans[OF _ add_right_mono]"], ["", "lemmas mult_right_mono_ge = order_trans[OF _ mult_right_mono]"], ["", "lemma dest_segment:\n  fixes x b::real\n  assumes \"(x, b) \\<in> closed_segment (x0, y0) (x1, y1)\"\n  assumes \"x0 \\<noteq> x1\"\n  shows \"b = (y1 - y0) * (x - x0) / (x1 - x0) + y0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = (y1 - y0) * (x - x0) / (x1 - x0) + y0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b = (y1 - y0) * (x - x0) / (x1 - x0) + y0", "from assms"], ["proof (chain)\npicking this:\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n  x0 \\<noteq> x1", "obtain u where u: \"x = x0 *\\<^sub>R (1 - u) + u * x1\" \"b = y0 *\\<^sub>R (1 - u) + u * y1\" \"0 \\<le> u\" \"u \\<le> 1\""], ["proof (prove)\nusing this:\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n  x0 \\<noteq> x1\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>x = x0 *\\<^sub>R (1 - u) + u * x1;\n         b = y0 *\\<^sub>R (1 - u) + u * y1; 0 \\<le> u; u \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: closed_segment_def algebra_simps)"], ["proof (state)\nthis:\n  x = x0 *\\<^sub>R (1 - u) + u * x1\n  b = y0 *\\<^sub>R (1 - u) + u * y1\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (1 subgoal):\n 1. b = (y1 - y0) * (x - x0) / (x1 - x0) + y0", "show \"b = (y1 - y0) * (x - x0) / (x1 - x0) + y0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = (y1 - y0) * (x - x0) / (x1 - x0) + y0", "using assms"], ["proof (prove)\nusing this:\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n  x0 \\<noteq> x1\n\ngoal (1 subgoal):\n 1. b = (y1 - y0) * (x - x0) / (x1 - x0) + y0", "by (auto simp: closed_segment_def field_simps u)"], ["proof (state)\nthis:\n  b = (y1 - y0) * (x - x0) / (x1 - x0) + y0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intersect_segment_xline':\n  assumes \"intersect_segment_xline' prec (p0, p1) x = Some (m, M)\"\n  shows \"closed_segment p0 p1 \\<inter> {p. fst p = x} \\<subseteq> {(x, m) .. (x, M)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "using assms"], ["proof (prove)\nusing this:\n  intersect_segment_xline' prec (p0, p1) x = Some (m, M)\n\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "proof (cases p0)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>intersect_segment_xline' prec (p0, p1) x = Some (m, M);\n        p0 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> closed_segment p0 p1 \\<inter> {p. fst p = x}\n                         \\<subseteq> {(x, m)..(x, M)}", "case (Pair x0 y0)"], ["proof (state)\nthis:\n  p0 = (x0, y0)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>intersect_segment_xline' prec (p0, p1) x = Some (m, M);\n        p0 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> closed_segment p0 p1 \\<inter> {p. fst p = x}\n                         \\<subseteq> {(x, m)..(x, M)}", "note p0 = this"], ["proof (state)\nthis:\n  p0 = (x0, y0)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>intersect_segment_xline' prec (p0, p1) x = Some (m, M);\n        p0 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> closed_segment p0 p1 \\<inter> {p. fst p = x}\n                         \\<subseteq> {(x, m)..(x, M)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "proof (cases p1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p1 = (a, b) \\<Longrightarrow>\n       closed_segment p0 p1 \\<inter> {p. fst p = x}\n       \\<subseteq> {(x, m)..(x, M)}", "case (Pair x1 y1)"], ["proof (state)\nthis:\n  p1 = (x1, y1)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p1 = (a, b) \\<Longrightarrow>\n       closed_segment p0 p1 \\<inter> {p. fst p = x}\n       \\<subseteq> {(x, m)..(x, M)}", "note p1 = this"], ["proof (state)\nthis:\n  p1 = (x1, y1)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p1 = (a, b) \\<Longrightarrow>\n       closed_segment p0 p1 \\<inter> {p. fst p = x}\n       \\<subseteq> {(x, m)..(x, M)}", "{"], ["proof (state)\nthis:\n  p1 = (x1, y1)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p1 = (a, b) \\<Longrightarrow>\n       closed_segment p0 p1 \\<inter> {p. fst p = x}\n       \\<subseteq> {(x, m)..(x, M)}", "assume \"x0 = x1\" \"x = x1\" \"m = min y0 y1\" \"M = max y0 y1\""], ["proof (state)\nthis:\n  x0 = x1\n  x = x1\n  m = min y0 y1\n  M = max y0 y1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p1 = (a, b) \\<Longrightarrow>\n       closed_segment p0 p1 \\<inter> {p. fst p = x}\n       \\<subseteq> {(x, m)..(x, M)}", "hence ?thesis"], ["proof (prove)\nusing this:\n  x0 = x1\n  x = x1\n  m = min y0 y1\n  M = max y0 y1\n\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "by (force simp: abs_le_iff p0 p1 min_def max_def algebra_simps dest: segment_bound\n          split: if_split_asm)"], ["proof (state)\nthis:\n  closed_segment p0 p1 \\<inter> {p. fst p = x} \\<subseteq> {(x, m)..(x, M)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p1 = (a, b) \\<Longrightarrow>\n       closed_segment p0 p1 \\<inter> {p. fst p = x}\n       \\<subseteq> {(x, m)..(x, M)}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>x0 = x1; x = x1; m = min y0 y1; M = max y0 y1\\<rbrakk>\n  \\<Longrightarrow> closed_segment p0 p1 \\<inter> {p. fst p = x}\n                    \\<subseteq> {(x, m)..(x, M)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p1 = (a, b) \\<Longrightarrow>\n       closed_segment p0 p1 \\<inter> {p. fst p = x}\n       \\<subseteq> {(x, m)..(x, M)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x0 = x1; x = x1; m = min y0 y1; M = max y0 y1\\<rbrakk>\n  \\<Longrightarrow> closed_segment p0 p1 \\<inter> {p. fst p = x}\n                    \\<subseteq> {(x, m)..(x, M)}\n\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>x0 = x1; x = x1; m = min y0 y1; M = max y0 y1\\<rbrakk>\n  \\<Longrightarrow> closed_segment p0 p1 \\<inter> {p. fst p = x}\n                    \\<subseteq> {(x, m)..(x, M)}\n  intersect_segment_xline' prec (p0, p1) x = Some (m, M)\n\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "by (auto simp: abs_le_iff p0 p1 split: if_split_asm\n        intro!: truncate_up_le truncate_down_le\n        add_right_mono_le[OF truncate_down]\n        add_right_mono_le[OF real_divl]\n        add_right_mono_le[OF mult_right_mono_le[OF real_divl]]\n        add_right_mono_ge[OF _ truncate_up]\n        add_right_mono_ge[OF _ mult_right_mono_ge[OF _ real_divr]]\n        dest!: dest_segment)"], ["proof (state)\nthis:\n  closed_segment p0 p1 \\<inter> {p. fst p = x} \\<subseteq> {(x, m)..(x, M)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed_segment p0 p1 \\<inter> {p. fst p = x} \\<subseteq> {(x, m)..(x, M)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  in_segment_fst_le:\n  fixes x0 x1 b::real\n  assumes \"x0 \\<le> x1\" \"(x, b) \\<in> closed_segment (x0, y0) (x1, y1)\"\n  shows \"x \\<le> x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x1", "using assms"], ["proof (prove)\nusing this:\n  x0 \\<le> x1\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n\ngoal (1 subgoal):\n 1. x \\<le> x1", "using mult_left_mono[OF \\<open>x0 \\<le> x1\\<close>, where c=\"1 - u\" for u]"], ["proof (prove)\nusing this:\n  x0 \\<le> x1\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n  0 \\<le> 1 - ?u2 \\<Longrightarrow> (1 - ?u2) * x0 \\<le> (1 - ?u2) * x1\n\ngoal (1 subgoal):\n 1. x \\<le> x1", "by (force simp add: min_def max_def split: if_split_asm\n    simp add: algebra_simps not_le closed_segment_def)"], ["", "lemma\n  in_segment_fst_ge:\n  fixes x0 x1 b::real\n  assumes \"x0 \\<le> x1\" \"(x, b) \\<in> closed_segment (x0, y0) (x1, y1)\"\n  shows \"x0 \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 \\<le> x", "using assms"], ["proof (prove)\nusing this:\n  x0 \\<le> x1\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n\ngoal (1 subgoal):\n 1. x0 \\<le> x", "using mult_left_mono[OF \\<open>x0 \\<le> x1\\<close>]"], ["proof (prove)\nusing this:\n  x0 \\<le> x1\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n  0 \\<le> ?c \\<Longrightarrow> ?c * x0 \\<le> ?c * x1\n\ngoal (1 subgoal):\n 1. x0 \\<le> x", "by (force simp add: min_def max_def split: if_split_asm\n    simp add: algebra_simps not_le closed_segment_def)"], ["", "lemma intersect_segment_xline'_eq_None:\n  assumes \"intersect_segment_xline' prec (p0, p1) x = None\"\n  assumes \"fst p0 \\<le> fst p1\"\n  shows \"closed_segment p0 p1 \\<inter> {p. fst p = x} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x} = {}", "using assms"], ["proof (prove)\nusing this:\n  intersect_segment_xline' prec (p0, p1) x = None\n  fst p0 \\<le> fst p1\n\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x} = {}", "by (cases p0, cases p1)\n    (auto simp: abs_le_iff split: if_split_asm dest: in_segment_fst_le in_segment_fst_ge)"], ["", "fun intersect_segment_xline\n  where \"intersect_segment_xline prec ((a, b), (c, d)) x =\n  (if a \\<le> c then intersect_segment_xline' prec ((a, b), (c, d)) x\n  else intersect_segment_xline' prec ((c, d), (a, b)) x)\""], ["", "lemma closed_segment_commute: \"closed_segment a b = closed_segment b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment a b = closed_segment b a", "by (meson convex_contains_segment convex_closed_segment dual_order.antisym ends_in_segment)"], ["", "lemma intersect_segment_xline:\n  assumes \"intersect_segment_xline prec (p0, p1) x = Some (m, M)\"\n  shows \"closed_segment p0 p1 \\<inter> {p. fst p = x} \\<subseteq> {(x, m) .. (x, M)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "using assms"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec (p0, p1) x = Some (m, M)\n\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "by (cases p0, cases p1)\n    (auto simp: closed_segment_commute split: if_split_asm simp del: intersect_segment_xline'.simps\n      dest!: intersect_segment_xline')"], ["", "lemma intersect_segment_xline_fst_snd:\n  assumes \"intersect_segment_xline prec seg x = Some (m, M)\"\n  shows \"closed_segment (fst seg) (snd seg) \\<inter> {p. fst p = x} \\<subseteq> {(x, m) .. (x, M)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment (fst seg) (snd seg) \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "using intersect_segment_xline[of prec \"fst seg\" \"snd seg\" x m M] assms"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec (fst seg, snd seg) x =\n  Some (m, M) \\<Longrightarrow>\n  closed_segment (fst seg) (snd seg) \\<inter> {p. fst p = x}\n  \\<subseteq> {(x, m)..(x, M)}\n  intersect_segment_xline prec seg x = Some (m, M)\n\ngoal (1 subgoal):\n 1. closed_segment (fst seg) (snd seg) \\<inter> {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "by simp"], ["", "lemma intersect_segment_xline_eq_None:\n  assumes \"intersect_segment_xline prec (p0, p1) x = None\"\n  shows \"closed_segment p0 p1 \\<inter> {p. fst p = x} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x} = {}", "using assms"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec (p0, p1) x = None\n\ngoal (1 subgoal):\n 1. closed_segment p0 p1 \\<inter> {p. fst p = x} = {}", "by (cases p0, cases p1)\n     (auto simp: closed_segment_commute split: if_split_asm simp del: intersect_segment_xline'.simps\n      dest!: intersect_segment_xline'_eq_None)"], ["", "lemma inter_image_empty_iff: \"(X \\<inter> {p. f p = x} = {}) \\<longleftrightarrow> (x \\<notin> f ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<inter> {p. f p = x} = {}) = (x \\<notin> f ` X)", "by auto"], ["", "lemma fst_closed_segment[simp]: \"fst ` closed_segment a b = closed_segment (fst a) (fst b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` closed_segment a b = closed_segment (fst a) (fst b)", "by (force simp: closed_segment_def)"], ["", "lemma intersect_segment_xline_eq_empty:\n  fixes p0 p1::\"real * real\"\n  assumes \"closed_segment p0 p1 \\<inter> {p. fst p = x} = {}\"\n  shows \"intersect_segment_xline prec (p0, p1) x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intersect_segment_xline prec (p0, p1) x = None", "using assms"], ["proof (prove)\nusing this:\n  closed_segment p0 p1 \\<inter> {p. fst p = x} = {}\n\ngoal (1 subgoal):\n 1. intersect_segment_xline prec (p0, p1) x = None", "by (cases p0, cases p1)\n    (auto simp: inter_image_empty_iff closed_segment_eq_real_ivl split: if_split_asm)"], ["", "lemma intersect_segment_xline_le:\n  assumes \"intersect_segment_xline prec y xl = Some (m0, M0)\"\n  shows \"m0 \\<le> M0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m0 \\<le> M0", "using assms"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec y xl = Some (m0, M0)\n\ngoal (1 subgoal):\n 1. m0 \\<le> M0", "by (cases y) (auto simp: min_def split: if_split_asm intro!: truncate_up_le truncate_down_le\n    order_trans[OF real_divl] order_trans[OF _ real_divr] mult_right_mono)"], ["", "lemma intersect_segment_xline_None_iff:\n  fixes p0 p1::\"real * real\"\n  shows \"intersect_segment_xline prec (p0, p1) x = None \\<longleftrightarrow> closed_segment p0 p1 \\<inter> {p. fst p = x} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (intersect_segment_xline prec (p0, p1) x = None) =\n    (closed_segment p0 p1 \\<inter> {p. fst p = x} = {})", "by (auto intro!: intersect_segment_xline_eq_empty dest!: intersect_segment_xline_eq_None)"], ["", "subsection \\<open>Bounds on Vertical Intersection with Oriented List of Segments\\<close>"], ["", "primrec bound_intersect_2d where\n  \"bound_intersect_2d prec [] x = None\"\n| \"bound_intersect_2d prec (X # Xs) xl =\n    (case bound_intersect_2d prec Xs xl of\n      None \\<Rightarrow> intersect_segment_xline prec X xl\n    | Some (m, M) \\<Rightarrow>\n      (case intersect_segment_xline prec X xl of\n        None \\<Rightarrow> Some (m, M)\n      | Some (m', M') \\<Rightarrow> Some (min m' m, max M' M)))\""], ["", "lemma\n  bound_intersect_2d_eq_None:\n  assumes \"bound_intersect_2d prec Xs x = None\"\n  assumes \"X \\<in> set Xs\"\n  shows \"intersect_segment_xline prec X x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intersect_segment_xline prec X x = None", "using assms"], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = None\n  X \\<in> set Xs\n\ngoal (1 subgoal):\n 1. intersect_segment_xline prec X x = None", "by (induct Xs) (auto split: option.split_asm)"], ["", "lemma bound_intersect_2d_upper:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\"\n  obtains X m' where \"X \\<in> set Xs\" \"intersect_segment_xline prec X x = Some (m', M)\"\n    \"\\<And>X m' M' . X \\<in> set Xs \\<Longrightarrow> intersect_segment_xline prec X x = Some (m', M') \\<Longrightarrow> M' \\<le> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X m'.\n        \\<lbrakk>X \\<in> set Xs;\n         intersect_segment_xline prec X x = Some (m', M);\n         \\<And>X m' M'.\n            \\<lbrakk>X \\<in> set Xs;\n             intersect_segment_xline prec X x = Some (m', M')\\<rbrakk>\n            \\<Longrightarrow> M' \\<le> M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>X m'.\n       X \\<in> set Xs \\<and>\n       intersect_segment_xline prec X x = Some (m', M) \\<and>\n       (\\<forall>X m' M'.\n           X \\<in> set Xs \\<longrightarrow>\n           intersect_segment_xline prec X x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "show \"\\<exists>X m'. X \\<in> set Xs \\<and> intersect_segment_xline prec X x = Some (m', M) \\<and>\n    (\\<forall>X m' M'. X \\<in> set Xs \\<longrightarrow> intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow> M' \\<le> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X m'.\n       X \\<in> set Xs \\<and>\n       intersect_segment_xline prec X x = Some (m', M) \\<and>\n       (\\<forall>X m' M'.\n           X \\<in> set Xs \\<longrightarrow>\n           intersect_segment_xline prec X x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "using assms"], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = Some (m, M)\n\ngoal (1 subgoal):\n 1. \\<exists>X m'.\n       X \\<in> set Xs \\<and>\n       intersect_segment_xline prec X x = Some (m', M) \\<and>\n       (\\<forall>X m' M'.\n           X \\<in> set Xs \\<longrightarrow>\n           intersect_segment_xline prec X x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "proof (induct Xs arbitrary: m M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m M.\n       bound_intersect_2d prec [] x = Some (m, M) \\<Longrightarrow>\n       \\<exists>X m'.\n          X \\<in> set [] \\<and>\n          intersect_segment_xline prec X x = Some (m', M) \\<and>\n          (\\<forall>X m' M'.\n              X \\<in> set [] \\<longrightarrow>\n              intersect_segment_xline prec X x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)\n 2. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X m'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m', M) \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          M' \\<le> M);\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X m'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m', M) \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                M' \\<le> M)", "case Nil"], ["proof (state)\nthis:\n  bound_intersect_2d prec [] x = Some (m, M)\n\ngoal (2 subgoals):\n 1. \\<And>m M.\n       bound_intersect_2d prec [] x = Some (m, M) \\<Longrightarrow>\n       \\<exists>X m'.\n          X \\<in> set [] \\<and>\n          intersect_segment_xline prec X x = Some (m', M) \\<and>\n          (\\<forall>X m' M'.\n              X \\<in> set [] \\<longrightarrow>\n              intersect_segment_xline prec X x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)\n 2. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X m'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m', M) \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          M' \\<le> M);\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X m'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m', M) \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                M' \\<le> M)", "thus ?case"], ["proof (prove)\nusing this:\n  bound_intersect_2d prec [] x = Some (m, M)\n\ngoal (1 subgoal):\n 1. \\<exists>X m'.\n       X \\<in> set [] \\<and>\n       intersect_segment_xline prec X x = Some (m', M) \\<and>\n       (\\<forall>X m' M'.\n           X \\<in> set [] \\<longrightarrow>\n           intersect_segment_xline prec X x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "by (simp add: bound_intersect_2d_def)"], ["proof (state)\nthis:\n  \\<exists>X m'.\n     X \\<in> set [] \\<and>\n     intersect_segment_xline prec X x = Some (m', M) \\<and>\n     (\\<forall>X m' M'.\n         X \\<in> set [] \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow>\n         M' \\<le> M)\n\ngoal (1 subgoal):\n 1. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X m'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m', M) \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          M' \\<le> M);\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X m'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m', M) \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                M' \\<le> M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X m'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m', M) \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          M' \\<le> M);\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X m'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m', M) \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                M' \\<le> M)", "case (Cons X Xs)"], ["proof (state)\nthis:\n  bound_intersect_2d prec Xs x = Some (?m, ?M) \\<Longrightarrow>\n  \\<exists>X m'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (m', ?M) \\<and>\n     (\\<forall>X m' M'.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow>\n         M' \\<le> ?M)\n  bound_intersect_2d prec (X # Xs) x = Some (m, M)\n\ngoal (1 subgoal):\n 1. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X m'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m', M) \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          M' \\<le> M);\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X m'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m', M) \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                M' \\<le> M)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "proof (cases \"bound_intersect_2d prec Xs x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bound_intersect_2d prec Xs x = None \\<Longrightarrow>\n    \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)\n 2. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "case None"], ["proof (state)\nthis:\n  bound_intersect_2d prec Xs x = None\n\ngoal (2 subgoals):\n 1. bound_intersect_2d prec Xs x = None \\<Longrightarrow>\n    \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)\n 2. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = None\n\ngoal (1 subgoal):\n 1. \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "using Cons"], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = None\n  bound_intersect_2d prec Xs x = Some (?m, ?M) \\<Longrightarrow>\n  \\<exists>X m'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (m', ?M) \\<and>\n     (\\<forall>X m' M'.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow>\n         M' \\<le> ?M)\n  bound_intersect_2d prec (X # Xs) x = Some (m, M)\n\ngoal (1 subgoal):\n 1. \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "by (intro exI[where x=X] exI[where x=m])\n          (simp del: intersect_segment_xline.simps add: bound_intersect_2d_eq_None)"], ["proof (state)\nthis:\n  \\<exists>Xa m'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         M' \\<le> M)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "case (Some mM)"], ["proof (state)\nthis:\n  bound_intersect_2d prec Xs x = Some mM\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "note Some1=this"], ["proof (state)\nthis:\n  bound_intersect_2d prec Xs x = Some mM\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "then"], ["proof (chain)\npicking this:\n  bound_intersect_2d prec Xs x = Some mM", "obtain m' M' where mM: \"mM = (m', M')\""], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = Some mM\n\ngoal (1 subgoal):\n 1. (\\<And>m' M'. mM = (m', M') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mM)"], ["proof (state)\nthis:\n  mM = (m', M')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "from Cons(1)[OF Some[unfolded mM]]"], ["proof (chain)\npicking this:\n  \\<exists>X m'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (m', M') \\<and>\n     (\\<forall>X m' M'a.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M'a) \\<longrightarrow>\n         M'a \\<le> M')", "obtain X' m'' where X': \"X' \\<in> set Xs\"\n        and m'': \"intersect_segment_xline prec X' x = Some (m'', M')\"\n        and max: \"\\<And>X m' M'a. X \\<in> set Xs \\<Longrightarrow> intersect_segment_xline prec X x = Some (m', M'a) \\<Longrightarrow>\n          M'a \\<le> M'\""], ["proof (prove)\nusing this:\n  \\<exists>X m'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (m', M') \\<and>\n     (\\<forall>X m' M'a.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M'a) \\<longrightarrow>\n         M'a \\<le> M')\n\ngoal (1 subgoal):\n 1. (\\<And>X' m''.\n        \\<lbrakk>X' \\<in> set Xs;\n         intersect_segment_xline prec X' x = Some (m'', M');\n         \\<And>X m' M'a.\n            \\<lbrakk>X \\<in> set Xs;\n             intersect_segment_xline prec X x = Some (m', M'a)\\<rbrakk>\n            \\<Longrightarrow> M'a \\<le> M'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X' \\<in> set Xs\n  intersect_segment_xline prec X' x = Some (m'', M')\n  \\<lbrakk>?X \\<in> set Xs;\n   intersect_segment_xline prec ?X x = Some (?m', ?M'a)\\<rbrakk>\n  \\<Longrightarrow> ?M'a \\<le> M'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "proof (cases \"intersect_segment_xline prec X x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. intersect_segment_xline prec X x = None \\<Longrightarrow>\n    \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)\n 2. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "case None"], ["proof (state)\nthis:\n  intersect_segment_xline prec X x = None\n\ngoal (2 subgoals):\n 1. intersect_segment_xline prec X x = None \\<Longrightarrow>\n    \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)\n 2. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X x = None\n\ngoal (1 subgoal):\n 1. \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "using Some1 mM Cons(2) X' m'' max"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X x = None\n  bound_intersect_2d prec Xs x = Some mM\n  mM = (m', M')\n  bound_intersect_2d prec (X # Xs) x = Some (m, M)\n  X' \\<in> set Xs\n  intersect_segment_xline prec X' x = Some (m'', M')\n  \\<lbrakk>?X \\<in> set Xs;\n   intersect_segment_xline prec ?X x = Some (?m', ?M'a)\\<rbrakk>\n  \\<Longrightarrow> ?M'a \\<le> M'\n\ngoal (1 subgoal):\n 1. \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "by (intro exI[where x= X'] exI[where x= m''])\n            (auto simp del: intersect_segment_xline.simps split: option.split_asm)"], ["proof (state)\nthis:\n  \\<exists>Xa m'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         M' \\<le> M)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "case (Some mM''')"], ["proof (state)\nthis:\n  intersect_segment_xline prec X x = Some mM'''\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa m'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              M' \\<le> M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X x = Some mM'''\n\ngoal (1 subgoal):\n 1. \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "using Some1 mM Cons(2) X' m''"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X x = Some mM'''\n  bound_intersect_2d prec Xs x = Some mM\n  mM = (m', M')\n  bound_intersect_2d prec (X # Xs) x = Some (m, M)\n  X' \\<in> set Xs\n  intersect_segment_xline prec X' x = Some (m'', M')\n\ngoal (1 subgoal):\n 1. \\<exists>Xa m'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           M' \\<le> M)", "by (cases mM''')\n            (force simp: max_def min_def simp del: intersect_segment_xline.simps\n              split: option.split_asm if_split_asm dest!: max\n              intro!: exI[where x= \"if M' \\<ge> snd mM''' then X' else X\"]\n              exI[where x= \"if M' \\<ge> snd mM''' then m'' else fst mM'''\"])"], ["proof (state)\nthis:\n  \\<exists>Xa m'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         M' \\<le> M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Xa m'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         M' \\<le> M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Xa m'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m', M) \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         M' \\<le> M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X m'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (m', M) \\<and>\n     (\\<forall>X m' M'.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow>\n         M' \\<le> M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_intersect_2d_lower:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\"\n  obtains X M' where \"X \\<in> set Xs\" \"intersect_segment_xline prec X x = Some (m, M')\"\n    \"\\<And>X m' M' . X \\<in> set Xs \\<Longrightarrow> intersect_segment_xline prec X x = Some (m', M') \\<Longrightarrow> m \\<le> m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X M'.\n        \\<lbrakk>X \\<in> set Xs;\n         intersect_segment_xline prec X x = Some (m, M');\n         \\<And>X m' M'.\n            \\<lbrakk>X \\<in> set Xs;\n             intersect_segment_xline prec X x = Some (m', M')\\<rbrakk>\n            \\<Longrightarrow> m \\<le> m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>X M'.\n       X \\<in> set Xs \\<and>\n       intersect_segment_xline prec X x = Some (m, M') \\<and>\n       (\\<forall>X m' M'.\n           X \\<in> set Xs \\<longrightarrow>\n           intersect_segment_xline prec X x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "show \"\\<exists>X M'. X \\<in> set Xs \\<and> intersect_segment_xline prec X x = Some (m, M') \\<and>\n    (\\<forall>X m' M'. X \\<in> set Xs \\<longrightarrow> intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow> m \\<le> m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X M'.\n       X \\<in> set Xs \\<and>\n       intersect_segment_xline prec X x = Some (m, M') \\<and>\n       (\\<forall>X m' M'.\n           X \\<in> set Xs \\<longrightarrow>\n           intersect_segment_xline prec X x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "using assms"], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = Some (m, M)\n\ngoal (1 subgoal):\n 1. \\<exists>X M'.\n       X \\<in> set Xs \\<and>\n       intersect_segment_xline prec X x = Some (m, M') \\<and>\n       (\\<forall>X m' M'.\n           X \\<in> set Xs \\<longrightarrow>\n           intersect_segment_xline prec X x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "proof (induct Xs arbitrary: m M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m M.\n       bound_intersect_2d prec [] x = Some (m, M) \\<Longrightarrow>\n       \\<exists>X M'.\n          X \\<in> set [] \\<and>\n          intersect_segment_xline prec X x = Some (m, M') \\<and>\n          (\\<forall>X m' M'.\n              X \\<in> set [] \\<longrightarrow>\n              intersect_segment_xline prec X x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')\n 2. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X M'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m, M') \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          m \\<le> m');\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X M'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m, M') \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                m \\<le> m')", "case Nil"], ["proof (state)\nthis:\n  bound_intersect_2d prec [] x = Some (m, M)\n\ngoal (2 subgoals):\n 1. \\<And>m M.\n       bound_intersect_2d prec [] x = Some (m, M) \\<Longrightarrow>\n       \\<exists>X M'.\n          X \\<in> set [] \\<and>\n          intersect_segment_xline prec X x = Some (m, M') \\<and>\n          (\\<forall>X m' M'.\n              X \\<in> set [] \\<longrightarrow>\n              intersect_segment_xline prec X x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')\n 2. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X M'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m, M') \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          m \\<le> m');\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X M'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m, M') \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                m \\<le> m')", "thus ?case"], ["proof (prove)\nusing this:\n  bound_intersect_2d prec [] x = Some (m, M)\n\ngoal (1 subgoal):\n 1. \\<exists>X M'.\n       X \\<in> set [] \\<and>\n       intersect_segment_xline prec X x = Some (m, M') \\<and>\n       (\\<forall>X m' M'.\n           X \\<in> set [] \\<longrightarrow>\n           intersect_segment_xline prec X x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "by (simp add: bound_intersect_2d_def)"], ["proof (state)\nthis:\n  \\<exists>X M'.\n     X \\<in> set [] \\<and>\n     intersect_segment_xline prec X x = Some (m, M') \\<and>\n     (\\<forall>X m' M'.\n         X \\<in> set [] \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow>\n         m \\<le> m')\n\ngoal (1 subgoal):\n 1. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X M'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m, M') \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          m \\<le> m');\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X M'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m, M') \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                m \\<le> m')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X M'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m, M') \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          m \\<le> m');\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X M'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m, M') \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                m \\<le> m')", "case (Cons X Xs)"], ["proof (state)\nthis:\n  bound_intersect_2d prec Xs x = Some (?m, ?M) \\<Longrightarrow>\n  \\<exists>X M'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (?m, M') \\<and>\n     (\\<forall>X m' M'.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow>\n         ?m \\<le> m')\n  bound_intersect_2d prec (X # Xs) x = Some (m, M)\n\ngoal (1 subgoal):\n 1. \\<And>a Xs m M.\n       \\<lbrakk>\\<And>m M.\n                   bound_intersect_2d prec Xs x =\n                   Some (m, M) \\<Longrightarrow>\n                   \\<exists>X M'.\n                      X \\<in> set Xs \\<and>\n                      intersect_segment_xline prec X x = Some (m, M') \\<and>\n                      (\\<forall>X m' M'.\n                          X \\<in> set Xs \\<longrightarrow>\n                          intersect_segment_xline prec X x =\n                          Some (m', M') \\<longrightarrow>\n                          m \\<le> m');\n        bound_intersect_2d prec (a # Xs) x = Some (m, M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X M'.\n                            X \\<in> set (a # Xs) \\<and>\n                            intersect_segment_xline prec X x =\n                            Some (m, M') \\<and>\n                            (\\<forall>X m' M'.\n                                X \\<in> set (a # Xs) \\<longrightarrow>\n                                intersect_segment_xline prec X x =\n                                Some (m', M') \\<longrightarrow>\n                                m \\<le> m')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "proof (cases \"bound_intersect_2d prec Xs x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bound_intersect_2d prec Xs x = None \\<Longrightarrow>\n    \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')\n 2. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "case None"], ["proof (state)\nthis:\n  bound_intersect_2d prec Xs x = None\n\ngoal (2 subgoals):\n 1. bound_intersect_2d prec Xs x = None \\<Longrightarrow>\n    \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')\n 2. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "thus ?thesis"], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = None\n\ngoal (1 subgoal):\n 1. \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "using Cons"], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = None\n  bound_intersect_2d prec Xs x = Some (?m, ?M) \\<Longrightarrow>\n  \\<exists>X M'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (?m, M') \\<and>\n     (\\<forall>X m' M'.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow>\n         ?m \\<le> m')\n  bound_intersect_2d prec (X # Xs) x = Some (m, M)\n\ngoal (1 subgoal):\n 1. \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "by (intro exI[where x= X])\n          (simp del: intersect_segment_xline.simps add: bound_intersect_2d_eq_None)"], ["proof (state)\nthis:\n  \\<exists>Xa M'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         m \\<le> m')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "case (Some mM)"], ["proof (state)\nthis:\n  bound_intersect_2d prec Xs x = Some mM\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "note Some1=this"], ["proof (state)\nthis:\n  bound_intersect_2d prec Xs x = Some mM\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "then"], ["proof (chain)\npicking this:\n  bound_intersect_2d prec Xs x = Some mM", "obtain m' M' where mM: \"mM = (m', M')\""], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = Some mM\n\ngoal (1 subgoal):\n 1. (\\<And>m' M'. mM = (m', M') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mM)"], ["proof (state)\nthis:\n  mM = (m', M')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "from Cons(1)[OF Some[unfolded mM]]"], ["proof (chain)\npicking this:\n  \\<exists>X M'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (m', M') \\<and>\n     (\\<forall>X m'a M'.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m'a, M') \\<longrightarrow>\n         m' \\<le> m'a)", "obtain X' M'' where X': \"X' \\<in> set Xs\"\n        and M'': \"intersect_segment_xline prec X' x = Some (m', M'')\"\n        and min: \"\\<And>X m'a M'. X \\<in> set Xs \\<Longrightarrow> intersect_segment_xline prec X x = Some (m'a, M') \\<Longrightarrow>\n          m' \\<le> m'a\""], ["proof (prove)\nusing this:\n  \\<exists>X M'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (m', M') \\<and>\n     (\\<forall>X m'a M'.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m'a, M') \\<longrightarrow>\n         m' \\<le> m'a)\n\ngoal (1 subgoal):\n 1. (\\<And>X' M''.\n        \\<lbrakk>X' \\<in> set Xs;\n         intersect_segment_xline prec X' x = Some (m', M'');\n         \\<And>X m'a M'.\n            \\<lbrakk>X \\<in> set Xs;\n             intersect_segment_xline prec X x = Some (m'a, M')\\<rbrakk>\n            \\<Longrightarrow> m' \\<le> m'a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X' \\<in> set Xs\n  intersect_segment_xline prec X' x = Some (m', M'')\n  \\<lbrakk>?X \\<in> set Xs;\n   intersect_segment_xline prec ?X x = Some (?m'a, ?M')\\<rbrakk>\n  \\<Longrightarrow> m' \\<le> ?m'a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bound_intersect_2d prec Xs x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "proof (cases \"intersect_segment_xline prec X x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. intersect_segment_xline prec X x = None \\<Longrightarrow>\n    \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')\n 2. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "case None"], ["proof (state)\nthis:\n  intersect_segment_xline prec X x = None\n\ngoal (2 subgoals):\n 1. intersect_segment_xline prec X x = None \\<Longrightarrow>\n    \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')\n 2. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "thus ?thesis"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X x = None\n\ngoal (1 subgoal):\n 1. \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "using Some1 mM Cons(2) X' M'' min"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X x = None\n  bound_intersect_2d prec Xs x = Some mM\n  mM = (m', M')\n  bound_intersect_2d prec (X # Xs) x = Some (m, M)\n  X' \\<in> set Xs\n  intersect_segment_xline prec X' x = Some (m', M'')\n  \\<lbrakk>?X \\<in> set Xs;\n   intersect_segment_xline prec ?X x = Some (?m'a, ?M')\\<rbrakk>\n  \\<Longrightarrow> m' \\<le> ?m'a\n\ngoal (1 subgoal):\n 1. \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "by (intro exI[where x= X'] exI[where x= M''])\n            (auto simp del: intersect_segment_xline.simps split: option.split_asm)"], ["proof (state)\nthis:\n  \\<exists>Xa M'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         m \\<le> m')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "case (Some mM''')"], ["proof (state)\nthis:\n  intersect_segment_xline prec X x = Some mM'''\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       intersect_segment_xline prec X x = Some a \\<Longrightarrow>\n       \\<exists>Xa M'.\n          Xa \\<in> set (X # Xs) \\<and>\n          intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n          (\\<forall>Xa m' M'.\n              Xa \\<in> set (X # Xs) \\<longrightarrow>\n              intersect_segment_xline prec Xa x =\n              Some (m', M') \\<longrightarrow>\n              m \\<le> m')", "thus ?thesis"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X x = Some mM'''\n\ngoal (1 subgoal):\n 1. \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "using Some1 mM Cons(2) X' M'' min"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X x = Some mM'''\n  bound_intersect_2d prec Xs x = Some mM\n  mM = (m', M')\n  bound_intersect_2d prec (X # Xs) x = Some (m, M)\n  X' \\<in> set Xs\n  intersect_segment_xline prec X' x = Some (m', M'')\n  \\<lbrakk>?X \\<in> set Xs;\n   intersect_segment_xline prec ?X x = Some (?m'a, ?M')\\<rbrakk>\n  \\<Longrightarrow> m' \\<le> ?m'a\n\ngoal (1 subgoal):\n 1. \\<exists>Xa M'.\n       Xa \\<in> set (X # Xs) \\<and>\n       intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n       (\\<forall>Xa m' M'.\n           Xa \\<in> set (X # Xs) \\<longrightarrow>\n           intersect_segment_xline prec Xa x =\n           Some (m', M') \\<longrightarrow>\n           m \\<le> m')", "by (cases mM''')\n            (force simp: max_def min_def\n              simp del: intersect_segment_xline.simps\n              split: option.split_asm if_split_asm\n              dest!: min\n              intro!: exI[where x= \"if m' \\<le> fst mM''' then X' else X\"]\n                exI[where x= \"if m' \\<le> fst mM''' then M'' else snd mM'''\"])"], ["proof (state)\nthis:\n  \\<exists>Xa M'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         m \\<le> m')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Xa M'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         m \\<le> m')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Xa M'.\n     Xa \\<in> set (X # Xs) \\<and>\n     intersect_segment_xline prec Xa x = Some (m, M') \\<and>\n     (\\<forall>Xa m' M'.\n         Xa \\<in> set (X # Xs) \\<longrightarrow>\n         intersect_segment_xline prec Xa x = Some (m', M') \\<longrightarrow>\n         m \\<le> m')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X M'.\n     X \\<in> set Xs \\<and>\n     intersect_segment_xline prec X x = Some (m, M') \\<and>\n     (\\<forall>X m' M'.\n         X \\<in> set Xs \\<longrightarrow>\n         intersect_segment_xline prec X x = Some (m', M') \\<longrightarrow>\n         m \\<le> m')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_intersect_2d:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\"\n  shows \"(\\<Union>(p1, p2) \\<in> set Xs. closed_segment p1 p2) \\<inter> {p. fst p = x} \\<subseteq> {(x, m) .. (x, M)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n    {p. fst p = x}\n    \\<subseteq> {(x, m)..(x, M)}", "proof (clarsimp, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> b\n 2. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "fix b x0 y0 x1 y1"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> b\n 2. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "assume H: \"((x0, y0), x1, y1) \\<in> set Xs\" \"(x, b) \\<in> closed_segment (x0, y0) (x1, y1)\""], ["proof (state)\nthis:\n  ((x0, y0), x1, y1) \\<in> set Xs\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n\ngoal (2 subgoals):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> b\n 2. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "hence \"intersect_segment_xline prec ((x0, y0), x1, y1) x \\<noteq> None\""], ["proof (prove)\nusing this:\n  ((x0, y0), x1, y1) \\<in> set Xs\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n\ngoal (1 subgoal):\n 1. intersect_segment_xline prec ((x0, y0), x1, y1) x \\<noteq> None", "by (intro notI)\n      (auto dest!: intersect_segment_xline_eq_None simp del: intersect_segment_xline.simps)"], ["proof (state)\nthis:\n  intersect_segment_xline prec ((x0, y0), x1, y1) x \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> b\n 2. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "then"], ["proof (chain)\npicking this:\n  intersect_segment_xline prec ((x0, y0), x1, y1) x \\<noteq> None", "obtain e f where ef: \"intersect_segment_xline prec ((x0, y0), x1, y1) x = Some (e, f)\""], ["proof (prove)\nusing this:\n  intersect_segment_xline prec ((x0, y0), x1, y1) x \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>e f.\n        intersect_segment_xline prec ((x0, y0), x1, y1) x =\n        Some (e, f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  intersect_segment_xline prec ((x0, y0), x1, y1) x = Some (e, f)\n\ngoal (2 subgoals):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> b\n 2. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "with H"], ["proof (chain)\npicking this:\n  ((x0, y0), x1, y1) \\<in> set Xs\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n  intersect_segment_xline prec ((x0, y0), x1, y1) x = Some (e, f)", "have \"m \\<le> e\""], ["proof (prove)\nusing this:\n  ((x0, y0), x1, y1) \\<in> set Xs\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n  intersect_segment_xline prec ((x0, y0), x1, y1) x = Some (e, f)\n\ngoal (1 subgoal):\n 1. m \\<le> e", "by (auto intro: bound_intersect_2d_lower[OF assms])"], ["proof (state)\nthis:\n  m \\<le> e\n\ngoal (2 subgoals):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> b\n 2. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "also"], ["proof (state)\nthis:\n  m \\<le> e\n\ngoal (2 subgoals):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> b\n 2. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "have \"\\<dots> \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<le> b", "using intersect_segment_xline[OF ef] H"], ["proof (prove)\nusing this:\n  closed_segment (x0, y0) (x1, y1) \\<inter> {p. fst p = x}\n  \\<subseteq> {(x, e)..(x, f)}\n  ((x0, y0), x1, y1) \\<in> set Xs\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n\ngoal (1 subgoal):\n 1. e \\<le> b", "by force"], ["proof (state)\nthis:\n  e \\<le> b\n\ngoal (2 subgoals):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> b\n 2. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "finally"], ["proof (chain)\npicking this:\n  m \\<le> b", "show \"m \\<le> b\""], ["proof (prove)\nusing this:\n  m \\<le> b\n\ngoal (1 subgoal):\n 1. m \\<le> b", "."], ["proof (state)\nthis:\n  m \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "have \"b \\<le> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> f", "using intersect_segment_xline[OF ef] H"], ["proof (prove)\nusing this:\n  closed_segment (x0, y0) (x1, y1) \\<inter> {p. fst p = x}\n  \\<subseteq> {(x, e)..(x, f)}\n  ((x0, y0), x1, y1) \\<in> set Xs\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n\ngoal (1 subgoal):\n 1. b \\<le> f", "by force"], ["proof (state)\nthis:\n  b \\<le> f\n\ngoal (1 subgoal):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "also"], ["proof (state)\nthis:\n  b \\<le> f\n\ngoal (1 subgoal):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "have \"\\<dots> \\<le> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> M", "using H ef"], ["proof (prove)\nusing this:\n  ((x0, y0), x1, y1) \\<in> set Xs\n  (x, b) \\<in> closed_segment (x0, y0) (x1, y1)\n  intersect_segment_xline prec ((x0, y0), x1, y1) x = Some (e, f)\n\ngoal (1 subgoal):\n 1. f \\<le> M", "by (auto intro: bound_intersect_2d_upper[OF assms])"], ["proof (state)\nthis:\n  f \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>b aa ba ab bb.\n       \\<lbrakk>((aa, ba), ab, bb) \\<in> set Xs;\n        (x, b) \\<in> closed_segment (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> b \\<le> M", "finally"], ["proof (chain)\npicking this:\n  b \\<le> M", "show \"b \\<le> M\""], ["proof (prove)\nusing this:\n  b \\<le> M\n\ngoal (1 subgoal):\n 1. b \\<le> M", "."], ["proof (state)\nthis:\n  b \\<le> M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_intersect_2d_eq_None_iff:\n  \"bound_intersect_2d prec Xs x = None \\<longleftrightarrow> (\\<forall>X\\<in>set Xs. intersect_segment_xline prec X x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bound_intersect_2d prec Xs x = None) =\n    (\\<forall>X\\<in>set Xs. intersect_segment_xline prec X x = None)", "by (induct Xs) (auto simp: split: option.split_asm)"], ["", "lemma bound_intersect_2d_nonempty:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\"\n  shows \"(\\<Union>(p1, p2) \\<in> set Xs. closed_segment p1 p2) \\<inter> {p. fst p = x} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n    {p. fst p = x} \\<noteq>\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n    {p. fst p = x} \\<noteq>\n    {}", "from assms"], ["proof (chain)\npicking this:\n  bound_intersect_2d prec Xs x = Some (m, M)", "have \"bound_intersect_2d prec Xs x \\<noteq> None\""], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x = Some (m, M)\n\ngoal (1 subgoal):\n 1. bound_intersect_2d prec Xs x \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  bound_intersect_2d prec Xs x \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n    {p. fst p = x} \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  bound_intersect_2d prec Xs x \\<noteq> None", "obtain p1 p2 where \"(p1, p2) \\<in> set Xs\" \"intersect_segment_xline prec (p1, p2) x \\<noteq> None\""], ["proof (prove)\nusing this:\n  bound_intersect_2d prec Xs x \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>(p1, p2) \\<in> set Xs;\n         intersect_segment_xline prec (p1, p2) x \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding bound_intersect_2d_eq_None_iff"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>X\\<in>set Xs. intersect_segment_xline prec X x = None)\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>(p1, p2) \\<in> set Xs;\n         intersect_segment_xline prec (p1, p2) x \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (p1, p2) \\<in> set Xs\n  intersect_segment_xline prec (p1, p2) x \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n    {p. fst p = x} \\<noteq>\n    {}", "hence \"closed_segment p1 p2 \\<inter> {p. fst p = x} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (p1, p2) \\<in> set Xs\n  intersect_segment_xline prec (p1, p2) x \\<noteq> None\n\ngoal (1 subgoal):\n 1. closed_segment p1 p2 \\<inter> {p. fst p = x} \\<noteq> {}", "by (simp add: intersect_segment_xline_None_iff)"], ["proof (state)\nthis:\n  closed_segment p1 p2 \\<inter> {p. fst p = x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n    {p. fst p = x} \\<noteq>\n    {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  closed_segment p1 p2 \\<inter> {p. fst p = x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n    {p. fst p = x} \\<noteq>\n    {}", "using \\<open>(p1, p2) \\<in> set Xs\\<close>"], ["proof (prove)\nusing this:\n  closed_segment p1 p2 \\<inter> {p. fst p = x} \\<noteq> {}\n  (p1, p2) \\<in> set Xs\n\ngoal (1 subgoal):\n 1. (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n    {p. fst p = x} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n  {p. fst p = x} \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_intersect_2d_le:\n  assumes \"bound_intersect_2d prec Xs x = Some (m, M)\" shows \"m \\<le> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<le> M", "from bound_intersect_2d_nonempty[OF assms] bound_intersect_2d[OF assms]"], ["proof (chain)\npicking this:\n  (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n  {p. fst p = x} \\<noteq>\n  {}\n  (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n  {p. fst p = x}\n  \\<subseteq> {(x, m)..(x, M)}", "show \"m \\<le> M\""], ["proof (prove)\nusing this:\n  (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n  {p. fst p = x} \\<noteq>\n  {}\n  (\\<Union>(p1, p2)\\<in>set Xs. closed_segment p1 p2) \\<inter>\n  {p. fst p = x}\n  \\<subseteq> {(x, m)..(x, M)}\n\ngoal (1 subgoal):\n 1. m \\<le> M", "by auto"], ["proof (state)\nthis:\n  m \\<le> M\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Bounds on Vertical Intersection with General List of Segments\\<close>"], ["", "definition \"bound_intersect_2d_ud prec X xl =\n  (case segments_of_aform X of\n    [] \\<Rightarrow> if fst (fst X) = xl then let m = snd (fst X) in Some (m, m) else None\n  | [x, y] \\<Rightarrow> intersect_segment_xline prec x xl\n  | xs \\<Rightarrow>\n    (case bound_intersect_2d prec (filter (\\<lambda>((x1, y1), x2, y2). x1 < x2) xs) xl of\n      Some (m, M') \\<Rightarrow>\n      (case bound_intersect_2d prec (filter (\\<lambda>((x1, y1), x2, y2). x1 > x2) xs) xl of\n        Some (m', M) \\<Rightarrow> Some (min m m', max M M')\n      | None \\<Rightarrow> None)\n    | None \\<Rightarrow> None))\""], ["", "lemma list_cases4:\n  \"\\<And>x P. (x = [] \\<Longrightarrow> P) \\<Longrightarrow> (\\<And>y. x = [y] \\<Longrightarrow> P) \\<Longrightarrow>\n    (\\<And>y z. x = [y, z] \\<Longrightarrow> P) \\<Longrightarrow>\n    (\\<And>w y z zs. x = w # y # z # zs \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x P.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>y. x = [y] \\<Longrightarrow> P;\n        \\<And>y z. x = [y, z] \\<Longrightarrow> P;\n        \\<And>w y z zs. x = w # y # z # zs \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "by (metis list.exhaust)"], ["", "lemma bound_intersect_2d_ud_segments_of_aform_le:\n  \"bound_intersect_2d_ud prec X xl = Some (m0, M0) \\<Longrightarrow> m0 \\<le> M0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bound_intersect_2d_ud prec X xl = Some (m0, M0) \\<Longrightarrow>\n    m0 \\<le> M0", "by (cases \"segments_of_aform X\" rule: list_cases4)\n    (auto simp: Let_def bound_intersect_2d_ud_def min_def max_def intersect_segment_xline_le\n      if_split_eq1 split: option.split_asm prod.split_asm list.split_asm\n      dest!: bound_intersect_2d_le)"], ["", "lemma pdevs_domain_eq_empty_iff[simp]: \"pdevs_domain (snd X) = {} \\<longleftrightarrow> snd X = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pdevs_domain (snd X) = {}) = (snd X = zero_pdevs)", "by (auto simp: intro!: pdevs_eqI)"], ["", "lemma ccw_contr_on_line_left:\n  assumes \"det3 (a, b) (x, c) (x, d) \\<ge> 0\" \"a > x\"\n  shows \"d \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<le> c", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> det3 (a, b) (x, c) (x, d)\n  x < a", "have \"d * (a - x) \\<le> c * (a - x)\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (a, b) (x, c) (x, d)\n  x < a\n\ngoal (1 subgoal):\n 1. d * (a - x) \\<le> c * (a - x)", "by (auto simp: det3_def' algebra_simps)"], ["proof (state)\nthis:\n  d * (a - x) \\<le> c * (a - x)\n\ngoal (1 subgoal):\n 1. d \\<le> c", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> det3 (a, b) (x, c) (x, d)\n  x < a\n  d * (a - x) \\<le> c * (a - x)", "show \"c \\<ge> d\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (a, b) (x, c) (x, d)\n  x < a\n  d * (a - x) \\<le> c * (a - x)\n\ngoal (1 subgoal):\n 1. d \\<le> c", "by auto"], ["proof (state)\nthis:\n  d \\<le> c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccw_contr_on_line_right:\n  assumes \"det3 (a, b) (x, c) (x, d) \\<ge> 0\" \"a < x\"\n  shows \"d \\<ge> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<le> d", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> det3 (a, b) (x, c) (x, d)\n  a < x", "have \"c * (x - a) \\<le> d * (x - a)\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (a, b) (x, c) (x, d)\n  a < x\n\ngoal (1 subgoal):\n 1. c * (x - a) \\<le> d * (x - a)", "by (auto simp: det3_def' algebra_simps)"], ["proof (state)\nthis:\n  c * (x - a) \\<le> d * (x - a)\n\ngoal (1 subgoal):\n 1. c \\<le> d", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> det3 (a, b) (x, c) (x, d)\n  a < x\n  c * (x - a) \\<le> d * (x - a)", "show \"d \\<ge> c\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (a, b) (x, c) (x, d)\n  a < x\n  c * (x - a) \\<le> d * (x - a)\n\ngoal (1 subgoal):\n 1. c \\<le> d", "by auto"], ["proof (state)\nthis:\n  c \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_contrE:\n  assumes \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> False\"\n  assumes \"X \\<noteq> {}\"\n  obtains x where \"X = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. X = {x} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> ?y; ?x \\<in> X; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> False\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. X = {x} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["", "lemma segment_intersection_singleton:\n  fixes xl and a b::\"real * real\"\n  defines \"i \\<equiv> closed_segment a b \\<inter> {p. fst p = xl}\"\n  assumes ne1: \"fst a \\<noteq> fst b\"\n  assumes upper: \"i \\<noteq> {}\"\n  obtains p1 where \"i = {p1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1. i = {p1} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "proof (rule singleton_contrE[OF _ upper])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis; x \\<noteq> y;\n        x \\<in> i; y \\<in> i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis;\n        i = {x}\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis; x \\<noteq> y;\n        x \\<in> i; y \\<in> i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis;\n        i = {x}\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume H: \"x \\<noteq> y\" \"x \\<in> i\" \"y \\<in> i\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  x \\<in> i\n  y \\<in> i\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis; x \\<noteq> y;\n        x \\<in> i; y \\<in> i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis;\n        i = {x}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x \\<in> i\n  y \\<in> i", "obtain u v where uv: \"x = u *\\<^sub>R b + (1 - u) *\\<^sub>R a\" \"y = v *\\<^sub>R b + (1 - v) *\\<^sub>R a\"\n    \"0 \\<le> u\" \"u \\<le> 1\" \"0 \\<le> v\" \"v \\<le> 1\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> i\n  y \\<in> i\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>x = u *\\<^sub>R b + (1 - u) *\\<^sub>R a;\n         y = v *\\<^sub>R b + (1 - v) *\\<^sub>R a; 0 \\<le> u; u \\<le> 1;\n         0 \\<le> v; v \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: closed_segment_def i_def field_simps)"], ["proof (state)\nthis:\n  x = u *\\<^sub>R b + (1 - u) *\\<^sub>R a\n  y = v *\\<^sub>R b + (1 - v) *\\<^sub>R a\n  0 \\<le> u\n  u \\<le> 1\n  0 \\<le> v\n  v \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis; x \\<noteq> y;\n        x \\<in> i; y \\<in> i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis;\n        i = {x}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  x = u *\\<^sub>R b + (1 - u) *\\<^sub>R a\n  y = v *\\<^sub>R b + (1 - v) *\\<^sub>R a\n  0 \\<le> u\n  u \\<le> 1\n  0 \\<le> v\n  v \\<le> 1", "have \"x + u *\\<^sub>R a = a + u *\\<^sub>R b\" \"y + v *\\<^sub>R a = a + v *\\<^sub>R b\""], ["proof (prove)\nusing this:\n  x = u *\\<^sub>R b + (1 - u) *\\<^sub>R a\n  y = v *\\<^sub>R b + (1 - v) *\\<^sub>R a\n  0 \\<le> u\n  u \\<le> 1\n  0 \\<le> v\n  v \\<le> 1\n\ngoal (1 subgoal):\n 1. x + u *\\<^sub>R a = a + u *\\<^sub>R b &&&\n    y + v *\\<^sub>R a = a + v *\\<^sub>R b", "by simp_all"], ["proof (state)\nthis:\n  x + u *\\<^sub>R a = a + u *\\<^sub>R b\n  y + v *\\<^sub>R a = a + v *\\<^sub>R b\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis; x \\<noteq> y;\n        x \\<in> i; y \\<in> i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis;\n        i = {x}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  x + u *\\<^sub>R a = a + u *\\<^sub>R b\n  y + v *\\<^sub>R a = a + v *\\<^sub>R b", "have \"fst (x + u *\\<^sub>R a) = fst (a + u *\\<^sub>R b)\" \"fst (y + v *\\<^sub>R a) = fst (a + v *\\<^sub>R b)\""], ["proof (prove)\nusing this:\n  x + u *\\<^sub>R a = a + u *\\<^sub>R b\n  y + v *\\<^sub>R a = a + v *\\<^sub>R b\n\ngoal (1 subgoal):\n 1. fst (x + u *\\<^sub>R a) = fst (a + u *\\<^sub>R b) &&&\n    fst (y + v *\\<^sub>R a) = fst (a + v *\\<^sub>R b)", "by simp_all"], ["proof (state)\nthis:\n  fst (x + u *\\<^sub>R a) = fst (a + u *\\<^sub>R b)\n  fst (y + v *\\<^sub>R a) = fst (a + v *\\<^sub>R b)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis; x \\<noteq> y;\n        x \\<in> i; y \\<in> i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis;\n        i = {x}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  fst (x + u *\\<^sub>R a) = fst (a + u *\\<^sub>R b)\n  fst (y + v *\\<^sub>R a) = fst (a + v *\\<^sub>R b)", "have \"u = v * (fst a - fst b) / (fst a - fst b)\""], ["proof (prove)\nusing this:\n  fst (x + u *\\<^sub>R a) = fst (a + u *\\<^sub>R b)\n  fst (y + v *\\<^sub>R a) = fst (a + v *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. u = v * (fst a - fst b) / (fst a - fst b)", "using ne1 H(2,3) \\<open>0 \\<le> u\\<close> \\<open>u \\<le> 1\\<close> \\<open>0 \\<le> v\\<close> \\<open>v \\<le> 1\\<close>"], ["proof (prove)\nusing this:\n  fst (x + u *\\<^sub>R a) = fst (a + u *\\<^sub>R b)\n  fst (y + v *\\<^sub>R a) = fst (a + v *\\<^sub>R b)\n  fst a \\<noteq> fst b\n  x \\<in> i\n  y \\<in> i\n  0 \\<le> u\n  u \\<le> 1\n  0 \\<le> v\n  v \\<le> 1\n\ngoal (1 subgoal):\n 1. u = v * (fst a - fst b) / (fst a - fst b)", "by (simp add: closed_segment_def i_def field_simps)"], ["proof (state)\nthis:\n  u = v * (fst a - fst b) / (fst a - fst b)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis; x \\<noteq> y;\n        x \\<in> i; y \\<in> i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis;\n        i = {x}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  u = v * (fst a - fst b) / (fst a - fst b)", "have \"u = v\""], ["proof (prove)\nusing this:\n  u = v * (fst a - fst b) / (fst a - fst b)\n\ngoal (1 subgoal):\n 1. u = v", "by (simp add: ne1)"], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis; x \\<noteq> y;\n        x \\<in> i; y \\<in> i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis;\n        i = {x}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  u = v", "show False"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. False", "using H uv"], ["proof (prove)\nusing this:\n  u = v\n  x \\<noteq> y\n  x \\<in> i\n  y \\<in> i\n  x = u *\\<^sub>R b + (1 - u) *\\<^sub>R a\n  y = v *\\<^sub>R b + (1 - v) *\\<^sub>R a\n  0 \\<le> u\n  u \\<le> 1\n  0 \\<le> v\n  v \\<le> 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>p1. i = {p1} \\<Longrightarrow> thesis;\n        i = {x}\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed"], ["", "lemma bound_intersect_2d_ud_segments_of_aform:\n  assumes \"bound_intersect_2d_ud prec X xl = Some (m0, M0)\"\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"{aform_val e X} \\<inter> {x. fst x = xl} \\<subseteq> {(xl, m0) .. (xl, M0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {aform_val e X} \\<inter> {x. fst x = xl}\n    \\<subseteq> {(xl, m0)..(xl, M0)}", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "assume safeassms: \"(a, b) = aform_val e X\" \"xl = fst (a, b)\""], ["proof (state)\nthis:\n  (a, b) = aform_val e X\n  xl = fst (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "hence fst_aform_val: \"fst (aform_val e X) = xl\""], ["proof (prove)\nusing this:\n  (a, b) = aform_val e X\n  xl = fst (a, b)\n\ngoal (1 subgoal):\n 1. fst (aform_val e X) = xl", "by simp"], ["proof (state)\nthis:\n  fst (aform_val e X) = xl\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "{"], ["proof (state)\nthis:\n  fst (aform_val e X) = xl\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "assume len: \"length (segments_of_aform X) > 2\""], ["proof (state)\nthis:\n  2 < length (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "with assms"], ["proof (chain)\npicking this:\n  bound_intersect_2d_ud prec X xl = Some (m0, M0)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  2 < length (segments_of_aform X)", "obtain m M m' M'\n    where lb: \"bound_intersect_2d prec\n        [((x1, y1), x2, y2)\\<leftarrow>segments_of_aform X . x1 < x2] xl = Some (m, M')\"\n      and ub: \"bound_intersect_2d prec\n        [((x1, y1), x2, y2)\\<leftarrow>segments_of_aform X . x2 < x1] xl = Some (m', M)\"\n      and minmax: \"m0 = min m m'\" \"M0 = max M M'\""], ["proof (prove)\nusing this:\n  bound_intersect_2d_ud prec X xl = Some (m0, M0)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  2 < length (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. (\\<And>m M' m' M.\n        \\<lbrakk>bound_intersect_2d prec\n                  (filter (\\<lambda>((x1, y1), x2, y2). x1 < x2)\n                    (segments_of_aform X))\n                  xl =\n                 Some (m, M');\n         bound_intersect_2d prec\n          (filter (\\<lambda>((x1, y1), x2, y2). x2 < x1)\n            (segments_of_aform X))\n          xl =\n         Some (m', M);\n         m0 = min m m'; M0 = max M M'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: bound_intersect_2d_ud_def split: option.split_asm list.split_asm )"], ["proof (state)\nthis:\n  bound_intersect_2d prec\n   (filter (\\<lambda>((x1, y1), x2, y2). x1 < x2) (segments_of_aform X))\n   xl =\n  Some (m, M')\n  bound_intersect_2d prec\n   (filter (\\<lambda>((x1, y1), x2, y2). x2 < x1) (segments_of_aform X))\n   xl =\n  Some (m', M)\n  m0 = min m m'\n  M0 = max M M'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from bound_intersect_2d_upper[OF ub]"], ["proof (chain)\npicking this:\n  (\\<And>Xa m'.\n      \\<lbrakk>Xa \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x2 < x1)\n                              (segments_of_aform X));\n       intersect_segment_xline prec Xa xl = Some (m', M);\n       \\<And>Xa m' M'.\n          \\<lbrakk>Xa \\<in> set (filter\n                                  (\\<lambda>((x1, y1), x2, y2). x2 < x1)\n                                  (segments_of_aform X));\n           intersect_segment_xline prec Xa xl = Some (m', M')\\<rbrakk>\n          \\<Longrightarrow> M' \\<le> M\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain X1 m1\n    where upper:\n      \"X1 \\<in> set [((x1, y1), x2, y2)\\<leftarrow>segments_of_aform X . x2 < x1]\"\n      \"intersect_segment_xline prec X1 xl = Some (m1, M)\""], ["proof (prove)\nusing this:\n  (\\<And>Xa m'.\n      \\<lbrakk>Xa \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x2 < x1)\n                              (segments_of_aform X));\n       intersect_segment_xline prec Xa xl = Some (m', M);\n       \\<And>Xa m' M'.\n          \\<lbrakk>Xa \\<in> set (filter\n                                  (\\<lambda>((x1, y1), x2, y2). x2 < x1)\n                                  (segments_of_aform X));\n           intersect_segment_xline prec Xa xl = Some (m', M')\\<rbrakk>\n          \\<Longrightarrow> M' \\<le> M\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>X1 m1.\n        \\<lbrakk>X1 \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x2 < x1)\n                                (segments_of_aform X));\n         intersect_segment_xline prec X1 xl = Some (m1, M)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  X1 \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x2 < x1)\n                 (segments_of_aform X))\n  intersect_segment_xline prec X1 xl = Some (m1, M)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from bound_intersect_2d_lower[OF lb]"], ["proof (chain)\npicking this:\n  (\\<And>Xa M'.\n      \\<lbrakk>Xa \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x1 < x2)\n                              (segments_of_aform X));\n       intersect_segment_xline prec Xa xl = Some (m, M');\n       \\<And>Xa m' M'.\n          \\<lbrakk>Xa \\<in> set (filter\n                                  (\\<lambda>((x1, y1), x2, y2). x1 < x2)\n                                  (segments_of_aform X));\n           intersect_segment_xline prec Xa xl = Some (m', M')\\<rbrakk>\n          \\<Longrightarrow> m \\<le> m'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain X2 M2\n    where lower:\n      \"X2 \\<in> set [((x1, y1), x2, y2)\\<leftarrow>segments_of_aform X . x1 < x2]\"\n      \"intersect_segment_xline prec X2 xl = Some (m, M2)\""], ["proof (prove)\nusing this:\n  (\\<And>Xa M'.\n      \\<lbrakk>Xa \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x1 < x2)\n                              (segments_of_aform X));\n       intersect_segment_xline prec Xa xl = Some (m, M');\n       \\<And>Xa m' M'.\n          \\<lbrakk>Xa \\<in> set (filter\n                                  (\\<lambda>((x1, y1), x2, y2). x1 < x2)\n                                  (segments_of_aform X));\n           intersect_segment_xline prec Xa xl = Some (m', M')\\<rbrakk>\n          \\<Longrightarrow> m \\<le> m'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>X2 M2.\n        \\<lbrakk>X2 \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x1 < x2)\n                                (segments_of_aform X));\n         intersect_segment_xline prec X2 xl = Some (m, M2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  X2 \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x1 < x2)\n                 (segments_of_aform X))\n  intersect_segment_xline prec X2 xl = Some (m, M2)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from upper(1) lower(1)"], ["proof (chain)\npicking this:\n  X1 \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x2 < x1)\n                 (segments_of_aform X))\n  X2 \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x1 < x2)\n                 (segments_of_aform X))", "have X1: \"X1 \\<in> set (segments_of_aform X)\" \"fst (fst X1) > fst (snd X1)\"\n      and X2: \"X2 \\<in> set (segments_of_aform X)\" \"fst (fst X2) < fst (snd X2)\""], ["proof (prove)\nusing this:\n  X1 \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x2 < x1)\n                 (segments_of_aform X))\n  X2 \\<in> set (filter (\\<lambda>((x1, y1), x2, y2). x1 < x2)\n                 (segments_of_aform X))\n\ngoal (1 subgoal):\n 1. (X1 \\<in> set (segments_of_aform X) &&& fst (snd X1) < fst (fst X1)) &&&\n    X2 \\<in> set (segments_of_aform X) &&& fst (fst X2) < fst (snd X2)", "by auto"], ["proof (state)\nthis:\n  X1 \\<in> set (segments_of_aform X)\n  fst (snd X1) < fst (fst X1)\n  X2 \\<in> set (segments_of_aform X)\n  fst (fst X2) < fst (snd X2)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "note upper_seg = intersect_segment_xline_fst_snd[OF upper(2)]"], ["proof (state)\nthis:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl}\n  \\<subseteq> {(xl, m1)..(xl, M)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "note lower_seg = intersect_segment_xline_fst_snd[OF lower(2)]"], ["proof (state)\nthis:\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl}\n  \\<subseteq> {(xl, m)..(xl, M2)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from len"], ["proof (chain)\npicking this:\n  2 < length (segments_of_aform X)", "have lh: \"length (half_segments_of_aform X) \\<noteq> 1\""], ["proof (prove)\nusing this:\n  2 < length (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. length (half_segments_of_aform X) \\<noteq> 1", "by (auto simp: segments_of_aform_def Let_def)"], ["proof (state)\nthis:\n  length (half_segments_of_aform X) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from X1"], ["proof (chain)\npicking this:\n  X1 \\<in> set (segments_of_aform X)\n  fst (snd X1) < fst (fst X1)", "have ne1: \"fst (fst X1) \\<noteq> fst (snd X1)\""], ["proof (prove)\nusing this:\n  X1 \\<in> set (segments_of_aform X)\n  fst (snd X1) < fst (fst X1)\n\ngoal (1 subgoal):\n 1. fst (fst X1) \\<noteq> fst (snd X1)", "by simp"], ["proof (state)\nthis:\n  fst (fst X1) \\<noteq> fst (snd X1)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "moreover"], ["proof (state)\nthis:\n  fst (fst X1) \\<noteq> fst (snd X1)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have \"closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} \\<noteq> {}", "using upper(2)"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X1 xl = Some (m1, M)\n\ngoal (1 subgoal):\n 1. closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} \\<noteq> {}", "by (simp add: intersect_segment_xline_None_iff[of prec, symmetric])"], ["proof (state)\nthis:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "ultimately"], ["proof (chain)\npicking this:\n  fst (fst X1) \\<noteq> fst (snd X1)\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} \\<noteq> {}", "obtain p1 where p1: \"closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} = {p1}\""], ["proof (prove)\nusing this:\n  fst (fst X1) \\<noteq> fst (snd X1)\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p1.\n        closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} =\n        {p1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule segment_intersection_singleton)"], ["proof (state)\nthis:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} = {p1}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "then"], ["proof (chain)\npicking this:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} = {p1}", "obtain u where u: \"p1 = (1 - u) *\\<^sub>R fst X1 + u *\\<^sub>R (snd X1)\" \"0 \\<le> u\" \"u \\<le> 1\""], ["proof (prove)\nusing this:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} = {p1}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>p1 = (1 - u) *\\<^sub>R fst X1 + u *\\<^sub>R snd X1;\n         0 \\<le> u; u \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: closed_segment_def algebra_simps)"], ["proof (state)\nthis:\n  p1 = (1 - u) *\\<^sub>R fst X1 + u *\\<^sub>R snd X1\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have coll1: \"det3 (fst X1) p1 (aform_val e X) \\<ge> 0\"\n      and coll1': \"det3 p1 (snd X1) (aform_val e X) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X1) p1 (aform_val e X) &&&\n    0 \\<le> det3 p1 (snd X1) (aform_val e X)", "unfolding atomize_conj"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X1) p1 (aform_val e X) \\<and>\n    0 \\<le> det3 p1 (snd X1) (aform_val e X)", "using u"], ["proof (prove)\nusing this:\n  p1 = (1 - u) *\\<^sub>R fst X1 + u *\\<^sub>R snd X1\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X1) p1 (aform_val e X) \\<and>\n    0 \\<le> det3 p1 (snd X1) (aform_val e X)", "by (cases \"u = 0 \\<or> u = 1\")\n        (auto simp: u(1) intro: det3_nonneg_scaleR_segment1 det3_nonneg_scaleR_segment2\n          det3_nonneg_segments_of_aformI[OF \\<open>e \\<in> _\\<close> lh X1(1)])"], ["proof (state)\nthis:\n  0 \\<le> det3 (fst X1) p1 (aform_val e X)\n  0 \\<le> det3 p1 (snd X1) (aform_val e X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from X2"], ["proof (chain)\npicking this:\n  X2 \\<in> set (segments_of_aform X)\n  fst (fst X2) < fst (snd X2)", "have ne2: \"fst (fst X2) \\<noteq> fst (snd X2)\""], ["proof (prove)\nusing this:\n  X2 \\<in> set (segments_of_aform X)\n  fst (fst X2) < fst (snd X2)\n\ngoal (1 subgoal):\n 1. fst (fst X2) \\<noteq> fst (snd X2)", "by simp"], ["proof (state)\nthis:\n  fst (fst X2) \\<noteq> fst (snd X2)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "moreover"], ["proof (state)\nthis:\n  fst (fst X2) \\<noteq> fst (snd X2)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have \"closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} \\<noteq> {}", "using lower(2)"], ["proof (prove)\nusing this:\n  intersect_segment_xline prec X2 xl = Some (m, M2)\n\ngoal (1 subgoal):\n 1. closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} \\<noteq> {}", "by (simp add: intersect_segment_xline_None_iff[of prec, symmetric])"], ["proof (state)\nthis:\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "ultimately"], ["proof (chain)\npicking this:\n  fst (fst X2) \\<noteq> fst (snd X2)\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} \\<noteq> {}", "obtain p2 where p2: \"closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} = {p2}\""], ["proof (prove)\nusing this:\n  fst (fst X2) \\<noteq> fst (snd X2)\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p2.\n        closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} =\n        {p2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule segment_intersection_singleton)"], ["proof (state)\nthis:\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} = {p2}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "then"], ["proof (chain)\npicking this:\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} = {p2}", "obtain v where v: \"p2 = (1 - v) *\\<^sub>R fst X2 + v *\\<^sub>R (snd X2)\" \"0 \\<le> v\" \"v \\<le> 1\""], ["proof (prove)\nusing this:\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} = {p2}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>p2 = (1 - v) *\\<^sub>R fst X2 + v *\\<^sub>R snd X2;\n         0 \\<le> v; v \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: closed_segment_def algebra_simps)"], ["proof (state)\nthis:\n  p2 = (1 - v) *\\<^sub>R fst X2 + v *\\<^sub>R snd X2\n  0 \\<le> v\n  v \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have coll2: \"det3 (fst X2) p2 (aform_val e X) \\<ge> 0\"\n      and coll2': \"det3 p2 (snd X2) (aform_val e X) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X2) p2 (aform_val e X) &&&\n    0 \\<le> det3 p2 (snd X2) (aform_val e X)", "unfolding atomize_conj"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X2) p2 (aform_val e X) \\<and>\n    0 \\<le> det3 p2 (snd X2) (aform_val e X)", "using v"], ["proof (prove)\nusing this:\n  p2 = (1 - v) *\\<^sub>R fst X2 + v *\\<^sub>R snd X2\n  0 \\<le> v\n  v \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X2) p2 (aform_val e X) \\<and>\n    0 \\<le> det3 p2 (snd X2) (aform_val e X)", "by (cases \"v = 0 \\<or> v = 1\")\n        (auto simp: v(1) intro: det3_nonneg_scaleR_segment1 det3_nonneg_scaleR_segment2\n          det3_nonneg_segments_of_aformI[OF \\<open>e \\<in> _\\<close> lh X2(1)])"], ["proof (state)\nthis:\n  0 \\<le> det3 (fst X2) p2 (aform_val e X)\n  0 \\<le> det3 p2 (snd X2) (aform_val e X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from in_set_segments_of_aform_aform_valE\n        [of \"fst X1\" \"snd X1\" X, unfolded prod.collapse, OF X1(1)]"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>snd X1 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e1s where e1s: \"snd X1 = aform_val e1s X\" \"e1s \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>snd X1 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e1s.\n        \\<lbrakk>snd X1 = aform_val e1s X;\n         e1s \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  snd X1 = aform_val e1s X\n  e1s \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from previous_segments_of_aformE\n        [of \"fst X1\" \"snd X1\" X, unfolded prod.collapse, OF X1(1)]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      (x, fst X1) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain fX0 where \"(fX0, fst X1) \\<in> set (segments_of_aform X)\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      (x, fst X1) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>fX0.\n        (fX0, fst X1) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  (fX0, fst X1) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from in_set_segments_of_aform_aform_valE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>fst X1 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e1f where e1f: \"fst X1 = aform_val e1f X\" \"e1f \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>fst X1 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e1f.\n        \\<lbrakk>fst X1 = aform_val e1f X;\n         e1f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  fst X1 = aform_val e1f X\n  e1f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have \"p1 \\<in> closed_segment (aform_val e1f X) (aform_val e1s X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<in> closed_segment (aform_val e1f X) (aform_val e1s X)", "using p1"], ["proof (prove)\nusing this:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} = {p1}\n\ngoal (1 subgoal):\n 1. p1 \\<in> closed_segment (aform_val e1f X) (aform_val e1s X)", "by (auto simp: e1s e1f)"], ["proof (state)\nthis:\n  p1 \\<in> closed_segment (aform_val e1f X) (aform_val e1s X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "with segment_in_aform_val[OF e1s(2) e1f(2), of X]"], ["proof (chain)\npicking this:\n  closed_segment (aform_val e1s X) (aform_val e1f X) \\<subseteq> Affine X\n  p1 \\<in> closed_segment (aform_val e1f X) (aform_val e1s X)", "obtain ep1 where ep1: \"ep1 \\<in> UNIV \\<rightarrow> {-1 .. 1}\" \"p1 = aform_val ep1 X\""], ["proof (prove)\nusing this:\n  closed_segment (aform_val e1s X) (aform_val e1f X) \\<subseteq> Affine X\n  p1 \\<in> closed_segment (aform_val e1f X) (aform_val e1s X)\n\ngoal (1 subgoal):\n 1. (\\<And>ep1.\n        \\<lbrakk>ep1 \\<in> UNIV \\<rightarrow> {- 1..1};\n         p1 = aform_val ep1 X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Affine_def valuate_def closed_segment_commute)"], ["proof (state)\nthis:\n  ep1 \\<in> UNIV \\<rightarrow> {- 1..1}\n  p1 = aform_val ep1 X\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from in_set_segments_of_aform_aform_valE\n        [of \"fst X2\" \"snd X2\" X, unfolded prod.collapse, OF X2(1)]"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>snd X2 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e2s where e2s: \"snd X2 = aform_val e2s X\" \"e2s \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>snd X2 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e2s.\n        \\<lbrakk>snd X2 = aform_val e2s X;\n         e2s \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  snd X2 = aform_val e2s X\n  e2s \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from previous_segments_of_aformE\n        [of \"fst X2\" \"snd X2\" X, unfolded prod.collapse, OF X2(1)]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      (x, fst X2) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain fX02 where \"(fX02, fst X2) \\<in> set (segments_of_aform X)\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      (x, fst X2) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>fX02.\n        (fX02, fst X2) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  (fX02, fst X2) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from in_set_segments_of_aform_aform_valE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>fst X2 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e2f where e2f: \"fst X2 = aform_val e2f X\" \"e2f \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>fst X2 = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e2f.\n        \\<lbrakk>fst X2 = aform_val e2f X;\n         e2f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  fst X2 = aform_val e2f X\n  e2f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have \"p2 \\<in> closed_segment (aform_val e2f X) (aform_val e2s X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p2 \\<in> closed_segment (aform_val e2f X) (aform_val e2s X)", "using p2"], ["proof (prove)\nusing this:\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} = {p2}\n\ngoal (1 subgoal):\n 1. p2 \\<in> closed_segment (aform_val e2f X) (aform_val e2s X)", "by (auto simp: e2s e2f)"], ["proof (state)\nthis:\n  p2 \\<in> closed_segment (aform_val e2f X) (aform_val e2s X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "with segment_in_aform_val[OF e2f(2) e2s(2), of X]"], ["proof (chain)\npicking this:\n  closed_segment (aform_val e2f X) (aform_val e2s X) \\<subseteq> Affine X\n  p2 \\<in> closed_segment (aform_val e2f X) (aform_val e2s X)", "obtain ep2 where ep2: \"ep2 \\<in> UNIV \\<rightarrow> {-1 .. 1}\" \"p2 = aform_val ep2 X\""], ["proof (prove)\nusing this:\n  closed_segment (aform_val e2f X) (aform_val e2s X) \\<subseteq> Affine X\n  p2 \\<in> closed_segment (aform_val e2f X) (aform_val e2s X)\n\ngoal (1 subgoal):\n 1. (\\<And>ep2.\n        \\<lbrakk>ep2 \\<in> UNIV \\<rightarrow> {- 1..1};\n         p2 = aform_val ep2 X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Affine_def valuate_def)"], ["proof (state)\nthis:\n  ep2 \\<in> UNIV \\<rightarrow> {- 1..1}\n  p2 = aform_val ep2 X\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from det3_nonneg_segments_of_aformI[OF ep2(1), of X \"(fst X1, snd X1)\", unfolded prod.collapse,\n        OF lh X1(1), unfolded ep2(2)[symmetric]]"], ["proof (chain)\npicking this:\n  0 \\<le> det3 (fst X1) (snd X1) p2", "have c2: \"det3 (fst X1) (snd X1) p2 \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst X1) (snd X1) p2\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X1) (snd X1) p2", "."], ["proof (state)\nthis:\n  0 \\<le> det3 (fst X1) (snd X1) p2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "hence c12: \"det3 (fst X1) p1 p2 \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst X1) (snd X1) p2\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X1) p1 p2", "using u"], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst X1) (snd X1) p2\n  p1 = (1 - u) *\\<^sub>R fst X1 + u *\\<^sub>R snd X1\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X1) p1 p2", "by (cases \"u = 0\") (auto simp: u(1) det3_nonneg_scaleR_segment2)"], ["proof (state)\nthis:\n  0 \\<le> det3 (fst X1) p1 p2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from det3_nonneg_segments_of_aformI[OF ep1(1), of X \"(fst X2, snd X2)\", unfolded prod.collapse,\n        OF lh X2(1), unfolded ep1(2)[symmetric]]"], ["proof (chain)\npicking this:\n  0 \\<le> det3 (fst X2) (snd X2) p1", "have c1: \"det3 (fst X2) (snd X2) p1 \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst X2) (snd X2) p1\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X2) (snd X2) p1", "."], ["proof (state)\nthis:\n  0 \\<le> det3 (fst X2) (snd X2) p1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "hence c21: \"det3 (fst X2) p2 p1 \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst X2) (snd X2) p1\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X2) p2 p1", "using v"], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst X2) (snd X2) p1\n  p2 = (1 - v) *\\<^sub>R fst X2 + v *\\<^sub>R snd X2\n  0 \\<le> v\n  v \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst X2) p2 p1", "by (cases \"v = 0\") (auto simp: v(1) det3_nonneg_scaleR_segment2)"], ["proof (state)\nthis:\n  0 \\<le> det3 (fst X2) p2 p1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from p1 p2"], ["proof (chain)\npicking this:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} = {p1}\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} = {p2}", "have p1p2xl: \"fst p1 = xl\" \"fst p2 = xl\""], ["proof (prove)\nusing this:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} = {p1}\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} = {p2}\n\ngoal (1 subgoal):\n 1. fst p1 = xl &&& fst p2 = xl", "by (auto simp: det3_def')"], ["proof (state)\nthis:\n  fst p1 = xl\n  fst p2 = xl\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from upper_seg p1"], ["proof (chain)\npicking this:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl}\n  \\<subseteq> {(xl, m1)..(xl, M)}\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} = {p1}", "have \"snd p1 \\<le> M\""], ["proof (prove)\nusing this:\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl}\n  \\<subseteq> {(xl, m1)..(xl, M)}\n  closed_segment (fst X1) (snd X1) \\<inter> {p. fst p = xl} = {p1}\n\ngoal (1 subgoal):\n 1. snd p1 \\<le> M", "by (auto simp: less_eq_prod_def)"], ["proof (state)\nthis:\n  snd p1 \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from lower_seg p2"], ["proof (chain)\npicking this:\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl}\n  \\<subseteq> {(xl, m)..(xl, M2)}\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} = {p2}", "have \"m \\<le> snd p2\""], ["proof (prove)\nusing this:\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl}\n  \\<subseteq> {(xl, m)..(xl, M2)}\n  closed_segment (fst X2) (snd X2) \\<inter> {p. fst p = xl} = {p2}\n\ngoal (1 subgoal):\n 1. m \\<le> snd p2", "by (auto simp: less_eq_prod_def)"], ["proof (state)\nthis:\n  m \\<le> snd p2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "{"], ["proof (state)\nthis:\n  m \\<le> snd p2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have *: \"(fst p1, snd (aform_val e X)) = aform_val e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst p1, snd (aform_val e X)) = aform_val e X", "by (simp add: prod_eq_iff p1p2xl fst_aform_val)"], ["proof (state)\nthis:\n  (fst p1, snd (aform_val e X)) = aform_val e X\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "hence coll:\n        \"det3 (fst (fst X1), snd (fst X1)) (fst p1, snd p1) (fst p1, snd (aform_val e X)) \\<ge> 0\"\n        and coll':\n        \"det3 (fst (snd X1), snd (snd X1)) (fst p1, snd (aform_val e X)) (fst p1, snd p1) \\<ge> 0\""], ["proof (prove)\nusing this:\n  (fst p1, snd (aform_val e X)) = aform_val e X\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst (fst X1), snd (fst X1)) (fst p1, snd p1)\n             (fst p1, snd (aform_val e X)) &&&\n    0 \\<le> det3 (fst (snd X1), snd (snd X1)) (fst p1, snd (aform_val e X))\n             (fst p1, snd p1)", "using coll1 coll1'"], ["proof (prove)\nusing this:\n  (fst p1, snd (aform_val e X)) = aform_val e X\n  0 \\<le> det3 (fst X1) p1 (aform_val e X)\n  0 \\<le> det3 p1 (snd X1) (aform_val e X)\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst (fst X1), snd (fst X1)) (fst p1, snd p1)\n             (fst p1, snd (aform_val e X)) &&&\n    0 \\<le> det3 (fst (snd X1), snd (snd X1)) (fst p1, snd (aform_val e X))\n             (fst p1, snd p1)", "by (auto simp: det3_rotate)"], ["proof (state)\nthis:\n  0 \\<le> det3 (fst (fst X1), snd (fst X1)) (fst p1, snd p1)\n           (fst p1, snd (aform_val e X))\n  0 \\<le> det3 (fst (snd X1), snd (snd X1)) (fst p1, snd (aform_val e X))\n           (fst p1, snd p1)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have \"snd (aform_val e X) \\<le> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (aform_val e X) \\<le> M", "proof (cases \"fst (fst X1) = xl\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M\n 2. fst (fst X1) \\<noteq> xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "case False"], ["proof (state)\nthis:\n  fst (fst X1) \\<noteq> xl\n\ngoal (2 subgoals):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M\n 2. fst (fst X1) \\<noteq> xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "have \"fst (fst X1) \\<ge> fst p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst p1 \\<le> fst (fst X1)", "unfolding u"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ((1 - u) *\\<^sub>R fst X1 + u *\\<^sub>R snd X1) \\<le> fst (fst X1)", "using X1"], ["proof (prove)\nusing this:\n  X1 \\<in> set (segments_of_aform X)\n  fst (snd X1) < fst (fst X1)\n\ngoal (1 subgoal):\n 1. fst ((1 - u) *\\<^sub>R fst X1 + u *\\<^sub>R snd X1) \\<le> fst (fst X1)", "by (auto simp: algebra_simps intro!: mult_left_mono u)"], ["proof (state)\nthis:\n  fst p1 \\<le> fst (fst X1)\n\ngoal (2 subgoals):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M\n 2. fst (fst X1) \\<noteq> xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "moreover"], ["proof (state)\nthis:\n  fst p1 \\<le> fst (fst X1)\n\ngoal (2 subgoals):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M\n 2. fst (fst X1) \\<noteq> xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "have \"fst (fst X1) \\<noteq> fst p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst X1) \\<noteq> fst p1", "using False"], ["proof (prove)\nusing this:\n  fst (fst X1) \\<noteq> xl\n\ngoal (1 subgoal):\n 1. fst (fst X1) \\<noteq> fst p1", "by (simp add: p1p2xl)"], ["proof (state)\nthis:\n  fst (fst X1) \\<noteq> fst p1\n\ngoal (2 subgoals):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M\n 2. fst (fst X1) \\<noteq> xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "ultimately"], ["proof (chain)\npicking this:\n  fst p1 \\<le> fst (fst X1)\n  fst (fst X1) \\<noteq> fst p1", "have \"fst (fst X1) > fst p1\""], ["proof (prove)\nusing this:\n  fst p1 \\<le> fst (fst X1)\n  fst (fst X1) \\<noteq> fst p1\n\ngoal (1 subgoal):\n 1. fst p1 < fst (fst X1)", "by simp"], ["proof (state)\nthis:\n  fst p1 < fst (fst X1)\n\ngoal (2 subgoals):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M\n 2. fst (fst X1) \\<noteq> xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "from ccw_contr_on_line_left[OF coll this]"], ["proof (chain)\npicking this:\n  snd (aform_val e X) \\<le> snd p1", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (aform_val e X) \\<le> snd p1\n\ngoal (1 subgoal):\n 1. snd (aform_val e X) \\<le> M", "using \\<open>snd p1 \\<le> M\\<close>"], ["proof (prove)\nusing this:\n  snd (aform_val e X) \\<le> snd p1\n  snd p1 \\<le> M\n\ngoal (1 subgoal):\n 1. snd (aform_val e X) \\<le> M", "by simp"], ["proof (state)\nthis:\n  snd (aform_val e X) \\<le> M\n\ngoal (1 subgoal):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "case True"], ["proof (state)\nthis:\n  fst (fst X1) = xl\n\ngoal (1 subgoal):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "have \"fst (snd X1) * (1 - u) \\<le> fst (fst X1) * (1 - u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd X1) * (1 - u) \\<le> fst (fst X1) * (1 - u)", "using X1 u"], ["proof (prove)\nusing this:\n  X1 \\<in> set (segments_of_aform X)\n  fst (snd X1) < fst (fst X1)\n  p1 = (1 - u) *\\<^sub>R fst X1 + u *\\<^sub>R snd X1\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (1 subgoal):\n 1. fst (snd X1) * (1 - u) \\<le> fst (fst X1) * (1 - u)", "by (auto simp: intro!: mult_right_mono)"], ["proof (state)\nthis:\n  fst (snd X1) * (1 - u) \\<le> fst (fst X1) * (1 - u)\n\ngoal (1 subgoal):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "hence \"fst (snd X1) \\<le> fst p1\""], ["proof (prove)\nusing this:\n  fst (snd X1) * (1 - u) \\<le> fst (fst X1) * (1 - u)\n\ngoal (1 subgoal):\n 1. fst (snd X1) \\<le> fst p1", "unfolding u"], ["proof (prove)\nusing this:\n  fst (snd X1) * (1 - u) \\<le> fst (fst X1) * (1 - u)\n\ngoal (1 subgoal):\n 1. fst (snd X1) \\<le> fst ((1 - u) *\\<^sub>R fst X1 + u *\\<^sub>R snd X1)", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  fst (snd X1) \\<le> fst p1\n\ngoal (1 subgoal):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "moreover"], ["proof (state)\nthis:\n  fst (snd X1) \\<le> fst p1\n\ngoal (1 subgoal):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "have \"fst (snd X1) \\<noteq> fst p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd X1) \\<noteq> fst p1", "using True ne1"], ["proof (prove)\nusing this:\n  fst (fst X1) = xl\n  fst (fst X1) \\<noteq> fst (snd X1)\n\ngoal (1 subgoal):\n 1. fst (snd X1) \\<noteq> fst p1", "by (simp add: p1p2xl)"], ["proof (state)\nthis:\n  fst (snd X1) \\<noteq> fst p1\n\ngoal (1 subgoal):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "ultimately"], ["proof (chain)\npicking this:\n  fst (snd X1) \\<le> fst p1\n  fst (snd X1) \\<noteq> fst p1", "have \"fst (snd X1) < fst p1\""], ["proof (prove)\nusing this:\n  fst (snd X1) \\<le> fst p1\n  fst (snd X1) \\<noteq> fst p1\n\ngoal (1 subgoal):\n 1. fst (snd X1) < fst p1", "by simp"], ["proof (state)\nthis:\n  fst (snd X1) < fst p1\n\ngoal (1 subgoal):\n 1. fst (fst X1) = xl \\<Longrightarrow> snd (aform_val e X) \\<le> M", "from ccw_contr_on_line_right[OF coll' this]"], ["proof (chain)\npicking this:\n  snd (aform_val e X) \\<le> snd p1", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (aform_val e X) \\<le> snd p1\n\ngoal (1 subgoal):\n 1. snd (aform_val e X) \\<le> M", "using \\<open>snd p1 \\<le> M\\<close>"], ["proof (prove)\nusing this:\n  snd (aform_val e X) \\<le> snd p1\n  snd p1 \\<le> M\n\ngoal (1 subgoal):\n 1. snd (aform_val e X) \\<le> M", "by simp"], ["proof (state)\nthis:\n  snd (aform_val e X) \\<le> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (aform_val e X) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "}"], ["proof (state)\nthis:\n  snd (aform_val e X) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "moreover"], ["proof (state)\nthis:\n  snd (aform_val e X) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "{"], ["proof (state)\nthis:\n  snd (aform_val e X) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have \"(fst p2, snd (aform_val e X)) = aform_val e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst p2, snd (aform_val e X)) = aform_val e X", "by (simp add: prod_eq_iff p1p2xl fst_aform_val)"], ["proof (state)\nthis:\n  (fst p2, snd (aform_val e X)) = aform_val e X\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "hence coll:\n        \"det3 (fst (fst X2), snd (fst X2)) (fst p2, snd p2) (fst p2, snd (aform_val e X)) \\<ge> 0\"\n        and coll':\n        \"det3 (fst (snd X2), snd (snd X2)) (fst p2, snd (aform_val e X)) (fst p2, snd p2) \\<ge> 0\""], ["proof (prove)\nusing this:\n  (fst p2, snd (aform_val e X)) = aform_val e X\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst (fst X2), snd (fst X2)) (fst p2, snd p2)\n             (fst p2, snd (aform_val e X)) &&&\n    0 \\<le> det3 (fst (snd X2), snd (snd X2)) (fst p2, snd (aform_val e X))\n             (fst p2, snd p2)", "using coll2 coll2'"], ["proof (prove)\nusing this:\n  (fst p2, snd (aform_val e X)) = aform_val e X\n  0 \\<le> det3 (fst X2) p2 (aform_val e X)\n  0 \\<le> det3 p2 (snd X2) (aform_val e X)\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst (fst X2), snd (fst X2)) (fst p2, snd p2)\n             (fst p2, snd (aform_val e X)) &&&\n    0 \\<le> det3 (fst (snd X2), snd (snd X2)) (fst p2, snd (aform_val e X))\n             (fst p2, snd p2)", "by (auto simp: det3_rotate)"], ["proof (state)\nthis:\n  0 \\<le> det3 (fst (fst X2), snd (fst X2)) (fst p2, snd p2)\n           (fst p2, snd (aform_val e X))\n  0 \\<le> det3 (fst (snd X2), snd (snd X2)) (fst p2, snd (aform_val e X))\n           (fst p2, snd p2)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "have \"m \\<le> snd (aform_val e X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> snd (aform_val e X)", "proof (cases \"fst (fst X2) = xl\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)\n 2. fst (fst X2) \\<noteq> xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "case False"], ["proof (state)\nthis:\n  fst (fst X2) \\<noteq> xl\n\ngoal (2 subgoals):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)\n 2. fst (fst X2) \\<noteq> xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "have \"fst (fst X2) \\<le> fst p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst X2) \\<le> fst p2", "unfolding v"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst X2) \\<le> fst ((1 - v) *\\<^sub>R fst X2 + v *\\<^sub>R snd X2)", "using X2"], ["proof (prove)\nusing this:\n  X2 \\<in> set (segments_of_aform X)\n  fst (fst X2) < fst (snd X2)\n\ngoal (1 subgoal):\n 1. fst (fst X2) \\<le> fst ((1 - v) *\\<^sub>R fst X2 + v *\\<^sub>R snd X2)", "by (auto simp: algebra_simps intro!: mult_left_mono v)"], ["proof (state)\nthis:\n  fst (fst X2) \\<le> fst p2\n\ngoal (2 subgoals):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)\n 2. fst (fst X2) \\<noteq> xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "moreover"], ["proof (state)\nthis:\n  fst (fst X2) \\<le> fst p2\n\ngoal (2 subgoals):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)\n 2. fst (fst X2) \\<noteq> xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "have \"fst (fst X2) \\<noteq> fst p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst X2) \\<noteq> fst p2", "using False"], ["proof (prove)\nusing this:\n  fst (fst X2) \\<noteq> xl\n\ngoal (1 subgoal):\n 1. fst (fst X2) \\<noteq> fst p2", "by (simp add: p1p2xl)"], ["proof (state)\nthis:\n  fst (fst X2) \\<noteq> fst p2\n\ngoal (2 subgoals):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)\n 2. fst (fst X2) \\<noteq> xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "ultimately"], ["proof (chain)\npicking this:\n  fst (fst X2) \\<le> fst p2\n  fst (fst X2) \\<noteq> fst p2", "have \"fst (fst X2) < fst p2\""], ["proof (prove)\nusing this:\n  fst (fst X2) \\<le> fst p2\n  fst (fst X2) \\<noteq> fst p2\n\ngoal (1 subgoal):\n 1. fst (fst X2) < fst p2", "by simp"], ["proof (state)\nthis:\n  fst (fst X2) < fst p2\n\ngoal (2 subgoals):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)\n 2. fst (fst X2) \\<noteq> xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "from ccw_contr_on_line_right[OF coll this]"], ["proof (chain)\npicking this:\n  snd p2 \\<le> snd (aform_val e X)", "show ?thesis"], ["proof (prove)\nusing this:\n  snd p2 \\<le> snd (aform_val e X)\n\ngoal (1 subgoal):\n 1. m \\<le> snd (aform_val e X)", "using \\<open>m \\<le> snd p2\\<close>"], ["proof (prove)\nusing this:\n  snd p2 \\<le> snd (aform_val e X)\n  m \\<le> snd p2\n\ngoal (1 subgoal):\n 1. m \\<le> snd (aform_val e X)", "by simp"], ["proof (state)\nthis:\n  m \\<le> snd (aform_val e X)\n\ngoal (1 subgoal):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "case True"], ["proof (state)\nthis:\n  fst (fst X2) = xl\n\ngoal (1 subgoal):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "have \"(1 - v) * fst (snd X2) \\<ge> (1 - v) * fst (fst X2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - v) * fst (fst X2) \\<le> (1 - v) * fst (snd X2)", "using X2 v"], ["proof (prove)\nusing this:\n  X2 \\<in> set (segments_of_aform X)\n  fst (fst X2) < fst (snd X2)\n  p2 = (1 - v) *\\<^sub>R fst X2 + v *\\<^sub>R snd X2\n  0 \\<le> v\n  v \\<le> 1\n\ngoal (1 subgoal):\n 1. (1 - v) * fst (fst X2) \\<le> (1 - v) * fst (snd X2)", "by (auto simp: intro!: mult_left_mono)"], ["proof (state)\nthis:\n  (1 - v) * fst (fst X2) \\<le> (1 - v) * fst (snd X2)\n\ngoal (1 subgoal):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "hence \"fst (snd X2) \\<ge> fst p2\""], ["proof (prove)\nusing this:\n  (1 - v) * fst (fst X2) \\<le> (1 - v) * fst (snd X2)\n\ngoal (1 subgoal):\n 1. fst p2 \\<le> fst (snd X2)", "unfolding v"], ["proof (prove)\nusing this:\n  (1 - v) * fst (fst X2) \\<le> (1 - v) * fst (snd X2)\n\ngoal (1 subgoal):\n 1. fst ((1 - v) *\\<^sub>R fst X2 + v *\\<^sub>R snd X2) \\<le> fst (snd X2)", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  fst p2 \\<le> fst (snd X2)\n\ngoal (1 subgoal):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "moreover"], ["proof (state)\nthis:\n  fst p2 \\<le> fst (snd X2)\n\ngoal (1 subgoal):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "have \"fst (snd X2) \\<noteq> fst p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd X2) \\<noteq> fst p2", "using True ne2"], ["proof (prove)\nusing this:\n  fst (fst X2) = xl\n  fst (fst X2) \\<noteq> fst (snd X2)\n\ngoal (1 subgoal):\n 1. fst (snd X2) \\<noteq> fst p2", "by (simp add: p1p2xl)"], ["proof (state)\nthis:\n  fst (snd X2) \\<noteq> fst p2\n\ngoal (1 subgoal):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "ultimately"], ["proof (chain)\npicking this:\n  fst p2 \\<le> fst (snd X2)\n  fst (snd X2) \\<noteq> fst p2", "have \"fst (snd X2) > fst p2\""], ["proof (prove)\nusing this:\n  fst p2 \\<le> fst (snd X2)\n  fst (snd X2) \\<noteq> fst p2\n\ngoal (1 subgoal):\n 1. fst p2 < fst (snd X2)", "by simp"], ["proof (state)\nthis:\n  fst p2 < fst (snd X2)\n\ngoal (1 subgoal):\n 1. fst (fst X2) = xl \\<Longrightarrow> m \\<le> snd (aform_val e X)", "from ccw_contr_on_line_left[OF coll' this]"], ["proof (chain)\npicking this:\n  snd p2 \\<le> snd (aform_val e X)", "show ?thesis"], ["proof (prove)\nusing this:\n  snd p2 \\<le> snd (aform_val e X)\n\ngoal (1 subgoal):\n 1. m \\<le> snd (aform_val e X)", "using \\<open>m \\<le> snd p2\\<close>"], ["proof (prove)\nusing this:\n  snd p2 \\<le> snd (aform_val e X)\n  m \\<le> snd p2\n\ngoal (1 subgoal):\n 1. m \\<le> snd (aform_val e X)", "by simp"], ["proof (state)\nthis:\n  m \\<le> snd (aform_val e X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<le> snd (aform_val e X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "}"], ["proof (state)\nthis:\n  m \\<le> snd (aform_val e X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "ultimately"], ["proof (chain)\npicking this:\n  snd (aform_val e X) \\<le> M\n  m \\<le> snd (aform_val e X)", "have \"aform_val e X \\<in> {(xl, m) .. (xl, M)}\""], ["proof (prove)\nusing this:\n  snd (aform_val e X) \\<le> M\n  m \\<le> snd (aform_val e X)\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> {(xl, m)..(xl, M)}", "by (auto simp: less_eq_prod_def fst_aform_val)"], ["proof (state)\nthis:\n  aform_val e X \\<in> {(xl, m)..(xl, M)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "hence \"aform_val e X \\<in> {(xl, m0) .. (xl, M0)}\""], ["proof (prove)\nusing this:\n  aform_val e X \\<in> {(xl, m)..(xl, M)}\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> {(xl, m0)..(xl, M0)}", "by (auto simp: minmax less_eq_prod_def)"], ["proof (state)\nthis:\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "}"], ["proof (state)\nthis:\n  2 < length (segments_of_aform X) \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "moreover"], ["proof (state)\nthis:\n  2 < length (segments_of_aform X) \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "{"], ["proof (state)\nthis:\n  2 < length (segments_of_aform X) \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "assume \"length (segments_of_aform X) = 2\""], ["proof (state)\nthis:\n  length (segments_of_aform X) = 2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "then"], ["proof (chain)\npicking this:\n  length (segments_of_aform X) = 2", "obtain a b where s: \"segments_of_aform X = [a, b]\""], ["proof (prove)\nusing this:\n  length (segments_of_aform X) = 2\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        segments_of_aform X = [a, b] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: numeral_2_eq_2 length_Suc_conv)"], ["proof (state)\nthis:\n  segments_of_aform X = [a, b]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from segments_of_aform_line_segment[OF this assms(2)]"], ["proof (chain)\npicking this:\n  aform_val e X \\<in> closed_segment (fst a) (snd a)", "have \"aform_val e X \\<in> closed_segment (fst a) (snd a)\""], ["proof (prove)\nusing this:\n  aform_val e X \\<in> closed_segment (fst a) (snd a)\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> closed_segment (fst a) (snd a)", "."], ["proof (state)\nthis:\n  aform_val e X \\<in> closed_segment (fst a) (snd a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "moreover"], ["proof (state)\nthis:\n  aform_val e X \\<in> closed_segment (fst a) (snd a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from assms"], ["proof (chain)\npicking this:\n  bound_intersect_2d_ud prec X xl = Some (m0, M0)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"intersect_segment_xline prec a xl = Some (m0, M0)\""], ["proof (prove)\nusing this:\n  bound_intersect_2d_ud prec X xl = Some (m0, M0)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. intersect_segment_xline prec a xl = Some (m0, M0)", "by (auto simp: bound_intersect_2d_ud_def s)"], ["proof (state)\nthis:\n  intersect_segment_xline prec a xl = Some (m0, M0)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "note intersect_segment_xline_fst_snd[OF this]"], ["proof (state)\nthis:\n  closed_segment (fst a) (snd a) \\<inter> {p. fst p = xl}\n  \\<subseteq> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "ultimately"], ["proof (chain)\npicking this:\n  aform_val e X \\<in> closed_segment (fst a) (snd a)\n  closed_segment (fst a) (snd a) \\<inter> {p. fst p = xl}\n  \\<subseteq> {(xl, m0)..(xl, M0)}", "have \"aform_val e X \\<in> {(xl, m0) .. (xl, M0)}\""], ["proof (prove)\nusing this:\n  aform_val e X \\<in> closed_segment (fst a) (snd a)\n  closed_segment (fst a) (snd a) \\<inter> {p. fst p = xl}\n  \\<subseteq> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> {(xl, m0)..(xl, M0)}", "by (auto simp: less_eq_prod_def fst_aform_val)"], ["proof (state)\nthis:\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "}"], ["proof (state)\nthis:\n  length (segments_of_aform X) = 2 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "moreover"], ["proof (state)\nthis:\n  length (segments_of_aform X) = 2 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "{"], ["proof (state)\nthis:\n  length (segments_of_aform X) = 2 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "assume \"length (segments_of_aform X) = 1\""], ["proof (state)\nthis:\n  length (segments_of_aform X) = 1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "from polychain_of_segments_of_aform1[OF this]"], ["proof (chain)\npicking this:\n  False", "have \"aform_val e X \\<in> {(xl, m0) .. (xl, M0)}\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> {(xl, m0)..(xl, M0)}", "by auto"], ["proof (state)\nthis:\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "}"], ["proof (state)\nthis:\n  length (segments_of_aform X) = 1 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "moreover"], ["proof (state)\nthis:\n  length (segments_of_aform X) = 1 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "{"], ["proof (state)\nthis:\n  length (segments_of_aform X) = 1 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "assume len: \"length (segments_of_aform X) = 0\""], ["proof (state)\nthis:\n  length (segments_of_aform X) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "hence \"independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = []\""], ["proof (prove)\nusing this:\n  length (segments_of_aform X) = 0\n\ngoal (1 subgoal):\n 1. independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = []", "by (simp add: segments_of_aform_def Let_def half_segments_of_aform_def inl_def)"], ["proof (state)\nthis:\n  independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = []\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "hence \"snd X = zero_pdevs\""], ["proof (prove)\nusing this:\n  independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = []\n\ngoal (1 subgoal):\n 1. snd X = zero_pdevs", "by (subst (asm) independent_pdevs_eq_Nil_iff) (auto simp: list_all_iff list_of_pdevs_def)"], ["proof (state)\nthis:\n  snd X = zero_pdevs\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "hence \"aform_val e X = fst X\""], ["proof (prove)\nusing this:\n  snd X = zero_pdevs\n\ngoal (1 subgoal):\n 1. aform_val e X = fst X", "by (simp add: aform_val_def)"], ["proof (state)\nthis:\n  aform_val e X = fst X\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "with len assms"], ["proof (chain)\npicking this:\n  length (segments_of_aform X) = 0\n  bound_intersect_2d_ud prec X xl = Some (m0, M0)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  aform_val e X = fst X", "have \"aform_val e X \\<in> {(xl, m0) .. (xl, M0)}\""], ["proof (prove)\nusing this:\n  length (segments_of_aform X) = 0\n  bound_intersect_2d_ud prec X xl = Some (m0, M0)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  aform_val e X = fst X\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> {(xl, m0)..(xl, M0)}", "by (auto simp: bound_intersect_2d_ud_def Let_def split: if_split_asm)"], ["proof (state)\nthis:\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "}"], ["proof (state)\nthis:\n  length (segments_of_aform X) = 0 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "ultimately"], ["proof (chain)\npicking this:\n  2 < length (segments_of_aform X) \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n  length (segments_of_aform X) = 2 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n  length (segments_of_aform X) = 1 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n  length (segments_of_aform X) = 0 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}", "have \"aform_val e X \\<in> {(xl, m0)..(xl, M0)}\""], ["proof (prove)\nusing this:\n  2 < length (segments_of_aform X) \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n  length (segments_of_aform X) = 2 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n  length (segments_of_aform X) = 1 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n  length (segments_of_aform X) = 0 \\<Longrightarrow>\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> {(xl, m0)..(xl, M0)}", "by arith"], ["proof (state)\nthis:\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) = aform_val e X; xl = fst (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "thus \"(a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}\""], ["proof (prove)\nusing this:\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "using safeassms"], ["proof (prove)\nusing this:\n  aform_val e X \\<in> {(xl, m0)..(xl, M0)}\n  (a, b) = aform_val e X\n  xl = fst (a, b)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}", "by simp"], ["proof (state)\nthis:\n  (a, b) \\<in> {(fst (a, b), m0)..(fst (a, b), M0)}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Approximation from Orthogonal Directions\\<close>"], ["", "definition inter_aform_plane_ortho::\n  \"nat \\<Rightarrow> 'a::executable_euclidean_space aform \\<Rightarrow> 'a \\<Rightarrow> real \\<Rightarrow> 'a aform option\"\n  where\n  \"inter_aform_plane_ortho p Z n g = do {\n    mMs \\<leftarrow> those (map (\\<lambda>b. bound_intersect_2d_ud p (inner2_aform Z n b) g) Basis_list);\n    let l = (\\<Sum>(b, m)\\<leftarrow>zip Basis_list (map fst mMs). m *\\<^sub>R b);\n    let u = (\\<Sum>(b, M)\\<leftarrow>zip Basis_list (map snd mMs). M *\\<^sub>R b);\n    Some (aform_of_ivl l u)\n  }\""], ["", "lemma\n  those_eq_SomeD:\n  assumes \"those (map f xs) = Some ys\"\n  shows \"ys = map (the o f) xs \\<and> (\\<forall>i.\\<exists>y. i < length xs \\<longrightarrow> f (xs ! i) = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = map (the \\<circ> f) xs \\<and>\n    (\\<forall>i.\n        \\<exists>y. i < length xs \\<longrightarrow> f (xs ! i) = Some y)", "using assms"], ["proof (prove)\nusing this:\n  those (map f xs) = Some ys\n\ngoal (1 subgoal):\n 1. ys = map (the \\<circ> f) xs \\<and>\n    (\\<forall>i.\n        \\<exists>y. i < length xs \\<longrightarrow> f (xs ! i) = Some y)", "by (induct xs arbitrary: ys) (auto split: option.split_asm simp: o_def nth_Cons split: nat.split)"], ["", "lemma\n  sum_list_zip_map:\n  assumes \"distinct xs\"\n  shows \"(\\<Sum>(x, y)\\<leftarrow>zip xs (map g xs). f x y) = (\\<Sum>x\\<in>set xs. f x (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 f xs (map g xs)) = (\\<Sum>x\\<in>set xs. f x (g x))", "by (force simp add: sum_list_distinct_conv_sum_set assms distinct_zipI1 split_beta'\n    in_set_zip in_set_conv_nth inj_on_convol_ident\n    intro!: sum.reindex_cong[where l=\"\\<lambda>x. (x, g x)\"])"], ["", "lemma\n  inter_aform_plane_ortho_overappr:\n  assumes \"inter_aform_plane_ortho p Z n g = Some X\"\n  shows \"{x. \\<forall>i \\<in> Basis. x \\<bullet> i \\<in> {y. (g, y) \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Affine Z}} \\<subseteq> Affine X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "let ?inter = \"(\\<lambda>b. bound_intersect_2d_ud p (inner2_aform Z n b) g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "obtain xs\n  where xs: \"those (map ?inter Basis_list) = Some xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        those\n         (map (\\<lambda>b. bound_intersect_2d_ud p (inner2_aform Z n b) g)\n           Basis_list) =\n        Some xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  inter_aform_plane_ortho p Z n g = Some X\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        those\n         (map (\\<lambda>b. bound_intersect_2d_ud p (inner2_aform Z n b) g)\n           Basis_list) =\n        Some xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"those (map ?inter Basis_list)\") (auto simp: inter_aform_plane_ortho_def)"], ["proof (state)\nthis:\n  those\n   (map (\\<lambda>b. bound_intersect_2d_ud p (inner2_aform Z n b) g)\n     Basis_list) =\n  Some xs\n\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "from those_eq_SomeD[OF this]"], ["proof (chain)\npicking this:\n  xs =\n  map (the \\<circ>\n       (\\<lambda>b. bound_intersect_2d_ud p (inner2_aform Z n b) g))\n   Basis_list \\<and>\n  (\\<forall>i.\n      \\<exists>y.\n         i < length Basis_list \\<longrightarrow>\n         bound_intersect_2d_ud p (inner2_aform Z n (Basis_list ! i)) g =\n         Some y)", "obtain y' where xs_eq: \"xs = map (the \\<circ> ?inter) Basis_list\"\n    and y': \"\\<And>i. i < length (Basis_list::'a list) \\<Longrightarrow> ?inter (Basis_list ! i) = Some (y' i)\""], ["proof (prove)\nusing this:\n  xs =\n  map (the \\<circ>\n       (\\<lambda>b. bound_intersect_2d_ud p (inner2_aform Z n b) g))\n   Basis_list \\<and>\n  (\\<forall>i.\n      \\<exists>y.\n         i < length Basis_list \\<longrightarrow>\n         bound_intersect_2d_ud p (inner2_aform Z n (Basis_list ! i)) g =\n         Some y)\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>xs =\n                 map (the \\<circ>\n                      (\\<lambda>b.\n                          bound_intersect_2d_ud p (inner2_aform Z n b) g))\n                  Basis_list;\n         \\<And>i.\n            i < length Basis_list \\<Longrightarrow>\n            bound_intersect_2d_ud p (inner2_aform Z n (Basis_list ! i)) g =\n            Some (y' i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs =\n  map (the \\<circ>\n       (\\<lambda>b. bound_intersect_2d_ud p (inner2_aform Z n b) g))\n   Basis_list\n  ?i < length Basis_list \\<Longrightarrow>\n  bound_intersect_2d_ud p (inner2_aform Z n (Basis_list ! ?i)) g =\n  Some (y' ?i)\n\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "have \"\\<forall>(i::'a) \\<in> Basis. \\<exists>j<length (Basis_list::'a list). i = Basis_list ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>Basis. \\<exists>j<length Basis_list. i = Basis_list ! j", "by (metis Basis_list in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>Basis. \\<exists>j<length Basis_list. i = Basis_list ! j\n\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>Basis. \\<exists>j<length Basis_list. i = Basis_list ! j", "obtain j where j:\n    \"\\<And>i::'a. i\\<in>Basis \\<Longrightarrow> j i < length (Basis_list::'a list)\"\n    \"\\<And>i::'a. i\\<in>Basis \\<Longrightarrow> i = Basis_list ! j i\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>Basis. \\<exists>j<length Basis_list. i = Basis_list ! j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>\\<And>i.\n                    i \\<in> Basis \\<Longrightarrow> j i < length Basis_list;\n         \\<And>i.\n            i \\<in> Basis \\<Longrightarrow> i = Basis_list ! j i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?i \\<in> Basis \\<Longrightarrow> j ?i < length Basis_list\n  ?i \\<in> Basis \\<Longrightarrow> ?i = Basis_list ! j ?i\n\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "define y where \"y = y' o j\""], ["proof (state)\nthis:\n  y = y' \\<circ> j\n\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "with y' j"], ["proof (chain)\npicking this:\n  ?i < length Basis_list \\<Longrightarrow>\n  bound_intersect_2d_ud p (inner2_aform Z n (Basis_list ! ?i)) g =\n  Some (y' ?i)\n  ?i \\<in> Basis \\<Longrightarrow> j ?i < length Basis_list\n  ?i \\<in> Basis \\<Longrightarrow> ?i = Basis_list ! j ?i\n  y = y' \\<circ> j", "have y: \"\\<And>i. i \\<in> Basis \\<Longrightarrow> ?inter i = Some (y i)\""], ["proof (prove)\nusing this:\n  ?i < length Basis_list \\<Longrightarrow>\n  bound_intersect_2d_ud p (inner2_aform Z n (Basis_list ! ?i)) g =\n  Some (y' ?i)\n  ?i \\<in> Basis \\<Longrightarrow> j ?i < length Basis_list\n  ?i \\<in> Basis \\<Longrightarrow> ?i = Basis_list ! j ?i\n  y = y' \\<circ> j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> Basis \\<Longrightarrow>\n       bound_intersect_2d_ud p (inner2_aform Z n i) g = Some (y i)", "by (metis comp_def)"], ["proof (state)\nthis:\n  ?i \\<in> Basis \\<Longrightarrow>\n  bound_intersect_2d_ud p (inner2_aform Z n ?i) g = Some (y ?i)\n\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "hence y_le: \"\\<And>i. i \\<in> Basis \\<Longrightarrow> fst (y i) \\<le> snd (y i)\""], ["proof (prove)\nusing this:\n  ?i \\<in> Basis \\<Longrightarrow>\n  bound_intersect_2d_ud p (inner2_aform Z n ?i) g = Some (y ?i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> Basis \\<Longrightarrow> fst (y i) \\<le> snd (y i)", "by (auto intro!: bound_intersect_2d_ud_segments_of_aform_le)"], ["proof (state)\nthis:\n  ?i \\<in> Basis \\<Longrightarrow> fst (y ?i) \\<le> snd (y ?i)\n\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "hence \"(\\<Sum>b\\<in>Basis. fst (y b) *\\<^sub>R b) \\<le> (\\<Sum>b\\<in>Basis. snd (y b) *\\<^sub>R b)\""], ["proof (prove)\nusing this:\n  ?i \\<in> Basis \\<Longrightarrow> fst (y ?i) \\<le> snd (y ?i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>Basis. fst (y b) *\\<^sub>R b)\n    \\<le> (\\<Sum>b\\<in>Basis. snd (y b) *\\<^sub>R b)", "by (auto simp: eucl_le[where 'a='a])"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>Basis. fst (y b) *\\<^sub>R b)\n  \\<le> (\\<Sum>b\\<in>Basis. snd (y b) *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "with assms"], ["proof (chain)\npicking this:\n  inter_aform_plane_ortho p Z n g = Some X\n  (\\<Sum>b\\<in>Basis. fst (y b) *\\<^sub>R b)\n  \\<le> (\\<Sum>b\\<in>Basis. snd (y b) *\\<^sub>R b)", "have X: \"Affine X = {\\<Sum>b\\<in>Basis. fst (y b) *\\<^sub>R b..\\<Sum>b\\<in>Basis. snd (y b) *\\<^sub>R b}\""], ["proof (prove)\nusing this:\n  inter_aform_plane_ortho p Z n g = Some X\n  (\\<Sum>b\\<in>Basis. fst (y b) *\\<^sub>R b)\n  \\<le> (\\<Sum>b\\<in>Basis. snd (y b) *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. Affine X =\n    {\\<Sum>b\\<in>Basis.\n       fst (y b) *\\<^sub>R b..\\<Sum>b\\<in>Basis. snd (y b) *\\<^sub>R b}", "by (auto simp: inter_aform_plane_ortho_def sum_list_zip_map xs xs_eq y Affine_aform_of_ivl)"], ["proof (state)\nthis:\n  Affine X =\n  {\\<Sum>b\\<in>Basis.\n     fst (y b) *\\<^sub>R b..\\<Sum>b\\<in>Basis. snd (y b) *\\<^sub>R b}\n\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<forall>i\\<in>Basis.\n           x \\<bullet> i\n           \\<in> {y. (g, y)\n                     \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                           Affine Z}}\n    \\<subseteq> Affine X", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "assume x: \"\\<forall>i\\<in>Basis. x \\<bullet> i \\<in> {y. (g, y) \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Affine Z}\""], ["proof (state)\nthis:\n  \\<forall>i\\<in>Basis.\n     x \\<bullet> i\n     \\<in> {y. (g, y)\n               \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                     Affine Z}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "{"], ["proof (state)\nthis:\n  \\<forall>i\\<in>Basis.\n     x \\<bullet> i\n     \\<in> {y. (g, y)\n               \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                     Affine Z}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "fix i::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "assume i: \"i \\<in> Basis\""], ["proof (state)\nthis:\n  i \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "from x i"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>Basis.\n     x \\<bullet> i\n     \\<in> {y. (g, y)\n               \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                     Affine Z}\n  i \\<in> Basis", "have x_in2: \"(g, x \\<bullet> i) \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Affine Z\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>Basis.\n     x \\<bullet> i\n     \\<in> {y. (g, y)\n               \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                     Affine Z}\n  i \\<in> Basis\n\ngoal (1 subgoal):\n 1. (g, x \\<bullet> i)\n    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Affine Z", "by auto"], ["proof (state)\nthis:\n  (g, x \\<bullet> i)\n  \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Affine Z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "from x_in2"], ["proof (chain)\npicking this:\n  (g, x \\<bullet> i)\n  \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Affine Z", "obtain e\n      where e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n        and g: \"g = aform_val e Z \\<bullet> n\"\n        and x: \"x \\<bullet> i = aform_val e Z \\<bullet> i\""], ["proof (prove)\nusing this:\n  (g, x \\<bullet> i)\n  \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Affine Z\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n         g = aform_val e Z \\<bullet> n;\n         x \\<bullet> i = aform_val e Z \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Affine_def valuate_def)"], ["proof (state)\nthis:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  g = aform_val e Z \\<bullet> n\n  x \\<bullet> i = aform_val e Z \\<bullet> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "have \"{aform_val e (inner2_aform Z n i)} = {aform_val e (inner2_aform Z n i)} \\<inter> {x. fst x = g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {aform_val e (inner2_aform Z n i)} =\n    {aform_val e (inner2_aform Z n i)} \\<inter> {x. fst x = g}", "by (auto simp: g inner2_def)"], ["proof (state)\nthis:\n  {aform_val e (inner2_aform Z n i)} =\n  {aform_val e (inner2_aform Z n i)} \\<inter> {x. fst x = g}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "also"], ["proof (state)\nthis:\n  {aform_val e (inner2_aform Z n i)} =\n  {aform_val e (inner2_aform Z n i)} \\<inter> {x. fst x = g}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "from y[OF \\<open>i \\<in> Basis\\<close>]"], ["proof (chain)\npicking this:\n  bound_intersect_2d_ud p (inner2_aform Z n i) g = Some (y i)", "have \"?inter i = Some (fst (y i), snd (y i))\""], ["proof (prove)\nusing this:\n  bound_intersect_2d_ud p (inner2_aform Z n i) g = Some (y i)\n\ngoal (1 subgoal):\n 1. bound_intersect_2d_ud p (inner2_aform Z n i) g =\n    Some (fst (y i), snd (y i))", "by simp"], ["proof (state)\nthis:\n  bound_intersect_2d_ud p (inner2_aform Z n i) g =\n  Some (fst (y i), snd (y i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "note bound_intersect_2d_ud_segments_of_aform[OF this e]"], ["proof (state)\nthis:\n  {aform_val e (inner2_aform Z n i)} \\<inter> {x. fst x = g}\n  \\<subseteq> {(g, fst (y i))..(g, snd (y i))}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "finally"], ["proof (chain)\npicking this:\n  {aform_val e (inner2_aform Z n i)}\n  \\<subseteq> {(g, fst (y i))..(g, snd (y i))}", "have \"x \\<bullet> i \\<in> {fst (y i) .. snd (y i)}\""], ["proof (prove)\nusing this:\n  {aform_val e (inner2_aform Z n i)}\n  \\<subseteq> {(g, fst (y i))..(g, snd (y i))}\n\ngoal (1 subgoal):\n 1. x \\<bullet> i \\<in> {fst (y i)..snd (y i)}", "by (auto simp: x inner2_def)"], ["proof (state)\nthis:\n  x \\<bullet> i \\<in> {fst (y i)..snd (y i)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> Basis \\<Longrightarrow>\n  x \\<bullet> ?i2 \\<in> {fst (y ?i2)..snd (y ?i2)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>Basis.\n          x \\<bullet> i\n          \\<in> {y. (g, y)\n                    \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                          Affine Z} \\<Longrightarrow>\n       x \\<in> Affine X", "thus \"x \\<in> Affine X\""], ["proof (prove)\nusing this:\n  ?i2 \\<in> Basis \\<Longrightarrow>\n  x \\<bullet> ?i2 \\<in> {fst (y ?i2)..snd (y ?i2)}\n\ngoal (1 subgoal):\n 1. x \\<in> Affine X", "unfolding X"], ["proof (prove)\nusing this:\n  ?i2 \\<in> Basis \\<Longrightarrow>\n  x \\<bullet> ?i2 \\<in> {fst (y ?i2)..snd (y ?i2)}\n\ngoal (1 subgoal):\n 1. x \\<in> {\\<Sum>b\\<in>Basis.\n               fst (y b) *\\<^sub>R\n               b..\\<Sum>b\\<in>Basis. snd (y b) *\\<^sub>R b}", "by (auto simp: eucl_le[where 'a='a])"], ["proof (state)\nthis:\n  x \\<in> Affine X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x. \\<forall>i\\<in>Basis.\n         x \\<bullet> i\n         \\<in> {y. (g, y)\n                   \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                         Affine Z}}\n  \\<subseteq> Affine X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inter_proj_eq:\n  fixes n g l\n  defines \"G \\<equiv> {x. x \\<bullet> n = g}\"\n  shows \"(\\<lambda>x. x \\<bullet> l) ` (Z \\<inter> G) =\n    {y. (g, y) \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> l)) ` Z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x \\<bullet> l) ` (Z \\<inter> G) =\n    {y. (g, y) \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> l)) ` Z}", "by (auto simp: G_def)"], ["", "lemma\n  inter_overappr:\n  fixes n \\<gamma> l\n  shows \"Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> {x. \\<forall>i \\<in> Basis. x \\<bullet> i \\<in> {y. (g, y) \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) ` Z}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<inter> {x. x \\<bullet> n = g}\n    \\<subseteq> {x. \\<forall>i\\<in>Basis.\n                       x \\<bullet> i\n                       \\<in> {y. (g, y)\n                                 \\<in> (\\<lambda>x.\n     (x \\<bullet> n, x \\<bullet> i)) `\n Z}}", "by auto"], ["", "lemma inter_inter_aform_plane_ortho:\n  assumes \"inter_aform_plane_ortho p Z n g = Some X\"\n  shows \"Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X", "note inter_overappr[of \"Affine Z\" n g]"], ["proof (state)\nthis:\n  Affine Z \\<inter> {x. x \\<bullet> n = g}\n  \\<subseteq> {x. \\<forall>i\\<in>Basis.\n                     x \\<bullet> i\n                     \\<in> {y. (g, y)\n                               \\<in> (\\<lambda>x.\n   (x \\<bullet> n, x \\<bullet> i)) `\n                                     Affine Z}}\n\ngoal (1 subgoal):\n 1. Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X", "also"], ["proof (state)\nthis:\n  Affine Z \\<inter> {x. x \\<bullet> n = g}\n  \\<subseteq> {x. \\<forall>i\\<in>Basis.\n                     x \\<bullet> i\n                     \\<in> {y. (g, y)\n                               \\<in> (\\<lambda>x.\n   (x \\<bullet> n, x \\<bullet> i)) `\n                                     Affine Z}}\n\ngoal (1 subgoal):\n 1. Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X", "note inter_aform_plane_ortho_overappr[OF assms]"], ["proof (state)\nthis:\n  {x. \\<forall>i\\<in>Basis.\n         x \\<bullet> i\n         \\<in> {y. (g, y)\n                   \\<in> (\\<lambda>x. (x \\<bullet> n, x \\<bullet> i)) `\n                         Affine Z}}\n  \\<subseteq> Affine X\n\ngoal (1 subgoal):\n 1. Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X", "finally"], ["proof (chain)\npicking this:\n  Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X", "show ?thesis"], ["proof (prove)\nusing this:\n  Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X\n\ngoal (1 subgoal):\n 1. Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X", "."], ["proof (state)\nthis:\n  Affine Z \\<inter> {x. x \\<bullet> n = g} \\<subseteq> Affine X\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>``Completeness'' of Intersection\\<close>"], ["", "abbreviation \"encompasses x seg \\<equiv> det3 (fst seg) (snd seg) x \\<ge> 0\""], ["", "lemma encompasses_cases:\n  \"encompasses x seg \\<or> encompasses x (snd seg, fst seg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 (fst seg) (snd seg) x \\<or>\n    0 \\<le> det3 (fst (snd seg, fst seg)) (snd (snd seg, fst seg)) x", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma list_all_encompasses_cases:\n  assumes \"list_all (encompasses p) (x # y # zs)\"\n  obtains \"list_all (encompasses p) [x, y, (snd y, fst x)]\"\n    | \"list_all (encompasses p) ((fst x, snd y)#zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using encompasses_cases"], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst ?seg) (snd ?seg) ?x \\<or>\n  0 \\<le> det3 (fst (snd ?seg, fst ?seg)) (snd (snd ?seg, fst ?seg)) ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst ?seg3) (snd ?seg3) ?x3\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst (snd ?seg3, fst ?seg3)) (snd (snd ?seg3, fst ?seg3))\n              ?x3\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"encompasses p (snd y, fst x)\""], ["proof (state)\nthis:\n  0 \\<le> det3 (fst (snd y, fst x)) (snd (snd y, fst x)) p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst ?seg3) (snd ?seg3) ?x3\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst (snd ?seg3, fst ?seg3)) (snd (snd ?seg3, fst ?seg3))\n              ?x3\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"list_all (encompasses p) [x, y, (snd y, fst x)]\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst (snd y, fst x)) (snd (snd y, fst x)) p\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     [x, y, (snd y, fst x)]", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst (snd y, fst x)) (snd (snd y, fst x)) p\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p) (x # y # zs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     [x, y, (snd y, fst x)]", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   [x, y, (snd y, fst x)]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst ?seg3) (snd ?seg3) ?x3\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst (snd ?seg3, fst ?seg3)) (snd (snd ?seg3, fst ?seg3))\n              ?x3\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   [x, y, (snd y, fst x)]\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst (snd (snd y, fst x), fst (snd y, fst x)))\n              (snd (snd (snd y, fst x), fst (snd y, fst x))) p\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst (snd (snd y, fst x), fst (snd y, fst x)))\n              (snd (snd (snd y, fst x), fst (snd y, fst x))) p\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"encompasses p (snd (snd y, fst x), fst (snd y, fst x))\""], ["proof (state)\nthis:\n  0 \\<le> det3 (fst (snd (snd y, fst x), fst (snd y, fst x)))\n           (snd (snd (snd y, fst x), fst (snd y, fst x))) p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst (snd (snd y, fst x), fst (snd y, fst x)))\n              (snd (snd (snd y, fst x), fst (snd y, fst x))) p\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"list_all (encompasses p) ((fst x, snd y)#zs)\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst (snd (snd y, fst x), fst (snd y, fst x)))\n           (snd (snd (snd y, fst x), fst (snd y, fst x))) p\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # zs)", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> det3 (fst (snd (snd y, fst x), fst (snd y, fst x)))\n           (snd (snd (snd y, fst x), fst (snd y, fst x))) p\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p) (x # y # zs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # zs)", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   ((fst x, snd y) # zs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n              [x, y, (snd y, fst x)] \\<Longrightarrow>\n             thesis;\n     list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n      ((fst x, snd y) # zs) \\<Longrightarrow>\n     thesis;\n     0 \\<le> det3 (fst (snd (snd y, fst x), fst (snd y, fst x)))\n              (snd (snd (snd y, fst x), fst (snd y, fst x))) p\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   ((fst x, snd y) # zs)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma triangle_encompassing_polychain_of:\n  assumes \"det3 p a b \\<ge> 0\" \"det3 p b c \\<ge> 0\" \"det3 p c a \\<ge> 0\"\n  assumes \"ccw' a b c\"\n  shows \"p \\<in> convex hull {a, b, c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> convex hull {a, b, c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> convex hull {a, b, c}", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> det3 p a b\n  0 \\<le> det3 p b c\n  0 \\<le> det3 p c a\n  ccw' a b c", "have nn: \"det3 b c p \\<ge> 0\" \"det3 c a p \\<ge> 0\" \"det3 a b p \\<ge> 0\" \"det3 a b c \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 p a b\n  0 \\<le> det3 p b c\n  0 \\<le> det3 p c a\n  ccw' a b c\n\ngoal (1 subgoal):\n 1. (0 \\<le> det3 b c p &&& 0 \\<le> det3 c a p) &&&\n    0 \\<le> det3 a b p &&& 0 \\<le> det3 a b c", "by (auto simp: det3_def' algebra_simps)"], ["proof (state)\nthis:\n  0 \\<le> det3 b c p\n  0 \\<le> det3 c a p\n  0 \\<le> det3 a b p\n  0 \\<le> det3 a b c\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull {a, b, c}", "have \"det3 a b c *\\<^sub>R p = det3 b c p *\\<^sub>R a + det3 c a p *\\<^sub>R b + det3 a b p *\\<^sub>R c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 a b c *\\<^sub>R p =\n    det3 b c p *\\<^sub>R a + det3 c a p *\\<^sub>R b + det3 a b p *\\<^sub>R c", "by (auto simp: det3_def' algebra_simps prod_eq_iff)"], ["proof (state)\nthis:\n  det3 a b c *\\<^sub>R p =\n  det3 b c p *\\<^sub>R a + det3 c a p *\\<^sub>R b + det3 a b p *\\<^sub>R c\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull {a, b, c}", "hence \"inverse (det3 a b c) *\\<^sub>R (det3 a b c *\\<^sub>R p) =\n      inverse (det3 a b c) *\\<^sub>R (det3 b c p *\\<^sub>R a + det3 c a p *\\<^sub>R b + det3 a b p *\\<^sub>R c)\""], ["proof (prove)\nusing this:\n  det3 a b c *\\<^sub>R p =\n  det3 b c p *\\<^sub>R a + det3 c a p *\\<^sub>R b + det3 a b p *\\<^sub>R c\n\ngoal (1 subgoal):\n 1. det3 a b c *\\<^sub>R p /\\<^sub>R det3 a b c =\n    (det3 b c p *\\<^sub>R a + det3 c a p *\\<^sub>R b +\n     det3 a b p *\\<^sub>R c) /\\<^sub>R\n    det3 a b c", "by simp"], ["proof (state)\nthis:\n  det3 a b c *\\<^sub>R p /\\<^sub>R det3 a b c =\n  (det3 b c p *\\<^sub>R a + det3 c a p *\\<^sub>R b +\n   det3 a b p *\\<^sub>R c) /\\<^sub>R\n  det3 a b c\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull {a, b, c}", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> det3 p a b\n  0 \\<le> det3 p b c\n  0 \\<le> det3 p c a\n  ccw' a b c\n  det3 a b c *\\<^sub>R p /\\<^sub>R det3 a b c =\n  (det3 b c p *\\<^sub>R a + det3 c a p *\\<^sub>R b +\n   det3 a b p *\\<^sub>R c) /\\<^sub>R\n  det3 a b c", "have p_eq: \"p =\n    (det3 b c p / det3 a b c) *\\<^sub>R a + (det3 c a p / det3 a b c) *\\<^sub>R b + (det3 a b p / det3 a b c) *\\<^sub>R c\"\n    (is \"_ = scaleR ?u _ + scaleR ?v _ + scaleR ?w _\")"], ["proof (prove)\nusing this:\n  0 \\<le> det3 p a b\n  0 \\<le> det3 p b c\n  0 \\<le> det3 p c a\n  ccw' a b c\n  det3 a b c *\\<^sub>R p /\\<^sub>R det3 a b c =\n  (det3 b c p *\\<^sub>R a + det3 c a p *\\<^sub>R b +\n   det3 a b p *\\<^sub>R c) /\\<^sub>R\n  det3 a b c\n\ngoal (1 subgoal):\n 1. p =\n    (det3 b c p / det3 a b c) *\\<^sub>R a +\n    (det3 c a p / det3 a b c) *\\<^sub>R b +\n    (det3 a b p / det3 a b c) *\\<^sub>R c", "by (simp add: inverse_eq_divide algebra_simps ccw'_def)"], ["proof (state)\nthis:\n  p =\n  (det3 b c p / det3 a b c) *\\<^sub>R a +\n  (det3 c a p / det3 a b c) *\\<^sub>R b +\n  (det3 a b p / det3 a b c) *\\<^sub>R c\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull {a, b, c}", "have det_eq: \"det3 b c p / det3 a b c + det3 c a p / det3 a b c + det3 a b p / det3 a b c = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 b c p / det3 a b c + det3 c a p / det3 a b c +\n    det3 a b p / det3 a b c =\n    1", "using assms(4)"], ["proof (prove)\nusing this:\n  ccw' a b c\n\ngoal (1 subgoal):\n 1. det3 b c p / det3 a b c + det3 c a p / det3 a b c +\n    det3 a b p / det3 a b c =\n    1", "by (simp add: add_divide_distrib[symmetric] det3_def' algebra_simps ccw'_def)"], ["proof (state)\nthis:\n  det3 b c p / det3 a b c + det3 c a p / det3 a b c +\n  det3 a b p / det3 a b c =\n  1\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull {a, b, c}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> convex hull {a, b, c}", "unfolding convex_hull_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> {u *\\<^sub>R a + v *\\<^sub>R b + w *\\<^sub>R c |u v w.\n             0 \\<le> u \\<and>\n             0 \\<le> v \\<and> 0 \\<le> w \\<and> u + v + w = 1}", "using assms(4)"], ["proof (prove)\nusing this:\n  ccw' a b c\n\ngoal (1 subgoal):\n 1. p \\<in> {u *\\<^sub>R a + v *\\<^sub>R b + w *\\<^sub>R c |u v w.\n             0 \\<le> u \\<and>\n             0 \\<le> v \\<and> 0 \\<le> w \\<and> u + v + w = 1}", "by (blast intro: exI[where x=\"?u\"] exI[where x=\"?v\"] exI[where x=\"?w\"]\n      intro!: p_eq divide_nonneg_nonneg nn det_eq)"], ["proof (state)\nthis:\n  p \\<in> convex hull {a, b, c}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encompasses_convex_polygon3:\n  assumes \"list_all (encompasses p) (x#y#z#zs)\"\n  assumes \"convex_polygon (x#y#z#zs)\"\n  assumes \"ccw'.sortedP (fst x) (map snd (butlast (x#y#z#zs)))\"\n  shows \"p \\<in> convex hull (set (map fst (x#y#z#zs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (x # y # z # zs))", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (x # y # z # zs)\n  convex_polygon (x # y # z # zs)\n  ccw'.sortedP (fst x) (map snd (butlast (x # y # z # zs)))\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (x # y # z # zs))", "proof (induct zs arbitrary: x y z p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z p.\n       \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n                 [x, y, z];\n        convex_polygon [x, y, z];\n        ccw'.sortedP (fst x) (map snd (butlast [x, y, z]))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> convex hull set (map fst [x, y, z])\n 2. \\<And>a zs x y z p.\n       \\<lbrakk>\\<And>x y z p.\n                   \\<lbrakk>list_all\n                             (\\<lambda>seg.\n                                 0 \\<le> det3 (fst seg) (snd seg) p)\n                             (x # y # z # zs);\n                    convex_polygon (x # y # z # zs);\n                    ccw'.sortedP (fst x)\n                     (map snd (butlast (x # y # z # zs)))\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> convex hull\n       set (map fst (x # y # z # zs));\n        list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n         (x # y # z # a # zs);\n        convex_polygon (x # y # z # a # zs);\n        ccw'.sortedP (fst x)\n         (map snd (butlast (x # y # z # a # zs)))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> convex hull\n                                 set (map fst (x # y # z # a # zs))", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p) [x, y, z]\n  convex_polygon [x, y, z]\n  ccw'.sortedP (fst x) (map snd (butlast [x, y, z]))\n\ngoal (2 subgoals):\n 1. \\<And>x y z p.\n       \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n                 [x, y, z];\n        convex_polygon [x, y, z];\n        ccw'.sortedP (fst x) (map snd (butlast [x, y, z]))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> convex hull set (map fst [x, y, z])\n 2. \\<And>a zs x y z p.\n       \\<lbrakk>\\<And>x y z p.\n                   \\<lbrakk>list_all\n                             (\\<lambda>seg.\n                                 0 \\<le> det3 (fst seg) (snd seg) p)\n                             (x # y # z # zs);\n                    convex_polygon (x # y # z # zs);\n                    ccw'.sortedP (fst x)\n                     (map snd (butlast (x # y # z # zs)))\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> convex hull\n       set (map fst (x # y # z # zs));\n        list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n         (x # y # z # a # zs);\n        convex_polygon (x # y # z # a # zs);\n        ccw'.sortedP (fst x)\n         (map snd (butlast (x # y # z # a # zs)))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> convex hull\n                                 set (map fst (x # y # z # a # zs))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p) [x, y, z]\n  convex_polygon [x, y, z]\n  ccw'.sortedP (fst x) (map snd (butlast [x, y, z]))\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst [x, y, z])", "by (auto simp: det3_def' algebra_simps\n      elim!: ccw'.sortedP_Cons ccw'.sortedP_Nil\n      intro!: triangle_encompassing_polychain_of)"], ["proof (state)\nthis:\n  p \\<in> convex hull set (map fst [x, y, z])\n\ngoal (1 subgoal):\n 1. \\<And>a zs x y z p.\n       \\<lbrakk>\\<And>x y z p.\n                   \\<lbrakk>list_all\n                             (\\<lambda>seg.\n                                 0 \\<le> det3 (fst seg) (snd seg) p)\n                             (x # y # z # zs);\n                    convex_polygon (x # y # z # zs);\n                    ccw'.sortedP (fst x)\n                     (map snd (butlast (x # y # z # zs)))\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> convex hull\n       set (map fst (x # y # z # zs));\n        list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n         (x # y # z # a # zs);\n        convex_polygon (x # y # z # a # zs);\n        ccw'.sortedP (fst x)\n         (map snd (butlast (x # y # z # a # zs)))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> convex hull\n                                 set (map fst (x # y # z # a # zs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a zs x y z p.\n       \\<lbrakk>\\<And>x y z p.\n                   \\<lbrakk>list_all\n                             (\\<lambda>seg.\n                                 0 \\<le> det3 (fst seg) (snd seg) p)\n                             (x # y # z # zs);\n                    convex_polygon (x # y # z # zs);\n                    ccw'.sortedP (fst x)\n                     (map snd (butlast (x # y # z # zs)))\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> convex hull\n       set (map fst (x # y # z # zs));\n        list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n         (x # y # z # a # zs);\n        convex_polygon (x # y # z # a # zs);\n        ccw'.sortedP (fst x)\n         (map snd (butlast (x # y # z # a # zs)))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> convex hull\n                                 set (map fst (x # y # z # a # zs))", "case (Cons w ws)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) ?p)\n            (?x # ?y # ?z # ws);\n   convex_polygon (?x # ?y # ?z # ws);\n   ccw'.sortedP (fst ?x) (map snd (butlast (?x # ?y # ?z # ws)))\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> convex hull set (map fst (?x # ?y # ?z # ws))\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (x # y # z # w # ws)\n  convex_polygon (x # y # z # w # ws)\n  ccw'.sortedP (fst x) (map snd (butlast (x # y # z # w # ws)))\n\ngoal (1 subgoal):\n 1. \\<And>a zs x y z p.\n       \\<lbrakk>\\<And>x y z p.\n                   \\<lbrakk>list_all\n                             (\\<lambda>seg.\n                                 0 \\<le> det3 (fst seg) (snd seg) p)\n                             (x # y # z # zs);\n                    convex_polygon (x # y # z # zs);\n                    ccw'.sortedP (fst x)\n                     (map snd (butlast (x # y # z # zs)))\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> convex hull\n       set (map fst (x # y # z # zs));\n        list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n         (x # y # z # a # zs);\n        convex_polygon (x # y # z # a # zs);\n        ccw'.sortedP (fst x)\n         (map snd (butlast (x # y # z # a # zs)))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> convex hull\n                                 set (map fst (x # y # z # a # zs))", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  convex_polygon (x # y # z # w # ws)", "have \"snd y = fst z\""], ["proof (prove)\nusing this:\n  convex_polygon (x # y # z # w # ws)\n\ngoal (1 subgoal):\n 1. snd y = fst z", "by auto"], ["proof (state)\nthis:\n  snd y = fst z\n\ngoal (1 subgoal):\n 1. \\<And>a zs x y z p.\n       \\<lbrakk>\\<And>x y z p.\n                   \\<lbrakk>list_all\n                             (\\<lambda>seg.\n                                 0 \\<le> det3 (fst seg) (snd seg) p)\n                             (x # y # z # zs);\n                    convex_polygon (x # y # z # zs);\n                    ccw'.sortedP (fst x)\n                     (map snd (butlast (x # y # z # zs)))\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> convex hull\n       set (map fst (x # y # z # zs));\n        list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n         (x # y # z # a # zs);\n        convex_polygon (x # y # z # a # zs);\n        ccw'.sortedP (fst x)\n         (map snd (butlast (x # y # z # a # zs)))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> convex hull\n                                 set (map fst (x # y # z # a # zs))", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (x # y # z # w # ws)", "show ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (x # y # z # w # ws)\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (x # y # z # w # ws))", "proof (rule list_all_encompasses_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     [x, y, (snd y, fst x)] \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))\n 2. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "assume \"list_all (encompasses p) [x, y, (snd y, fst x)]\""], ["proof (state)\nthis:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   [x, y, (snd y, fst x)]\n\ngoal (2 subgoals):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     [x, y, (snd y, fst x)] \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))\n 2. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "hence \"p \\<in> convex hull {fst x, fst y, snd y}\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   [x, y, (snd y, fst x)]\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull {fst x, fst y, snd y}", "using Cons.prems"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   [x, y, (snd y, fst x)]\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (x # y # z # w # ws)\n  convex_polygon (x # y # z # w # ws)\n  ccw'.sortedP (fst x) (map snd (butlast (x # y # z # w # ws)))\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull {fst x, fst y, snd y}", "by (auto simp: det3_def' algebra_simps\n        elim!: ccw'.sortedP_Cons ccw'.sortedP_Nil\n        intro!: triangle_encompassing_polychain_of)"], ["proof (state)\nthis:\n  p \\<in> convex hull {fst x, fst y, snd y}\n\ngoal (2 subgoals):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     [x, y, (snd y, fst x)] \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))\n 2. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "thus ?case"], ["proof (prove)\nusing this:\n  p \\<in> convex hull {fst x, fst y, snd y}\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (x # y # z # w # ws))", "by (rule rev_subsetD[OF _ hull_mono]) (auto simp: \\<open>snd y = fst z\\<close>)"], ["proof (state)\nthis:\n  p \\<in> convex hull set (map fst (x # y # z # w # ws))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "assume *: \"list_all (encompasses p) ((fst x, snd y) # z # w # ws)\""], ["proof (state)\nthis:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   ((fst x, snd y) # z # w # ws)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "from Cons.prems"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (x # y # z # w # ws)\n  convex_polygon (x # y # z # w # ws)\n  ccw'.sortedP (fst x) (map snd (butlast (x # y # z # w # ws)))", "have enc: \"ws \\<noteq> [] \\<Longrightarrow> encompasses p (last ws)\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (x # y # z # w # ws)\n  convex_polygon (x # y # z # w # ws)\n  ccw'.sortedP (fst x) (map snd (butlast (x # y # z # w # ws)))\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    0 \\<le> det3 (fst (last ws)) (snd (last ws)) p", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  ws \\<noteq> [] \\<Longrightarrow>\n  0 \\<le> det3 (fst (last ws)) (snd (last ws)) p\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "have \"set (map fst ((fst x, snd y)#z#w#ws)) \\<subseteq> set (map fst (x # y # z # w # ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst ((fst x, snd y) # z # w # ws))\n    \\<subseteq> set (map fst (x # y # z # w # ws))", "by auto"], ["proof (state)\nthis:\n  set (map fst ((fst x, snd y) # z # w # ws))\n  \\<subseteq> set (map fst (x # y # z # w # ws))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "moreover"], ["proof (state)\nthis:\n  set (map fst ((fst x, snd y) # z # w # ws))\n  \\<subseteq> set (map fst (x # y # z # w # ws))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "{"], ["proof (state)\nthis:\n  set (map fst ((fst x, snd y) # z # w # ws))\n  \\<subseteq> set (map fst (x # y # z # w # ws))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "note *"], ["proof (state)\nthis:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   ((fst x, snd y) # z # w # ws)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   ((fst x, snd y) # z # w # ws)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "have \"convex_polygon ((fst x, snd y) # z # w # ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polygon ((fst x, snd y) # z # w # ws)", "by (metis convex_polygon_skip Cons.prems(2,3))"], ["proof (state)\nthis:\n  convex_polygon ((fst x, snd y) # z # w # ws)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "moreover"], ["proof (state)\nthis:\n  convex_polygon ((fst x, snd y) # z # w # ws)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "have \"ccw'.sortedP (fst (fst x, snd y)) (map snd (butlast ((fst x, snd y) # z # w # ws)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (fst (fst x, snd y))\n     (map snd (butlast ((fst x, snd y) # z # w # ws)))", "using Cons.prems(3)"], ["proof (prove)\nusing this:\n  ccw'.sortedP (fst x) (map snd (butlast (x # y # z # w # ws)))\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (fst (fst x, snd y))\n     (map snd (butlast ((fst x, snd y) # z # w # ws)))", "by (auto elim!: ccw'.sortedP_Cons intro!: ccw'.sortedP.Cons ccw'.sortedP.Nil\n          split: if_split_asm)"], ["proof (state)\nthis:\n  ccw'.sortedP (fst (fst x, snd y))\n   (map snd (butlast ((fst x, snd y) # z # w # ws)))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "ultimately"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   ((fst x, snd y) # z # w # ws)\n  convex_polygon ((fst x, snd y) # z # w # ws)\n  ccw'.sortedP (fst (fst x, snd y))\n   (map snd (butlast ((fst x, snd y) # z # w # ws)))", "have \"p \\<in> convex hull set (map fst ((fst x, snd y)#z#w#ws))\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   ((fst x, snd y) # z # w # ws)\n  convex_polygon ((fst x, snd y) # z # w # ws)\n  ccw'.sortedP (fst (fst x, snd y))\n   (map snd (butlast ((fst x, snd y) # z # w # ws)))\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst ((fst x, snd y) # z # w # ws))", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  p \\<in> convex hull set (map fst ((fst x, snd y) # z # w # ws))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "}"], ["proof (state)\nthis:\n  p \\<in> convex hull set (map fst ((fst x, snd y) # z # w # ws))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n     ((fst x, snd y) # z # w # ws) \\<Longrightarrow>\n    p \\<in> convex hull set (map fst (x # y # z # w # ws))", "ultimately"], ["proof (chain)\npicking this:\n  set (map fst ((fst x, snd y) # z # w # ws))\n  \\<subseteq> set (map fst (x # y # z # w # ws))\n  p \\<in> convex hull set (map fst ((fst x, snd y) # z # w # ws))", "show \"p \\<in> convex hull set (map fst (x # y # z # w # ws))\""], ["proof (prove)\nusing this:\n  set (map fst ((fst x, snd y) # z # w # ws))\n  \\<subseteq> set (map fst (x # y # z # w # ws))\n  p \\<in> convex hull set (map fst ((fst x, snd y) # z # w # ws))\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (x # y # z # w # ws))", "by (rule subsetD[OF hull_mono])"], ["proof (state)\nthis:\n  p \\<in> convex hull set (map fst (x # y # z # w # ws))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> convex hull set (map fst (x # y # z # w # ws))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma segments_of_aform_empty_Affine_eq:\n  assumes \"segments_of_aform X = []\"\n  shows \"Affine X = {fst X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Affine X = {fst X}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Affine X = {fst X}", "have \"independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = [] \\<longleftrightarrow>\n    (list_of_pdevs (nlex_pdevs (snd X))) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))) =\n     []) =\n    (list_of_pdevs (nlex_pdevs (snd X)) = [])", "by (subst independent_pdevs_eq_Nil_iff) (auto simp: list_all_iff list_of_pdevs_def )"], ["proof (state)\nthis:\n  (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = []) =\n  (list_of_pdevs (nlex_pdevs (snd X)) = [])\n\ngoal (1 subgoal):\n 1. Affine X = {fst X}", "with assms"], ["proof (chain)\npicking this:\n  segments_of_aform X = []\n  (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = []) =\n  (list_of_pdevs (nlex_pdevs (snd X)) = [])", "show ?thesis"], ["proof (prove)\nusing this:\n  segments_of_aform X = []\n  (independent_pdevs (map snd (list_of_pdevs (nlex_pdevs (snd X)))) = []) =\n  (list_of_pdevs (nlex_pdevs (snd X)) = [])\n\ngoal (1 subgoal):\n 1. Affine X = {fst X}", "by (force simp: aform_val_def list_of_pdevs_def Affine_def valuate_def segments_of_aform_def\n      Let_def half_segments_of_aform_def inl_def)"], ["proof (state)\nthis:\n  Affine X = {fst X}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_segments_of_aform_singleton: \"segments_of_aform X \\<noteq> [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. segments_of_aform X \\<noteq> [x]", "by (auto simp: segments_of_aform_def Let_def add_is_1 dest!: arg_cong[where f=length])"], ["", "lemma encompasses_segments_of_aform_in_AffineI:\n  assumes \"length (segments_of_aform X) > 2\"\n  assumes \"list_all (encompasses p) (segments_of_aform X)\"\n  shows \"p \\<in> Affine X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "from assms(1)"], ["proof (chain)\npicking this:\n  2 < length (segments_of_aform X)", "obtain x y z zs where eq: \"segments_of_aform X = x#y#z#zs\""], ["proof (prove)\nusing this:\n  2 < length (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. (\\<And>x y z zs.\n        segments_of_aform X = x # y # z # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"segments_of_aform X\" rule: list_cases4) auto"], ["proof (state)\nthis:\n  segments_of_aform X = x # y # z # zs\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "hence \"fst x = fst (hd (half_segments_of_aform X))\""], ["proof (prove)\nusing this:\n  segments_of_aform X = x # y # z # zs\n\ngoal (1 subgoal):\n 1. fst x = fst (hd (half_segments_of_aform X))", "by (metis segments_of_aform_def hd_append list.map_disc_iff list.sel(1))"], ["proof (state)\nthis:\n  fst x = fst (hd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "also"], ["proof (state)\nthis:\n  fst x = fst (hd (half_segments_of_aform X))\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "have \"\\<dots> = lowest_vertex (fst X, nlex_pdevs (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (hd (half_segments_of_aform X)) =\n    lowest_vertex (fst X, nlex_pdevs (snd X))", "using assms"], ["proof (prove)\nusing this:\n  2 < length (segments_of_aform X)\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. fst (hd (half_segments_of_aform X)) =\n    lowest_vertex (fst X, nlex_pdevs (snd X))", "by (intro fst_hd_half_segments_of_aform) (auto simp: segments_of_aform_def)"], ["proof (state)\nthis:\n  fst (hd (half_segments_of_aform X)) =\n  lowest_vertex (fst X, nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "finally"], ["proof (chain)\npicking this:\n  fst x = lowest_vertex (fst X, nlex_pdevs (snd X))", "have fstx: \"fst x = lowest_vertex (fst X, nlex_pdevs (snd X))\""], ["proof (prove)\nusing this:\n  fst x = lowest_vertex (fst X, nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. fst x = lowest_vertex (fst X, nlex_pdevs (snd X))", "."], ["proof (state)\nthis:\n  fst x = lowest_vertex (fst X, nlex_pdevs (snd X))\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "have \"p \\<in> convex hull (set (map fst (segments_of_aform X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (segments_of_aform X))", "using assms(2)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (segments_of_aform X))", "unfolding eq"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>seg. 0 \\<le> det3 (fst seg) (snd seg) p)\n   (x # y # z # zs)\n\ngoal (1 subgoal):\n 1. p \\<in> convex hull set (map fst (x # y # z # zs))", "proof (rule encompasses_convex_polygon3)"], ["proof (state)\ngoal (2 subgoals):\n 1. convex_polygon (x # y # z # zs)\n 2. ccw'.sortedP (fst x) (map snd (butlast (x # y # z # zs)))", "show \"convex_polygon (x # y # z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_polygon (x # y # z # zs)", "using assms(1)"], ["proof (prove)\nusing this:\n  2 < length (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. convex_polygon (x # y # z # zs)", "unfolding eq[symmetric]"], ["proof (prove)\nusing this:\n  2 < length (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. convex_polygon (segments_of_aform X)", "by (intro convex_polygon_segments_of_aform) (simp add: segments_of_aform_def Let_def)"], ["proof (state)\nthis:\n  convex_polygon (x # y # z # zs)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (fst x) (map snd (butlast (x # y # z # zs)))", "show \"ccw'.sortedP (fst x) (map snd (butlast (x # y # z # zs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw'.sortedP (fst x) (map snd (butlast (x # y # z # zs)))", "using assms(1)"], ["proof (prove)\nusing this:\n  2 < length (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (fst x) (map snd (butlast (x # y # z # zs)))", "unfolding fstx map_butlast eq[symmetric]"], ["proof (prove)\nusing this:\n  2 < length (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. ccw'.sortedP (lowest_vertex (fst X, nlex_pdevs (snd X)))\n     (butlast (map snd (segments_of_aform X)))", "by (intro ccw'_sortedP_snd_segments_of_aform)\n        (simp add: segments_of_aform_def Let_def half_segments_of_aform_def)"], ["proof (state)\nthis:\n  ccw'.sortedP (fst x) (map snd (butlast (x # y # z # zs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> convex hull set (map fst (segments_of_aform X))\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "also"], ["proof (state)\nthis:\n  p \\<in> convex hull set (map fst (segments_of_aform X))\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "have \"\\<dots> \\<subseteq> convex hull (Affine X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex hull set (map fst (segments_of_aform X))\n    \\<subseteq> convex hull Affine X", "proof (rule hull_mono, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (map fst (segments_of_aform X)) \\<Longrightarrow>\n       (a, b) \\<in> Affine X", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (map fst (segments_of_aform X)) \\<Longrightarrow>\n       (a, b) \\<in> Affine X", "assume \"(a, b) \\<in> set (map fst (segments_of_aform X))\""], ["proof (state)\nthis:\n  (a, b) \\<in> set (map fst (segments_of_aform X))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (map fst (segments_of_aform X)) \\<Longrightarrow>\n       (a, b) \\<in> Affine X", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set (map fst (segments_of_aform X))", "obtain c d where \"((a, b), c, d) \\<in> set (segments_of_aform X)\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> set (map fst (segments_of_aform X))\n\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        ((a, b), c, d) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ((a, b), c, d) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (map fst (segments_of_aform X)) \\<Longrightarrow>\n       (a, b) \\<in> Affine X", "from previous_segments_of_aformE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      (x, a, b) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain x where \"(x, a, b) \\<in> set (segments_of_aform X)\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      (x, a, b) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, a, b) \\<in> set (segments_of_aform X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, a, b) \\<in> set (segments_of_aform X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (map fst (segments_of_aform X)) \\<Longrightarrow>\n       (a, b) \\<in> Affine X", "from in_set_segments_of_aform_aform_valE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>e.\n      \\<lbrakk>(a, b) = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e where \"(a, b) = aform_val e X\" \"e \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>e.\n      \\<lbrakk>(a, b) = aform_val e X;\n       e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>(a, b) = aform_val e X;\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a, b) = aform_val e X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (map fst (segments_of_aform X)) \\<Longrightarrow>\n       (a, b) \\<in> Affine X", "thus \"(a, b) \\<in> Affine X\""], ["proof (prove)\nusing this:\n  (a, b) = aform_val e X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> Affine X", "by (auto simp: Affine_def valuate_def image_iff)"], ["proof (state)\nthis:\n  (a, b) \\<in> Affine X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  convex hull set (map fst (segments_of_aform X))\n  \\<subseteq> convex hull Affine X\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "also"], ["proof (state)\nthis:\n  convex hull set (map fst (segments_of_aform X))\n  \\<subseteq> convex hull Affine X\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "have \"\\<dots> = Affine X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex hull Affine X = Affine X", "by (simp add: convex_Affine convex_hull_eq)"], ["proof (state)\nthis:\n  convex hull Affine X = Affine X\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "finally"], ["proof (chain)\npicking this:\n  p \\<in> Affine X", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> Affine X\n\ngoal (1 subgoal):\n 1. p \\<in> Affine X", "."], ["proof (state)\nthis:\n  p \\<in> Affine X\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}