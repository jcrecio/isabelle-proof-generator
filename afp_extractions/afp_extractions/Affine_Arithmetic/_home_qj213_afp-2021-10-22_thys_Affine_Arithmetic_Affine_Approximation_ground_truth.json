{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Affine_Approximation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma convex_on_imp_above_tangent:\\<comment> \\<open>TODO: generalizes @{thm convex_on_imp_above_tangent}\\<close>\n  assumes convex: \"convex_on A f\" and connected: \"connected A\"\n  assumes c: \"c \\<in> A\" and x : \"x \\<in> A\"\n  assumes deriv: \"(f has_field_derivative f') (at c within A)\"\n  shows   \"f x - f c \\<ge> f' * (x - c)\"", "lemma Affine_notempty[intro, simp]: \"Affine X \\<noteq> {}\"", "lemma truncate_up_lt: \"x < y \\<Longrightarrow> x < truncate_up prec y\"", "lemma truncate_up_pos_eq[simp]: \"0 < truncate_up p x \\<longleftrightarrow> 0 < x\"", "lemma inner_scaleR_pdevs_0: \"inner_scaleR_pdevs 0 One_pdevs = zero_pdevs\"", "lemma Affine_aform_of_point_eq[simp]: \"Affine (aform_of_point p) = {p}\"", "lemma mem_Affine_aform_of_point: \"x \\<in> Affine (aform_of_point x)\"", "lemma\n  aform_val_aform_of_ivl_innerE:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"a \\<le> b\" \"c \\<in> Basis\"\n  obtains f where \"aform_val e (aform_of_ivl a b) \\<bullet> c = aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))\"\n    \"f \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma pdevs_apply_coord_pdevs [simp]: \"pdevs_apply (coord_pdevs i) x = (if x = i then 1 else 0)\"", "lemma degree_coord_pdevs[simp]: \"degree (coord_pdevs i) = Suc i\"", "lemma pdevs_val_coord_pdevs[simp]: \"pdevs_val e (coord_pdevs i) = e i\"", "lemma\n  aforms_of_ivls:\n  assumes \"length ls = length us\" \"length xs = length ls\"\n  assumes \"\\<And>i. i < length xs \\<Longrightarrow> xs ! i \\<in> {ls ! i .. us ! i}\"\n  shows \"xs \\<in> Joints (aforms_of_ivls ls us)\"", "lemma\n  eucl_fold_mono:\n  fixes f::\"'a::ordered_euclidean_space\\<Rightarrow>'a\\<Rightarrow>'a\"\n  assumes mono: \"\\<And>w x y z. w \\<le> x \\<Longrightarrow> y \\<le> z \\<Longrightarrow> f w y \\<le> f x z\"\n  shows \"x \\<le> y \\<Longrightarrow> fold f xs x \\<le> fold f xs y\"", "lemma sum_list_add_le_fold_eucl_truncate_up:\n  fixes z::\"'a::executable_euclidean_space\"\n  shows \"sum_list xs + z \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs z\"", "lemma sum_list_le_sum_list':\n  \"sum_list xs \\<le> sum_list' p xs\"", "lemma sum_list'_sum_list_le:\n  \"y \\<le> sum_list xs \\<Longrightarrow> y \\<le> sum_list' p xs\"", "lemma tdev': \"tdev x \\<le> tdev' p x\"", "lemma tdev'_le: \"x \\<le> tdev y \\<Longrightarrow> x \\<le> tdev' p y\"", "lemmas abs_pdevs_val_le_tdev' = tdev'_le[OF abs_pdevs_val_le_tdev]", "lemma tdev'_uminus_pdevs[simp]: \"tdev' p (uminus_pdevs x) = tdev' p x\"", "lemma Radius'_uminus_aform[simp]: \"Radius' p (uminus_aform X) = Radius' p X\"", "lemma nonzeros_trunc_pdevs_raw:\n  \"{i. trunc_pdevs_raw r x i \\<noteq> 0} \\<subseteq> {i. x i \\<noteq> 0}\"", "lemma nonzeros_trunc_err_pdevs_raw:\n  \"{i. trunc_err_pdevs_raw r x i \\<noteq> 0} \\<subseteq> {i. x i \\<noteq> 0}\"", "lemma pdevs_apply_trunc_pdevs[simp]:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_apply (trunc_pdevs p X) n = eucl_truncate_down p (pdevs_apply X n)\"", "lemma pdevs_apply_trunc_err_pdevs[simp]:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_apply (trunc_err_pdevs p X) n =\n    eucl_truncate_down p (pdevs_apply X n) - (pdevs_apply X n)\"", "lemma pdevs_val_trunc_pdevs:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_val e (trunc_pdevs p X) = pdevs_val e X + pdevs_val e (trunc_err_pdevs p X)\"", "lemma pdevs_val_trunc_err_pdevs:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_val e (trunc_err_pdevs p X) = pdevs_val e (trunc_pdevs p X) - pdevs_val e X\"", "lemma\n  abs_aform_val_le:\n  assumes \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  shows \"abs (aform_val e X) \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + tdev' p (snd X))\"", "lemma trunc_bound_euclE:\n  obtains err where\n  \"\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x)\"\n  \"fst (trunc_bound_eucl p x) = x + err\"", "lemma pdevs_apply_fst_trunc_bound_pdevs[simp]: \"pdevs_apply (fst (trunc_bound_pdevs p x)) =\n  pdevs_apply (trunc_pdevs p x)\"", "lemma trunc_bound_pdevsE:\n  assumes \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  obtains err where\n  \"\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x)\"\n  \"pdevs_val e (fst ((trunc_bound_pdevs p x))) = pdevs_val e x + err\"", "lemma\n  degree_add_pdevs_le:\n  assumes \"degree X \\<le> n\"\n  assumes \"degree Y \\<le> n\"\n  shows \"degree (add_pdevs X Y) \\<le> n\"", "lemma truncate_aform_error_aform_cancel:\n  \"aform_val e (truncate_aform p z) = aform_val e z + aform_val e (truncate_error_aform p z) \"", "lemma error_absE:\n  assumes \"abs err \\<le> k\"\n  obtains e::real where \"err = e * k\" \"e \\<in> {-1 .. 1}\"", "lemma eucl_truncate_up_nonneg_eq_zero_iff:\n  \"x \\<ge> 0 \\<Longrightarrow> eucl_truncate_up p x = 0 \\<longleftrightarrow> x = 0\"", "lemma\n  aform_val_consume_error:\n  assumes \"abs err \\<le> abs (pdevs_apply (snd X) n)\"\n  shows \"aform_val (e(n := 0)) X + err = aform_val (e(n := err/pdevs_apply (snd X) n)) X\"", "lemma\n  aform_val_consume_errorE:\n  fixes X::\"real aform\"\n  assumes \"abs err \\<le> abs (pdevs_apply (snd X) n)\"\n  obtains err' where \"aform_val (e(n := 0)) X + err = aform_val (e(n := err')) X\" \"err' \\<in> {-1 .. 1}\"", "lemma\n  degree_trunc_pdevs_le:\n  assumes \"degree X \\<le> n\"\n  shows \"degree (trunc_pdevs p X) \\<le> n\"", "lemma pdevs_val_sum_less_degree:\n  \"pdevs_val e X = (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply X i)\" if \"degree X \\<le> d\"", "lemma pdevs_domain_One_pdevs[simp]: \"pdevs_domain (One_pdevs::'a::executable_euclidean_space pdevs) =\n  {0..<DIM('a)}\"", "lemma pdevs_val_One_pdevs:\n  \"pdevs_val e (One_pdevs::'a::executable_euclidean_space pdevs) = (\\<Sum>i<DIM('a). e i *\\<^sub>R Basis_list ! i)\"", "lemma affine_binop:\n  assumes \"degree_aforms [X, Y] \\<le> k\"\n  shows \"aform_val e (affine_binop X Y a b c d k) =\n    a * aform_val e X + b * aform_val e Y + c + e k * d\"", "lemma sum_list'_noneg_eq_zero_iff: \"sum_list' p xs = 0 \\<longleftrightarrow> (\\<forall>x\\<in>set xs. x = 0)\" if \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<ge> 0\"", "lemma affine_binop'E:\n  assumes deg: \"degree_aforms [X, Y] \\<le> k\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  assumes d: \"abs u \\<le> d\"\n  obtains ek where\n    \"a * aform_val e X + b * aform_val e Y + c + u = aform_val (e(k:=ek)) (affine_binop' p X Y a b c d k)\"\n    \"ek \\<in> {-1 .. 1}\"", "lemma Inf_aform':\n  shows \"Inf_aform' p X \\<le> Inf_aform X\"", "lemma Sup_aform':\n  shows \"Sup_aform X \\<le> Sup_aform' p X\"", "lemma Inf_aform_le_Sup_aform[intro]:\n  \"Inf_aform X \\<le> Sup_aform X\"", "lemma Inf_aform'_le_Sup_aform'[intro]:\n  \"Inf_aform' p X \\<le> Sup_aform' p X\"", "lemma\n  assumes \"\\<And>i. e'' i \\<le> 1\"\n  assumes \"\\<And>i. -1 \\<le> e'' i\"\n  shows Inf_aform'_le: \"Inf_aform' p r \\<le> aform_val e'' r\"\n    and Sup_aform'_le: \"aform_val e'' r \\<le> Sup_aform' p r\"", "lemma InfSup_aform'_in_float[intro, simp]:\n  \"Inf_aform' p X \\<in> float\" \"Sup_aform' p X \\<in> float\"", "theorem ivls_of_aforms: \"xs \\<in> Joints XS \\<Longrightarrow> bounded_by xs (ivls_of_aforms prec XS)\"", "theorem isFDERIV_aform:\n  assumes \"isFDERIV_aform prec N xs fas AS\"\n  assumes \"vs \\<in> Joints AS\"\n  shows \"isFDERIV N xs fas vs\"", "lemma env_len_takeI: \"env_len xs d1 \\<Longrightarrow> d1 \\<ge> d \\<Longrightarrow> env_len (take d ` xs) d\"", "lemma\n  linear_lower:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> f' x \\<le> u\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f b + u * (x - b) \\<le> f x\"", "lemma\n  linear_lower2:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> l \\<le> f' x\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f x \\<ge> f a + l * (x - a)\"", "lemma\n  linear_upper:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> f' x \\<le> u\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f x \\<le> f a + u * (x - a)\"", "lemma\n  linear_upper2:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> l \\<le> f' x\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f x \\<le> f b + l * (x - b)\"", "lemma linear_enclosure:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> f' x \\<le> u\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f x \\<in> {f b + u * (x - b) .. f a + u * (x - a)}\"", "lemma degree_aform_uminus_aform[simp]: \"degree_aform (uminus_aform X) = degree_aform X\"", "lemma aform_val_add_aform:\n  shows \"aform_val e (add_aform X Y) = aform_val e X + aform_val e Y\"", "lemma degree_aform_err_add_aform':\n  assumes \"degree_aform_err x \\<le> n\"\n  assumes \"degree_aform_err y \\<le> n\"\n  shows \"degree_aform_err (add_aform' p x y) \\<le> n\"", "lemma aform_errI: \"x \\<in> aform_err e Xe\"\n  if \"abs (x - aform_val e (fst Xe)) \\<le> snd Xe\"", "lemma add_aform':\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes y: \"y \\<in> aform_err e Y\"\n  shows \"x + y \\<in> aform_err e (add_aform' p X Y)\"", "lemma aform_val_scaleR_aform[simp]:\n  shows \"aform_val e (aform_scaleR X y) = aform_val e X *\\<^sub>R y\"", "lemma aform_val_mult_exact:\n  \"aform_val e x * aform_val e y =\n    fst x * fst y +\n    pdevs_val e (add_pdevs (scaleR_pdevs (fst y) (snd x)) (scaleR_pdevs (fst x) (snd y))) +\n    (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply (snd x) i)*(\\<Sum>i<d. e i *\\<^sub>R pdevs_apply (snd y) i)\"\n   if \"degree (snd x) \\<le> d\" \"degree (snd y) \\<le> d\"", "lemma sum_times_bound:\\<comment> \\<open>TODO: this gives better bounds for the remainder of multiplication\\<close>\n  \"(\\<Sum>i<d. e i * f i::real) * (\\<Sum>i<d. e i * g i) =\n   (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n   (\\<Sum>(i, j) | i < j \\<and> j < d. (e i * e j) * (f j * g i + f i * g j))\" for d::nat", "lemma mult_aformE:\n  fixes X Y::\"aform_err\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes y: \"y \\<in> aform_err e Y\"\n  shows \"x * y \\<in> aform_err e (mult_aform X Y)\"", "lemma aform_errE:\n  \"abs (x - aform_val e (fst X)) \\<le> snd X\"\n  if \"x \\<in> aform_err e X\"", "lemma mult_aform'E:\n  fixes X Y::\"aform_err\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes y: \"y \\<in> aform_err e Y\"\n  shows \"x * y \\<in> aform_err e (mult_aform' p X Y)\"", "lemma degree_aform_mult_aform':\n  assumes \"degree_aform_err x \\<le> n\"\n  assumes \"degree_aform_err y \\<le> n\"\n  shows \"degree_aform_err (mult_aform' p x y) \\<le> n\"", "lemma\n  fixes x a b::real\n  assumes \"a > 0\"\n  assumes \"x \\<in> {a ..b}\"\n  assumes \"- inverse (b*b) \\<le> alpha\"\n  shows inverse_linear_lower: \"inverse b + alpha * (x - b) \\<le> inverse x\" (is ?lower)\n    and inverse_linear_upper: \"inverse x \\<le> inverse a + alpha * (x - a)\" (is ?upper)", "lemma inverse_aform'E:\n  fixes X::\"real aform\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes Inf_pos: \"Inf_aform' p X > 0\"\n  assumes \"x = aform_val e X\"\n  shows \"inverse x \\<in> aform_err e (inverse_aform' p X)\"", "lemma eucl_truncate_up_eq_eucl_truncate_down:\n  \"eucl_truncate_up p x = - (eucl_truncate_down p (- x))\"", "lemma inverse_aformE:\n  fixes X::\"real aform\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n    and disj: \"Inf_aform' p X > 0 \\<or> Sup_aform' p X < 0\"\n  obtains Y where\n    \"inverse_aform p X = Some Y\"\n    \"inverse (aform_val e X) \\<in> aform_err e Y\"", "lemma aform_err_to_aformE:\n  assumes \"x \\<in> aform_err e X\"\n  assumes deg: \"degree_aform_err X \\<le> n\"\n  obtains err where \"x = aform_val (e(n:=err)) (aform_err_to_aform X n)\"\n    \"-1 \\<le> err\" \"err \\<le> 1\"", "lemma aform_to_aform_err: \"aform_val e X \\<in> aform_err e (aform_to_aform_err X n)\"\n  if \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma inverse_aform:\n  fixes X::\"real aform\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"inverse_aform p X = Some Y\"\n  shows \"inverse (aform_val e X) \\<in> aform_err e Y\"", "lemma aform_err_acc_err_leI:\n  \"fx \\<in> aform_err e (acc_err p X err)\"\n  if \"aform_val e (fst X) - (snd X + err) \\<le> fx\" \"fx \\<le> aform_val e (fst X) + (snd X + err)\"", "lemma aform_err_acc_errI:\n  \"fx \\<in> aform_err e (acc_err p X err)\"\n  if \"fx \\<in> aform_err e (fst X, snd X + err)\"", "lemma minus_times_le_abs: \"- (err * B) \\<le> \\<bar>B\\<bar>\" if \"-1 \\<le> err\" \"err \\<le> 1\" for err::real", "lemma times_le_abs: \"err * B \\<le> \\<bar>B\\<bar>\" if \"-1 \\<le> err\" \"err \\<le> 1\" for err::real", "lemma aform_err_lemma1: \"- 1 \\<le> err \\<Longrightarrow> err \\<le> 1 \\<Longrightarrow>\n  X1 + (A - e d * B + err * B) - e1 \\<le> x \\<Longrightarrow>\n  X1 + (A - e d * B) - truncate_up p (\\<bar>B\\<bar> + e1) \\<le> x\"", "lemma aform_err_lemma2: \"- 1 \\<le> err \\<Longrightarrow> err \\<le> 1 \\<Longrightarrow>\n    x \\<le> X1 + (A - e d * B + err * B) + e1 \\<Longrightarrow>\n    x \\<le> X1 + (A - e d * B) + truncate_up p (\\<bar>B\\<bar> + e1)\"", "lemma aform_err_acc_err_aform_to_aform_errI:\n  \"x \\<in> aform_err e (acc_err p (aform_to_aform_err X1 d) e1)\"\n  if \"-1 \\<le> err\" \"err \\<le> 1\" \"x \\<in> aform_err (e(d := err)) (X1, e1)\"", "lemma map_aform_err:\n  \"i x \\<in> aform_err e Y\"\n  if I: \"\\<And>e X Y. e \\<in> UNIV \\<rightarrow> {-1 .. 1} \\<Longrightarrow> I X = Some Y \\<Longrightarrow> i (aform_val e X) \\<in> aform_err e Y\"\n  and e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  and Y: \"map_aform_err I p X = Some Y\"\n  and x: \"x \\<in> aform_err e X\"", "lemma inverse_aform_err:\n  \"inverse x \\<in> aform_err e Y\"\n  if  e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  and Y: \"inverse_aform_err p X = Some Y\"\n  and x: \"x \\<in> aform_err e X\"", "lemma pdevs_of_centered_ivl_eq_pdevs_of_ivl[simp]: \"pdevs_of_centered_ivl r = pdevs_of_ivl (-r) r\"", "lemma filter_pdevs_raw_nonzeros: \"{i. filter_pdevs_raw s f i \\<noteq> 0} = {i. f i \\<noteq> 0} \\<inter> {x. s x (f x)}\"", "lemma error_abs_euclE:\n  fixes err::\"'a::ordered_euclidean_space\"\n  assumes \"abs err \\<le> k\"\n  obtains e::\"'a \\<Rightarrow> real\" where \"err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i)\" \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma summarize_pdevsE:\n  fixes x::\"'a::executable_euclidean_space pdevs\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes d: \"degree x \\<le> d\"\n  obtains e' where \"pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x)\"\n    \"\\<And>i. i < d \\<Longrightarrow> e i = e' i\"\n    \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma filter_pdevs_cong[cong]:\n  assumes \"x = y\"\n  assumes \"\\<And>i. i \\<in> pdevs_domain y \\<Longrightarrow> P i (pdevs_apply x i) = Q i (pdevs_apply y i)\"\n  shows \"filter_pdevs P x = filter_pdevs Q y\"", "lemma summarize_pdevs_cong[cong]:\n  assumes \"p = q\" \"a = c\" \"b = d\"\n  assumes PQ: \"\\<And>i. i \\<in> pdevs_domain d \\<Longrightarrow> P i (pdevs_apply b i) = Q i (pdevs_apply d i)\"\n  shows \"summarize_pdevs p P a b = summarize_pdevs q Q c d\"", "lemma lookup_eq_None_iff: \"(Mapping.lookup M x = None) = (x \\<notin> Mapping.keys M)\"", "lemma lookup_eq_SomeD:\n  \"(Mapping.lookup M x = Some y) \\<Longrightarrow> (x \\<in> Mapping.keys M)\"", "lemma pdevs_mapping_eq[simp]: \"pdevs_mapping xs = pdevs_applys xs\"", "lemma compute_summarize_pdevs_list[code]:\n  \"summarize_pdevs_list p I d xs =\n    (let M = pdevs_mapping xs\n    in map (\\<lambda>(x, y). summarize_pdevs p (\\<lambda>i _. I i (M i)) x y) (zip [d..<d + length xs] xs))\"", "lemma\n  in_centered_ivlE:\n  fixes r t::real\n  assumes \"r \\<in> {-t .. t}\"\n  obtains e where \"e \\<in> {-1 .. 1}\" \"r = e * t\"", "lemmas [simp] = singleton_pdevs.rep_eq", "lemma singleton_0[simp]: \"singleton_pdevs 0 = zero_pdevs\"", "lemma degree_singleton_pdevs[simp]: \"degree (singleton_pdevs x) = (if x = 0 then 0 else Suc 0)\"", "lemma pdevs_val_singleton_pdevs[simp]: \"pdevs_val e (singleton_pdevs x) = e 0 *\\<^sub>R x\"", "lemma pdevs_of_ivl_real:\n  fixes a b::real\n  shows \"pdevs_of_ivl a b = singleton_pdevs ((b - a) / 2)\"", "lemma summarize_pdevs_listE:\n  fixes X::\"real pdevs list\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes d: \"degrees X \\<le> d\"\n  obtains e' where \"pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)\"\n    \"\\<And>i. i < d \\<Longrightarrow> e i = e' i\"\n    \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma list_ex2_iff:\n  \"list_ex2 P xs ys \\<longleftrightarrow> (\\<not>list_all2 (-P) (take (length ys) xs) (take (length xs) ys))\"", "lemma aform_vals_pdevs_vals:\n  \"aform_vals e X = map (\\<lambda>(x, y). x + y) (zip (map fst X) (pdevs_vals e (map snd X)))\"", "lemma summarize_aformsE:\n  fixes X::\"real aform list\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes d: \"degree_aforms X \\<le> d\"\n  obtains e' where \"aform_vals e X = aform_vals e' (summarize_aforms p C d X)\"\n    \"\\<And>i. i < d \\<Longrightarrow> e i = e' i\"\n    \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma lower_ivl_of_aform_err: \"lower (ivl_of_aform_err p Rd) = Inf_aform_err p Rd\"\n  and upper_ivl_of_aform_err: \"upper (ivl_of_aform_err p Rd) = Sup_aform_err p Rd\"", "lemma interval_extension1D:\n  assumes \"interval_extension1 F f\"\n  assumes \"F ivl = Some ivl'\"\n  assumes \"x \\<in>\\<^sub>r ivl\"\n  shows \"f x \\<in>\\<^sub>r ivl'\"", "lemma approx_un_argE:\n  assumes au: \"approx_un p F X = Some Y\"\n  obtains X' where \"X = Some X'\"", "lemma degree_aform_independent_from:\n  \"degree_aform (independent_from d1 X) \\<le> d1 + degree_aform X\"", "lemma degree_aform_of_ivl:\n  fixes a b::\"'a::executable_euclidean_space\"\n  shows \"degree_aform (aform_of_ivl a b) \\<le> length (Basis_list::'a list)\"", "lemma aform_err_ivl_err[simp]: \"aform_err e (ivl_err ivl') = set_of ivl'\"", "lemma Inf_Sup_aform_err:\n  fixes X\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  defines \"X' \\<equiv> fst X\"\n  shows \"aform_err e X \\<subseteq> {Inf_aform_err p X .. Sup_aform_err p X}\"", "lemma ivl_of_aform_err:\n  fixes X\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"x \\<in> aform_err e X \\<Longrightarrow> x \\<in>\\<^sub>r ivl_of_aform_err p X\"", "lemma approx_unE:\n  assumes ie: \"interval_extension1 F f\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes au: \"approx_un p F X'err = Some Ye\"\n  assumes x: \"case X'err of None \\<Rightarrow> True | Some X'err \\<Rightarrow> x \\<in> aform_err e X'err\"\n  shows \"f x \\<in> aform_err e Ye\"", "lemma interval_extension2D:\n  assumes \"interval_extension2 F f\"\n  assumes \"F ivl1 ivl2 = Some ivl\"\n  shows \"x \\<in>\\<^sub>r ivl1 \\<Longrightarrow> y \\<in>\\<^sub>r ivl2 \\<Longrightarrow> f x y \\<in>\\<^sub>r ivl\"", "lemma approx_binE:\n  assumes ie: \"interval_extension2 F f\"\n  assumes w: \"w \\<in> aform_err e (W', errw)\"\n  assumes x: \"x \\<in> aform_err e (X', errx)\"\n  assumes ab: \"approx_bin p F ((W', errw)) ((X', errx)) = Some Ye\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"f w x \\<in> aform_err e Ye\"", "lemma aform_err_leI:\n  \"y \\<in> aform_err e (c, d)\"\n  if \"y \\<in> aform_err e (c, d')\" \"d' \\<le> d\"", "lemma aform_err_eqI:\n  \"y \\<in> aform_err e (c, d)\"\n  if \"y \\<in> aform_err e (c, d')\" \"d' = d\"", "lemma sum_list'_append[simp]: \"sum_list' p (ds@[d]) = truncate_up p (d + sum_list' p ds)\"", "lemma aform_err_sum_list':\n  \"y \\<in> aform_err e (c, sum_list' p ds)\"\n  if \"y \\<in> aform_err e (c, sum_list ds)\"", "lemma aform_err_trunc_bound_eucl:\n  \"y \\<in> aform_err e ((fst (trunc_bound_eucl p X), xs), snd (trunc_bound_eucl p X) + d)\"\n  if y: \"y \\<in> aform_err e ((X, xs), d)\"", "lemma trunc_err_pdevsE:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  obtains err where\n  \"\\<bar>err\\<bar> \\<le> tdev' p (trunc_err_pdevs p xs)\"\n  \"pdevs_val e (trunc_pdevs p xs) = pdevs_val e xs + err\"", "lemma aform_err_trunc_bound_pdevsI:\n  \"y \\<in> aform_err e ((c, fst (trunc_bound_pdevs p xs)), snd (trunc_bound_pdevs p xs) + d)\"\n  if y: \"y \\<in> aform_err e ((c, xs), d)\"\n  and e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"", "lemma aform_err_addI:\n  \"y \\<in> aform_err e ((a + b, xs), d)\"\n  if \"y - b \\<in> aform_err e ((a, xs), d)\"", "theorem affine_unop:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes f: \"\\<bar>f x - (a * x + b)\\<bar> \\<le> d\"\n    and e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"f x \\<in> aform_err e (affine_unop p a b d X)\"", "lemma min_range_coeffs_ge:\n  \"\\<bar>f x - (a * x + b)\\<bar> \\<le> d\"\n  if l: \"l \\<le> x\" and u: \"x \\<le> u\"\n    and f': \"\\<And>y. y \\<in> {l .. u} \\<Longrightarrow> (f has_real_derivative f' y) (at y)\"\n    and a: \"\\<And>y. y \\<in> {l..u} \\<Longrightarrow> a \\<le> f' y\"\n    and d: \"d \\<ge> (f u - f l - a * (u - l)) / 2 + \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\"\n  for a b d::real", "lemma min_range_coeffs_le:\n  \"\\<bar>f x - (a * x + b)\\<bar> \\<le> d\"\n  if l: \"l \\<le> x\" and u: \"x \\<le> u\"\n    and f': \"\\<And>y. y \\<in> {l .. u} \\<Longrightarrow> (f has_real_derivative f' y) (at y)\"\n    and a: \"\\<And>y. y \\<in> {l .. u} \\<Longrightarrow> f' y \\<le> a\"\n    and d: \"d \\<ge> (f l - f u + a * (u - l)) / 2 + \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\"\n  for a b d::real", "lemmas approx_emptyD = approx[OF bounded_by_None[of Nil], simplified]", "lemma range_reducerE:\n  assumes \"range_reducer p l = Some ivl\"\n  obtains n::int where \"n * (2 * pi) \\<in>\\<^sub>r ivl\"", "lemma range_reduce_aform_errE:\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"range_reduce_aform_err p X = Some Y\"\n  obtains n::int where \"x + n * (2 * pi) \\<in> aform_err e Y\"", "lemma min_range_mono:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"l \\<le> x\" \"x \\<le> u\"\n  assumes \"min_range_mono p F DF l u X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes F: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> interpret_floatarith (F (Num x)) [] = f x\"\n  assumes DF: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> interpret_floatarith (DF (Num x)) [] = f' x\"\n  assumes f': \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> (f has_real_derivative f' x) (at x)\"\n  assumes f'_le: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> min (f' l) (f' u) \\<le> f' x\"\n  shows \"f x \\<in> aform_err e Y\"", "lemma min_range_antimono:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"l \\<le> x\" \"x \\<le> u\"\n  assumes \"min_range_antimono p F DF l u X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes F: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> interpret_floatarith (F (Num x)) [] = f x\"\n  assumes DF: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> interpret_floatarith (DF (Num x)) [] = f' x\"\n  assumes f': \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> (f has_real_derivative f' x) (at x)\"\n  assumes f'_le: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> f' x \\<le> max (f' l) (f' u)\"\n  shows \"f x \\<in> aform_err e Y\"", "lemma abs_half_enclosure:\n  fixes r::real\n  assumes \"bl \\<le> r\" \"r \\<le> bu\"\n  shows \"\\<bar>r - (bl + bu) / 2\\<bar> \\<le> (bu - bl) / 2\"", "lemma cos_aform_err:\n  assumes x: \"x \\<in> aform_err e X0\"\n  assumes \"cos_aform_err p X0 = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"cos x \\<in> aform_err e Y\"", "lemma sqrt_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"sqrt_aform_err p X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"sqrt x \\<in> aform_err e Y\"", "lemma ln_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"ln_aform_err p X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"ln x \\<in> aform_err e Y\"", "lemma exp_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"exp_aform_err p X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"exp x \\<in> aform_err e Y\"", "lemma pos_add_nonneg_ne_zero: \"a > 0 \\<Longrightarrow> b \\<ge> 0 \\<Longrightarrow> a + b \\<noteq> 0\"\n  for a b::real", "lemma arctan_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"arctan_aform_err p X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"arctan x \\<in> aform_err e Y\"", "lemma bounded_by_Nil: \"bounded_by [] []\"", "lemma plain_floatarith_approx:\n  assumes \"plain_floatarith 0 f\"\n  shows \"interpret_floatarith f [] \\<in>\\<^sub>r (the (approx p f []))\"", "lemma plain_floatarith_Sum\\<^sub>e:\n  \"plain_floatarith n (Sum\\<^sub>e f xs) \\<longleftrightarrow> list_all (\\<lambda>i. plain_floatarith n (f i)) xs\"", "lemma sum_list'_float[simp]: \"sum_list' p xs \\<in> float\"", "lemma tdev'_float[simp]: \"tdev' p xs \\<in> float\"", "lemma\n  fixes x y::real\n  assumes \"abs (x - y) \\<le> e\"\n  obtains err where \"x = y + err\" \"abs err \\<le> e\"", "theorem power_aform_err:\n  assumes \"x \\<in> aform_err e X\"\n  assumes floats[simp]: \"fst (fst X) \\<in> float\" \"snd X \\<in> float\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"x ^ n \\<in> aform_err e (power_aform_err p X n)\"", "lemma [code]: \"is_float (real_of_float f) = True\"", "lemma interval_extension_powr: \"interval_extension2 (powr_float_interval p) (powr)\"", "theorem powr_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes a: \"a \\<in> aform_err e A\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes Y: \"powr_aform_err p X A = Some Y\"\n  shows \"x powr a \\<in> aform_err e Y\"", "lemma uminus_aform_uminus_aform[simp]: \"uminus_aform (uminus_aform z) = (z::'a::real_vector aform)\"", "lemma degree_aform_inverse_aform':\n  \"degree_aform X \\<le> n \\<Longrightarrow> degree_aform (fst (inverse_aform' p X)) \\<le> n\"", "lemma degree_aform_inverse_aform:\n  assumes \"inverse_aform p X = Some Y\"\n  assumes \"degree_aform X \\<le> n\"\n  shows \"degree_aform (fst Y) \\<le> n\"", "lemma degree_aform_ivl_err[simp]: \"degree_aform (fst (ivl_err a)) = 0\"", "lemma degree_aform_approx_bin:\n  assumes \"approx_bin p ivl X Y = Some Z\"\n  assumes \"degree_aform (fst X) \\<le> m\"\n  assumes \"degree_aform (fst Y) \\<le> m\"\n  shows \"degree_aform (fst Z) \\<le> m\"", "lemma degree_aform_approx_un:\n  assumes \"approx_un p ivl X = Some Y\"\n  assumes \"case X of None \\<Rightarrow> True | Some X \\<Rightarrow> degree_aform (fst X) \\<le> d1\"\n  shows \"degree_aform (fst Y) \\<le> d1\"", "lemma degree_aform_num_aform[simp]: \"degree_aform (num_aform x) = 0\"", "lemma degree_max_aform:\n  assumes \"degree_aform_err x \\<le> d\"\n  assumes \"degree_aform_err y \\<le> d\"\n  shows \"degree_aform_err (max_aform_err p x y) \\<le> d\"", "lemma degree_min_aform:\n  assumes \"degree_aform_err x \\<le> d\"\n  assumes \"degree_aform_err y \\<le> d\"\n  shows \"degree_aform_err ((min_aform_err p x y)) \\<le> d\"", "lemma degree_aform_acc_err:\n  \"degree_aform (fst (acc_err p X e)) \\<le> d\"\n  if \"degree_aform (fst X) \\<le> d\"", "lemma degree_pdev_upd_degree:\n  assumes \"degree b \\<le> Suc n\"\n  assumes \"degree b \\<le> Suc (degree_aform_err X)\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree (pdev_upd b (degree_aform_err X) 0) \\<le> n\"", "lemma degree_aform_err_inverse_aform_err:\n  assumes \"inverse_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\"", "lemma degree_aform_err_affine_unop:\n  \"degree_aform_err (affine_unop p a b d X) \\<le> n\"\n  if \"degree_aform_err X \\<le> n\"", "lemma degree_aform_err_min_range_mono:\n  assumes \"min_range_mono p F D l u X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\"", "lemma degree_aform_err_min_range_antimono:\n  assumes \"min_range_antimono p F D l u X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\"", "lemma degree_aform_err_cos_aform_err:\n  assumes \"cos_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\"", "lemma degree_aform_err_sqrt_aform_err:\n  assumes \"sqrt_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\"", "lemma degree_aform_err_arctan_aform_err:\n  assumes \"arctan_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\"", "lemma degree_aform_err_exp_aform_err:\n  assumes \"exp_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\"", "lemma degree_aform_err_ln_aform_err:\n  assumes \"ln_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\"", "lemma degree_aform_err_power_aform_err:\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err (power_aform_err p X m) \\<le> n\"", "lemma degree_aform_err_powr_aform_err:\n  assumes \"powr_aform_err p X Z = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  assumes \"degree_aform_err Z \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\"", "lemma approx_floatarith_degree:\n  assumes \"approx_floatarith p ra VS = Some X\"\n  assumes \"\\<And>V. V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\"\n  shows \"degree_aform_err X \\<le> d\"", "lemma affine_extension2E:\n  assumes \"affine_extension2 fnctn_aff fnctn\"\n  assumes \"fnctn_aff d a1 a2 = Some X\"\n    \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n    \"d \\<ge> degree_aform a1\"\n    \"d \\<ge> degree_aform a2\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> {- 1..1}\"\n    \"fnctn (aform_val e a1) (aform_val e a2) = aform_val e' X\"\n    \"\\<And>n. n < d \\<Longrightarrow> e' n = e n\"\n    \"aform_val e a1 = aform_val e' a1\"\n    \"aform_val e a2 = aform_val e' a2\"", "lemma aform_err_uminus_aform:\n  \"- x \\<in> aform_err e (uminus_aform X, ba)\"\n  if \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\" \"x \\<in> aform_err e (X, ba)\"", "lemma aforms_err_Nil[simp]: \"aforms_err e [] = {[]}\"\n  and aforms_err_Cons: \"aforms_err e (x#xs) = set_Cons (aform_err e x) (aforms_err e xs)\"", "lemma in_set_ConsI: \"a#b \\<in> set_Cons A B\"\n  if \"a \\<in> A\" and \"b \\<in> B\"", "lemma mem_aforms_err_Cons_iff[simp]: \"x#xs \\<in> aforms_err e (X#XS) \\<longleftrightarrow> x \\<in> aform_err e X \\<and> xs \\<in> aforms_err e XS\"", "lemma mem_aforms_err_Cons_iff_Ex_conv: \"x \\<in> aforms_err e (X#XS) \\<longleftrightarrow> (\\<exists>y ys. x = y#ys \\<and> y \\<in> aform_err e X \\<and> ys \\<in> aforms_err e XS)\"", "lemma listset_Cons_mem_conv:\n  \"a # vs \\<in> listset AVS \\<longleftrightarrow> (\\<exists>A VS. AVS = A # VS \\<and> a \\<in> A \\<and> vs \\<in> listset VS)\"", "lemma listset_Nil_mem_conv[simp]:\n  \"[] \\<in> listset AVS \\<longleftrightarrow> AVS = []\"", "lemma listset_nthD: \"vs \\<in> listset VS \\<Longrightarrow> i < length vs \\<Longrightarrow> vs ! i \\<in> VS ! i\"", "lemma length_listsetD:\n  \"vs \\<in> listset VS \\<Longrightarrow> length vs = length VS\"", "lemma length_aforms_errD:\n  \"vs \\<in> aforms_err e VS \\<Longrightarrow> length vs = length VS\"", "lemma nth_aforms_errI:\n  \"vs ! i \\<in> aform_err e (VS ! i)\"\n  if \"vs \\<in> aforms_err e VS\" \"i < length vs\"", "lemma eucl_truncate_down_float[simp]: \"eucl_truncate_down p x \\<in> float\"", "lemma eucl_truncate_up_float[simp]: \"eucl_truncate_up p x \\<in> float\"", "lemma trunc_bound_eucl_float[simp]: \"fst (trunc_bound_eucl p x) \\<in> float\"\n  \"snd (trunc_bound_eucl p x) \\<in> float\"", "lemma add_aform'_float:\n  \"add_aform' p x y = ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n  \"add_aform' p x y = ((a, b), ba) \\<Longrightarrow> ba \\<in> float\"", "lemma uminus_aform_float: \"uminus_aform (aa, bb) = (a, b) \\<Longrightarrow> aa \\<in> float \\<Longrightarrow> a \\<in> float\"", "lemma mult_aform'_float: \"mult_aform' p x y = ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n   \"mult_aform' p x y = ((a, b), ba) \\<Longrightarrow> ba \\<in> float\"", "lemma inverse_aform'_float: \"inverse_aform' p x = ((a, bb), baa) \\<Longrightarrow> a \\<in> float\"", "lemma inverse_aform_float:\n  \"inverse_aform p x = Some ((a, bb), baa) \\<Longrightarrow> a \\<in> float\"", "lemma inverse_aform_err_float: \"inverse_aform_err p x = Some ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n   \"inverse_aform_err p x = Some ((a, b), ba) \\<Longrightarrow> ba \\<in> float\"", "lemma affine_unop_float:\n  \"affine_unop p asdf aaa bba h = ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n  \"affine_unop p asdf aaa bba h = ((a, b), ba) \\<Longrightarrow> ba \\<in> float\"", "lemma min_range_antimono_float:\n  \"min_range_antimono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n  \"min_range_antimono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow> ba \\<in> float\"", "lemma min_range_mono_float:\n  \"min_range_mono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n  \"min_range_mono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow> ba \\<in> float\"", "lemma in_float_timesI: \"a \\<in> float\" if \"b = a * 2\" \"b \\<in> float\"", "lemma interval_extension_floor: \"interval_extension1 (\\<lambda>ivl. Some (floor_float_interval ivl)) floor\"", "lemma approx_floatarith_Elem:\n  assumes \"approx_floatarith p ra VS = Some X\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"vs \\<in> aforms_err e VS\"\n  shows \"interpret_floatarith ra vs \\<in> aform_err e X\"", "lemma approx_floatariths_Elem:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"approx_floatariths_aformerr p ra VS = Some X\"\n  assumes \"vs \\<in> aforms_err e VS\"\n  shows \"interpret_floatariths ra vs \\<in> aforms_err e X\"", "lemma fold_max_mono:\n  fixes x::\"'a::linorder\"\n  shows \"x \\<le> y \\<Longrightarrow> fold max zs x \\<le> fold max zs y\"", "lemma fold_max_le_self:\n  fixes y::\"'a::linorder\"\n  shows \"y \\<le> fold max ys y\"", "lemma fold_max_le:\n  fixes x::\"'a::linorder\"\n  shows \"x \\<in> set xs \\<Longrightarrow> x \\<le> fold max xs z\"", "lemma aform_vals_empty[simp]: \"aform_vals e' [] = []\"", "lemma aforms_err_to_aforms_Nil[simp]: \"(aforms_err_to_aforms n []) = []\"", "lemma aforms_err_to_aforms_Cons[simp]:\n  \"aforms_err_to_aforms n (X # XS) = aform_err_to_aform X n # aforms_err_to_aforms (Suc n) XS\"", "lemma degree_aform_err_to_aform_le:\n  \"degree_aform (aform_err_to_aform X n) \\<le> max (degree_aform_err X) (Suc n)\"", "lemma less_degree_aform_aform_err_to_aformD: \"i < degree_aform (aform_err_to_aform X n) \\<Longrightarrow> i < max (Suc n) (degree_aform_err X)\"", "lemma pdevs_domain_aform_err_to_aform:\n  \"pdevs_domain (snd (aform_err_to_aform X n)) = pdevs_domain (snd (fst X)) \\<union> (if snd X = 0 then {} else {n})\"\n  if \"n \\<ge> degree_aform_err X\"", "lemma length_aforms_err_to_aforms[simp]: \"length (aforms_err_to_aforms i XS) = length XS\"", "lemma aforms_err_to_aforms_ex:\n  assumes X: \"x \\<in> aforms_err e X\"\n  assumes deg: \"degree_aforms_err X \\<le> n\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"\\<exists>e'\\<in> UNIV \\<rightarrow> {-1 .. 1}. x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n    (\\<forall>i < n. e' i = e i)\"", "lemma aforms_err_to_aformsE:\n  assumes X: \"x \\<in> aforms_err e X\"\n  assumes deg: \"degree_aforms_err X \\<le> n\"\n    assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  obtains e' where \"x = aform_vals e' (aforms_err_to_aforms n X)\" \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n    \"\\<And>i. i < n \\<Longrightarrow> e' i = e i\"", "lemma listset_sings[simp]:\n  \"listset (map (\\<lambda>x. {f x}) as) = {map f as}\"", "lemma approx_floatariths_outer:\n  assumes \"approx_floatariths p ea as = Some XS\"\n  assumes \"vs \\<in> Joints as\"\n  shows \"(interpret_floatariths ea vs @ vs) \\<in> Joints (XS @ as)\"", "lemma length_eq_NilI: \"length [] = length []\"\n  and length_eq_ConsI: \"length xs = length ys \\<Longrightarrow> length (x#xs) = length (y#ys)\"", "lemma pdevs_val_domain_cong:\n  assumes \"b = d\"\n  assumes \"\\<And>i. i \\<in> pdevs_domain b \\<Longrightarrow> a i = c i\"\n  shows \"pdevs_val a b = pdevs_val c d\"", "lemma fresh_JointsI:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"list_all (\\<lambda>Y. pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {}) XS\"\n  assumes \"x \\<in> Affine X\"\n  shows \"x#xs \\<in> Joints (X#XS)\"", "lemma Nil_mem_Joints[intro, simp]: \"[] \\<in> Joints []\"", "lemma map_nth_Joints: \"xs \\<in> Joints XS \\<Longrightarrow> (\\<And>i. i \\<in> set is \\<Longrightarrow> i < length XS) \\<Longrightarrow> map (nth xs) is @ xs \\<in> Joints (map (nth XS) is @ XS)\"", "lemma map_nth_Joints': \"xs \\<in> Joints XS \\<Longrightarrow> (\\<And>i. i \\<in> set is \\<Longrightarrow> i < length XS) \\<Longrightarrow> map (nth xs) is \\<in> Joints (map (nth XS) is)\"", "lemma approx_slp_Elem:\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"vs \\<in> aforms_err e VS\"\n  assumes \"approx_slp p ra VS = Some X\"\n  shows \"interpret_slp ra vs \\<in> aforms_err e X\"", "lemma take_in_listsetI: \"xs \\<in> listset XS \\<Longrightarrow> take n xs \\<in> listset (take n XS)\"", "lemma take_in_aforms_errI: \"take n xs \\<in> aforms_err e (take n XS)\"\n  if \"xs \\<in> aforms_err e XS\"", "theorem approx_slp_outer:\n  assumes \"approx_slp_outer p n slp XS = Some RS\"\n  assumes slp: \"slp = slp_of_fas fas\" \"n = length fas\"\n  assumes \"xs \\<in> Joints XS\"\n  shows \"interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)\"", "theorem approx_slp_outer_plain:\n  assumes \"approx_slp_outer p n slp XS = Some RS\"\n  assumes slp: \"slp = slp_of_fas fas\" \"n = length fas\"\n  assumes \"xs \\<in> Joints XS\"\n  shows \"interpret_floatariths fas xs \\<in> Joints RS\""], "translations": [["", "lemma convex_on_imp_above_tangent:\\<comment> \\<open>TODO: generalizes @{thm convex_on_imp_above_tangent}\\<close>\n  assumes convex: \"convex_on A f\" and connected: \"connected A\"\n  assumes c: \"c \\<in> A\" and x : \"x \\<in> A\"\n  assumes deriv: \"(f has_field_derivative f') (at c within A)\"\n  shows   \"f x - f c \\<ge> f' * (x - c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' * (x - c) \\<le> f x - f c", "proof (cases x c rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "assume xc: \"x > c\""], ["proof (state)\nthis:\n  c < x\n\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "let ?A' = \"{c<..<x}\""], ["proof (state)\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "have subs: \"?A' \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {c<..<x} \\<subseteq> A", "using xc x c"], ["proof (prove)\nusing this:\n  c < x\n  x \\<in> A\n  c \\<in> A\n\ngoal (1 subgoal):\n 1. {c<..<x} \\<subseteq> A", "by (simp add: connected connected_contains_Ioo)"], ["proof (state)\nthis:\n  {c<..<x} \\<subseteq> A\n\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "have \"at c within ?A' \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at c within {c<..<x} \\<noteq> bot", "using xc"], ["proof (prove)\nusing this:\n  c < x\n\ngoal (1 subgoal):\n 1. at c within {c<..<x} \\<noteq> bot", "by (simp add: at_within_eq_bot_iff)"], ["proof (state)\nthis:\n  at c within {c<..<x} \\<noteq> bot\n\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "moreover"], ["proof (state)\nthis:\n  at c within {c<..<x} \\<noteq> bot\n\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "from deriv"], ["proof (chain)\npicking this:\n  (f has_real_derivative f') (at c within A)", "have \"((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f') (at c within ?A')\""], ["proof (prove)\nusing this:\n  (f has_real_derivative f') (at c within A)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n     (at c within {c<..<x})", "unfolding has_field_derivative_iff"], ["proof (prove)\nusing this:\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within A)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n     (at c within {c<..<x})", "using subs"], ["proof (prove)\nusing this:\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within A)\n  {c<..<x} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n     (at c within {c<..<x})", "by (blast intro: tendsto_mono at_le)"], ["proof (state)\nthis:\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within {c<..<x})\n\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within {c<..<x})\n\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "from eventually_at_right_real[OF xc]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F xa in at_right c. xa \\<in> {c<..<x}", "have \"eventually (\\<lambda>y. (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)) (at_right c)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F xa in at_right c. xa \\<in> {c<..<x}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F y in at_right c.\n       (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {c<..<x} \\<Longrightarrow>\n       (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {c<..<x} \\<Longrightarrow>\n       (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "assume y: \"y \\<in> {c<..<x}\""], ["proof (state)\nthis:\n  y \\<in> {c<..<x}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {c<..<x} \\<Longrightarrow>\n       (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "with convex connected x c"], ["proof (chain)\npicking this:\n  convex_on A f\n  connected A\n  x \\<in> A\n  c \\<in> A\n  y \\<in> {c<..<x}", "have \"f y \\<le> (f x - f c) / (x - c) * (y - c) + f c\""], ["proof (prove)\nusing this:\n  convex_on A f\n  connected A\n  x \\<in> A\n  c \\<in> A\n  y \\<in> {c<..<x}\n\ngoal (1 subgoal):\n 1. f y \\<le> (f x - f c) / (x - c) * (y - c) + f c", "using interior_subset[of A]"], ["proof (prove)\nusing this:\n  convex_on A f\n  connected A\n  x \\<in> A\n  c \\<in> A\n  y \\<in> {c<..<x}\n  interior A \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f y \\<le> (f x - f c) / (x - c) * (y - c) + f c", "by (intro convex_onD_Icc' convex_on_subset[OF convex] connected_contains_Icc) auto"], ["proof (state)\nthis:\n  f y \\<le> (f x - f c) / (x - c) * (y - c) + f c\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {c<..<x} \\<Longrightarrow>\n       (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "hence \"f y - f c \\<le> (f x - f c) / (x - c) * (y - c)\""], ["proof (prove)\nusing this:\n  f y \\<le> (f x - f c) / (x - c) * (y - c) + f c\n\ngoal (1 subgoal):\n 1. f y - f c \\<le> (f x - f c) / (x - c) * (y - c)", "by simp"], ["proof (state)\nthis:\n  f y - f c \\<le> (f x - f c) / (x - c) * (y - c)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {c<..<x} \\<Longrightarrow>\n       (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "thus \"(f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)\""], ["proof (prove)\nusing this:\n  f y - f c \\<le> (f x - f c) / (x - c) * (y - c)\n\ngoal (1 subgoal):\n 1. (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "using y xc"], ["proof (prove)\nusing this:\n  f y - f c \\<le> (f x - f c) / (x - c) * (y - c)\n  y \\<in> {c<..<x}\n  c < x\n\ngoal (1 subgoal):\n 1. (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F y in at_right c.\n     (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)\n\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "hence \"eventually (\\<lambda>y. (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)) (at c within ?A')\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F y in at_right c.\n     (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F y in at c within {c<..<x}.\n       (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "by (simp add: eventually_at_filter eventually_mono)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F y in at c within {c<..<x}.\n     (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)\n\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "ultimately"], ["proof (chain)\npicking this:\n  at c within {c<..<x} \\<noteq> bot\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within {c<..<x})\n  \\<forall>\\<^sub>F y in at c within {c<..<x}.\n     (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)", "have \"f' \\<le> (f x - f c) / (x - c)\""], ["proof (prove)\nusing this:\n  at c within {c<..<x} \\<noteq> bot\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within {c<..<x})\n  \\<forall>\\<^sub>F y in at c within {c<..<x}.\n     (f y - f c) / (y - c) \\<le> (f x - f c) / (x - c)\n\ngoal (1 subgoal):\n 1. f' \\<le> (f x - f c) / (x - c)", "by (simp add: tendsto_upperbound)"], ["proof (state)\nthis:\n  f' \\<le> (f x - f c) / (x - c)\n\ngoal (3 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 3. c < x \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "thus ?thesis"], ["proof (prove)\nusing this:\n  f' \\<le> (f x - f c) / (x - c)\n\ngoal (1 subgoal):\n 1. f' * (x - c) \\<le> f x - f c", "using xc"], ["proof (prove)\nusing this:\n  f' \\<le> (f x - f c) / (x - c)\n  c < x\n\ngoal (1 subgoal):\n 1. f' * (x - c) \\<le> f x - f c", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  f' * (x - c) \\<le> f x - f c\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "assume xc: \"x < c\""], ["proof (state)\nthis:\n  x < c\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "let ?A' = \"{x<..<c}\""], ["proof (state)\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "have subs: \"?A' \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x<..<c} \\<subseteq> A", "using xc x c"], ["proof (prove)\nusing this:\n  x < c\n  x \\<in> A\n  c \\<in> A\n\ngoal (1 subgoal):\n 1. {x<..<c} \\<subseteq> A", "by (simp add: connected connected_contains_Ioo)"], ["proof (state)\nthis:\n  {x<..<c} \\<subseteq> A\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "have \"at c within ?A' \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at c within {x<..<c} \\<noteq> bot", "using xc"], ["proof (prove)\nusing this:\n  x < c\n\ngoal (1 subgoal):\n 1. at c within {x<..<c} \\<noteq> bot", "by (simp add: at_within_eq_bot_iff)"], ["proof (state)\nthis:\n  at c within {x<..<c} \\<noteq> bot\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "moreover"], ["proof (state)\nthis:\n  at c within {x<..<c} \\<noteq> bot\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "from deriv"], ["proof (chain)\npicking this:\n  (f has_real_derivative f') (at c within A)", "have \"((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f') (at c within ?A')\""], ["proof (prove)\nusing this:\n  (f has_real_derivative f') (at c within A)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n     (at c within {x<..<c})", "unfolding has_field_derivative_iff"], ["proof (prove)\nusing this:\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within A)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n     (at c within {x<..<c})", "using subs"], ["proof (prove)\nusing this:\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within A)\n  {x<..<c} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n     (at c within {x<..<c})", "by (blast intro: tendsto_mono at_le)"], ["proof (state)\nthis:\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within {x<..<c})\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within {x<..<c})\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "from eventually_at_left_real[OF xc]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F xa in at_left c. xa \\<in> {x<..<c}", "have \"eventually (\\<lambda>y. (f y - f c) / (y - c) \\<ge> (f x - f c) / (x - c)) (at_left c)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F xa in at_left c. xa \\<in> {x<..<c}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F y in at_left c.\n       (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {x<..<c} \\<Longrightarrow>\n       (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {x<..<c} \\<Longrightarrow>\n       (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "assume y: \"y \\<in> {x<..<c}\""], ["proof (state)\nthis:\n  y \\<in> {x<..<c}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {x<..<c} \\<Longrightarrow>\n       (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "with convex connected x c"], ["proof (chain)\npicking this:\n  convex_on A f\n  connected A\n  x \\<in> A\n  c \\<in> A\n  y \\<in> {x<..<c}", "have \"f y \\<le> (f x - f c) / (c - x) * (c - y) + f c\""], ["proof (prove)\nusing this:\n  convex_on A f\n  connected A\n  x \\<in> A\n  c \\<in> A\n  y \\<in> {x<..<c}\n\ngoal (1 subgoal):\n 1. f y \\<le> (f x - f c) / (c - x) * (c - y) + f c", "using interior_subset[of A]"], ["proof (prove)\nusing this:\n  convex_on A f\n  connected A\n  x \\<in> A\n  c \\<in> A\n  y \\<in> {x<..<c}\n  interior A \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f y \\<le> (f x - f c) / (c - x) * (c - y) + f c", "by (intro convex_onD_Icc'' convex_on_subset[OF convex] connected_contains_Icc) auto"], ["proof (state)\nthis:\n  f y \\<le> (f x - f c) / (c - x) * (c - y) + f c\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {x<..<c} \\<Longrightarrow>\n       (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "hence \"f y - f c \\<le> (f x - f c) * ((c - y) / (c - x))\""], ["proof (prove)\nusing this:\n  f y \\<le> (f x - f c) / (c - x) * (c - y) + f c\n\ngoal (1 subgoal):\n 1. f y - f c \\<le> (f x - f c) * ((c - y) / (c - x))", "by simp"], ["proof (state)\nthis:\n  f y - f c \\<le> (f x - f c) * ((c - y) / (c - x))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {x<..<c} \\<Longrightarrow>\n       (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "also"], ["proof (state)\nthis:\n  f y - f c \\<le> (f x - f c) * ((c - y) / (c - x))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {x<..<c} \\<Longrightarrow>\n       (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "have \"(c - y) / (c - x) = (y - c) / (x - c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c - y) / (c - x) = (y - c) / (x - c)", "using y xc"], ["proof (prove)\nusing this:\n  y \\<in> {x<..<c}\n  x < c\n\ngoal (1 subgoal):\n 1. (c - y) / (c - x) = (y - c) / (x - c)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (c - y) / (c - x) = (y - c) / (x - c)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {x<..<c} \\<Longrightarrow>\n       (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "finally"], ["proof (chain)\npicking this:\n  f y - f c \\<le> (f x - f c) * ((y - c) / (x - c))", "show \"(f y - f c) / (y - c) \\<ge> (f x - f c) / (x - c)\""], ["proof (prove)\nusing this:\n  f y - f c \\<le> (f x - f c) * ((y - c) / (x - c))\n\ngoal (1 subgoal):\n 1. (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "using y xc"], ["proof (prove)\nusing this:\n  f y - f c \\<le> (f x - f c) * ((y - c) / (x - c))\n  y \\<in> {x<..<c}\n  x < c\n\ngoal (1 subgoal):\n 1. (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F y in at_left c.\n     (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "hence \"eventually (\\<lambda>y. (f y - f c) / (y - c) \\<ge> (f x - f c) / (x - c)) (at c within ?A')\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F y in at_left c.\n     (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F y in at c within {x<..<c}.\n       (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "by (simp add: eventually_at_filter eventually_mono)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F y in at c within {x<..<c}.\n     (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "ultimately"], ["proof (chain)\npicking this:\n  at c within {x<..<c} \\<noteq> bot\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within {x<..<c})\n  \\<forall>\\<^sub>F y in at c within {x<..<c}.\n     (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)", "have \"f' \\<ge> (f x - f c) / (x - c)\""], ["proof (prove)\nusing this:\n  at c within {x<..<c} \\<noteq> bot\n  ((\\<lambda>y. (f y - f c) / (y - c)) \\<longlongrightarrow> f')\n   (at c within {x<..<c})\n  \\<forall>\\<^sub>F y in at c within {x<..<c}.\n     (f x - f c) / (x - c) \\<le> (f y - f c) / (y - c)\n\ngoal (1 subgoal):\n 1. (f x - f c) / (x - c) \\<le> f'", "by (simp add: tendsto_lowerbound)"], ["proof (state)\nthis:\n  (f x - f c) / (x - c) \\<le> f'\n\ngoal (2 subgoals):\n 1. x < c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c\n 2. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "thus ?thesis"], ["proof (prove)\nusing this:\n  (f x - f c) / (x - c) \\<le> f'\n\ngoal (1 subgoal):\n 1. f' * (x - c) \\<le> f x - f c", "using xc"], ["proof (prove)\nusing this:\n  (f x - f c) / (x - c) \\<le> f'\n  x < c\n\ngoal (1 subgoal):\n 1. f' * (x - c) \\<le> f x - f c", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  f' * (x - c) \\<le> f x - f c\n\ngoal (1 subgoal):\n 1. x = c \\<Longrightarrow> f' * (x - c) \\<le> f x - f c", "qed simp_all"], ["", "text \\<open>Approximate operations on affine forms.\\<close>"], ["", "lemma Affine_notempty[intro, simp]: \"Affine X \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Affine X \\<noteq> {}", "by (auto simp: Affine_def valuate_def)"], ["", "lemma truncate_up_lt: \"x < y \\<Longrightarrow> x < truncate_up prec y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> x < truncate_up prec y", "by (rule less_le_trans[OF _ truncate_up])"], ["", "lemma truncate_up_pos_eq[simp]: \"0 < truncate_up p x \\<longleftrightarrow> 0 < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < truncate_up p x) = (0 < x)", "by (auto simp: truncate_up_lt) (metis (poly_guards_query) not_le truncate_up_nonpos)"], ["", "lemma inner_scaleR_pdevs_0: \"inner_scaleR_pdevs 0 One_pdevs = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_scaleR_pdevs (0::'a) One_pdevs = zero_pdevs", "unfolding inner_scaleR_pdevs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unop_pdevs (\\<lambda>x. ((0::'a) \\<bullet> x) *\\<^sub>R x) One_pdevs =\n    zero_pdevs", "by transfer (auto simp: unop_pdevs_raw_def)"], ["", "lemma Affine_aform_of_point_eq[simp]: \"Affine (aform_of_point p) = {p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Affine (aform_of_point p) = {p}", "by (simp add: Affine_aform_of_ivl aform_of_point_def)"], ["", "lemma mem_Affine_aform_of_point: \"x \\<in> Affine (aform_of_point x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Affine (aform_of_point x)", "by simp"], ["", "lemma\n  aform_val_aform_of_ivl_innerE:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"a \\<le> b\" \"c \\<in> Basis\"\n  obtains f where \"aform_val e (aform_of_ivl a b) \\<bullet> c = aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))\"\n    \"f \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>aform_val e (aform_of_ivl a b) \\<bullet> c =\n                 aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c));\n         f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>aform_val e (aform_of_ivl a b) \\<bullet> c =\n                 aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c));\n         f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \"a \\<bullet> c \\<le> b \\<bullet> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<bullet> c \\<le> b \\<bullet> c", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  a \\<le> b\n  c \\<in> Basis\n\ngoal (1 subgoal):\n 1. a \\<bullet> c \\<le> b \\<bullet> c", "by (auto simp: eucl_le[where 'a='a])"], ["proof (state)\nthis:\n  a \\<bullet> c \\<le> b \\<bullet> c\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>aform_val e (aform_of_ivl a b) \\<bullet> c =\n                 aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c));\n         f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<lambda>x. x \\<bullet> c) ` Affine (aform_of_ivl a b) = Affine (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x \\<bullet> c) ` Affine (aform_of_ivl a b) =\n    Affine (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  a \\<le> b\n  c \\<in> Basis\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x \\<bullet> c) ` Affine (aform_of_ivl a b) =\n    Affine (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))", "by (auto simp: Affine_aform_of_ivl eucl_le[where 'a='a]\n      image_eqI[where x=\"\\<Sum>i\\<in>Basis. (if i = c then x else a \\<bullet> i) *\\<^sub>R i\" for x])"], ["proof (state)\nthis:\n  (\\<lambda>x. x \\<bullet> c) ` Affine (aform_of_ivl a b) =\n  Affine (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>aform_val e (aform_of_ivl a b) \\<bullet> c =\n                 aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c));\n         f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. x \\<bullet> c) ` Affine (aform_of_ivl a b) =\n  Affine (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))", "obtain f where\n      \"aform_val e (aform_of_ivl a b) \\<bullet> c = aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))\"\n      \"f \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. x \\<bullet> c) ` Affine (aform_of_ivl a b) =\n  Affine (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>aform_val e (aform_of_ivl a b) \\<bullet> c =\n                 aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c));\n         f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (\\<lambda>x. x \\<bullet> c) ` Affine (aform_of_ivl a b) =\n  Affine (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  a \\<le> b\n  c \\<in> Basis\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>aform_val e (aform_of_ivl a b) \\<bullet> c =\n                 aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c));\n         f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: Affine_def valuate_def)"], ["proof (state)\nthis:\n  aform_val e (aform_of_ivl a b) \\<bullet> c =\n  aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>aform_val e (aform_of_ivl a b) \\<bullet> c =\n                 aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c));\n         f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  aform_val e (aform_of_ivl a b) \\<bullet> c =\n  aform_val f (aform_of_ivl (a \\<bullet> c) (b \\<bullet> c))\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition coord_pdevs::\"nat \\<Rightarrow> real pdevs\" is \"\\<lambda>n i. if i = n then 1 else 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat. finite {i. (if i = nat then 1 else 0) \\<noteq> 0}", "by auto"], ["", "lemma pdevs_apply_coord_pdevs [simp]: \"pdevs_apply (coord_pdevs i) x = (if x = i then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (coord_pdevs i) x = (if x = i then 1 else 0)", "by transfer simp"], ["", "lemma degree_coord_pdevs[simp]: \"degree (coord_pdevs i) = Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (coord_pdevs i) = Suc i", "by (auto intro!: degree_eqI)"], ["", "lemma pdevs_val_coord_pdevs[simp]: \"pdevs_val e (coord_pdevs i) = e i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (coord_pdevs i) = e i", "by (auto simp: pdevs_val_sum if_distrib sum.delta cong: if_cong)"], ["", "definition \"aforms_of_ivls ls us = map\n    (\\<lambda>(i, (l, u)). ((l + u)/2, scaleR_pdevs ((u - l)/2) (coord_pdevs i)))\n    (zip [0..<length ls] (zip ls us))\""], ["", "lemma\n  aforms_of_ivls:\n  assumes \"length ls = length us\" \"length xs = length ls\"\n  assumes \"\\<And>i. i < length xs \\<Longrightarrow> xs ! i \\<in> {ls ! i .. us ! i}\"\n  shows \"xs \\<in> Joints (aforms_of_ivls ls us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "assume \"i < length xs\""], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "then"], ["proof (chain)\npicking this:\n  i < length xs", "have \"\\<exists>e. e \\<in> {-1 .. 1} \\<and> xs ! i = (ls ! i + us ! i) / 2 + e * (us ! i - ls ! i) / 2\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> {- 1..1} \\<and>\n       xs ! i = (ls ! i + us ! i) / 2 + e * (us ! i - ls ! i) / 2", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n  length ls = length us\n  length xs = length ls\n  ?i < length xs \\<Longrightarrow> xs ! ?i \\<in> {ls ! ?i..us ! ?i}\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> {- 1..1} \\<and>\n       xs ! i = (ls ! i + us ! i) / 2 + e * (us ! i - ls ! i) / 2", "by (force intro!: exI[where x=\"(xs ! i - (ls ! i + us ! i) / 2) / (us ! i - ls ! i) * 2\"]\n          simp: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  \\<exists>e.\n     e \\<in> {- 1..1} \\<and>\n     xs ! i = (ls ! i + us ! i) / 2 + e * (us ! i - ls ! i) / 2\n\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "}"], ["proof (state)\nthis:\n  ?i2 < length xs \\<Longrightarrow>\n  \\<exists>e.\n     e \\<in> {- 1..1} \\<and>\n     xs ! ?i2 = (ls ! ?i2 + us ! ?i2) / 2 + e * (us ! ?i2 - ls ! ?i2) / 2\n\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "then"], ["proof (chain)\npicking this:\n  ?i2 < length xs \\<Longrightarrow>\n  \\<exists>e.\n     e \\<in> {- 1..1} \\<and>\n     xs ! ?i2 = (ls ! ?i2 + us ! ?i2) / 2 + e * (us ! ?i2 - ls ! ?i2) / 2", "obtain e where e: \"e i \\<in> {-1 .. 1}\"\n    \"xs ! i = (ls ! i + us ! i) / 2 + e i * (us ! i - ls ! i) / 2\" \n    if \"i < length xs\" for i"], ["proof (prove)\nusing this:\n  ?i2 < length xs \\<Longrightarrow>\n  \\<exists>e.\n     e \\<in> {- 1..1} \\<and>\n     xs ! ?i2 = (ls ! ?i2 + us ! ?i2) / 2 + e * (us ! ?i2 - ls ! ?i2) / 2\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow> e i \\<in> {- 1..1};\n         \\<And>i.\n            i < length xs \\<Longrightarrow>\n            xs ! i =\n            (ls ! i + us ! i) / 2 + e i * (us ! i - ls ! i) / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using that"], ["proof (prove)\nusing this:\n  ?i2 < length xs \\<Longrightarrow>\n  \\<exists>e.\n     e \\<in> {- 1..1} \\<and>\n     xs ! ?i2 = (ls ! ?i2 + us ! ?i2) / 2 + e * (us ! ?i2 - ls ! ?i2) / 2\n  \\<lbrakk>\\<And>i. i < length xs \\<Longrightarrow> ?e i \\<in> {- 1..1};\n   \\<And>i.\n      i < length xs \\<Longrightarrow>\n      xs ! i = (ls ! i + us ! i) / 2 + ?e i * (us ! i - ls ! i) / 2\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow> e i \\<in> {- 1..1};\n         \\<And>i.\n            i < length xs \\<Longrightarrow>\n            xs ! i =\n            (ls ! i + us ! i) / 2 + e i * (us ! i - ls ! i) / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow> e ?i \\<in> {- 1..1}\n  ?i < length xs \\<Longrightarrow>\n  xs ! ?i = (ls ! ?i + us ! ?i) / 2 + e ?i * (us ! ?i - ls ! ?i) / 2\n\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "define e' where \"e' i = (if i < length xs then e i else 0)\" for i"], ["proof (state)\nthis:\n  e' ?i = (if ?i < length xs then e ?i else 0)\n\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "using e assms"], ["proof (prove)\nusing this:\n  ?i < length xs \\<Longrightarrow> e ?i \\<in> {- 1..1}\n  ?i < length xs \\<Longrightarrow>\n  xs ! ?i = (ls ! ?i + us ! ?i) / 2 + e ?i * (us ! ?i - ls ! ?i) / 2\n  length ls = length us\n  length xs = length ls\n  ?i < length xs \\<Longrightarrow> xs ! ?i \\<in> {ls ! ?i..us ! ?i}\n\ngoal (1 subgoal):\n 1. xs \\<in> Joints (aforms_of_ivls ls us)", "by (auto simp: aforms_of_ivls_def Joints_def valuate_def e'_def aform_val_def\n        intro!: image_eqI[where x=e'] nth_equalityI)"], ["proof (state)\nthis:\n  xs \\<in> Joints (aforms_of_ivls ls us)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Approximate Operations\\<close>"], ["", "definition \"max_pdev x = fold (\\<lambda>x y. if infnorm (snd x) \\<ge> infnorm (snd y) then x else y) (list_of_pdevs x) (0, 0)\""], ["", "subsubsection \\<open>set of generated endpoints\\<close>"], ["", "fun points_of_list where\n  \"points_of_list x0 [] = [x0]\"\n| \"points_of_list x0 ((i, x)#xs) = (points_of_list (x0 + x) xs @ points_of_list (x0 - x) xs)\""], ["", "primrec points_of_aform where\n  \"points_of_aform (x, xs) = points_of_list x (list_of_pdevs xs)\""], ["", "subsubsection \\<open>Approximate total deviation\\<close>"], ["", "definition sum_list'::\"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a::executable_euclidean_space\"\n  where \"sum_list' p xs = fold (\\<lambda>a b. eucl_truncate_up p (a + b)) xs 0\""], ["", "definition \"tdev' p x = sum_list' p (map (abs o snd) (list_of_pdevs x))\""], ["", "lemma\n  eucl_fold_mono:\n  fixes f::\"'a::ordered_euclidean_space\\<Rightarrow>'a\\<Rightarrow>'a\"\n  assumes mono: \"\\<And>w x y z. w \\<le> x \\<Longrightarrow> y \\<le> z \\<Longrightarrow> f w y \\<le> f x z\"\n  shows \"x \\<le> y \\<Longrightarrow> fold f xs x \\<le> fold f xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> fold f xs x \\<le> fold f xs y", "by (induct xs arbitrary: x y) (auto simp: mono)"], ["", "lemma sum_list_add_le_fold_eucl_truncate_up:\n  fixes z::\"'a::executable_euclidean_space\"\n  shows \"sum_list xs + z \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs + z\n    \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs z", "proof (induct xs arbitrary: z)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z.\n       sum_list [] + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) [] z\n 2. \\<And>a xs z.\n       (\\<And>z.\n           sum_list xs + z\n           \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n                  z) \\<Longrightarrow>\n       sum_list (a # xs) + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) (a # xs) z", "case (Cons x xs)"], ["proof (state)\nthis:\n  sum_list xs + ?z\n  \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs ?z\n\ngoal (2 subgoals):\n 1. \\<And>z.\n       sum_list [] + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) [] z\n 2. \\<And>a xs z.\n       (\\<And>z.\n           sum_list xs + z\n           \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n                  z) \\<Longrightarrow>\n       sum_list (a # xs) + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) (a # xs) z", "have \"sum_list (x # xs) + z = sum_list xs + (z + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (x # xs) + z = sum_list xs + (z + x)", "by simp"], ["proof (state)\nthis:\n  sum_list (x # xs) + z = sum_list xs + (z + x)\n\ngoal (2 subgoals):\n 1. \\<And>z.\n       sum_list [] + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) [] z\n 2. \\<And>a xs z.\n       (\\<And>z.\n           sum_list xs + z\n           \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n                  z) \\<Longrightarrow>\n       sum_list (a # xs) + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) (a # xs) z", "also"], ["proof (state)\nthis:\n  sum_list (x # xs) + z = sum_list xs + (z + x)\n\ngoal (2 subgoals):\n 1. \\<And>z.\n       sum_list [] + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) [] z\n 2. \\<And>a xs z.\n       (\\<And>z.\n           sum_list xs + z\n           \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n                  z) \\<Longrightarrow>\n       sum_list (a # xs) + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) (a # xs) z", "have \"\\<dots> \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs (z + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs + (z + x)\n    \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs (z + x)", "using Cons"], ["proof (prove)\nusing this:\n  sum_list xs + ?z\n  \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs ?z\n\ngoal (1 subgoal):\n 1. sum_list xs + (z + x)\n    \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs (z + x)", "by simp"], ["proof (state)\nthis:\n  sum_list xs + (z + x)\n  \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs (z + x)\n\ngoal (2 subgoals):\n 1. \\<And>z.\n       sum_list [] + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) [] z\n 2. \\<And>a xs z.\n       (\\<And>z.\n           sum_list xs + z\n           \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n                  z) \\<Longrightarrow>\n       sum_list (a # xs) + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) (a # xs) z", "also"], ["proof (state)\nthis:\n  sum_list xs + (z + x)\n  \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs (z + x)\n\ngoal (2 subgoals):\n 1. \\<And>z.\n       sum_list [] + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) [] z\n 2. \\<And>a xs z.\n       (\\<And>z.\n           sum_list xs + z\n           \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n                  z) \\<Longrightarrow>\n       sum_list (a # xs) + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) (a # xs) z", "have \"\\<dots> \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs (eucl_truncate_up p (x + z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs (z + x)\n    \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n           (eucl_truncate_up p (x + z))", "by (auto intro!: add_mono eucl_fold_mono eucl_truncate_up eucl_truncate_up_mono simp: ac_simps)"], ["proof (state)\nthis:\n  fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs (z + x)\n  \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n         (eucl_truncate_up p (x + z))\n\ngoal (2 subgoals):\n 1. \\<And>z.\n       sum_list [] + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) [] z\n 2. \\<And>a xs z.\n       (\\<And>z.\n           sum_list xs + z\n           \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n                  z) \\<Longrightarrow>\n       sum_list (a # xs) + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) (a # xs) z", "finally"], ["proof (chain)\npicking this:\n  sum_list (x # xs) + z\n  \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n         (eucl_truncate_up p (x + z))", "show ?case"], ["proof (prove)\nusing this:\n  sum_list (x # xs) + z\n  \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) xs\n         (eucl_truncate_up p (x + z))\n\ngoal (1 subgoal):\n 1. sum_list (x # xs) + z\n    \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) (x # xs) z", "by simp"], ["proof (state)\nthis:\n  sum_list (x # xs) + z\n  \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) (x # xs) z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       sum_list [] + z\n       \\<le> fold (\\<lambda>x y. eucl_truncate_up p (x + y)) [] z", "qed simp"], ["", "lemma sum_list_le_sum_list':\n  \"sum_list xs \\<le> sum_list' p xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs \\<le> sum_list' p xs", "unfolding sum_list'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs\n    \\<le> fold (\\<lambda>a b. eucl_truncate_up p (a + b)) xs (0::'a)", "using sum_list_add_le_fold_eucl_truncate_up[of xs 0]"], ["proof (prove)\nusing this:\n  sum_list xs + (0::'a)\n  \\<le> fold (\\<lambda>x y. eucl_truncate_up ?p (x + y)) xs (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list xs\n    \\<le> fold (\\<lambda>a b. eucl_truncate_up p (a + b)) xs (0::'a)", "by simp"], ["", "lemma sum_list'_sum_list_le:\n  \"y \\<le> sum_list xs \\<Longrightarrow> y \\<le> sum_list' p xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> sum_list xs \\<Longrightarrow> y \\<le> sum_list' p xs", "by (metis sum_list_le_sum_list' order.trans)"], ["", "lemma tdev': \"tdev x \\<le> tdev' p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev x \\<le> tdev' p x", "unfolding tdev'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "have \"tdev x = (\\<Sum>i = 0 ..< degree x. \\<bar>pdevs_apply x i\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev x = (\\<Sum>i = 0..<degree x. \\<bar>pdevs_apply x i\\<bar>)", "by (auto intro!: sum.mono_neutral_cong_left simp: tdev_def)"], ["proof (state)\nthis:\n  tdev x = (\\<Sum>i = 0..<degree x. \\<bar>pdevs_apply x i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "also"], ["proof (state)\nthis:\n  tdev x = (\\<Sum>i = 0..<degree x. \\<bar>pdevs_apply x i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "have \"\\<dots> = (\\<Sum>i \\<leftarrow> rev [0 ..< degree x]. \\<bar>pdevs_apply x i\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<degree x. \\<bar>pdevs_apply x i\\<bar>) =\n    (\\<Sum>i\\<leftarrow>rev [0..<degree x]. \\<bar>pdevs_apply x i\\<bar>)", "by (metis atLeastLessThan_upt sum_list_rev rev_map sum_set_upt_conv_sum_list_nat)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<degree x. \\<bar>pdevs_apply x i\\<bar>) =\n  (\\<Sum>i\\<leftarrow>rev [0..<degree x]. \\<bar>pdevs_apply x i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<degree x. \\<bar>pdevs_apply x i\\<bar>) =\n  (\\<Sum>i\\<leftarrow>rev [0..<degree x]. \\<bar>pdevs_apply x i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "have\n    \"\\<dots> = sum_list (map (\\<lambda>xa. \\<bar>pdevs_apply x xa\\<bar>) [xa\\<leftarrow>rev [0..<degree x] . pdevs_apply x xa \\<noteq> 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>rev [0..<degree x]. \\<bar>pdevs_apply x i\\<bar>) =\n    (\\<Sum>xa\\<leftarrow>filter\n                          (\\<lambda>xa. pdevs_apply x xa \\<noteq> (0::'a))\n                          (rev [0..<\n                                degree x]). \\<bar>pdevs_apply x xa\\<bar>)", "unfolding filter_map map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>rev [0..<degree x]. \\<bar>pdevs_apply x i\\<bar>) =\n    (\\<Sum>xa\\<leftarrow>filter\n                          (\\<lambda>xa. pdevs_apply x xa \\<noteq> (0::'a))\n                          (rev [0..<\n                                degree x]). \\<bar>pdevs_apply x xa\\<bar>)", "by (subst sum_list_map_filter) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>rev [0..<degree x]. \\<bar>pdevs_apply x i\\<bar>) =\n  (\\<Sum>xa\\<leftarrow>filter\n                        (\\<lambda>xa. pdevs_apply x xa \\<noteq> (0::'a))\n                        (rev [0..<degree x]). \\<bar>pdevs_apply x xa\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>rev [0..<degree x]. \\<bar>pdevs_apply x i\\<bar>) =\n  (\\<Sum>xa\\<leftarrow>filter\n                        (\\<lambda>xa. pdevs_apply x xa \\<noteq> (0::'a))\n                        (rev [0..<degree x]). \\<bar>pdevs_apply x xa\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "note sum_list_le_sum_list'[of _ p]"], ["proof (state)\nthis:\n  sum_list ?xs \\<le> sum_list' p ?xs\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "also"], ["proof (state)\nthis:\n  sum_list ?xs \\<le> sum_list' p ?xs\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "have \"[xa\\<leftarrow>rev [0..<degree x] . pdevs_apply x xa \\<noteq> 0] =\n      rev (sorted_list_of_set (pdevs_domain x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>xa. pdevs_apply x xa \\<noteq> (0::'a))\n     (rev [0..<degree x]) =\n    rev (sorted_list_of_set (pdevs_domain x))", "by (subst rev_is_rev_conv[symmetric])\n      (auto simp: filter_map rev_filter intro!: sorted_distinct_set_unique\n        sorted_filter[of \"\\<lambda>x. x\", simplified] degree_gt)"], ["proof (state)\nthis:\n  filter (\\<lambda>xa. pdevs_apply x xa \\<noteq> (0::'a))\n   (rev [0..<degree x]) =\n  rev (sorted_list_of_set (pdevs_domain x))\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "finally"], ["proof (chain)\npicking this:\n  tdev x\n  \\<le> sum_list' p\n         (map (\\<lambda>xa. \\<bar>pdevs_apply x xa\\<bar>)\n           (rev (sorted_list_of_set (pdevs_domain x))))", "show \"tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))\""], ["proof (prove)\nusing this:\n  tdev x\n  \\<le> sum_list' p\n         (map (\\<lambda>xa. \\<bar>pdevs_apply x xa\\<bar>)\n           (rev (sorted_list_of_set (pdevs_domain x))))\n\ngoal (1 subgoal):\n 1. tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))", "by (auto simp: list_of_pdevs_def o_def rev_map filter_map rev_filter)"], ["proof (state)\nthis:\n  tdev x \\<le> sum_list' p (map (abs \\<circ> snd) (list_of_pdevs x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tdev'_le: \"x \\<le> tdev y \\<Longrightarrow> x \\<le> tdev' p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> tdev y \\<Longrightarrow> x \\<le> tdev' p y", "by (metis order.trans tdev')"], ["", "lemmas abs_pdevs_val_le_tdev' = tdev'_le[OF abs_pdevs_val_le_tdev]"], ["", "lemma tdev'_uminus_pdevs[simp]: \"tdev' p (uminus_pdevs x) = tdev' p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev' p (uminus_pdevs x) = tdev' p x", "by (auto simp: tdev'_def o_def rev_map filter_map rev_filter list_of_pdevs_def pdevs_domain_def)"], ["", "abbreviation Radius::\"'a::ordered_euclidean_space aform \\<Rightarrow> 'a\"\n  where \"Radius X \\<equiv> tdev (snd X)\""], ["", "abbreviation Radius'::\"nat\\<Rightarrow>'a::executable_euclidean_space aform \\<Rightarrow> 'a\"\n  where \"Radius' p X \\<equiv> tdev' p (snd X)\""], ["", "lemma Radius'_uminus_aform[simp]: \"Radius' p (uminus_aform X) = Radius' p X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Radius' p (uminus_aform X) = Radius' p X", "by (auto simp: uminus_aform_def)"], ["", "subsubsection \\<open>truncate partial deviations\\<close>"], ["", "definition trunc_pdevs_raw::\"nat \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> nat \\<Rightarrow> 'a::executable_euclidean_space\"\n  where \"trunc_pdevs_raw p x i = eucl_truncate_down p (x i)\""], ["", "lemma nonzeros_trunc_pdevs_raw:\n  \"{i. trunc_pdevs_raw r x i \\<noteq> 0} \\<subseteq> {i. x i \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. trunc_pdevs_raw r x i \\<noteq> (0::'a)}\n    \\<subseteq> {i. x i \\<noteq> (0::'a)}", "by (auto simp: trunc_pdevs_raw_def[abs_def])"], ["", "lift_definition trunc_pdevs::\"nat \\<Rightarrow> 'a::executable_euclidean_space pdevs \\<Rightarrow> 'a pdevs\"\n  is trunc_pdevs_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat fun.\n       finite {i. fun i \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {i. trunc_pdevs_raw nat fun i \\<noteq> (0::'a)}", "by (auto intro!: finite_subset[OF nonzeros_trunc_pdevs_raw])"], ["", "definition trunc_err_pdevs_raw::\"nat \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> nat \\<Rightarrow> 'a::executable_euclidean_space\"\n  where \"trunc_err_pdevs_raw p x i = trunc_pdevs_raw p x i - x i\""], ["", "lemma nonzeros_trunc_err_pdevs_raw:\n  \"{i. trunc_err_pdevs_raw r x i \\<noteq> 0} \\<subseteq> {i. x i \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. trunc_err_pdevs_raw r x i \\<noteq> (0::'a)}\n    \\<subseteq> {i. x i \\<noteq> (0::'a)}", "by (auto simp: trunc_pdevs_raw_def trunc_err_pdevs_raw_def[abs_def])"], ["", "lift_definition trunc_err_pdevs::\"nat \\<Rightarrow> 'a::executable_euclidean_space pdevs \\<Rightarrow> 'a pdevs\"\n  is trunc_err_pdevs_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat fun.\n       finite {i. fun i \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {i. trunc_err_pdevs_raw nat fun i \\<noteq> (0::'a)}", "by (auto intro!: finite_subset[OF nonzeros_trunc_err_pdevs_raw])"], ["", "term float_plus_down"], ["", "lemma pdevs_apply_trunc_pdevs[simp]:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_apply (trunc_pdevs p X) n = eucl_truncate_down p (pdevs_apply X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (trunc_pdevs p X) n = eucl_truncate_down p (pdevs_apply X n)", "by transfer (simp add: trunc_pdevs_raw_def)"], ["", "lemma pdevs_apply_trunc_err_pdevs[simp]:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_apply (trunc_err_pdevs p X) n =\n    eucl_truncate_down p (pdevs_apply X n) - (pdevs_apply X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (trunc_err_pdevs p X) n =\n    eucl_truncate_down p (pdevs_apply X n) - pdevs_apply X n", "by transfer (auto simp: trunc_err_pdevs_raw_def trunc_pdevs_raw_def)"], ["", "lemma pdevs_val_trunc_pdevs:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_val e (trunc_pdevs p X) = pdevs_val e X + pdevs_val e (trunc_err_pdevs p X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (trunc_pdevs p X) =\n    pdevs_val e X + pdevs_val e (trunc_err_pdevs p X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e (trunc_pdevs p X) =\n    pdevs_val e X + pdevs_val e (trunc_err_pdevs p X)", "have \"pdevs_val e X + pdevs_val e (trunc_err_pdevs p X) =\n      pdevs_val e (add_pdevs X (trunc_err_pdevs p X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e X + pdevs_val e (trunc_err_pdevs p X) =\n    pdevs_val e (add_pdevs X (trunc_err_pdevs p X))", "by simp"], ["proof (state)\nthis:\n  pdevs_val e X + pdevs_val e (trunc_err_pdevs p X) =\n  pdevs_val e (add_pdevs X (trunc_err_pdevs p X))\n\ngoal (1 subgoal):\n 1. pdevs_val e (trunc_pdevs p X) =\n    pdevs_val e X + pdevs_val e (trunc_err_pdevs p X)", "also"], ["proof (state)\nthis:\n  pdevs_val e X + pdevs_val e (trunc_err_pdevs p X) =\n  pdevs_val e (add_pdevs X (trunc_err_pdevs p X))\n\ngoal (1 subgoal):\n 1. pdevs_val e (trunc_pdevs p X) =\n    pdevs_val e X + pdevs_val e (trunc_err_pdevs p X)", "have \"\\<dots> = pdevs_val e (trunc_pdevs p X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X (trunc_err_pdevs p X)) =\n    pdevs_val e (trunc_pdevs p X)", "by (auto simp: pdevs_val_def trunc_pdevs_raw_def trunc_err_pdevs_raw_def)"], ["proof (state)\nthis:\n  pdevs_val e (add_pdevs X (trunc_err_pdevs p X)) =\n  pdevs_val e (trunc_pdevs p X)\n\ngoal (1 subgoal):\n 1. pdevs_val e (trunc_pdevs p X) =\n    pdevs_val e X + pdevs_val e (trunc_err_pdevs p X)", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e X + pdevs_val e (trunc_err_pdevs p X) =\n  pdevs_val e (trunc_pdevs p X)", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_val e X + pdevs_val e (trunc_err_pdevs p X) =\n  pdevs_val e (trunc_pdevs p X)\n\ngoal (1 subgoal):\n 1. pdevs_val e (trunc_pdevs p X) =\n    pdevs_val e X + pdevs_val e (trunc_err_pdevs p X)", "by simp"], ["proof (state)\nthis:\n  pdevs_val e (trunc_pdevs p X) =\n  pdevs_val e X + pdevs_val e (trunc_err_pdevs p X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_val_trunc_err_pdevs:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_val e (trunc_err_pdevs p X) = pdevs_val e (trunc_pdevs p X) - pdevs_val e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (trunc_err_pdevs p X) =\n    pdevs_val e (trunc_pdevs p X) - pdevs_val e X", "by (simp add: pdevs_val_trunc_pdevs)"], ["", "definition truncate_aform::\"nat \\<Rightarrow> 'a aform \\<Rightarrow> 'a::executable_euclidean_space aform\"\n  where \"truncate_aform p x = (eucl_truncate_down p (fst x), trunc_pdevs p (snd x))\""], ["", "definition truncate_error_aform::\"nat \\<Rightarrow> 'a aform \\<Rightarrow> 'a::executable_euclidean_space aform\"\n  where \"truncate_error_aform p x =\n    (eucl_truncate_down p (fst x) - fst x, trunc_err_pdevs p (snd x))\""], ["", "lemma\n  abs_aform_val_le:\n  assumes \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  shows \"abs (aform_val e X) \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + tdev' p (snd X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "have \"abs (aform_val e X) \\<le> \\<bar>fst X\\<bar> + \\<bar>pdevs_val e (snd X)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> \\<bar>fst X\\<bar> + \\<bar>pdevs_val e (snd X)\\<bar>", "by (auto simp: aform_val_def intro!: abs_triangle_ineq)"], ["proof (state)\nthis:\n  \\<bar>aform_val e X\\<bar>\n  \\<le> \\<bar>fst X\\<bar> + \\<bar>pdevs_val e (snd X)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "also"], ["proof (state)\nthis:\n  \\<bar>aform_val e X\\<bar>\n  \\<le> \\<bar>fst X\\<bar> + \\<bar>pdevs_val e (snd X)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "have \"\\<bar>pdevs_val e (snd X)\\<bar> \\<le> tdev (snd X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e (snd X)\\<bar> \\<le> Radius X", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e (snd X)\\<bar> \\<le> Radius X", "by (rule abs_pdevs_val_le_tdev)"], ["proof (state)\nthis:\n  \\<bar>pdevs_val e (snd X)\\<bar> \\<le> Radius X\n\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "also"], ["proof (state)\nthis:\n  \\<bar>pdevs_val e (snd X)\\<bar> \\<le> Radius X\n\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "note tdev'"], ["proof (state)\nthis:\n  tdev ?x \\<le> tdev' ?p ?x\n\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "also"], ["proof (state)\nthis:\n  tdev ?x \\<le> tdev' ?p ?x\n\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "note eucl_truncate_up"], ["proof (state)\nthis:\n  ?x \\<le> eucl_truncate_up ?e ?x\n\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              \\<bar>fst X\\<bar> + x \\<le> \\<bar>fst X\\<bar> + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      \\<bar>fst X\\<bar> + x \\<le> \\<bar>fst X\\<bar> + y\\<rbrakk>\n  \\<Longrightarrow> \\<bar>aform_val e X\\<bar>\n                    \\<le> eucl_truncate_up ?e1\n                           (\\<bar>fst X\\<bar> + Radius' ?p3 X)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              \\<bar>fst X\\<bar> + x \\<le> \\<bar>fst X\\<bar> + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      \\<bar>fst X\\<bar> + x \\<le> \\<bar>fst X\\<bar> + y\\<rbrakk>\n  \\<Longrightarrow> \\<bar>aform_val e X\\<bar>\n                    \\<le> eucl_truncate_up ?e1\n                           (\\<bar>fst X\\<bar> + Radius' ?p3 X)\n\ngoal (1 subgoal):\n 1. \\<bar>aform_val e X\\<bar>\n    \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)", "by simp"], ["proof (state)\nthis:\n  \\<bar>aform_val e X\\<bar>\n  \\<le> eucl_truncate_up p (\\<bar>fst X\\<bar> + Radius' p X)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>truncation with error bound\\<close>"], ["", "definition \"trunc_bound_eucl p s =\n  (let\n    d = eucl_truncate_down p s;\n    ed = abs (d - s) in\n  (d, eucl_truncate_up p ed))\""], ["", "lemma trunc_bound_euclE:\n  obtains err where\n  \"\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x)\"\n  \"fst (trunc_bound_eucl p x) = x + err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x);\n         fst (trunc_bound_eucl p x) = x + err\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x) \\<and>\n       fst (trunc_bound_eucl p x) = x + err", "have \"fst (trunc_bound_eucl p x) = x + (eucl_truncate_down p x - x)\"\n    (is \"_ = _ + ?err\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (trunc_bound_eucl p x) = x + (eucl_truncate_down p x - x)", "by (simp_all add: trunc_bound_eucl_def Let_def)"], ["proof (state)\nthis:\n  fst (trunc_bound_eucl p x) = x + (eucl_truncate_down p x - x)\n\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x) \\<and>\n       fst (trunc_bound_eucl p x) = x + err", "moreover"], ["proof (state)\nthis:\n  fst (trunc_bound_eucl p x) = x + (eucl_truncate_down p x - x)\n\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x) \\<and>\n       fst (trunc_bound_eucl p x) = x + err", "have \"abs ?err \\<le> snd (trunc_bound_eucl p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>eucl_truncate_down p x - x\\<bar> \\<le> snd (trunc_bound_eucl p x)", "by (simp add: trunc_bound_eucl_def Let_def eucl_truncate_up)"], ["proof (state)\nthis:\n  \\<bar>eucl_truncate_down p x - x\\<bar> \\<le> snd (trunc_bound_eucl p x)\n\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x) \\<and>\n       fst (trunc_bound_eucl p x) = x + err", "ultimately"], ["proof (chain)\npicking this:\n  fst (trunc_bound_eucl p x) = x + (eucl_truncate_down p x - x)\n  \\<bar>eucl_truncate_down p x - x\\<bar> \\<le> snd (trunc_bound_eucl p x)", "show \"\\<exists>err. \\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x) \\<and> fst (trunc_bound_eucl p x) = x + err\""], ["proof (prove)\nusing this:\n  fst (trunc_bound_eucl p x) = x + (eucl_truncate_down p x - x)\n  \\<bar>eucl_truncate_down p x - x\\<bar> \\<le> snd (trunc_bound_eucl p x)\n\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x) \\<and>\n       fst (trunc_bound_eucl p x) = x + err", "by auto"], ["proof (state)\nthis:\n  \\<exists>err.\n     \\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p x) \\<and>\n     fst (trunc_bound_eucl p x) = x + err\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"trunc_bound_pdevs p x = (trunc_pdevs p x, tdev' p (trunc_err_pdevs p x))\""], ["", "lemma pdevs_apply_fst_trunc_bound_pdevs[simp]: \"pdevs_apply (fst (trunc_bound_pdevs p x)) =\n  pdevs_apply (trunc_pdevs p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (fst (trunc_bound_pdevs p x)) =\n    pdevs_apply (trunc_pdevs p x)", "by (simp add: trunc_bound_pdevs_def)"], ["", "lemma trunc_bound_pdevsE:\n  assumes \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  obtains err where\n  \"\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x)\"\n  \"pdevs_val e (fst ((trunc_bound_pdevs p x))) = pdevs_val e x + err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x);\n         pdevs_val e (fst (trunc_bound_pdevs p x)) =\n         pdevs_val e x + err\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x) \\<and>\n       pdevs_val e (fst (trunc_bound_pdevs p x)) = pdevs_val e x + err", "have \"pdevs_val e (fst (trunc_bound_pdevs p x)) = pdevs_val e x +\n    pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\"\n    (is \"_ = _ + ?err\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (fst (trunc_bound_pdevs p x)) =\n    pdevs_val e x +\n    pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))", "by (simp_all add: trunc_bound_pdevs_def Let_def)"], ["proof (state)\nthis:\n  pdevs_val e (fst (trunc_bound_pdevs p x)) =\n  pdevs_val e x + pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\n\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x) \\<and>\n       pdevs_val e (fst (trunc_bound_pdevs p x)) = pdevs_val e x + err", "moreover"], ["proof (state)\nthis:\n  pdevs_val e (fst (trunc_bound_pdevs p x)) =\n  pdevs_val e x + pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\n\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x) \\<and>\n       pdevs_val e (fst (trunc_bound_pdevs p x)) = pdevs_val e x + err", "have \"abs ?err \\<le> snd (trunc_bound_pdevs p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\\<bar>\n    \\<le> snd (trunc_bound_pdevs p x)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\\<bar>\n    \\<le> snd (trunc_bound_pdevs p x)", "by (auto simp add: pdevs_val_trunc_pdevs trunc_bound_pdevs_def Let_def eucl_truncate_up\n      intro!: order_trans[OF abs_pdevs_val_le_tdev tdev'])"], ["proof (state)\nthis:\n  \\<bar>pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\\<bar>\n  \\<le> snd (trunc_bound_pdevs p x)\n\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x) \\<and>\n       pdevs_val e (fst (trunc_bound_pdevs p x)) = pdevs_val e x + err", "ultimately"], ["proof (chain)\npicking this:\n  pdevs_val e (fst (trunc_bound_pdevs p x)) =\n  pdevs_val e x + pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\n  \\<bar>pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\\<bar>\n  \\<le> snd (trunc_bound_pdevs p x)", "show \"\\<exists>err. \\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x) \\<and>\n      pdevs_val e (fst ((trunc_bound_pdevs p x))) = pdevs_val e x + err\""], ["proof (prove)\nusing this:\n  pdevs_val e (fst (trunc_bound_pdevs p x)) =\n  pdevs_val e x + pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\n  \\<bar>pdevs_val e (add_pdevs (trunc_pdevs p x) (uminus_pdevs x))\\<bar>\n  \\<le> snd (trunc_bound_pdevs p x)\n\ngoal (1 subgoal):\n 1. \\<exists>err.\n       \\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x) \\<and>\n       pdevs_val e (fst (trunc_bound_pdevs p x)) = pdevs_val e x + err", "by auto"], ["proof (state)\nthis:\n  \\<exists>err.\n     \\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p x) \\<and>\n     pdevs_val e (fst (trunc_bound_pdevs p x)) = pdevs_val e x + err\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  degree_add_pdevs_le:\n  assumes \"degree X \\<le> n\"\n  assumes \"degree Y \\<le> n\"\n  shows \"degree (add_pdevs X Y) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (add_pdevs X Y) \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  degree X \\<le> n\n  degree Y \\<le> n\n\ngoal (1 subgoal):\n 1. degree (add_pdevs X Y) \\<le> n", "by (auto intro!: degree_le)"], ["", "lemma truncate_aform_error_aform_cancel:\n  \"aform_val e (truncate_aform p z) = aform_val e z + aform_val e (truncate_error_aform p z) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (truncate_aform p z) =\n    aform_val e z + aform_val e (truncate_error_aform p z)", "by (simp add: truncate_aform_def aform_val_def truncate_error_aform_def pdevs_val_trunc_pdevs)"], ["", "lemma error_absE:\n  assumes \"abs err \\<le> k\"\n  obtains e::real where \"err = e * k\" \"e \\<in> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>err = e * k; e \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<bar>err\\<bar> \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>err = e * k; e \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim\n    (safe intro!: exI[where x=\"err / abs k\"] divide_atLeastAtMost_1_absI, auto)"], ["", "lemma eucl_truncate_up_nonneg_eq_zero_iff:\n  \"x \\<ge> 0 \\<Longrightarrow> eucl_truncate_up p x = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x \\<Longrightarrow>\n    (eucl_truncate_up p x = (0::'a)) = (x = (0::'a))", "by (metis (poly_guards_query) eq_iff eucl_truncate_up eucl_truncate_up_zero)"], ["", "lemma\n  aform_val_consume_error:\n  assumes \"abs err \\<le> abs (pdevs_apply (snd X) n)\"\n  shows \"aform_val (e(n := 0)) X + err = aform_val (e(n := err/pdevs_apply (snd X) n)) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val (e(n := 0)) X + err =\n    aform_val (e(n := err / pdevs_apply (snd X) n)) X", "using assms"], ["proof (prove)\nusing this:\n  \\<bar>err\\<bar> \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. aform_val (e(n := 0)) X + err =\n    aform_val (e(n := err / pdevs_apply (snd X) n)) X", "by (auto simp add: aform_val_def)"], ["", "lemma\n  aform_val_consume_errorE:\n  fixes X::\"real aform\"\n  assumes \"abs err \\<le> abs (pdevs_apply (snd X) n)\"\n  obtains err' where \"aform_val (e(n := 0)) X + err = aform_val (e(n := err')) X\" \"err' \\<in> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>err'.\n        \\<lbrakk>aform_val (e(n := 0)) X + err = aform_val (e(n := err')) X;\n         err' \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim\n    (rule aform_val_consume_error assms aform_val_consume_error exI conjI\n      divide_atLeastAtMost_1_absI)+"], ["", "lemma\n  degree_trunc_pdevs_le:\n  assumes \"degree X \\<le> n\"\n  shows \"degree (trunc_pdevs p X) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (trunc_pdevs p X) \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  degree X \\<le> n\n\ngoal (1 subgoal):\n 1. degree (trunc_pdevs p X) \\<le> n", "by (auto intro!: degree_le)"], ["", "lemma pdevs_val_sum_less_degree:\n  \"pdevs_val e X = (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply X i)\" if \"degree X \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e X = (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply X i)", "unfolding pdevs_val_pdevs_domain"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>pdevs_domain X. e i *\\<^sub>R pdevs_apply X i) =\n    (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply X i)", "apply (rule sum.mono_neutral_cong_left)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {..<d}\n 2. pdevs_domain X \\<subseteq> {..<d}\n 3. \\<forall>i\\<in>{..<d} - pdevs_domain X.\n       e i *\\<^sub>R pdevs_apply X i = (0::'a)\n 4. \\<And>x.\n       x \\<in> pdevs_domain X \\<Longrightarrow>\n       e x *\\<^sub>R pdevs_apply X x = e x *\\<^sub>R pdevs_apply X x", "using that"], ["proof (prove)\nusing this:\n  degree X \\<le> d\n\ngoal (4 subgoals):\n 1. finite {..<d}\n 2. pdevs_domain X \\<subseteq> {..<d}\n 3. \\<forall>i\\<in>{..<d} - pdevs_domain X.\n       e i *\\<^sub>R pdevs_apply X i = (0::'a)\n 4. \\<And>x.\n       x \\<in> pdevs_domain X \\<Longrightarrow>\n       e x *\\<^sub>R pdevs_apply X x = e x *\\<^sub>R pdevs_apply X x", "by force+"], ["", "subsubsection \\<open>general affine operation\\<close>"], ["", "definition \"affine_binop (X::real aform) Y a b c d k =\n  (a * fst X + b * fst Y + c,\n    pdev_upd (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) k d)\""], ["", "lemma pdevs_domain_One_pdevs[simp]: \"pdevs_domain (One_pdevs::'a::executable_euclidean_space pdevs) =\n  {0..<DIM('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain One_pdevs = {0..<DIM('a)}", "apply (auto simp: length_Basis_list split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < DIM('a); Basis_list ! x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < DIM('a); Basis_list ! i = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "using nth_Basis_list_in_Basis[of i, where 'a='a]"], ["proof (prove)\nusing this:\n  i < length Basis_list \\<Longrightarrow> Basis_list ! i \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < DIM('a); Basis_list ! i = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto simp: length_Basis_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pdevs_val_One_pdevs:\n  \"pdevs_val e (One_pdevs::'a::executable_euclidean_space pdevs) = (\\<Sum>i<DIM('a). e i *\\<^sub>R Basis_list ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e One_pdevs = (\\<Sum>i<DIM('a). e i *\\<^sub>R Basis_list ! i)", "by (auto simp: pdevs_val_pdevs_domain length_Basis_list intro!:sum.cong)"], ["", "lemma affine_binop:\n  assumes \"degree_aforms [X, Y] \\<le> k\"\n  shows \"aform_val e (affine_binop X Y a b c d k) =\n    a * aform_val e X + b * aform_val e Y + c + e k * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (affine_binop X Y a b c d k) =\n    a * aform_val e X + b * aform_val e Y + c + e k * d", "using assms"], ["proof (prove)\nusing this:\n  degree_aforms [X, Y] \\<le> k\n\ngoal (1 subgoal):\n 1. aform_val e (affine_binop X Y a b c d k) =\n    a * aform_val e X + b * aform_val e Y + c + e k * d", "by (auto simp: aform_val_def affine_binop_def degrees_def\n      pdevs_val_msum_pdevs degree_add_pdevs_le pdevs_val_One_pdevs Basis_list_real_def\n      algebra_simps)"], ["", "definition \"affine_binop' p (X::real aform) Y a b c d k =\n  (let\n    \\<comment> \\<open>TODO: more round-off operations here?\\<close>\n    (r, e1) = trunc_bound_eucl p (a * fst X + b * fst Y + c);\n    (Z, e2) = trunc_bound_pdevs p (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))\n  in\n    (r, pdev_upd Z k (sum_list' p [e1, e2, d]))\n  )\""], ["", "lemma sum_list'_noneg_eq_zero_iff: \"sum_list' p xs = 0 \\<longleftrightarrow> (\\<forall>x\\<in>set xs. x = 0)\" if \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sum_list' p xs = (0::'a)) = (\\<forall>x\\<in>set xs. x = (0::'a))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sum_list' p xs = (0::'a); x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x = (0::'a)\n 2. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    sum_list' p xs = (0::'a)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sum_list' p xs = (0::'a); x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x = (0::'a)\n 2. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    sum_list' p xs = (0::'a)", "assume x: \"sum_list' p xs = 0\" \"x \\<in> set xs\""], ["proof (state)\nthis:\n  sum_list' p xs = (0::'a)\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sum_list' p xs = (0::'a); x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x = (0::'a)\n 2. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    sum_list' p xs = (0::'a)", "from that"], ["proof (chain)\npicking this:\n  ?x \\<in> set xs \\<Longrightarrow> (0::'a) \\<le> ?x", "have \"0 \\<le> sum_list xs\""], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> (0::'a) \\<le> ?x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> sum_list xs", "by (auto intro!: sum_list_nonneg)"], ["proof (state)\nthis:\n  (0::'a) \\<le> sum_list xs\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sum_list' p xs = (0::'a); x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x = (0::'a)\n 2. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    sum_list' p xs = (0::'a)", "with that x"], ["proof (chain)\npicking this:\n  ?x \\<in> set xs \\<Longrightarrow> (0::'a) \\<le> ?x\n  sum_list' p xs = (0::'a)\n  x \\<in> set xs\n  (0::'a) \\<le> sum_list xs", "have \"sum_list xs = 0\""], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> (0::'a) \\<le> ?x\n  sum_list' p xs = (0::'a)\n  x \\<in> set xs\n  (0::'a) \\<le> sum_list xs\n\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)", "by (metis antisym sum_list_le_sum_list')"], ["proof (state)\nthis:\n  sum_list xs = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sum_list' p xs = (0::'a); x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x = (0::'a)\n 2. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    sum_list' p xs = (0::'a)", "then"], ["proof (chain)\npicking this:\n  sum_list xs = (0::'a)", "have \"(\\<Sum>i<length xs.  xs ! i) = 0\""], ["proof (prove)\nusing this:\n  sum_list xs = (0::'a)\n\ngoal (1 subgoal):\n 1. sum ((!) xs) {..<length xs} = (0::'a)", "by (auto simp: sum_list_sum_nth atLeast0LessThan)"], ["proof (state)\nthis:\n  sum ((!) xs) {..<length xs} = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sum_list' p xs = (0::'a); x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x = (0::'a)\n 2. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    sum_list' p xs = (0::'a)", "then"], ["proof (chain)\npicking this:\n  sum ((!) xs) {..<length xs} = (0::'a)", "show \"x = 0\""], ["proof (prove)\nusing this:\n  sum ((!) xs) {..<length xs} = (0::'a)\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "using x(2) that"], ["proof (prove)\nusing this:\n  sum ((!) xs) {..<length xs} = (0::'a)\n  x \\<in> set xs\n  ?x \\<in> set xs \\<Longrightarrow> (0::'a) \\<le> ?x\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "by (subst (asm) sum_nonneg_eq_0_iff) (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    sum_list' p xs = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    sum_list' p xs = (0::'a)", "show \"\\<forall>x\\<in>set xs. x = 0 \\<Longrightarrow> sum_list' p xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    sum_list' p xs = (0::'a)", "by (induction xs) (auto simp: sum_list'_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n  sum_list' p xs = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma affine_binop'E:\n  assumes deg: \"degree_aforms [X, Y] \\<le> k\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  assumes d: \"abs u \\<le> d\"\n  obtains ek where\n    \"a * aform_val e X + b * aform_val e Y + c + u = aform_val (e(k:=ek)) (affine_binop' p X Y a b c d k)\"\n    \"ek \\<in> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"a * aform_val e X + b * aform_val e Y + c + u =\n    (a * fst X + b * fst Y + c) + pdevs_val e (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) + u\"\n    (is \"_ = ?c + pdevs_val _ ?ps + _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * aform_val e X + b * aform_val e Y + c + u =\n    a * fst X + b * fst Y + c +\n    pdevs_val e\n     (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) +\n    u", "by (auto simp: aform_val_def algebra_simps)"], ["proof (state)\nthis:\n  a * aform_val e X + b * aform_val e Y + c + u =\n  a * fst X + b * fst Y + c +\n  pdevs_val e\n   (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) +\n  u\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from trunc_bound_euclE[of p ?c]"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar>\n               \\<le> snd (trunc_bound_eucl p (a * fst X + b * fst Y + c));\n       fst (trunc_bound_eucl p (a * fst X + b * fst Y + c)) =\n       a * fst X + b * fst Y + c + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain ec where ec: \"abs ec \\<le> snd (trunc_bound_eucl p ?c)\"\n    \"fst (trunc_bound_eucl p ?c) - ec = ?c\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar>\n               \\<le> snd (trunc_bound_eucl p (a * fst X + b * fst Y + c));\n       fst (trunc_bound_eucl p (a * fst X + b * fst Y + c)) =\n       a * fst X + b * fst Y + c + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ec.\n        \\<lbrakk>\\<bar>ec\\<bar>\n                 \\<le> snd (trunc_bound_eucl p (a * fst X + b * fst Y + c));\n         fst (trunc_bound_eucl p (a * fst X + b * fst Y + c)) - ec =\n         a * fst X + b * fst Y + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  \\<bar>ec\\<bar> \\<le> snd (trunc_bound_eucl p (a * fst X + b * fst Y + c))\n  fst (trunc_bound_eucl p (a * fst X + b * fst Y + c)) - ec =\n  a * fst X + b * fst Y + c\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<bar>ec\\<bar> \\<le> snd (trunc_bound_eucl p (a * fst X + b * fst Y + c))\n  fst (trunc_bound_eucl p (a * fst X + b * fst Y + c)) - ec =\n  a * fst X + b * fst Y + c\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from trunc_bound_pdevsE[OF e, of p ?ps]"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar>\n               \\<le> snd (trunc_bound_pdevs p\n                           (add_pdevs (scaleR_pdevs a (snd X))\n                             (scaleR_pdevs b (snd Y))));\n       pdevs_val e\n        (fst (trunc_bound_pdevs p\n               (add_pdevs (scaleR_pdevs a (snd X))\n                 (scaleR_pdevs b (snd Y))))) =\n       pdevs_val e\n        (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) +\n       err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain eps where eps: \"\\<bar>eps\\<bar> \\<le> snd (trunc_bound_pdevs p ?ps)\"\n    \"pdevs_val e (fst (trunc_bound_pdevs p ?ps)) - eps = pdevs_val e ?ps\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar>\n               \\<le> snd (trunc_bound_pdevs p\n                           (add_pdevs (scaleR_pdevs a (snd X))\n                             (scaleR_pdevs b (snd Y))));\n       pdevs_val e\n        (fst (trunc_bound_pdevs p\n               (add_pdevs (scaleR_pdevs a (snd X))\n                 (scaleR_pdevs b (snd Y))))) =\n       pdevs_val e\n        (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) +\n       err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>eps.\n        \\<lbrakk>\\<bar>eps\\<bar>\n                 \\<le> snd (trunc_bound_pdevs p\n                             (add_pdevs (scaleR_pdevs a (snd X))\n                               (scaleR_pdevs b (snd Y))));\n         pdevs_val e\n          (fst (trunc_bound_pdevs p\n                 (add_pdevs (scaleR_pdevs a (snd X))\n                   (scaleR_pdevs b (snd Y))))) -\n         eps =\n         pdevs_val e\n          (add_pdevs (scaleR_pdevs a (snd X))\n            (scaleR_pdevs b (snd Y)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  \\<bar>eps\\<bar>\n  \\<le> snd (trunc_bound_pdevs p\n              (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))\n  pdevs_val e\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))) -\n  eps =\n  pdevs_val e (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<bar>eps\\<bar>\n  \\<le> snd (trunc_bound_pdevs p\n              (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))\n  pdevs_val e\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))) -\n  eps =\n  pdevs_val e (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define ek where \"ek = (u - ec - eps)/\n        sum_list' p [snd (trunc_bound_eucl p ?c), snd (trunc_bound_pdevs p ?ps), d]\""], ["proof (state)\nthis:\n  ek =\n  (u - ec - eps) /\n  sum_list' p\n   [snd (trunc_bound_eucl p (a * fst X + b * fst Y + c)),\n    snd (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))),\n    d]\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"degree (fst (trunc_bound_pdevs p ?ps)) \\<le>\n      degree_aforms [X, Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (fst (trunc_bound_pdevs p\n            (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n    \\<le> degree_aforms [X, Y]", "by (auto simp: trunc_bound_pdevs_def degrees_def intro!: degree_trunc_pdevs_le degree_add_pdevs_le)"], ["proof (state)\nthis:\n  degree\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n  \\<le> degree_aforms [X, Y]\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  degree\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n  \\<le> degree_aforms [X, Y]\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this"], ["proof (chain)\npicking this:\n  degree\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n  \\<le> degree_aforms [X, Y]", "have \"pdevs_apply (fst (trunc_bound_pdevs p ?ps)) k = 0\""], ["proof (prove)\nusing this:\n  degree\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n  \\<le> degree_aforms [X, Y]\n\ngoal (1 subgoal):\n 1. pdevs_apply\n     (fst (trunc_bound_pdevs p\n            (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n     k =\n    0", "using deg order_trans"], ["proof (prove)\nusing this:\n  degree\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n  \\<le> degree_aforms [X, Y]\n  degree_aforms [X, Y] \\<le> k\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. pdevs_apply\n     (fst (trunc_bound_pdevs p\n            (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n     k =\n    0", "by blast"], ["proof (state)\nthis:\n  pdevs_apply\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n   k =\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>ec\\<bar> \\<le> snd (trunc_bound_eucl p (a * fst X + b * fst Y + c))\n  fst (trunc_bound_eucl p (a * fst X + b * fst Y + c)) - ec =\n  a * fst X + b * fst Y + c\n  \\<bar>eps\\<bar>\n  \\<le> snd (trunc_bound_pdevs p\n              (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))\n  pdevs_val e\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))) -\n  eps =\n  pdevs_val e (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))\n  degree\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n  \\<le> degree_aforms [X, Y]\n  pdevs_apply\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n   k =\n  0", "have \"a * aform_val e X + b * aform_val e Y + c + u =\n    aform_val (e(k:=ek)) (affine_binop' p X Y a b c d k)\""], ["proof (prove)\nusing this:\n  \\<bar>ec\\<bar> \\<le> snd (trunc_bound_eucl p (a * fst X + b * fst Y + c))\n  fst (trunc_bound_eucl p (a * fst X + b * fst Y + c)) - ec =\n  a * fst X + b * fst Y + c\n  \\<bar>eps\\<bar>\n  \\<le> snd (trunc_bound_pdevs p\n              (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))\n  pdevs_val e\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))) -\n  eps =\n  pdevs_val e (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))\n  degree\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n  \\<le> degree_aforms [X, Y]\n  pdevs_apply\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n   k =\n  0\n\ngoal (1 subgoal):\n 1. a * aform_val e X + b * aform_val e Y + c + u =\n    aform_val (e(k := ek)) (affine_binop' p X Y a b c d k)", "apply (auto simp: affine_binop'_def algebra_simps aform_val_def split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x1a x2a.\n       \\<lbrakk>\\<bar>ec\\<bar> \\<le> x2; \\<bar>eps\\<bar> \\<le> x2a;\n        pdevs_val e x1a =\n        eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n        degree x1a \\<le> degrees [snd X, snd Y];\n        eucl_truncate_down p\n         (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n        0;\n        trunc_bound_pdevs p\n         (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n        (x1a, x2a);\n        trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n        (c + (ec + (a * fst X + b * fst Y)), x2)\\<rbrakk>\n       \\<Longrightarrow> u + e k * pdevs_apply x1a k =\n                         ec + (eps + ek * sum_list' p [x2, x2a, d])", "subgoal for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x)\\<rbrakk>\n    \\<Longrightarrow> u + e k * pdevs_apply y k =\n                      ec + (eps + ek * sum_list' p [x, z, d])", "apply (cases \"sum_list' p [x, z, d] = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     sum_list' p [x, z, d] = 0\\<rbrakk>\n    \\<Longrightarrow> u + e k * pdevs_apply y k =\n                      ec + (eps + ek * sum_list' p [x, z, d])\n 2. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     sum_list' p [x, z, d] \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> u + e k * pdevs_apply y k =\n                      ec + (eps + ek * sum_list' p [x, z, d])", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     sum_list' p [x, z, d] = 0\\<rbrakk>\n    \\<Longrightarrow> u + e k * pdevs_apply y k =\n                      ec + (eps + ek * sum_list' p [x, z, d])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     sum_list' p [x, z, d] = 0\\<rbrakk>\n    \\<Longrightarrow> u + e k * pdevs_apply y k = ec + eps", "apply (subst (asm) sum_list'_noneg_eq_zero_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n        pdevs_val e y =\n        eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n        degree y \\<le> degrees [snd X, snd Y];\n        eucl_truncate_down p\n         (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n        0;\n        trunc_bound_pdevs p\n         (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n        (y, z);\n        trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n        (c + (ec + (a * fst X + b * fst Y)), x);\n        xa \\<in> set [x, z, d]\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> xa\n 2. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     \\<forall>x\\<in>set [x, z, d]. x = 0\\<rbrakk>\n    \\<Longrightarrow> u + e k * pdevs_apply y k = ec + eps", "using d deg"], ["proof (prove)\nusing this:\n  \\<bar>u\\<bar> \\<le> d\n  degree_aforms [X, Y] \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n        pdevs_val e y =\n        eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n        degree y \\<le> degrees [snd X, snd Y];\n        eucl_truncate_down p\n         (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n        0;\n        trunc_bound_pdevs p\n         (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n        (y, z);\n        trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n        (c + (ec + (a * fst X + b * fst Y)), x);\n        xa \\<in> set [x, z, d]\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> xa\n 2. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     \\<forall>x\\<in>set [x, z, d]. x = 0\\<rbrakk>\n    \\<Longrightarrow> u + e k * pdevs_apply y k = ec + eps", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     sum_list' p [x, z, d] \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> u + e k * pdevs_apply y k =\n                      ec + (eps + ek * sum_list' p [x, z, d])", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     sum_list' p [x, z, d] \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> u + e k * pdevs_apply y k =\n                      ec + (eps + ek * sum_list' p [x, z, d])", "apply (simp add: divide_simps algebra_simps ek_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     sum_list' p [x, z, d] \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> e k = 0 \\<or> pdevs_apply y k = 0", "using \\<open>pdevs_apply (fst (trunc_bound_pdevs p (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))) k = 0\\<close>"], ["proof (prove)\nusing this:\n  pdevs_apply\n   (fst (trunc_bound_pdevs p\n          (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))))\n   k =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bar>ec\\<bar> \\<le> x; \\<bar>eps\\<bar> \\<le> z;\n     pdevs_val e y =\n     eps + (a * pdevs_val e (snd X) + b * pdevs_val e (snd Y));\n     degree y \\<le> degrees [snd X, snd Y];\n     eucl_truncate_down p\n      (a * pdevs_apply (snd X) k + b * pdevs_apply (snd Y) k) =\n     0;\n     trunc_bound_pdevs p\n      (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))) =\n     (y, z);\n     trunc_bound_eucl p (c + (a * fst X + b * fst Y)) =\n     (c + (ec + (a * fst X + b * fst Y)), x);\n     sum_list' p [x, z, d] \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> e k = 0 \\<or> pdevs_apply y k = 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a * aform_val e X + b * aform_val e Y + c + u =\n  aform_val (e(k := ek)) (affine_binop' p X Y a b c d k)\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  a * aform_val e X + b * aform_val e Y + c + u =\n  aform_val (e(k := ek)) (affine_binop' p X Y a b c d k)\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"ek \\<in> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ek \\<in> {- 1..1}", "unfolding ek_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u - ec - eps) /\n    sum_list' p\n     [snd (trunc_bound_eucl p (a * fst X + b * fst Y + c)),\n      snd (trunc_bound_pdevs p\n            (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y)))),\n      d]\n    \\<in> {- 1..1}", "apply (rule divide_atLeastAtMost_1_absI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>u - ec - eps\\<bar>\n    \\<le> \\<bar>sum_list' p\n                 [snd (trunc_bound_eucl p (a * fst X + b * fst Y + c)),\n                  snd (trunc_bound_pdevs p\n                        (add_pdevs (scaleR_pdevs a (snd X))\n                          (scaleR_pdevs b (snd Y)))),\n                  d]\\<bar>", "apply (rule abs_triangle_ineq4[THEN order_trans])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>u - ec\\<bar> + \\<bar>eps\\<bar>\n    \\<le> \\<bar>sum_list' p\n                 [snd (trunc_bound_eucl p (a * fst X + b * fst Y + c)),\n                  snd (trunc_bound_pdevs p\n                        (add_pdevs (scaleR_pdevs a (snd X))\n                          (scaleR_pdevs b (snd Y)))),\n                  d]\\<bar>", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bar>u - ec\\<bar> + \\<bar>eps\\<bar> \\<le> ?y5\n 2. ?y5\n    \\<le> \\<bar>sum_list' p\n                 [snd (trunc_bound_eucl p (a * fst X + b * fst Y + c)),\n                  snd (trunc_bound_pdevs p\n                        (add_pdevs (scaleR_pdevs a (snd X))\n                          (scaleR_pdevs b (snd Y)))),\n                  d]\\<bar>", "apply (rule add_right_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bar>u - ec\\<bar> \\<le> ?b8\n 2. ?b8 + \\<bar>eps\\<bar>\n    \\<le> \\<bar>sum_list' p\n                 [snd (trunc_bound_eucl p (a * fst X + b * fst Y + c)),\n                  snd (trunc_bound_pdevs p\n                        (add_pdevs (scaleR_pdevs a (snd X))\n                          (scaleR_pdevs b (snd Y)))),\n                  d]\\<bar>", "apply (rule abs_triangle_ineq4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>u\\<bar> + \\<bar>ec\\<bar> + \\<bar>eps\\<bar>\n    \\<le> \\<bar>sum_list' p\n                 [snd (trunc_bound_eucl p (a * fst X + b * fst Y + c)),\n                  snd (trunc_bound_pdevs p\n                        (add_pdevs (scaleR_pdevs a (snd X))\n                          (scaleR_pdevs b (snd Y)))),\n                  d]\\<bar>", "using ec(1) eps(1)"], ["proof (prove)\nusing this:\n  \\<bar>ec\\<bar> \\<le> snd (trunc_bound_eucl p (a * fst X + b * fst Y + c))\n  \\<bar>eps\\<bar>\n  \\<le> snd (trunc_bound_pdevs p\n              (add_pdevs (scaleR_pdevs a (snd X)) (scaleR_pdevs b (snd Y))))\n\ngoal (1 subgoal):\n 1. \\<bar>u\\<bar> + \\<bar>ec\\<bar> + \\<bar>eps\\<bar>\n    \\<le> \\<bar>sum_list' p\n                 [snd (trunc_bound_eucl p (a * fst X + b * fst Y + c)),\n                  snd (trunc_bound_pdevs p\n                        (add_pdevs (scaleR_pdevs a (snd X))\n                          (scaleR_pdevs b (snd Y)))),\n                  d]\\<bar>", "by (auto simp: sum_list'_def eucl_truncate_up_real_def add.assoc\n        intro!: order_trans[OF _ abs_ge_self] order_trans[OF _ truncate_up_le] add_mono d )"], ["proof (state)\nthis:\n  ek \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<And>ek.\n        \\<lbrakk>a * aform_val e X + b * aform_val e Y + c + u =\n                 aform_val (e(k := ek)) (affine_binop' p X Y a b c d k);\n         ek \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  a * aform_val e X + b * aform_val e Y + c + u =\n  aform_val (e(k := ek)) (affine_binop' p X Y a b c d k)\n  ek \\<in> {- 1..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  a * aform_val e X + b * aform_val e Y + c + u =\n  aform_val (e(k := ek)) (affine_binop' p X Y a b c d k)\n  ek \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Inf/Sup\\<close>"], ["", "definition \"Inf_aform' p X = eucl_truncate_down p (fst X - tdev' p (snd X))\""], ["", "definition \"Sup_aform' p X = eucl_truncate_up p (fst X + tdev' p (snd X))\""], ["", "lemma Inf_aform':\n  shows \"Inf_aform' p X \\<le> Inf_aform X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_aform' p X \\<le> Inf_aform X", "unfolding Inf_aform_def Inf_aform'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_truncate_down p (fst X - Radius' p X) \\<le> fst X - Radius X", "by (auto intro!: eucl_truncate_down_le add_left_mono tdev')"], ["", "lemma Sup_aform':\n  shows \"Sup_aform X \\<le> Sup_aform' p X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_aform X \\<le> Sup_aform' p X", "unfolding Sup_aform_def Sup_aform'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst X + Radius X \\<le> eucl_truncate_up p (fst X + Radius' p X)", "by (rule eucl_truncate_up_le add_left_mono tdev')+"], ["", "lemma Inf_aform_le_Sup_aform[intro]:\n  \"Inf_aform X \\<le> Sup_aform X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_aform X \\<le> Sup_aform X", "by (simp add: Inf_aform_def Sup_aform_def algebra_simps)"], ["", "lemma Inf_aform'_le_Sup_aform'[intro]:\n  \"Inf_aform' p X \\<le> Sup_aform' p X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_aform' p X \\<le> Sup_aform' p X", "by (metis Inf_aform' Inf_aform_le_Sup_aform Sup_aform' order.trans)"], ["", "definition\n  \"ivls_of_aforms prec = map (\\<lambda>a. Interval' (float_of (Inf_aform' prec a)) (float_of(Sup_aform' prec a)))\""], ["", "lemma\n  assumes \"\\<And>i. e'' i \\<le> 1\"\n  assumes \"\\<And>i. -1 \\<le> e'' i\"\n  shows Inf_aform'_le: \"Inf_aform' p r \\<le> aform_val e'' r\"\n    and Sup_aform'_le: \"aform_val e'' r \\<le> Sup_aform' p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_aform' p r \\<le> aform_val e'' r &&&\n    aform_val e'' r \\<le> Sup_aform' p r", "by (auto intro!: order_trans[OF Inf_aform'] order_trans[OF _ Sup_aform'] Inf_aform Sup_aform\n    simp: Affine_def valuate_def intro!: image_eqI[where x=e''] assms)"], ["", "lemma InfSup_aform'_in_float[intro, simp]:\n  \"Inf_aform' p X \\<in> float\" \"Sup_aform' p X \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_aform' p X \\<in> float &&& Sup_aform' p X \\<in> float", "by (auto simp: Inf_aform'_def eucl_truncate_down_real_def\n      Sup_aform'_def eucl_truncate_up_real_def)"], ["", "theorem ivls_of_aforms: \"xs \\<in> Joints XS \\<Longrightarrow> bounded_by xs (ivls_of_aforms prec XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> Joints XS \\<Longrightarrow>\n    bounded_by xs (ivls_of_aforms prec XS)", "by (auto simp: bounded_by_def ivls_of_aforms_def Affine_def valuate_def Pi_iff set_of_eq\n      intro!: Inf_aform'_le Sup_aform'_le\n      dest!: nth_in_AffineI split: Interval'_splits)"], ["", "definition \"isFDERIV_aform prec N xs fas AS = isFDERIV_approx prec N xs fas (ivls_of_aforms prec AS)\""], ["", "theorem isFDERIV_aform:\n  assumes \"isFDERIV_aform prec N xs fas AS\"\n  assumes \"vs \\<in> Joints AS\"\n  shows \"isFDERIV N xs fas vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFDERIV N xs fas vs", "apply (rule isFDERIV_approx)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bounded_by vs ?VS\n 2. isFDERIV_approx ?prec N xs fas ?VS", "apply (rule ivls_of_aforms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vs \\<in> Joints ?XS3\n 2. isFDERIV_approx ?prec N xs fas (ivls_of_aforms ?prec3 ?XS3)", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. isFDERIV_approx ?prec N xs fas (ivls_of_aforms ?prec3 AS)", "apply (rule assms[unfolded isFDERIV_aform_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"env_len env l = (\\<forall>xs \\<in> env. length xs = l)\""], ["", "lemma env_len_takeI: \"env_len xs d1 \\<Longrightarrow> d1 \\<ge> d \\<Longrightarrow> env_len (take d ` xs) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>env_len xs d1; d \\<le> d1\\<rbrakk>\n    \\<Longrightarrow> env_len (take d ` xs) d", "by (auto simp: env_len_def)"], ["", "subsection \\<open>Min Range approximation\\<close>"], ["", "lemma\n  linear_lower:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> f' x \\<le> u\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f b + u * (x - b) \\<le> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b + u * (x - b) \\<le> f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f b + u * (x - b) \\<le> f x", "from assms(2-)\n    mvt_very_simple[of x b f \"\\<lambda>x. (*) (f' x)\",\n      rule_format,\n      OF _ has_derivative_subset[OF assms(1)[simplified has_field_derivative_def]]]"], ["proof (chain)\npicking this:\n  ?x \\<in> {a..b} \\<Longrightarrow> f' ?x \\<le> u\n  x \\<in> {a..b}\n  \\<lbrakk>x \\<le> b;\n   \\<And>xa.\n      \\<lbrakk>x \\<le> xa; xa \\<le> b\\<rbrakk>\n      \\<Longrightarrow> xa \\<in> {a..b};\n   \\<And>xa.\n      \\<lbrakk>x \\<le> xa; xa \\<le> b\\<rbrakk>\n      \\<Longrightarrow> {x..b} \\<subseteq> {a..b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa\\<in>{x..b}. f b - f x = f' xa * (b - x)", "obtain y where \"y \\<in> {x .. b}\"  \"f b - f x = (b - x) * f' y\""], ["proof (prove)\nusing this:\n  ?x \\<in> {a..b} \\<Longrightarrow> f' ?x \\<le> u\n  x \\<in> {a..b}\n  \\<lbrakk>x \\<le> b;\n   \\<And>xa.\n      \\<lbrakk>x \\<le> xa; xa \\<le> b\\<rbrakk>\n      \\<Longrightarrow> xa \\<in> {a..b};\n   \\<And>xa.\n      \\<lbrakk>x \\<le> xa; xa \\<le> b\\<rbrakk>\n      \\<Longrightarrow> {x..b} \\<subseteq> {a..b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa\\<in>{x..b}. f b - f x = f' xa * (b - x)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> {x..b}; f b - f x = (b - x) * f' y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Bex_def ac_simps)"], ["proof (state)\nthis:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n\ngoal (1 subgoal):\n 1. f b + u * (x - b) \\<le> f x", "moreover"], ["proof (state)\nthis:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n\ngoal (1 subgoal):\n 1. f b + u * (x - b) \\<le> f x", "hence \"f' y \\<le> u\""], ["proof (prove)\nusing this:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n\ngoal (1 subgoal):\n 1. f' y \\<le> u", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n  ?x \\<in> {a..b} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x within {a..b})\n  ?x \\<in> {a..b} \\<Longrightarrow> f' ?x \\<le> u\n  x \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. f' y \\<le> u", "by auto"], ["proof (state)\nthis:\n  f' y \\<le> u\n\ngoal (1 subgoal):\n 1. f b + u * (x - b) \\<le> f x", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n  f' y \\<le> u", "have \"f b - f x \\<le> (b - x) * u\""], ["proof (prove)\nusing this:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n  f' y \\<le> u\n\ngoal (1 subgoal):\n 1. f b - f x \\<le> (b - x) * u", "by (auto intro!: mult_left_mono)"], ["proof (state)\nthis:\n  f b - f x \\<le> (b - x) * u\n\ngoal (1 subgoal):\n 1. f b + u * (x - b) \\<le> f x", "thus ?thesis"], ["proof (prove)\nusing this:\n  f b - f x \\<le> (b - x) * u\n\ngoal (1 subgoal):\n 1. f b + u * (x - b) \\<le> f x", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  f b + u * (x - b) \\<le> f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  linear_lower2:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> l \\<le> f' x\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f x \\<ge> f a + l * (x - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a + l * (x - a) \\<le> f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f a + l * (x - a) \\<le> f x", "from assms(2-)\n    mvt_very_simple[of a x f \"\\<lambda>x. (*) (f' x)\",\n      rule_format,\n      OF _ has_derivative_subset[OF assms(1)[simplified has_field_derivative_def]]]"], ["proof (chain)\npicking this:\n  ?x \\<in> {a..b} \\<Longrightarrow> l \\<le> f' ?x\n  x \\<in> {a..b}\n  \\<lbrakk>a \\<le> x;\n   \\<And>xa.\n      \\<lbrakk>a \\<le> xa; xa \\<le> x\\<rbrakk>\n      \\<Longrightarrow> xa \\<in> {a..b};\n   \\<And>xa.\n      \\<lbrakk>a \\<le> xa; xa \\<le> x\\<rbrakk>\n      \\<Longrightarrow> {a..x} \\<subseteq> {a..b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa\\<in>{a..x}. f x - f a = f' xa * (x - a)", "obtain y where \"y \\<in> {a .. x}\"  \"f x - f a = (x - a) * f' y\""], ["proof (prove)\nusing this:\n  ?x \\<in> {a..b} \\<Longrightarrow> l \\<le> f' ?x\n  x \\<in> {a..b}\n  \\<lbrakk>a \\<le> x;\n   \\<And>xa.\n      \\<lbrakk>a \\<le> xa; xa \\<le> x\\<rbrakk>\n      \\<Longrightarrow> xa \\<in> {a..b};\n   \\<And>xa.\n      \\<lbrakk>a \\<le> xa; xa \\<le> x\\<rbrakk>\n      \\<Longrightarrow> {a..x} \\<subseteq> {a..b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa\\<in>{a..x}. f x - f a = f' xa * (x - a)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> {a..x}; f x - f a = (x - a) * f' y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Bex_def ac_simps)"], ["proof (state)\nthis:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n\ngoal (1 subgoal):\n 1. f a + l * (x - a) \\<le> f x", "moreover"], ["proof (state)\nthis:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n\ngoal (1 subgoal):\n 1. f a + l * (x - a) \\<le> f x", "hence \"l \\<le> f' y\""], ["proof (prove)\nusing this:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n\ngoal (1 subgoal):\n 1. l \\<le> f' y", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n  ?x \\<in> {a..b} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x within {a..b})\n  ?x \\<in> {a..b} \\<Longrightarrow> l \\<le> f' ?x\n  x \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. l \\<le> f' y", "by auto"], ["proof (state)\nthis:\n  l \\<le> f' y\n\ngoal (1 subgoal):\n 1. f a + l * (x - a) \\<le> f x", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n  l \\<le> f' y", "have \"(x - a) * l \\<le> f x - f a\""], ["proof (prove)\nusing this:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n  l \\<le> f' y\n\ngoal (1 subgoal):\n 1. (x - a) * l \\<le> f x - f a", "by (auto intro!: mult_left_mono)"], ["proof (state)\nthis:\n  (x - a) * l \\<le> f x - f a\n\ngoal (1 subgoal):\n 1. f a + l * (x - a) \\<le> f x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x - a) * l \\<le> f x - f a\n\ngoal (1 subgoal):\n 1. f a + l * (x - a) \\<le> f x", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  f a + l * (x - a) \\<le> f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  linear_upper:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> f' x \\<le> u\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f x \\<le> f a + u * (x - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> f a + u * (x - a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<le> f a + u * (x - a)", "from assms(2-)\n    mvt_very_simple[of a x f \"\\<lambda>x. (*) (f' x)\",\n      rule_format,\n      OF _ has_derivative_subset[OF assms(1)[simplified has_field_derivative_def]]]"], ["proof (chain)\npicking this:\n  ?x \\<in> {a..b} \\<Longrightarrow> f' ?x \\<le> u\n  x \\<in> {a..b}\n  \\<lbrakk>a \\<le> x;\n   \\<And>xa.\n      \\<lbrakk>a \\<le> xa; xa \\<le> x\\<rbrakk>\n      \\<Longrightarrow> xa \\<in> {a..b};\n   \\<And>xa.\n      \\<lbrakk>a \\<le> xa; xa \\<le> x\\<rbrakk>\n      \\<Longrightarrow> {a..x} \\<subseteq> {a..b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa\\<in>{a..x}. f x - f a = f' xa * (x - a)", "obtain y where \"y \\<in> {a .. x}\"  \"f x - f a = (x - a) * f' y\""], ["proof (prove)\nusing this:\n  ?x \\<in> {a..b} \\<Longrightarrow> f' ?x \\<le> u\n  x \\<in> {a..b}\n  \\<lbrakk>a \\<le> x;\n   \\<And>xa.\n      \\<lbrakk>a \\<le> xa; xa \\<le> x\\<rbrakk>\n      \\<Longrightarrow> xa \\<in> {a..b};\n   \\<And>xa.\n      \\<lbrakk>a \\<le> xa; xa \\<le> x\\<rbrakk>\n      \\<Longrightarrow> {a..x} \\<subseteq> {a..b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa\\<in>{a..x}. f x - f a = f' xa * (x - a)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> {a..x}; f x - f a = (x - a) * f' y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Bex_def ac_simps)"], ["proof (state)\nthis:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n\ngoal (1 subgoal):\n 1. f x \\<le> f a + u * (x - a)", "moreover"], ["proof (state)\nthis:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n\ngoal (1 subgoal):\n 1. f x \\<le> f a + u * (x - a)", "hence \"f' y \\<le> u\""], ["proof (prove)\nusing this:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n\ngoal (1 subgoal):\n 1. f' y \\<le> u", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n  ?x \\<in> {a..b} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x within {a..b})\n  ?x \\<in> {a..b} \\<Longrightarrow> f' ?x \\<le> u\n  x \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. f' y \\<le> u", "by auto"], ["proof (state)\nthis:\n  f' y \\<le> u\n\ngoal (1 subgoal):\n 1. f x \\<le> f a + u * (x - a)", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n  f' y \\<le> u", "have \"(x - a) * u \\<ge> f x - f a\""], ["proof (prove)\nusing this:\n  y \\<in> {a..x}\n  f x - f a = (x - a) * f' y\n  f' y \\<le> u\n\ngoal (1 subgoal):\n 1. f x - f a \\<le> (x - a) * u", "by (auto intro!: mult_left_mono)"], ["proof (state)\nthis:\n  f x - f a \\<le> (x - a) * u\n\ngoal (1 subgoal):\n 1. f x \\<le> f a + u * (x - a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f x - f a \\<le> (x - a) * u\n\ngoal (1 subgoal):\n 1. f x \\<le> f a + u * (x - a)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  f x \\<le> f a + u * (x - a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  linear_upper2:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> l \\<le> f' x\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f x \\<le> f b + l * (x - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> f b + l * (x - b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<le> f b + l * (x - b)", "from assms(2-)\n    mvt_very_simple[of x b f \"\\<lambda>x. (*) (f' x)\",\n      rule_format,\n      OF _ has_derivative_subset[OF assms(1)[simplified has_field_derivative_def]]]"], ["proof (chain)\npicking this:\n  ?x \\<in> {a..b} \\<Longrightarrow> l \\<le> f' ?x\n  x \\<in> {a..b}\n  \\<lbrakk>x \\<le> b;\n   \\<And>xa.\n      \\<lbrakk>x \\<le> xa; xa \\<le> b\\<rbrakk>\n      \\<Longrightarrow> xa \\<in> {a..b};\n   \\<And>xa.\n      \\<lbrakk>x \\<le> xa; xa \\<le> b\\<rbrakk>\n      \\<Longrightarrow> {x..b} \\<subseteq> {a..b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa\\<in>{x..b}. f b - f x = f' xa * (b - x)", "obtain y where \"y \\<in> {x .. b}\"  \"f b - f x = (b - x) * f' y\""], ["proof (prove)\nusing this:\n  ?x \\<in> {a..b} \\<Longrightarrow> l \\<le> f' ?x\n  x \\<in> {a..b}\n  \\<lbrakk>x \\<le> b;\n   \\<And>xa.\n      \\<lbrakk>x \\<le> xa; xa \\<le> b\\<rbrakk>\n      \\<Longrightarrow> xa \\<in> {a..b};\n   \\<And>xa.\n      \\<lbrakk>x \\<le> xa; xa \\<le> b\\<rbrakk>\n      \\<Longrightarrow> {x..b} \\<subseteq> {a..b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa\\<in>{x..b}. f b - f x = f' xa * (b - x)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> {x..b}; f b - f x = (b - x) * f' y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Bex_def ac_simps)"], ["proof (state)\nthis:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n\ngoal (1 subgoal):\n 1. f x \\<le> f b + l * (x - b)", "moreover"], ["proof (state)\nthis:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n\ngoal (1 subgoal):\n 1. f x \\<le> f b + l * (x - b)", "hence \"l \\<le> f' y\""], ["proof (prove)\nusing this:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n\ngoal (1 subgoal):\n 1. l \\<le> f' y", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n  ?x \\<in> {a..b} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x within {a..b})\n  ?x \\<in> {a..b} \\<Longrightarrow> l \\<le> f' ?x\n  x \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. l \\<le> f' y", "by auto"], ["proof (state)\nthis:\n  l \\<le> f' y\n\ngoal (1 subgoal):\n 1. f x \\<le> f b + l * (x - b)", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n  l \\<le> f' y", "have \"f b - f x \\<ge> (b - x) * l\""], ["proof (prove)\nusing this:\n  y \\<in> {x..b}\n  f b - f x = (b - x) * f' y\n  l \\<le> f' y\n\ngoal (1 subgoal):\n 1. (b - x) * l \\<le> f b - f x", "by (auto intro!: mult_left_mono)"], ["proof (state)\nthis:\n  (b - x) * l \\<le> f b - f x\n\ngoal (1 subgoal):\n 1. f x \\<le> f b + l * (x - b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (b - x) * l \\<le> f b - f x\n\ngoal (1 subgoal):\n 1. f x \\<le> f b + l * (x - b)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  f x \\<le> f b + l * (x - b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_enclosure:\n  fixes x::real\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (f has_field_derivative f' x) (at x within {a .. b})\"\n  assumes \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> f' x \\<le> u\"\n  assumes \"x \\<in> {a .. b}\"\n  shows \"f x \\<in> {f b + u * (x - b) .. f a + u * (x - a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in> {f b + u * (x - b)..f a + u * (x - a)}", "using linear_lower[OF assms] linear_upper[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> {a..b} \\<Longrightarrow> x \\<in> {a..b};\n   \\<And>x. x \\<in> {a..b} \\<Longrightarrow> x \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> f b + u * (x - b) \\<le> f x\n  \\<lbrakk>\\<And>x. x \\<in> {a..b} \\<Longrightarrow> x \\<in> {a..b};\n   \\<And>x. x \\<in> {a..b} \\<Longrightarrow> x \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> f x \\<le> f a + u * (x - a)\n\ngoal (1 subgoal):\n 1. f x \\<in> {f b + u * (x - b)..f a + u * (x - a)}", "by auto"], ["", "definition \"mid_err ivl = ((lower ivl + upper ivl::float)/2, (upper ivl - lower ivl)/2)\""], ["", "lemma degree_aform_uminus_aform[simp]: \"degree_aform (uminus_aform X) = degree_aform X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform (uminus_aform X) = degree_aform X", "by (auto simp: uminus_aform_def)"], ["", "subsubsection \\<open>Addition\\<close>"], ["", "definition add_aform::\"'a::real_vector aform \\<Rightarrow> 'a aform \\<Rightarrow> 'a aform\"\n  where \"add_aform x y = (fst x + fst y, add_pdevs (snd x) (snd y))\""], ["", "lemma aform_val_add_aform:\n  shows \"aform_val e (add_aform X Y) = aform_val e X + aform_val e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (add_aform X Y) = aform_val e X + aform_val e Y", "by (auto simp: add_aform_def aform_val_def)"], ["", "type_synonym aform_err = \"real aform \\<times> real\""], ["", "definition add_aform'::\"nat \\<Rightarrow> aform_err \\<Rightarrow> aform_err \\<Rightarrow> aform_err\"\n  where \"add_aform' p x y =\n    (let\n      z0 = trunc_bound_eucl p (fst (fst x) + fst (fst y));\n      z = trunc_bound_pdevs p (add_pdevs (snd (fst x)) (snd (fst y)))\n      in ((fst z0, fst z), (sum_list' p [snd z0, snd z, abs (snd x), abs (snd y)])))\""], ["", "abbreviation degree_aform_err::\"aform_err \\<Rightarrow> nat\"\n  where \"degree_aform_err X \\<equiv> degree_aform (fst X)\""], ["", "lemma degree_aform_err_add_aform':\n  assumes \"degree_aform_err x \\<le> n\"\n  assumes \"degree_aform_err y \\<le> n\"\n  shows \"degree_aform_err (add_aform' p x y) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err (add_aform' p x y) \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  degree_aform_err x \\<le> n\n  degree_aform_err y \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err (add_aform' p x y) \\<le> n", "by (auto simp: add_aform'_def Let_def trunc_bound_pdevs_def\n      intro!: degree_pdev_upd_le degree_trunc_pdevs_le degree_add_pdevs_le)"], ["", "definition \"aform_err e Xe = {aform_val e (fst Xe) - snd Xe .. aform_val e (fst Xe) + snd Xe::real}\""], ["", "lemma aform_errI: \"x \\<in> aform_err e Xe\"\n  if \"abs (x - aform_val e (fst Xe)) \\<le> snd Xe\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> aform_err e Xe", "using that"], ["proof (prove)\nusing this:\n  \\<bar>x - aform_val e (fst Xe)\\<bar> \\<le> snd Xe\n\ngoal (1 subgoal):\n 1. x \\<in> aform_err e Xe", "by (auto simp: aform_err_def abs_real_def algebra_simps split: if_splits)"], ["", "lemma add_aform':\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes y: \"y \\<in> aform_err e Y\"\n  shows \"x + y \\<in> aform_err e (add_aform' p X Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<in> aform_err e (add_aform' p X Y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + y \\<in> aform_err e (add_aform' p X Y)", "let ?t1 = \"trunc_bound_eucl p (fst (fst X) + fst (fst Y))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x + y \\<in> aform_err e (add_aform' p X Y)", "from trunc_bound_euclE"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl ?p ?x);\n       fst (trunc_bound_eucl ?p ?x) = ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e1 where abs_e1: \"\\<bar>e1\\<bar> \\<le> snd ?t1\" and e1: \"fst ?t1 = fst (fst X) + fst (fst Y) + e1\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl ?p ?x);\n       fst (trunc_bound_eucl ?p ?x) = ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e1.\n        \\<lbrakk>\\<bar>e1\\<bar>\n                 \\<le> snd (trunc_bound_eucl p (fst (fst X) + fst (fst Y)));\n         fst (trunc_bound_eucl p (fst (fst X) + fst (fst Y))) =\n         fst (fst X) + fst (fst Y) + e1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>e1\\<bar> \\<le> snd (trunc_bound_eucl p (fst (fst X) + fst (fst Y)))\n  fst (trunc_bound_eucl p (fst (fst X) + fst (fst Y))) =\n  fst (fst X) + fst (fst Y) + e1\n\ngoal (1 subgoal):\n 1. x + y \\<in> aform_err e (add_aform' p X Y)", "let ?t2 = \"trunc_bound_pdevs p (add_pdevs (snd (fst X)) (snd (fst Y)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x + y \\<in> aform_err e (add_aform' p X Y)", "from trunc_bound_pdevsE[OF e, of p \"add_pdevs (snd (fst X)) (snd (fst Y))\"]"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar>\n               \\<le> snd (trunc_bound_pdevs p\n                           (add_pdevs (snd (fst X)) (snd (fst Y))));\n       pdevs_val e\n        (fst (trunc_bound_pdevs p\n               (add_pdevs (snd (fst X)) (snd (fst Y))))) =\n       pdevs_val e (add_pdevs (snd (fst X)) (snd (fst Y))) + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e2 where abs_e2: \"\\<bar>e2\\<bar> \\<le> snd (?t2)\"\n    and e2: \"pdevs_val e (fst ?t2) = pdevs_val e (add_pdevs (snd (fst X)) (snd (fst Y))) + e2\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar>\n               \\<le> snd (trunc_bound_pdevs p\n                           (add_pdevs (snd (fst X)) (snd (fst Y))));\n       pdevs_val e\n        (fst (trunc_bound_pdevs p\n               (add_pdevs (snd (fst X)) (snd (fst Y))))) =\n       pdevs_val e (add_pdevs (snd (fst X)) (snd (fst Y))) + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e2.\n        \\<lbrakk>\\<bar>e2\\<bar>\n                 \\<le> snd (trunc_bound_pdevs p\n                             (add_pdevs (snd (fst X)) (snd (fst Y))));\n         pdevs_val e\n          (fst (trunc_bound_pdevs p\n                 (add_pdevs (snd (fst X)) (snd (fst Y))))) =\n         pdevs_val e (add_pdevs (snd (fst X)) (snd (fst Y))) + e2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>e2\\<bar>\n  \\<le> snd (trunc_bound_pdevs p (add_pdevs (snd (fst X)) (snd (fst Y))))\n  pdevs_val e\n   (fst (trunc_bound_pdevs p (add_pdevs (snd (fst X)) (snd (fst Y))))) =\n  pdevs_val e (add_pdevs (snd (fst X)) (snd (fst Y))) + e2\n\ngoal (1 subgoal):\n 1. x + y \\<in> aform_err e (add_aform' p X Y)", "have e_le: \"\\<bar>e1 + e2 + snd X + snd Y\\<bar> \\<le> snd (add_aform' p (X) Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>e1 + e2 + snd X + snd Y\\<bar> \\<le> snd (add_aform' p X Y)", "apply (auto simp: add_aform'_def Let_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>e1 + e2 + snd X + snd Y\\<bar>\n    \\<le> sum_list' p\n           [snd (trunc_bound_eucl p (fst (fst X) + fst (fst Y))),\n            snd (trunc_bound_pdevs p\n                  (add_pdevs (snd (fst X)) (snd (fst Y)))),\n            \\<bar>snd X\\<bar>, \\<bar>snd Y\\<bar>]", "apply (rule sum_list'_sum_list_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>e1 + e2 + snd X + snd Y\\<bar>\n    \\<le> sum_list\n           [snd (trunc_bound_eucl p (fst (fst X) + fst (fst Y))),\n            snd (trunc_bound_pdevs p\n                  (add_pdevs (snd (fst X)) (snd (fst Y)))),\n            \\<bar>snd X\\<bar>, \\<bar>snd Y\\<bar>]", "apply (simp add: add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>e1 + (e2 + (snd X + snd Y))\\<bar>\n    \\<le> snd (trunc_bound_eucl p (fst (fst X) + fst (fst Y))) +\n          (snd (trunc_bound_pdevs p\n                 (add_pdevs (snd (fst X)) (snd (fst Y)))) +\n           (\\<bar>snd X\\<bar> + \\<bar>snd Y\\<bar>))", "by (intro order.trans[OF abs_triangle_ineq] add_mono abs_e1 abs_e2 order_refl)"], ["proof (state)\nthis:\n  \\<bar>e1 + e2 + snd X + snd Y\\<bar> \\<le> snd (add_aform' p X Y)\n\ngoal (1 subgoal):\n 1. x + y \\<in> aform_err e (add_aform' p X Y)", "then"], ["proof (chain)\npicking this:\n  \\<bar>e1 + e2 + snd X + snd Y\\<bar> \\<le> snd (add_aform' p X Y)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>e1 + e2 + snd X + snd Y\\<bar> \\<le> snd (add_aform' p X Y)\n\ngoal (1 subgoal):\n 1. x + y \\<in> aform_err e (add_aform' p X Y)", "apply (intro aform_errI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>e1 + e2 + snd X + snd Y\\<bar>\n    \\<le> snd (add_aform' p X Y) \\<Longrightarrow>\n    \\<bar>x + y - aform_val e (fst (add_aform' p X Y))\\<bar>\n    \\<le> snd (add_aform' p X Y)", "using x y abs_e1 abs_e2"], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X\n  y \\<in> aform_err e Y\n  \\<bar>e1\\<bar> \\<le> snd (trunc_bound_eucl p (fst (fst X) + fst (fst Y)))\n  \\<bar>e2\\<bar>\n  \\<le> snd (trunc_bound_pdevs p (add_pdevs (snd (fst X)) (snd (fst Y))))\n\ngoal (1 subgoal):\n 1. \\<bar>e1 + e2 + snd X + snd Y\\<bar>\n    \\<le> snd (add_aform' p X Y) \\<Longrightarrow>\n    \\<bar>x + y - aform_val e (fst (add_aform' p X Y))\\<bar>\n    \\<le> snd (add_aform' p X Y)", "apply (simp add: aform_val_def aform_err_def add_aform_def add_aform'_def Let_def e1 e2 assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bar>e1 + e2 + snd X + snd Y\\<bar>\n             \\<le> sum_list' p\n                    [snd (trunc_bound_eucl p (fst (fst X) + fst (fst Y))),\n                     snd (trunc_bound_pdevs p\n                           (add_pdevs (snd (fst X)) (snd (fst Y)))),\n                     snd X, snd Y];\n     fst (fst X) + pdevs_val e (snd (fst X)) - snd X \\<le> x \\<and>\n     x \\<le> fst (fst X) + pdevs_val e (snd (fst X)) + snd X;\n     fst (fst Y) + pdevs_val e (snd (fst Y)) - snd Y \\<le> y \\<and>\n     y \\<le> fst (fst Y) + pdevs_val e (snd (fst Y)) + snd Y;\n     \\<bar>e1\\<bar>\n     \\<le> snd (trunc_bound_eucl p (fst (fst X) + fst (fst Y)));\n     \\<bar>e2\\<bar>\n     \\<le> snd (trunc_bound_pdevs p\n                 (add_pdevs (snd (fst X)) (snd (fst Y))))\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x + y -\n                            (fst (fst X) + fst (fst Y) + e1 +\n                             (pdevs_val e (snd (fst X)) +\n                              pdevs_val e (snd (fst Y)) +\n                              e2))\\<bar>\n                      \\<le> sum_list' p\n                             [snd (trunc_bound_eucl p\n                                    (fst (fst X) + fst (fst Y))),\n                              snd (trunc_bound_pdevs p\n                                    (add_pdevs (snd (fst X))\n(snd (fst Y)))),\n                              snd X, snd Y]", "by (auto intro!: order_trans[OF _ sum_list_le_sum_list'] )"], ["proof (state)\nthis:\n  x + y \\<in> aform_err e (add_aform' p X Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Scaling\\<close>"], ["", "definition aform_scaleR::\"real aform \\<Rightarrow> 'a::real_vector \\<Rightarrow> 'a aform\"\n  where \"aform_scaleR x y = (fst x *\\<^sub>R y, pdevs_scaleR (snd x) y)\""], ["", "lemma aform_val_scaleR_aform[simp]:\n  shows \"aform_val e (aform_scaleR X y) = aform_val e X *\\<^sub>R y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (aform_scaleR X y) = aform_val e X *\\<^sub>R y", "by (auto simp: aform_scaleR_def aform_val_def scaleR_left_distrib)"], ["", "subsubsection \\<open>Multiplication\\<close>"], ["", "lemma aform_val_mult_exact:\n  \"aform_val e x * aform_val e y =\n    fst x * fst y +\n    pdevs_val e (add_pdevs (scaleR_pdevs (fst y) (snd x)) (scaleR_pdevs (fst x) (snd y))) +\n    (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply (snd x) i)*(\\<Sum>i<d. e i *\\<^sub>R pdevs_apply (snd y) i)\"\n   if \"degree (snd x) \\<le> d\" \"degree (snd y) \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e x * aform_val e y =\n    fst x * fst y +\n    pdevs_val e\n     (add_pdevs (scaleR_pdevs (fst y) (snd x))\n       (scaleR_pdevs (fst x) (snd y))) +\n    (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply (snd x) i) *\n    (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply (snd y) i)", "using that"], ["proof (prove)\nusing this:\n  degree_aform x \\<le> d\n  degree_aform y \\<le> d\n\ngoal (1 subgoal):\n 1. aform_val e x * aform_val e y =\n    fst x * fst y +\n    pdevs_val e\n     (add_pdevs (scaleR_pdevs (fst y) (snd x))\n       (scaleR_pdevs (fst x) (snd y))) +\n    (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply (snd x) i) *\n    (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply (snd y) i)", "by (auto simp: pdevs_val_sum_less_degree[where d=d] aform_val_def algebra_simps)"], ["", "lemma sum_times_bound:\\<comment> \\<open>TODO: this gives better bounds for the remainder of multiplication\\<close>\n  \"(\\<Sum>i<d. e i * f i::real) * (\\<Sum>i<d. e i * g i) =\n   (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n   (\\<Sum>(i, j) | i < j \\<and> j < d. (e i * e j) * (f j * g i + f i * g j))\" for d::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "have \"(\\<Sum>i<d. e i * f i)*(\\<Sum>i<d. e i * g i) = (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d}. e i * f i * (e j * g j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d}. e i * f i * (e j * g j))", "unfolding sum_product sum.cartesian_product"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d}. e i * f i * (e j * g j)) =\n    (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d}. e i * f i * (e j * g j))", ".."], ["proof (state)\nthis:\n  (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d}. e i * f i * (e j * g j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d}. e i * f i * (e j * g j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "have \"\\<dots> = (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i = j}. e i * f i * (e j * g j)) +\n    ((\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}. e i * f i * (e j * g j)) +\n    (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). j < i}. e i * f i * (e j * g j)))\"\n    (is \"_ = ?a + (?b + ?c)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d}. e i * f i * (e j * g j)) =\n    (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i = j}.\n       e i * f i * (e j * g j)) +\n    ((\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n        e i * f i * (e j * g j)) +\n     (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). j < i}.\n        e i * f i * (e j * g j)))", "by (subst sum.union_disjoint[symmetric], force, force, force)+ (auto intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d}. e i * f i * (e j * g j)) =\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i = j}.\n     e i * f i * (e j * g j)) +\n  ((\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n      e i * f i * (e j * g j)) +\n   (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). j < i}.\n      e i * f i * (e j * g j)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d}. e i * f i * (e j * g j)) =\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i = j}.\n     e i * f i * (e j * g j)) +\n  ((\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n      e i * f i * (e j * g j)) +\n   (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). j < i}.\n      e i * f i * (e j * g j)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "have \"?c = (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}. e i * f j * (e j * g i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). j < i}.\n       e i * f i * (e j * g j)) =\n    (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n       e i * f j * (e j * g i))", "by (rule sum.reindex_cong[of \"\\<lambda>(x, y). (y, x)\"]) (auto intro!: inj_onI)"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). j < i}.\n     e i * f i * (e j * g j)) =\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * f j * (e j * g i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). j < i}.\n     e i * f i * (e j * g j)) =\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * f j * (e j * g i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "have \"?b + \\<dots> = (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}. (e i * e j) * (f j * g i + f i * g j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n       e i * f i * (e j * g j)) +\n    (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n       e i * f j * (e j * g i)) =\n    (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n       e i * e j * (f j * g i + f i * g j))", "by (auto simp: algebra_simps sum.distrib split_beta')"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * f i * (e j * g j)) +\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * f j * (e j * g i)) =\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * e j * (f j * g i + f i * g j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * f i * (e j * g j)) +\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * f j * (e j * g i)) =\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * e j * (f j * g i + f i * g j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "have \"\\<dots> = (\\<Sum>(i, j) | i < j \\<and> j < d. (e i * e j) * (f j * g i + f i * g j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n       e i * e j * (f j * g i + f i * g j)) =\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "by (rule sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * e j * (f j * g i + f i * g j)) =\n  (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n     e i * e j * (f j * g i + f i * g j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i < j}.\n     e i * e j * (f j * g i + f i * g j)) =\n  (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n     e i * e j * (f j * g i + f i * g j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "have \"?a = (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i = j}.\n       e i * f i * (e j * g j)) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i))", "by (rule sum.reindex_cong[of \"\\<lambda>i. (i, i)\"]) (auto simp: power2_eq_square intro!: inj_onI)"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..<d} \\<times> {..<d} \\<inter> {(i, j). i = j}.\n     e i * f i * (e j * g j)) =\n  (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n  (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n  (\\<Sum> | case  of (i, j) \\<Rightarrow> i < j \\<and> j < d.\n     case  of (i, j) \\<Rightarrow> e i * e j * (f j * g i + f i * g j))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n  (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n  (\\<Sum> | case  of (i, j) \\<Rightarrow> i < j \\<and> j < d.\n     case  of (i, j) \\<Rightarrow> e i * e j * (f j * g i + f i * g j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n    (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n    (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n       e i * e j * (f j * g i + f i * g j))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<d. e i * f i) * (\\<Sum>i<d. e i * g i) =\n  (\\<Sum>i<d. (e i)\\<^sup>2 * (f i * g i)) +\n  (\\<Sum>(i, j)\\<in>{(i, j). i < j \\<and> j < d}.\n     e i * e j * (f j * g i + f i * g j))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mult_aform::\"aform_err \\<Rightarrow> aform_err \\<Rightarrow> aform_err\"\n  where \"mult_aform x y = ((fst (fst x) * fst (fst y),\n    (add_pdevs (scaleR_pdevs (fst (fst y)) (snd (fst x))) (scaleR_pdevs (fst (fst x)) (snd (fst y))))),\n     (tdev (snd (fst x)) * tdev (snd (fst y)) +\n      abs (snd x) * (abs (fst (fst y)) + Radius (fst y)) +\n      abs (snd y) * (abs (fst (fst x)) + Radius (fst x)) + abs (snd x) * abs (snd y)\n     ))\""], ["", "lemma mult_aformE:\n  fixes X Y::\"aform_err\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes y: \"y \\<in> aform_err e Y\"\n  shows \"x * y \\<in> aform_err e (mult_aform X Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform X Y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform X Y)", "define ex where \"ex \\<equiv> x - aform_val e (fst X)\""], ["proof (state)\nthis:\n  ex \\<equiv> x - aform_val e (fst X)\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform X Y)", "define ey where \"ey \\<equiv> y - aform_val e (fst Y)\""], ["proof (state)\nthis:\n  ey \\<equiv> y - aform_val e (fst Y)\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform X Y)", "have [intro, simp]: \"\\<bar>ex\\<bar> \\<le> \\<bar>snd X\\<bar>\" \"\\<bar>ey\\<bar> \\<le> \\<bar>snd Y\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>ex\\<bar> \\<le> \\<bar>snd X\\<bar> &&&\n    \\<bar>ey\\<bar> \\<le> \\<bar>snd Y\\<bar>", "using x y"], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X\n  y \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. \\<bar>ex\\<bar> \\<le> \\<bar>snd X\\<bar> &&&\n    \\<bar>ey\\<bar> \\<le> \\<bar>snd Y\\<bar>", "by (auto simp: ex_def ey_def aform_err_def)"], ["proof (state)\nthis:\n  \\<bar>ex\\<bar> \\<le> \\<bar>snd X\\<bar>\n  \\<bar>ey\\<bar> \\<le> \\<bar>snd Y\\<bar>\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform X Y)", "have \"x * y =\n    fst (fst X) * fst (fst Y) +\n    fst (fst Y) * pdevs_val e (snd (fst X)) +\n    fst (fst X) * pdevs_val e (snd (fst Y)) +\n\n    (pdevs_val e (snd (fst X)) * pdevs_val e (snd (fst Y)) +\n    ex * (fst (fst Y) + pdevs_val e (snd (fst Y))) +\n    ey * (fst (fst X) + pdevs_val e (snd (fst X))) +\n    ex * ey)\"\n    (is \"_ = ?c + ?d + ?e + ?err\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y =\n    fst (fst X) * fst (fst Y) + fst (fst Y) * pdevs_val e (snd (fst X)) +\n    fst (fst X) * pdevs_val e (snd (fst Y)) +\n    (pdevs_val e (snd (fst X)) * pdevs_val e (snd (fst Y)) +\n     ex * (fst (fst Y) + pdevs_val e (snd (fst Y))) +\n     ey * (fst (fst X) + pdevs_val e (snd (fst X))) +\n     ex * ey)", "by (auto simp: ex_def ey_def algebra_simps aform_val_def)"], ["proof (state)\nthis:\n  x * y =\n  fst (fst X) * fst (fst Y) + fst (fst Y) * pdevs_val e (snd (fst X)) +\n  fst (fst X) * pdevs_val e (snd (fst Y)) +\n  (pdevs_val e (snd (fst X)) * pdevs_val e (snd (fst Y)) +\n   ex * (fst (fst Y) + pdevs_val e (snd (fst Y))) +\n   ey * (fst (fst X) + pdevs_val e (snd (fst X))) +\n   ex * ey)\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform X Y)", "have abs_err: \"abs ?err \\<le> snd (mult_aform X Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e (snd (fst X)) * pdevs_val e (snd (fst Y)) +\n          ex * (fst (fst Y) + pdevs_val e (snd (fst Y))) +\n          ey * (fst (fst X) + pdevs_val e (snd (fst X))) +\n          ex * ey\\<bar>\n    \\<le> snd (mult_aform X Y)", "by (auto simp: mult_aform_def abs_mult\n        intro!: abs_triangle_ineq[THEN order_trans] add_mono mult_mono\n          abs_pdevs_val_le_tdev e)"], ["proof (state)\nthis:\n  \\<bar>pdevs_val e (snd (fst X)) * pdevs_val e (snd (fst Y)) +\n        ex * (fst (fst Y) + pdevs_val e (snd (fst Y))) +\n        ey * (fst (fst X) + pdevs_val e (snd (fst X))) +\n        ex * ey\\<bar>\n  \\<le> snd (mult_aform X Y)\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform X Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform X Y)", "apply (auto simp: intro!: aform_errI order_trans[OF _ abs_err])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x * y - aform_val e (fst (mult_aform X Y))\\<bar>\n    \\<le> \\<bar>pdevs_val e (snd (fst X)) * pdevs_val e (snd (fst Y)) +\n                ex * (fst (fst Y) + pdevs_val e (snd (fst Y))) +\n                ey * (fst (fst X) + pdevs_val e (snd (fst X))) +\n                ex * ey\\<bar>", "apply (subst mult_aform_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x * y -\n          aform_val e\n           (fst ((fst (fst X) * fst (fst Y),\n                  add_pdevs (scaleR_pdevs (fst (fst Y)) (snd (fst X)))\n                   (scaleR_pdevs (fst (fst X)) (snd (fst Y)))),\n                 Radius (fst X) * Radius (fst Y) +\n                 \\<bar>snd X\\<bar> *\n                 (\\<bar>fst (fst Y)\\<bar> + Radius (fst Y)) +\n                 \\<bar>snd Y\\<bar> *\n                 (\\<bar>fst (fst X)\\<bar> + Radius (fst X)) +\n                 \\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>))\\<bar>\n    \\<le> \\<bar>pdevs_val e (snd (fst X)) * pdevs_val e (snd (fst Y)) +\n                ex * (fst (fst Y) + pdevs_val e (snd (fst Y))) +\n                ey * (fst (fst X) + pdevs_val e (snd (fst X))) +\n                ex * ey\\<bar>", "apply (auto simp: aform_val_def ex_def ey_def algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x * y \\<in> aform_err e (mult_aform X Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mult_aform'::\"nat \\<Rightarrow> aform_err \\<Rightarrow> aform_err \\<Rightarrow> aform_err\"\n  where \"mult_aform' p x y = (\n    let\n      (fx, sx) = x;\n      (fy, sy) = y;\n      ex = abs sx;\n      ey = abs sy;\n      z0 = trunc_bound_eucl p (fst fx * fst fy);\n      u = trunc_bound_pdevs p (scaleR_pdevs (fst fy) (snd fx));\n      v = trunc_bound_pdevs p (scaleR_pdevs (fst fx) (snd fy));\n      w = trunc_bound_pdevs p (add_pdevs (fst u) (fst v));\n      tx = tdev' p (snd fx);\n      ty = tdev' p (snd fy);\n      l = truncate_up p (tx * ty);\n      ee = truncate_up p (ex * ey);\n      e1 = truncate_up p (ex * truncate_up p (abs (fst fy) + ty));\n      e2 = truncate_up p (ey * truncate_up p (abs (fst fx) + tx))\n    in\n      ((fst z0, (fst w)), (sum_list' p [ee, e1, e2, l, snd z0, snd u, snd v, snd w])))\""], ["", "lemma aform_errE:\n  \"abs (x - aform_val e (fst X)) \\<le> snd X\"\n  if \"x \\<in> aform_err e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X", "using that"], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X\n\ngoal (1 subgoal):\n 1. \\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X", "by (auto simp: aform_err_def)"], ["", "lemma mult_aform'E:\n  fixes X Y::\"aform_err\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes y: \"y \\<in> aform_err e Y\"\n  shows \"x * y \\<in> aform_err e (mult_aform' p X Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?z0 = \"trunc_bound_eucl p (fst (fst X) * fst (fst Y))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "from trunc_bound_euclE"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl ?p ?x);\n       fst (trunc_bound_eucl ?p ?x) = ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e1 where abs_e1: \"\\<bar>e1\\<bar> \\<le> snd ?z0\" and e1: \"fst ?z0 = fst (fst X) * fst (fst Y) + e1\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl ?p ?x);\n       fst (trunc_bound_eucl ?p ?x) = ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e1.\n        \\<lbrakk>\\<bar>e1\\<bar>\n                 \\<le> snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y)));\n         fst (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) =\n         fst (fst X) * fst (fst Y) + e1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>e1\\<bar> \\<le> snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y)))\n  fst (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) =\n  fst (fst X) * fst (fst Y) + e1\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?u = \"trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "from trunc_bound_pdevsE[OF e]"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs ?p ?x);\n       pdevs_val e (fst (trunc_bound_pdevs ?p ?x)) =\n       pdevs_val e ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e2 where abs_e2: \"\\<bar>e2\\<bar> \\<le> snd (?u)\"\n    and e2: \"pdevs_val e (fst ?u) = pdevs_val e (scaleR_pdevs (fst (fst Y)) (snd (fst X))) + e2\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs ?p ?x);\n       pdevs_val e (fst (trunc_bound_pdevs ?p ?x)) =\n       pdevs_val e ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e2.\n        \\<lbrakk>\\<bar>e2\\<bar>\n                 \\<le> snd (trunc_bound_pdevs p\n                             (scaleR_pdevs (fst (fst Y)) (snd (fst X))));\n         pdevs_val e\n          (fst (trunc_bound_pdevs p\n                 (scaleR_pdevs (fst (fst Y)) (snd (fst X))))) =\n         pdevs_val e (scaleR_pdevs (fst (fst Y)) (snd (fst X))) +\n         e2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>e2\\<bar>\n  \\<le> snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X))))\n  pdevs_val e\n   (fst (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X))))) =\n  pdevs_val e (scaleR_pdevs (fst (fst Y)) (snd (fst X))) + e2\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?v = \"trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "from trunc_bound_pdevsE[OF e]"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs ?p ?x);\n       pdevs_val e (fst (trunc_bound_pdevs ?p ?x)) =\n       pdevs_val e ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e3 where abs_e3: \"\\<bar>e3\\<bar> \\<le> snd (?v)\"\n    and e3: \"pdevs_val e (fst ?v) = pdevs_val e (scaleR_pdevs (fst (fst X)) (snd (fst Y))) + e3\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs ?p ?x);\n       pdevs_val e (fst (trunc_bound_pdevs ?p ?x)) =\n       pdevs_val e ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e3.\n        \\<lbrakk>\\<bar>e3\\<bar>\n                 \\<le> snd (trunc_bound_pdevs p\n                             (scaleR_pdevs (fst (fst X)) (snd (fst Y))));\n         pdevs_val e\n          (fst (trunc_bound_pdevs p\n                 (scaleR_pdevs (fst (fst X)) (snd (fst Y))))) =\n         pdevs_val e (scaleR_pdevs (fst (fst X)) (snd (fst Y))) +\n         e3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>e3\\<bar>\n  \\<le> snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y))))\n  pdevs_val e\n   (fst (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y))))) =\n  pdevs_val e (scaleR_pdevs (fst (fst X)) (snd (fst Y))) + e3\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?w = \"trunc_bound_pdevs p (add_pdevs (fst ?u) (fst ?v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "from trunc_bound_pdevsE[OF e]"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs ?p ?x);\n       pdevs_val e (fst (trunc_bound_pdevs ?p ?x)) =\n       pdevs_val e ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e4 where abs_e4: \"\\<bar>e4\\<bar> \\<le> snd (?w)\"\n    and e4: \"pdevs_val e (fst ?w) = pdevs_val e (add_pdevs (fst ?u) (fst ?v)) + e4\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs ?p ?x);\n       pdevs_val e (fst (trunc_bound_pdevs ?p ?x)) =\n       pdevs_val e ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e4.\n        \\<lbrakk>\\<bar>e4\\<bar>\n                 \\<le> snd (trunc_bound_pdevs p\n                             (add_pdevs\n                               (fst (trunc_bound_pdevs p\n(scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                               (fst (trunc_bound_pdevs p\n(scaleR_pdevs (fst (fst X)) (snd (fst Y)))))));\n         pdevs_val e\n          (fst (trunc_bound_pdevs p\n                 (add_pdevs\n                   (fst (trunc_bound_pdevs p\n                          (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                   (fst (trunc_bound_pdevs p\n                          (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))) =\n         pdevs_val e\n          (add_pdevs\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))) +\n         e4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>e4\\<bar>\n  \\<le> snd (trunc_bound_pdevs p\n              (add_pdevs\n                (fst (trunc_bound_pdevs p\n                       (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                (fst (trunc_bound_pdevs p\n                       (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n  pdevs_val e\n   (fst (trunc_bound_pdevs p\n          (add_pdevs\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))) =\n  pdevs_val e\n   (add_pdevs\n     (fst (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n     (fst (trunc_bound_pdevs p\n            (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))) +\n  e4\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?tx = \"tdev' p (snd (fst X))\" and ?ty = \"tdev' p (snd (fst Y))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?l = \"truncate_up p (?tx * ?ty)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?ee = \"truncate_up p (abs (snd X) * abs (snd Y))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?e1 = \"truncate_up p (abs (snd X) * truncate_up p (\\<bar>fst (fst Y)\\<bar> + ?ty))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?e2 = \"truncate_up p (abs (snd Y) * truncate_up p (\\<bar>fst (fst X)\\<bar> + ?tx))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?e0 = \"x * y - fst (fst X) * fst (fst Y) -\n      fst (fst X) * pdevs_val e (snd (fst Y)) -\n      fst (fst Y) * pdevs_val e (snd (fst X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "let ?err = \"?e0 - (e1 + e2  + e3 + e4)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "have \"abs ?err \\<le> abs ?e0 + abs e1 + abs e2 + abs e3 + abs e4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x * y - fst (fst X) * fst (fst Y) -\n          fst (fst X) * pdevs_val e (snd (fst Y)) -\n          fst (fst Y) * pdevs_val e (snd (fst X)) -\n          (e1 + e2 + e3 + e4)\\<bar>\n    \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n                fst (fst X) * pdevs_val e (snd (fst Y)) -\n                fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n          \\<bar>e1\\<bar> +\n          \\<bar>e2\\<bar> +\n          \\<bar>e3\\<bar> +\n          \\<bar>e4\\<bar>", "by arith"], ["proof (state)\nthis:\n  \\<bar>x * y - fst (fst X) * fst (fst Y) -\n        fst (fst X) * pdevs_val e (snd (fst Y)) -\n        fst (fst Y) * pdevs_val e (snd (fst X)) -\n        (e1 + e2 + e3 + e4)\\<bar>\n  \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n              fst (fst X) * pdevs_val e (snd (fst Y)) -\n              fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n        \\<bar>e1\\<bar> +\n        \\<bar>e2\\<bar> +\n        \\<bar>e3\\<bar> +\n        \\<bar>e4\\<bar>\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "also"], ["proof (state)\nthis:\n  \\<bar>x * y - fst (fst X) * fst (fst Y) -\n        fst (fst X) * pdevs_val e (snd (fst Y)) -\n        fst (fst Y) * pdevs_val e (snd (fst X)) -\n        (e1 + e2 + e3 + e4)\\<bar>\n  \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n              fst (fst X) * pdevs_val e (snd (fst Y)) -\n              fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n        \\<bar>e1\\<bar> +\n        \\<bar>e2\\<bar> +\n        \\<bar>e3\\<bar> +\n        \\<bar>e4\\<bar>\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "have \"\\<dots> \\<le> abs ?e0 + snd ?z0 + snd ?u + snd ?v + snd ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x * y - fst (fst X) * fst (fst Y) -\n          fst (fst X) * pdevs_val e (snd (fst Y)) -\n          fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n    \\<bar>e1\\<bar> +\n    \\<bar>e2\\<bar> +\n    \\<bar>e3\\<bar> +\n    \\<bar>e4\\<bar>\n    \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n                fst (fst X) * pdevs_val e (snd (fst Y)) -\n                fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n          snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n          snd (trunc_bound_pdevs p\n                (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n          snd (trunc_bound_pdevs p\n                (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n          snd (trunc_bound_pdevs p\n                (add_pdevs\n                  (fst (trunc_bound_pdevs p\n                         (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                  (fst (trunc_bound_pdevs p\n                         (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))", "unfolding abs_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x * y - fst (fst X) * fst (fst Y) -\n          fst (fst X) * pdevs_val e (snd (fst Y)) -\n          fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n    \\<bar>e1\\<bar> +\n    \\<bar>e2\\<bar> +\n    \\<bar>e3\\<bar> +\n    \\<bar>e4\\<bar>\n    \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n                fst (fst X) * pdevs_val e (snd (fst Y)) -\n                fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n          snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n          snd (trunc_bound_pdevs p\n                (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n          snd (trunc_bound_pdevs p\n                (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n          snd (trunc_bound_pdevs p\n                (add_pdevs\n                  (fst (trunc_bound_pdevs p\n                         (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                  (fst (trunc_bound_pdevs p\n                         (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))", "by (auto intro!: add_mono mult_mono e abs_pdevs_val_le_tdev' abs_ge_zero abs_e1 abs_e2 abs_e3\n      abs_e4 intro: tdev'_le)"], ["proof (state)\nthis:\n  \\<bar>x * y - fst (fst X) * fst (fst Y) -\n        fst (fst X) * pdevs_val e (snd (fst Y)) -\n        fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n  \\<bar>e1\\<bar> +\n  \\<bar>e2\\<bar> +\n  \\<bar>e3\\<bar> +\n  \\<bar>e4\\<bar>\n  \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n              fst (fst X) * pdevs_val e (snd (fst Y)) -\n              fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n        snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n        snd (trunc_bound_pdevs p\n              (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n        snd (trunc_bound_pdevs p\n              (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n        snd (trunc_bound_pdevs p\n              (add_pdevs\n                (fst (trunc_bound_pdevs p\n                       (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                (fst (trunc_bound_pdevs p\n                       (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "also"], ["proof (state)\nthis:\n  \\<bar>x * y - fst (fst X) * fst (fst Y) -\n        fst (fst X) * pdevs_val e (snd (fst Y)) -\n        fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n  \\<bar>e1\\<bar> +\n  \\<bar>e2\\<bar> +\n  \\<bar>e3\\<bar> +\n  \\<bar>e4\\<bar>\n  \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n              fst (fst X) * pdevs_val e (snd (fst Y)) -\n              fst (fst Y) * pdevs_val e (snd (fst X))\\<bar> +\n        snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n        snd (trunc_bound_pdevs p\n              (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n        snd (trunc_bound_pdevs p\n              (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n        snd (trunc_bound_pdevs p\n              (add_pdevs\n                (fst (trunc_bound_pdevs p\n                       (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                (fst (trunc_bound_pdevs p\n                       (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "have asdf: \"snd (mult_aform X Y) \\<le> tdev' p (snd (fst X)) * tdev' p (snd (fst Y)) + ?e1 + ?e2 + ?ee\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mult_aform X Y)\n    \\<le> Radius' p (fst X) * Radius' p (fst Y) +\n          truncate_up p\n           (\\<bar>snd X\\<bar> *\n            truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n          truncate_up p\n           (\\<bar>snd Y\\<bar> *\n            truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n          truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>)", "by (auto simp: mult_aform_def intro!: add_mono mult_mono order_trans[OF _ tdev'] truncate_up_le)"], ["proof (state)\nthis:\n  snd (mult_aform X Y)\n  \\<le> Radius' p (fst X) * Radius' p (fst Y) +\n        truncate_up p\n         (\\<bar>snd X\\<bar> *\n          truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n        truncate_up p\n         (\\<bar>snd Y\\<bar> *\n          truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n        truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>)\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "have \"abs ?e0 \\<le> ?ee + ?e1 + ?e2 + tdev' p (snd (fst X)) * tdev' p (snd (fst Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x * y - fst (fst X) * fst (fst Y) -\n          fst (fst X) * pdevs_val e (snd (fst Y)) -\n          fst (fst Y) * pdevs_val e (snd (fst X))\\<bar>\n    \\<le> truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n          truncate_up p\n           (\\<bar>snd X\\<bar> *\n            truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n          truncate_up p\n           (\\<bar>snd Y\\<bar> *\n            truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n          Radius' p (fst X) * Radius' p (fst Y)", "using mult_aformE[OF e x y, THEN aform_errE, THEN order_trans, OF asdf]"], ["proof (prove)\nusing this:\n  \\<bar>x * y - aform_val e (fst (mult_aform X Y))\\<bar>\n  \\<le> Radius' p (fst X) * Radius' p (fst Y) +\n        truncate_up p\n         (\\<bar>snd X\\<bar> *\n          truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n        truncate_up p\n         (\\<bar>snd Y\\<bar> *\n          truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n        truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>x * y - fst (fst X) * fst (fst Y) -\n          fst (fst X) * pdevs_val e (snd (fst Y)) -\n          fst (fst Y) * pdevs_val e (snd (fst X))\\<bar>\n    \\<le> truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n          truncate_up p\n           (\\<bar>snd X\\<bar> *\n            truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n          truncate_up p\n           (\\<bar>snd Y\\<bar> *\n            truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n          Radius' p (fst X) * Radius' p (fst Y)", "by (simp add: aform_val_def mult_aform_def) arith"], ["proof (state)\nthis:\n  \\<bar>x * y - fst (fst X) * fst (fst Y) -\n        fst (fst X) * pdevs_val e (snd (fst Y)) -\n        fst (fst Y) * pdevs_val e (snd (fst X))\\<bar>\n  \\<le> truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n        truncate_up p\n         (\\<bar>snd X\\<bar> *\n          truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n        truncate_up p\n         (\\<bar>snd Y\\<bar> *\n          truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n        Radius' p (fst X) * Radius' p (fst Y)\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "also"], ["proof (state)\nthis:\n  \\<bar>x * y - fst (fst X) * fst (fst Y) -\n        fst (fst X) * pdevs_val e (snd (fst Y)) -\n        fst (fst Y) * pdevs_val e (snd (fst X))\\<bar>\n  \\<le> truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n        truncate_up p\n         (\\<bar>snd X\\<bar> *\n          truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n        truncate_up p\n         (\\<bar>snd Y\\<bar> *\n          truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n        Radius' p (fst X) * Radius' p (fst Y)\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "have \"tdev' p (snd (fst X)) * tdev' p (snd (fst Y)) \\<le> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Radius' p (fst X) * Radius' p (fst Y)\n    \\<le> truncate_up p (Radius' p (fst X) * Radius' p (fst Y))", "by (auto intro!: truncate_up_le)"], ["proof (state)\nthis:\n  Radius' p (fst X) * Radius' p (fst Y)\n  \\<le> truncate_up p (Radius' p (fst X) * Radius' p (fst Y))\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "also"], ["proof (state)\nthis:\n  Radius' p (fst X) * Radius' p (fst Y)\n  \\<le> truncate_up p (Radius' p (fst X) * Radius' p (fst Y))\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "have \"?ee + ?e1 + ?e2 + ?l + snd ?z0 + snd ?u + snd ?v + snd ?w \\<le>\n      sum_list' p [?ee, ?e1, ?e2, ?l, snd ?z0, snd ?u, snd ?v, snd ?w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n    truncate_up p\n     (\\<bar>snd X\\<bar> *\n      truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n    truncate_up p\n     (\\<bar>snd Y\\<bar> *\n      truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n    truncate_up p (Radius' p (fst X) * Radius' p (fst Y)) +\n    snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n    snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n    snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n    snd (trunc_bound_pdevs p\n          (add_pdevs\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n    \\<le> sum_list' p\n           [truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>),\n            truncate_up p\n             (\\<bar>snd X\\<bar> *\n              truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))),\n            truncate_up p\n             (\\<bar>snd Y\\<bar> *\n              truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))),\n            truncate_up p (Radius' p (fst X) * Radius' p (fst Y)),\n            snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))),\n            snd (trunc_bound_pdevs p\n                  (scaleR_pdevs (fst (fst Y)) (snd (fst X)))),\n            snd (trunc_bound_pdevs p\n                  (scaleR_pdevs (fst (fst X)) (snd (fst Y)))),\n            snd (trunc_bound_pdevs p\n                  (add_pdevs\n                    (fst (trunc_bound_pdevs p\n                           (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                    (fst (trunc_bound_pdevs p\n                           (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))]", "by (rule order_trans[OF _ sum_list_le_sum_list']) simp"], ["proof (state)\nthis:\n  truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n  truncate_up p\n   (\\<bar>snd X\\<bar> *\n    truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n  truncate_up p\n   (\\<bar>snd Y\\<bar> *\n    truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n  truncate_up p (Radius' p (fst X) * Radius' p (fst Y)) +\n  snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n  snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n  snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n  snd (trunc_bound_pdevs p\n        (add_pdevs\n          (fst (trunc_bound_pdevs p\n                 (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n          (fst (trunc_bound_pdevs p\n                 (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n  \\<le> sum_list' p\n         [truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>),\n          truncate_up p\n           (\\<bar>snd X\\<bar> *\n            truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))),\n          truncate_up p\n           (\\<bar>snd Y\\<bar> *\n            truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))),\n          truncate_up p (Radius' p (fst X) * Radius' p (fst Y)),\n          snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))),\n          snd (trunc_bound_pdevs p\n                (scaleR_pdevs (fst (fst Y)) (snd (fst X)))),\n          snd (trunc_bound_pdevs p\n                (scaleR_pdevs (fst (fst X)) (snd (fst Y)))),\n          snd (trunc_bound_pdevs p\n                (add_pdevs\n                  (fst (trunc_bound_pdevs p\n                         (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                  (fst (trunc_bound_pdevs p\n                         (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))]\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "also"], ["proof (state)\nthis:\n  truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n  truncate_up p\n   (\\<bar>snd X\\<bar> *\n    truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n  truncate_up p\n   (\\<bar>snd Y\\<bar> *\n    truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n  truncate_up p (Radius' p (fst X) * Radius' p (fst Y)) +\n  snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n  snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n  snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n  snd (trunc_bound_pdevs p\n        (add_pdevs\n          (fst (trunc_bound_pdevs p\n                 (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n          (fst (trunc_bound_pdevs p\n                 (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n  \\<le> sum_list' p\n         [truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>),\n          truncate_up p\n           (\\<bar>snd X\\<bar> *\n            truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))),\n          truncate_up p\n           (\\<bar>snd Y\\<bar> *\n            truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))),\n          truncate_up p (Radius' p (fst X) * Radius' p (fst Y)),\n          snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))),\n          snd (trunc_bound_pdevs p\n                (scaleR_pdevs (fst (fst Y)) (snd (fst X)))),\n          snd (trunc_bound_pdevs p\n                (scaleR_pdevs (fst (fst X)) (snd (fst Y)))),\n          snd (trunc_bound_pdevs p\n                (add_pdevs\n                  (fst (trunc_bound_pdevs p\n                         (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                  (fst (trunc_bound_pdevs p\n                         (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))]\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "have \"\\<dots> \\<le> (snd (mult_aform' p X Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list' p\n     [truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>),\n      truncate_up p\n       (\\<bar>snd X\\<bar> *\n        truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))),\n      truncate_up p\n       (\\<bar>snd Y\\<bar> *\n        truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))),\n      truncate_up p (Radius' p (fst X) * Radius' p (fst Y)),\n      snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))),\n      snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))),\n      snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y)))),\n      snd (trunc_bound_pdevs p\n            (add_pdevs\n              (fst (trunc_bound_pdevs p\n                     (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n              (fst (trunc_bound_pdevs p\n                     (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))]\n    \\<le> snd (mult_aform' p X Y)", "by (auto simp: mult_aform'_def Let_def assms split: prod.splits)"], ["proof (state)\nthis:\n  sum_list' p\n   [truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>),\n    truncate_up p\n     (\\<bar>snd X\\<bar> *\n      truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))),\n    truncate_up p\n     (\\<bar>snd Y\\<bar> *\n      truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))),\n    truncate_up p (Radius' p (fst X) * Radius' p (fst Y)),\n    snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))),\n    snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))),\n    snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y)))),\n    snd (trunc_bound_pdevs p\n          (add_pdevs\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))]\n  \\<le> snd (mult_aform' p X Y)\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n              snd (trunc_bound_pdevs p\n                    (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n              snd (trunc_bound_pdevs p\n                    (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n              snd (trunc_bound_pdevs p\n                    (add_pdevs\n                      (fst (trunc_bound_pdevs p\n                             (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                      (fst (trunc_bound_pdevs p\n                             (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n              \\<le> y +\n                    snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n                    snd (trunc_bound_pdevs p\n                          (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n                    snd (trunc_bound_pdevs p\n                          (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n                    snd (trunc_bound_pdevs p\n                          (add_pdevs\n                            (fst (trunc_bound_pdevs p\n                                   (scaleR_pdevs (fst (fst Y))\n                                     (snd (fst X)))))\n                            (fst (trunc_bound_pdevs p\n                                   (scaleR_pdevs (fst (fst X))\n                                     (snd (fst Y)))))));\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n      truncate_up p\n       (\\<bar>snd X\\<bar> *\n        truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n      truncate_up p\n       (\\<bar>snd Y\\<bar> *\n        truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n      x +\n      snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n      snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n      snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n      snd (trunc_bound_pdevs p\n            (add_pdevs\n              (fst (trunc_bound_pdevs p\n                     (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n              (fst (trunc_bound_pdevs p\n                     (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n      \\<le> truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n            truncate_up p\n             (\\<bar>snd X\\<bar> *\n              truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n            truncate_up p\n             (\\<bar>snd Y\\<bar> *\n              truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n            y +\n            snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n            snd (trunc_bound_pdevs p\n                  (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n            snd (trunc_bound_pdevs p\n                  (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n            snd (trunc_bound_pdevs p\n                  (add_pdevs\n                    (fst (trunc_bound_pdevs p\n                           (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                    (fst (trunc_bound_pdevs p\n                           (scaleR_pdevs (fst (fst X))\n                             (snd (fst Y)))))))\\<rbrakk>\n  \\<Longrightarrow> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n                          fst (fst X) * pdevs_val e (snd (fst Y)) -\n                          fst (fst Y) * pdevs_val e (snd (fst X)) -\n                          (e1 + e2 + e3 + e4)\\<bar>\n                    \\<le> snd (mult_aform' p X Y)", "have err_le: \"abs ?err \\<le> (snd (mult_aform' p X Y))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n              snd (trunc_bound_pdevs p\n                    (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n              snd (trunc_bound_pdevs p\n                    (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n              snd (trunc_bound_pdevs p\n                    (add_pdevs\n                      (fst (trunc_bound_pdevs p\n                             (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                      (fst (trunc_bound_pdevs p\n                             (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n              \\<le> y +\n                    snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n                    snd (trunc_bound_pdevs p\n                          (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n                    snd (trunc_bound_pdevs p\n                          (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n                    snd (trunc_bound_pdevs p\n                          (add_pdevs\n                            (fst (trunc_bound_pdevs p\n                                   (scaleR_pdevs (fst (fst Y))\n                                     (snd (fst X)))))\n                            (fst (trunc_bound_pdevs p\n                                   (scaleR_pdevs (fst (fst X))\n                                     (snd (fst Y)))))));\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n      truncate_up p\n       (\\<bar>snd X\\<bar> *\n        truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n      truncate_up p\n       (\\<bar>snd Y\\<bar> *\n        truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n      x +\n      snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n      snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n      snd (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n      snd (trunc_bound_pdevs p\n            (add_pdevs\n              (fst (trunc_bound_pdevs p\n                     (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n              (fst (trunc_bound_pdevs p\n                     (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))\n      \\<le> truncate_up p (\\<bar>snd X\\<bar> * \\<bar>snd Y\\<bar>) +\n            truncate_up p\n             (\\<bar>snd X\\<bar> *\n              truncate_up p (\\<bar>fst (fst Y)\\<bar> + Radius' p (fst Y))) +\n            truncate_up p\n             (\\<bar>snd Y\\<bar> *\n              truncate_up p (\\<bar>fst (fst X)\\<bar> + Radius' p (fst X))) +\n            y +\n            snd (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) +\n            snd (trunc_bound_pdevs p\n                  (scaleR_pdevs (fst (fst Y)) (snd (fst X)))) +\n            snd (trunc_bound_pdevs p\n                  (scaleR_pdevs (fst (fst X)) (snd (fst Y)))) +\n            snd (trunc_bound_pdevs p\n                  (add_pdevs\n                    (fst (trunc_bound_pdevs p\n                           (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n                    (fst (trunc_bound_pdevs p\n                           (scaleR_pdevs (fst (fst X))\n                             (snd (fst Y)))))))\\<rbrakk>\n  \\<Longrightarrow> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n                          fst (fst X) * pdevs_val e (snd (fst Y)) -\n                          fst (fst Y) * pdevs_val e (snd (fst X)) -\n                          (e1 + e2 + e3 + e4)\\<bar>\n                    \\<le> snd (mult_aform' p X Y)\n\ngoal (1 subgoal):\n 1. \\<bar>x * y - fst (fst X) * fst (fst Y) -\n          fst (fst X) * pdevs_val e (snd (fst Y)) -\n          fst (fst Y) * pdevs_val e (snd (fst X)) -\n          (e1 + e2 + e3 + e4)\\<bar>\n    \\<le> snd (mult_aform' p X Y)", "by arith"], ["proof (state)\nthis:\n  \\<bar>x * y - fst (fst X) * fst (fst Y) -\n        fst (fst X) * pdevs_val e (snd (fst Y)) -\n        fst (fst Y) * pdevs_val e (snd (fst X)) -\n        (e1 + e2 + e3 + e4)\\<bar>\n  \\<le> snd (mult_aform' p X Y)\n\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<in> aform_err e (mult_aform' p X Y)", "apply (rule aform_errI[OF order_trans[OF _ err_le]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x * y - aform_val e (fst (mult_aform' p X Y))\\<bar>\n    \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n                fst (fst X) * pdevs_val e (snd (fst Y)) -\n                fst (fst Y) * pdevs_val e (snd (fst X)) -\n                (e1 + e2 + e3 + e4)\\<bar>", "apply (subst mult_aform'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x * y -\n          aform_val e\n           (fst (let (fx, sx) = X; (fy, sy) = Y; ex = \\<bar>sx\\<bar>;\n                     ey = \\<bar>sy\\<bar>;\n                     z0 = trunc_bound_eucl p (fst fx * fst fy);\n                     u = trunc_bound_pdevs p\n                          (scaleR_pdevs (fst fy) (snd fx));\n                     v = trunc_bound_pdevs p\n                          (scaleR_pdevs (fst fx) (snd fy));\n                     w = trunc_bound_pdevs p (add_pdevs (fst u) (fst v));\n                     tx = Radius' p fx; ty = Radius' p fy;\n                     l = truncate_up p (tx * ty);\n                     ee = truncate_up p (ex * ey);\n                     e1 = truncate_up p\n                           (ex * truncate_up p (\\<bar>fst fy\\<bar> + ty));\n                     e2 = truncate_up p\n                           (ey * truncate_up p (\\<bar>fst fx\\<bar> + tx))\n                 in ((fst z0, fst w),\n                     sum_list' p\n                      [ee, e1, e2, l, snd z0, snd u, snd v, snd w])))\\<bar>\n    \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n                fst (fst X) * pdevs_val e (snd (fst Y)) -\n                fst (fst Y) * pdevs_val e (snd (fst X)) -\n                (e1 + e2 + e3 + e4)\\<bar>", "using e1 e2 e3 e4"], ["proof (prove)\nusing this:\n  fst (trunc_bound_eucl p (fst (fst X) * fst (fst Y))) =\n  fst (fst X) * fst (fst Y) + e1\n  pdevs_val e\n   (fst (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X))))) =\n  pdevs_val e (scaleR_pdevs (fst (fst Y)) (snd (fst X))) + e2\n  pdevs_val e\n   (fst (trunc_bound_pdevs p (scaleR_pdevs (fst (fst X)) (snd (fst Y))))) =\n  pdevs_val e (scaleR_pdevs (fst (fst X)) (snd (fst Y))) + e3\n  pdevs_val e\n   (fst (trunc_bound_pdevs p\n          (add_pdevs\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n            (fst (trunc_bound_pdevs p\n                   (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))))) =\n  pdevs_val e\n   (add_pdevs\n     (fst (trunc_bound_pdevs p (scaleR_pdevs (fst (fst Y)) (snd (fst X)))))\n     (fst (trunc_bound_pdevs p\n            (scaleR_pdevs (fst (fst X)) (snd (fst Y)))))) +\n  e4\n\ngoal (1 subgoal):\n 1. \\<bar>x * y -\n          aform_val e\n           (fst (let (fx, sx) = X; (fy, sy) = Y; ex = \\<bar>sx\\<bar>;\n                     ey = \\<bar>sy\\<bar>;\n                     z0 = trunc_bound_eucl p (fst fx * fst fy);\n                     u = trunc_bound_pdevs p\n                          (scaleR_pdevs (fst fy) (snd fx));\n                     v = trunc_bound_pdevs p\n                          (scaleR_pdevs (fst fx) (snd fy));\n                     w = trunc_bound_pdevs p (add_pdevs (fst u) (fst v));\n                     tx = Radius' p fx; ty = Radius' p fy;\n                     l = truncate_up p (tx * ty);\n                     ee = truncate_up p (ex * ey);\n                     e1 = truncate_up p\n                           (ex * truncate_up p (\\<bar>fst fy\\<bar> + ty));\n                     e2 = truncate_up p\n                           (ey * truncate_up p (\\<bar>fst fx\\<bar> + tx))\n                 in ((fst z0, fst w),\n                     sum_list' p\n                      [ee, e1, e2, l, snd z0, snd u, snd v, snd w])))\\<bar>\n    \\<le> \\<bar>x * y - fst (fst X) * fst (fst Y) -\n                fst (fst X) * pdevs_val e (snd (fst Y)) -\n                fst (fst Y) * pdevs_val e (snd (fst X)) -\n                (e1 + e2 + e3 + e4)\\<bar>", "apply (auto simp: aform_val_def Let_def assms split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x * y \\<in> aform_err e (mult_aform' p X Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_aform_mult_aform':\n  assumes \"degree_aform_err x \\<le> n\"\n  assumes \"degree_aform_err y \\<le> n\"\n  shows \"degree_aform_err (mult_aform' p x y) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err (mult_aform' p x y) \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  degree_aform_err x \\<le> n\n  degree_aform_err y \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err (mult_aform' p x y) \\<le> n", "by (auto simp: mult_aform'_def Let_def trunc_bound_pdevs_def split: prod.splits\n      intro!: degree_pdev_upd_le degree_trunc_pdevs_le degree_add_pdevs_le)"], ["", "lemma\n  fixes x a b::real\n  assumes \"a > 0\"\n  assumes \"x \\<in> {a ..b}\"\n  assumes \"- inverse (b*b) \\<le> alpha\"\n  shows inverse_linear_lower: \"inverse b + alpha * (x - b) \\<le> inverse x\" (is ?lower)\n    and inverse_linear_upper: \"inverse x \\<le> inverse a + alpha * (x - a)\" (is ?upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse b + alpha * (x - b) \\<le> inverse x &&&\n    inverse x \\<le> inverse a + alpha * (x - a)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. inverse b + alpha * (x - b) \\<le> inverse x\n 2. inverse x \\<le> inverse a + alpha * (x - a)", "have deriv_inv:\n    \"\\<And>x. x \\<in> {a .. b} \\<Longrightarrow> (inverse has_field_derivative - inverse (x*x)) (at x within {a .. b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a..b} \\<Longrightarrow>\n       (inverse has_real_derivative - inverse (x * x)) (at x within {a..b})", "using assms"], ["proof (prove)\nusing this:\n  0 < a\n  x \\<in> {a..b}\n  - inverse (b * b) \\<le> alpha\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a..b} \\<Longrightarrow>\n       (inverse has_real_derivative - inverse (x * x)) (at x within {a..b})", "by (auto intro!: derivative_eq_intros)"], ["proof (state)\nthis:\n  ?x \\<in> {a..b} \\<Longrightarrow>\n  (inverse has_real_derivative - inverse (?x * ?x)) (at ?x within {a..b})\n\ngoal (2 subgoals):\n 1. inverse b + alpha * (x - b) \\<le> inverse x\n 2. inverse x \\<le> inverse a + alpha * (x - a)", "show ?lower"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse b + alpha * (x - b) \\<le> inverse x", "using assms"], ["proof (prove)\nusing this:\n  0 < a\n  x \\<in> {a..b}\n  - inverse (b * b) \\<le> alpha\n\ngoal (1 subgoal):\n 1. inverse b + alpha * (x - b) \\<le> inverse x", "by (intro linear_lower[OF deriv_inv])\n        (auto simp: mult_mono intro!:  order_trans[OF _ assms(3)])"], ["proof (state)\nthis:\n  inverse b + alpha * (x - b) \\<le> inverse x\n\ngoal (1 subgoal):\n 1. inverse x \\<le> inverse a + alpha * (x - a)", "show ?upper"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse x \\<le> inverse a + alpha * (x - a)", "using assms"], ["proof (prove)\nusing this:\n  0 < a\n  x \\<in> {a..b}\n  - inverse (b * b) \\<le> alpha\n\ngoal (1 subgoal):\n 1. inverse x \\<le> inverse a + alpha * (x - a)", "by (intro linear_upper[OF deriv_inv])\n        (auto simp: mult_mono intro!:  order_trans[OF _ assms(3)])"], ["proof (state)\nthis:\n  inverse x \\<le> inverse a + alpha * (x - a)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Inverse\\<close>"], ["", "definition inverse_aform'::\"nat \\<Rightarrow> real aform \\<Rightarrow> real aform \\<times> real\" where\n  \"inverse_aform' p X = (\n    let l = Inf_aform' p X in\n    let u = Sup_aform' p X in\n    let a = min (abs l) (abs u) in\n    let b = max (abs l) (abs u) in\n    let sq = truncate_up p (b * b) in\n    let alpha = - real_divl p 1 sq in\n    let dmax = truncate_up p (real_divr p 1 a - alpha * a) in\n    let dmin = truncate_down p (real_divl p 1 b - alpha * b) in\n    let zeta' = truncate_up p ((dmin + dmax) / 2) in\n    let zeta = if l < 0 then - zeta' else zeta' in\n    let delta = truncate_up p (zeta - dmin) in\n    let res1 = trunc_bound_eucl p (alpha * fst X) in\n    let res2 = trunc_bound_eucl p (fst res1 + zeta) in\n    let zs = trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)) in\n    ((fst res2, fst zs), (sum_list' p [delta, snd res1, snd res2, snd zs])))\""], ["", "lemma inverse_aform'E:\n  fixes X::\"real aform\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes Inf_pos: \"Inf_aform' p X > 0\"\n  assumes \"x = aform_val e X\"\n  shows \"inverse x \\<in> aform_err e (inverse_aform' p X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define l where \"l = Inf_aform' p X\""], ["proof (state)\nthis:\n  l = Inf_aform' p X\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define u where \"u = Sup_aform' p X\""], ["proof (state)\nthis:\n  u = Sup_aform' p X\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define a where \"a = min (abs l) (abs u)\""], ["proof (state)\nthis:\n  a = min \\<bar>l\\<bar> \\<bar>u\\<bar>\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define b where \"b = max (abs l) (abs u)\""], ["proof (state)\nthis:\n  b = max \\<bar>l\\<bar> \\<bar>u\\<bar>\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define sq where \"sq = truncate_up p (b * b)\""], ["proof (state)\nthis:\n  sq = truncate_up p (b * b)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define alpha where \"alpha = - (real_divl p 1 sq)\""], ["proof (state)\nthis:\n  alpha = - real_divl p 1 sq\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define d_max' where \"d_max' = truncate_up p (real_divr p 1 a - alpha * a)\""], ["proof (state)\nthis:\n  d_max' = truncate_up p (real_divr p 1 a - alpha * a)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define d_min' where \"d_min' = truncate_down p (real_divl p 1 b - alpha * b)\""], ["proof (state)\nthis:\n  d_min' = truncate_down p (real_divl p 1 b - alpha * b)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define zeta where \"zeta = truncate_up p ((d_min' + d_max') / 2)\""], ["proof (state)\nthis:\n  zeta = truncate_up p ((d_min' + d_max') / 2)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "define delta where \"delta = truncate_up p (zeta - d_min')\""], ["proof (state)\nthis:\n  delta = truncate_up p (zeta - d_min')\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "note vars = l_def u_def a_def b_def sq_def alpha_def d_max'_def d_min'_def zeta_def delta_def"], ["proof (state)\nthis:\n  l = Inf_aform' p X\n  u = Sup_aform' p X\n  a = min \\<bar>l\\<bar> \\<bar>u\\<bar>\n  b = max \\<bar>l\\<bar> \\<bar>u\\<bar>\n  sq = truncate_up p (b * b)\n  alpha = - real_divl p 1 sq\n  d_max' = truncate_up p (real_divr p 1 a - alpha * a)\n  d_min' = truncate_down p (real_divl p 1 b - alpha * b)\n  zeta = truncate_up p ((d_min' + d_max') / 2)\n  delta = truncate_up p (zeta - d_min')\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "let ?x = \"aform_val e X\""], ["proof (state)\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"0 < l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  0 < Inf_aform' p X\n  x = aform_val e X\n\ngoal (1 subgoal):\n 1. 0 < l", "by (auto simp add: l_def Inf_aform_def)"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"l \\<le> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> u", "by (auto simp: l_def u_def)"], ["proof (state)\nthis:\n  l \\<le> u\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "hence a_def': \"a = l\" and b_def': \"b = u\" and \"0 < a\" \"0 < b\""], ["proof (prove)\nusing this:\n  l \\<le> u\n\ngoal (1 subgoal):\n 1. a = l &&& b = u &&& 0 < a &&& 0 < b", "using \\<open>0 < l\\<close>"], ["proof (prove)\nusing this:\n  l \\<le> u\n  0 < l\n\ngoal (1 subgoal):\n 1. a = l &&& b = u &&& 0 < a &&& 0 < b", "by (simp_all add: a_def b_def)"], ["proof (state)\nthis:\n  a = l\n  b = u\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"0 < ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < aform_val e X", "by (rule less_le_trans[OF Inf_pos order.trans[OF Inf_aform' Inf_aform], OF e])"], ["proof (state)\nthis:\n  0 < aform_val e X\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"a \\<le> ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> aform_val e X", "by (metis order.trans Inf_aform e Inf_aform' a_def' l_def)"], ["proof (state)\nthis:\n  a \\<le> aform_val e X\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"?x \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e X \\<le> b", "by (metis order.trans Sup_aform e Sup_aform' b_def' u_def)"], ["proof (state)\nthis:\n  aform_val e X \\<le> b\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "hence \"?x \\<in> {?x .. b}\""], ["proof (prove)\nusing this:\n  aform_val e X \\<le> b\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> {aform_val e X..b}", "by simp"], ["proof (state)\nthis:\n  aform_val e X \\<in> {aform_val e X..b}\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"- inverse (b * b) \\<le> alpha\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - inverse (b * b) \\<le> alpha", "by (auto simp add: alpha_def inverse_mult_distrib[symmetric] inverse_eq_divide sq_def\n      intro!: order_trans[OF real_divl] divide_left_mono truncate_up mult_pos_pos \\<open>0 < b\\<close>)"], ["proof (state)\nthis:\n  - inverse (b * b) \\<le> alpha\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "{"], ["proof (state)\nthis:\n  - inverse (b * b) \\<le> alpha\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "note \\<open>0 < a\\<close>"], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "moreover"], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"?x \\<in> {a .. b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e X \\<in> {a..b}", "using \\<open>a \\<le> ?x\\<close> \\<open>?x \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> aform_val e X\n  aform_val e X \\<le> b\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> {a..b}", "by simp"], ["proof (state)\nthis:\n  aform_val e X \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "moreover"], ["proof (state)\nthis:\n  aform_val e X \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "note \\<open>- inverse (b * b) \\<le> alpha\\<close>"], ["proof (state)\nthis:\n  - inverse (b * b) \\<le> alpha\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "ultimately"], ["proof (chain)\npicking this:\n  0 < a\n  aform_val e X \\<in> {a..b}\n  - inverse (b * b) \\<le> alpha", "have \"inverse ?x \\<le> inverse a + alpha * (?x - a)\""], ["proof (prove)\nusing this:\n  0 < a\n  aform_val e X \\<in> {a..b}\n  - inverse (b * b) \\<le> alpha\n\ngoal (1 subgoal):\n 1. inverse (aform_val e X) \\<le> inverse a + alpha * (aform_val e X - a)", "by (rule inverse_linear_upper)"], ["proof (state)\nthis:\n  inverse (aform_val e X) \\<le> inverse a + alpha * (aform_val e X - a)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  inverse (aform_val e X) \\<le> inverse a + alpha * (aform_val e X - a)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"\\<dots> = alpha * ?x + (inverse a - alpha * a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse a + alpha * (aform_val e X - a) =\n    alpha * aform_val e X + (inverse a - alpha * a)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  inverse a + alpha * (aform_val e X - a) =\n  alpha * aform_val e X + (inverse a - alpha * a)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  inverse a + alpha * (aform_val e X - a) =\n  alpha * aform_val e X + (inverse a - alpha * a)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"inverse a - (alpha * a) \\<le> (real_divr p 1 a - alpha * a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse a - alpha * a \\<le> real_divr p 1 a - alpha * a", "by (auto simp: inverse_eq_divide real_divr)"], ["proof (state)\nthis:\n  inverse a - alpha * a \\<le> real_divr p 1 a - alpha * a\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  inverse a - alpha * a \\<le> real_divr p 1 a - alpha * a\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"\\<dots> \\<le> (truncate_down p (real_divl p 1 b - alpha * b) +\n          (real_divr p 1 a - alpha * a)) / 2 +\n        (truncate_up p (real_divr p 1 a - alpha * a) -\n          truncate_down p (real_divl p 1 b - alpha * b)) / 2\"\n      (is \"_ \\<le> (truncate_down p ?lb + ?ra) / 2 + (truncate_up p ?ra - truncate_down p ?lb) / 2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_divr p 1 a - alpha * a\n    \\<le> (truncate_down p (real_divl p 1 b - alpha * b) +\n           (real_divr p 1 a - alpha * a)) /\n          2 +\n          (truncate_up p (real_divr p 1 a - alpha * a) -\n           truncate_down p (real_divl p 1 b - alpha * b)) /\n          2", "by (auto simp add: field_simps\n        intro!: order_trans[OF _ add_left_mono[OF mult_left_mono[OF truncate_up]]])"], ["proof (state)\nthis:\n  real_divr p 1 a - alpha * a\n  \\<le> (truncate_down p (real_divl p 1 b - alpha * b) +\n         (real_divr p 1 a - alpha * a)) /\n        2 +\n        (truncate_up p (real_divr p 1 a - alpha * a) -\n         truncate_down p (real_divl p 1 b - alpha * b)) /\n        2\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  real_divr p 1 a - alpha * a\n  \\<le> (truncate_down p (real_divl p 1 b - alpha * b) +\n         (real_divr p 1 a - alpha * a)) /\n        2 +\n        (truncate_up p (real_divr p 1 a - alpha * a) -\n         truncate_down p (real_divl p 1 b - alpha * b)) /\n        2\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"(truncate_down p ?lb + ?ra) / 2 \\<le>\n        truncate_up p ((truncate_down p ?lb + truncate_up p ?ra) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (truncate_down p (real_divl p 1 b - alpha * b) +\n     (real_divr p 1 a - alpha * a)) /\n    2\n    \\<le> truncate_up p\n           ((truncate_down p (real_divl p 1 b - alpha * b) +\n             truncate_up p (real_divr p 1 a - alpha * a)) /\n            2)", "by (intro truncate_up_le divide_right_mono add_left_mono truncate_up) auto"], ["proof (state)\nthis:\n  (truncate_down p (real_divl p 1 b - alpha * b) +\n   (real_divr p 1 a - alpha * a)) /\n  2\n  \\<le> truncate_up p\n         ((truncate_down p (real_divl p 1 b - alpha * b) +\n           truncate_up p (real_divr p 1 a - alpha * a)) /\n          2)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  (truncate_down p (real_divl p 1 b - alpha * b) +\n   (real_divr p 1 a - alpha * a)) /\n  2\n  \\<le> truncate_up p\n         ((truncate_down p (real_divl p 1 b - alpha * b) +\n           truncate_up p (real_divr p 1 a - alpha * a)) /\n          2)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"(truncate_up p ?ra - truncate_down p ?lb) / 2 + truncate_down p ?lb \\<le>\n        (truncate_up p ((truncate_down p ?lb + truncate_up p ?ra) / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (truncate_up p (real_divr p 1 a - alpha * a) -\n     truncate_down p (real_divl p 1 b - alpha * b)) /\n    2 +\n    truncate_down p (real_divl p 1 b - alpha * b)\n    \\<le> truncate_up p\n           ((truncate_down p (real_divl p 1 b - alpha * b) +\n             truncate_up p (real_divr p 1 a - alpha * a)) /\n            2)", "by (rule truncate_up_le) (simp add: field_simps)"], ["proof (state)\nthis:\n  (truncate_up p (real_divr p 1 a - alpha * a) -\n   truncate_down p (real_divl p 1 b - alpha * b)) /\n  2 +\n  truncate_down p (real_divl p 1 b - alpha * b)\n  \\<le> truncate_up p\n         ((truncate_down p (real_divl p 1 b - alpha * b) +\n           truncate_up p (real_divr p 1 a - alpha * a)) /\n          2)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "hence \"(truncate_up p ?ra - truncate_down p ?lb) / 2 \\<le> truncate_up p\n        (truncate_up p ((truncate_down p ?lb + truncate_up p ?ra) / 2) - truncate_down p ?lb)\""], ["proof (prove)\nusing this:\n  (truncate_up p (real_divr p 1 a - alpha * a) -\n   truncate_down p (real_divl p 1 b - alpha * b)) /\n  2 +\n  truncate_down p (real_divl p 1 b - alpha * b)\n  \\<le> truncate_up p\n         ((truncate_down p (real_divl p 1 b - alpha * b) +\n           truncate_up p (real_divr p 1 a - alpha * a)) /\n          2)\n\ngoal (1 subgoal):\n 1. (truncate_up p (real_divr p 1 a - alpha * a) -\n     truncate_down p (real_divl p 1 b - alpha * b)) /\n    2\n    \\<le> truncate_up p\n           (truncate_up p\n             ((truncate_down p (real_divl p 1 b - alpha * b) +\n               truncate_up p (real_divr p 1 a - alpha * a)) /\n              2) -\n            truncate_down p (real_divl p 1 b - alpha * b))", "by (intro truncate_up_le) (simp add: field_simps)"], ["proof (state)\nthis:\n  (truncate_up p (real_divr p 1 a - alpha * a) -\n   truncate_down p (real_divl p 1 b - alpha * b)) /\n  2\n  \\<le> truncate_up p\n         (truncate_up p\n           ((truncate_down p (real_divl p 1 b - alpha * b) +\n             truncate_up p (real_divr p 1 a - alpha * a)) /\n            2) -\n          truncate_down p (real_divl p 1 b - alpha * b))\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              alpha * aform_val e X + x \\<le> alpha * aform_val e X + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      alpha * aform_val e X + x \\<le> alpha * aform_val e X + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      alpha * aform_val e X +\n      (x +\n       (truncate_up p (real_divr p 1 a - alpha * a) -\n        truncate_down p (real_divl p 1 b - alpha * b)) /\n       2)\n      \\<le> alpha * aform_val e X +\n            (y +\n             (truncate_up p (real_divr p 1 a - alpha * a) -\n              truncate_down p (real_divl p 1 b - alpha * b)) /\n             2);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      alpha * aform_val e X +\n      (truncate_up p\n        ((truncate_down p (real_divl p 1 b - alpha * b) +\n          truncate_up p (real_divr p 1 a - alpha * a)) /\n         2) +\n       x)\n      \\<le> alpha * aform_val e X +\n            (truncate_up p\n              ((truncate_down p (real_divl p 1 b - alpha * b) +\n                truncate_up p (real_divr p 1 a - alpha * a)) /\n               2) +\n             y)\\<rbrakk>\n  \\<Longrightarrow> inverse (aform_val e X)\n                    \\<le> alpha * aform_val e X +\n                          (truncate_up p\n                            ((truncate_down p\n                               (real_divl p 1 b - alpha * b) +\n                              truncate_up p (real_divr p 1 a - alpha * a)) /\n                             2) +\n                           truncate_up p\n                            (truncate_up p\n                              ((truncate_down p\n                                 (real_divl p 1 b - alpha * b) +\n                                truncate_up p\n                                 (real_divr p 1 a - alpha * a)) /\n                               2) -\n                             truncate_down p (real_divl p 1 b - alpha * b)))", "have \"inverse ?x \\<le> alpha * ?x + zeta + delta\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              alpha * aform_val e X + x \\<le> alpha * aform_val e X + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      alpha * aform_val e X + x \\<le> alpha * aform_val e X + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      alpha * aform_val e X +\n      (x +\n       (truncate_up p (real_divr p 1 a - alpha * a) -\n        truncate_down p (real_divl p 1 b - alpha * b)) /\n       2)\n      \\<le> alpha * aform_val e X +\n            (y +\n             (truncate_up p (real_divr p 1 a - alpha * a) -\n              truncate_down p (real_divl p 1 b - alpha * b)) /\n             2);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      alpha * aform_val e X +\n      (truncate_up p\n        ((truncate_down p (real_divl p 1 b - alpha * b) +\n          truncate_up p (real_divr p 1 a - alpha * a)) /\n         2) +\n       x)\n      \\<le> alpha * aform_val e X +\n            (truncate_up p\n              ((truncate_down p (real_divl p 1 b - alpha * b) +\n                truncate_up p (real_divr p 1 a - alpha * a)) /\n               2) +\n             y)\\<rbrakk>\n  \\<Longrightarrow> inverse (aform_val e X)\n                    \\<le> alpha * aform_val e X +\n                          (truncate_up p\n                            ((truncate_down p\n                               (real_divl p 1 b - alpha * b) +\n                              truncate_up p (real_divr p 1 a - alpha * a)) /\n                             2) +\n                           truncate_up p\n                            (truncate_up p\n                              ((truncate_down p\n                                 (real_divl p 1 b - alpha * b) +\n                                truncate_up p\n                                 (real_divr p 1 a - alpha * a)) /\n                               2) -\n                             truncate_down p (real_divl p 1 b - alpha * b)))\n\ngoal (1 subgoal):\n 1. inverse (aform_val e X) \\<le> alpha * aform_val e X + zeta + delta", "by (auto simp: zeta_def delta_def d_min'_def d_max'_def right_diff_distrib ac_simps)"], ["proof (state)\nthis:\n  inverse (aform_val e X) \\<le> alpha * aform_val e X + zeta + delta\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "}"], ["proof (state)\nthis:\n  inverse (aform_val e X) \\<le> alpha * aform_val e X + zeta + delta\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "note upper = this"], ["proof (state)\nthis:\n  inverse (aform_val e X) \\<le> alpha * aform_val e X + zeta + delta\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "{"], ["proof (state)\nthis:\n  inverse (aform_val e X) \\<le> alpha * aform_val e X + zeta + delta\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"alpha * b + truncate_down p (real_divl p 1 b - alpha * b) \\<le> inverse b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha * b + truncate_down p (real_divl p 1 b - alpha * b)\n    \\<le> inverse b", "by (rule order_trans[OF add_left_mono[OF truncate_down]])\n        (auto simp: inverse_eq_divide real_divl)"], ["proof (state)\nthis:\n  alpha * b + truncate_down p (real_divl p 1 b - alpha * b) \\<le> inverse b\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "hence \"zeta + alpha * b \\<le> delta + inverse b\""], ["proof (prove)\nusing this:\n  alpha * b + truncate_down p (real_divl p 1 b - alpha * b) \\<le> inverse b\n\ngoal (1 subgoal):\n 1. zeta + alpha * b \\<le> delta + inverse b", "by (auto simp: zeta_def delta_def d_min'_def d_max'_def right_diff_distrib\n        intro!: order_trans[OF _ add_right_mono[OF truncate_up]])"], ["proof (state)\nthis:\n  zeta + alpha * b \\<le> delta + inverse b\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "hence \"alpha * ?x + zeta - delta \\<le> inverse b + alpha * (?x - b)\""], ["proof (prove)\nusing this:\n  zeta + alpha * b \\<le> delta + inverse b\n\ngoal (1 subgoal):\n 1. alpha * aform_val e X + zeta - delta\n    \\<le> inverse b + alpha * (aform_val e X - b)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  alpha * aform_val e X + zeta - delta\n  \\<le> inverse b + alpha * (aform_val e X - b)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  alpha * aform_val e X + zeta - delta\n  \\<le> inverse b + alpha * (aform_val e X - b)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "{"], ["proof (state)\nthis:\n  alpha * aform_val e X + zeta - delta\n  \\<le> inverse b + alpha * (aform_val e X - b)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "note \\<open>0 < aform_val e X\\<close>"], ["proof (state)\nthis:\n  0 < aform_val e X\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "moreover"], ["proof (state)\nthis:\n  0 < aform_val e X\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "note \\<open>aform_val e X \\<in> {aform_val e X .. b}\\<close>"], ["proof (state)\nthis:\n  aform_val e X \\<in> {aform_val e X..b}\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "moreover"], ["proof (state)\nthis:\n  aform_val e X \\<in> {aform_val e X..b}\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "note \\<open>- inverse (b * b) \\<le> alpha\\<close>"], ["proof (state)\nthis:\n  - inverse (b * b) \\<le> alpha\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "ultimately"], ["proof (chain)\npicking this:\n  0 < aform_val e X\n  aform_val e X \\<in> {aform_val e X..b}\n  - inverse (b * b) \\<le> alpha", "have \"inverse b + alpha * (aform_val e X - b) \\<le> inverse (aform_val e X)\""], ["proof (prove)\nusing this:\n  0 < aform_val e X\n  aform_val e X \\<in> {aform_val e X..b}\n  - inverse (b * b) \\<le> alpha\n\ngoal (1 subgoal):\n 1. inverse b + alpha * (aform_val e X - b) \\<le> inverse (aform_val e X)", "by (rule inverse_linear_lower)"], ["proof (state)\nthis:\n  inverse b + alpha * (aform_val e X - b) \\<le> inverse (aform_val e X)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "}"], ["proof (state)\nthis:\n  inverse b + alpha * (aform_val e X - b) \\<le> inverse (aform_val e X)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "finally"], ["proof (chain)\npicking this:\n  alpha * aform_val e X + zeta - delta \\<le> inverse (aform_val e X)", "have \"alpha * (aform_val e X) + zeta - delta \\<le> inverse (aform_val e X)\""], ["proof (prove)\nusing this:\n  alpha * aform_val e X + zeta - delta \\<le> inverse (aform_val e X)\n\ngoal (1 subgoal):\n 1. alpha * aform_val e X + zeta - delta \\<le> inverse (aform_val e X)", "."], ["proof (state)\nthis:\n  alpha * aform_val e X + zeta - delta \\<le> inverse (aform_val e X)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "}"], ["proof (state)\nthis:\n  alpha * aform_val e X + zeta - delta \\<le> inverse (aform_val e X)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "note lower = this"], ["proof (state)\nthis:\n  alpha * aform_val e X + zeta - delta \\<le> inverse (aform_val e X)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"inverse (aform_val e X) = alpha * (aform_val e X) + zeta +\n      (inverse (aform_val e X) - alpha * (aform_val e X) - zeta)\"\n    (is \"_ = _ + ?linerr\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (aform_val e X) =\n    alpha * aform_val e X + zeta +\n    (inverse (aform_val e X) - alpha * aform_val e X - zeta)", "by simp"], ["proof (state)\nthis:\n  inverse (aform_val e X) =\n  alpha * aform_val e X + zeta +\n  (inverse (aform_val e X) - alpha * aform_val e X - zeta)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  inverse (aform_val e X) =\n  alpha * aform_val e X + zeta +\n  (inverse (aform_val e X) - alpha * aform_val e X - zeta)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"?linerr \\<in> {- delta .. delta}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (aform_val e X) - alpha * aform_val e X - zeta\n    \\<in> {- delta..delta}", "using lower upper"], ["proof (prove)\nusing this:\n  alpha * aform_val e X + zeta - delta \\<le> inverse (aform_val e X)\n  inverse (aform_val e X) \\<le> alpha * aform_val e X + zeta + delta\n\ngoal (1 subgoal):\n 1. inverse (aform_val e X) - alpha * aform_val e X - zeta\n    \\<in> {- delta..delta}", "by simp"], ["proof (state)\nthis:\n  inverse (aform_val e X) - alpha * aform_val e X - zeta\n  \\<in> {- delta..delta}\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "hence linerr_le: \"abs ?linerr \\<le> delta\""], ["proof (prove)\nusing this:\n  inverse (aform_val e X) - alpha * aform_val e X - zeta\n  \\<in> {- delta..delta}\n\ngoal (1 subgoal):\n 1. \\<bar>inverse (aform_val e X) - alpha * aform_val e X - zeta\\<bar>\n    \\<le> delta", "by auto"], ["proof (state)\nthis:\n  \\<bar>inverse (aform_val e X) - alpha * aform_val e X - zeta\\<bar>\n  \\<le> delta\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "let ?z0 = \"trunc_bound_eucl p (alpha * fst X)\""], ["proof (state)\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "from trunc_bound_euclE"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl ?p ?x);\n       fst (trunc_bound_eucl ?p ?x) = ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e1 where abs_e1: \"\\<bar>e1\\<bar> \\<le> snd ?z0\" and e1: \"fst ?z0 = alpha * fst X + e1\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl ?p ?x);\n       fst (trunc_bound_eucl ?p ?x) = ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e1.\n        \\<lbrakk>\\<bar>e1\\<bar>\n                 \\<le> snd (trunc_bound_eucl p (alpha * fst X));\n         fst (trunc_bound_eucl p (alpha * fst X)) =\n         alpha * fst X + e1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>e1\\<bar> \\<le> snd (trunc_bound_eucl p (alpha * fst X))\n  fst (trunc_bound_eucl p (alpha * fst X)) = alpha * fst X + e1\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "let ?z1 = \"trunc_bound_eucl p (fst ?z0 + zeta)\""], ["proof (state)\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "from trunc_bound_euclE"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl ?p ?x);\n       fst (trunc_bound_eucl ?p ?x) = ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e1' where abs_e1': \"\\<bar>e1'\\<bar> \\<le> snd ?z1\" and e1': \"fst ?z1 = fst ?z0 + zeta + e1'\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl ?p ?x);\n       fst (trunc_bound_eucl ?p ?x) = ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e1'.\n        \\<lbrakk>\\<bar>e1'\\<bar>\n                 \\<le> snd (trunc_bound_eucl p\n                             (fst (trunc_bound_eucl p (alpha * fst X)) +\n                              zeta));\n         fst (trunc_bound_eucl p\n               (fst (trunc_bound_eucl p (alpha * fst X)) + zeta)) =\n         fst (trunc_bound_eucl p (alpha * fst X)) + zeta + e1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>e1'\\<bar>\n  \\<le> snd (trunc_bound_eucl p\n              (fst (trunc_bound_eucl p (alpha * fst X)) + zeta))\n  fst (trunc_bound_eucl p\n        (fst (trunc_bound_eucl p (alpha * fst X)) + zeta)) =\n  fst (trunc_bound_eucl p (alpha * fst X)) + zeta + e1'\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "let ?zs = \"trunc_bound_pdevs p (scaleR_pdevs alpha (snd X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "from trunc_bound_pdevsE[OF e]"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs ?p ?x);\n       pdevs_val e (fst (trunc_bound_pdevs ?p ?x)) =\n       pdevs_val e ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e2 where abs_e2: \"\\<bar>e2\\<bar> \\<le> snd (?zs)\"\n    and e2: \"pdevs_val e (fst ?zs) = pdevs_val e (scaleR_pdevs alpha (snd X)) + e2\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs ?p ?x);\n       pdevs_val e (fst (trunc_bound_pdevs ?p ?x)) =\n       pdevs_val e ?x + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e2.\n        \\<lbrakk>\\<bar>e2\\<bar>\n                 \\<le> snd (trunc_bound_pdevs p\n                             (scaleR_pdevs alpha (snd X)));\n         pdevs_val e\n          (fst (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))) =\n         pdevs_val e (scaleR_pdevs alpha (snd X)) + e2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>e2\\<bar>\n  \\<le> snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))\n  pdevs_val e (fst (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))) =\n  pdevs_val e (scaleR_pdevs alpha (snd X)) + e2\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"alpha * (aform_val e X) + zeta =\n      aform_val e (fst (inverse_aform' p X)) + (- e1 - e1' - e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha * aform_val e X + zeta =\n    aform_val e (fst (inverse_aform' p X)) + (- e1 - e1' - e2)", "unfolding inverse_aform'_def Let_def vars[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha * aform_val e X + zeta =\n    aform_val e\n     (fst ((fst (trunc_bound_eucl p\n                  (fst (trunc_bound_eucl p (alpha * fst X)) +\n                   (if l < 0 then - zeta else zeta))),\n            fst (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))),\n           sum_list' p\n            [truncate_up p ((if l < 0 then - zeta else zeta) - d_min'),\n             snd (trunc_bound_eucl p (alpha * fst X)),\n             snd (trunc_bound_eucl p\n                   (fst (trunc_bound_eucl p (alpha * fst X)) +\n                    (if l < 0 then - zeta else zeta))),\n             snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))])) +\n    (- e1 - e1' - e2)", "using \\<open>0 < l\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. alpha * aform_val e X + zeta =\n    aform_val e\n     (fst ((fst (trunc_bound_eucl p\n                  (fst (trunc_bound_eucl p (alpha * fst X)) +\n                   (if l < 0 then - zeta else zeta))),\n            fst (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))),\n           sum_list' p\n            [truncate_up p ((if l < 0 then - zeta else zeta) - d_min'),\n             snd (trunc_bound_eucl p (alpha * fst X)),\n             snd (trunc_bound_eucl p\n                   (fst (trunc_bound_eucl p (alpha * fst X)) +\n                    (if l < 0 then - zeta else zeta))),\n             snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))])) +\n    (- e1 - e1' - e2)", "by (simp add: aform_val_def assms e1') (simp add: e1 e2 algebra_simps)"], ["proof (state)\nthis:\n  alpha * aform_val e X + zeta =\n  aform_val e (fst (inverse_aform' p X)) + (- e1 - e1' - e2)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  alpha * aform_val e X + zeta =\n  aform_val e (fst (inverse_aform' p X)) + (- e1 - e1' - e2)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "let ?err = \"(- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X - zeta)\""], ["proof (state)\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"abs ?err \\<le> abs ?linerr + abs e1 + abs e1' + abs e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) -\n          alpha * aform_val e X -\n          zeta\\<bar>\n    \\<le> \\<bar>inverse (aform_val e X) - alpha * aform_val e X -\n                zeta\\<bar> +\n          \\<bar>e1\\<bar> +\n          \\<bar>e1'\\<bar> +\n          \\<bar>e2\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n        zeta\\<bar>\n  \\<le> \\<bar>inverse (aform_val e X) - alpha * aform_val e X - zeta\\<bar> +\n        \\<bar>e1\\<bar> +\n        \\<bar>e1'\\<bar> +\n        \\<bar>e2\\<bar>\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n        zeta\\<bar>\n  \\<le> \\<bar>inverse (aform_val e X) - alpha * aform_val e X - zeta\\<bar> +\n        \\<bar>e1\\<bar> +\n        \\<bar>e1'\\<bar> +\n        \\<bar>e2\\<bar>\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"\\<dots> \\<le> delta + snd ?z0 + snd ?z1 + snd ?zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>inverse (aform_val e X) - alpha * aform_val e X - zeta\\<bar> +\n    \\<bar>e1\\<bar> +\n    \\<bar>e1'\\<bar> +\n    \\<bar>e2\\<bar>\n    \\<le> delta + snd (trunc_bound_eucl p (alpha * fst X)) +\n          snd (trunc_bound_eucl p\n                (fst (trunc_bound_eucl p (alpha * fst X)) + zeta)) +\n          snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))", "by (blast intro: add_mono linerr_le abs_e1 abs_e1' abs_e2)"], ["proof (state)\nthis:\n  \\<bar>inverse (aform_val e X) - alpha * aform_val e X - zeta\\<bar> +\n  \\<bar>e1\\<bar> +\n  \\<bar>e1'\\<bar> +\n  \\<bar>e2\\<bar>\n  \\<le> delta + snd (trunc_bound_eucl p (alpha * fst X)) +\n        snd (trunc_bound_eucl p\n              (fst (trunc_bound_eucl p (alpha * fst X)) + zeta)) +\n        snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "also"], ["proof (state)\nthis:\n  \\<bar>inverse (aform_val e X) - alpha * aform_val e X - zeta\\<bar> +\n  \\<bar>e1\\<bar> +\n  \\<bar>e1'\\<bar> +\n  \\<bar>e2\\<bar>\n  \\<le> delta + snd (trunc_bound_eucl p (alpha * fst X)) +\n        snd (trunc_bound_eucl p\n              (fst (trunc_bound_eucl p (alpha * fst X)) + zeta)) +\n        snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"\\<dots> \\<le> (snd (inverse_aform' p X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta + snd (trunc_bound_eucl p (alpha * fst X)) +\n    snd (trunc_bound_eucl p\n          (fst (trunc_bound_eucl p (alpha * fst X)) + zeta)) +\n    snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))\n    \\<le> snd (inverse_aform' p X)", "unfolding inverse_aform'_def Let_def vars[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. delta + snd (trunc_bound_eucl p (alpha * fst X)) +\n    snd (trunc_bound_eucl p\n          (fst (trunc_bound_eucl p (alpha * fst X)) + zeta)) +\n    snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))\n    \\<le> snd ((fst (trunc_bound_eucl p\n                      (fst (trunc_bound_eucl p (alpha * fst X)) +\n                       (if l < 0 then - zeta else zeta))),\n                fst (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))),\n               sum_list' p\n                [truncate_up p ((if l < 0 then - zeta else zeta) - d_min'),\n                 snd (trunc_bound_eucl p (alpha * fst X)),\n                 snd (trunc_bound_eucl p\n                       (fst (trunc_bound_eucl p (alpha * fst X)) +\n                        (if l < 0 then - zeta else zeta))),\n                 snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))])", "using \\<open>0 < l\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. delta + snd (trunc_bound_eucl p (alpha * fst X)) +\n    snd (trunc_bound_eucl p\n          (fst (trunc_bound_eucl p (alpha * fst X)) + zeta)) +\n    snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))\n    \\<le> snd ((fst (trunc_bound_eucl p\n                      (fst (trunc_bound_eucl p (alpha * fst X)) +\n                       (if l < 0 then - zeta else zeta))),\n                fst (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))),\n               sum_list' p\n                [truncate_up p ((if l < 0 then - zeta else zeta) - d_min'),\n                 snd (trunc_bound_eucl p (alpha * fst X)),\n                 snd (trunc_bound_eucl p\n                       (fst (trunc_bound_eucl p (alpha * fst X)) +\n                        (if l < 0 then - zeta else zeta))),\n                 snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))])", "by (auto simp add: inverse_aform'_def pdevs_apply_trunc_pdevs assms vars[symmetric]\n        intro!: order.trans[OF _ sum_list'_sum_list_le])"], ["proof (state)\nthis:\n  delta + snd (trunc_bound_eucl p (alpha * fst X)) +\n  snd (trunc_bound_eucl p\n        (fst (trunc_bound_eucl p (alpha * fst X)) + zeta)) +\n  snd (trunc_bound_pdevs p (scaleR_pdevs alpha (snd X)))\n  \\<le> snd (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n        zeta\\<bar>\n  \\<le> snd (inverse_aform' p X)", "have \"abs ?err \\<le> snd (inverse_aform' p X)\""], ["proof (prove)\nusing this:\n  \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n        zeta\\<bar>\n  \\<le> snd (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) -\n          alpha * aform_val e X -\n          zeta\\<bar>\n    \\<le> snd (inverse_aform' p X)", "by simp"], ["proof (state)\nthis:\n  \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n        zeta\\<bar>\n  \\<le> snd (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "}"], ["proof (state)\nthis:\n  \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n        zeta\\<bar>\n  \\<le> snd (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "note err_le = this"], ["proof (state)\nthis:\n  \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n        zeta\\<bar>\n  \\<le> snd (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "have \"aform_val (e) (fst (inverse_aform' p X)) + (- e1 - e1' - e2) +\n    (inverse (aform_val e X) - alpha * aform_val e X - zeta) =\n    aform_val e (fst (inverse_aform' p X)) + ?err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (fst (inverse_aform' p X)) + (- e1 - e1' - e2) +\n    (inverse (aform_val e X) - alpha * aform_val e X - zeta) =\n    aform_val e (fst (inverse_aform' p X)) +\n    (- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n     zeta)", "by simp"], ["proof (state)\nthis:\n  aform_val e (fst (inverse_aform' p X)) + (- e1 - e1' - e2) +\n  (inverse (aform_val e X) - alpha * aform_val e X - zeta) =\n  aform_val e (fst (inverse_aform' p X)) +\n  (- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X - zeta)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "finally"], ["proof (chain)\npicking this:\n  inverse (aform_val e X) =\n  aform_val e (fst (inverse_aform' p X)) +\n  (- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X - zeta)", "show ?thesis"], ["proof (prove)\nusing this:\n  inverse (aform_val e X) =\n  aform_val e (fst (inverse_aform' p X)) +\n  (- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X - zeta)\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e (inverse_aform' p X)", "apply (intro aform_errI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (aform_val e X) =\n    aform_val e (fst (inverse_aform' p X)) +\n    (- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n     zeta) \\<Longrightarrow>\n    \\<bar>inverse x - aform_val e (fst (inverse_aform' p X))\\<bar>\n    \\<le> snd (inverse_aform' p X)", "using err_le"], ["proof (prove)\nusing this:\n  \\<bar>- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n        zeta\\<bar>\n  \\<le> snd (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. inverse (aform_val e X) =\n    aform_val e (fst (inverse_aform' p X)) +\n    (- e1 - e1' - e2 + inverse (aform_val e X) - alpha * aform_val e X -\n     zeta) \\<Longrightarrow>\n    \\<bar>inverse x - aform_val e (fst (inverse_aform' p X))\\<bar>\n    \\<le> snd (inverse_aform' p X)", "by (auto simp: assms)"], ["proof (state)\nthis:\n  inverse x \\<in> aform_err e (inverse_aform' p X)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"inverse_aform p a =\n  do {\n    let l = Inf_aform' p a;\n    let u = Sup_aform' p a;\n    if (l \\<le> 0 \\<and> 0 \\<le> u) then None\n    else if (l \\<le> 0) then (Some (apfst uminus_aform (inverse_aform' p (uminus_aform a))))\n    else Some (inverse_aform' p a)\n  }\""], ["", "lemma eucl_truncate_up_eq_eucl_truncate_down:\n  \"eucl_truncate_up p x = - (eucl_truncate_down p (- x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_truncate_up p x = - eucl_truncate_down p (- x)", "by (auto simp: eucl_truncate_up_def eucl_truncate_down_def truncate_up_eq_truncate_down sum_negf)"], ["", "lemma inverse_aformE:\n  fixes X::\"real aform\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n    and disj: \"Inf_aform' p X > 0 \\<or> Sup_aform' p X < 0\"\n  obtains Y where\n    \"inverse_aform p X = Some Y\"\n    \"inverse (aform_val e X) \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume neg: \"Sup_aform' p X < 0\""], ["proof (state)\nthis:\n  Sup_aform' p X < 0\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from neg"], ["proof (chain)\npicking this:\n  Sup_aform' p X < 0", "have [simp]: \"Inf_aform' p X \\<le> 0\""], ["proof (prove)\nusing this:\n  Sup_aform' p X < 0\n\ngoal (1 subgoal):\n 1. Inf_aform' p X \\<le> 0", "by (metis Inf_aform'_le_Sup_aform' dual_order.strict_trans1 less_asym not_less)"], ["proof (state)\nthis:\n  Inf_aform' p X \\<le> 0\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from neg disj"], ["proof (chain)\npicking this:\n  Sup_aform' p X < 0\n  0 < Inf_aform' p X \\<or> Sup_aform' p X < 0", "have \"0 < Inf_aform' p (uminus_aform X)\""], ["proof (prove)\nusing this:\n  Sup_aform' p X < 0\n  0 < Inf_aform' p X \\<or> Sup_aform' p X < 0\n\ngoal (1 subgoal):\n 1. 0 < Inf_aform' p (uminus_aform X)", "by (auto simp: Inf_aform'_def Sup_aform'_def eucl_truncate_up_eq_eucl_truncate_down ac_simps)"], ["proof (state)\nthis:\n  0 < Inf_aform' p (uminus_aform X)\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from inverse_aform'E[OF e(1) this]"], ["proof (chain)\npicking this:\n  ?x = aform_val e (uminus_aform X) \\<Longrightarrow>\n  inverse ?x \\<in> aform_err e (inverse_aform' p (uminus_aform X))", "have iin: \"inverse (aform_val e (uminus_aform X)) \\<in> aform_err e (inverse_aform' p (uminus_aform X))\""], ["proof (prove)\nusing this:\n  ?x = aform_val e (uminus_aform X) \\<Longrightarrow>\n  inverse ?x \\<in> aform_err e (inverse_aform' p (uminus_aform X))\n\ngoal (1 subgoal):\n 1. inverse (aform_val e (uminus_aform X))\n    \\<in> aform_err e (inverse_aform' p (uminus_aform X))", "by simp"], ["proof (state)\nthis:\n  inverse (aform_val e (uminus_aform X))\n  \\<in> aform_err e (inverse_aform' p (uminus_aform X))\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?Y = \"apfst uminus_aform (inverse_aform' p (uminus_aform X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"inverse_aform p X = Some ?Y\"\n      \"inverse (aform_val e X) \\<in> aform_err e ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_aform p X =\n    Some (apfst uminus_aform (inverse_aform' p (uminus_aform X))) &&&\n    inverse (aform_val e X)\n    \\<in> aform_err e\n           (apfst uminus_aform (inverse_aform' p (uminus_aform X)))", "using neg iin"], ["proof (prove)\nusing this:\n  Sup_aform' p X < 0\n  inverse (aform_val e (uminus_aform X))\n  \\<in> aform_err e (inverse_aform' p (uminus_aform X))\n\ngoal (1 subgoal):\n 1. inverse_aform p X =\n    Some (apfst uminus_aform (inverse_aform' p (uminus_aform X))) &&&\n    inverse (aform_val e X)\n    \\<in> aform_err e\n           (apfst uminus_aform (inverse_aform' p (uminus_aform X)))", "by (auto simp: inverse_aform_def aform_err_def)"], ["proof (state)\nthis:\n  inverse_aform p X =\n  Some (apfst uminus_aform (inverse_aform' p (uminus_aform X)))\n  inverse (aform_val e X)\n  \\<in> aform_err e (apfst uminus_aform (inverse_aform' p (uminus_aform X)))\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  inverse_aform p X =\n  Some (apfst uminus_aform (inverse_aform' p (uminus_aform X)))\n  inverse (aform_val e X)\n  \\<in> aform_err e (apfst uminus_aform (inverse_aform' p (uminus_aform X)))", "have ?thesis"], ["proof (prove)\nusing this:\n  inverse_aform p X =\n  Some (apfst uminus_aform (inverse_aform' p (uminus_aform X)))\n  inverse (aform_val e X)\n  \\<in> aform_err e (apfst uminus_aform (inverse_aform' p (uminus_aform X)))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  Sup_aform' p X < 0 \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  Sup_aform' p X < 0 \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  Sup_aform' p X < 0 \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume pos: \"Inf_aform' p X > 0\""], ["proof (state)\nthis:\n  0 < Inf_aform' p X\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pos"], ["proof (chain)\npicking this:\n  0 < Inf_aform' p X", "have eq: \"inverse_aform p X = Some (inverse_aform' p X)\""], ["proof (prove)\nusing this:\n  0 < Inf_aform' p X\n\ngoal (1 subgoal):\n 1. inverse_aform p X = Some (inverse_aform' p X)", "by (auto simp: inverse_aform_def)"], ["proof (state)\nthis:\n  inverse_aform p X = Some (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  inverse_aform p X = Some (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from inverse_aform'E[OF e(1) pos refl]"], ["proof (chain)\npicking this:\n  inverse (aform_val e X) \\<in> aform_err e (inverse_aform' p X)", "have \"inverse (aform_val e X) \\<in> aform_err e (inverse_aform' p X)\""], ["proof (prove)\nusing this:\n  inverse (aform_val e X) \\<in> aform_err e (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. inverse (aform_val e X) \\<in> aform_err e (inverse_aform' p X)", "."], ["proof (state)\nthis:\n  inverse (aform_val e X) \\<in> aform_err e (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  inverse_aform p X = Some (inverse_aform' p X)\n  inverse (aform_val e X) \\<in> aform_err e (inverse_aform' p X)", "have ?thesis"], ["proof (prove)\nusing this:\n  inverse_aform p X = Some (inverse_aform' p X)\n  inverse (aform_val e X) \\<in> aform_err e (inverse_aform' p X)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  0 < Inf_aform' p X \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  Sup_aform' p X < 0 \\<Longrightarrow> thesis\n  0 < Inf_aform' p X \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  Sup_aform' p X < 0 \\<Longrightarrow> thesis\n  0 < Inf_aform' p X \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  Sup_aform' p X < 0 \\<Longrightarrow> thesis\n  0 < Inf_aform' p X \\<Longrightarrow> thesis\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  0 < Inf_aform' p X \\<or> Sup_aform' p X < 0\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition aform_err_to_aform::\"aform_err \\<Rightarrow> nat \\<Rightarrow> real aform\"\n  where \"aform_err_to_aform X n = (fst (fst X),  pdev_upd (snd (fst X)) n (snd X))\""], ["", "lemma aform_err_to_aformE:\n  assumes \"x \\<in> aform_err e X\"\n  assumes deg: \"degree_aform_err X \\<le> n\"\n  obtains err where \"x = aform_val (e(n:=err)) (aform_err_to_aform X n)\"\n    \"-1 \\<le> err\" \"err \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>x = aform_val (e(n := err)) (aform_err_to_aform X n);\n         - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>x = aform_val (e(n := err)) (aform_err_to_aform X n);\n         - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from aform_errE[OF assms(1)]"], ["proof (chain)\npicking this:\n  \\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X", "have \"\\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X\""], ["proof (prove)\nusing this:\n  \\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X\n\ngoal (1 subgoal):\n 1. \\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X", "by auto"], ["proof (state)\nthis:\n  \\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X\n\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>x = aform_val (e(n := err)) (aform_err_to_aform X n);\n         - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from error_absE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>ea.\n      \\<lbrakk>x - aform_val e (fst X) = ea * snd X;\n       ea \\<in> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain err where err:\n    \"x - aform_val e (fst X) = err * snd X\" \"err \\<in> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>ea.\n      \\<lbrakk>x - aform_val e (fst X) = ea * snd X;\n       ea \\<in> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>x - aform_val e (fst X) = err * snd X;\n         err \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x - aform_val e (fst X) = err * snd X\n  err \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>x = aform_val (e(n := err)) (aform_err_to_aform X n);\n         - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"x = aform_val (e(n:=err)) (aform_err_to_aform X n)\"\n    \"-1 \\<le> err\" \"err \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = aform_val (e(n := err)) (aform_err_to_aform X n) &&&\n    - 1 \\<le> err &&& err \\<le> 1", "using err deg"], ["proof (prove)\nusing this:\n  x - aform_val e (fst X) = err * snd X\n  err \\<in> {- 1..1}\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. x = aform_val (e(n := err)) (aform_err_to_aform X n) &&&\n    - 1 \\<le> err &&& err \\<le> 1", "by (auto simp: aform_val_def aform_err_to_aform_def)"], ["proof (state)\nthis:\n  x = aform_val (e(n := err)) (aform_err_to_aform X n)\n  - 1 \\<le> err\n  err \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>x = aform_val (e(n := err)) (aform_err_to_aform X n);\n         - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  x = aform_val (e(n := err)) (aform_err_to_aform X n)\n  - 1 \\<le> err\n  err \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  x = aform_val (e(n := err)) (aform_err_to_aform X n)\n  - 1 \\<le> err\n  err \\<le> 1\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition aform_to_aform_err::\"real aform \\<Rightarrow> nat \\<Rightarrow> aform_err\"\n  where \"aform_to_aform_err X n = ((fst X,  pdev_upd (snd X) n 0), abs (pdevs_apply (snd X) n))\""], ["", "lemma aform_to_aform_err: \"aform_val e X \\<in> aform_err e (aform_to_aform_err X n)\"\n  if \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e X \\<in> aform_err e (aform_to_aform_err X n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aform_val e X \\<in> aform_err e (aform_to_aform_err X n)", "from that"], ["proof (chain)\npicking this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}", "have abs_e[simp]: \"\\<And>i. \\<bar>e i\\<bar> \\<le> 1\""], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<bar>e i\\<bar> \\<le> 1", "by (auto simp: abs_real_def)"], ["proof (state)\nthis:\n  \\<bar>e ?i\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> aform_err e (aform_to_aform_err X n)", "have \"- e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "have \"- e n * pdevs_apply (snd X) n \\<le> \\<bar>- e n * pdevs_apply (snd X) n\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - e n * pdevs_apply (snd X) n\n    \\<le> \\<bar>- e n * pdevs_apply (snd X) n\\<bar>", "by auto"], ["proof (state)\nthis:\n  - e n * pdevs_apply (snd X) n\n  \\<le> \\<bar>- e n * pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "also"], ["proof (state)\nthis:\n  - e n * pdevs_apply (snd X) n\n  \\<le> \\<bar>- e n * pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "have \"\\<dots> \\<le> abs (pdevs_apply (snd X) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>- e n * pdevs_apply (snd X) n\\<bar>\n    \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "using that"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<bar>- e n * pdevs_apply (snd X) n\\<bar>\n    \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "by (auto simp: abs_mult intro!: mult_left_le_one_le)"], ["proof (state)\nthis:\n  \\<bar>- e n * pdevs_apply (snd X) n\\<bar>\n  \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "finally"], ["proof (chain)\npicking this:\n  - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "."], ["proof (state)\nthis:\n  - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> aform_err e (aform_to_aform_err X n)", "moreover"], ["proof (state)\nthis:\n  - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> aform_err e (aform_to_aform_err X n)", "have \"e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "have \"e n * pdevs_apply (snd X) n \\<le> \\<bar>e n * pdevs_apply (snd X) n\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e n * pdevs_apply (snd X) n\n    \\<le> \\<bar>e n * pdevs_apply (snd X) n\\<bar>", "by auto"], ["proof (state)\nthis:\n  e n * pdevs_apply (snd X) n \\<le> \\<bar>e n * pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "also"], ["proof (state)\nthis:\n  e n * pdevs_apply (snd X) n \\<le> \\<bar>e n * pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "have \"\\<dots> \\<le> abs (pdevs_apply (snd X) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>e n * pdevs_apply (snd X) n\\<bar>\n    \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "using that"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<bar>e n * pdevs_apply (snd X) n\\<bar>\n    \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "by (auto simp: abs_mult intro!: mult_left_le_one_le)"], ["proof (state)\nthis:\n  \\<bar>e n * pdevs_apply (snd X) n\\<bar>\n  \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "finally"], ["proof (chain)\npicking this:\n  e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "."], ["proof (state)\nthis:\n  e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> aform_err e (aform_to_aform_err X n)", "ultimately"], ["proof (chain)\npicking this:\n  - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n  e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  - e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n  e n * pdevs_apply (snd X) n \\<le> \\<bar>pdevs_apply (snd X) n\\<bar>\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> aform_err e (aform_to_aform_err X n)", "by (auto simp: aform_to_aform_err_def aform_err_def aform_val_def)"], ["proof (state)\nthis:\n  aform_val e X \\<in> aform_err e (aform_to_aform_err X n)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"acc_err p x e \\<equiv> (fst x, truncate_up p (snd x + e))\""], ["", "definition ivl_err :: \"real interval \\<Rightarrow> (real \\<times> real pdevs) \\<times> real\"\n  where \"ivl_err ivl \\<equiv> (((upper ivl + lower ivl)/2, zero_pdevs::real pdevs), (upper ivl - lower ivl) / 2)\""], ["", "lemma inverse_aform:\n  fixes X::\"real aform\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"inverse_aform p X = Some Y\"\n  shows \"inverse (aform_val e X) \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (aform_val e X) \\<in> aform_err e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse (aform_val e X) \\<in> aform_err e Y", "from assms"], ["proof (chain)\npicking this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  inverse_aform p X = Some Y", "have \"Inf_aform' p X > 0 \\<or> 0 > Sup_aform' p X\""], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  inverse_aform p X = Some Y\n\ngoal (1 subgoal):\n 1. 0 < Inf_aform' p X \\<or> Sup_aform' p X < 0", "by (auto simp: inverse_aform_def Let_def bind_eq_Some_conv split: if_splits)"], ["proof (state)\nthis:\n  0 < Inf_aform' p X \\<or> Sup_aform' p X < 0\n\ngoal (1 subgoal):\n 1. inverse (aform_val e X) \\<in> aform_err e Y", "from inverse_aformE[OF e this]"], ["proof (chain)\npicking this:\n  (\\<And>Y.\n      \\<lbrakk>inverse_aform p X = Some Y;\n       inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain Y where\n    \"inverse_aform p X = Some Y\" \"inverse (aform_val e X) \\<in> aform_err e Y\""], ["proof (prove)\nusing this:\n  (\\<And>Y.\n      \\<lbrakk>inverse_aform p X = Some Y;\n       inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>inverse_aform p X = Some Y;\n         inverse (aform_val e X) \\<in> aform_err e Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inverse_aform p X = Some Y\n  inverse (aform_val e X) \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. inverse (aform_val e X) \\<in> aform_err e Y", "with assms"], ["proof (chain)\npicking this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  inverse_aform p X = Some Y\n  inverse_aform p X = Some Y\n  inverse (aform_val e X) \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  inverse_aform p X = Some Y\n  inverse_aform p X = Some Y\n  inverse (aform_val e X) \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. inverse (aform_val e X) \\<in> aform_err e Y", "by auto"], ["proof (state)\nthis:\n  inverse (aform_val e X) \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aform_err_acc_err_leI:\n  \"fx \\<in> aform_err e (acc_err p X err)\"\n  if \"aform_val e (fst X) - (snd X + err) \\<le> fx\" \"fx \\<le> aform_val e (fst X) + (snd X + err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fx \\<in> aform_err e (acc_err p X err)", "using truncate_up[of \"(snd X + err)\" p] truncate_down[of p \"(snd X + err)\"] that"], ["proof (prove)\nusing this:\n  snd X + err \\<le> truncate_up p (snd X + err)\n  truncate_down p (snd X + err) \\<le> snd X + err\n  aform_val e (fst X) - (snd X + err) \\<le> fx\n  fx \\<le> aform_val e (fst X) + (snd X + err)\n\ngoal (1 subgoal):\n 1. fx \\<in> aform_err e (acc_err p X err)", "by (auto simp: aform_err_def acc_err_def)"], ["", "lemma aform_err_acc_errI:\n  \"fx \\<in> aform_err e (acc_err p X err)\"\n  if \"fx \\<in> aform_err e (fst X, snd X + err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fx \\<in> aform_err e (acc_err p X err)", "using truncate_up[of \"(snd X + err)\" p] truncate_down[of p \"(snd X + err)\"] that"], ["proof (prove)\nusing this:\n  snd X + err \\<le> truncate_up p (snd X + err)\n  truncate_down p (snd X + err) \\<le> snd X + err\n  fx \\<in> aform_err e (fst X, snd X + err)\n\ngoal (1 subgoal):\n 1. fx \\<in> aform_err e (acc_err p X err)", "by (auto simp: aform_err_def acc_err_def)"], ["", "lemma minus_times_le_abs: \"- (err * B) \\<le> \\<bar>B\\<bar>\" if \"-1 \\<le> err\" \"err \\<le> 1\" for err::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (err * B) \\<le> \\<bar>B\\<bar>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (err * B) \\<le> \\<bar>B\\<bar>", "have [simp]: \"abs err \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>err\\<bar> \\<le> 1", "using that"], ["proof (prove)\nusing this:\n  - 1 \\<le> err\n  err \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>err\\<bar> \\<le> 1", "by (auto simp: )"], ["proof (state)\nthis:\n  \\<bar>err\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. - (err * B) \\<le> \\<bar>B\\<bar>", "have \"- (err * B) \\<le> abs (- err * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (err * B) \\<le> \\<bar>- err * B\\<bar>", "by auto"], ["proof (state)\nthis:\n  - (err * B) \\<le> \\<bar>- err * B\\<bar>\n\ngoal (1 subgoal):\n 1. - (err * B) \\<le> \\<bar>B\\<bar>", "also"], ["proof (state)\nthis:\n  - (err * B) \\<le> \\<bar>- err * B\\<bar>\n\ngoal (1 subgoal):\n 1. - (err * B) \\<le> \\<bar>B\\<bar>", "have \"\\<dots> \\<le> abs B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>- err * B\\<bar> \\<le> \\<bar>B\\<bar>", "by (auto simp: abs_mult intro!: mult_left_le_one_le)"], ["proof (state)\nthis:\n  \\<bar>- err * B\\<bar> \\<le> \\<bar>B\\<bar>\n\ngoal (1 subgoal):\n 1. - (err * B) \\<le> \\<bar>B\\<bar>", "finally"], ["proof (chain)\npicking this:\n  - (err * B) \\<le> \\<bar>B\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  - (err * B) \\<le> \\<bar>B\\<bar>\n\ngoal (1 subgoal):\n 1. - (err * B) \\<le> \\<bar>B\\<bar>", "by simp"], ["proof (state)\nthis:\n  - (err * B) \\<le> \\<bar>B\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma times_le_abs: \"err * B \\<le> \\<bar>B\\<bar>\" if \"-1 \\<le> err\" \"err \\<le> 1\" for err::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. err * B \\<le> \\<bar>B\\<bar>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. err * B \\<le> \\<bar>B\\<bar>", "have [simp]: \"abs err \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>err\\<bar> \\<le> 1", "using that"], ["proof (prove)\nusing this:\n  - 1 \\<le> err\n  err \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>err\\<bar> \\<le> 1", "by (auto simp: )"], ["proof (state)\nthis:\n  \\<bar>err\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. err * B \\<le> \\<bar>B\\<bar>", "have \"err * B \\<le> abs (err * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. err * B \\<le> \\<bar>err * B\\<bar>", "by auto"], ["proof (state)\nthis:\n  err * B \\<le> \\<bar>err * B\\<bar>\n\ngoal (1 subgoal):\n 1. err * B \\<le> \\<bar>B\\<bar>", "also"], ["proof (state)\nthis:\n  err * B \\<le> \\<bar>err * B\\<bar>\n\ngoal (1 subgoal):\n 1. err * B \\<le> \\<bar>B\\<bar>", "have \"\\<dots> \\<le> abs B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>err * B\\<bar> \\<le> \\<bar>B\\<bar>", "by (auto simp: abs_mult intro!: mult_left_le_one_le)"], ["proof (state)\nthis:\n  \\<bar>err * B\\<bar> \\<le> \\<bar>B\\<bar>\n\ngoal (1 subgoal):\n 1. err * B \\<le> \\<bar>B\\<bar>", "finally"], ["proof (chain)\npicking this:\n  err * B \\<le> \\<bar>B\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  err * B \\<le> \\<bar>B\\<bar>\n\ngoal (1 subgoal):\n 1. err * B \\<le> \\<bar>B\\<bar>", "by simp"], ["proof (state)\nthis:\n  err * B \\<le> \\<bar>B\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aform_err_lemma1: \"- 1 \\<le> err \\<Longrightarrow> err \\<le> 1 \\<Longrightarrow>\n  X1 + (A - e d * B + err * B) - e1 \\<le> x \\<Longrightarrow>\n  X1 + (A - e d * B) - truncate_up p (\\<bar>B\\<bar> + e1) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> X1 + (A - e d * B) -\n                      truncate_up p (\\<bar>B\\<bar> + e1)\n                      \\<le> x", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> X1 + (A - e d * B) -\n                      truncate_up p (\\<bar>B\\<bar> + e1)\n                      \\<le> ?y\n 2. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> ?y \\<le> x", "apply (rule diff_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> X1 + (A - e d * B) \\<le> ?b3\n 2. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> ?d3 \\<le> truncate_up p (\\<bar>B\\<bar> + e1)\n 3. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> ?b3 - ?d3 \\<le> x", "apply (rule order_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> ?d3 \\<le> truncate_up p (\\<bar>B\\<bar> + e1)\n 2. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> X1 + (A - e d * B) - ?d3 \\<le> x", "apply (rule truncate_up_le[where x=\"e1 - err * B\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> e1 - err * B \\<le> \\<bar>B\\<bar> + e1\n 2. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     X1 + (A - e d * B + err * B) - e1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> X1 + (A - e d * B) - (e1 - err * B) \\<le> x", "by (auto simp: minus_times_le_abs)"], ["", "lemma aform_err_lemma2: \"- 1 \\<le> err \\<Longrightarrow> err \\<le> 1 \\<Longrightarrow>\n    x \\<le> X1 + (A - e d * B + err * B) + e1 \\<Longrightarrow>\n    x \\<le> X1 + (A - e d * B) + truncate_up p (\\<bar>B\\<bar> + e1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> x \\<le> X1 + (A - e d * B) +\n                              truncate_up p (\\<bar>B\\<bar> + e1)", "apply (rule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> ?y \\<le> X1 + (A - e d * B) +\n                               truncate_up p (\\<bar>B\\<bar> + e1)\n 2. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> x \\<le> ?y", "apply (rule add_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> ?a3 \\<le> X1 + (A - e d * B)\n 2. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> ?c3 \\<le> truncate_up p (\\<bar>B\\<bar> + e1)\n 3. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> x \\<le> ?a3 + ?c3", "apply (rule order_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> ?c3 \\<le> truncate_up p (\\<bar>B\\<bar> + e1)\n 2. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> x \\<le> X1 + (A - e d * B) + ?c3", "apply (rule truncate_up_le[where x=\"e1 + err * B\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> e1 + err * B \\<le> \\<bar>B\\<bar> + e1\n 2. \\<lbrakk>- 1 \\<le> err; err \\<le> 1;\n     x \\<le> X1 + (A - e d * B + err * B) + e1\\<rbrakk>\n    \\<Longrightarrow> x \\<le> X1 + (A - e d * B) + (e1 + err * B)", "by (auto simp: times_le_abs)"], ["", "lemma aform_err_acc_err_aform_to_aform_errI:\n  \"x \\<in> aform_err e (acc_err p (aform_to_aform_err X1 d) e1)\"\n  if \"-1 \\<le> err\" \"err \\<le> 1\" \"x \\<in> aform_err (e(d := err)) (X1, e1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> aform_err e (acc_err p (aform_to_aform_err X1 d) e1)", "using that"], ["proof (prove)\nusing this:\n  - 1 \\<le> err\n  err \\<le> 1\n  x \\<in> aform_err (e(d := err)) (X1, e1)\n\ngoal (1 subgoal):\n 1. x \\<in> aform_err e (acc_err p (aform_to_aform_err X1 d) e1)", "by (auto simp: acc_err_def aform_err_def aform_val_def aform_to_aform_err_def\n      aform_err_to_aform_def aform_err_lemma1 aform_err_lemma2)"], ["", "definition \"map_aform_err I p X =\n  (do {\n    let X0 = aform_err_to_aform X (degree_aform_err X);\n    (X1, e1) \\<leftarrow> I X0;\n    Some (acc_err p (aform_to_aform_err X1 (degree_aform_err X)) e1)\n  })\""], ["", "lemma map_aform_err:\n  \"i x \\<in> aform_err e Y\"\n  if I: \"\\<And>e X Y. e \\<in> UNIV \\<rightarrow> {-1 .. 1} \\<Longrightarrow> I X = Some Y \\<Longrightarrow> i (aform_val e X) \\<in> aform_err e Y\"\n  and e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  and Y: \"map_aform_err I p X = Some Y\"\n  and x: \"x \\<in> aform_err e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "obtain X1 e1 where\n    X1: \"(I (aform_err_to_aform X (degree_aform_err X))) = Some (X1, e1)\"\n    and Y: \"Y = acc_err p (aform_to_aform_err X1 (degree_aform (fst X))) e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X1 e1.\n        \\<lbrakk>I (aform_err_to_aform X (degree_aform_err X)) =\n                 Some (X1, e1);\n         Y =\n         acc_err p (aform_to_aform_err X1 (degree_aform_err X)) e1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Y"], ["proof (prove)\nusing this:\n  map_aform_err I p X = Some Y\n\ngoal (1 subgoal):\n 1. (\\<And>X1 e1.\n        \\<lbrakk>I (aform_err_to_aform X (degree_aform_err X)) =\n                 Some (X1, e1);\n         Y =\n         acc_err p (aform_to_aform_err X1 (degree_aform_err X)) e1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: map_aform_err_def bind_eq_Some_conv Let_def)"], ["proof (state)\nthis:\n  I (aform_err_to_aform X (degree_aform_err X)) = Some (X1, e1)\n  Y = acc_err p (aform_to_aform_err X1 (degree_aform_err X)) e1\n\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "from aform_err_to_aformE[OF x]"], ["proof (chain)\npicking this:\n  \\<lbrakk>degree_aform_err X \\<le> ?n;\n   \\<And>err.\n      \\<lbrakk>x = aform_val (e(?n := err)) (aform_err_to_aform X ?n);\n       - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain err where\n    err: \"x = aform_val (e(degree_aform_err X := err)) (aform_err_to_aform X  (degree_aform_err X)) \"\n    (is \"_ = aform_val ?e _\")\n    and \"- 1 \\<le> err\" \"err \\<le> 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>degree_aform_err X \\<le> ?n;\n   \\<And>err.\n      \\<lbrakk>x = aform_val (e(?n := err)) (aform_err_to_aform X ?n);\n       - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>x =\n                 aform_val (e(degree_aform_err X := err))\n                  (aform_err_to_aform X (degree_aform_err X));\n         - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x =\n  aform_val (e(degree_aform_err X := err))\n   (aform_err_to_aform X (degree_aform_err X))\n  - 1 \\<le> err\n  err \\<le> 1\n\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  x =\n  aform_val (e(degree_aform_err X := err))\n   (aform_err_to_aform X (degree_aform_err X))\n  - 1 \\<le> err\n  err \\<le> 1", "have e': \"?e \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  x =\n  aform_val (e(degree_aform_err X := err))\n   (aform_err_to_aform X (degree_aform_err X))\n  - 1 \\<le> err\n  err \\<le> 1\n\ngoal (1 subgoal):\n 1. e(degree_aform_err X := err) \\<in> UNIV \\<rightarrow> {- 1..1}", "using e"], ["proof (prove)\nusing this:\n  x =\n  aform_val (e(degree_aform_err X := err))\n   (aform_err_to_aform X (degree_aform_err X))\n  - 1 \\<le> err\n  err \\<le> 1\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. e(degree_aform_err X := err) \\<in> UNIV \\<rightarrow> {- 1..1}", "by auto"], ["proof (state)\nthis:\n  e(degree_aform_err X := err) \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "from err"], ["proof (chain)\npicking this:\n  x =\n  aform_val (e(degree_aform_err X := err))\n   (aform_err_to_aform X (degree_aform_err X))", "have \"i x =\n      i (aform_val (e(degree_aform_err X := err)) (aform_err_to_aform X  (degree_aform_err X)))\""], ["proof (prove)\nusing this:\n  x =\n  aform_val (e(degree_aform_err X := err))\n   (aform_err_to_aform X (degree_aform_err X))\n\ngoal (1 subgoal):\n 1. i x =\n    i (aform_val (e(degree_aform_err X := err))\n        (aform_err_to_aform X (degree_aform_err X)))", "by simp"], ["proof (state)\nthis:\n  i x =\n  i (aform_val (e(degree_aform_err X := err))\n      (aform_err_to_aform X (degree_aform_err X)))\n\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "also"], ["proof (state)\nthis:\n  i x =\n  i (aform_val (e(degree_aform_err X := err))\n      (aform_err_to_aform X (degree_aform_err X)))\n\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "note I[OF e' X1]"], ["proof (state)\nthis:\n  i (aform_val (e(degree_aform_err X := err))\n      (aform_err_to_aform X (degree_aform_err X)))\n  \\<in> aform_err (e(degree_aform_err X := err)) (X1, e1)\n\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "also"], ["proof (state)\nthis:\n  i (aform_val (e(degree_aform_err X := err))\n      (aform_err_to_aform X (degree_aform_err X)))\n  \\<in> aform_err (e(degree_aform_err X := err)) (X1, e1)\n\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "have \"aform_err (e(degree_aform_err X := err)) (X1, e1) \\<subseteq> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_err (e(degree_aform_err X := err)) (X1, e1)\n    \\<subseteq> aform_err e Y", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> aform_err (e(degree_aform_err X := err))\n                (X1, e1) \\<Longrightarrow>\n       x \\<in> aform_err e Y", "unfolding Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> aform_err (e(degree_aform_err X := err))\n                (X1, e1) \\<Longrightarrow>\n       x \\<in> aform_err e\n                (acc_err p (aform_to_aform_err X1 (degree_aform_err X)) e1)", "using \\<open>-1 \\<le> err\\<close> \\<open>err \\<le> 1\\<close>"], ["proof (prove)\nusing this:\n  - 1 \\<le> err\n  err \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> aform_err (e(degree_aform_err X := err))\n                (X1, e1) \\<Longrightarrow>\n       x \\<in> aform_err e\n                (acc_err p (aform_to_aform_err X1 (degree_aform_err X)) e1)", "by (rule aform_err_acc_err_aform_to_aform_errI)"], ["proof (state)\nthis:\n  aform_err (e(degree_aform_err X := err)) (X1, e1)\n  \\<subseteq> aform_err e Y\n\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "finally"], ["proof (chain)\npicking this:\n  i x \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  i x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. i x \\<in> aform_err e Y", "."], ["proof (state)\nthis:\n  i x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"inverse_aform_err p X = map_aform_err (inverse_aform p) p X\""], ["", "lemma inverse_aform_err:\n  \"inverse x \\<in> aform_err e Y\"\n  if  e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  and Y: \"inverse_aform_err p X = Some Y\"\n  and x: \"x \\<in> aform_err e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e Y", "using map_aform_err[OF inverse_aform[where p=p] e Y[unfolded inverse_aform_err_def] x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>e X Y.\n              \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n               inverse_aform p X = Some Y\\<rbrakk>\n              \\<Longrightarrow> e \\<in> UNIV \\<rightarrow> {- 1..1};\n   \\<And>e X Y.\n      \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n       inverse_aform p X = Some Y\\<rbrakk>\n      \\<Longrightarrow> inverse_aform p X = Some Y\\<rbrakk>\n  \\<Longrightarrow> inverse x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. inverse x \\<in> aform_err e Y", "by auto"], ["", "subsection \\<open>Reduction (Summarization of Coefficients)\\<close>"], ["", "text \\<open>\\label{sec:affinesummarize}\\<close>"], ["", "definition \"pdevs_of_centered_ivl r = (inner_scaleR_pdevs r One_pdevs)\""], ["", "lemma pdevs_of_centered_ivl_eq_pdevs_of_ivl[simp]: \"pdevs_of_centered_ivl r = pdevs_of_ivl (-r) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_centered_ivl r = pdevs_of_ivl (- r) r", "by (auto simp: pdevs_of_centered_ivl_def pdevs_of_ivl_def algebra_simps intro!: pdevs_eqI)"], ["", "lemma filter_pdevs_raw_nonzeros: \"{i. filter_pdevs_raw s f i \\<noteq> 0} = {i. f i \\<noteq> 0} \\<inter> {x. s x (f x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. filter_pdevs_raw s f i \\<noteq> (0::'a)} =\n    {i. f i \\<noteq> (0::'a)} \\<inter> {x. s x (f x)}", "by (auto simp: filter_pdevs_raw_def)"], ["", "definition summarize_pdevs::\n  \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> nat \\<Rightarrow> 'a::executable_euclidean_space pdevs \\<Rightarrow> 'a pdevs\"\n  where \"summarize_pdevs p I d x =\n    (let t = tdev' p (filter_pdevs (-I) x)\n     in msum_pdevs d (filter_pdevs I x) (pdevs_of_centered_ivl t))\""], ["", "definition summarize_threshold\n  where \"summarize_threshold p t x y \\<longleftrightarrow> infnorm y \\<ge> t * infnorm (eucl_truncate_up p (tdev' p x))\""], ["", "lemma error_abs_euclE:\n  fixes err::\"'a::ordered_euclidean_space\"\n  assumes \"abs err \\<le> k\"\n  obtains e::\"'a \\<Rightarrow> real\" where \"err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i)\" \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>err =\n                 (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i);\n         e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "fix i::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "assume \"i \\<in> Basis\""], ["proof (state)\nthis:\n  i \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "hence \"abs (err \\<bullet> i) \\<le> (k \\<bullet> i)\""], ["proof (prove)\nusing this:\n  i \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<bar>err \\<bullet> i\\<bar> \\<le> k \\<bullet> i", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> Basis\n  \\<bar>err\\<bar> \\<le> k\n\ngoal (1 subgoal):\n 1. \\<bar>err \\<bullet> i\\<bar> \\<le> k \\<bullet> i", "by (auto simp add: eucl_le[where 'a='a] abs_inner)"], ["proof (state)\nthis:\n  \\<bar>err \\<bullet> i\\<bar> \\<le> k \\<bullet> i\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "hence \"\\<exists>e. (err  \\<bullet> i = e * (k \\<bullet> i)) \\<and> e \\<in> {-1..1}\""], ["proof (prove)\nusing this:\n  \\<bar>err \\<bullet> i\\<bar> \\<le> k \\<bullet> i\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err \\<bullet> i = e * (k \\<bullet> i) \\<and> e \\<in> {- 1..1}", "by (rule error_absE) auto"], ["proof (state)\nthis:\n  \\<exists>e. err \\<bullet> i = e * (k \\<bullet> i) \\<and> e \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> Basis \\<Longrightarrow>\n  \\<exists>e.\n     err \\<bullet> ?i2 = e * (k \\<bullet> ?i2) \\<and> e \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "then"], ["proof (chain)\npicking this:\n  ?i2 \\<in> Basis \\<Longrightarrow>\n  \\<exists>e.\n     err \\<bullet> ?i2 = e * (k \\<bullet> ?i2) \\<and> e \\<in> {- 1..1}", "obtain e where e:\n    \"\\<And>i. i \\<in> Basis \\<Longrightarrow> err \\<bullet> i = e i * (k \\<bullet> i)\"\n    \"\\<And>i. i \\<in> Basis \\<Longrightarrow> e i \\<in> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  ?i2 \\<in> Basis \\<Longrightarrow>\n  \\<exists>e.\n     err \\<bullet> ?i2 = e * (k \\<bullet> ?i2) \\<and> e \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>\\<And>i.\n                    i \\<in> Basis \\<Longrightarrow>\n                    err \\<bullet> i = e i * (k \\<bullet> i);\n         \\<And>i.\n            i \\<in> Basis \\<Longrightarrow> e i \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?i \\<in> Basis \\<Longrightarrow>\n  err \\<bullet> ?i = e ?i * (k \\<bullet> ?i)\n  ?i \\<in> Basis \\<Longrightarrow> e ?i \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "have singleton: \"\\<And>b. b \\<in> Basis \\<Longrightarrow> (\\<Sum>i\\<in>Basis. e i * (k \\<bullet> i) * (if i = b then 1 else 0)) =\n    (\\<Sum>i\\<in>{b}. e i * (k \\<bullet> i) * (if i = b then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow>\n       (\\<Sum>i\\<in>Basis.\n          e i * (k \\<bullet> i) * (if i = b then 1 else 0)) =\n       (\\<Sum>i\\<in>{b}. e i * (k \\<bullet> i) * (if i = b then 1 else 0))", "by (rule sum.mono_neutral_cong_right) auto"], ["proof (state)\nthis:\n  ?b \\<in> Basis \\<Longrightarrow>\n  (\\<Sum>i\\<in>Basis. e i * (k \\<bullet> i) * (if i = ?b then 1 else 0)) =\n  (\\<Sum>i\\<in>{?b}. e i * (k \\<bullet> i) * (if i = ?b then 1 else 0))\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "show \"\\<exists>e::'a\\<Rightarrow>real. err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and> (e \\<in> UNIV \\<rightarrow> {-1..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "using e"], ["proof (prove)\nusing this:\n  ?i \\<in> Basis \\<Longrightarrow>\n  err \\<bullet> ?i = e ?i * (k \\<bullet> ?i)\n  ?i \\<in> Basis \\<Longrightarrow> e ?i \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n       e \\<in> UNIV \\<rightarrow> {- 1..1}", "by (auto intro!: exI[where x=\"\\<lambda>i. if i \\<in> Basis then e i else 0\"] euclidean_eqI[where 'a='a]\n      simp: inner_sum_left inner_Basis singleton)"], ["proof (state)\nthis:\n  \\<exists>e.\n     err = (\\<Sum>i\\<in>Basis. (e i * (k \\<bullet> i)) *\\<^sub>R i) \\<and>\n     e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma summarize_pdevsE:\n  fixes x::\"'a::executable_euclidean_space pdevs\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes d: \"degree x \\<le> d\"\n  obtains e' where \"pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x)\"\n    \"\\<And>i. i < d \\<Longrightarrow> e i = e' i\"\n    \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"pdevs_val e x = (\\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e x = (\\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i)", "by (auto simp add: pdevs_val_sum intro!: sum.cong)"], ["proof (state)\nthis:\n  pdevs_val e x = (\\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "also"], ["proof (state)\nthis:\n  pdevs_val e x = (\\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"\\<dots> = (\\<Sum>i \\<in> {..<degree x} \\<inter> {i. I i (pdevs_apply x i)}. e i *\\<^sub>R pdevs_apply x i) +\n    (\\<Sum>i\\<in> {..<degree x} - {i. I i (pdevs_apply x i)}. e i *\\<^sub>R pdevs_apply x i)\"\n    (is \"_ = ?large + ?small\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) =\n    (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_apply x i)}.\n       e i *\\<^sub>R pdevs_apply x i) +\n    (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_apply x i)}.\n       e i *\\<^sub>R pdevs_apply x i)", "by (subst sum.union_disjoint[symmetric]) (auto simp: ac_simps intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) =\n  (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_apply x i)}.\n     e i *\\<^sub>R pdevs_apply x i) +\n  (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_apply x i)}.\n     e i *\\<^sub>R pdevs_apply x i)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) =\n  (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_apply x i)}.\n     e i *\\<^sub>R pdevs_apply x i) +\n  (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_apply x i)}.\n     e i *\\<^sub>R pdevs_apply x i)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"?large = pdevs_val e (filter_pdevs I x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_apply x i)}.\n       e i *\\<^sub>R pdevs_apply x i) =\n    pdevs_val e (filter_pdevs I x)", "by (simp add: pdevs_val_filter_pdevs)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_apply x i)}.\n     e i *\\<^sub>R pdevs_apply x i) =\n  pdevs_val e (filter_pdevs I x)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_apply x i)}.\n     e i *\\<^sub>R pdevs_apply x i) =\n  pdevs_val e (filter_pdevs I x)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"?small = pdevs_val e (filter_pdevs (-I) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_apply x i)}.\n       e i *\\<^sub>R pdevs_apply x i) =\n    pdevs_val e (filter_pdevs (- I) x)", "by (simp add: pdevs_val_filter_pdevs Collect_neg_eq Diff_eq)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_apply x i)}.\n     e i *\\<^sub>R pdevs_apply x i) =\n  pdevs_val e (filter_pdevs (- I) x)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_apply x i)}.\n     e i *\\<^sub>R pdevs_apply x i) =\n  pdevs_val e (filter_pdevs (- I) x)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"abs \\<dots> \\<le> tdev' p (filter_pdevs (-I) x)\" (is \"abs ?r \\<le> ?t\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e (filter_pdevs (- I) x)\\<bar>\n    \\<le> tdev' p (filter_pdevs (- I) x)", "using e"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e (filter_pdevs (- I) x)\\<bar>\n    \\<le> tdev' p (filter_pdevs (- I) x)", "by (rule abs_pdevs_val_le_tdev')"], ["proof (state)\nthis:\n  \\<bar>pdevs_val e (filter_pdevs (- I) x)\\<bar>\n  \\<le> tdev' p (filter_pdevs (- I) x)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "hence \"?r \\<in> {-?t .. ?t}\""], ["proof (prove)\nusing this:\n  \\<bar>pdevs_val e (filter_pdevs (- I) x)\\<bar>\n  \\<le> tdev' p (filter_pdevs (- I) x)\n\ngoal (1 subgoal):\n 1. pdevs_val e (filter_pdevs (- I) x)\n    \\<in> {- tdev' p (filter_pdevs (- I) x)..tdev' p (filter_pdevs (- I) x)}", "by (metis abs_le_D1 abs_le_D2 atLeastAtMost_iff minus_le_iff)"], ["proof (state)\nthis:\n  pdevs_val e (filter_pdevs (- I) x)\n  \\<in> {- tdev' p (filter_pdevs (- I) x)..tdev' p (filter_pdevs (- I) x)}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "from in_ivl_affine_of_ivlE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>ea.\n      \\<lbrakk>ea \\<in> UNIV \\<rightarrow> {- 1..1};\n       pdevs_val e (filter_pdevs (- I) x) =\n       aform_val ea\n        (aform_of_ivl (- tdev' p (filter_pdevs (- I) x))\n          (tdev' p (filter_pdevs (- I) x)))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e2\n    where \"?r = aform_val e2 (aform_of_ivl (- ?t) ?t)\"\n      and e2: \"e2 \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  (\\<And>ea.\n      \\<lbrakk>ea \\<in> UNIV \\<rightarrow> {- 1..1};\n       pdevs_val e (filter_pdevs (- I) x) =\n       aform_val ea\n        (aform_of_ivl (- tdev' p (filter_pdevs (- I) x))\n          (tdev' p (filter_pdevs (- I) x)))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e2.\n        \\<lbrakk>pdevs_val e (filter_pdevs (- I) x) =\n                 aform_val e2\n                  (aform_of_ivl (- tdev' p (filter_pdevs (- I) x))\n                    (tdev' p (filter_pdevs (- I) x)));\n         e2 \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  pdevs_val e (filter_pdevs (- I) x) =\n  aform_val e2\n   (aform_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x)))\n  e2 \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val e (filter_pdevs (- I) x) =\n  aform_val e2\n   (aform_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x)))\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "also"], ["proof (state)\nthis:\n  pdevs_val e (filter_pdevs (- I) x) =\n  aform_val e2\n   (aform_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x)))\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "define e' where \"e' i = (if i < d then e i else e2 (i - d))\" for i"], ["proof (state)\nthis:\n  e' ?i = (if ?i < d then e ?i else e2 (?i - d))\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "hence \"aform_val e2 (aform_of_ivl (- ?t) ?t) =\n      pdevs_val (\\<lambda>i. e' (i + d)) (pdevs_of_ivl (- ?t) ?t)\""], ["proof (prove)\nusing this:\n  e' ?i = (if ?i < d then e ?i else e2 (?i - d))\n\ngoal (1 subgoal):\n 1. aform_val e2\n     (aform_of_ivl (- tdev' p (filter_pdevs (- I) x))\n       (tdev' p (filter_pdevs (- I) x))) =\n    pdevs_val (\\<lambda>i. e' (i + d))\n     (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n       (tdev' p (filter_pdevs (- I) x)))", "by (auto simp: aform_of_ivl_def aform_val_def)"], ["proof (state)\nthis:\n  aform_val e2\n   (aform_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x))) =\n  pdevs_val (\\<lambda>i. e' (i + d))\n   (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x)))\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "also"], ["proof (state)\nthis:\n  aform_val e2\n   (aform_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x))) =\n  pdevs_val (\\<lambda>i. e' (i + d))\n   (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x)))\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"pdevs_val e (filter_pdevs I x) = pdevs_val e' (filter_pdevs I x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (filter_pdevs I x) = pdevs_val e' (filter_pdevs I x)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  degree x \\<le> d\n\ngoal (1 subgoal):\n 1. pdevs_val e (filter_pdevs I x) = pdevs_val e' (filter_pdevs I x)", "by (auto simp: e'_def pdevs_val_sum intro!: sum.cong)"], ["proof (state)\nthis:\n  pdevs_val e (filter_pdevs I x) = pdevs_val e' (filter_pdevs I x)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e x =\n  pdevs_val e' (filter_pdevs I x) +\n  pdevs_val (\\<lambda>i. e' (i + d))\n   (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x)))", "have \"pdevs_val e x =\n      pdevs_val e' (filter_pdevs I x) + pdevs_val (\\<lambda>i. e' (i + d)) (pdevs_of_ivl (- ?t) ?t)\""], ["proof (prove)\nusing this:\n  pdevs_val e x =\n  pdevs_val e' (filter_pdevs I x) +\n  pdevs_val (\\<lambda>i. e' (i + d))\n   (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x)))\n\ngoal (1 subgoal):\n 1. pdevs_val e x =\n    pdevs_val e' (filter_pdevs I x) +\n    pdevs_val (\\<lambda>i. e' (i + d))\n     (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n       (tdev' p (filter_pdevs (- I) x)))", "."], ["proof (state)\nthis:\n  pdevs_val e x =\n  pdevs_val e' (filter_pdevs I x) +\n  pdevs_val (\\<lambda>i. e' (i + d))\n   (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x)))\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "also"], ["proof (state)\nthis:\n  pdevs_val e x =\n  pdevs_val e' (filter_pdevs I x) +\n  pdevs_val (\\<lambda>i. e' (i + d))\n   (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n     (tdev' p (filter_pdevs (- I) x)))\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "note pdevs_val_msum_pdevs[symmetric, OF order_trans[OF degree_filter_pdevs_le d]]"], ["proof (state)\nthis:\n  pdevs_val ?e (filter_pdevs ?I2 x) +\n  pdevs_val (\\<lambda>i. ?e (i + d)) ?g =\n  pdevs_val ?e (msum_pdevs d (filter_pdevs ?I2 x) ?g)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e x =\n  pdevs_val e'\n   (msum_pdevs d (filter_pdevs I x)\n     (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n       (tdev' p (filter_pdevs (- I) x))))", "have \"pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x)\""], ["proof (prove)\nusing this:\n  pdevs_val e x =\n  pdevs_val e'\n   (msum_pdevs d (filter_pdevs I x)\n     (pdevs_of_ivl (- tdev' p (filter_pdevs (- I) x))\n       (tdev' p (filter_pdevs (- I) x))))\n\ngoal (1 subgoal):\n 1. pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x)", "by (auto simp: summarize_pdevs_def Let_def)"], ["proof (state)\nthis:\n  pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "moreover"], ["proof (state)\nthis:\n  pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e' \\<in> UNIV \\<rightarrow> {- 1..1}", "using e e2"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  e2 \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. e' \\<in> UNIV \\<rightarrow> {- 1..1}", "by (auto simp: e'_def Pi_iff)"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "moreover"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "have \"\\<forall>i < d. e' i = e i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<d. e' i = e i", "by (auto simp: e'_def)"], ["proof (state)\nthis:\n  \\<forall>i<d. e' i = e i\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "ultimately"], ["proof (chain)\npicking this:\n  pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x)\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  \\<forall>i<d. e' i = e i", "show \"\\<exists>e'. pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n      (\\<forall>i<d. e i = e' i) \\<and> e' \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\nusing this:\n  pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x)\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  \\<forall>i<d. e' i = e i\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n       (\\<forall>i<d. e i = e' i) \\<and>\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}", "by auto"], ["proof (state)\nthis:\n  \\<exists>e'.\n     pdevs_val e x = pdevs_val e' (summarize_pdevs p I d x) \\<and>\n     (\\<forall>i<d. e i = e' i) \\<and> e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"summarize_pdevs_list p I d xs =\n  map (\\<lambda>(d, x). summarize_pdevs p (\\<lambda>i _. I i (pdevs_applys xs i)) d x) (zip [d..<d + length xs] xs)\""], ["", "lemma filter_pdevs_cong[cong]:\n  assumes \"x = y\"\n  assumes \"\\<And>i. i \\<in> pdevs_domain y \\<Longrightarrow> P i (pdevs_apply x i) = Q i (pdevs_apply y i)\"\n  shows \"filter_pdevs P x = filter_pdevs Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_pdevs P x = filter_pdevs Q y", "using assms"], ["proof (prove)\nusing this:\n  x = y\n  ?i \\<in> pdevs_domain y \\<Longrightarrow>\n  P ?i (pdevs_apply x ?i) = Q ?i (pdevs_apply y ?i)\n\ngoal (1 subgoal):\n 1. filter_pdevs P x = filter_pdevs Q y", "by (force intro!: pdevs_eqI)"], ["", "lemma summarize_pdevs_cong[cong]:\n  assumes \"p = q\" \"a = c\" \"b = d\"\n  assumes PQ: \"\\<And>i. i \\<in> pdevs_domain d \\<Longrightarrow> P i (pdevs_apply b i) = Q i (pdevs_apply d i)\"\n  shows \"summarize_pdevs p P a b = summarize_pdevs q Q c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summarize_pdevs p P a b = summarize_pdevs q Q c d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. summarize_pdevs p P a b = summarize_pdevs q Q c d", "have \"(filter_pdevs P b) = filter_pdevs Q d\"\n    \"(filter_pdevs (\\<lambda>a b. \\<not> P a b) b) = filter_pdevs (\\<lambda>a b. \\<not> Q a b) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_pdevs P b = filter_pdevs Q d &&&\n    filter_pdevs (\\<lambda>a b. \\<not> P a b) b =\n    filter_pdevs (\\<lambda>a b. \\<not> Q a b) d", "using assms"], ["proof (prove)\nusing this:\n  p = q\n  a = c\n  b = d\n  ?i \\<in> pdevs_domain d \\<Longrightarrow>\n  P ?i (pdevs_apply b ?i) = Q ?i (pdevs_apply d ?i)\n\ngoal (1 subgoal):\n 1. filter_pdevs P b = filter_pdevs Q d &&&\n    filter_pdevs (\\<lambda>a b. \\<not> P a b) b =\n    filter_pdevs (\\<lambda>a b. \\<not> Q a b) d", "by (auto intro!: filter_pdevs_cong)"], ["proof (state)\nthis:\n  filter_pdevs P b = filter_pdevs Q d\n  filter_pdevs (\\<lambda>a b. \\<not> P a b) b =\n  filter_pdevs (\\<lambda>a b. \\<not> Q a b) d\n\ngoal (1 subgoal):\n 1. summarize_pdevs p P a b = summarize_pdevs q Q c d", "then"], ["proof (chain)\npicking this:\n  filter_pdevs P b = filter_pdevs Q d\n  filter_pdevs (\\<lambda>a b. \\<not> P a b) b =\n  filter_pdevs (\\<lambda>a b. \\<not> Q a b) d", "show ?thesis"], ["proof (prove)\nusing this:\n  filter_pdevs P b = filter_pdevs Q d\n  filter_pdevs (\\<lambda>a b. \\<not> P a b) b =\n  filter_pdevs (\\<lambda>a b. \\<not> Q a b) d\n\ngoal (1 subgoal):\n 1. summarize_pdevs p P a b = summarize_pdevs q Q c d", "by (auto simp add: assms summarize_pdevs_def Let_def)"], ["proof (state)\nthis:\n  summarize_pdevs p P a b = summarize_pdevs q Q c d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_eq_None_iff: \"(Mapping.lookup M x = None) = (x \\<notin> Mapping.keys M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mapping.lookup M x = None) = (x \\<notin> Mapping.keys M)", "by (transfer) auto"], ["", "lemma lookup_eq_SomeD:\n  \"(Mapping.lookup M x = Some y) \\<Longrightarrow> (x \\<in> Mapping.keys M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup M x = Some y \\<Longrightarrow> x \\<in> Mapping.keys M", "by transfer auto"], ["", "definition \"domain_pdevs xs = (\\<Union>(pdevs_domain ` (set xs)))\""], ["", "definition \"pdevs_mapping xs =\n  (let\n    D = sorted_list_of_set (domain_pdevs xs);\n    M = Mapping.tabulate D (pdevs_applys xs);\n    zeroes = replicate (length xs) 0\n  in Mapping.lookup_default zeroes M)\""], ["", "lemma pdevs_mapping_eq[simp]: \"pdevs_mapping xs = pdevs_applys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_mapping xs = pdevs_applys xs", "unfolding pdevs_mapping_def pdevs_applys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let D = sorted_list_of_set (domain_pdevs xs);\n         M = Mapping.tabulate D\n              (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs);\n         zeroes = replicate (length xs) (0::'a)\n     in Mapping.lookup_default zeroes M) =\n    (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs)", "apply (auto simp: Mapping.lookup_default_def lookup_eq_None_iff domain_pdevs_def\n      split: option.splits intro!: ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<forall>x\\<in>set xs. pdevs_apply x i = (0::'a) \\<Longrightarrow>\n       replicate (length xs) (0::'a) = map (\\<lambda>x. pdevs_apply x i) xs\n 2. \\<And>i x2.\n       Mapping.lookup\n        (Mapping.tabulate\n          (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n          (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n        i =\n       Some x2 \\<Longrightarrow>\n       x2 = map (\\<lambda>x. pdevs_apply x i) xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. pdevs_apply x i_ = (0::'a) \\<Longrightarrow>\n    replicate (length xs) (0::'a) = map (\\<lambda>x. pdevs_apply x i_) xs", "by (auto intro!: nth_equalityI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x2.\n       Mapping.lookup\n        (Mapping.tabulate\n          (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n          (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n        i =\n       Some x2 \\<Longrightarrow>\n       x2 = map (\\<lambda>x. pdevs_apply x i) xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (Mapping.tabulate\n       (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n       (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n     i_ =\n    Some x2_ \\<Longrightarrow>\n    x2_ = map (\\<lambda>x. pdevs_apply x i_) xs", "apply (auto intro!: nth_equalityI dest: )"], ["proof (prove)\ngoal (2 subgoals):\n 1. Mapping.lookup\n     (Mapping.tabulate\n       (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n       (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n     i_ =\n    Some x2_ \\<Longrightarrow>\n    length x2_ = length xs\n 2. \\<And>ia.\n       \\<lbrakk>Mapping.lookup\n                 (Mapping.tabulate\n                   (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n                   (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n                 i_ =\n                Some x2_;\n        ia < length x2_\\<rbrakk>\n       \\<Longrightarrow> x2_ ! ia =\n                         map (\\<lambda>x. pdevs_apply x i_) xs ! ia", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (Mapping.tabulate\n       (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n       (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n     i_ =\n    Some x2_ \\<Longrightarrow>\n    length x2_ = length xs", "apply (frule lookup_eq_SomeD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Mapping.lookup\n              (Mapping.tabulate\n                (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n                (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n              i_ =\n             Some x2_;\n     i_ \\<in> Mapping.keys\n               (Mapping.tabulate\n                 (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n                 (\\<lambda>i.\n                     map (\\<lambda>x. pdevs_apply x i) xs))\\<rbrakk>\n    \\<Longrightarrow> length x2_ = length xs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Mapping.lookup\n                 (Mapping.tabulate\n                   (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n                   (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n                 i_ =\n                Some x2_;\n        x \\<in> set xs; pdevs_apply x i_ \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> length x2_ = length xs", "by (metis distinct_sorted_list_of_set keys_tabulate length_map lookup_eq_SomeD lookup_tabulate option.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>Mapping.lookup\n                 (Mapping.tabulate\n                   (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n                   (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n                 i_ =\n                Some x2_;\n        ia < length x2_\\<rbrakk>\n       \\<Longrightarrow> x2_ ! ia =\n                         map (\\<lambda>x. pdevs_apply x i_) xs ! ia", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Mapping.lookup\n              (Mapping.tabulate\n                (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n                (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n              i_ =\n             Some x2_;\n     ia_ < length x2_\\<rbrakk>\n    \\<Longrightarrow> x2_ ! ia_ =\n                      map (\\<lambda>x. pdevs_apply x i_) xs ! ia_", "apply (frule lookup_eq_SomeD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Mapping.lookup\n              (Mapping.tabulate\n                (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n                (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n              i_ =\n             Some x2_;\n     ia_ < length x2_;\n     i_ \\<in> Mapping.keys\n               (Mapping.tabulate\n                 (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n                 (\\<lambda>i.\n                     map (\\<lambda>x. pdevs_apply x i) xs))\\<rbrakk>\n    \\<Longrightarrow> x2_ ! ia_ =\n                      map (\\<lambda>x. pdevs_apply x i_) xs ! ia_", "apply (auto simp: map_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Mapping.lookup\n                 (Mapping.tabulate\n                   (sorted_list_of_set (\\<Union> (pdevs_domain ` set xs)))\n                   (\\<lambda>i. map (\\<lambda>x. pdevs_apply x i) xs))\n                 i_ =\n                Some x2_;\n        ia_ < length x2_; x \\<in> set xs;\n        pdevs_apply x i_ \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x2_ ! ia_ =\n                         map (\\<lambda>x. pdevs_apply x i_) xs ! ia_", "by (metis (mono_tags, lifting) keys_tabulate\n          lookup_eq_SomeD lookup_tabulate option.inject distinct_sorted_list_of_set)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_summarize_pdevs_list[code]:\n  \"summarize_pdevs_list p I d xs =\n    (let M = pdevs_mapping xs\n    in map (\\<lambda>(x, y). summarize_pdevs p (\\<lambda>i _. I i (M i)) x y) (zip [d..<d + length xs] xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summarize_pdevs_list p I d xs =\n    (let M = pdevs_mapping xs\n     in map2 (summarize_pdevs p (\\<lambda>i _. I i (M i)))\n         [d..<d + length xs] xs)", "unfolding summarize_pdevs_list_def pdevs_mapping_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (summarize_pdevs p (\\<lambda>i _. I i (pdevs_applys xs i)))\n     [d..<d + length xs] xs =\n    (let M = pdevs_applys xs\n     in map2 (summarize_pdevs p (\\<lambda>i _. I i (M i)))\n         [d..<d + length xs] xs)", "by auto"], ["", "lemma\n  in_centered_ivlE:\n  fixes r t::real\n  assumes \"r \\<in> {-t .. t}\"\n  obtains e where \"e \\<in> {-1 .. 1}\" \"r = e * t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> {- 1..1}; r = e * t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  r \\<in> {- t..t}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> {- 1..1}; r = e * t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim) (auto intro!: exI[where x=\"r / t\"] simp: divide_simps)"], ["", "lift_definition singleton_pdevs::\"'a \\<Rightarrow> 'a::real_normed_vector pdevs\" is \"\\<lambda>x i. if i = 0 then x else 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. finite {i. (if i = 0 then a else (0::'a)) \\<noteq> (0::'a)}", "by auto"], ["", "lemmas [simp] = singleton_pdevs.rep_eq"], ["", "lemma singleton_0[simp]: \"singleton_pdevs 0 = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton_pdevs (0::'a) = zero_pdevs", "by (auto intro!: pdevs_eqI)"], ["", "lemma degree_singleton_pdevs[simp]: \"degree (singleton_pdevs x) = (if x = 0 then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (singleton_pdevs x) = (if x = (0::'a) then 0 else Suc 0)", "by (auto simp: intro!: degree_eqI)"], ["", "lemma pdevs_val_singleton_pdevs[simp]: \"pdevs_val e (singleton_pdevs x) = e 0 *\\<^sub>R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (singleton_pdevs x) = e 0 *\\<^sub>R x", "by (auto simp: pdevs_val_sum if_distrib sum.delta cong: if_cong)"], ["", "lemma pdevs_of_ivl_real:\n  fixes a b::real\n  shows \"pdevs_of_ivl a b = singleton_pdevs ((b - a) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_ivl a b = singleton_pdevs ((b - a) / 2)", "by (auto simp: pdevs_of_ivl_def Basis_list_real_def intro!: pdevs_eqI)"], ["", "lemma summarize_pdevs_listE:\n  fixes X::\"real pdevs list\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes d: \"degrees X \\<le> d\"\n  obtains e' where \"pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)\"\n    \"\\<And>i. i < d \\<Longrightarrow> e i = e' i\"\n    \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?I = \"{i. I i (pdevs_applys X i)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?J = \"\\<lambda>i x. I i (pdevs_applys X i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"pdevs_vals e X = map (\\<lambda>x. \\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_vals e X =\n    map (\\<lambda>x. \\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) X", "using d"], ["proof (prove)\nusing this:\n  degrees X \\<le> d\n\ngoal (1 subgoal):\n 1. pdevs_vals e X =\n    map (\\<lambda>x. \\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) X", "by (auto simp: pdevs_vals_def\n        simp del: real_scaleR_def\n        intro!: pdevs_val_sum_le\n        dest!: degrees_leD)"], ["proof (state)\nthis:\n  pdevs_vals e X =\n  map (\\<lambda>x. \\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_vals e X =\n  map (\\<lambda>x. \\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = map (\\<lambda>x.\n      (\\<Sum>i\\<in>{..<degree x} \\<inter> ?I. e i * pdevs_apply x i) +\n      (\\<Sum>i\\<in>{..<degree x} - ?I. e i * pdevs_apply x i)) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. \\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) X =\n    map (\\<lambda>x.\n            (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_applys X i)}.\n               e i * pdevs_apply x i) +\n            (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_applys X i)}.\n               e i * pdevs_apply x i))\n     X", "by (rule map_cong[OF refl], subst sum.union_disjoint[symmetric]) (auto intro!: sum.cong)"], ["proof (state)\nthis:\n  map (\\<lambda>x. \\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) X =\n  map (\\<lambda>x.\n          (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_applys X i)}.\n             e i * pdevs_apply x i) +\n          (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_applys X i)}.\n             e i * pdevs_apply x i))\n   X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map (\\<lambda>x. \\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i) X =\n  map (\\<lambda>x.\n          (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_applys X i)}.\n             e i * pdevs_apply x i) +\n          (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_applys X i)}.\n             e i * pdevs_apply x i))\n   X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = map (\\<lambda>x. pdevs_val e (filter_pdevs ?J x) + pdevs_val e (filter_pdevs (-?J) x)) X\"\n    (is \"_ = map (\\<lambda>x. ?large x + ?small x) _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x.\n            (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_applys X i)}.\n               e i * pdevs_apply x i) +\n            (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_applys X i)}.\n               e i * pdevs_apply x i))\n     X =\n    map (\\<lambda>x.\n            pdevs_val e\n             (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n            pdevs_val e\n             (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n     X", "by (auto simp: pdevs_val_filter_pdevs Diff_eq Compl_eq)"], ["proof (state)\nthis:\n  map (\\<lambda>x.\n          (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_applys X i)}.\n             e i * pdevs_apply x i) +\n          (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_applys X i)}.\n             e i * pdevs_apply x i))\n   X =\n  map (\\<lambda>x.\n          pdevs_val e\n           (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n          pdevs_val e\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n   X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map (\\<lambda>x.\n          (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_applys X i)}.\n             e i * pdevs_apply x i) +\n          (\\<Sum>i\\<in>{..<degree x} - {i. I i (pdevs_applys X i)}.\n             e i * pdevs_apply x i))\n   X =\n  map (\\<lambda>x.\n          pdevs_val e\n           (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n          pdevs_val e\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n   X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = map snd (zip [d..<d + length X] \\<dots>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x.\n            pdevs_val e\n             (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n            pdevs_val e\n             (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n     X =\n    map snd\n     (zip [d..<d + length X]\n       (map (\\<lambda>x.\n                pdevs_val e\n                 (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n                pdevs_val e\n                 (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                   x))\n         X))", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>x.\n          pdevs_val e\n           (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n          pdevs_val e\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n   X =\n  map snd\n   (zip [d..<d + length X]\n     (map (\\<lambda>x.\n              pdevs_val e\n               (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n              pdevs_val e\n               (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n       X))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map (\\<lambda>x.\n          pdevs_val e\n           (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n          pdevs_val e\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n   X =\n  map snd\n   (zip [d..<d + length X]\n     (map (\\<lambda>x.\n              pdevs_val e\n               (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n              pdevs_val e\n               (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n       X))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = map (\\<lambda>(d, x). ?large x + ?small x) (zip [d..<d + length X] X)\"\n    (is \"_ = map _ ?z\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd\n     (zip [d..<d + length X]\n       (map (\\<lambda>x.\n                pdevs_val e\n                 (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n                pdevs_val e\n                 (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                   x))\n         X)) =\n    map2\n     (\\<lambda>d x.\n         pdevs_val e\n          (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n         pdevs_val e\n          (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n     [d..<d + length X] X", "unfolding map_zip_map2"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2\n     (\\<lambda>x y.\n         snd (x, pdevs_val e\n                  (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) y) +\n                 pdevs_val e\n                  (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                    y)))\n     [d..<d + length X] X =\n    map2\n     (\\<lambda>d x.\n         pdevs_val e\n          (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n         pdevs_val e\n          (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n     [d..<d + length X] X", "by simp"], ["proof (state)\nthis:\n  map snd\n   (zip [d..<d + length X]\n     (map (\\<lambda>x.\n              pdevs_val e\n               (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n              pdevs_val e\n               (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n       X)) =\n  map2\n   (\\<lambda>d x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n   [d..<d + length X] X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map snd\n   (zip [d..<d + length X]\n     (map (\\<lambda>x.\n              pdevs_val e\n               (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n              pdevs_val e\n               (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n       X)) =\n  map2\n   (\\<lambda>d x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n   [d..<d + length X] X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = map (\\<lambda>(d', x). ?large x + ?small (snd (?z ! (d' - d)))) ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2\n     (\\<lambda>d x.\n         pdevs_val e\n          (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n         pdevs_val e\n          (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n     [d..<d + length X] X =\n    map2\n     (\\<lambda>d' x.\n         pdevs_val e\n          (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n         pdevs_val e\n          (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n            (snd (zip [d..<d + length X] X ! (d' - d)))))\n     [d..<d + length X] X", "by (auto simp: in_set_zip)"], ["proof (state)\nthis:\n  map2\n   (\\<lambda>d x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n   [d..<d + length X] X =\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))))\n   [d..<d + length X] X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map2\n   (\\<lambda>d x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i))) x))\n   [d..<d + length X] X =\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))))\n   [d..<d + length X] X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?t = \"\\<lambda>x. tdev' p (filter_pdevs (-?J) x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?x = \"\\<lambda>d'. snd (?z ! (d' - d))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix d'"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"d \\<le> d'\" \"d' < d + length X\""], ["proof (state)\nthis:\n  d \\<le> d'\n  d' < d + length X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"abs (?small (?x d')) \\<le> ?t (?x d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (d' - d))))\\<bar>\n    \\<le> tdev' p\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (d' - d))))", "using \\<open>e \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<bar>pdevs_val e\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (d' - d))))\\<bar>\n    \\<le> tdev' p\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (d' - d))))", "by (rule abs_pdevs_val_le_tdev')"], ["proof (state)\nthis:\n  \\<bar>pdevs_val e\n         (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n           (snd (zip [d..<d + length X] X ! (d' - d))))\\<bar>\n  \\<le> tdev' p\n         (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n           (snd (zip [d..<d + length X] X ! (d' - d))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<bar>pdevs_val e\n         (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n           (snd (zip [d..<d + length X] X ! (d' - d))))\\<bar>\n  \\<le> tdev' p\n         (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n           (snd (zip [d..<d + length X] X ! (d' - d))))", "have \"?small (?x d') \\<in> {-?t (?x d') .. ?t (?x d')}\""], ["proof (prove)\nusing this:\n  \\<bar>pdevs_val e\n         (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n           (snd (zip [d..<d + length X] X ! (d' - d))))\\<bar>\n  \\<le> tdev' p\n         (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n           (snd (zip [d..<d + length X] X ! (d' - d))))\n\ngoal (1 subgoal):\n 1. pdevs_val e\n     (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n       (snd (zip [d..<d + length X] X ! (d' - d))))\n    \\<in> {- tdev' p\n              (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                (snd (zip [d..<d + length X] X !\n                      (d' -\n                       d))))..tdev' p\n                               (filter_pdevs\n                                 (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                                 (snd (zip [d..<d + length X] X !\n (d' - d))))}", "by auto"], ["proof (state)\nthis:\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (d' - d))))\n  \\<in> {- tdev' p\n            (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n              (snd (zip [d..<d + length X] X !\n                    (d' -\n                     d))))..tdev' p\n                             (filter_pdevs\n                               (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                               (snd (zip [d..<d + length X] X ! (d' - d))))}\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from in_centered_ivlE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>ea.\n      \\<lbrakk>ea \\<in> {- 1..1};\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))) =\n       ea *\n       tdev' p\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d))))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "have \"\\<exists>e\\<in>{-1 .. 1}. ?small (?x d') = e * ?t (?x d')\""], ["proof (prove)\nusing this:\n  (\\<And>ea.\n      \\<lbrakk>ea \\<in> {- 1..1};\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))) =\n       ea *\n       tdev' p\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d))))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>ea\\<in>{- 1..1}.\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))) =\n       ea *\n       tdev' p\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d))))", "by blast"], ["proof (state)\nthis:\n  \\<exists>ea\\<in>{- 1..1}.\n     pdevs_val e\n      (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n        (snd (zip [d..<d + length X] X ! (d' - d)))) =\n     ea *\n     tdev' p\n      (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n        (snd (zip [d..<d + length X] X ! (d' - d))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<lbrakk>d \\<le> ?d'4; ?d'4 < d + length X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ea\\<in>{- 1..1}.\n                       pdevs_val e\n                        (filter_pdevs\n                          (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                          (snd (zip [d..<d + length X] X ! (?d'4 - d)))) =\n                       ea *\n                       tdev' p\n                        (filter_pdevs\n                          (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                          (snd (zip [d..<d + length X] X ! (?d'4 - d))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>d \\<le> ?d'4; ?d'4 < d + length X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ea\\<in>{- 1..1}.\n                       pdevs_val e\n                        (filter_pdevs\n                          (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                          (snd (zip [d..<d + length X] X ! (?d'4 - d)))) =\n                       ea *\n                       tdev' p\n                        (filter_pdevs\n                          (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                          (snd (zip [d..<d + length X] X ! (?d'4 - d))))", "obtain e'' where e'':\n    \"e'' d' \\<in> {-1 .. 1}\"\n    \"?small (?x d') = e'' d' * ?t (?x d')\"\n    if \"d' \\<in> {d ..< d + length X}\" for d'"], ["proof (prove)\nusing this:\n  \\<lbrakk>d \\<le> ?d'4; ?d'4 < d + length X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ea\\<in>{- 1..1}.\n                       pdevs_val e\n                        (filter_pdevs\n                          (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                          (snd (zip [d..<d + length X] X ! (?d'4 - d)))) =\n                       ea *\n                       tdev' p\n                        (filter_pdevs\n                          (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                          (snd (zip [d..<d + length X] X ! (?d'4 - d))))\n\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>\\<And>d'.\n                    d' \\<in> {d..<d + length X} \\<Longrightarrow>\n                    e'' d' \\<in> {- 1..1};\n         \\<And>d'.\n            d' \\<in> {d..<d + length X} \\<Longrightarrow>\n            pdevs_val e\n             (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n               (snd (zip [d..<d + length X] X ! (d' - d)))) =\n            e'' d' *\n            tdev' p\n             (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n               (snd (zip [d..<d + length X] X ! (d' - d))))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>d \\<le> d'; d' < d + length X\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ea\\<in>{- 1..1}.\n                             pdevs_val e\n                              (filter_pdevs\n                                (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                                (snd (zip [d..<d + length X] X !\n(d' - d)))) =\n                             ea *\n                             tdev' p\n                              (filter_pdevs\n                                (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                                (snd (zip [d..<d + length X] X !\n(d' - d))))) \\<Longrightarrow>\n    \\<exists>e''.\n       (\\<forall>d'.\n           d' \\<in> {d..<d + length X} \\<longrightarrow>\n           e'' d' \\<in> {- 1..1}) \\<and>\n       (\\<forall>d'.\n           d' \\<in> {d..<d + length X} \\<longrightarrow>\n           pdevs_val e\n            (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n              (snd (zip [d..<d + length X] X ! (d' - d)))) =\n           e'' d' *\n           tdev' p\n            (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n              (snd (zip [d..<d + length X] X ! (d' - d)))))", "unfolding all_conj_distrib[symmetric] imp_conjR[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>d \\<le> d'; d' < d + length X\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ea\\<in>{- 1..1}.\n                             pdevs_val e\n                              (filter_pdevs\n                                (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                                (snd (zip [d..<d + length X] X !\n(d' - d)))) =\n                             ea *\n                             tdev' p\n                              (filter_pdevs\n                                (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                                (snd (zip [d..<d + length X] X !\n(d' - d))))) \\<Longrightarrow>\n    \\<exists>e''.\n       \\<forall>x.\n          x \\<in> {d..<d + length X} \\<longrightarrow>\n          e'' x \\<in> {- 1..1} \\<and>\n          pdevs_val e\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (x - d)))) =\n          e'' x *\n          tdev' p\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (x - d))))", "unfolding Ball_def[symmetric] atLeastAtMost_iff[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>d \\<le> d'; d' < d + length X\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ea\\<in>{- 1..1}.\n                             pdevs_val e\n                              (filter_pdevs\n                                (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                                (snd (zip [d..<d + length X] X !\n(d' - d)))) =\n                             ea *\n                             tdev' p\n                              (filter_pdevs\n                                (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                                (snd (zip [d..<d + length X] X !\n(d' - d))))) \\<Longrightarrow>\n    \\<exists>e''.\n       \\<forall>x\\<in>{d..<d + length X}.\n          e'' x \\<in> {- 1..1} \\<and>\n          pdevs_val e\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (x - d)))) =\n          e'' x *\n          tdev' p\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (x - d))))", "apply (rule bchoice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>d \\<le> d'; d' < d + length X\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ea\\<in>{- 1..1}.\n                             pdevs_val e\n                              (filter_pdevs\n                                (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                                (snd (zip [d..<d + length X] X !\n(d' - d)))) =\n                             ea *\n                             tdev' p\n                              (filter_pdevs\n                                (- (\\<lambda>i x. I i (pdevs_applys X i)))\n                                (snd (zip [d..<d + length X] X !\n(d' - d))))) \\<Longrightarrow>\n    \\<forall>x\\<in>{d..<d + length X}.\n       \\<exists>y.\n          y \\<in> {- 1..1} \\<and>\n          pdevs_val e\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (x - d)))) =\n          y *\n          tdev' p\n           (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n             (snd (zip [d..<d + length X] X ! (x - d))))", "apply (auto simp: Bex_def )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow> e'' ?d'2 \\<in> {- 1..1}\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d)))) =\n  e'' ?d'2 *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define e' where \"e' \\<equiv> \\<lambda>i. if i < d then e i else if i < d + length X then e'' i else 0\""], ["proof (state)\nthis:\n  e' \\<equiv>\n  \\<lambda>i. if i < d then e i else if i < d + length X then e'' i else 0\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have e': \"e' d' \\<in> {-1 .. 1}\"\n    \"?small (?x d') = e' d' * ?t (?x d')\"\n    if \"d' \\<in> {d ..< d + length X}\" for d'"], ["proof (prove)\ngoal (1 subgoal):\n 1. e' d' \\<in> {- 1..1} &&&\n    pdevs_val e\n     (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n       (snd (zip [d..<d + length X] X ! (d' - d)))) =\n    e' d' *\n    tdev' p\n     (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n       (snd (zip [d..<d + length X] X ! (d' - d))))", "using e'' that"], ["proof (prove)\nusing this:\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow> e'' ?d'2 \\<in> {- 1..1}\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d)))) =\n  e'' ?d'2 *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d))))\n  d' \\<in> {d..<d + length X}\n\ngoal (1 subgoal):\n 1. e' d' \\<in> {- 1..1} &&&\n    pdevs_val e\n     (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n       (snd (zip [d..<d + length X] X ! (d' - d)))) =\n    e' d' *\n    tdev' p\n     (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n       (snd (zip [d..<d + length X] X ! (d' - d))))", "by (auto simp: e'_def split: if_splits)"], ["proof (state)\nthis:\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow> e' ?d'2 \\<in> {- 1..1}\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d)))) =\n  e' ?d'2 *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow> e' ?d'2 \\<in> {- 1..1}\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d)))) =\n  e' ?d'2 *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d))))", "have *: \"pdevs_val e (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a)) (?x d')) =\n    e' d' * ?t (?x d')\" if \"d' \\<in> {d ..< d + length X}\" for d'"], ["proof (prove)\nusing this:\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow> e' ?d'2 \\<in> {- 1..1}\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d)))) =\n  e' ?d'2 *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d))))\n\ngoal (1 subgoal):\n 1. pdevs_val e\n     (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n       (snd (zip [d..<d + length X] X ! (d' - d)))) =\n    e' d' *\n    tdev' p\n     (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n       (snd (zip [d..<d + length X] X ! (d' - d))))", "using that"], ["proof (prove)\nusing this:\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow> e' ?d'2 \\<in> {- 1..1}\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d)))) =\n  e' ?d'2 *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d))))\n  d' \\<in> {d..<d + length X}\n\ngoal (1 subgoal):\n 1. pdevs_val e\n     (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n       (snd (zip [d..<d + length X] X ! (d' - d)))) =\n    e' d' *\n    tdev' p\n     (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n       (snd (zip [d..<d + length X] X ! (d' - d))))", "by auto"], ["proof (state)\nthis:\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d)))) =\n  e' ?d'2 *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d))))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"map (\\<lambda>(d', x). ?large x + ?small (?x d')) ?z =\n      map (\\<lambda>(d', x). ?large x + e' d' * ?t (?x d')) ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2\n     (\\<lambda>d' x.\n         pdevs_val e\n          (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n         pdevs_val e\n          (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n            (snd (zip [d..<d + length X] X ! (d' - d)))))\n     [d..<d + length X] X =\n    map2\n     (\\<lambda>d' x.\n         pdevs_val e\n          (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n         e' d' *\n         tdev' p\n          (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n            (snd (zip [d..<d + length X] X ! (d' - d)))))\n     [d..<d + length X] X", "apply (auto simp: in_set_zip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length X \\<Longrightarrow>\n       pdevs_val e\n        (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n          (X ! n)) =\n       e' (d + n) *\n       tdev' p\n        (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a)) (X ! n))", "subgoal for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length X \\<Longrightarrow>\n    pdevs_val e\n     (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a)) (X ! n)) =\n    e' (d + n) *\n    tdev' p\n     (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a)) (X ! n))", "using e'(2)[of \"d + n\"]"], ["proof (prove)\nusing this:\n  d + n \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (d + n - d)))) =\n  e' (d + n) *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (d + n - d))))\n\ngoal (1 subgoal):\n 1. n < length X \\<Longrightarrow>\n    pdevs_val e\n     (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a)) (X ! n)) =\n    e' (d + n) *\n    tdev' p\n     (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a)) (X ! n))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))))\n   [d..<d + length X] X =\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       e' d' *\n       tdev' p\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))))\n   [d..<d + length X] X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       pdevs_val e\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))))\n   [d..<d + length X] X =\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       e' d' *\n       tdev' p\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))))\n   [d..<d + length X] X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = map (\\<lambda>(d', x). pdevs_val e' (summarize_pdevs p ?J d' x)) (zip [d..<d + length X] X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2\n     (\\<lambda>d' x.\n         pdevs_val e\n          (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n         e' d' *\n         tdev' p\n          (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n            (snd (zip [d..<d + length X] X ! (d' - d)))))\n     [d..<d + length X] X =\n    map2\n     (\\<lambda>d' x.\n         pdevs_val e'\n          (summarize_pdevs p (\\<lambda>i x. I i (pdevs_applys X i)) d' x))\n     [d..<d + length X] X", "apply (auto simp: summarize_pdevs_def pdevs_val_msum_pdevs Let_def in_set_zip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length X \\<Longrightarrow>\n       pdevs_val e\n        (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n)) +\n       e' (d + n) *\n       tdev' p\n        (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n          (X ! n)) =\n       pdevs_val e'\n        (msum_pdevs (d + n)\n          (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n))\n          (pdevs_of_ivl\n            (- tdev' p\n                (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n                  (X ! n)))\n            (tdev' p\n              (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n                (X ! n)))))", "apply (subst pdevs_val_msum_pdevs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       n < length X \\<Longrightarrow>\n       degree (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n))\n       \\<le> d + n\n 2. \\<And>n.\n       n < length X \\<Longrightarrow>\n       pdevs_val e\n        (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n)) +\n       e' (d + n) *\n       tdev' p\n        (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n          (X ! n)) =\n       pdevs_val e'\n        (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n)) +\n       pdevs_val (\\<lambda>i. e' (i + (d + n)))\n        (pdevs_of_ivl\n          (- tdev' p\n              (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n                (X ! n)))\n          (tdev' p\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (X ! n))))", "using d"], ["proof (prove)\nusing this:\n  degrees X \\<le> d\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n < length X \\<Longrightarrow>\n       degree (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n))\n       \\<le> d + n\n 2. \\<And>n.\n       n < length X \\<Longrightarrow>\n       pdevs_val e\n        (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n)) +\n       e' (d + n) *\n       tdev' p\n        (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n          (X ! n)) =\n       pdevs_val e'\n        (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n)) +\n       pdevs_val (\\<lambda>i. e' (i + (d + n)))\n        (pdevs_of_ivl\n          (- tdev' p\n              (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n                (X ! n)))\n          (tdev' p\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (X ! n))))", "apply (auto intro!: degree_filter_pdevs_le[THEN order_trans])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n < length X; degrees X \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree (X ! n) \\<le> d + n\n 2. \\<And>n.\n       \\<lbrakk>n < length X; degrees X \\<le> d\\<rbrakk>\n       \\<Longrightarrow> pdevs_val e\n                          (filter_pdevs\n                            (\\<lambda>i x. I i (pdevs_applys X i))\n                            (X ! n)) +\n                         e' (d + n) *\n                         tdev' p\n                          (filter_pdevs\n                            (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n                            (X ! n)) =\n                         pdevs_val e'\n                          (filter_pdevs\n                            (\\<lambda>i x. I i (pdevs_applys X i))\n                            (X ! n)) +\n                         pdevs_val (\\<lambda>i. e' (i + (d + n)))\n                          (pdevs_of_ivl\n                            (- tdev' p\n                                (filter_pdevs\n                                  (\\<lambda>a b.\n\\<not> I a (pdevs_applys X a))\n                                  (X ! n)))\n                            (tdev' p\n                              (filter_pdevs\n                                (\\<lambda>a b.\n                                    \\<not> I a (pdevs_applys X a))\n                                (X ! n))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n_ < length X; degrees X \\<le> d\\<rbrakk>\n    \\<Longrightarrow> degree (X ! n_) \\<le> d + n_", "by (auto dest!: degrees_leD nth_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < length X; degrees X \\<le> d\\<rbrakk>\n       \\<Longrightarrow> pdevs_val e\n                          (filter_pdevs\n                            (\\<lambda>i x. I i (pdevs_applys X i))\n                            (X ! n)) +\n                         e' (d + n) *\n                         tdev' p\n                          (filter_pdevs\n                            (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n                            (X ! n)) =\n                         pdevs_val e'\n                          (filter_pdevs\n                            (\\<lambda>i x. I i (pdevs_applys X i))\n                            (X ! n)) +\n                         pdevs_val (\\<lambda>i. e' (i + (d + n)))\n                          (pdevs_of_ivl\n                            (- tdev' p\n                                (filter_pdevs\n                                  (\\<lambda>a b.\n\\<not> I a (pdevs_applys X a))\n                                  (X ! n)))\n                            (tdev' p\n                              (filter_pdevs\n                                (\\<lambda>a b.\n                                    \\<not> I a (pdevs_applys X a))\n                                (X ! n))))", "apply (auto simp: pdevs_of_ivl_real intro!: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < length X; degrees X \\<le> d\\<rbrakk>\n       \\<Longrightarrow> pdevs_val e\n                          (filter_pdevs\n                            (\\<lambda>i x. I i (pdevs_applys X i))\n                            (X ! n)) =\n                         pdevs_val e'\n                          (filter_pdevs\n                            (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n))", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_)) =\n    pdevs_val e'\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_)) =\n    pdevs_val e'\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_))", "have \"degree (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n)) \\<le> d\" if \"n < length X\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n))\n    \\<le> d", "using d that"], ["proof (prove)\nusing this:\n  degrees X \\<le> d\n  n < length X\n\ngoal (1 subgoal):\n 1. degree (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n))\n    \\<le> d", "by (intro degree_filter_pdevs_le[THEN order_trans]) (simp add: degrees_leD)"], ["proof (state)\nthis:\n  ?n2 < length X \\<Longrightarrow>\n  degree (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! ?n2))\n  \\<le> d\n\ngoal (1 subgoal):\n 1. pdevs_val e\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_)) =\n    pdevs_val e'\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_))", "then"], ["proof (chain)\npicking this:\n  ?n2 < length X \\<Longrightarrow>\n  degree (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! ?n2))\n  \\<le> d", "show ?thesis"], ["proof (prove)\nusing this:\n  ?n2 < length X \\<Longrightarrow>\n  degree (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! ?n2))\n  \\<le> d\n\ngoal (1 subgoal):\n 1. pdevs_val e\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_)) =\n    pdevs_val e'\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_))", "using prems e''"], ["proof (prove)\nusing this:\n  ?n2 < length X \\<Longrightarrow>\n  degree (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! ?n2))\n  \\<le> d\n  n_ < length X\n  degrees X \\<le> d\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow> e'' ?d'2 \\<in> {- 1..1}\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d)))) =\n  e'' ?d'2 *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d))))\n\ngoal (1 subgoal):\n 1. pdevs_val e\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_)) =\n    pdevs_val e'\n     (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_))", "apply (intro pdevs_val_degree_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                n < length X \\<Longrightarrow>\n                degree\n                 (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n                   (X ! n))\n                \\<le> d;\n     n_ < length X; degrees X \\<le> d;\n     \\<And>d'.\n        d' \\<in> {d..<d + length X} \\<Longrightarrow> e'' d' \\<in> {- 1..1};\n     \\<And>d'.\n        d' \\<in> {d..<d + length X} \\<Longrightarrow>\n        pdevs_val e\n         (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n           (snd (zip [d..<d + length X] X ! (d' - d)))) =\n        e'' d' *\n        tdev' p\n         (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n           (snd (zip [d..<d + length X] X ! (d' - d))))\\<rbrakk>\n    \\<Longrightarrow> filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n                       (X ! n_) =\n                      filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n                       (X ! n_)\n 2. \\<And>i.\n       \\<lbrakk>\\<And>n.\n                   n < length X \\<Longrightarrow>\n                   degree\n                    (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n                      (X ! n))\n                   \\<le> d;\n        n_ < length X; degrees X \\<le> d;\n        \\<And>d'.\n           d' \\<in> {d..<d + length X} \\<Longrightarrow>\n           e'' d' \\<in> {- 1..1};\n        \\<And>d'.\n           d' \\<in> {d..<d + length X} \\<Longrightarrow>\n           pdevs_val e\n            (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n              (snd (zip [d..<d + length X] X ! (d' - d)))) =\n           e'' d' *\n           tdev' p\n            (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n              (snd (zip [d..<d + length X] X ! (d' - d))));\n        i < degree\n             (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n               (X ! n_))\\<rbrakk>\n       \\<Longrightarrow> e i = e' i", "apply (auto dest!: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>n.\n                   n < length X \\<Longrightarrow>\n                   degree\n                    (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n                      (X ! n))\n                   \\<le> d;\n        n_ < length X; degrees X \\<le> d;\n        \\<And>d'.\n           d \\<le> d' \\<and> d' < d + length X \\<Longrightarrow>\n           - 1 \\<le> e'' d' \\<and> e'' d' \\<le> 1;\n        \\<And>d'.\n           d \\<le> d' \\<and> d' < d + length X \\<Longrightarrow>\n           pdevs_val e\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (snd (zip [d..<d + length X] X ! (d' - d)))) =\n           e'' d' *\n           tdev' p\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (snd (zip [d..<d + length X] X ! (d' - d))));\n        i < degree\n             (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n               (X ! n_))\\<rbrakk>\n       \\<Longrightarrow> e i = e' i", "apply (auto simp: e'_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>n.\n                   n < length X \\<Longrightarrow>\n                   degree\n                    (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n                      (X ! n))\n                   \\<le> d;\n        n_ < length X; degrees X \\<le> d;\n        \\<And>d'.\n           d \\<le> d' \\<and> d' < d + length X \\<Longrightarrow>\n           - 1 \\<le> e'' d' \\<and> e'' d' \\<le> 1;\n        \\<And>d'.\n           d \\<le> d' \\<and> d' < d + length X \\<Longrightarrow>\n           pdevs_val e\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (snd (zip [d..<d + length X] X ! (d' - d)))) =\n           e'' d' *\n           tdev' p\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (snd (zip [d..<d + length X] X ! (d' - d))));\n        i < degree\n             (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_));\n        i < d + length X; \\<not> i < d\\<rbrakk>\n       \\<Longrightarrow> e i = e'' i\n 2. \\<And>i.\n       \\<lbrakk>\\<And>n.\n                   n < length X \\<Longrightarrow>\n                   degree\n                    (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n                      (X ! n))\n                   \\<le> d;\n        n_ < length X; degrees X \\<le> d;\n        \\<And>d'.\n           d \\<le> d' \\<and> d' < d + length X \\<Longrightarrow>\n           - 1 \\<le> e'' d' \\<and> e'' d' \\<le> 1;\n        \\<And>d'.\n           d \\<le> d' \\<and> d' < d + length X \\<Longrightarrow>\n           pdevs_val e\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (snd (zip [d..<d + length X] X ! (d' - d)))) =\n           e'' d' *\n           tdev' p\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (snd (zip [d..<d + length X] X ! (d' - d))));\n        i < degree\n             (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_));\n        \\<not> i < d + length X\\<rbrakk>\n       \\<Longrightarrow> e i = 0", "apply (meson \\<open>\\<And>n. \\<lbrakk>n < length X; degrees X \\<le> d\\<rbrakk> \\<Longrightarrow> degree (X ! n) \\<le> d + n\\<close> degree_filter_pdevs_le less_le_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>n.\n                   n < length X \\<Longrightarrow>\n                   degree\n                    (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i))\n                      (X ! n))\n                   \\<le> d;\n        n_ < length X; degrees X \\<le> d;\n        \\<And>d'.\n           d \\<le> d' \\<and> d' < d + length X \\<Longrightarrow>\n           - 1 \\<le> e'' d' \\<and> e'' d' \\<le> 1;\n        \\<And>d'.\n           d \\<le> d' \\<and> d' < d + length X \\<Longrightarrow>\n           pdevs_val e\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (snd (zip [d..<d + length X] X ! (d' - d)))) =\n           e'' d' *\n           tdev' p\n            (filter_pdevs (\\<lambda>a b. \\<not> I a (pdevs_applys X a))\n              (snd (zip [d..<d + length X] X ! (d' - d))));\n        i < degree\n             (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_));\n        \\<not> i < d + length X\\<rbrakk>\n       \\<Longrightarrow> e i = 0", "by (meson less_le_trans trans_less_add1)"], ["proof (state)\nthis:\n  pdevs_val e\n   (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_)) =\n  pdevs_val e'\n   (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) (X ! n_))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       e' d' *\n       tdev' p\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))))\n   [d..<d + length X] X =\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e'\n        (summarize_pdevs p (\\<lambda>i x. I i (pdevs_applys X i)) d' x))\n   [d..<d + length X] X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e (filter_pdevs (\\<lambda>i x. I i (pdevs_applys X i)) x) +\n       e' d' *\n       tdev' p\n        (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n          (snd (zip [d..<d + length X] X ! (d' - d)))))\n   [d..<d + length X] X =\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e'\n        (summarize_pdevs p (\\<lambda>i x. I i (pdevs_applys X i)) d' x))\n   [d..<d + length X] X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = pdevs_vals e' (summarize_pdevs_list p I d X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2\n     (\\<lambda>d' x.\n         pdevs_val e'\n          (summarize_pdevs p (\\<lambda>i x. I i (pdevs_applys X i)) d' x))\n     [d..<d + length X] X =\n    pdevs_vals e' (summarize_pdevs_list p I d X)", "by (auto simp: summarize_pdevs_list_def pdevs_vals_def)"], ["proof (state)\nthis:\n  map2\n   (\\<lambda>d' x.\n       pdevs_val e'\n        (summarize_pdevs p (\\<lambda>i x. I i (pdevs_applys X i)) d' x))\n   [d..<d + length X] X =\n  pdevs_vals e' (summarize_pdevs_list p I d X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)", "have \"pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)\""], ["proof (prove)\nusing this:\n  pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)\n\ngoal (1 subgoal):\n 1. pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)", "."], ["proof (state)\nthis:\n  pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<And>i. i < d \\<Longrightarrow> e i = e' i)\" \"e' \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i < d \\<Longrightarrow> e i = e' i) &&&\n    e' \\<in> UNIV \\<rightarrow> {- 1..1}", "using \\<open>e \\<in> _\\<close> e''"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow> e'' ?d'2 \\<in> {- 1..1}\n  ?d'2 \\<in> {d..<d + length X} \\<Longrightarrow>\n  pdevs_val e\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d)))) =\n  e'' ?d'2 *\n  tdev' p\n   (filter_pdevs (- (\\<lambda>i x. I i (pdevs_applys X i)))\n     (snd (zip [d..<d + length X] X ! (?d'2 - d))))\n\ngoal (1 subgoal):\n 1. (\\<And>i. i < d \\<Longrightarrow> e i = e' i) &&&\n    e' \\<in> UNIV \\<rightarrow> {- 1..1}", "by (auto simp: e'_def)"], ["proof (state)\nthis:\n  ?i2 < d \\<Longrightarrow> e ?i2 = e' ?i2\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_vals e X =\n                 pdevs_vals e' (summarize_pdevs_list p I d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)\n  ?i2 < d \\<Longrightarrow> e ?i2 = e' ?i2\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_vals e X = pdevs_vals e' (summarize_pdevs_list p I d X)\n  ?i2 < d \\<Longrightarrow> e ?i2 = e' ?i2\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "fun list_ex2 where\n  \"list_ex2 P [] xs = False\"\n| \"list_ex2 P xs [] = False\"\n| \"list_ex2 P (x#xs) (y#ys) = (P x y \\<or> list_ex2 P xs ys)\""], ["", "lemma list_ex2_iff:\n  \"list_ex2 P xs ys \\<longleftrightarrow> (\\<not>list_all2 (-P) (take (length ys) xs) (take (length xs) ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex2 P xs ys =\n    (\\<not> list_all2 (- P) (take (length ys) xs) (take (length xs) ys))", "by (induction P xs ys rule: list_ex2.induct) auto"], ["", "definition \"summarize_aforms p C d (X::real aform list) =\n  (zip (map fst X) (summarize_pdevs_list p (C X) d (map snd X)))\""], ["", "lemma aform_vals_pdevs_vals:\n  \"aform_vals e X = map (\\<lambda>(x, y). x + y) (zip (map fst X) (pdevs_vals e (map snd X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_vals e X = map2 (+) (map fst X) (pdevs_vals e (map snd X))", "by (auto simp: pdevs_vals_def aform_vals_def aform_val_def[abs_def]\n      map_zip_map map_zip_map2 split_beta' zip_same_conv_map)"], ["", "lemma summarize_aformsE:\n  fixes X::\"real aform list\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes d: \"degree_aforms X \\<le> d\"\n  obtains e' where \"aform_vals e X = aform_vals e' (summarize_aforms p C d X)\"\n    \"\\<And>i. i < d \\<Longrightarrow> e i = e' i\"\n    \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define Xs where \"Xs = map snd X\""], ["proof (state)\nthis:\n  Xs = map snd X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"aform_vals e X = map (\\<lambda>(x, y). x + y) (zip (map fst X) (pdevs_vals e Xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_vals e X = map2 (+) (map fst X) (pdevs_vals e Xs)", "by (auto simp: aform_vals_pdevs_vals Xs_def)"], ["proof (state)\nthis:\n  aform_vals e X = map2 (+) (map fst X) (pdevs_vals e Xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  aform_vals e X = map2 (+) (map fst X) (pdevs_vals e Xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain e' where e': \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n    \"\\<And>i. i < d \\<Longrightarrow> e i = e' i\"\n    \"pdevs_vals e Xs = pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         pdevs_vals e Xs =\n         pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using summarize_pdevs_listE[OF e d, of p \"C X\"]"], ["proof (prove)\nusing this:\n  (\\<And>e'.\n      \\<lbrakk>pdevs_vals e (map snd X) =\n               pdevs_vals e' (summarize_pdevs_list p (C X) d (map snd X));\n       \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n       e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         pdevs_vals e Xs =\n         pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Xs_def)"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d \\<Longrightarrow> e ?i = e' ?i\n  pdevs_vals e Xs = pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(3)"], ["proof (state)\nthis:\n  pdevs_vals e Xs = pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_vals e Xs = pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"map (\\<lambda>(x, y). x + y) (zip (map fst X) \\<dots>) = aform_vals e' (summarize_aforms p C d X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (+) (map fst X)\n     (pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)) =\n    aform_vals e' (summarize_aforms p C d X)", "unfolding aform_vals_pdevs_vals"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (+) (map fst X)\n     (pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)) =\n    map2 (+) (map fst (summarize_aforms p C d X))\n     (pdevs_vals e' (map snd (summarize_aforms p C d X)))", "by (simp add: summarize_aforms_def Let_def Xs_def summarize_pdevs_list_def\n        split_beta')"], ["proof (state)\nthis:\n  map2 (+) (map fst X) (pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)) =\n  aform_vals e' (summarize_aforms p C d X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  aform_vals e X = aform_vals e' (summarize_aforms p C d X)", "have \"aform_vals e X = aform_vals e' (summarize_aforms p C d X)\"\n    \"\\<And>i. i < d \\<Longrightarrow> e i = e' i\"\n    \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  aform_vals e X = aform_vals e' (summarize_aforms p C d X)\n\ngoal (1 subgoal):\n 1. aform_vals e X = aform_vals e' (summarize_aforms p C d X) &&&\n    (\\<And>i. i < d \\<Longrightarrow> e i = e' i) &&&\n    e' \\<in> UNIV \\<rightarrow> {- 1..1}", "using e' d"], ["proof (prove)\nusing this:\n  aform_vals e X = aform_vals e' (summarize_aforms p C d X)\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d \\<Longrightarrow> e ?i = e' ?i\n  pdevs_vals e Xs = pdevs_vals e' (summarize_pdevs_list p (C X) d Xs)\n  degree_aforms X \\<le> d\n\ngoal (1 subgoal):\n 1. aform_vals e X = aform_vals e' (summarize_aforms p C d X) &&&\n    (\\<And>i. i < d \\<Longrightarrow> e i = e' i) &&&\n    e' \\<in> UNIV \\<rightarrow> {- 1..1}", "by (auto simp: Xs_def)"], ["proof (state)\nthis:\n  aform_vals e X = aform_vals e' (summarize_aforms p C d X)\n  ?i < d \\<Longrightarrow> e ?i = e' ?i\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>aform_vals e X = aform_vals e' (summarize_aforms p C d X);\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  aform_vals e X = aform_vals e' (summarize_aforms p C d X)\n  ?i < d \\<Longrightarrow> e ?i = e' ?i\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  aform_vals e X = aform_vals e' (summarize_aforms p C d X)\n  ?i < d \\<Longrightarrow> e ?i = e' ?i\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Different reduction strategies:\\<close>"], ["", "definition \"collect_threshold p ta t (X::real aform list) =\n  (let\n    Xs = map snd X;\n    as = map (\\<lambda>X. max ta (t * tdev' p X)) Xs\n  in (\\<lambda>(i::nat) xs. list_ex2 (\\<le>) as (map abs xs)))\""], ["", "definition \"collect_girard p m (X::real aform list) =\n  (let\n    Xs = map snd X;\n    M = pdevs_mapping Xs;\n    D = domain_pdevs Xs;\n    N = length X\n  in if card D \\<le> m then (\\<lambda>_ _. True) else\n    let\n      Ds = sorted_list_of_set D;\n      ortho_indices = map fst (take (2 * N) (sort_key (\\<lambda>(i, r). r) (map (\\<lambda>i. let xs = M i in (i, sum_list' p xs - fold max xs 0)) Ds)));\n      _ = ()\n    in (\\<lambda>i (xs::real list). i \\<in> set ortho_indices))\""], ["", "subsection \\<open>Splitting with heuristics\\<close>"], ["", "definition \"abs_pdevs = unop_pdevs abs\""], ["", "definition \"abssum_of_pdevs_list X = fold (\\<lambda>a b. (add_pdevs (abs_pdevs a) b)) X zero_pdevs\""], ["", "definition \"split_aforms xs i = (let splits = map (\\<lambda>x. split_aform x i) xs in (map fst splits, map snd splits))\""], ["", "definition \"split_aforms_largest_uncond X =\n  (let (i, x) = max_pdev (abssum_of_pdevs_list (map snd X)) in split_aforms X i)\""], ["", "definition \"Inf_aform_err p Rd = (float_of (truncate_down p (Inf_aform' p (fst Rd) - abs(snd Rd))))\""], ["", "definition \"Sup_aform_err p Rd = (float_of (truncate_up p (Sup_aform' p (fst Rd) + abs(snd Rd))))\""], ["", "context includes interval.lifting begin"], ["", "lift_definition ivl_of_aform_err::\"nat \\<Rightarrow> aform_err \\<Rightarrow> float interval\"\n  is \"\\<lambda>p Rd. (Inf_aform_err p Rd, Sup_aform_err p Rd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat prod.\n       (Inf_aform_err nat prod, Sup_aform_err nat prod)\n       \\<in> {(x, y). x \\<le> y}", "by (auto simp: aform_err_def  Inf_aform_err_def Sup_aform_err_def\n      intro!: truncate_down_le truncate_up_le add_increasing[OF _ Inf_aform'_le_Sup_aform'])"], ["", "lemma lower_ivl_of_aform_err: \"lower (ivl_of_aform_err p Rd) = Inf_aform_err p Rd\"\n  and upper_ivl_of_aform_err: \"upper (ivl_of_aform_err p Rd) = Sup_aform_err p Rd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower (ivl_of_aform_err p Rd) = Inf_aform_err p Rd &&&\n    upper (ivl_of_aform_err p Rd) = Sup_aform_err p Rd", "by (transfer, simp)+"], ["", "end"], ["", "definition approx_un::\"nat\n     \\<Rightarrow> (float interval \\<Rightarrow> float interval option)\n        \\<Rightarrow> ((real \\<times> real pdevs) \\<times> real) option\n           \\<Rightarrow> ((real \\<times> real pdevs) \\<times> real) option\"\n  where \"approx_un p f a = do {\n  rd \\<leftarrow> a;\n  ivl \\<leftarrow> f (ivl_of_aform_err p rd);\n  Some (ivl_err (real_interval ivl))\n}\""], ["", "definition interval_extension1::\"(float interval \\<Rightarrow> (float interval) option) \\<Rightarrow> (real \\<Rightarrow> real) \\<Rightarrow> bool\"\n  where \"interval_extension1 F f \\<longleftrightarrow> (\\<forall>ivl ivl'. F ivl = Some ivl' \\<longrightarrow> (\\<forall>x. x \\<in>\\<^sub>r ivl \\<longrightarrow> f x \\<in>\\<^sub>r ivl'))\""], ["", "lemma interval_extension1D:\n  assumes \"interval_extension1 F f\"\n  assumes \"F ivl = Some ivl'\"\n  assumes \"x \\<in>\\<^sub>r ivl\"\n  shows \"f x \\<in>\\<^sub>r ivl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in>\\<^sub>r ivl'", "using assms"], ["proof (prove)\nusing this:\n  interval_extension1 F f\n  F ivl = Some ivl'\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. f x \\<in>\\<^sub>r ivl'", "by (auto simp: interval_extension1_def)"], ["", "lemma approx_un_argE:\n  assumes au: \"approx_un p F X = Some Y\"\n  obtains X' where \"X = Some X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X'. X = Some X' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  approx_un p F X = Some Y\n\ngoal (1 subgoal):\n 1. (\\<And>X'. X = Some X' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: approx_un_def bind_eq_Some_conv)"], ["", "lemma degree_aform_independent_from:\n  \"degree_aform (independent_from d1 X) \\<le> d1 + degree_aform X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform (independent_from d1 X) \\<le> d1 + degree_aform X", "by (auto simp: independent_from_def degree_msum_pdevs_le)"], ["", "lemma degree_aform_of_ivl:\n  fixes a b::\"'a::executable_euclidean_space\"\n  shows \"degree_aform (aform_of_ivl a b) \\<le> length (Basis_list::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform (aform_of_ivl a b) \\<le> length Basis_list", "by (auto simp: aform_of_ivl_def degree_pdevs_of_ivl_le)"], ["", "lemma aform_err_ivl_err[simp]: \"aform_err e (ivl_err ivl') = set_of ivl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_err e (ivl_err ivl') = set_of ivl'", "by (auto simp: aform_err_def ivl_err_def aform_val_def divide_simps set_of_eq)"], ["", "lemma Inf_Sup_aform_err:\n  fixes X\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  defines \"X' \\<equiv> fst X\"\n  shows \"aform_err e X \\<subseteq> {Inf_aform_err p X .. Sup_aform_err p X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_err e X\n    \\<subseteq> {real_of_float\n                  (Inf_aform_err p X)..real_of_float (Sup_aform_err p X)}", "using Inf_aform[OF e, of X'] Sup_aform[OF e, of X'] Inf_aform'[of p X'] Sup_aform'[of X' p]"], ["proof (prove)\nusing this:\n  Inf_aform X' \\<le> aform_val e X'\n  aform_val e X' \\<le> Sup_aform X'\n  Inf_aform' p X' \\<le> Inf_aform X'\n  Sup_aform X' \\<le> Sup_aform' p X'\n\ngoal (1 subgoal):\n 1. aform_err e X\n    \\<subseteq> {real_of_float\n                  (Inf_aform_err p X)..real_of_float (Sup_aform_err p X)}", "by (auto simp: aform_err_def X'_def Inf_aform_err_def Sup_aform_err_def\n      intro!: truncate_down_le truncate_up_le)"], ["", "lemma ivl_of_aform_err:\n  fixes X\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"x \\<in> aform_err e X \\<Longrightarrow> x \\<in>\\<^sub>r ivl_of_aform_err p X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> aform_err e X \\<Longrightarrow>\n    x \\<in>\\<^sub>r ivl_of_aform_err p X", "using Inf_Sup_aform_err[OF e, of X p]"], ["proof (prove)\nusing this:\n  aform_err e X\n  \\<subseteq> {real_of_float\n                (Inf_aform_err p X)..real_of_float (Sup_aform_err p X)}\n\ngoal (1 subgoal):\n 1. x \\<in> aform_err e X \\<Longrightarrow>\n    x \\<in>\\<^sub>r ivl_of_aform_err p X", "by (auto simp: set_of_eq lower_ivl_of_aform_err upper_ivl_of_aform_err)"], ["", "lemma approx_unE:\n  assumes ie: \"interval_extension1 F f\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes au: \"approx_un p F X'err = Some Ye\"\n  assumes x: \"case X'err of None \\<Rightarrow> True | Some X'err \\<Rightarrow> x \\<in> aform_err e X'err\"\n  shows \"f x \\<in> aform_err e Ye\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Ye", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Ye", "from au"], ["proof (chain)\npicking this:\n  approx_un p F X'err = Some Ye", "obtain ivl' X' err\n    where F: \"F (ivl_of_aform_err p (X', err)) = Some (ivl')\"\n      and Y: \"Ye = ivl_err (real_interval ivl')\"\n     and X'err: \"X'err = Some (X', err)\""], ["proof (prove)\nusing this:\n  approx_un p F X'err = Some Ye\n\ngoal (1 subgoal):\n 1. (\\<And>X' err ivl'.\n        \\<lbrakk>F (ivl_of_aform_err p (X', err)) = Some ivl';\n         Ye = ivl_err (real_interval ivl'); X'err = Some (X', err)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: approx_un_def bind_eq_Some_conv)"], ["proof (state)\nthis:\n  F (ivl_of_aform_err p (X', err)) = Some ivl'\n  Ye = ivl_err (real_interval ivl')\n  X'err = Some (X', err)\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Ye", "from x"], ["proof (chain)\npicking this:\n  case X'err of None \\<Rightarrow> True\n  | Some X'err \\<Rightarrow> x \\<in> aform_err e X'err", "have \"x \\<in> aform_err e (X', err)\""], ["proof (prove)\nusing this:\n  case X'err of None \\<Rightarrow> True\n  | Some X'err \\<Rightarrow> x \\<in> aform_err e X'err\n\ngoal (1 subgoal):\n 1. x \\<in> aform_err e (X', err)", "by (auto simp: X'err)"], ["proof (state)\nthis:\n  x \\<in> aform_err e (X', err)\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Ye", "from ivl_of_aform_err[OF e this]"], ["proof (chain)\npicking this:\n  x \\<in>\\<^sub>r ivl_of_aform_err ?p (X', err)", "have \"x \\<in>\\<^sub>r ivl_of_aform_err p (X', err)\""], ["proof (prove)\nusing this:\n  x \\<in>\\<^sub>r ivl_of_aform_err ?p (X', err)\n\ngoal (1 subgoal):\n 1. x \\<in>\\<^sub>r ivl_of_aform_err p (X', err)", "."], ["proof (state)\nthis:\n  x \\<in>\\<^sub>r ivl_of_aform_err p (X', err)\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Ye", "from interval_extension1D[OF ie F this]"], ["proof (chain)\npicking this:\n  f x \\<in>\\<^sub>r ivl'", "have \"f x \\<in>\\<^sub>r ivl'\""], ["proof (prove)\nusing this:\n  f x \\<in>\\<^sub>r ivl'\n\ngoal (1 subgoal):\n 1. f x \\<in>\\<^sub>r ivl'", "."], ["proof (state)\nthis:\n  f x \\<in>\\<^sub>r ivl'\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Ye", "also"], ["proof (state)\nthis:\n  f x \\<in>\\<^sub>r ivl'\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Ye", "have \"\\<dots> = aform_err e Ye\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (real_interval ivl') = aform_err e Ye", "unfolding Y aform_err_ivl_err"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (real_interval ivl') = set_of (real_interval ivl')", ".."], ["proof (state)\nthis:\n  set_of (real_interval ivl') = aform_err e Ye\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Ye", "finally"], ["proof (chain)\npicking this:\n  f x \\<in> aform_err e Ye", "show ?thesis"], ["proof (prove)\nusing this:\n  f x \\<in> aform_err e Ye\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Ye", "."], ["proof (state)\nthis:\n  f x \\<in> aform_err e Ye\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"approx_bin p f rd sd = do {\n  ivl \\<leftarrow> f (ivl_of_aform_err p rd)\n             (ivl_of_aform_err p sd);\n  Some (ivl_err (real_interval ivl))\n}\""], ["", "definition interval_extension2::\"(float interval \\<Rightarrow> float interval \\<Rightarrow> float interval option) \\<Rightarrow> (real \\<Rightarrow> real \\<Rightarrow> real) \\<Rightarrow> bool\"\n  where \"interval_extension2 F f \\<longleftrightarrow> (\\<forall>ivl1 ivl2 ivl. F ivl1 ivl2 = Some ivl \\<longrightarrow>\n    (\\<forall>x y. x \\<in>\\<^sub>r ivl1 \\<longrightarrow> y \\<in>\\<^sub>r ivl2 \\<longrightarrow> f x y \\<in>\\<^sub>r ivl))\""], ["", "lemma interval_extension2D:\n  assumes \"interval_extension2 F f\"\n  assumes \"F ivl1 ivl2 = Some ivl\"\n  shows \"x \\<in>\\<^sub>r ivl1 \\<Longrightarrow> y \\<in>\\<^sub>r ivl2 \\<Longrightarrow> f x y \\<in>\\<^sub>r ivl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in>\\<^sub>r ivl1; y \\<in>\\<^sub>r ivl2\\<rbrakk>\n    \\<Longrightarrow> f x y \\<in>\\<^sub>r ivl", "using assms"], ["proof (prove)\nusing this:\n  interval_extension2 F f\n  F ivl1 ivl2 = Some ivl\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in>\\<^sub>r ivl1; y \\<in>\\<^sub>r ivl2\\<rbrakk>\n    \\<Longrightarrow> f x y \\<in>\\<^sub>r ivl", "by (auto simp: interval_extension2_def)"], ["", "lemma approx_binE:\n  assumes ie: \"interval_extension2 F f\"\n  assumes w: \"w \\<in> aform_err e (W', errw)\"\n  assumes x: \"x \\<in> aform_err e (X', errx)\"\n  assumes ab: \"approx_bin p F ((W', errw)) ((X', errx)) = Some Ye\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"f w x \\<in> aform_err e Ye\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f w x \\<in> aform_err e Ye", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f w x \\<in> aform_err e Ye", "from ab"], ["proof (chain)\npicking this:\n  approx_bin p F (W', errw) (X', errx) = Some Ye", "obtain ivl'\n    where F: \"F (ivl_of_aform_err p (W', errw)) (ivl_of_aform_err p (X', errx)) = Some ivl'\"\n      and Y: \"Ye = ivl_err (real_interval ivl')\""], ["proof (prove)\nusing this:\n  approx_bin p F (W', errw) (X', errx) = Some Ye\n\ngoal (1 subgoal):\n 1. (\\<And>ivl'.\n        \\<lbrakk>F (ivl_of_aform_err p (W', errw))\n                  (ivl_of_aform_err p (X', errx)) =\n                 Some ivl';\n         Ye = ivl_err (real_interval ivl')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: approx_bin_def bind_eq_Some_conv max_def)"], ["proof (state)\nthis:\n  F (ivl_of_aform_err p (W', errw)) (ivl_of_aform_err p (X', errx)) =\n  Some ivl'\n  Ye = ivl_err (real_interval ivl')\n\ngoal (1 subgoal):\n 1. f w x \\<in> aform_err e Ye", "from interval_extension2D[OF ie F\n        ivl_of_aform_err[OF e, where p=p, OF w]\n        ivl_of_aform_err[OF e, where p=p, OF x]]"], ["proof (chain)\npicking this:\n  f w x \\<in>\\<^sub>r ivl'", "have \"f w x \\<in>\\<^sub>r ivl'\""], ["proof (prove)\nusing this:\n  f w x \\<in>\\<^sub>r ivl'\n\ngoal (1 subgoal):\n 1. f w x \\<in>\\<^sub>r ivl'", "."], ["proof (state)\nthis:\n  f w x \\<in>\\<^sub>r ivl'\n\ngoal (1 subgoal):\n 1. f w x \\<in> aform_err e Ye", "also"], ["proof (state)\nthis:\n  f w x \\<in>\\<^sub>r ivl'\n\ngoal (1 subgoal):\n 1. f w x \\<in> aform_err e Ye", "have \"\\<dots> = aform_err e Ye\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (real_interval ivl') = aform_err e Ye", "unfolding Y aform_err_ivl_err"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (real_interval ivl') = set_of (real_interval ivl')", ".."], ["proof (state)\nthis:\n  set_of (real_interval ivl') = aform_err e Ye\n\ngoal (1 subgoal):\n 1. f w x \\<in> aform_err e Ye", "finally"], ["proof (chain)\npicking this:\n  f w x \\<in> aform_err e Ye", "show ?thesis"], ["proof (prove)\nusing this:\n  f w x \\<in> aform_err e Ye\n\ngoal (1 subgoal):\n 1. f w x \\<in> aform_err e Ye", "."], ["proof (state)\nthis:\n  f w x \\<in> aform_err e Ye\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"min_aform_err p a1 (a2::aform_err) =\n  (let\n    ivl1 = ivl_of_aform_err p a1;\n    ivl2 = ivl_of_aform_err p a2\n  in if upper ivl1 < lower ivl2 then a1\n      else if upper ivl2 < lower ivl1 then a2\n      else ivl_err (real_interval (min_interval ivl1 ivl2)))\""], ["", "definition \"max_aform_err p a1 (a2::aform_err) =\n  (let\n    ivl1 = ivl_of_aform_err p a1;\n    ivl2 = ivl_of_aform_err p a2\n  in if upper ivl1 < lower ivl2 then a2\n      else if upper ivl2 < lower ivl1 then a1\n      else ivl_err (real_interval (max_interval ivl1 ivl2)))\""], ["", "subsection \\<open>Approximate Min Range - Kind Of Trigonometric Functions\\<close>"], ["", "definition affine_unop :: \"nat \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> aform_err \\<Rightarrow> aform_err\" where\n\"affine_unop p a b d X = (let\n    ((x, xs), xe) = X;\n    (ax, axe) = trunc_bound_eucl p (a * x);\n    (y, ye) = trunc_bound_eucl p (ax + b);\n    (ys, yse) = trunc_bound_pdevs p (scaleR_pdevs a xs)\n    in ((y, ys), sum_list' p [truncate_up p (\\<bar>a\\<bar> * xe), axe, ye, yse, d]))\"\n  \\<comment> \\<open>TODO: also do binop\\<close>"], ["", "lemma aform_err_leI:\n  \"y \\<in> aform_err e (c, d)\"\n  if \"y \\<in> aform_err e (c, d')\" \"d' \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> aform_err e (c, d)", "using that"], ["proof (prove)\nusing this:\n  y \\<in> aform_err e (c, d')\n  d' \\<le> d\n\ngoal (1 subgoal):\n 1. y \\<in> aform_err e (c, d)", "by (auto simp: aform_err_def)"], ["", "lemma aform_err_eqI:\n  \"y \\<in> aform_err e (c, d)\"\n  if \"y \\<in> aform_err e (c, d')\" \"d' = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> aform_err e (c, d)", "using that"], ["proof (prove)\nusing this:\n  y \\<in> aform_err e (c, d')\n  d' = d\n\ngoal (1 subgoal):\n 1. y \\<in> aform_err e (c, d)", "by (auto simp: aform_err_def)"], ["", "lemma sum_list'_append[simp]: \"sum_list' p (ds@[d]) = truncate_up p (d + sum_list' p ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list' p (ds @ [d]) = truncate_up p (d + sum_list' p ds)", "unfolding sum_list'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>a b. eucl_truncate_up p (a + b)) (ds @ [d]) 0 =\n    truncate_up p (d + fold (\\<lambda>a b. eucl_truncate_up p (a + b)) ds 0)", "by (simp add: eucl_truncate_up_real_def)"], ["", "lemma aform_err_sum_list':\n  \"y \\<in> aform_err e (c, sum_list' p ds)\"\n  if \"y \\<in> aform_err e (c, sum_list ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> aform_err e (c, sum_list' p ds)", "using that(1)"], ["proof (prove)\nusing this:\n  y \\<in> aform_err e (c, sum_list ds)\n\ngoal (1 subgoal):\n 1. y \\<in> aform_err e (c, sum_list' p ds)", "apply (rule aform_err_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list' p ds", "by (rule sum_list_le_sum_list')"], ["", "lemma aform_err_trunc_bound_eucl:\n  \"y \\<in> aform_err e ((fst (trunc_bound_eucl p X), xs), snd (trunc_bound_eucl p X) + d)\"\n  if y: \"y \\<in> aform_err e ((X, xs), d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> aform_err e\n             ((fst (trunc_bound_eucl p X), xs),\n              snd (trunc_bound_eucl p X) + d)", "using that"], ["proof (prove)\nusing this:\n  y \\<in> aform_err e ((X, xs), d)\n\ngoal (1 subgoal):\n 1. y \\<in> aform_err e\n             ((fst (trunc_bound_eucl p X), xs),\n              snd (trunc_bound_eucl p X) + d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> aform_err e ((X, xs), d) \\<Longrightarrow>\n    y \\<in> aform_err e\n             ((fst (trunc_bound_eucl p X), xs),\n              snd (trunc_bound_eucl p X) + d)", "from aform_errE[OF y]"], ["proof (chain)\npicking this:\n  \\<bar>y - aform_val e (fst ((X, xs), d))\\<bar> \\<le> snd ((X, xs), d)", "have \"\\<bar>y - aform_val e (X, xs)\\<bar> \\<le> d\""], ["proof (prove)\nusing this:\n  \\<bar>y - aform_val e (fst ((X, xs), d))\\<bar> \\<le> snd ((X, xs), d)\n\ngoal (1 subgoal):\n 1. \\<bar>y - aform_val e (X, xs)\\<bar> \\<le> d", "by auto"], ["proof (state)\nthis:\n  \\<bar>y - aform_val e (X, xs)\\<bar> \\<le> d\n\ngoal (1 subgoal):\n 1. y \\<in> aform_err e ((X, xs), d) \\<Longrightarrow>\n    y \\<in> aform_err e\n             ((fst (trunc_bound_eucl p X), xs),\n              snd (trunc_bound_eucl p X) + d)", "then"], ["proof (chain)\npicking this:\n  \\<bar>y - aform_val e (X, xs)\\<bar> \\<le> d", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>y - aform_val e (X, xs)\\<bar> \\<le> d\n\ngoal (1 subgoal):\n 1. y \\<in> aform_err e\n             ((fst (trunc_bound_eucl p X), xs),\n              snd (trunc_bound_eucl p X) + d)", "apply (intro aform_errI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>y - aform_val e (X, xs)\\<bar> \\<le> d \\<Longrightarrow>\n    \\<bar>y -\n          aform_val e\n           (fst ((fst (trunc_bound_eucl p X), xs),\n                 snd (trunc_bound_eucl p X) + d))\\<bar>\n    \\<le> snd ((fst (trunc_bound_eucl p X), xs),\n               snd (trunc_bound_eucl p X) + d)", "apply (rule trunc_bound_euclE[of p X])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>err.\n       \\<lbrakk>\\<bar>y - aform_val e (X, xs)\\<bar> \\<le> d;\n        \\<bar>err\\<bar> \\<le> snd (trunc_bound_eucl p X);\n        fst (trunc_bound_eucl p X) = X + err\\<rbrakk>\n       \\<Longrightarrow> \\<bar>y -\n                               aform_val e\n                                (fst ((fst (trunc_bound_eucl p X), xs),\nsnd (trunc_bound_eucl p X) + d))\\<bar>\n                         \\<le> snd ((fst (trunc_bound_eucl p X), xs),\n                                    snd (trunc_bound_eucl p X) + d)", "by (auto simp: aform_val_def)"], ["proof (state)\nthis:\n  y \\<in> aform_err e\n           ((fst (trunc_bound_eucl p X), xs),\n            snd (trunc_bound_eucl p X) + d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trunc_err_pdevsE:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  obtains err where\n  \"\\<bar>err\\<bar> \\<le> tdev' p (trunc_err_pdevs p xs)\"\n  \"pdevs_val e (trunc_pdevs p xs) = pdevs_val e xs + err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>\\<bar>err\\<bar> \\<le> tdev' p (trunc_err_pdevs p xs);\n         pdevs_val e (trunc_pdevs p xs) = pdevs_val e xs + err\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trunc_bound_pdevsE[of e p xs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n   \\<And>err.\n      \\<lbrakk>\\<bar>err\\<bar> \\<le> snd (trunc_bound_pdevs p xs);\n       pdevs_val e (fst (trunc_bound_pdevs p xs)) =\n       pdevs_val e xs + err\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>\\<bar>err\\<bar> \\<le> tdev' p (trunc_err_pdevs p xs);\n         pdevs_val e (trunc_pdevs p xs) = pdevs_val e xs + err\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: trunc_bound_pdevs_def assms)"], ["", "lemma aform_err_trunc_bound_pdevsI:\n  \"y \\<in> aform_err e ((c, fst (trunc_bound_pdevs p xs)), snd (trunc_bound_pdevs p xs) + d)\"\n  if y: \"y \\<in> aform_err e ((c, xs), d)\"\n  and e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> aform_err e\n             ((c, fst (trunc_bound_pdevs p xs)),\n              snd (trunc_bound_pdevs p xs) + d)", "using that"], ["proof (prove)\nusing this:\n  y \\<in> aform_err e ((c, xs), d)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. y \\<in> aform_err e\n             ((c, fst (trunc_bound_pdevs p xs)),\n              snd (trunc_bound_pdevs p xs) + d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> aform_err e ((c, xs), d);\n     e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n    \\<Longrightarrow> y \\<in> aform_err e\n                               ((c, fst (trunc_bound_pdevs p xs)),\n                                snd (trunc_bound_pdevs p xs) + d)", "define exs where \"exs = trunc_err_pdevs p xs\""], ["proof (state)\nthis:\n  exs = trunc_err_pdevs p xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> aform_err e ((c, xs), d);\n     e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n    \\<Longrightarrow> y \\<in> aform_err e\n                               ((c, fst (trunc_bound_pdevs p xs)),\n                                snd (trunc_bound_pdevs p xs) + d)", "from aform_errE[OF y]"], ["proof (chain)\npicking this:\n  \\<bar>y - aform_val e (fst ((c, xs), d))\\<bar> \\<le> snd ((c, xs), d)", "have \"\\<bar>y - aform_val e (c, xs)\\<bar> \\<le> d\""], ["proof (prove)\nusing this:\n  \\<bar>y - aform_val e (fst ((c, xs), d))\\<bar> \\<le> snd ((c, xs), d)\n\ngoal (1 subgoal):\n 1. \\<bar>y - aform_val e (c, xs)\\<bar> \\<le> d", "by auto"], ["proof (state)\nthis:\n  \\<bar>y - aform_val e (c, xs)\\<bar> \\<le> d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> aform_err e ((c, xs), d);\n     e \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n    \\<Longrightarrow> y \\<in> aform_err e\n                               ((c, fst (trunc_bound_pdevs p xs)),\n                                snd (trunc_bound_pdevs p xs) + d)", "then"], ["proof (chain)\npicking this:\n  \\<bar>y - aform_val e (c, xs)\\<bar> \\<le> d", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>y - aform_val e (c, xs)\\<bar> \\<le> d\n\ngoal (1 subgoal):\n 1. y \\<in> aform_err e\n             ((c, fst (trunc_bound_pdevs p xs)),\n              snd (trunc_bound_pdevs p xs) + d)", "apply (intro aform_errI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>y - aform_val e (c, xs)\\<bar> \\<le> d \\<Longrightarrow>\n    \\<bar>y -\n          aform_val e\n           (fst ((c, fst (trunc_bound_pdevs p xs)),\n                 snd (trunc_bound_pdevs p xs) + d))\\<bar>\n    \\<le> snd ((c, fst (trunc_bound_pdevs p xs)),\n               snd (trunc_bound_pdevs p xs) + d)", "apply (rule trunc_err_pdevsE[OF e, of p xs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>err.\n       \\<lbrakk>\\<bar>y - aform_val e (c, xs)\\<bar> \\<le> d;\n        \\<bar>err\\<bar> \\<le> tdev' p (trunc_err_pdevs p xs);\n        pdevs_val e (trunc_pdevs p xs) = pdevs_val e xs + err\\<rbrakk>\n       \\<Longrightarrow> \\<bar>y -\n                               aform_val e\n                                (fst ((c, fst (trunc_bound_pdevs p xs)),\nsnd (trunc_bound_pdevs p xs) + d))\\<bar>\n                         \\<le> snd ((c, fst (trunc_bound_pdevs p xs)),\n                                    snd (trunc_bound_pdevs p xs) + d)", "by (auto simp: aform_val_def trunc_bound_pdevs_def)"], ["proof (state)\nthis:\n  y \\<in> aform_err e\n           ((c, fst (trunc_bound_pdevs p xs)),\n            snd (trunc_bound_pdevs p xs) + d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aform_err_addI:\n  \"y \\<in> aform_err e ((a + b, xs), d)\"\n  if \"y - b \\<in> aform_err e ((a, xs), d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> aform_err e ((a + b, xs), d)", "using that"], ["proof (prove)\nusing this:\n  y - b \\<in> aform_err e ((a, xs), d)\n\ngoal (1 subgoal):\n 1. y \\<in> aform_err e ((a + b, xs), d)", "by (auto simp: aform_err_def aform_val_def)"], ["", "theorem affine_unop:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes f: \"\\<bar>f x - (a * x + b)\\<bar> \\<le> d\"\n    and e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"f x \\<in> aform_err e (affine_unop p a b d X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e (affine_unop p a b d X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e (affine_unop p a b d X)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e (affine_unop p a b d X)", "unfolding affine_unop_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x\n    \\<in> aform_err e\n           (case X of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (x, xs) \\<Rightarrow>\n                 \\<lambda>xe.\n                    case trunc_bound_eucl p (a * x) of\n                    (ax, axe) \\<Rightarrow>\n                      case trunc_bound_eucl p (ax + b) of\n                      (y, ye) \\<Rightarrow>\n                        case trunc_bound_pdevs p (scaleR_pdevs a xs) of\n                        (ys, yse) \\<Rightarrow>\n                          ((y, ys),\n                           sum_list' p\n                            [truncate_up p (\\<bar>a\\<bar> * xe), axe, ye,\n                             yse, d]))\n               xa)", "apply (auto simp: split_beta')"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x\n    \\<in> aform_err e\n           ((fst (trunc_bound_eucl p\n                   (fst (trunc_bound_eucl p (a * fst (fst X))) + b)),\n             fst (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X))))),\n            sum_list' p\n             [truncate_up p (\\<bar>a\\<bar> * snd X),\n              snd (trunc_bound_eucl p (a * fst (fst X))),\n              snd (trunc_bound_eucl p\n                    (fst (trunc_bound_eucl p (a * fst (fst X))) + b)),\n              snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))), d])", "apply (rule aform_err_sum_list')"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x\n    \\<in> aform_err e\n           ((fst (trunc_bound_eucl p\n                   (fst (trunc_bound_eucl p (a * fst (fst X))) + b)),\n             fst (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X))))),\n            sum_list\n             [truncate_up p (\\<bar>a\\<bar> * snd X),\n              snd (trunc_bound_eucl p (a * fst (fst X))),\n              snd (trunc_bound_eucl p\n                    (fst (trunc_bound_eucl p (a * fst (fst X))) + b)),\n              snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))), d])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x\n    \\<in> aform_err e\n           ((fst (trunc_bound_eucl p\n                   (fst (trunc_bound_eucl p (a * fst (fst X))) + b)),\n             fst (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X))))),\n            truncate_up p (\\<bar>a\\<bar> * snd X) +\n            (snd (trunc_bound_eucl p (a * fst (fst X))) +\n             (snd (trunc_bound_eucl p\n                    (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n              (snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))) +\n               d))))", "apply (rule aform_err_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f x\n    \\<in> aform_err e\n           ((fst (trunc_bound_eucl p\n                   (fst (trunc_bound_eucl p (a * fst (fst X))) + b)),\n             fst (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X))))),\n            ?d'2)\n 2. ?d'2 =\n    truncate_up p (\\<bar>a\\<bar> * snd X) +\n    (snd (trunc_bound_eucl p (a * fst (fst X))) +\n     (snd (trunc_bound_eucl p\n            (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n      (snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))) + d)))", "apply (rule aform_err_trunc_bound_eucl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f x\n    \\<in> aform_err e\n           ((fst (trunc_bound_eucl p (a * fst (fst X))) + b,\n             fst (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X))))),\n            ?d5)\n 2. snd (trunc_bound_eucl p\n          (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n    ?d5 =\n    truncate_up p (\\<bar>a\\<bar> * snd X) +\n    (snd (trunc_bound_eucl p (a * fst (fst X))) +\n     (snd (trunc_bound_eucl p\n            (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n      (snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))) + d)))", "apply (rule aform_err_addI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f x - b\n    \\<in> aform_err e\n           ((fst (trunc_bound_eucl p (a * fst (fst X))),\n             fst (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X))))),\n            ?d5)\n 2. snd (trunc_bound_eucl p\n          (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n    ?d5 =\n    truncate_up p (\\<bar>a\\<bar> * snd X) +\n    (snd (trunc_bound_eucl p (a * fst (fst X))) +\n     (snd (trunc_bound_eucl p\n            (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n      (snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))) + d)))", "apply (rule aform_err_trunc_bound_eucl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f x - b\n    \\<in> aform_err e\n           ((a * fst (fst X),\n             fst (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X))))),\n            ?d9)\n 2. snd (trunc_bound_eucl p\n          (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n    (snd (trunc_bound_eucl p (a * fst (fst X))) + ?d9) =\n    truncate_up p (\\<bar>a\\<bar> * snd X) +\n    (snd (trunc_bound_eucl p (a * fst (fst X))) +\n     (snd (trunc_bound_eucl p\n            (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n      (snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))) + d)))", "apply (rule aform_err_trunc_bound_pdevsI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. f x - b\n    \\<in> aform_err e\n           ((a * fst (fst X), scaleR_pdevs a (snd (fst X))), ?d11)\n 2. e \\<in> UNIV \\<rightarrow> {- 1..1}\n 3. snd (trunc_bound_eucl p\n          (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n    (snd (trunc_bound_eucl p (a * fst (fst X))) +\n     (snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))) + ?d11)) =\n    truncate_up p (\\<bar>a\\<bar> * snd X) +\n    (snd (trunc_bound_eucl p (a * fst (fst X))) +\n     (snd (trunc_bound_eucl p\n            (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n      (snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))) + d)))", "using e"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (3 subgoals):\n 1. f x - b\n    \\<in> aform_err e\n           ((a * fst (fst X), scaleR_pdevs a (snd (fst X))), ?d11)\n 2. e \\<in> UNIV \\<rightarrow> {- 1..1}\n 3. snd (trunc_bound_eucl p\n          (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n    (snd (trunc_bound_eucl p (a * fst (fst X))) +\n     (snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))) + ?d11)) =\n    truncate_up p (\\<bar>a\\<bar> * snd X) +\n    (snd (trunc_bound_eucl p (a * fst (fst X))) +\n     (snd (trunc_bound_eucl p\n            (fst (trunc_bound_eucl p (a * fst (fst X))) + b)) +\n      (snd (trunc_bound_pdevs p (scaleR_pdevs a (snd (fst X)))) + d)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    f x - b\n    \\<in> aform_err e\n           ((a * fst (fst X), scaleR_pdevs a (snd (fst X))),\n            truncate_up p (\\<bar>a\\<bar> * snd X) + d)", "apply (rule aform_errI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b -\n          aform_val e\n           (fst ((a * fst (fst X), scaleR_pdevs a (snd (fst X))),\n                 truncate_up p (\\<bar>a\\<bar> * snd X) + d))\\<bar>\n    \\<le> snd ((a * fst (fst X), scaleR_pdevs a (snd (fst X))),\n               truncate_up p (\\<bar>a\\<bar> * snd X) + d)", "apply (auto simp: aform_val_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "define x' where \"x' = (fst (fst X) + pdevs_val e (snd (fst X)))\""], ["proof (state)\nthis:\n  x' = fst (fst X) + pdevs_val e (snd (fst X))\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "have x_x': \"\\<bar>x - x'\\<bar> \\<le> snd X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x - x'\\<bar> \\<le> snd X", "using aform_errE[OF x]"], ["proof (prove)\nusing this:\n  \\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X\n\ngoal (1 subgoal):\n 1. \\<bar>x - x'\\<bar> \\<le> snd X", "by (auto simp: x'_def aform_val_def)"], ["proof (state)\nthis:\n  \\<bar>x - x'\\<bar> \\<le> snd X\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "have \"\\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar> =\n      \\<bar>f x - (a * x + b) + a * (x - x')\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - b -\n          (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar> =\n    \\<bar>f x - (a * x + b) + a * (x - x')\\<bar>", "by (simp add: algebra_simps x'_def)"], ["proof (state)\nthis:\n  \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar> =\n  \\<bar>f x - (a * x + b) + a * (x - x')\\<bar>\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "also"], ["proof (state)\nthis:\n  \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar> =\n  \\<bar>f x - (a * x + b) + a * (x - x')\\<bar>\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "have \"\\<dots> \\<le> \\<bar>f x - (a * x + b)\\<bar> + \\<bar>a * (x - x')\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b) + a * (x - x')\\<bar>\n    \\<le> \\<bar>f x - (a * x + b)\\<bar> + \\<bar>a * (x - x')\\<bar>", "by (rule abs_triangle_ineq)"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b) + a * (x - x')\\<bar>\n  \\<le> \\<bar>f x - (a * x + b)\\<bar> + \\<bar>a * (x - x')\\<bar>\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "also"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b) + a * (x - x')\\<bar>\n  \\<le> \\<bar>f x - (a * x + b)\\<bar> + \\<bar>a * (x - x')\\<bar>\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "note f"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b)\\<bar> \\<le> d\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "also"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b)\\<bar> \\<le> d\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "have \"\\<bar>a * (x - x')\\<bar> \\<le> truncate_up p (\\<bar>a\\<bar> * snd X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>a * (x - x')\\<bar> \\<le> truncate_up p (\\<bar>a\\<bar> * snd X)", "by (rule truncate_up_le)\n        (auto simp: abs_mult intro!: mult_left_mono x_x')"], ["proof (state)\nthis:\n  \\<bar>a * (x - x')\\<bar> \\<le> truncate_up p (\\<bar>a\\<bar> * snd X)\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>xa y.\n              xa \\<le> y \\<Longrightarrow>\n              xa + \\<bar>a * (x - x')\\<bar>\n              \\<le> y + \\<bar>a * (x - x')\\<bar>;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> d + x \\<le> d + y\\<rbrakk>\n  \\<Longrightarrow> \\<bar>f x - b -\n                          (a * fst (fst X) +\n                           a * pdevs_val e (snd (fst X)))\\<bar>\n                    \\<le> d + truncate_up p (\\<bar>a\\<bar> * snd X)", "show \"\\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar> \\<le>\n        truncate_up p (\\<bar>a\\<bar> * snd X) + d\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xa y.\n              xa \\<le> y \\<Longrightarrow>\n              xa + \\<bar>a * (x - x')\\<bar>\n              \\<le> y + \\<bar>a * (x - x')\\<bar>;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> d + x \\<le> d + y\\<rbrakk>\n  \\<Longrightarrow> \\<bar>f x - b -\n                          (a * fst (fst X) +\n                           a * pdevs_val e (snd (fst X)))\\<bar>\n                    \\<le> d + truncate_up p (\\<bar>a\\<bar> * snd X)\n\ngoal (1 subgoal):\n 1. \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n    \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d", "by auto"], ["proof (state)\nthis:\n  \\<bar>f x - b - (a * fst (fst X) + a * pdevs_val e (snd (fst X)))\\<bar>\n  \\<le> truncate_up p (\\<bar>a\\<bar> * snd X) + d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x \\<in> aform_err e (affine_unop p a b d X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_range_coeffs_ge:\n  \"\\<bar>f x - (a * x + b)\\<bar> \\<le> d\"\n  if l: \"l \\<le> x\" and u: \"x \\<le> u\"\n    and f': \"\\<And>y. y \\<in> {l .. u} \\<Longrightarrow> (f has_real_derivative f' y) (at y)\"\n    and a: \"\\<And>y. y \\<in> {l..u} \\<Longrightarrow> a \\<le> f' y\"\n    and d: \"d \\<ge> (f u - f l - a * (u - l)) / 2 + \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\"\n  for a b d::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar> \\<le> d", "proof (rule order_trans[OF _ d])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "note f'_at = has_field_derivative_at_within[OF f']"], ["proof (state)\nthis:\n  ?x \\<in> {l..u} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x within ?s)\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "from l u"], ["proof (chain)\npicking this:\n  l \\<le> x\n  x \\<le> u", "have lu: \"x \\<in> {l .. u}\" and llu: \"l \\<in> {l .. u}\""], ["proof (prove)\nusing this:\n  l \\<le> x\n  x \\<le> u\n\ngoal (1 subgoal):\n 1. x \\<in> {l..u} &&& l \\<in> {l..u}", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> {l..u}\n  l \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "define m where \"m = (f l + f u - a * (l + u)) / 2\""], ["proof (state)\nthis:\n  m = (f l + f u - a * (l + u)) / 2\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "have \"\\<bar>f x - (a * x + b)\\<bar> = \\<bar>f x - (a * x + m) + (m - b)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar> = \\<bar>f x - (a * x + m) + (m - b)\\<bar>", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b)\\<bar> = \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "also"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b)\\<bar> = \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "have \"\\<dots> \\<le> \\<bar>f x - (a * x + m)\\<bar> + \\<bar>m - b\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n    \\<le> \\<bar>f x - (a * x + m)\\<bar> + \\<bar>m - b\\<bar>", "by (rule abs_triangle_ineq)"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n  \\<le> \\<bar>f x - (a * x + m)\\<bar> + \\<bar>m - b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "also"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n  \\<le> \\<bar>f x - (a * x + m)\\<bar> + \\<bar>m - b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "have \"\\<bar>f x - (a * x + m)\\<bar> \\<le> (f u - f l - a * (u - l)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + m)\\<bar> \\<le> (f u - f l - a * (u - l)) / 2", "proof (rule abs_leI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2\n 2. - (f x - (a * x + m)) \\<le> (f u - f l - a * (u - l)) / 2", "have \"f x \\<ge> f l + a * (x - l)\" (is \"?l \\<ge> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. f l + a * (x - l) \\<le> f x", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f l + a * (x - l) \\<le> ?y\n 2. ?y \\<le> f x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?y \\<le> f x\n 2. f l + a * (x - l) \\<le> ?y", "apply (rule linear_lower2[OF f'_at, of l u a])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> x \\<in> {l..u}\n 2. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> a \\<le> f' x\n 3. x \\<in> {l..u}\n 4. f l + a * (x - l) \\<le> f l + a * (x - l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {l..u} \\<Longrightarrow> x_ \\<in> {l..u}", "by assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> a \\<le> f' x\n 2. x \\<in> {l..u}\n 3. f l + a * (x - l) \\<le> f l + a * (x - l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {l..u} \\<Longrightarrow> a \\<le> f' x_", "by (rule a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> {l..u}\n 2. f l + a * (x - l) \\<le> f l + a * (x - l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {l..u}", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. x \\<in> {l..u}", "by (auto intro!: mult_right_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f l + a * (x - l) \\<le> f l + a * (x - l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. f l + a * (x - l) \\<le> f l + a * (x - l)", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. f l + a * (x - l) \\<le> f l + a * (x - l)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  f l + a * (x - l) \\<le> f x\n\ngoal (2 subgoals):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2\n 2. - (f x - (a * x + m)) \\<le> (f u - f l - a * (u - l)) / 2", "also"], ["proof (state)\nthis:\n  f l + a * (x - l) \\<le> f x\n\ngoal (2 subgoals):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2\n 2. - (f x - (a * x + m)) \\<le> (f u - f l - a * (u - l)) / 2", "have \"a * x + m - (f u - f l - a * (u - l)) / 2 \\<le> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * x + m - (f u - f l - a * (u - l)) / 2 \\<le> f l + a * (x - l)", "by (simp add: algebra_simps m_def field_simps)"], ["proof (state)\nthis:\n  a * x + m - (f u - f l - a * (u - l)) / 2 \\<le> f l + a * (x - l)\n\ngoal (2 subgoals):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2\n 2. - (f x - (a * x + m)) \\<le> (f u - f l - a * (u - l)) / 2", "finally (xtrans)"], ["proof (chain)\npicking this:\n  a * x + m - (f u - f l - a * (u - l)) / 2 \\<le> f x", "show \"- (f x - (a * x + m)) \\<le> (f u - f l - a * (u - l)) / 2\""], ["proof (prove)\nusing this:\n  a * x + m - (f u - f l - a * (u - l)) / 2 \\<le> f x\n\ngoal (1 subgoal):\n 1. - (f x - (a * x + m)) \\<le> (f u - f l - a * (u - l)) / 2", "by (simp add: algebra_simps m_def divide_simps)"], ["proof (state)\nthis:\n  - (f x - (a * x + m)) \\<le> (f u - f l - a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2", "have \"f x \\<le> f u + a * (x - u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> f u + a * (x - u)", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f x \\<le> ?y\n 2. ?y \\<le> f u + a * (x - u)", "apply (rule linear_upper2[OF f'_at, of l u a])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> x \\<in> {l..u}\n 2. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> a \\<le> f' x\n 3. x \\<in> {l..u}\n 4. f u + a * (x - u) \\<le> f u + a * (x - u)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {l..u} \\<Longrightarrow> x_ \\<in> {l..u}", "by assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> a \\<le> f' x\n 2. x \\<in> {l..u}\n 3. f u + a * (x - u) \\<le> f u + a * (x - u)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {l..u} \\<Longrightarrow> a \\<le> f' x_", "by (rule a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> {l..u}\n 2. f u + a * (x - u) \\<le> f u + a * (x - u)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {l..u}", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. x \\<in> {l..u}", "by (auto intro!: mult_right_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f u + a * (x - u) \\<le> f u + a * (x - u)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. f u + a * (x - u) \\<le> f u + a * (x - u)", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. f u + a * (x - u) \\<le> f u + a * (x - u)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  f x \\<le> f u + a * (x - u)\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2", "also"], ["proof (state)\nthis:\n  f x \\<le> f u + a * (x - u)\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2", "have \"\\<dots> \\<le> a * x + m + (f u - f l - a * (u - l)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f u + a * (x - u) \\<le> a * x + m + (f u - f l - a * (u - l)) / 2", "by (simp add: m_def divide_simps algebra_simps)"], ["proof (state)\nthis:\n  f u + a * (x - u) \\<le> a * x + m + (f u - f l - a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2", "finally"], ["proof (chain)\npicking this:\n  f x \\<le> a * x + m + (f u - f l - a * (u - l)) / 2", "show \"f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2\""], ["proof (prove)\nusing this:\n  f x \\<le> a * x + m + (f u - f l - a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2", "by (simp add: algebra_simps m_def divide_simps)"], ["proof (state)\nthis:\n  f x - (a * x + m) \\<le> (f u - f l - a * (u - l)) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + m)\\<bar> \\<le> (f u - f l - a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "also"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + m)\\<bar> \\<le> (f u - f l - a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "have \"\\<bar>m - b\\<bar> = abs ((f l + f u - a * (l + u)) / 2 - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>m - b\\<bar> = \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar> =\n    \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", ".."], ["proof (state)\nthis:\n  \\<bar>m - b\\<bar> = \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + \\<bar>m - b\\<bar> \\<le> y + \\<bar>m - b\\<bar>) \\<Longrightarrow>\n  \\<bar>f x - (a * x + b)\\<bar>\n  \\<le> (f u - f l - a * (u - l)) / 2 +\n        \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "show \"\\<bar>f x - (a * x + b)\\<bar> \\<le> (f u - f l - a * (u - l)) / 2 + \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + \\<bar>m - b\\<bar> \\<le> y + \\<bar>m - b\\<bar>) \\<Longrightarrow>\n  \\<bar>f x - (a * x + b)\\<bar>\n  \\<le> (f u - f l - a * (u - l)) / 2 +\n        \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f u - f l - a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "by (simp)"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b)\\<bar>\n  \\<le> (f u - f l - a * (u - l)) / 2 +\n        \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_range_coeffs_le:\n  \"\\<bar>f x - (a * x + b)\\<bar> \\<le> d\"\n  if l: \"l \\<le> x\" and u: \"x \\<le> u\"\n    and f': \"\\<And>y. y \\<in> {l .. u} \\<Longrightarrow> (f has_real_derivative f' y) (at y)\"\n    and a: \"\\<And>y. y \\<in> {l .. u} \\<Longrightarrow> f' y \\<le> a\"\n    and d: \"d \\<ge> (f l - f u + a * (u - l)) / 2 + \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\"\n  for a b d::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar> \\<le> d", "proof (rule order_trans[OF _ d])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "note f'_at = has_field_derivative_at_within[OF f']"], ["proof (state)\nthis:\n  ?x \\<in> {l..u} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x within ?s)\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "from l u"], ["proof (chain)\npicking this:\n  l \\<le> x\n  x \\<le> u", "have lu: \"x \\<in> {l .. u}\" and llu: \"l \\<in> {l .. u}\""], ["proof (prove)\nusing this:\n  l \\<le> x\n  x \\<le> u\n\ngoal (1 subgoal):\n 1. x \\<in> {l..u} &&& l \\<in> {l..u}", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> {l..u}\n  l \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "define m where \"m = (f l + f u - a * (l + u)) / 2\""], ["proof (state)\nthis:\n  m = (f l + f u - a * (l + u)) / 2\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "have \"\\<bar>f x - (a * x + b)\\<bar> = \\<bar>f x - (a * x + m) + (m - b)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar> = \\<bar>f x - (a * x + m) + (m - b)\\<bar>", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b)\\<bar> = \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "also"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b)\\<bar> = \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "have \"\\<dots> \\<le> \\<bar>f x - (a * x + m)\\<bar> + \\<bar>m - b\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n    \\<le> \\<bar>f x - (a * x + m)\\<bar> + \\<bar>m - b\\<bar>", "by (rule abs_triangle_ineq)"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n  \\<le> \\<bar>f x - (a * x + m)\\<bar> + \\<bar>m - b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "also"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + m) + (m - b)\\<bar>\n  \\<le> \\<bar>f x - (a * x + m)\\<bar> + \\<bar>m - b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "have \"\\<bar>f x - (a * x + m)\\<bar> \\<le> (f l - f u + a * (u - l)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + m)\\<bar> \\<le> (f l - f u + a * (u - l)) / 2", "proof (rule abs_leI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2\n 2. - (f x - (a * x + m)) \\<le> (f l - f u + a * (u - l)) / 2", "have \"f x \\<ge> f u + a * (x - u)\" (is \"?l \\<ge> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. f u + a * (x - u) \\<le> f x", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f u + a * (x - u) \\<le> ?y\n 2. ?y \\<le> f x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?y \\<le> f x\n 2. f u + a * (x - u) \\<le> ?y", "apply (rule linear_lower[OF f'_at, of l u a])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> x \\<in> {l..u}\n 2. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> f' x \\<le> a\n 3. x \\<in> {l..u}\n 4. f u + a * (x - u) \\<le> f u + a * (x - u)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {l..u} \\<Longrightarrow> x_ \\<in> {l..u}", "by assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> f' x \\<le> a\n 2. x \\<in> {l..u}\n 3. f u + a * (x - u) \\<le> f u + a * (x - u)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {l..u} \\<Longrightarrow> f' x_ \\<le> a", "by (rule a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> {l..u}\n 2. f u + a * (x - u) \\<le> f u + a * (x - u)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {l..u}", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. x \\<in> {l..u}", "by (auto intro!: mult_right_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f u + a * (x - u) \\<le> f u + a * (x - u)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. f u + a * (x - u) \\<le> f u + a * (x - u)", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. f u + a * (x - u) \\<le> f u + a * (x - u)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  f u + a * (x - u) \\<le> f x\n\ngoal (2 subgoals):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2\n 2. - (f x - (a * x + m)) \\<le> (f l - f u + a * (u - l)) / 2", "also"], ["proof (state)\nthis:\n  f u + a * (x - u) \\<le> f x\n\ngoal (2 subgoals):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2\n 2. - (f x - (a * x + m)) \\<le> (f l - f u + a * (u - l)) / 2", "have \"a * x + m - (f l - f u + a * (u - l)) / 2 \\<le> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * x + m - (f l - f u + a * (u - l)) / 2 \\<le> f u + a * (x - u)", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. a * x + m - (f l - f u + a * (u - l)) / 2 \\<le> f u + a * (x - u)", "by (auto simp add: algebra_simps m_def field_simps intro!: mult_left_mono_neg)"], ["proof (state)\nthis:\n  a * x + m - (f l - f u + a * (u - l)) / 2 \\<le> f u + a * (x - u)\n\ngoal (2 subgoals):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2\n 2. - (f x - (a * x + m)) \\<le> (f l - f u + a * (u - l)) / 2", "finally (xtrans)"], ["proof (chain)\npicking this:\n  a * x + m - (f l - f u + a * (u - l)) / 2 \\<le> f x", "show \"- (f x - (a * x + m)) \\<le> (f l - f u + a * (u - l)) / 2\""], ["proof (prove)\nusing this:\n  a * x + m - (f l - f u + a * (u - l)) / 2 \\<le> f x\n\ngoal (1 subgoal):\n 1. - (f x - (a * x + m)) \\<le> (f l - f u + a * (u - l)) / 2", "by (simp add: algebra_simps m_def divide_simps)"], ["proof (state)\nthis:\n  - (f x - (a * x + m)) \\<le> (f l - f u + a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2", "have \"f x \\<le> f l + a * (x - l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> f l + a * (x - l)", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f x \\<le> ?y\n 2. ?y \\<le> f l + a * (x - l)", "apply (rule linear_upper[OF f'_at, of l u a])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> x \\<in> {l..u}\n 2. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> f' x \\<le> a\n 3. x \\<in> {l..u}\n 4. f l + a * (x - l) \\<le> f l + a * (x - l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {l..u} \\<Longrightarrow> x_ \\<in> {l..u}", "by assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> {l..u} \\<Longrightarrow> f' x \\<le> a\n 2. x \\<in> {l..u}\n 3. f l + a * (x - l) \\<le> f l + a * (x - l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {l..u} \\<Longrightarrow> f' x_ \\<le> a", "by (rule a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> {l..u}\n 2. f l + a * (x - l) \\<le> f l + a * (x - l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {l..u}", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. x \\<in> {l..u}", "by (auto intro!: mult_right_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f l + a * (x - l) \\<le> f l + a * (x - l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. f l + a * (x - l) \\<le> f l + a * (x - l)", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. f l + a * (x - l) \\<le> f l + a * (x - l)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  f x \\<le> f l + a * (x - l)\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2", "also"], ["proof (state)\nthis:\n  f x \\<le> f l + a * (x - l)\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2", "have \"\\<dots> \\<le> a * x + m + (f l - f u + a * (u - l)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f l + a * (x - l) \\<le> a * x + m + (f l - f u + a * (u - l)) / 2", "using lu"], ["proof (prove)\nusing this:\n  x \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. f l + a * (x - l) \\<le> a * x + m + (f l - f u + a * (u - l)) / 2", "by (auto simp add: algebra_simps m_def field_simps intro!: mult_left_mono_neg)"], ["proof (state)\nthis:\n  f l + a * (x - l) \\<le> a * x + m + (f l - f u + a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2", "finally"], ["proof (chain)\npicking this:\n  f x \\<le> a * x + m + (f l - f u + a * (u - l)) / 2", "show \"f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2\""], ["proof (prove)\nusing this:\n  f x \\<le> a * x + m + (f l - f u + a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2", "by (simp add: algebra_simps m_def divide_simps)"], ["proof (state)\nthis:\n  f x - (a * x + m) \\<le> (f l - f u + a * (u - l)) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + m)\\<bar> \\<le> (f l - f u + a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "also"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + m)\\<bar> \\<le> (f l - f u + a * (u - l)) / 2\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "have \"\\<bar>m - b\\<bar> = abs ((f l + f u - a * (l + u)) / 2 - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>m - b\\<bar> = \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar> =\n    \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", ".."], ["proof (state)\nthis:\n  \\<bar>m - b\\<bar> = \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + \\<bar>m - b\\<bar> \\<le> y + \\<bar>m - b\\<bar>) \\<Longrightarrow>\n  \\<bar>f x - (a * x + b)\\<bar>\n  \\<le> (f l - f u + a * (u - l)) / 2 +\n        \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "show \"\\<bar>f x - (a * x + b)\\<bar> \\<le> (f l - f u + a * (u - l)) / 2 + \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + \\<bar>m - b\\<bar> \\<le> y + \\<bar>m - b\\<bar>) \\<Longrightarrow>\n  \\<bar>f x - (a * x + b)\\<bar>\n  \\<le> (f l - f u + a * (u - l)) / 2 +\n        \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f x - (a * x + b)\\<bar>\n    \\<le> (f l - f u + a * (u - l)) / 2 +\n          \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>", "by (simp)"], ["proof (state)\nthis:\n  \\<bar>f x - (a * x + b)\\<bar>\n  \\<le> (f l - f u + a * (u - l)) / 2 +\n        \\<bar>(f l + f u - a * (l + u)) / 2 - b\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "context includes floatarith_notation begin"], ["", "definition \"range_reducer p l =\n  (if l < 0 \\<or> l > 2 * lb_pi p\n  then approx p (Pi * (Num (-2)) * (Floor (Num (l * Float 1 (-1)) / Pi))) []\n  else Some 0)\""], ["", "lemmas approx_emptyD = approx[OF bounded_by_None[of Nil], simplified]"], ["", "lemma range_reducerE:\n  assumes \"range_reducer p l = Some ivl\"\n  obtains n::int where \"n * (2 * pi) \\<in>\\<^sub>r ivl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"l \\<ge> 0 \\<and> l \\<le> 2 * lb_pi p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     \\<not> (0 \\<le> l \\<and> l \\<le> 2 * lb_pi p)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> (0 \\<le> l \\<and> l \\<le> 2 * lb_pi p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     \\<not> (0 \\<le> l \\<and> l \\<le> 2 * lb_pi p)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms"], ["proof (chain)\npicking this:\n  range_reducer p l = Some ivl\n  \\<not> (0 \\<le> l \\<and> l \\<le> 2 * lb_pi p)", "have \"- \\<lfloor>l / (2 * pi)\\<rfloor> * (2 * pi) \\<in>\\<^sub>r ivl\""], ["proof (prove)\nusing this:\n  range_reducer p l = Some ivl\n  \\<not> (0 \\<le> l \\<and> l \\<le> 2 * lb_pi p)\n\ngoal (1 subgoal):\n 1. real_of_int (- \\<lfloor>real_of_float l / (2 * pi)\\<rfloor>) * (2 * pi)\n    \\<in>\\<^sub>r ivl", "by (auto simp: range_reducer_def bind_eq_Some_conv inverse_eq_divide\n        algebra_simps dest!: approx_emptyD)"], ["proof (state)\nthis:\n  real_of_int (- \\<lfloor>real_of_float l / (2 * pi)\\<rfloor>) * (2 * pi)\n  \\<in>\\<^sub>r ivl\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     \\<not> (0 \\<le> l \\<and> l \\<le> 2 * lb_pi p)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  real_of_int (- \\<lfloor>real_of_float l / (2 * pi)\\<rfloor>) * (2 * pi)\n  \\<in>\\<^sub>r ivl", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (- \\<lfloor>real_of_float l / (2 * pi)\\<rfloor>) * (2 * pi)\n  \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  0 \\<le> l \\<and> l \\<le> 2 * lb_pi p", "have \"real_of_int 0 * (2 * pi) \\<in>\\<^sub>r ivl\""], ["proof (prove)\nusing this:\n  0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\n\ngoal (1 subgoal):\n 1. real_of_int 0 * (2 * pi) \\<in>\\<^sub>r ivl", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\n  range_reducer p l = Some ivl\n\ngoal (1 subgoal):\n 1. real_of_int 0 * (2 * pi) \\<in>\\<^sub>r ivl", "by (auto simp: range_reducer_def zero_in_float_intervalI)"], ["proof (state)\nthis:\n  real_of_int 0 * (2 * pi) \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                real_of_int n * (2 * pi) \\<in>\\<^sub>r ivl \\<Longrightarrow>\n                thesis;\n     0 \\<le> l \\<and> l \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  real_of_int 0 * (2 * pi) \\<in>\\<^sub>r ivl", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int 0 * (2 * pi) \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"range_reduce_aform_err p X = do {\n  r \\<leftarrow> range_reducer p (lower (ivl_of_aform_err p X));\n  Some (add_aform' p X (ivl_err (real_interval r)))\n}\""], ["", "lemma range_reduce_aform_errE:\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"range_reduce_aform_err p X = Some Y\"\n  obtains n::int where \"x + n * (2 * pi) \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x + real_of_int n * (2 * pi) \\<in> aform_err e Y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x + real_of_int n * (2 * pi) \\<in> aform_err e Y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  x \\<in> aform_err e X\n  range_reduce_aform_err p X = Some Y", "obtain r\n    where x: \"x \\<in> aform_err e X\"\n     and r: \"range_reducer p (lower (ivl_of_aform_err p X)) = Some r\"\n     and Y:  \"Y = add_aform' p X (ivl_err (real_interval r))\""], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  x \\<in> aform_err e X\n  range_reduce_aform_err p X = Some Y\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>x \\<in> aform_err e X;\n         range_reducer p (lower (ivl_of_aform_err p X)) = Some r;\n         Y = add_aform' p X (ivl_err (real_interval r))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: range_reduce_aform_err_def bind_eq_Some_conv mid_err_def split: prod.splits)"], ["proof (state)\nthis:\n  x \\<in> aform_err e X\n  range_reducer p (lower (ivl_of_aform_err p X)) = Some r\n  Y = add_aform' p X (ivl_err (real_interval r))\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x + real_of_int n * (2 * pi) \\<in> aform_err e Y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from range_reducerE[OF r]"], ["proof (chain)\npicking this:\n  (\\<And>n.\n      real_of_int n * (2 * pi) \\<in>\\<^sub>r r \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain n::int where \"n * (2 * pi) \\<in>\\<^sub>r r\""], ["proof (prove)\nusing this:\n  (\\<And>n.\n      real_of_int n * (2 * pi) \\<in>\\<^sub>r r \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        real_of_int n * (2 * pi) \\<in>\\<^sub>r r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  real_of_int n * (2 * pi) \\<in>\\<^sub>r r\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x + real_of_int n * (2 * pi) \\<in> aform_err e Y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  real_of_int n * (2 * pi) \\<in>\\<^sub>r r", "have \"n * (2 * pi) \\<in> aform_err e (ivl_err (real_interval r))\""], ["proof (prove)\nusing this:\n  real_of_int n * (2 * pi) \\<in>\\<^sub>r r\n\ngoal (1 subgoal):\n 1. real_of_int n * (2 * pi) \\<in> aform_err e (ivl_err (real_interval r))", "by (auto simp: aform_val_def ac_simps divide_simps abs_real_def set_of_eq intro!: aform_errI)"], ["proof (state)\nthis:\n  real_of_int n * (2 * pi) \\<in> aform_err e (ivl_err (real_interval r))\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x + real_of_int n * (2 * pi) \\<in> aform_err e Y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from add_aform'[OF e x this, of p]"], ["proof (chain)\npicking this:\n  x + real_of_int n * (2 * pi)\n  \\<in> aform_err e (add_aform' p X (ivl_err (real_interval r)))", "have \"x + n * (2 * pi) \\<in> aform_err e Y\""], ["proof (prove)\nusing this:\n  x + real_of_int n * (2 * pi)\n  \\<in> aform_err e (add_aform' p X (ivl_err (real_interval r)))\n\ngoal (1 subgoal):\n 1. x + real_of_int n * (2 * pi) \\<in> aform_err e Y", "by (auto simp: Y)"], ["proof (state)\nthis:\n  x + real_of_int n * (2 * pi) \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x + real_of_int n * (2 * pi) \\<in> aform_err e Y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  x + real_of_int n * (2 * pi) \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  x + real_of_int n * (2 * pi) \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"min_range_mono p F DF l u X = do {\n  let L = Num l;\n  let U = Num u;\n  aivl \\<leftarrow> approx p (Min (DF L) (DF U)) [];\n  let a = lower aivl;\n  let A = Num a;\n  bivl \\<leftarrow> approx p (Half (F L + F U - A * (L + U))) [];\n  let (b, be) = mid_err bivl;\n  let (B, Be) = (Num (float_of b), Num (float_of be));\n  divl \\<leftarrow> approx p ((Half (F U - F L - A * (U - L))) + Be) [];\n  Some (affine_unop p a b (real_of_float (upper divl)) X)\n}\""], ["", "lemma min_range_mono:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"l \\<le> x\" \"x \\<le> u\"\n  assumes \"min_range_mono p F DF l u X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes F: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> interpret_floatarith (F (Num x)) [] = f x\"\n  assumes DF: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> interpret_floatarith (DF (Num x)) [] = f' x\"\n  assumes f': \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> (f has_real_derivative f' x) (at x)\"\n  assumes f'_le: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> min (f' l) (f' u) \\<le> f' x\"\n  shows \"f x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> aform_err e X\n  real_of_float l \\<le> x\n  x \\<le> real_of_float u\n  min_range_mono p F DF l u X = Some Y\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  real_of_float ?x\n  \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  interpret_floatarith (F (Num ?x)) [] = f (real_of_float ?x)\n  real_of_float ?x\n  \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  interpret_floatarith (DF (Num ?x)) [] = f' (real_of_float ?x)\n  ?x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x)\n  ?x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  min (f' (real_of_float l)) (f' (real_of_float u)) \\<le> f' ?x", "obtain a b be bivl divl\n    where bivl: \"(f l + f u - a * (l + u))/2 \\<in>\\<^sub>r bivl\"\n      and Y: \"Y = affine_unop p a b (upper divl) X\"\n      and du: \"(f u - f l - a * (u - l)) / 2 + be \\<in>\\<^sub>r divl\"\n      and a: \"a \\<le> f' l\" \"a \\<le> f' u\"\n      and b_def: \"b = (lower bivl + upper bivl) / 2\"\n      and be_def: \"be = (upper bivl - lower bivl) / 2\""], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X\n  real_of_float l \\<le> x\n  x \\<le> real_of_float u\n  min_range_mono p F DF l u X = Some Y\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  real_of_float ?x\n  \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  interpret_floatarith (F (Num ?x)) [] = f (real_of_float ?x)\n  real_of_float ?x\n  \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  interpret_floatarith (DF (Num ?x)) [] = f' (real_of_float ?x)\n  ?x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x)\n  ?x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  min (f' (real_of_float l)) (f' (real_of_float u)) \\<le> f' ?x\n\ngoal (1 subgoal):\n 1. (\\<And>a bivl b divl be.\n        \\<lbrakk>(f (real_of_float l) + f (real_of_float u) -\n                  real_of_float (a * (l + u))) /\n                 2\n                 \\<in>\\<^sub>r bivl;\n         Y =\n         affine_unop p (real_of_float a) b (real_of_float (upper divl)) X;\n         (f (real_of_float u) - f (real_of_float l) -\n          real_of_float (a * (u - l))) /\n         2 +\n         be\n         \\<in>\\<^sub>r divl;\n         real_of_float a \\<le> f' (real_of_float l);\n         real_of_float a \\<le> f' (real_of_float u);\n         b = real_of_float (lower bivl + upper bivl) / 2;\n         be = real_of_float (upper bivl - lower bivl) / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: min_range_mono_def Let_def bind_eq_Some_conv mid_err_def set_of_eq\n        simp del: eq_divide_eq_numeral1\n        split: prod.splits if_splits dest!: approx_emptyD)"], ["proof (state)\nthis:\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float (a * (l + u))) /\n  2\n  \\<in>\\<^sub>r bivl\n  Y = affine_unop p (real_of_float a) b (real_of_float (upper divl)) X\n  (f (real_of_float u) - f (real_of_float l) -\n   real_of_float (a * (u - l))) /\n  2 +\n  be\n  \\<in>\\<^sub>r divl\n  real_of_float a \\<le> f' (real_of_float l)\n  real_of_float a \\<le> f' (real_of_float u)\n  b = real_of_float (lower bivl + upper bivl) / 2\n  be = real_of_float (upper bivl - lower bivl) / 2\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "have diff_le: \"real_of_float a \\<le> f' y\" if \"real_of_float l \\<le> y\" \"y \\<le> u\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float a \\<le> f' y", "using f'_le[of y] that a"], ["proof (prove)\nusing this:\n  y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  min (f' (real_of_float l)) (f' (real_of_float u)) \\<le> f' y\n  real_of_float l \\<le> y\n  y \\<le> real_of_float u\n  real_of_float a \\<le> f' (real_of_float l)\n  real_of_float a \\<le> f' (real_of_float u)\n\ngoal (1 subgoal):\n 1. real_of_float a \\<le> f' y", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>real_of_float l \\<le> ?y; ?y \\<le> real_of_float u\\<rbrakk>\n  \\<Longrightarrow> real_of_float a \\<le> f' ?y\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "have le_be: \"\\<bar>(f (l) + f (u) - a * (real_of_float l + u)) / 2 - b\\<bar> \\<le> be\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> be", "using bivl"], ["proof (prove)\nusing this:\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float (a * (l + u))) /\n  2\n  \\<in>\\<^sub>r bivl\n\ngoal (1 subgoal):\n 1. \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> be", "unfolding b_def be_def"], ["proof (prove)\nusing this:\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float (a * (l + u))) /\n  2\n  \\<in>\\<^sub>r bivl\n\ngoal (1 subgoal):\n 1. \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          real_of_float (lower bivl + upper bivl) / 2\\<bar>\n    \\<le> real_of_float (upper bivl - lower bivl) / 2", "by (auto simp: abs_real_def divide_simps set_of_eq)"], ["proof (state)\nthis:\n  \\<bar>(f (real_of_float l) + f (real_of_float u) -\n         real_of_float a * (real_of_float l + real_of_float u)) /\n        2 -\n        b\\<bar>\n  \\<le> be\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "have \"\\<bar>f x - (a * x + b)\\<bar> \\<le> upper divl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (real_of_float a * x + b)\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule min_range_coeffs_ge)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?l \\<le> x\n 2. x \\<le> ?u\n 3. \\<And>y.\n       y \\<in> {?l..?u} \\<Longrightarrow>\n       (f has_real_derivative ?f' y) (at y)\n 4. \\<And>y. y \\<in> {?l..?u} \\<Longrightarrow> real_of_float a \\<le> ?f' y\n 5. (f ?u - f ?l - real_of_float a * (?u - ?l)) / 2 +\n    \\<bar>(f ?l + f ?u - real_of_float a * (?l + ?u)) / 2 - b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule \\<open>l \\<le> x\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<le> ?u\n 2. \\<And>y.\n       y \\<in> {real_of_float l..?u} \\<Longrightarrow>\n       (f has_real_derivative ?f' y) (at y)\n 3. \\<And>y.\n       y \\<in> {real_of_float l..?u} \\<Longrightarrow>\n       real_of_float a \\<le> ?f' y\n 4. (f ?u - f (real_of_float l) -\n     real_of_float a * (?u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f ?u -\n           real_of_float a * (real_of_float l + ?u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule \\<open>x \\<le> u\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (f has_real_derivative ?f' y) (at y)\n 2. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       real_of_float a \\<le> ?f' y\n 3. (f (real_of_float u) - f (real_of_float l) -\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule f')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       y \\<in> {real_of_float l..real_of_float u}\n 2. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       real_of_float a \\<le> f' y\n 3. (f (real_of_float u) - f (real_of_float l) -\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       real_of_float a \\<le> f' y\n 2. (f (real_of_float u) - f (real_of_float l) -\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "using diff_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>real_of_float l \\<le> ?y; ?y \\<le> real_of_float u\\<rbrakk>\n  \\<Longrightarrow> real_of_float a \\<le> f' ?y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       real_of_float a \\<le> f' y\n 2. (f (real_of_float u) - f (real_of_float l) -\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f (real_of_float u) - f (real_of_float l) -\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule order_trans[OF add_mono[OF order_refl]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> ?d13\n 2. (f (real_of_float u) - f (real_of_float l) -\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    ?d13\n    \\<le> real_of_float (upper divl)", "apply (rule le_be)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f (real_of_float u) - f (real_of_float l) -\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    be\n    \\<le> real_of_float (upper divl)", "using bivl du"], ["proof (prove)\nusing this:\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float (a * (l + u))) /\n  2\n  \\<in>\\<^sub>r bivl\n  (f (real_of_float u) - f (real_of_float l) -\n   real_of_float (a * (u - l))) /\n  2 +\n  be\n  \\<in>\\<^sub>r divl\n\ngoal (1 subgoal):\n 1. (f (real_of_float u) - f (real_of_float l) -\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    be\n    \\<le> real_of_float (upper divl)", "unfolding b_def[symmetric] be_def[symmetric]"], ["proof (prove)\nusing this:\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float (a * (l + u))) /\n  2\n  \\<in>\\<^sub>r bivl\n  (f (real_of_float u) - f (real_of_float l) -\n   real_of_float (a * (u - l))) /\n  2 +\n  be\n  \\<in>\\<^sub>r divl\n\ngoal (1 subgoal):\n 1. (f (real_of_float u) - f (real_of_float l) -\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    be\n    \\<le> real_of_float (upper divl)", "by (auto simp: set_of_eq)"], ["proof (state)\nthis:\n  \\<bar>f x - (real_of_float a * x + b)\\<bar>\n  \\<le> real_of_float (upper divl)\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "from affine_unop[where f=f and p = p, OF \\<open>x \\<in> _\\<close> this e]"], ["proof (chain)\npicking this:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)", "have \"f x \\<in> aform_err e (affine_unop p (real_of_float a) b (upper divl) X)\""], ["proof (prove)\nusing this:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)\n\ngoal (1 subgoal):\n 1. f x\n    \\<in> aform_err e\n           (affine_unop p (real_of_float a) b (real_of_float (upper divl))\n             X)", "by (auto simp: Y)"], ["proof (state)\nthis:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)", "show ?thesis"], ["proof (prove)\nusing this:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "by (simp add: Y b_def)"], ["proof (state)\nthis:\n  f x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"min_range_antimono p F DF l u X = do {\n  let L = Num l;\n  let U = Num u;\n  aivl \\<leftarrow> approx p (Max (DF L) (DF U)) [];\n  let a = upper aivl;\n  let A = Num a;\n  bivl \\<leftarrow> approx p (Half (F L + F U - A * (L + U))) [];\n  let (b, be) = mid_err bivl;\n  let (B, Be) = (Num (float_of b), Num (float_of be));\n  divl \\<leftarrow> approx p (Add (Half (F L - F U + A * (U - L))) Be) [];\n  Some (affine_unop p a b (real_of_float (upper divl)) X)\n}\""], ["", "lemma min_range_antimono:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"l \\<le> x\" \"x \\<le> u\"\n  assumes \"min_range_antimono p F DF l u X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes F: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> interpret_floatarith (F (Num x)) [] = f x\"\n  assumes DF: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> interpret_floatarith (DF (Num x)) [] = f' x\"\n  assumes f': \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> (f has_real_derivative f' x) (at x)\"\n  assumes f'_le: \"\\<And>x. x \\<in> {real_of_float l .. u} \\<Longrightarrow> f' x \\<le> max (f' l) (f' u)\"\n  shows \"f x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> aform_err e X\n  real_of_float l \\<le> x\n  x \\<le> real_of_float u\n  min_range_antimono p F DF l u X = Some Y\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  real_of_float ?x\n  \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  interpret_floatarith (F (Num ?x)) [] = f (real_of_float ?x)\n  real_of_float ?x\n  \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  interpret_floatarith (DF (Num ?x)) [] = f' (real_of_float ?x)\n  ?x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x)\n  ?x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  f' ?x \\<le> max (f' (real_of_float l)) (f' (real_of_float u))", "obtain a b be aivl bivl divl\n    where bivl: \"(f l + f u - real_of_float a * (l + u)) / 2 \\<in>\\<^sub>r bivl\"\n    and Y: \"Y = affine_unop p a b (real_of_float (upper divl)) X\"\n    and du: \"(f l - f u + a * (u - l)) / 2 + be \\<in>\\<^sub>r divl\"\n    and a: \"f' l \\<le> a\" \"f' u \\<le> a\"\n    and a_def: \"a = upper aivl\"\n    and b_def: \"b = (lower bivl + upper bivl) / 2\"\n    and be_def: \"be = (upper bivl - lower bivl) / 2\""], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X\n  real_of_float l \\<le> x\n  x \\<le> real_of_float u\n  min_range_antimono p F DF l u X = Some Y\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  real_of_float ?x\n  \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  interpret_floatarith (F (Num ?x)) [] = f (real_of_float ?x)\n  real_of_float ?x\n  \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  interpret_floatarith (DF (Num ?x)) [] = f' (real_of_float ?x)\n  ?x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  (f has_real_derivative f' ?x) (at ?x)\n  ?x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  f' ?x \\<le> max (f' (real_of_float l)) (f' (real_of_float u))\n\ngoal (1 subgoal):\n 1. (\\<And>a bivl b divl be aivl.\n        \\<lbrakk>(f (real_of_float l) + f (real_of_float u) -\n                  real_of_float a * real_of_float (l + u)) /\n                 2\n                 \\<in>\\<^sub>r bivl;\n         Y =\n         affine_unop p (real_of_float a) b (real_of_float (upper divl)) X;\n         (f (real_of_float l) - f (real_of_float u) +\n          real_of_float (a * (u - l))) /\n         2 +\n         be\n         \\<in>\\<^sub>r divl;\n         f' (real_of_float l) \\<le> real_of_float a;\n         f' (real_of_float u) \\<le> real_of_float a; a = upper aivl;\n         b = real_of_float (lower bivl + upper bivl) / 2;\n         be = real_of_float (upper bivl - lower bivl) / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: min_range_antimono_def Let_def bind_eq_Some_conv mid_err_def set_of_eq\n        simp del: eq_divide_eq_numeral1\n        split: prod.splits if_splits dest!: approx_emptyD)"], ["proof (state)\nthis:\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float a * real_of_float (l + u)) /\n  2\n  \\<in>\\<^sub>r bivl\n  Y = affine_unop p (real_of_float a) b (real_of_float (upper divl)) X\n  (f (real_of_float l) - f (real_of_float u) +\n   real_of_float (a * (u - l))) /\n  2 +\n  be\n  \\<in>\\<^sub>r divl\n  f' (real_of_float l) \\<le> real_of_float a\n  f' (real_of_float u) \\<le> real_of_float a\n  a = upper aivl\n  b = real_of_float (lower bivl + upper bivl) / 2\n  be = real_of_float (upper bivl - lower bivl) / 2\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "have diff_le: \"f' y \\<le> real_of_float a\" if \"real_of_float l \\<le> y\" \"y \\<le> u\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f' y \\<le> real_of_float a", "using f'_le[of y] that a"], ["proof (prove)\nusing this:\n  y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n  f' y \\<le> max (f' (real_of_float l)) (f' (real_of_float u))\n  real_of_float l \\<le> y\n  y \\<le> real_of_float u\n  f' (real_of_float l) \\<le> real_of_float a\n  f' (real_of_float u) \\<le> real_of_float a\n\ngoal (1 subgoal):\n 1. f' y \\<le> real_of_float a", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>real_of_float l \\<le> ?y; ?y \\<le> real_of_float u\\<rbrakk>\n  \\<Longrightarrow> f' ?y \\<le> real_of_float a\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "have le_be: \"\\<bar>(f (l) + f (u) - a * (real_of_float l + u)) / 2 - b\\<bar> \\<le> be\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> be", "using bivl"], ["proof (prove)\nusing this:\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float a * real_of_float (l + u)) /\n  2\n  \\<in>\\<^sub>r bivl\n\ngoal (1 subgoal):\n 1. \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> be", "unfolding b_def be_def"], ["proof (prove)\nusing this:\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float a * real_of_float (l + u)) /\n  2\n  \\<in>\\<^sub>r bivl\n\ngoal (1 subgoal):\n 1. \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          real_of_float (lower bivl + upper bivl) / 2\\<bar>\n    \\<le> real_of_float (upper bivl - lower bivl) / 2", "by (auto simp: abs_real_def divide_simps set_of_eq)"], ["proof (state)\nthis:\n  \\<bar>(f (real_of_float l) + f (real_of_float u) -\n         real_of_float a * (real_of_float l + real_of_float u)) /\n        2 -\n        b\\<bar>\n  \\<le> be\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "have \"\\<bar>f x - (a * x + b)\\<bar> \\<le> upper divl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f x - (real_of_float a * x + b)\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule min_range_coeffs_le)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?l \\<le> x\n 2. x \\<le> ?u\n 3. \\<And>y.\n       y \\<in> {?l..?u} \\<Longrightarrow>\n       (f has_real_derivative ?f' y) (at y)\n 4. \\<And>y. y \\<in> {?l..?u} \\<Longrightarrow> ?f' y \\<le> real_of_float a\n 5. (f ?l - f ?u + real_of_float a * (?u - ?l)) / 2 +\n    \\<bar>(f ?l + f ?u - real_of_float a * (?l + ?u)) / 2 - b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule \\<open>l \\<le> x\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<le> ?u\n 2. \\<And>y.\n       y \\<in> {real_of_float l..?u} \\<Longrightarrow>\n       (f has_real_derivative ?f' y) (at y)\n 3. \\<And>y.\n       y \\<in> {real_of_float l..?u} \\<Longrightarrow>\n       ?f' y \\<le> real_of_float a\n 4. (f (real_of_float l) - f ?u +\n     real_of_float a * (?u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f ?u -\n           real_of_float a * (real_of_float l + ?u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule \\<open>x \\<le> u\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (f has_real_derivative ?f' y) (at y)\n 2. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       ?f' y \\<le> real_of_float a\n 3. (f (real_of_float l) - f (real_of_float u) +\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule f')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       y \\<in> {real_of_float l..real_of_float u}\n 2. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       f' y \\<le> real_of_float a\n 3. (f (real_of_float l) - f (real_of_float u) +\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       f' y \\<le> real_of_float a\n 2. (f (real_of_float l) - f (real_of_float u) +\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "using diff_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>real_of_float l \\<le> ?y; ?y \\<le> real_of_float u\\<rbrakk>\n  \\<Longrightarrow> f' ?y \\<le> real_of_float a\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       f' y \\<le> real_of_float a\n 2. (f (real_of_float l) - f (real_of_float u) +\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f (real_of_float l) - f (real_of_float u) +\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> real_of_float (upper divl)", "apply (rule order_trans[OF add_mono[OF order_refl]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bar>(f (real_of_float l) + f (real_of_float u) -\n           real_of_float a * (real_of_float l + real_of_float u)) /\n          2 -\n          b\\<bar>\n    \\<le> ?d13\n 2. (f (real_of_float l) - f (real_of_float u) +\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    ?d13\n    \\<le> real_of_float (upper divl)", "apply (rule le_be)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f (real_of_float l) - f (real_of_float u) +\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    be\n    \\<le> real_of_float (upper divl)", "using du bivl"], ["proof (prove)\nusing this:\n  (f (real_of_float l) - f (real_of_float u) +\n   real_of_float (a * (u - l))) /\n  2 +\n  be\n  \\<in>\\<^sub>r divl\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float a * real_of_float (l + u)) /\n  2\n  \\<in>\\<^sub>r bivl\n\ngoal (1 subgoal):\n 1. (f (real_of_float l) - f (real_of_float u) +\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    be\n    \\<le> real_of_float (upper divl)", "unfolding b_def[symmetric] be_def[symmetric]"], ["proof (prove)\nusing this:\n  (f (real_of_float l) - f (real_of_float u) +\n   real_of_float (a * (u - l))) /\n  2 +\n  be\n  \\<in>\\<^sub>r divl\n  (f (real_of_float l) + f (real_of_float u) -\n   real_of_float a * real_of_float (l + u)) /\n  2\n  \\<in>\\<^sub>r bivl\n\ngoal (1 subgoal):\n 1. (f (real_of_float l) - f (real_of_float u) +\n     real_of_float a * (real_of_float u - real_of_float l)) /\n    2 +\n    be\n    \\<le> real_of_float (upper divl)", "by (auto simp: set_of_eq)"], ["proof (state)\nthis:\n  \\<bar>f x - (real_of_float a * x + b)\\<bar>\n  \\<le> real_of_float (upper divl)\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "from affine_unop[where f=f and p = p, OF \\<open>x \\<in> _\\<close> this e]"], ["proof (chain)\npicking this:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)", "have \"f x \\<in> aform_err e (affine_unop p (real_of_float a) b (upper divl) X)\""], ["proof (prove)\nusing this:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)\n\ngoal (1 subgoal):\n 1. f x\n    \\<in> aform_err e\n           (affine_unop p (real_of_float a) b (real_of_float (upper divl))\n             X)", "by (auto simp: Y)"], ["proof (state)\nthis:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)", "show ?thesis"], ["proof (prove)\nusing this:\n  f x\n  \\<in> aform_err e\n         (affine_unop p (real_of_float a) b (real_of_float (upper divl)) X)\n\ngoal (1 subgoal):\n 1. f x \\<in> aform_err e Y", "by (simp add: Y b_def)"], ["proof (state)\nthis:\n  f x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"cos_aform_err p X = do {\n  X \\<leftarrow> range_reduce_aform_err p X;\n  let ivl = ivl_of_aform_err p X;\n  let l = lower ivl;\n  let u = upper ivl;\n  let L = Num l;\n  let U = Num u;\n  if l \\<ge> 0 \\<and> u \\<le> lb_pi p then\n   min_range_antimono p Cos (\\<lambda>x. (Minus (Sin x))) l u X\n  else if l \\<ge> ub_pi p \\<and> u \\<le> 2 * lb_pi p then\n   min_range_mono p Cos (\\<lambda>x. (Minus (Sin x))) l u X\n  else do {\n    Some (ivl_err (real_interval (cos_float_interval p ivl)))\n  }\n}\""], ["", "lemma abs_half_enclosure:\n  fixes r::real\n  assumes \"bl \\<le> r\" \"r \\<le> bu\"\n  shows \"\\<bar>r - (bl + bu) / 2\\<bar> \\<le> (bu - bl) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>r - (bl + bu) / 2\\<bar> \\<le> (bu - bl) / 2", "using assms"], ["proof (prove)\nusing this:\n  bl \\<le> r\n  r \\<le> bu\n\ngoal (1 subgoal):\n 1. \\<bar>r - (bl + bu) / 2\\<bar> \\<le> (bu - bl) / 2", "by (auto simp: abs_real_def divide_simps)"], ["", "lemma cos_aform_err:\n  assumes x: \"x \\<in> aform_err e X0\"\n  assumes \"cos_aform_err p X0 = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"cos x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> aform_err e X0\n  cos_aform_err p X0 = Some Y\n  e \\<in> UNIV \\<rightarrow> {- 1..1}", "obtain X ivl l u where\n    X: \"range_reduce_aform_err p X0 = Some X\"\n    and ivl_def: \"ivl = ivl_of_aform_err p X\"\n    and l_def: \"l = lower ivl\"\n    and u_def: \"u = upper ivl\""], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X0\n  cos_aform_err p X0 = Some Y\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<And>X ivl l u.\n        \\<lbrakk>range_reduce_aform_err p X0 = Some X;\n         ivl = ivl_of_aform_err p X; l = lower ivl; u = upper ivl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: cos_aform_err_def bind_eq_Some_conv)"], ["proof (state)\nthis:\n  range_reduce_aform_err p X0 = Some X\n  ivl = ivl_of_aform_err p X\n  l = lower ivl\n  u = upper ivl\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "from range_reduce_aform_errE[OF e x X]"], ["proof (chain)\npicking this:\n  (\\<And>n.\n      x + real_of_int n * (2 * pi) \\<in> aform_err e X \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain n where xn: \"x + real_of_int n * (2 * pi) \\<in> aform_err e X\""], ["proof (prove)\nusing this:\n  (\\<And>n.\n      x + real_of_int n * (2 * pi) \\<in> aform_err e X \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x + real_of_int n * (2 * pi) \\<in> aform_err e X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x + real_of_int n * (2 * pi) \\<in> aform_err e X\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "define xn where \"xn = x + n * (2 * pi)\""], ["proof (state)\nthis:\n  xn = x + real_of_int n * (2 * pi)\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "with xn"], ["proof (chain)\npicking this:\n  x + real_of_int n * (2 * pi) \\<in> aform_err e X\n  xn = x + real_of_int n * (2 * pi)", "have xn: \"xn \\<in> aform_err e X\""], ["proof (prove)\nusing this:\n  x + real_of_int n * (2 * pi) \\<in> aform_err e X\n  xn = x + real_of_int n * (2 * pi)\n\ngoal (1 subgoal):\n 1. xn \\<in> aform_err e X", "by auto"], ["proof (state)\nthis:\n  xn \\<in> aform_err e X\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "from ivl_of_aform_err[OF e xn, of p, folded ivl_def]"], ["proof (chain)\npicking this:\n  xn \\<in>\\<^sub>r ivl", "have \"xn \\<in>\\<^sub>r ivl\""], ["proof (prove)\nusing this:\n  xn \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. xn \\<in>\\<^sub>r ivl", "."], ["proof (state)\nthis:\n  xn \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  xn \\<in>\\<^sub>r ivl", "have lxn: \"l \\<le> xn\" and uxn: \"xn \\<le> u\""], ["proof (prove)\nusing this:\n  xn \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. real_of_float l \\<le> xn &&& xn \\<le> real_of_float u", "by (auto simp: l_def u_def set_of_eq)"], ["proof (state)\nthis:\n  real_of_float l \\<le> xn\n  xn \\<le> real_of_float u\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "consider \"l \\<ge> 0\" \"u \\<le> lb_pi p\"\n    | \"l < 0 \\<or> u > lb_pi p\" \"l \\<ge> ub_pi p\" \"u \\<le> 2 * lb_pi p\"\n    | \"l < 0 \\<or> u > lb_pi p\" \"l < ub_pi p \\<or> u > 2 * lb_pi p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n      u \\<le> 2 * lb_pi p\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n      l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n    u \\<le> 2 * lb_pi p\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n    l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n    u \\<le> 2 * lb_pi p\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n    l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n    u \\<le> 2 * lb_pi p\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n    l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 3. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "case 1"], ["proof (state)\nthis:\n  0 \\<le> l\n  u \\<le> lb_pi p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 3. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  0 \\<le> l\n  u \\<le> lb_pi p", "have min_eq_Some: \"min_range_antimono p Cos (\\<lambda>x. Minus (Sin x)) l u X = Some Y\"\n      and bounds: \"0 \\<le> l\" \"u \\<le> (lb_pi p)\""], ["proof (prove)\nusing this:\n  0 \\<le> l\n  u \\<le> lb_pi p\n\ngoal (1 subgoal):\n 1. min_range_antimono p Cos (\\<lambda>x. Minus (Sin x)) l u X = Some Y &&&\n    0 \\<le> l &&& u \\<le> lb_pi p", "using assms(2)"], ["proof (prove)\nusing this:\n  0 \\<le> l\n  u \\<le> lb_pi p\n  cos_aform_err p X0 = Some Y\n\ngoal (1 subgoal):\n 1. min_range_antimono p Cos (\\<lambda>x. Minus (Sin x)) l u X = Some Y &&&\n    0 \\<le> l &&& u \\<le> lb_pi p", "unfolding cos_aform_err_def X l_def u_def"], ["proof (prove)\nusing this:\n  0 \\<le> lower ivl\n  upper ivl \\<le> lb_pi p\n  Some X \\<bind>\n  (\\<lambda>X.\n      let ivl = ivl_of_aform_err p X; l = lower ivl; u = upper ivl;\n          L = Num l; U = Num u\n      in if 0 \\<le> l \\<and> u \\<le> lb_pi p\n         then min_range_antimono p Cos (\\<lambda>x. Minus (Sin x)) l u X\n         else if ub_pi p \\<le> l \\<and> u \\<le> 2 * lb_pi p\n              then min_range_mono p Cos (\\<lambda>x. Minus (Sin x)) l u X\n              else Some\n                    (ivl_err (real_interval (cos_float_interval p ivl)))) =\n  Some Y\n\ngoal (1 subgoal):\n 1. min_range_antimono p Cos (\\<lambda>x. Minus (Sin x)) (lower ivl)\n     (upper ivl) X =\n    Some Y &&&\n    0 \\<le> lower ivl &&& upper ivl \\<le> lb_pi p", "by (auto simp: X Let_def simp flip: l_def u_def ivl_def  split: prod.splits)"], ["proof (state)\nthis:\n  min_range_antimono p Cos (\\<lambda>x. Minus (Sin x)) l u X = Some Y\n  0 \\<le> l\n  u \\<le> lb_pi p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 3. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "have bounds: \"0 \\<le> l\" \"u \\<le> pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> l &&& real_of_float u \\<le> pi", "using bounds pi_boundaries[of p]"], ["proof (prove)\nusing this:\n  0 \\<le> l\n  u \\<le> lb_pi p\n  pi \\<in> {real_of_float (lb_pi p)..real_of_float (ub_pi p)}\n\ngoal (1 subgoal):\n 1. 0 \\<le> l &&& real_of_float u \\<le> pi", "by auto"], ["proof (state)\nthis:\n  0 \\<le> l\n  real_of_float u \\<le> pi\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 3. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "have diff_le: \"- sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))\"\n      if \"real_of_float l \\<le> y\" \"y \\<le> real_of_float u\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "consider \"y \\<le> pi / 2\" | \"y \\<ge> pi / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<le> pi / 2 \\<Longrightarrow> thesis;\n     pi / 2 \\<le> y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<le> pi / 2 \\<Longrightarrow> ?thesis;\n   pi / 2 \\<le> y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>y \\<le> pi / 2 \\<Longrightarrow> ?thesis;\n   pi / 2 \\<le> y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<le> pi / 2 \\<Longrightarrow> ?thesis;\n   pi / 2 \\<le> y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<le> pi / 2 \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))\n 2. pi / 2 \\<le> y \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "case 1"], ["proof (state)\nthis:\n  y \\<le> pi / 2\n\ngoal (2 subgoals):\n 1. y \\<le> pi / 2 \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))\n 2. pi / 2 \\<le> y \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "then"], ["proof (chain)\npicking this:\n  y \\<le> pi / 2", "have \"- sin y \\<le> - sin l\""], ["proof (prove)\nusing this:\n  y \\<le> pi / 2\n\ngoal (1 subgoal):\n 1. - sin y \\<le> - sin (real_of_float l)", "using that bounds"], ["proof (prove)\nusing this:\n  y \\<le> pi / 2\n  real_of_float l \\<le> y\n  y \\<le> real_of_float u\n  0 \\<le> l\n  real_of_float u \\<le> pi\n\ngoal (1 subgoal):\n 1. - sin y \\<le> - sin (real_of_float l)", "by (auto intro!: sin_monotone_2pi_le)"], ["proof (state)\nthis:\n  - sin y \\<le> - sin (real_of_float l)\n\ngoal (2 subgoals):\n 1. y \\<le> pi / 2 \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))\n 2. pi / 2 \\<le> y \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "then"], ["proof (chain)\npicking this:\n  - sin y \\<le> - sin (real_of_float l)", "show ?thesis"], ["proof (prove)\nusing this:\n  - sin y \\<le> - sin (real_of_float l)\n\ngoal (1 subgoal):\n 1. - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "by auto"], ["proof (state)\nthis:\n  - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))\n\ngoal (1 subgoal):\n 1. pi / 2 \\<le> y \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pi / 2 \\<le> y \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "case 2"], ["proof (state)\nthis:\n  pi / 2 \\<le> y\n\ngoal (1 subgoal):\n 1. pi / 2 \\<le> y \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "then"], ["proof (chain)\npicking this:\n  pi / 2 \\<le> y", "have \"- sin y \\<le> - sin u\""], ["proof (prove)\nusing this:\n  pi / 2 \\<le> y\n\ngoal (1 subgoal):\n 1. - sin y \\<le> - sin (real_of_float u)", "using that bounds"], ["proof (prove)\nusing this:\n  pi / 2 \\<le> y\n  real_of_float l \\<le> y\n  y \\<le> real_of_float u\n  0 \\<le> l\n  real_of_float u \\<le> pi\n\ngoal (1 subgoal):\n 1. - sin y \\<le> - sin (real_of_float u)", "unfolding sin_minus_pi[symmetric]"], ["proof (prove)\nusing this:\n  pi / 2 \\<le> y\n  real_of_float l \\<le> y\n  y \\<le> real_of_float u\n  0 \\<le> l\n  real_of_float u \\<le> pi\n\ngoal (1 subgoal):\n 1. sin (y - pi) \\<le> sin (real_of_float u - pi)", "apply (intro sin_monotone_2pi_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pi / 2 \\<le> y; real_of_float l \\<le> y;\n     y \\<le> real_of_float u; 0 \\<le> l; real_of_float u \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> - (pi / 2) \\<le> y - pi\n 2. \\<lbrakk>pi / 2 \\<le> y; real_of_float l \\<le> y;\n     y \\<le> real_of_float u; 0 \\<le> l; real_of_float u \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> y - pi \\<le> real_of_float u - pi\n 3. \\<lbrakk>pi / 2 \\<le> y; real_of_float l \\<le> y;\n     y \\<le> real_of_float u; 0 \\<le> l; real_of_float u \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> real_of_float u - pi \\<le> pi / 2", "by (auto intro!: )"], ["proof (state)\nthis:\n  - sin y \\<le> - sin (real_of_float u)\n\ngoal (1 subgoal):\n 1. pi / 2 \\<le> y \\<Longrightarrow>\n    - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "then"], ["proof (chain)\npicking this:\n  - sin y \\<le> - sin (real_of_float u)", "show ?thesis"], ["proof (prove)\nusing this:\n  - sin y \\<le> - sin (real_of_float u)\n\ngoal (1 subgoal):\n 1. - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "by auto"], ["proof (state)\nthis:\n  - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - sin y \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>real_of_float l \\<le> ?y; ?y \\<le> real_of_float u\\<rbrakk>\n  \\<Longrightarrow> - sin ?y\n                    \\<le> max (- sin (real_of_float l))\n                           (- sin (real_of_float u))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 3. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "have \"cos xn \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos xn \\<in> aform_err e Y", "apply (rule min_range_antimono[OF xn lxn uxn min_eq_Some e, where f'=\"\\<lambda>x. - sin x\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Cos (Num x)) [] = cos (real_of_float x)\n 2. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Minus (Sin (Num x))) [] =\n       - sin (real_of_float x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (cos has_real_derivative - sin x) (at x)\n 4. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       - sin x \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Cos (Num x_)) [] = cos (real_of_float x_)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Minus (Sin (Num x))) [] =\n       - sin (real_of_float x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (cos has_real_derivative - sin x) (at x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       - sin x \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Minus (Sin (Num x_))) [] =\n    - sin (real_of_float x_)", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (cos has_real_derivative - sin x) (at x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       - sin x \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    (cos has_real_derivative - sin x_) (at x_)", "by (auto intro!: derivative_eq_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       - sin x \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    - sin x_ \\<le> max (- sin (real_of_float l)) (- sin (real_of_float u))", "by (rule diff_le) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cos xn \\<in> aform_err e Y\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> l; u \\<le> lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 3. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  cos xn \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  cos xn \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "unfolding xn_def"], ["proof (prove)\nusing this:\n  cos (x + real_of_int n * (2 * pi)) \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "by (simp add: )"], ["proof (state)\nthis:\n  cos x \\<in> aform_err e Y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "case 2"], ["proof (state)\nthis:\n  l < 0 \\<or> lb_pi p < u\n  ub_pi p \\<le> l\n  u \\<le> 2 * lb_pi p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  l < 0 \\<or> lb_pi p < u\n  ub_pi p \\<le> l\n  u \\<le> 2 * lb_pi p", "have min_eq_Some: \"min_range_mono p Cos (\\<lambda>x. Minus (Sin x)) l u X = Some Y\"\n      and bounds: \"ub_pi p \\<le> l\" \"u \\<le> 2 * lb_pi p\""], ["proof (prove)\nusing this:\n  l < 0 \\<or> lb_pi p < u\n  ub_pi p \\<le> l\n  u \\<le> 2 * lb_pi p\n\ngoal (1 subgoal):\n 1. min_range_mono p Cos (\\<lambda>x. Minus (Sin x)) l u X = Some Y &&&\n    ub_pi p \\<le> l &&& u \\<le> 2 * lb_pi p", "using assms(2)"], ["proof (prove)\nusing this:\n  l < 0 \\<or> lb_pi p < u\n  ub_pi p \\<le> l\n  u \\<le> 2 * lb_pi p\n  cos_aform_err p X0 = Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Cos (\\<lambda>x. Minus (Sin x)) l u X = Some Y &&&\n    ub_pi p \\<le> l &&& u \\<le> 2 * lb_pi p", "unfolding cos_aform_err_def X"], ["proof (prove)\nusing this:\n  l < 0 \\<or> lb_pi p < u\n  ub_pi p \\<le> l\n  u \\<le> 2 * lb_pi p\n  Some X \\<bind>\n  (\\<lambda>X.\n      let ivl = ivl_of_aform_err p X; l = lower ivl; u = upper ivl;\n          L = Num l; U = Num u\n      in if 0 \\<le> l \\<and> u \\<le> lb_pi p\n         then min_range_antimono p Cos (\\<lambda>x. Minus (Sin x)) l u X\n         else if ub_pi p \\<le> l \\<and> u \\<le> 2 * lb_pi p\n              then min_range_mono p Cos (\\<lambda>x. Minus (Sin x)) l u X\n              else Some\n                    (ivl_err (real_interval (cos_float_interval p ivl)))) =\n  Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Cos (\\<lambda>x. Minus (Sin x)) l u X = Some Y &&&\n    ub_pi p \\<le> l &&& u \\<le> 2 * lb_pi p", "by (auto simp: X Let_def simp flip: l_def u_def ivl_def split: prod.splits)"], ["proof (state)\nthis:\n  min_range_mono p Cos (\\<lambda>x. Minus (Sin x)) l u X = Some Y\n  ub_pi p \\<le> l\n  u \\<le> 2 * lb_pi p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "have bounds: \"pi \\<le> l\" \"u \\<le> 2 * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi \\<le> real_of_float l &&& real_of_float u \\<le> 2 * pi", "using bounds pi_boundaries[of p]"], ["proof (prove)\nusing this:\n  ub_pi p \\<le> l\n  u \\<le> 2 * lb_pi p\n  pi \\<in> {real_of_float (lb_pi p)..real_of_float (ub_pi p)}\n\ngoal (1 subgoal):\n 1. pi \\<le> real_of_float l &&& real_of_float u \\<le> 2 * pi", "by auto"], ["proof (state)\nthis:\n  pi \\<le> real_of_float l\n  real_of_float u \\<le> 2 * pi\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "have diff_le: \"min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y\"\n      if \"real_of_float l \\<le> y\" \"y \\<le> real_of_float u\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "consider \"y \\<le> 3 * pi / 2\" | \"y \\<ge> 3 * pi / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<le> 3 * pi / 2 \\<Longrightarrow> thesis;\n     3 * pi / 2 \\<le> y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<le> 3 * pi / 2 \\<Longrightarrow> ?thesis;\n   3 * pi / 2 \\<le> y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>y \\<le> 3 * pi / 2 \\<Longrightarrow> ?thesis;\n   3 * pi / 2 \\<le> y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<le> 3 * pi / 2 \\<Longrightarrow> ?thesis;\n   3 * pi / 2 \\<le> y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<le> 3 * pi / 2 \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y\n 2. 3 * pi / 2 \\<le> y \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "case 1"], ["proof (state)\nthis:\n  y \\<le> 3 * pi / 2\n\ngoal (2 subgoals):\n 1. y \\<le> 3 * pi / 2 \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y\n 2. 3 * pi / 2 \\<le> y \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "then"], ["proof (chain)\npicking this:\n  y \\<le> 3 * pi / 2", "have \"- sin l \\<le> - sin y\""], ["proof (prove)\nusing this:\n  y \\<le> 3 * pi / 2\n\ngoal (1 subgoal):\n 1. - sin (real_of_float l) \\<le> - sin y", "unfolding sin_minus_pi[symmetric]"], ["proof (prove)\nusing this:\n  y \\<le> 3 * pi / 2\n\ngoal (1 subgoal):\n 1. sin (real_of_float l - pi) \\<le> sin (y - pi)", "apply (intro sin_monotone_2pi_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<le> 3 * pi / 2 \\<Longrightarrow>\n    - (pi / 2) \\<le> real_of_float l - pi\n 2. y \\<le> 3 * pi / 2 \\<Longrightarrow> real_of_float l - pi \\<le> y - pi\n 3. y \\<le> 3 * pi / 2 \\<Longrightarrow> y - pi \\<le> pi / 2", "using that bounds"], ["proof (prove)\nusing this:\n  real_of_float l \\<le> y\n  y \\<le> real_of_float u\n  pi \\<le> real_of_float l\n  real_of_float u \\<le> 2 * pi\n\ngoal (3 subgoals):\n 1. y \\<le> 3 * pi / 2 \\<Longrightarrow>\n    - (pi / 2) \\<le> real_of_float l - pi\n 2. y \\<le> 3 * pi / 2 \\<Longrightarrow> real_of_float l - pi \\<le> y - pi\n 3. y \\<le> 3 * pi / 2 \\<Longrightarrow> y - pi \\<le> pi / 2", "by (auto)"], ["proof (state)\nthis:\n  - sin (real_of_float l) \\<le> - sin y\n\ngoal (2 subgoals):\n 1. y \\<le> 3 * pi / 2 \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y\n 2. 3 * pi / 2 \\<le> y \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "then"], ["proof (chain)\npicking this:\n  - sin (real_of_float l) \\<le> - sin y", "show ?thesis"], ["proof (prove)\nusing this:\n  - sin (real_of_float l) \\<le> - sin y\n\ngoal (1 subgoal):\n 1. min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "by auto"], ["proof (state)\nthis:\n  min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y\n\ngoal (1 subgoal):\n 1. 3 * pi / 2 \\<le> y \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 * pi / 2 \\<le> y \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "case 2"], ["proof (state)\nthis:\n  3 * pi / 2 \\<le> y\n\ngoal (1 subgoal):\n 1. 3 * pi / 2 \\<le> y \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "then"], ["proof (chain)\npicking this:\n  3 * pi / 2 \\<le> y", "have \"- sin u \\<le> - sin y\""], ["proof (prove)\nusing this:\n  3 * pi / 2 \\<le> y\n\ngoal (1 subgoal):\n 1. - sin (real_of_float u) \\<le> - sin y", "unfolding sin_2pi_minus[symmetric]"], ["proof (prove)\nusing this:\n  3 * pi / 2 \\<le> y\n\ngoal (1 subgoal):\n 1. sin (2 * pi - real_of_float u) \\<le> sin (2 * pi - y)", "using that bounds"], ["proof (prove)\nusing this:\n  3 * pi / 2 \\<le> y\n  real_of_float l \\<le> y\n  y \\<le> real_of_float u\n  pi \\<le> real_of_float l\n  real_of_float u \\<le> 2 * pi\n\ngoal (1 subgoal):\n 1. sin (2 * pi - real_of_float u) \\<le> sin (2 * pi - y)", "apply (intro sin_monotone_2pi_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>3 * pi / 2 \\<le> y; real_of_float l \\<le> y;\n     y \\<le> real_of_float u; pi \\<le> real_of_float l;\n     real_of_float u \\<le> 2 * pi\\<rbrakk>\n    \\<Longrightarrow> - (pi / 2) \\<le> 2 * pi - real_of_float u\n 2. \\<lbrakk>3 * pi / 2 \\<le> y; real_of_float l \\<le> y;\n     y \\<le> real_of_float u; pi \\<le> real_of_float l;\n     real_of_float u \\<le> 2 * pi\\<rbrakk>\n    \\<Longrightarrow> 2 * pi - real_of_float u \\<le> 2 * pi - y\n 3. \\<lbrakk>3 * pi / 2 \\<le> y; real_of_float l \\<le> y;\n     y \\<le> real_of_float u; pi \\<le> real_of_float l;\n     real_of_float u \\<le> 2 * pi\\<rbrakk>\n    \\<Longrightarrow> 2 * pi - y \\<le> pi / 2", "by (auto intro!: )"], ["proof (state)\nthis:\n  - sin (real_of_float u) \\<le> - sin y\n\ngoal (1 subgoal):\n 1. 3 * pi / 2 \\<le> y \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "then"], ["proof (chain)\npicking this:\n  - sin (real_of_float u) \\<le> - sin y", "show ?thesis"], ["proof (prove)\nusing this:\n  - sin (real_of_float u) \\<le> - sin y\n\ngoal (1 subgoal):\n 1. min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y", "by auto"], ["proof (state)\nthis:\n  min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>real_of_float l \\<le> ?y; ?y \\<le> real_of_float u\\<rbrakk>\n  \\<Longrightarrow> min (- sin (real_of_float l)) (- sin (real_of_float u))\n                    \\<le> - sin ?y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "have \"cos xn \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos xn \\<in> aform_err e Y", "apply (rule min_range_mono[OF xn lxn uxn min_eq_Some e, where f'=\"\\<lambda>x. - sin x\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Cos (Num x)) [] = cos (real_of_float x)\n 2. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Minus (Sin (Num x))) [] =\n       - sin (real_of_float x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (cos has_real_derivative - sin x) (at x)\n 4. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Cos (Num x_)) [] = cos (real_of_float x_)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Minus (Sin (Num x))) [] =\n       - sin (real_of_float x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (cos has_real_derivative - sin x) (at x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Minus (Sin (Num x_))) [] =\n    - sin (real_of_float x_)", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (cos has_real_derivative - sin x) (at x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    (cos has_real_derivative - sin x_) (at x_)", "by (auto intro!: derivative_eq_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    min (- sin (real_of_float l)) (- sin (real_of_float u)) \\<le> - sin x_", "by (rule diff_le) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cos xn \\<in> aform_err e Y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u; ub_pi p \\<le> l;\n     u \\<le> 2 * lb_pi p\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y\n 2. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  cos xn \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  cos xn \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "unfolding xn_def"], ["proof (prove)\nusing this:\n  cos (x + real_of_int n * (2 * pi)) \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "by (simp add: )"], ["proof (state)\nthis:\n  cos x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "case 3"], ["proof (state)\nthis:\n  l < 0 \\<or> lb_pi p < u\n  l < ub_pi p \\<or> 2 * lb_pi p < u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  l < 0 \\<or> lb_pi p < u\n  l < ub_pi p \\<or> 2 * lb_pi p < u", "obtain ivl' where\n      \"cos_float_interval p ivl = ivl'\"\n      \"Y = ivl_err (real_interval ivl')\""], ["proof (prove)\nusing this:\n  l < 0 \\<or> lb_pi p < u\n  l < ub_pi p \\<or> 2 * lb_pi p < u\n\ngoal (1 subgoal):\n 1. (\\<And>ivl'.\n        \\<lbrakk>cos_float_interval p ivl = ivl';\n         Y = ivl_err (real_interval ivl')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  l < 0 \\<or> lb_pi p < u\n  l < ub_pi p \\<or> 2 * lb_pi p < u\n  cos_aform_err p X0 = Some Y\n\ngoal (1 subgoal):\n 1. (\\<And>ivl'.\n        \\<lbrakk>cos_float_interval p ivl = ivl';\n         Y = ivl_err (real_interval ivl')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding cos_aform_err_def X l_def u_def"], ["proof (prove)\nusing this:\n  lower ivl < 0 \\<or> lb_pi p < upper ivl\n  lower ivl < ub_pi p \\<or> 2 * lb_pi p < upper ivl\n  Some X \\<bind>\n  (\\<lambda>X.\n      let ivl = ivl_of_aform_err p X; l = lower ivl; u = upper ivl;\n          L = Num l; U = Num u\n      in if 0 \\<le> l \\<and> u \\<le> lb_pi p\n         then min_range_antimono p Cos (\\<lambda>x. Minus (Sin x)) l u X\n         else if ub_pi p \\<le> l \\<and> u \\<le> 2 * lb_pi p\n              then min_range_mono p Cos (\\<lambda>x. Minus (Sin x)) l u X\n              else Some\n                    (ivl_err (real_interval (cos_float_interval p ivl)))) =\n  Some Y\n\ngoal (1 subgoal):\n 1. (\\<And>ivl'.\n        \\<lbrakk>cos_float_interval p ivl = ivl';\n         Y = ivl_err (real_interval ivl')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: X simp flip: l_def u_def ivl_def split: prod.splits)"], ["proof (state)\nthis:\n  cos_float_interval p ivl = ivl'\n  Y = ivl_err (real_interval ivl')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l < 0 \\<or> lb_pi p < u;\n     l < ub_pi p \\<or> 2 * lb_pi p < u\\<rbrakk>\n    \\<Longrightarrow> cos x \\<in> aform_err e Y", "with cos_float_intervalI[OF \\<open>xn \\<in>\\<^sub>r ivl\\<close>, of p]"], ["proof (chain)\npicking this:\n  cos xn \\<in>\\<^sub>r cos_float_interval p ivl\n  cos_float_interval p ivl = ivl'\n  Y = ivl_err (real_interval ivl')", "show ?thesis"], ["proof (prove)\nusing this:\n  cos xn \\<in>\\<^sub>r cos_float_interval p ivl\n  cos_float_interval p ivl = ivl'\n  Y = ivl_err (real_interval ivl')\n\ngoal (1 subgoal):\n 1. cos x \\<in> aform_err e Y", "by (auto simp: xn_def)"], ["proof (state)\nthis:\n  cos x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cos x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"sqrt_aform_err p X = do {\n  let ivl = ivl_of_aform_err p X;\n  let l = lower ivl;\n  let u = upper ivl;\n  if 0 < l then min_range_mono p Sqrt (\\<lambda>x. Half (Inverse (Sqrt x))) l u X\n  else Some (ivl_err (real_interval (sqrt_float_interval p ivl)))\n}\""], ["", "lemma sqrt_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"sqrt_aform_err p X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"sqrt x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "obtain l u ivl\n    where ivl_def: \"ivl = ivl_of_aform_err p X\"\n    and l_def: \"l = lower ivl\"\n    and u_def: \"u = upper ivl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ivl l u.\n        \\<lbrakk>ivl = ivl_of_aform_err p X; l = lower ivl;\n         u = upper ivl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ivl = ivl_of_aform_err p X\n  l = lower ivl\n  u = upper ivl\n\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "from ivl_of_aform_err[OF e x, of p, folded ivl_def]"], ["proof (chain)\npicking this:\n  x \\<in>\\<^sub>r ivl", "have ivl: \"x \\<in>\\<^sub>r ivl\""], ["proof (prove)\nusing this:\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. x \\<in>\\<^sub>r ivl", "."], ["proof (state)\nthis:\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  x \\<in>\\<^sub>r ivl", "have lx: \"l \\<le> x\" and ux: \"x \\<le> u\""], ["proof (prove)\nusing this:\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. real_of_float l \\<le> x &&& x \\<le> real_of_float u", "by (auto simp flip: ivl_def simp: l_def u_def set_of_eq)"], ["proof (state)\nthis:\n  real_of_float l \\<le> x\n  x \\<le> real_of_float u\n\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "consider \"l > 0\" | \"l \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l \\<Longrightarrow> thesis;\n     l \\<le> 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>0 < l \\<Longrightarrow> ?thesis;\n   l \\<le> 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < l \\<Longrightarrow> ?thesis;\n   l \\<le> 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < l \\<Longrightarrow> ?thesis;\n   l \\<le> 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> sqrt x \\<in> aform_err e Y\n 2. l \\<le> 0 \\<Longrightarrow> sqrt x \\<in> aform_err e Y", "case 1"], ["proof (state)\nthis:\n  0 < l\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> sqrt x \\<in> aform_err e Y\n 2. l \\<le> 0 \\<Longrightarrow> sqrt x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  0 < l", "have min_eq_Some: \"min_range_mono p Sqrt (\\<lambda>x. Half (Inverse (Sqrt x))) l u X = Some Y\"\n      and bounds: \"0 < l\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. min_range_mono p Sqrt (\\<lambda>x. Half (Inverse (Sqrt x))) l u X =\n    Some Y &&&\n    0 < l", "using assms(2)"], ["proof (prove)\nusing this:\n  0 < l\n  sqrt_aform_err p X = Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Sqrt (\\<lambda>x. Half (Inverse (Sqrt x))) l u X =\n    Some Y &&&\n    0 < l", "unfolding sqrt_aform_err_def"], ["proof (prove)\nusing this:\n  0 < l\n  (let ivl = ivl_of_aform_err p X; l = lower ivl; u = upper ivl\n   in if 0 < l\n      then min_range_mono p Sqrt (\\<lambda>x. Half (Inverse (Sqrt x))) l u X\n      else Some (ivl_err (real_interval (sqrt_float_interval p ivl)))) =\n  Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Sqrt (\\<lambda>x. Half (Inverse (Sqrt x))) l u X =\n    Some Y &&&\n    0 < l", "by (auto simp: Let_def simp flip: l_def u_def ivl_def split: prod.splits)"], ["proof (state)\nthis:\n  min_range_mono p Sqrt (\\<lambda>x. Half (Inverse (Sqrt x))) l u X = Some Y\n  0 < l\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> sqrt x \\<in> aform_err e Y\n 2. l \\<le> 0 \\<Longrightarrow> sqrt x \\<in> aform_err e Y", "have \"sqrt x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "apply (rule min_range_mono[OF x lx ux min_eq_Some e, where f'=\"\\<lambda>x. 1 / (2 * sqrt x)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Sqrt (Num x)) [] = sqrt (real_of_float x)\n 2. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Half (Inverse (Sqrt (Num x)))) [] =\n       1 / (2 * sqrt (real_of_float x))\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (sqrt has_real_derivative 1 / (2 * sqrt x)) (at x)\n 4. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (1 / (2 * sqrt (real_of_float l)))\n        (1 / (2 * sqrt (real_of_float u)))\n       \\<le> 1 / (2 * sqrt x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Sqrt (Num x_)) [] = sqrt (real_of_float x_)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Half (Inverse (Sqrt (Num x)))) [] =\n       1 / (2 * sqrt (real_of_float x))\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (sqrt has_real_derivative 1 / (2 * sqrt x)) (at x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (1 / (2 * sqrt (real_of_float l)))\n        (1 / (2 * sqrt (real_of_float u)))\n       \\<le> 1 / (2 * sqrt x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Half (Inverse (Sqrt (Num x_)))) [] =\n    1 / (2 * sqrt (real_of_float x_))", "by (simp add: divide_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (sqrt has_real_derivative 1 / (2 * sqrt x)) (at x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (1 / (2 * sqrt (real_of_float l)))\n        (1 / (2 * sqrt (real_of_float u)))\n       \\<le> 1 / (2 * sqrt x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    (sqrt has_real_derivative 1 / (2 * sqrt x_)) (at x_)", "using bounds"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    (sqrt has_real_derivative 1 / (2 * sqrt x_)) (at x_)", "by (auto intro!: derivative_eq_intros simp: inverse_eq_divide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (1 / (2 * sqrt (real_of_float l)))\n        (1 / (2 * sqrt (real_of_float u)))\n       \\<le> 1 / (2 * sqrt x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    min (1 / (2 * sqrt (real_of_float l)))\n     (1 / (2 * sqrt (real_of_float u)))\n    \\<le> 1 / (2 * sqrt x_)", "using \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    min (1 / (2 * sqrt (real_of_float l)))\n     (1 / (2 * sqrt (real_of_float u)))\n    \\<le> 1 / (2 * sqrt x_)", "by (auto simp: inverse_eq_divide min_def divide_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sqrt x \\<in> aform_err e Y\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> sqrt x \\<in> aform_err e Y\n 2. l \\<le> 0 \\<Longrightarrow> sqrt x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  sqrt x \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  sqrt x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "by (simp add: )"], ["proof (state)\nthis:\n  sqrt x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. l \\<le> 0 \\<Longrightarrow> sqrt x \\<in> aform_err e Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<le> 0 \\<Longrightarrow> sqrt x \\<in> aform_err e Y", "case 2"], ["proof (state)\nthis:\n  l \\<le> 0\n\ngoal (1 subgoal):\n 1. l \\<le> 0 \\<Longrightarrow> sqrt x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  l \\<le> 0", "have \"Y = ivl_err (real_interval (sqrt_float_interval p ivl))\""], ["proof (prove)\nusing this:\n  l \\<le> 0\n\ngoal (1 subgoal):\n 1. Y = ivl_err (real_interval (sqrt_float_interval p ivl))", "using assms(2)"], ["proof (prove)\nusing this:\n  l \\<le> 0\n  sqrt_aform_err p X = Some Y\n\ngoal (1 subgoal):\n 1. Y = ivl_err (real_interval (sqrt_float_interval p ivl))", "unfolding sqrt_aform_err_def"], ["proof (prove)\nusing this:\n  l \\<le> 0\n  (let ivl = ivl_of_aform_err p X; l = lower ivl; u = upper ivl\n   in if 0 < l\n      then min_range_mono p Sqrt (\\<lambda>x. Half (Inverse (Sqrt x))) l u X\n      else Some (ivl_err (real_interval (sqrt_float_interval p ivl)))) =\n  Some Y\n\ngoal (1 subgoal):\n 1. Y = ivl_err (real_interval (sqrt_float_interval p ivl))", "by (auto simp: Let_def simp flip: ivl_def l_def u_def split: prod.splits)"], ["proof (state)\nthis:\n  Y = ivl_err (real_interval (sqrt_float_interval p ivl))\n\ngoal (1 subgoal):\n 1. l \\<le> 0 \\<Longrightarrow> sqrt x \\<in> aform_err e Y", "with sqrt_float_intervalI[OF ivl]"], ["proof (chain)\npicking this:\n  sqrt x \\<in>\\<^sub>r sqrt_float_interval ?p ivl\n  Y = ivl_err (real_interval (sqrt_float_interval p ivl))", "show ?thesis"], ["proof (prove)\nusing this:\n  sqrt x \\<in>\\<^sub>r sqrt_float_interval ?p ivl\n  Y = ivl_err (real_interval (sqrt_float_interval p ivl))\n\ngoal (1 subgoal):\n 1. sqrt x \\<in> aform_err e Y", "by (auto simp: set_of_eq)"], ["proof (state)\nthis:\n  sqrt x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"ln_aform_err p X = do {\n  let ivl = ivl_of_aform_err p X;\n  let l = lower ivl;\n  if 0 < l then min_range_mono p Ln inverse l (upper ivl) X\n  else None\n}\""], ["", "lemma ln_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"ln_aform_err p X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"ln x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "obtain ivl l u\n    where l_def: \"l = lower ivl\"\n      and u_def: \"u = upper ivl\"\n      and ivl_def: \"ivl = ivl_of_aform_err p X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l ivl u.\n        \\<lbrakk>l = lower ivl; u = upper ivl;\n         ivl = ivl_of_aform_err p X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = lower ivl\n  u = upper ivl\n  ivl = ivl_of_aform_err p X\n\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "from ivl_of_aform_err[OF e x, of p, folded ivl_def]"], ["proof (chain)\npicking this:\n  x \\<in>\\<^sub>r ivl", "have \"x \\<in>\\<^sub>r ivl\""], ["proof (prove)\nusing this:\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. x \\<in>\\<^sub>r ivl", "."], ["proof (state)\nthis:\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  x \\<in>\\<^sub>r ivl", "have lx: \"l \\<le> x\" and ux: \"x \\<le> u\""], ["proof (prove)\nusing this:\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. real_of_float l \\<le> x &&& x \\<le> real_of_float u", "by (auto simp: set_of_eq l_def u_def)"], ["proof (state)\nthis:\n  real_of_float l \\<le> x\n  x \\<le> real_of_float u\n\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "consider \"l > 0\" | \"l \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l \\<Longrightarrow> thesis;\n     l \\<le> 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>0 < l \\<Longrightarrow> ?thesis;\n   l \\<le> 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < l \\<Longrightarrow> ?thesis;\n   l \\<le> 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < l \\<Longrightarrow> ?thesis;\n   l \\<le> 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> ln x \\<in> aform_err e Y\n 2. l \\<le> 0 \\<Longrightarrow> ln x \\<in> aform_err e Y", "case 1"], ["proof (state)\nthis:\n  0 < l\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> ln x \\<in> aform_err e Y\n 2. l \\<le> 0 \\<Longrightarrow> ln x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  0 < l", "have min_eq_Some: \"min_range_mono p Ln inverse l u X = Some Y\"\n      and bounds: \"0 < l\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. min_range_mono p Ln inverse l u X = Some Y &&& 0 < l", "using assms(2)"], ["proof (prove)\nusing this:\n  0 < l\n  ln_aform_err p X = Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Ln inverse l u X = Some Y &&& 0 < l", "unfolding ln_aform_err_def"], ["proof (prove)\nusing this:\n  0 < l\n  (let ivl = ivl_of_aform_err p X; l = lower ivl\n   in if 0 < l then min_range_mono p Ln inverse l (upper ivl) X else None) =\n  Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Ln inverse l u X = Some Y &&& 0 < l", "by (auto simp: Let_def simp flip: ivl_def l_def u_def split: prod.splits if_splits)"], ["proof (state)\nthis:\n  min_range_mono p Ln inverse l u X = Some Y\n  0 < l\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> ln x \\<in> aform_err e Y\n 2. l \\<le> 0 \\<Longrightarrow> ln x \\<in> aform_err e Y", "have \"ln x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "apply (rule min_range_mono[OF x lx ux min_eq_Some e, where f'=inverse])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Ln (Num x)) [] = ln (real_of_float x)\n 2. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (inverse (Num x)) [] = inverse (real_of_float x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (ln has_real_derivative inverse x) (at x)\n 4. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (inverse (real_of_float l)) (inverse (real_of_float u))\n       \\<le> inverse x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Ln (Num x_)) [] = ln (real_of_float x_)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (inverse (Num x)) [] = inverse (real_of_float x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (ln has_real_derivative inverse x) (at x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (inverse (real_of_float l)) (inverse (real_of_float u))\n       \\<le> inverse x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (inverse (Num x_)) [] = inverse (real_of_float x_)", "by (simp add: divide_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (ln has_real_derivative inverse x) (at x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (inverse (real_of_float l)) (inverse (real_of_float u))\n       \\<le> inverse x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    (ln has_real_derivative inverse x_) (at x_)", "using bounds"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    (ln has_real_derivative inverse x_) (at x_)", "by (auto intro!: derivative_eq_intros simp: inverse_eq_divide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (inverse (real_of_float l)) (inverse (real_of_float u))\n       \\<le> inverse x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    min (inverse (real_of_float l)) (inverse (real_of_float u))\n    \\<le> inverse x_", "using \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    min (inverse (real_of_float l)) (inverse (real_of_float u))\n    \\<le> inverse x_", "by (auto simp: inverse_eq_divide min_def divide_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ln x \\<in> aform_err e Y\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> ln x \\<in> aform_err e Y\n 2. l \\<le> 0 \\<Longrightarrow> ln x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  ln x \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  ln x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "by (simp add: )"], ["proof (state)\nthis:\n  ln x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. l \\<le> 0 \\<Longrightarrow> ln x \\<in> aform_err e Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<le> 0 \\<Longrightarrow> ln x \\<in> aform_err e Y", "case 2"], ["proof (state)\nthis:\n  l \\<le> 0\n\ngoal (1 subgoal):\n 1. l \\<le> 0 \\<Longrightarrow> ln x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  l \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<le> 0\n\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> 0\n  x \\<in> aform_err e X\n  ln_aform_err p X = Some Y\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e Y", "by (auto simp: ln_aform_err_def Let_def l_def ivl_def)"], ["proof (state)\nthis:\n  ln x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ln x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"exp_aform_err p X = do {\n  let ivl = ivl_of_aform_err p X;\n  min_range_mono p Exp Exp (lower ivl) (upper ivl) X\n}\""], ["", "lemma exp_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"exp_aform_err p X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"exp x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp x \\<in> aform_err e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exp x \\<in> aform_err e Y", "obtain l u ivl\n    where l_def: \"l = lower ivl\"\n      and u_def: \"u = upper ivl\"\n      and ivl_def: \"ivl = ivl_of_aform_err p X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l ivl u.\n        \\<lbrakk>l = lower ivl; u = upper ivl;\n         ivl = ivl_of_aform_err p X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = lower ivl\n  u = upper ivl\n  ivl = ivl_of_aform_err p X\n\ngoal (1 subgoal):\n 1. exp x \\<in> aform_err e Y", "from ivl_of_aform_err[OF e x, of p, folded ivl_def]"], ["proof (chain)\npicking this:\n  x \\<in>\\<^sub>r ivl", "have \"x \\<in>\\<^sub>r ivl\""], ["proof (prove)\nusing this:\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. x \\<in>\\<^sub>r ivl", "."], ["proof (state)\nthis:\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. exp x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  x \\<in>\\<^sub>r ivl", "have lx: \"l \\<le> x\" and ux: \"x \\<le> u\""], ["proof (prove)\nusing this:\n  x \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. real_of_float l \\<le> x &&& x \\<le> real_of_float u", "by (auto simp: ivl_def l_def u_def set_of_eq)"], ["proof (state)\nthis:\n  real_of_float l \\<le> x\n  x \\<le> real_of_float u\n\ngoal (1 subgoal):\n 1. exp x \\<in> aform_err e Y", "have min_eq_Some: \"min_range_mono p Exp Exp l u X = Some Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_range_mono p Exp Exp l u X = Some Y", "using assms(2)"], ["proof (prove)\nusing this:\n  exp_aform_err p X = Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Exp Exp l u X = Some Y", "unfolding exp_aform_err_def"], ["proof (prove)\nusing this:\n  (let ivl = ivl_of_aform_err p X\n   in min_range_mono p Exp Exp (lower ivl) (upper ivl) X) =\n  Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Exp Exp l u X = Some Y", "by (auto simp: Let_def simp flip: ivl_def u_def l_def split: prod.splits if_splits)"], ["proof (state)\nthis:\n  min_range_mono p Exp Exp l u X = Some Y\n\ngoal (1 subgoal):\n 1. exp x \\<in> aform_err e Y", "have \"exp x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp x \\<in> aform_err e Y", "apply (rule min_range_mono[OF x lx ux min_eq_Some e, where f'=exp])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Exp (Num x)) [] = exp (real_of_float x)\n 2. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Exp (Num x)) [] = exp (real_of_float x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (exp has_real_derivative exp x) (at x)\n 4. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (exp (real_of_float l)) (exp (real_of_float u)) \\<le> exp x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Exp (Num x_)) [] = exp (real_of_float x_)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Exp (Num x)) [] = exp (real_of_float x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (exp has_real_derivative exp x) (at x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (exp (real_of_float l)) (exp (real_of_float u)) \\<le> exp x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Exp (Num x_)) [] = exp (real_of_float x_)", "by (simp add: divide_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (exp has_real_derivative exp x) (at x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (exp (real_of_float l)) (exp (real_of_float u)) \\<le> exp x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    (exp has_real_derivative exp x_) (at x_)", "by (auto intro!: derivative_eq_intros simp: inverse_eq_divide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (exp (real_of_float l)) (exp (real_of_float u)) \\<le> exp x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    min (exp (real_of_float l)) (exp (real_of_float u)) \\<le> exp x_", "by (auto simp: inverse_eq_divide min_def divide_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  exp x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. exp x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  exp x \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  exp x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. exp x \\<in> aform_err e Y", "by (simp add: )"], ["proof (state)\nthis:\n  exp x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"arctan_aform_err p X = do {\n  let l = Inf_aform_err p X;\n  let u = Sup_aform_err p X;\n  min_range_mono p Arctan (\\<lambda>x. 1 / (Num 1 + x * x)) l u X\n}\""], ["", "lemma pos_add_nonneg_ne_zero: \"a > 0 \\<Longrightarrow> b \\<ge> 0 \\<Longrightarrow> a + b \\<noteq> 0\"\n  for a b::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a; 0 \\<le> b\\<rbrakk> \\<Longrightarrow> a + b \\<noteq> 0", "by arith"], ["", "lemma arctan_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes \"arctan_aform_err p X = Some Y\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"arctan x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan x \\<in> aform_err e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arctan x \\<in> aform_err e Y", "obtain l u where l: \"l = Inf_aform_err p X\"\n    and u: \"u = Sup_aform_err p X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l u.\n        \\<lbrakk>l = Inf_aform_err p X; u = Sup_aform_err p X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = Inf_aform_err p X\n  u = Sup_aform_err p X\n\ngoal (1 subgoal):\n 1. arctan x \\<in> aform_err e Y", "from x l u"], ["proof (chain)\npicking this:\n  x \\<in> aform_err e X\n  l = Inf_aform_err p X\n  u = Sup_aform_err p X", "have lx: \"l \\<le> x\" and ux: \"x \\<le> u\""], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X\n  l = Inf_aform_err p X\n  u = Sup_aform_err p X\n\ngoal (1 subgoal):\n 1. real_of_float l \\<le> x &&& x \\<le> real_of_float u", "using Inf_Sup_aform_err[OF e, of X p]"], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X\n  l = Inf_aform_err p X\n  u = Sup_aform_err p X\n  aform_err e X\n  \\<subseteq> {real_of_float\n                (Inf_aform_err p X)..real_of_float (Sup_aform_err p X)}\n\ngoal (1 subgoal):\n 1. real_of_float l \\<le> x &&& x \\<le> real_of_float u", "by auto"], ["proof (state)\nthis:\n  real_of_float l \\<le> x\n  x \\<le> real_of_float u\n\ngoal (1 subgoal):\n 1. arctan x \\<in> aform_err e Y", "have min_eq_Some: \"min_range_mono p Arctan (\\<lambda>x. 1 / (Num 1 + x * x))  l u X = Some Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_range_mono p Arctan (\\<lambda>x. 1 / (Num 1 + x * x)) l u X = Some Y", "using assms(2)"], ["proof (prove)\nusing this:\n  arctan_aform_err p X = Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Arctan (\\<lambda>x. 1 / (Num 1 + x * x)) l u X = Some Y", "unfolding arctan_aform_err_def l u"], ["proof (prove)\nusing this:\n  (let l = Inf_aform_err p X; u = Sup_aform_err p X\n   in min_range_mono p Arctan (\\<lambda>x. 1 / (Num 1 + x * x)) l u X) =\n  Some Y\n\ngoal (1 subgoal):\n 1. min_range_mono p Arctan (\\<lambda>x. 1 / (Num 1 + x * x))\n     (Inf_aform_err p X) (Sup_aform_err p X) X =\n    Some Y", "by (auto simp: l[symmetric] u[symmetric] split: prod.splits if_splits)"], ["proof (state)\nthis:\n  min_range_mono p Arctan (\\<lambda>x. 1 / (Num 1 + x * x)) l u X = Some Y\n\ngoal (1 subgoal):\n 1. arctan x \\<in> aform_err e Y", "have \"arctan x \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan x \\<in> aform_err e Y", "apply (rule min_range_mono[OF x lx ux min_eq_Some e, where f'=\"\\<lambda>x. inverse (1 + x\\<^sup>2)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (Arctan (Num x)) [] = arctan (real_of_float x)\n 2. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (1 / (Num 1 + Num x * Num x)) [] =\n       inverse (1 + (real_of_float x)\\<^sup>2)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (arctan has_real_derivative inverse (1 + x\\<^sup>2)) (at x)\n 4. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (inverse (1 + (real_of_float l)\\<^sup>2))\n        (inverse (1 + (real_of_float u)\\<^sup>2))\n       \\<le> inverse (1 + x\\<^sup>2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (Arctan (Num x_)) [] = arctan (real_of_float x_)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       real_of_float x\n       \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       interpret_floatarith (1 / (Num 1 + Num x * Num x)) [] =\n       inverse (1 + (real_of_float x)\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (arctan has_real_derivative inverse (1 + x\\<^sup>2)) (at x)\n 3. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (inverse (1 + (real_of_float l)\\<^sup>2))\n        (inverse (1 + (real_of_float u)\\<^sup>2))\n       \\<le> inverse (1 + x\\<^sup>2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float x_\n    \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    interpret_floatarith (1 / (Num 1 + Num x_ * Num x_)) [] =\n    inverse (1 + (real_of_float x_)\\<^sup>2)", "by (simp add: power2_eq_square inverse_eq_divide)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       (arctan has_real_derivative inverse (1 + x\\<^sup>2)) (at x)\n 2. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (inverse (1 + (real_of_float l)\\<^sup>2))\n        (inverse (1 + (real_of_float u)\\<^sup>2))\n       \\<le> inverse (1 + x\\<^sup>2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    (arctan has_real_derivative inverse (1 + x_\\<^sup>2)) (at x_)", "by (auto intro!: derivative_eq_intros simp: inverse_eq_divide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n       min (inverse (1 + (real_of_float l)\\<^sup>2))\n        (inverse (1 + (real_of_float u)\\<^sup>2))\n       \\<le> inverse (1 + x\\<^sup>2)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {real_of_float l..real_of_float u} \\<Longrightarrow>\n    min (inverse (1 + (real_of_float l)\\<^sup>2))\n     (inverse (1 + (real_of_float u)\\<^sup>2))\n    \\<le> inverse (1 + x\\<^sup>2)", "apply (cases \"x \\<le> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u}; x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> min (inverse (1 + (real_of_float l)\\<^sup>2))\n                       (inverse (1 + (real_of_float u)\\<^sup>2))\n                      \\<le> inverse (1 + x\\<^sup>2)\n 2. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u};\n     \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> min (inverse (1 + (real_of_float l)\\<^sup>2))\n                       (inverse (1 + (real_of_float u)\\<^sup>2))\n                      \\<le> inverse (1 + x\\<^sup>2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u}; x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> min (inverse (1 + (real_of_float l)\\<^sup>2))\n                       (inverse (1 + (real_of_float u)\\<^sup>2))\n                      \\<le> inverse (1 + x\\<^sup>2)", "apply (rule min.coboundedI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u}; x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> inverse (1 + (real_of_float l)\\<^sup>2)\n                      \\<le> inverse (1 + x\\<^sup>2)", "apply (rule deriv_nonneg_imp_mono[of \"real_of_float l\" x])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> {real_of_float l..real_of_float u}; x \\<le> 0;\n        x \\<in> {real_of_float l..x}\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>a.\n                              inverse (1 + a\\<^sup>2)) has_real_derivative\n                          ?g'2 x)\n                          (at x)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> {real_of_float l..real_of_float u}; x \\<le> 0;\n        x \\<in> {real_of_float l..x}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ?g'2 x\n 3. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u}; x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> real_of_float l \\<le> x", "by (auto intro!: derivative_eq_intros simp: mult_le_0_iff pos_add_nonneg_ne_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u};\n     \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> min (inverse (1 + (real_of_float l)\\<^sup>2))\n                       (inverse (1 + (real_of_float u)\\<^sup>2))\n                      \\<le> inverse (1 + x\\<^sup>2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u};\n     \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> min (inverse (1 + (real_of_float l)\\<^sup>2))\n                       (inverse (1 + (real_of_float u)\\<^sup>2))\n                      \\<le> inverse (1 + x\\<^sup>2)", "apply (rule min.coboundedI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u};\n     \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> inverse (1 + (real_of_float u)\\<^sup>2)\n                      \\<le> inverse (1 + x\\<^sup>2)", "apply (rule le_imp_inverse_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u};\n     \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> 1 + x\\<^sup>2 \\<le> 1 + (real_of_float u)\\<^sup>2\n 2. \\<lbrakk>x \\<in> {real_of_float l..real_of_float u};\n     \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < 1 + x\\<^sup>2", "by (auto intro!: power_mono add_pos_nonneg)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  arctan x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. arctan x \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  arctan x \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  arctan x \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. arctan x \\<in> aform_err e Y", "by (simp add: )"], ["proof (state)\nthis:\n  arctan x \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Power, TODO: compare with Min-range approximation?!\\<close>"], ["", "definition \"power_aform_err p (X::aform_err) n =\n  (if n = 0 then ((1, zero_pdevs), 0)\n  else if n = 1 then X\n  else\n    let x0 = float_of (fst (fst X));\n      xs = snd (fst X);\n      xe = float_of (snd X);\n      C = the (approx p (Num x0 ^\\<^sub>e n) []);\n      (c, ce) = mid_err C;\n      NX = the (approx p (Num (of_nat n) * (Num x0 ^\\<^sub>e (n - 1))) []);\n      (nx, nxe) = mid_err NX;\n      Y = scaleR_pdevs nx xs;\n      (Y', Y_err) = trunc_bound_pdevs p Y;\n      t = tdev' p xs;\n      Ye = truncate_up p (nxe * t);\n      err = the (approx p\n        (Num (of_nat n) * Num xe * Abs (Num x0) ^\\<^sub>e (n - 1) + \n        (Sum\\<^sub>e (\\<lambda>k. Num (of_nat (n choose k)) * Abs (Num x0) ^\\<^sub>e (n - k) * (Num xe + Num (float_of t)) ^\\<^sub>e k)\n          [2..<Suc n])) []);\n      ERR = upper err\n    in ((c, Y'), sum_list' p [ce, Y_err, Ye, real_of_float ERR]))\""], ["", "lemma bounded_by_Nil: \"bounded_by [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by [] []", "by (auto simp: bounded_by_def)"], ["", "lemma plain_floatarith_approx:\n  assumes \"plain_floatarith 0 f\"\n  shows \"interpret_floatarith f [] \\<in>\\<^sub>r (the (approx p f []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatarith f [] \\<in>\\<^sub>r the (approx p f [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. interpret_floatarith f [] \\<in>\\<^sub>r the (approx p f [])", "from plain_floatarith_approx_not_None[OF assms(1), of Nil p]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> length [];\n   \\<And>i. i < 0 \\<Longrightarrow> [] ! i \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> approx p f [] \\<noteq> None", "obtain ivl where \"approx p f [] = Some ivl\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> length [];\n   \\<And>i. i < 0 \\<Longrightarrow> [] ! i \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> approx p f [] \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>ivl.\n        approx p f [] = Some ivl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  approx p f [] = Some ivl\n\ngoal (1 subgoal):\n 1. interpret_floatarith f [] \\<in>\\<^sub>r the (approx p f [])", "from this approx[OF bounded_by_Nil this]"], ["proof (chain)\npicking this:\n  approx p f [] = Some ivl\n  interpret_floatarith f [] \\<in>\\<^sub>r ivl", "show ?thesis"], ["proof (prove)\nusing this:\n  approx p f [] = Some ivl\n  interpret_floatarith f [] \\<in>\\<^sub>r ivl\n\ngoal (1 subgoal):\n 1. interpret_floatarith f [] \\<in>\\<^sub>r the (approx p f [])", "by auto"], ["proof (state)\nthis:\n  interpret_floatarith f [] \\<in>\\<^sub>r the (approx p f [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plain_floatarith_Sum\\<^sub>e:\n  \"plain_floatarith n (Sum\\<^sub>e f xs) \\<longleftrightarrow> list_all (\\<lambda>i. plain_floatarith n (f i)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plain_floatarith n (Sum\\<^sub>e f xs) =\n    list_all (\\<lambda>i. plain_floatarith n (f i)) xs", "by (induction xs) (auto simp: zero_floatarith_def plus_floatarith_def)"], ["", "lemma sum_list'_float[simp]: \"sum_list' p xs \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list' p xs \\<in> float", "by (induction xs rule: rev_induct) (auto simp: sum_list'_def eucl_truncate_up_real_def)"], ["", "lemma tdev'_float[simp]: \"tdev' p xs \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev' p xs \\<in> float", "by (auto simp: tdev'_def)"], ["", "lemma\n  fixes x y::real\n  assumes \"abs (x - y) \\<le> e\"\n  obtains err where \"x = y + err\" \"abs err \\<le> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>x = y + err; \\<bar>err\\<bar> \\<le> e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<bar>x - y\\<bar> \\<le> e\n\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>x = y + err; \\<bar>err\\<bar> \\<le> e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> \\<le> e \\<Longrightarrow>\n    \\<exists>err. x = y + err \\<and> \\<bar>err\\<bar> \\<le> e", "apply (rule exI[where x=\"x - y\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> \\<le> e \\<Longrightarrow>\n    x = y + (x - y) \\<and> \\<bar>x - y\\<bar> \\<le> e", "by (auto simp: abs_real_def)"], ["", "theorem power_aform_err:\n  assumes \"x \\<in> aform_err e X\"\n  assumes floats[simp]: \"fst (fst X) \\<in> float\" \"snd X \\<in> float\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"x ^ n \\<in> aform_err e (power_aform_err p X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ n \\<in> aform_err e (power_aform_err p X n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ n \\<in> aform_err e (power_aform_err p X n)", "consider \"n = 0\" | \"n = 1\" | \"n \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 0 \\<Longrightarrow> thesis; n = 1 \\<Longrightarrow> thesis;\n     2 \\<le> n \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>n = 0 \\<Longrightarrow> ?thesis; n = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x ^ n \\<in> aform_err e (power_aform_err p X n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = 0 \\<Longrightarrow> ?thesis; n = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = 0 \\<Longrightarrow> ?thesis; n = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x ^ n \\<in> aform_err e (power_aform_err p X n)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> x ^ n \\<in> aform_err e (power_aform_err p X n)\n 2. n = 1 \\<Longrightarrow> x ^ n \\<in> aform_err e (power_aform_err p X n)\n 3. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "case 1"], ["proof (state)\nthis:\n  n = 0\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> x ^ n \\<in> aform_err e (power_aform_err p X n)\n 2. n = 1 \\<Longrightarrow> x ^ n \\<in> aform_err e (power_aform_err p X n)\n 3. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. x ^ n \\<in> aform_err e (power_aform_err p X n)", "by (auto simp: aform_err_def power_aform_err_def aform_val_def)"], ["proof (state)\nthis:\n  x ^ n \\<in> aform_err e (power_aform_err p X n)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow> x ^ n \\<in> aform_err e (power_aform_err p X n)\n 2. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow> x ^ n \\<in> aform_err e (power_aform_err p X n)\n 2. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "case 2"], ["proof (state)\nthis:\n  n = 1\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow> x ^ n \\<in> aform_err e (power_aform_err p X n)\n 2. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "then"], ["proof (chain)\npicking this:\n  n = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 1\n\ngoal (1 subgoal):\n 1. x ^ n \\<in> aform_err e (power_aform_err p X n)", "using assms"], ["proof (prove)\nusing this:\n  n = 1\n  x \\<in> aform_err e X\n  fst (fst X) \\<in> float\n  snd X \\<in> float\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. x ^ n \\<in> aform_err e (power_aform_err p X n)", "by (auto simp: aform_err_def power_aform_err_def aform_val_def)"], ["proof (state)\nthis:\n  x ^ n \\<in> aform_err e (power_aform_err p X n)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "case n: 3"], ["proof (state)\nthis:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define x0 where \"x0 = (fst (fst X))\""], ["proof (state)\nthis:\n  x0 = fst (fst X)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define xs where \"xs = snd (fst X)\""], ["proof (state)\nthis:\n  xs = snd (fst X)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define xe where \"xe = (snd X)\""], ["proof (state)\nthis:\n  xe = snd X\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have [simp]: \"x0 \\<in> float\" \"xe \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 \\<in> float &&& xe \\<in> float", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X\n  fst (fst X) \\<in> float\n  snd X \\<in> float\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. x0 \\<in> float &&& xe \\<in> float", "by (auto simp: x0_def xe_def)"], ["proof (state)\nthis:\n  x0 \\<in> float\n  xe \\<in> float\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define xe' where \"xe' = x - aform_val e (x0, xs)\""], ["proof (state)\nthis:\n  xe' = x - aform_val e (x0, xs)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "from aform_errE[OF assms(1)]"], ["proof (chain)\npicking this:\n  \\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X", "have xe': \"\\<bar>xe'\\<bar> \\<le> xe\""], ["proof (prove)\nusing this:\n  \\<bar>x - aform_val e (fst X)\\<bar> \\<le> snd X\n\ngoal (1 subgoal):\n 1. \\<bar>xe'\\<bar> \\<le> xe", "by (auto simp: x0_def xs_def xe_def xe'_def)"], ["proof (state)\nthis:\n  \\<bar>xe'\\<bar> \\<le> xe\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "then"], ["proof (chain)\npicking this:\n  \\<bar>xe'\\<bar> \\<le> xe", "have xe_nonneg: \"0 \\<le> xe\""], ["proof (prove)\nusing this:\n  \\<bar>xe'\\<bar> \\<le> xe\n\ngoal (1 subgoal):\n 1. 0 \\<le> xe", "by (auto simp: )"], ["proof (state)\nthis:\n  0 \\<le> xe\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define t where \"t = tdev' p xs\""], ["proof (state)\nthis:\n  t = tdev' p xs\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have t: \"tdev xs \\<le> t\" \"t \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev xs \\<le> t &&& t \\<in> float", "by (auto simp add: t_def tdev'_le)"], ["proof (state)\nthis:\n  tdev xs \\<le> t\n  t \\<in> float\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "then"], ["proof (chain)\npicking this:\n  tdev xs \\<le> t\n  t \\<in> float", "have t_nonneg: \"0 \\<le> t\""], ["proof (prove)\nusing this:\n  tdev xs \\<le> t\n  t \\<in> float\n\ngoal (1 subgoal):\n 1. 0 \\<le> t", "using tdev_nonneg[of xs]"], ["proof (prove)\nusing this:\n  tdev xs \\<le> t\n  t \\<in> float\n  0 \\<le> tdev xs\n\ngoal (1 subgoal):\n 1. 0 \\<le> t", "by arith"], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "note t_pdevs = abs_pdevs_val_le_tdev[OF e, THEN order_trans, OF t(1)]"], ["proof (state)\nthis:\n  \\<bar>pdevs_val e xs\\<bar> \\<le> t\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have rewr1: \"{..n} = (insert 0 (insert 1 {2..n}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..n} = insert 0 (insert 1 {2..n})", "using n"], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. {..n} = insert 0 (insert 1 {2..n})", "by auto"], ["proof (state)\nthis:\n  {..n} = insert 0 (insert 1 {2..n})\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"x = (pdevs_val e xs + xe') + x0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = pdevs_val e xs + xe' + x0", "by (simp add: xe'_def aform_val_def)"], ["proof (state)\nthis:\n  x = pdevs_val e xs + xe' + x0\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "also"], ["proof (state)\nthis:\n  x = pdevs_val e xs + xe' + x0\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"\\<dots> ^ n = x0 ^ n + n * x0 ^ (n - Suc 0) * pdevs_val e xs +\n      (n * xe' * x0 ^ (n - Suc 0) +\n        (\\<Sum>k = 2..n. real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)))\"\n      (is \"_ = _ + ?err\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pdevs_val e xs + xe' + x0) ^ n =\n    x0 ^ n + real n * x0 ^ (n - Suc 0) * pdevs_val e xs +\n    (real n * xe' * x0 ^ (n - Suc 0) +\n     (\\<Sum>k = 2..n.\n         real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)))", "apply (subst binomial_ring)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)) =\n    x0 ^ n + real n * x0 ^ (n - Suc 0) * pdevs_val e xs +\n    (real n * xe' * x0 ^ (n - Suc 0) +\n     (\\<Sum>k = 2..n.\n         real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)))", "unfolding rewr1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert 0 (insert 1 {2..n}).\n       real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)) =\n    x0 ^ n + real n * x0 ^ (n - Suc 0) * pdevs_val e xs +\n    (real n * xe' * x0 ^ (n - Suc 0) +\n     (\\<Sum>k = 2..n.\n         real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)))", "using n"], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert 0 (insert 1 {2..n}).\n       real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)) =\n    x0 ^ n + real n * x0 ^ (n - Suc 0) * pdevs_val e xs +\n    (real n * xe' * x0 ^ (n - Suc 0) +\n     (\\<Sum>k = 2..n.\n         real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)))", "apply (simp add: algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (pdevs_val e xs + xe' + x0) ^ n =\n  x0 ^ n + real n * x0 ^ (n - Suc 0) * pdevs_val e xs +\n  (real n * xe' * x0 ^ (n - Suc 0) +\n   (\\<Sum>k = 2..n.\n       real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "also"], ["proof (state)\nthis:\n  (pdevs_val e xs + xe' + x0) ^ n =\n  x0 ^ n + real n * x0 ^ (n - Suc 0) * pdevs_val e xs +\n  (real n * xe' * x0 ^ (n - Suc 0) +\n   (\\<Sum>k = 2..n.\n       real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "let ?ERR = \"(Num (of_nat n) * Num (float_of xe) * Abs (Num (float_of x0)) ^\\<^sub>e (n - 1) +\n          (Sum\\<^sub>e (\\<lambda>k. Num (of_nat (n choose k)) * Abs (Num (float_of x0)) ^\\<^sub>e (n - k) *\n            (Num (float_of xe) + Num (float_of t)) ^\\<^sub>e k)\n            [2..<Suc n]))\""], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define err where \"err = the (approx p ?ERR [])\""], ["proof (state)\nthis:\n  err =\n  the (approx p\n        (Num (of_nat n) * Num (float_of xe) *\n         Power (Abs (Num (float_of x0))) (n - 1) +\n         Sum\\<^sub>e\n          (\\<lambda>k.\n              Num (of_nat (n choose k)) *\n              Power (Abs (Num (float_of x0))) (n - k) *\n              Power (Num (float_of xe) + Num (float_of t)) k)\n          [2..<Suc n])\n        [])\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define ERR where \"ERR = upper err\""], ["proof (state)\nthis:\n  ERR = upper err\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have ERR: \"abs ?err \\<le> ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (pdevs_val e xs + xe') ^ k *\n              x0 ^ (n - k))\\<bar>\n    \\<le> real_of_float ERR", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (pdevs_val e xs + xe') ^ k *\n              x0 ^ (n - k))\\<bar>\n    \\<le> real_of_float ERR", "have err_aerr: \"abs (?err) \\<le> n * xe * abs x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n. real (n choose k) * (t + xe) ^ k * abs x0 ^ (n - k))\"\n        (is \"_ \\<le> ?aerr\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (pdevs_val e xs + xe') ^ k *\n              x0 ^ (n - k))\\<bar>\n    \\<le> real n * xe * \\<bar>x0\\<bar> ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (t + xe) ^ k * \\<bar>x0\\<bar> ^ (n - k))", "by (auto simp: abs_mult power_abs intro!: sum_mono mult_mono power_mono xe'\n            mult_nonneg_nonneg zero_le_power t_nonneg xe_nonneg add_nonneg_nonneg\n            sum_abs[THEN order_trans] abs_triangle_ineq[THEN order_trans] add_mono t_pdevs)"], ["proof (state)\nthis:\n  \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n        (\\<Sum>k = 2..n.\n            real (n choose k) * (pdevs_val e xs + xe') ^ k *\n            x0 ^ (n - k))\\<bar>\n  \\<le> real n * xe * \\<bar>x0\\<bar> ^ (n - Suc 0) +\n        (\\<Sum>k = 2..n.\n            real (n choose k) * (t + xe) ^ k * \\<bar>x0\\<bar> ^ (n - k))\n\ngoal (1 subgoal):\n 1. \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (pdevs_val e xs + xe') ^ k *\n              x0 ^ (n - k))\\<bar>\n    \\<le> real_of_float ERR", "also"], ["proof (state)\nthis:\n  \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n        (\\<Sum>k = 2..n.\n            real (n choose k) * (pdevs_val e xs + xe') ^ k *\n            x0 ^ (n - k))\\<bar>\n  \\<le> real n * xe * \\<bar>x0\\<bar> ^ (n - Suc 0) +\n        (\\<Sum>k = 2..n.\n            real (n choose k) * (t + xe) ^ k * \\<bar>x0\\<bar> ^ (n - k))\n\ngoal (1 subgoal):\n 1. \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (pdevs_val e xs + xe') ^ k *\n              x0 ^ (n - k))\\<bar>\n    \\<le> real_of_float ERR", "have rewr: \"{2 .. n} = {2 ..<Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {2..n} = {2..<Suc n}", "using n"], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. {2..n} = {2..<Suc n}", "by (auto simp: )"], ["proof (state)\nthis:\n  {2..n} = {2..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (pdevs_val e xs + xe') ^ k *\n              x0 ^ (n - k))\\<bar>\n    \\<le> real_of_float ERR", "have \"plain_floatarith 0 ?ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plain_floatarith 0\n     (Num (of_nat n) * Num (float_of xe) *\n      Power (Abs (Num (float_of x0))) (n - 1) +\n      Sum\\<^sub>e\n       (\\<lambda>k.\n           Num (of_nat (n choose k)) *\n           Power (Abs (Num (float_of x0))) (n - k) *\n           Power (Num (float_of xe) + Num (float_of t)) k)\n       [2..<Suc n])", "by (auto simp add: zero_floatarith_def plain_floatarith_Sum\\<^sub>e times_floatarith_def\n            plus_floatarith_def intro!: list_allI)"], ["proof (state)\nthis:\n  plain_floatarith 0\n   (Num (of_nat n) * Num (float_of xe) *\n    Power (Abs (Num (float_of x0))) (n - 1) +\n    Sum\\<^sub>e\n     (\\<lambda>k.\n         Num (of_nat (n choose k)) *\n         Power (Abs (Num (float_of x0))) (n - k) *\n         Power (Num (float_of xe) + Num (float_of t)) k)\n     [2..<Suc n])\n\ngoal (1 subgoal):\n 1. \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (pdevs_val e xs + xe') ^ k *\n              x0 ^ (n - k))\\<bar>\n    \\<le> real_of_float ERR", "from plain_floatarith_approx[OF this, of p]"], ["proof (chain)\npicking this:\n  interpret_floatarith\n   (Num (of_nat n) * Num (float_of xe) *\n    Power (Abs (Num (float_of x0))) (n - 1) +\n    Sum\\<^sub>e\n     (\\<lambda>k.\n         Num (of_nat (n choose k)) *\n         Power (Abs (Num (float_of x0))) (n - k) *\n         Power (Num (float_of xe) + Num (float_of t)) k)\n     [2..<Suc n])\n   []\n  \\<in>\\<^sub>r the (approx p\n                      (Num (of_nat n) * Num (float_of xe) *\n                       Power (Abs (Num (float_of x0))) (n - 1) +\n                       Sum\\<^sub>e\n                        (\\<lambda>k.\n                            Num (of_nat (n choose k)) *\n                            Power (Abs (Num (float_of x0))) (n - k) *\n                            Power (Num (float_of xe) + Num (float_of t)) k)\n                        [2..<Suc n])\n                      [])", "have \"ERR \\<ge> ?aerr\""], ["proof (prove)\nusing this:\n  interpret_floatarith\n   (Num (of_nat n) * Num (float_of xe) *\n    Power (Abs (Num (float_of x0))) (n - 1) +\n    Sum\\<^sub>e\n     (\\<lambda>k.\n         Num (of_nat (n choose k)) *\n         Power (Abs (Num (float_of x0))) (n - k) *\n         Power (Num (float_of xe) + Num (float_of t)) k)\n     [2..<Suc n])\n   []\n  \\<in>\\<^sub>r the (approx p\n                      (Num (of_nat n) * Num (float_of xe) *\n                       Power (Abs (Num (float_of x0))) (n - 1) +\n                       Sum\\<^sub>e\n                        (\\<lambda>k.\n                            Num (of_nat (n choose k)) *\n                            Power (Abs (Num (float_of x0))) (n - k) *\n                            Power (Num (float_of xe) + Num (float_of t)) k)\n                        [2..<Suc n])\n                      [])\n\ngoal (1 subgoal):\n 1. real n * xe * \\<bar>x0\\<bar> ^ (n - Suc 0) +\n    (\\<Sum>k = 2..n.\n        real (n choose k) * (t + xe) ^ k * \\<bar>x0\\<bar> ^ (n - k))\n    \\<le> real_of_float ERR", "using n"], ["proof (prove)\nusing this:\n  interpret_floatarith\n   (Num (of_nat n) * Num (float_of xe) *\n    Power (Abs (Num (float_of x0))) (n - 1) +\n    Sum\\<^sub>e\n     (\\<lambda>k.\n         Num (of_nat (n choose k)) *\n         Power (Abs (Num (float_of x0))) (n - k) *\n         Power (Num (float_of xe) + Num (float_of t)) k)\n     [2..<Suc n])\n   []\n  \\<in>\\<^sub>r the (approx p\n                      (Num (of_nat n) * Num (float_of xe) *\n                       Power (Abs (Num (float_of x0))) (n - 1) +\n                       Sum\\<^sub>e\n                        (\\<lambda>k.\n                            Num (of_nat (n choose k)) *\n                            Power (Abs (Num (float_of x0))) (n - k) *\n                            Power (Num (float_of xe) + Num (float_of t)) k)\n                        [2..<Suc n])\n                      [])\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. real n * xe * \\<bar>x0\\<bar> ^ (n - Suc 0) +\n    (\\<Sum>k = 2..n.\n        real (n choose k) * (t + xe) ^ k * \\<bar>x0\\<bar> ^ (n - k))\n    \\<le> real_of_float ERR", "by (auto simp: set_of_eq err_def ERR_def sum_list_distinct_conv_sum_set rewr t x0_def\n            algebra_simps)"], ["proof (state)\nthis:\n  real n * xe * \\<bar>x0\\<bar> ^ (n - Suc 0) +\n  (\\<Sum>k = 2..n.\n      real (n choose k) * (t + xe) ^ k * \\<bar>x0\\<bar> ^ (n - k))\n  \\<le> real_of_float ERR\n\ngoal (1 subgoal):\n 1. \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (pdevs_val e xs + xe') ^ k *\n              x0 ^ (n - k))\\<bar>\n    \\<le> real_of_float ERR", "finally"], ["proof (chain)\npicking this:\n  \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n        (\\<Sum>k = 2..n.\n            real (n choose k) * (pdevs_val e xs + xe') ^ k *\n            x0 ^ (n - k))\\<bar>\n  \\<le> real_of_float ERR", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n        (\\<Sum>k = 2..n.\n            real (n choose k) * (pdevs_val e xs + xe') ^ k *\n            x0 ^ (n - k))\\<bar>\n  \\<le> real_of_float ERR\n\ngoal (1 subgoal):\n 1. \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n          (\\<Sum>k = 2..n.\n              real (n choose k) * (pdevs_val e xs + xe') ^ k *\n              x0 ^ (n - k))\\<bar>\n    \\<le> real_of_float ERR", "."], ["proof (state)\nthis:\n  \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n        (\\<Sum>k = 2..n.\n            real (n choose k) * (pdevs_val e xs + xe') ^ k *\n            x0 ^ (n - k))\\<bar>\n  \\<le> real_of_float ERR\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>real n * xe' * x0 ^ (n - Suc 0) +\n        (\\<Sum>k = 2..n.\n            real (n choose k) * (pdevs_val e xs + xe') ^ k *\n            x0 ^ (n - k))\\<bar>\n  \\<le> real_of_float ERR\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "let ?x0n = \"Num (float_of x0) ^\\<^sub>e n\""], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define C where \"C = the (approx p ?x0n [])\""], ["proof (state)\nthis:\n  C = the (approx p (Power (Num (float_of x0)) n) [])\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"plain_floatarith 0 ?x0n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plain_floatarith 0 (Power (Num (float_of x0)) n)", "by simp"], ["proof (state)\nthis:\n  plain_floatarith 0 (Power (Num (float_of x0)) n)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "from plain_floatarith_approx[OF this, of p]"], ["proof (chain)\npicking this:\n  interpret_floatarith (Power (Num (float_of x0)) n) []\n  \\<in>\\<^sub>r the (approx p (Power (Num (float_of x0)) n) [])", "have C: \"x0 ^ n \\<in> {lower C .. upper C}\""], ["proof (prove)\nusing this:\n  interpret_floatarith (Power (Num (float_of x0)) n) []\n  \\<in>\\<^sub>r the (approx p (Power (Num (float_of x0)) n) [])\n\ngoal (1 subgoal):\n 1. x0 ^ n \\<in> {real_of_float (lower C)..real_of_float (upper C)}", "by (auto simp: C_def x0_def set_of_eq)"], ["proof (state)\nthis:\n  x0 ^ n \\<in> {real_of_float (lower C)..real_of_float (upper C)}\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define c where \"c = fst (mid_err C)\""], ["proof (state)\nthis:\n  c = fst (mid_err C)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define ce where \"ce = snd (mid_err C)\""], ["proof (state)\nthis:\n  ce = snd (mid_err C)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define ce' where \"ce' = x0 ^ n - c\""], ["proof (state)\nthis:\n  ce' = x0 ^ n - c\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have ce': \"abs (ce') \\<le> ce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>ce'\\<bar> \\<le> ce", "using C"], ["proof (prove)\nusing this:\n  x0 ^ n \\<in> {real_of_float (lower C)..real_of_float (upper C)}\n\ngoal (1 subgoal):\n 1. \\<bar>ce'\\<bar> \\<le> ce", "by (auto simp: ce'_def c_def ce_def abs_diff_le_iff mid_err_def divide_simps)"], ["proof (state)\nthis:\n  \\<bar>ce'\\<bar> \\<le> ce\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"x0 ^ n = c + ce'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 ^ n = c + ce'", "by (simp add: ce'_def)"], ["proof (state)\nthis:\n  x0 ^ n = c + ce'\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "also"], ["proof (state)\nthis:\n  x0 ^ n = c + ce'\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "let ?NX = \"(Num (of_nat n) * (Num (float_of x0) ^\\<^sub>e (n - 1)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define NX where \"NX = the (approx p ?NX [])\""], ["proof (state)\nthis:\n  NX =\n  the (approx p (Num (of_nat n) * Power (Num (float_of x0)) (n - 1)) [])\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"plain_floatarith 0 ?NX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plain_floatarith 0 (Num (of_nat n) * Power (Num (float_of x0)) (n - 1))", "by (simp add: times_floatarith_def)"], ["proof (state)\nthis:\n  plain_floatarith 0 (Num (of_nat n) * Power (Num (float_of x0)) (n - 1))\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "from plain_floatarith_approx[OF this, of p]"], ["proof (chain)\npicking this:\n  interpret_floatarith (Num (of_nat n) * Power (Num (float_of x0)) (n - 1))\n   []\n  \\<in>\\<^sub>r the (approx p\n                      (Num (of_nat n) * Power (Num (float_of x0)) (n - 1))\n                      [])", "have NX: \"n * x0 ^ (n - 1) \\<in> {lower NX .. upper NX}\""], ["proof (prove)\nusing this:\n  interpret_floatarith (Num (of_nat n) * Power (Num (float_of x0)) (n - 1))\n   []\n  \\<in>\\<^sub>r the (approx p\n                      (Num (of_nat n) * Power (Num (float_of x0)) (n - 1))\n                      [])\n\ngoal (1 subgoal):\n 1. real n * x0 ^ (n - 1)\n    \\<in> {real_of_float (lower NX)..real_of_float (upper NX)}", "by (auto simp: NX_def x0_def set_of_eq)"], ["proof (state)\nthis:\n  real n * x0 ^ (n - 1)\n  \\<in> {real_of_float (lower NX)..real_of_float (upper NX)}\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define nx where \"nx = fst (mid_err NX)\""], ["proof (state)\nthis:\n  nx = fst (mid_err NX)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define nxe where \"nxe = snd (mid_err NX)\""], ["proof (state)\nthis:\n  nxe = snd (mid_err NX)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define nx' where \"nx' = n * x0 ^ (n - 1) - nx\""], ["proof (state)\nthis:\n  nx' = real n * x0 ^ (n - 1) - nx\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define Ye where \"Ye = truncate_up p (nxe * t)\""], ["proof (state)\nthis:\n  Ye = truncate_up p (nxe * t)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have Ye: \"Ye \\<ge> nxe * t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nxe * t \\<le> Ye", "by (auto simp: Ye_def truncate_up_le)"], ["proof (state)\nthis:\n  nxe * t \\<le> Ye\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have nx: \"abs (nx') \\<le> nxe\" \"0 \\<le> nxe\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>nx'\\<bar> \\<le> nxe &&& 0 \\<le> nxe", "using NX"], ["proof (prove)\nusing this:\n  real n * x0 ^ (n - 1)\n  \\<in> {real_of_float (lower NX)..real_of_float (upper NX)}\n\ngoal (1 subgoal):\n 1. \\<bar>nx'\\<bar> \\<le> nxe &&& 0 \\<le> nxe", "by (auto simp: nx_def nxe_def abs_diff_le_iff mid_err_def divide_simps nx'_def)"], ["proof (state)\nthis:\n  \\<bar>nx'\\<bar> \\<le> nxe\n  0 \\<le> nxe\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have Ye: \"abs (nx' * pdevs_val e xs) \\<le> Ye\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>nx' * pdevs_val e xs\\<bar> \\<le> Ye", "by (auto simp: Ye_def abs_mult intro!: truncate_up_le mult_mono nx t_pdevs)"], ["proof (state)\nthis:\n  \\<bar>nx' * pdevs_val e xs\\<bar> \\<le> Ye\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"n * x0 ^ (n - Suc 0) = nx + nx'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n * x0 ^ (n - Suc 0) = nx + nx'", "by (simp add: nx'_def)"], ["proof (state)\nthis:\n  real n * x0 ^ (n - Suc 0) = nx + nx'\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "also"], ["proof (state)\nthis:\n  real n * x0 ^ (n - Suc 0) = nx + nx'\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define Y where \"Y = scaleR_pdevs nx xs\""], ["proof (state)\nthis:\n  Y = scaleR_pdevs nx xs\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have Y: \"pdevs_val e Y = nx * pdevs_val e xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e Y = nx * pdevs_val e xs", "by (simp add: Y_def)"], ["proof (state)\nthis:\n  pdevs_val e Y = nx * pdevs_val e xs\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"(nx + nx') * pdevs_val e xs = pdevs_val e Y + nx' * pdevs_val e xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nx + nx') * pdevs_val e xs = pdevs_val e Y + nx' * pdevs_val e xs", "unfolding Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nx + nx') * pdevs_val e xs = nx * pdevs_val e xs + nx' * pdevs_val e xs", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (nx + nx') * pdevs_val e xs = pdevs_val e Y + nx' * pdevs_val e xs\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "also"], ["proof (state)\nthis:\n  (nx + nx') * pdevs_val e xs = pdevs_val e Y + nx' * pdevs_val e xs\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define Y' where \"Y' = fst (trunc_bound_pdevs p Y)\""], ["proof (state)\nthis:\n  Y' = fst (trunc_bound_pdevs p Y)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "define Y_err where \"Y_err = snd (trunc_bound_pdevs p Y)\""], ["proof (state)\nthis:\n  Y_err = snd (trunc_bound_pdevs p Y)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have Y_err: \"abs (- pdevs_val e (trunc_err_pdevs p Y)) \\<le> Y_err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>- pdevs_val e (trunc_err_pdevs p Y)\\<bar> \\<le> Y_err", "by (auto simp: Y_err_def trunc_bound_pdevs_def abs_pdevs_val_le_tdev' e)"], ["proof (state)\nthis:\n  \\<bar>- pdevs_val e (trunc_err_pdevs p Y)\\<bar> \\<le> Y_err\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"pdevs_val e Y = pdevs_val e Y' + - pdevs_val e (trunc_err_pdevs p Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e Y = pdevs_val e Y' + - pdevs_val e (trunc_err_pdevs p Y)", "by (simp add: Y'_def trunc_bound_pdevs_def pdevs_val_trunc_err_pdevs)"], ["proof (state)\nthis:\n  pdevs_val e Y = pdevs_val e Y' + - pdevs_val e (trunc_err_pdevs p Y)\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "finally"], ["proof (chain)\npicking this:\n  x ^ n =\n  c + ce' +\n  (pdevs_val e Y' + - pdevs_val e (trunc_err_pdevs p Y) +\n   nx' * pdevs_val e xs) +\n  (real n * xe' * x0 ^ (n - Suc 0) +\n   (\\<Sum>k = 2..n.\n       real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)))", "have \"\\<bar>x ^ n - aform_val e (c, Y') \\<bar> =\n      \\<bar>ce' + - pdevs_val e (trunc_err_pdevs p Y) + nx' * pdevs_val e xs + ?err\\<bar>\""], ["proof (prove)\nusing this:\n  x ^ n =\n  c + ce' +\n  (pdevs_val e Y' + - pdevs_val e (trunc_err_pdevs p Y) +\n   nx' * pdevs_val e xs) +\n  (real n * xe' * x0 ^ (n - Suc 0) +\n   (\\<Sum>k = 2..n.\n       real (n choose k) * (pdevs_val e xs + xe') ^ k * x0 ^ (n - k)))\n\ngoal (1 subgoal):\n 1. \\<bar>x ^ n - aform_val e (c, Y')\\<bar> =\n    \\<bar>ce' + - pdevs_val e (trunc_err_pdevs p Y) + nx' * pdevs_val e xs +\n          (real n * xe' * x0 ^ (n - Suc 0) +\n           (\\<Sum>k = 2..n.\n               real (n choose k) * (pdevs_val e xs + xe') ^ k *\n               x0 ^ (n - k)))\\<bar>", "by (simp add: algebra_simps aform_val_def)"], ["proof (state)\nthis:\n  \\<bar>x ^ n - aform_val e (c, Y')\\<bar> =\n  \\<bar>ce' + - pdevs_val e (trunc_err_pdevs p Y) + nx' * pdevs_val e xs +\n        (real n * xe' * x0 ^ (n - Suc 0) +\n         (\\<Sum>k = 2..n.\n             real (n choose k) * (pdevs_val e xs + xe') ^ k *\n             x0 ^ (n - k)))\\<bar>\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "also"], ["proof (state)\nthis:\n  \\<bar>x ^ n - aform_val e (c, Y')\\<bar> =\n  \\<bar>ce' + - pdevs_val e (trunc_err_pdevs p Y) + nx' * pdevs_val e xs +\n        (real n * xe' * x0 ^ (n - Suc 0) +\n         (\\<Sum>k = 2..n.\n             real (n choose k) * (pdevs_val e xs + xe') ^ k *\n             x0 ^ (n - k)))\\<bar>\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"\\<dots> \\<le> ce + Y_err + Ye + ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>ce' + - pdevs_val e (trunc_err_pdevs p Y) + nx' * pdevs_val e xs +\n          (real n * xe' * x0 ^ (n - Suc 0) +\n           (\\<Sum>k = 2..n.\n               real (n choose k) * (pdevs_val e xs + xe') ^ k *\n               x0 ^ (n - k)))\\<bar>\n    \\<le> ce + Y_err + Ye + real_of_float ERR", "by (intro ERR abs_triangle_ineq[THEN order_trans] add_mono ce' Ye Y_err)"], ["proof (state)\nthis:\n  \\<bar>ce' + - pdevs_val e (trunc_err_pdevs p Y) + nx' * pdevs_val e xs +\n        (real n * xe' * x0 ^ (n - Suc 0) +\n         (\\<Sum>k = 2..n.\n             real (n choose k) * (pdevs_val e xs + xe') ^ k *\n             x0 ^ (n - k)))\\<bar>\n  \\<le> ce + Y_err + Ye + real_of_float ERR\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "also"], ["proof (state)\nthis:\n  \\<bar>ce' + - pdevs_val e (trunc_err_pdevs p Y) + nx' * pdevs_val e xs +\n        (real n * xe' * x0 ^ (n - Suc 0) +\n         (\\<Sum>k = 2..n.\n             real (n choose k) * (pdevs_val e xs + xe') ^ k *\n             x0 ^ (n - k)))\\<bar>\n  \\<le> ce + Y_err + Ye + real_of_float ERR\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "have \"\\<dots> \\<le> sum_list' p [ce, Y_err, Ye, real_of_float ERR]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ce + Y_err + Ye + real_of_float ERR\n    \\<le> sum_list' p [ce, Y_err, Ye, real_of_float ERR]", "by (auto intro!: sum_list'_sum_list_le)"], ["proof (state)\nthis:\n  ce + Y_err + Ye + real_of_float ERR\n  \\<le> sum_list' p [ce, Y_err, Ye, real_of_float ERR]\n\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow>\n    x ^ n \\<in> aform_err e (power_aform_err p X n)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>x ^ n - aform_val e (c, Y')\\<bar>\n  \\<le> sum_list' p [ce, Y_err, Ye, real_of_float ERR]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>x ^ n - aform_val e (c, Y')\\<bar>\n  \\<le> sum_list' p [ce, Y_err, Ye, real_of_float ERR]\n\ngoal (1 subgoal):\n 1. x ^ n \\<in> aform_err e (power_aform_err p X n)", "using n"], ["proof (prove)\nusing this:\n  \\<bar>x ^ n - aform_val e (c, Y')\\<bar>\n  \\<le> sum_list' p [ce, Y_err, Ye, real_of_float ERR]\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. x ^ n \\<in> aform_err e (power_aform_err p X n)", "by (intro aform_errI)\n        (auto simp: power_aform_err_def c_def Y'_def C_def Y_def ERR_def x0_def nx_def xs_def NX_def\n          ce_def Y_err_def Ye_def xe_def nxe_def t_def Let_def split_beta' set_of_eq err_def)"], ["proof (state)\nthis:\n  x ^ n \\<in> aform_err e (power_aform_err p X n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x ^ n \\<in> aform_err e (power_aform_err p X n)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition [code_abbrev]: \"is_float r \\<longleftrightarrow> r \\<in> float\""], ["", "lemma [code]: \"is_float (real_of_float f) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_float (real_of_float f) = True", "by (auto simp: is_float_def)"], ["", "definition \"powr_aform_err p X A = (\n    if Inf_aform_err p X > 0 then do {\n      L \\<leftarrow> ln_aform_err p X;\n      exp_aform_err p (mult_aform' p A L)\n    }\n    else approx_bin p (powr_float_interval p) X A)\""], ["", "lemma interval_extension_powr: \"interval_extension2 (powr_float_interval p) (powr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interval_extension2 (powr_float_interval p) (powr)", "using powr_float_interval_eqI[of p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>powr_float_interval p ?X ?Y = Some ?IVL; ?x \\<in>\\<^sub>r ?X;\n   ?y \\<in>\\<^sub>r ?Y\\<rbrakk>\n  \\<Longrightarrow> ?x powr ?y \\<in>\\<^sub>r ?IVL\n\ngoal (1 subgoal):\n 1. interval_extension2 (powr_float_interval p) (powr)", "by (auto simp: interval_extension2_def)"], ["", "theorem powr_aform_err:\n  assumes x: \"x \\<in> aform_err e X\"\n  assumes a: \"a \\<in> aform_err e A\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes Y: \"powr_aform_err p X A = Some Y\"\n  shows \"x powr a \\<in> aform_err e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x powr a \\<in> aform_err e Y", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y\n 2. \\<not> ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y", "assume pos: \"Inf_aform_err p X > 0\""], ["proof (state)\nthis:\n  0 < Inf_aform_err p X\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y\n 2. \\<not> ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y", "with Inf_Sup_aform_err[OF e, of X p] x"], ["proof (chain)\npicking this:\n  aform_err e X\n  \\<subseteq> {real_of_float\n                (Inf_aform_err p X)..real_of_float (Sup_aform_err p X)}\n  x \\<in> aform_err e X\n  0 < Inf_aform_err p X", "have \"x > 0\""], ["proof (prove)\nusing this:\n  aform_err e X\n  \\<subseteq> {real_of_float\n                (Inf_aform_err p X)..real_of_float (Sup_aform_err p X)}\n  x \\<in> aform_err e X\n  0 < Inf_aform_err p X\n\ngoal (1 subgoal):\n 1. 0 < x", "by auto"], ["proof (state)\nthis:\n  0 < x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y\n 2. \\<not> ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  0 < x", "have \"x powr a = exp (a * ln x)\""], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. x powr a = exp (a * ln x)", "by (simp add: powr_def)"], ["proof (state)\nthis:\n  x powr a = exp (a * ln x)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y\n 2. \\<not> ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y", "also"], ["proof (state)\nthis:\n  x powr a = exp (a * ln x)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y\n 2. \\<not> ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y", "from pos"], ["proof (chain)\npicking this:\n  0 < Inf_aform_err p X", "obtain L where L: \"ln_aform_err p X = Some L\"\n    and E: \"exp_aform_err p (mult_aform' p A L) = Some Y\""], ["proof (prove)\nusing this:\n  0 < Inf_aform_err p X\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>ln_aform_err p X = Some L;\n         exp_aform_err p (mult_aform' p A L) = Some Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Y"], ["proof (prove)\nusing this:\n  0 < Inf_aform_err p X\n  powr_aform_err p X A = Some Y\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>ln_aform_err p X = Some L;\n         exp_aform_err p (mult_aform' p A L) = Some Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: bind_eq_Some_conv powr_aform_err_def)"], ["proof (state)\nthis:\n  ln_aform_err p X = Some L\n  exp_aform_err p (mult_aform' p A L) = Some Y\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y\n 2. \\<not> ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y", "from ln_aform_err[OF x L e]"], ["proof (chain)\npicking this:\n  ln x \\<in> aform_err e L", "have \"ln x \\<in> aform_err e L\""], ["proof (prove)\nusing this:\n  ln x \\<in> aform_err e L\n\ngoal (1 subgoal):\n 1. ln x \\<in> aform_err e L", "."], ["proof (state)\nthis:\n  ln x \\<in> aform_err e L\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y\n 2. \\<not> ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y", "from mult_aform'E[OF e a this]"], ["proof (chain)\npicking this:\n  a * ln x \\<in> aform_err e (mult_aform' ?p A L)", "have \"a * ln x \\<in> aform_err e (mult_aform' p A L)\""], ["proof (prove)\nusing this:\n  a * ln x \\<in> aform_err e (mult_aform' ?p A L)\n\ngoal (1 subgoal):\n 1. a * ln x \\<in> aform_err e (mult_aform' p A L)", "."], ["proof (state)\nthis:\n  a * ln x \\<in> aform_err e (mult_aform' p A L)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y\n 2. \\<not> ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y", "from exp_aform_err[OF this E e]"], ["proof (chain)\npicking this:\n  exp (a * ln x) \\<in> aform_err e Y", "have \"exp (a * ln x) \\<in> aform_err e Y\""], ["proof (prove)\nusing this:\n  exp (a * ln x) \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. exp (a * ln x) \\<in> aform_err e Y", "."], ["proof (state)\nthis:\n  exp (a * ln x) \\<in> aform_err e Y\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y\n 2. \\<not> ?P \\<Longrightarrow> x powr a \\<in> aform_err e Y", "finally"], ["proof (chain)\npicking this:\n  x powr a \\<in> aform_err e Y", "show ?thesis"], ["proof (prove)\nusing this:\n  x powr a \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. x powr a \\<in> aform_err e Y", "."], ["proof (state)\nthis:\n  x powr a \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Inf_aform_err p X \\<Longrightarrow>\n    x powr a \\<in> aform_err e Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < Inf_aform_err p X \\<Longrightarrow>\n    x powr a \\<in> aform_err e Y", "from x a"], ["proof (chain)\npicking this:\n  x \\<in> aform_err e X\n  a \\<in> aform_err e A", "have xa: \"x \\<in> aform_err e (fst X, snd X)\" \"a \\<in> aform_err e (fst A, snd A)\""], ["proof (prove)\nusing this:\n  x \\<in> aform_err e X\n  a \\<in> aform_err e A\n\ngoal (1 subgoal):\n 1. x \\<in> aform_err e (fst X, snd X) &&&\n    a \\<in> aform_err e (fst A, snd A)", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> aform_err e (fst X, snd X)\n  a \\<in> aform_err e (fst A, snd A)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Inf_aform_err p X \\<Longrightarrow>\n    x powr a \\<in> aform_err e Y", "assume \"\\<not> Inf_aform_err p X > 0\""], ["proof (state)\nthis:\n  \\<not> 0 < Inf_aform_err p X\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Inf_aform_err p X \\<Longrightarrow>\n    x powr a \\<in> aform_err e Y", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < Inf_aform_err p X", "have \"approx_bin p (powr_float_interval p) (fst X, snd X) (fst A, snd A) = Some Y\""], ["proof (prove)\nusing this:\n  \\<not> 0 < Inf_aform_err p X\n\ngoal (1 subgoal):\n 1. approx_bin p (powr_float_interval p) (fst X, snd X) (fst A, snd A) =\n    Some Y", "using Y"], ["proof (prove)\nusing this:\n  \\<not> 0 < Inf_aform_err p X\n  powr_aform_err p X A = Some Y\n\ngoal (1 subgoal):\n 1. approx_bin p (powr_float_interval p) (fst X, snd X) (fst A, snd A) =\n    Some Y", "by (auto simp: powr_aform_err_def)"], ["proof (state)\nthis:\n  approx_bin p (powr_float_interval p) (fst X, snd X) (fst A, snd A) =\n  Some Y\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Inf_aform_err p X \\<Longrightarrow>\n    x powr a \\<in> aform_err e Y", "from approx_binE[OF interval_extension_powr xa this e]"], ["proof (chain)\npicking this:\n  x powr a \\<in> aform_err e Y", "show \"x powr a \\<in> aform_err e Y\""], ["proof (prove)\nusing this:\n  x powr a \\<in> aform_err e Y\n\ngoal (1 subgoal):\n 1. x powr a \\<in> aform_err e Y", "."], ["proof (state)\nthis:\n  x powr a \\<in> aform_err e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "fun\n  approx_floatarith :: \"nat \\<Rightarrow> floatarith \\<Rightarrow> aform_err list \\<Rightarrow> (aform_err) option\"\nwhere\n  \"approx_floatarith p (Add a b) vs =\n    do {\n      a1 \\<leftarrow> approx_floatarith p a vs;\n      a2 \\<leftarrow> approx_floatarith p b vs;\n      Some (add_aform' p a1 a2)\n    }\"\n| \"approx_floatarith p (Mult a b) vs =\n    do {\n      a1 \\<leftarrow> approx_floatarith p a vs;\n      a2 \\<leftarrow> approx_floatarith p b vs;\n      Some (mult_aform' p a1 a2)\n    }\"\n| \"approx_floatarith p (Inverse a) vs =\n    do {\n      a \\<leftarrow> approx_floatarith p a vs;\n      inverse_aform_err p a\n    }\"\n| \"approx_floatarith p (Minus a) vs =\n    map_option (apfst uminus_aform) (approx_floatarith p a vs)\"\n| \"approx_floatarith p (Num f) vs =\n    Some (num_aform (real_of_float f), 0)\"\n| \"approx_floatarith p (Var i) vs =\n  (if i < length vs then Some (vs ! i) else None)\"\n| \"approx_floatarith p (Abs a) vs =\n    do {\n      r \\<leftarrow> approx_floatarith p a vs;\n      let ivl = ivl_of_aform_err p r;\n      let i = lower ivl;\n      let s = upper ivl;\n      if i > 0 then Some r\n      else if s < 0 then Some (apfst uminus_aform r)\n      else do {\n        Some (ivl_err (real_interval (abs_interval ivl)))\n      }\n    }\"\n| \"approx_floatarith p (Min a b) vs =\n    do {\n      a1 \\<leftarrow> approx_floatarith p a vs;\n      a2 \\<leftarrow> approx_floatarith p b vs;\n      Some (min_aform_err p a1 a2)\n    }\"\n| \"approx_floatarith p (Max a b) vs =\n    do {\n      a1 \\<leftarrow> approx_floatarith p a vs;\n      a2 \\<leftarrow> approx_floatarith p b vs;\n      Some (max_aform_err p a1 a2)\n    }\"\n| \"approx_floatarith p (Floor a) vs =\n    approx_un p (\\<lambda>ivl. Some (floor_float_interval ivl)) (approx_floatarith p a vs)\"\n| \"approx_floatarith p (Cos a) vs =\n    do {\n      a \\<leftarrow> approx_floatarith p a vs;\n      cos_aform_err p a\n    }\"\n| \"approx_floatarith p Pi vs = Some (ivl_err (real_interval (pi_float_interval p)))\"\n| \"approx_floatarith p (Sqrt a) vs =\n    do {\n      a \\<leftarrow> approx_floatarith p a vs;\n      sqrt_aform_err p a\n    }\"\n| \"approx_floatarith p (Ln a) vs =\n    do {\n      a \\<leftarrow> approx_floatarith p a vs;\n      ln_aform_err p a\n    }\"\n| \"approx_floatarith p (Arctan a) vs =\n    do {\n      a \\<leftarrow> approx_floatarith p a vs;\n      arctan_aform_err p a\n    }\"\n| \"approx_floatarith p (Exp a) vs =\n    do {\n      a \\<leftarrow> approx_floatarith p a vs;\n      exp_aform_err p a\n    }\"\n| \"approx_floatarith p (Power a n) vs =\n    do {\n      ((a, as), e) \\<leftarrow> approx_floatarith p a vs;\n      if is_float a \\<and> is_float e then Some (power_aform_err p ((a, as), e) n)\n      else None\n    }\"\n| \"approx_floatarith p (Powr a b) vs =\n    do {\n      ae1 \\<leftarrow> approx_floatarith p a vs;\n      ae2 \\<leftarrow> approx_floatarith p b vs;\n      powr_aform_err p ae1 ae2\n    }\""], ["", "lemma uminus_aform_uminus_aform[simp]: \"uminus_aform (uminus_aform z) = (z::'a::real_vector aform)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uminus_aform (uminus_aform z) = z", "by (auto intro!: prod_eqI pdevs_eqI simp: uminus_aform_def)"], ["", "lemma degree_aform_inverse_aform':\n  \"degree_aform X \\<le> n \\<Longrightarrow> degree_aform (fst (inverse_aform' p X)) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform X \\<le> n \\<Longrightarrow>\n    degree_aform_err (inverse_aform' p X) \\<le> n", "unfolding inverse_aform'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform X \\<le> n \\<Longrightarrow>\n    degree_aform_err\n     (let l = Inf_aform' p X; u = Sup_aform' p X;\n          a = min \\<bar>l\\<bar> \\<bar>u\\<bar>;\n          b = max \\<bar>l\\<bar> \\<bar>u\\<bar>; sq = truncate_up p (b * b);\n          alpha = - real_divl p 1 sq;\n          dmax = truncate_up p (real_divr p 1 a - alpha * a);\n          dmin = truncate_down p (real_divl p 1 b - alpha * b);\n          zeta' = truncate_up p ((dmin + dmax) / 2);\n          zeta = if l < 0 then - zeta' else zeta';\n          delta = truncate_up p (zeta - dmin);\n          res1 = trunc_bound_eucl p (alpha * fst X);\n          res2 = trunc_bound_eucl p (fst res1 + zeta);\n          zs = trunc_bound_pdevs p (scaleR_pdevs alpha (snd X))\n      in ((fst res2, fst zs),\n          sum_list' p [delta, snd res1, snd res2, snd zs]))\n    \\<le> n", "by (auto simp: Let_def trunc_bound_pdevs_def intro!: degree_pdev_upd_le degree_trunc_pdevs_le)"], ["", "lemma degree_aform_inverse_aform:\n  assumes \"inverse_aform p X = Some Y\"\n  assumes \"degree_aform X \\<le> n\"\n  shows \"degree_aform (fst Y) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  inverse_aform p X = Some Y\n  degree_aform X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "by (auto simp: inverse_aform_def Let_def degree_aform_inverse_aform' split: if_splits)"], ["", "lemma degree_aform_ivl_err[simp]: \"degree_aform (fst (ivl_err a)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err (ivl_err a) = 0", "by (auto simp: ivl_err_def)"], ["", "lemma degree_aform_approx_bin:\n  assumes \"approx_bin p ivl X Y = Some Z\"\n  assumes \"degree_aform (fst X) \\<le> m\"\n  assumes \"degree_aform (fst Y) \\<le> m\"\n  shows \"degree_aform (fst Z) \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Z \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  approx_bin p ivl X Y = Some Z\n  degree_aform_err X \\<le> m\n  degree_aform_err Y \\<le> m\n\ngoal (1 subgoal):\n 1. degree_aform_err Z \\<le> m", "by (auto simp: approx_bin_def bind_eq_Some_conv Basis_list_real_def\n      intro!: order_trans[OF degree_aform_independent_from]\n      order_trans[OF degree_aform_of_ivl])"], ["", "lemma degree_aform_approx_un:\n  assumes \"approx_un p ivl X = Some Y\"\n  assumes \"case X of None \\<Rightarrow> True | Some X \\<Rightarrow> degree_aform (fst X) \\<le> d1\"\n  shows \"degree_aform (fst Y) \\<le> d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> d1", "using assms"], ["proof (prove)\nusing this:\n  approx_un p ivl X = Some Y\n  case X of None \\<Rightarrow> True\n  | Some X \\<Rightarrow> degree_aform_err X \\<le> d1\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> d1", "by (auto simp: approx_un_def bind_eq_Some_conv Basis_list_real_def\n      intro!: order_trans[OF degree_aform_independent_from]\n      order_trans[OF degree_aform_of_ivl])"], ["", "lemma degree_aform_num_aform[simp]: \"degree_aform (num_aform x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform (num_aform x) = 0", "by (auto simp: num_aform_def)"], ["", "lemma degree_max_aform:\n  assumes \"degree_aform_err x \\<le> d\"\n  assumes \"degree_aform_err y \\<le> d\"\n  shows \"degree_aform_err (max_aform_err p x y) \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err (max_aform_err p x y) \\<le> d", "using assms"], ["proof (prove)\nusing this:\n  degree_aform_err x \\<le> d\n  degree_aform_err y \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err (max_aform_err p x y) \\<le> d", "by (auto simp: max_aform_err_def Let_def Basis_list_real_def split: prod.splits\n      intro!: order_trans[OF degree_aform_independent_from] order_trans[OF degree_aform_of_ivl])"], ["", "lemma degree_min_aform:\n  assumes \"degree_aform_err x \\<le> d\"\n  assumes \"degree_aform_err y \\<le> d\"\n  shows \"degree_aform_err ((min_aform_err p x y)) \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err (min_aform_err p x y) \\<le> d", "using assms"], ["proof (prove)\nusing this:\n  degree_aform_err x \\<le> d\n  degree_aform_err y \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err (min_aform_err p x y) \\<le> d", "by (auto simp: min_aform_err_def Let_def Basis_list_real_def split: prod.splits\n      intro!: order_trans[OF degree_aform_independent_from] order_trans[OF degree_aform_of_ivl])"], ["", "lemma degree_aform_acc_err:\n  \"degree_aform (fst (acc_err p X e)) \\<le> d\"\n  if \"degree_aform (fst X) \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform (fst (acc_err p X e)) \\<le> d", "using that"], ["proof (prove)\nusing this:\n  degree_aform (fst X) \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform (fst (acc_err p X e)) \\<le> d", "by (auto simp: acc_err_def)"], ["", "lemma degree_pdev_upd_degree:\n  assumes \"degree b \\<le> Suc n\"\n  assumes \"degree b \\<le> Suc (degree_aform_err X)\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree (pdev_upd b (degree_aform_err X) 0) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pdev_upd b (degree_aform_err X) (0::'a)) \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  degree b \\<le> Suc n\n  degree b \\<le> Suc (degree_aform_err X)\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree (pdev_upd b (degree_aform_err X) (0::'a)) \\<le> n", "by (auto intro!: degree_le)"], ["", "lemma degree_aform_err_inverse_aform_err:\n  assumes \"inverse_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  inverse_aform_err p X = Some Y\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "apply (auto simp: inverse_aform_err_def bind_eq_Some_conv aform_to_aform_err_def\n      acc_err_def map_aform_err_def\n      aform_err_to_aform_def\n      intro!: degree_aform_acc_err)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        inverse_aform p\n         (fst (fst X),\n          pdev_upd (snd (fst X)) (degree_aform_err X) (snd X)) =\n        Some ((a, b), ba);\n        Y =\n        ((a, pdev_upd b (degree_aform_err X) 0),\n         truncate_up p\n          (\\<bar>pdevs_apply b (degree_aform_err X)\\<bar> + ba))\\<rbrakk>\n       \\<Longrightarrow> degree (pdev_upd b (degree_aform_err X) 0) \\<le> n", "apply (rule degree_pdev_upd_degree)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        inverse_aform p\n         (fst (fst X),\n          pdev_upd (snd (fst X)) (degree_aform_err X) (snd X)) =\n        Some ((a, b), ba);\n        Y =\n        ((a, pdev_upd b (degree_aform_err X) 0),\n         truncate_up p\n          (\\<bar>pdevs_apply b (degree_aform_err X)\\<bar> + ba))\\<rbrakk>\n       \\<Longrightarrow> degree b \\<le> Suc n\n 2. \\<And>a b ba.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        inverse_aform p\n         (fst (fst X),\n          pdev_upd (snd (fst X)) (degree_aform_err X) (snd X)) =\n        Some ((a, b), ba);\n        Y =\n        ((a, pdev_upd b (degree_aform_err X) 0),\n         truncate_up p\n          (\\<bar>pdevs_apply b (degree_aform_err X)\\<bar> + ba))\\<rbrakk>\n       \\<Longrightarrow> degree b \\<le> Suc (degree_aform_err X)\n 3. \\<And>a b ba.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        inverse_aform p\n         (fst (fst X),\n          pdev_upd (snd (fst X)) (degree_aform_err X) (snd X)) =\n        Some ((a, b), ba);\n        Y =\n        ((a, pdev_upd b (degree_aform_err X) 0),\n         truncate_up p\n          (\\<bar>pdevs_apply b (degree_aform_err X)\\<bar> + ba))\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> n", "apply (auto dest!: degree_aform_inverse_aform)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        Y =\n        ((a, pdev_upd b (degree_aform_err X) 0),\n         truncate_up p\n          (\\<bar>pdevs_apply b (degree_aform_err X)\\<bar> + ba));\n        degree b\n        \\<le> degree\n               (pdev_upd (snd (fst X)) (degree_aform_err X)\n                 (snd X))\\<rbrakk>\n       \\<Longrightarrow> degree b \\<le> Suc n\n 2. \\<And>a b ba.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        Y =\n        ((a, pdev_upd b (degree_aform_err X) 0),\n         truncate_up p\n          (\\<bar>pdevs_apply b (degree_aform_err X)\\<bar> + ba));\n        degree b\n        \\<le> degree\n               (pdev_upd (snd (fst X)) (degree_aform_err X)\n                 (snd X))\\<rbrakk>\n       \\<Longrightarrow> degree b \\<le> Suc (degree_aform_err X)", "apply (meson degree_pdev_upd_le nat_le_linear not_less_eq_eq order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        Y =\n        ((a, pdev_upd b (degree_aform_err X) 0),\n         truncate_up p\n          (\\<bar>pdevs_apply b (degree_aform_err X)\\<bar> + ba));\n        degree b\n        \\<le> degree\n               (pdev_upd (snd (fst X)) (degree_aform_err X)\n                 (snd X))\\<rbrakk>\n       \\<Longrightarrow> degree b \\<le> Suc (degree_aform_err X)", "apply (meson degree_pdev_upd_le nat_le_linear not_less_eq_eq order_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma degree_aform_err_affine_unop:\n  \"degree_aform_err (affine_unop p a b d X) \\<le> n\"\n  if \"degree_aform_err X \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err (affine_unop p a b d X) \\<le> n", "using that"], ["proof (prove)\nusing this:\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err (affine_unop p a b d X) \\<le> n", "by (auto simp: affine_unop_def trunc_bound_pdevs_def degree_trunc_pdevs_le split: prod.splits)"], ["", "lemma degree_aform_err_min_range_mono:\n  assumes \"min_range_mono p F D l u X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  min_range_mono p F D l u X = Some Y\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "by (auto simp: min_range_mono_def bind_eq_Some_conv aform_to_aform_err_def\n      acc_err_def map_aform_err_def mid_err_def range_reduce_aform_err_def\n      aform_err_to_aform_def Let_def split: if_splits prod.splits\n      intro!: degree_aform_err_affine_unop)"], ["", "lemma degree_aform_err_min_range_antimono:\n  assumes \"min_range_antimono p F D l u X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  min_range_antimono p F D l u X = Some Y\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "by (auto simp: min_range_antimono_def bind_eq_Some_conv aform_to_aform_err_def\n      acc_err_def map_aform_err_def mid_err_def range_reduce_aform_err_def\n      aform_err_to_aform_def Let_def split: if_splits prod.splits\n      intro!: degree_aform_err_affine_unop)"], ["", "lemma degree_aform_err_cos_aform_err:\n  assumes \"cos_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  cos_aform_err p X = Some Y\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "apply (auto simp: cos_aform_err_def bind_eq_Some_conv aform_to_aform_err_def\n      acc_err_def map_aform_err_def mid_err_def range_reduce_aform_err_def\n      aform_err_to_aform_def Let_def split: if_splits prod.splits\n      intro!: degree_aform_err_affine_unop)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 2. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_mono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float\n                (upper\n                  (ivl_of_aform_err p\n                    (add_aform' p X (ivl_err (real_interval y)))))\n               \\<le> real_of_float (lb_pi p)\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 3. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_mono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> 0 \\<le> real_of_float\n                        (lower\n                          (ivl_of_aform_err p\n                            (add_aform' p X\n                              (ivl_err (real_interval y)))))\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 4. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        min_range_mono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 5. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float (ub_pi p)\n               \\<le> real_of_float\n                      (lower\n                        (ivl_of_aform_err p\n                          (add_aform' p X\n                            (ivl_err (real_interval y)))))\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 6. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float\n                (upper\n                  (ivl_of_aform_err p\n                    (add_aform' p X (ivl_err (real_interval y)))))\n               \\<le> 2 * real_of_float (lb_pi p)\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_add_aform' degree_aform_err_min_range_antimono degree_aform_ivl_err zero_le)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_mono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float\n                (upper\n                  (ivl_of_aform_err p\n                    (add_aform' p X (ivl_err (real_interval y)))))\n               \\<le> real_of_float (lb_pi p)\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 2. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_mono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> 0 \\<le> real_of_float\n                        (lower\n                          (ivl_of_aform_err p\n                            (add_aform' p X\n                              (ivl_err (real_interval y)))))\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 3. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        min_range_mono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 4. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float (ub_pi p)\n               \\<le> real_of_float\n                      (lower\n                        (ivl_of_aform_err p\n                          (add_aform' p X\n                            (ivl_err (real_interval y)))))\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 5. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float\n                (upper\n                  (ivl_of_aform_err p\n                    (add_aform' p X (ivl_err (real_interval y)))))\n               \\<le> 2 * real_of_float (lb_pi p)\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_add_aform' degree_aform_err_min_range_mono degree_aform_ivl_err zero_le)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_mono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> 0 \\<le> real_of_float\n                        (lower\n                          (ivl_of_aform_err p\n                            (add_aform' p X\n                              (ivl_err (real_interval y)))))\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 2. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        min_range_mono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 3. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float (ub_pi p)\n               \\<le> real_of_float\n                      (lower\n                        (ivl_of_aform_err p\n                          (add_aform' p X\n                            (ivl_err (real_interval y)))))\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 4. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float\n                (upper\n                  (ivl_of_aform_err p\n                    (add_aform' p X (ivl_err (real_interval y)))))\n               \\<le> 2 * real_of_float (lb_pi p)\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_add_aform' degree_aform_err_min_range_mono degree_aform_ivl_err zero_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        real_of_float (ub_pi p)\n        \\<le> real_of_float\n               (lower\n                 (ivl_of_aform_err p\n                   (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> 2 * real_of_float (lb_pi p);\n        min_range_mono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 2. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float (ub_pi p)\n               \\<le> real_of_float\n                      (lower\n                        (ivl_of_aform_err p\n                          (add_aform' p X\n                            (ivl_err (real_interval y)))))\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 3. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float\n                (upper\n                  (ivl_of_aform_err p\n                    (add_aform' p X (ivl_err (real_interval y)))))\n               \\<le> 2 * real_of_float (lb_pi p)\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_add_aform' degree_aform_err_min_range_antimono degree_aform_ivl_err zero_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float (ub_pi p)\n               \\<le> real_of_float\n                      (lower\n                        (ivl_of_aform_err p\n                          (add_aform' p X\n                            (ivl_err (real_interval y)))))\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 2. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float\n                (upper\n                  (ivl_of_aform_err p\n                    (add_aform' p X (ivl_err (real_interval y)))))\n               \\<le> 2 * real_of_float (lb_pi p)\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_add_aform' degree_aform_err_min_range_antimono degree_aform_ivl_err zero_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>degree_aform_err X \\<le> n;\n        0 \\<le> real_of_float\n                 (lower\n                   (ivl_of_aform_err p\n                     (add_aform' p X (ivl_err (real_interval y)))));\n        real_of_float\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n        \\<le> real_of_float (lb_pi p);\n        range_reducer p (lower (ivl_of_aform_err p X)) = Some y;\n        min_range_antimono p Cos (\\<lambda>x. Minus (Sin x))\n         (lower\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (upper\n           (ivl_of_aform_err p\n             (add_aform' p X (ivl_err (real_interval y)))))\n         (add_aform' p X (ivl_err (real_interval y))) =\n        Some Y;\n        \\<not> real_of_float\n                (upper\n                  (ivl_of_aform_err p\n                    (add_aform' p X (ivl_err (real_interval y)))))\n               \\<le> 2 * real_of_float (lb_pi p)\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_add_aform' degree_aform_err_min_range_antimono degree_aform_ivl_err zero_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma degree_aform_err_sqrt_aform_err:\n  assumes \"sqrt_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  sqrt_aform_err p X = Some Y\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "apply (auto simp: sqrt_aform_err_def Let_def split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>degree_aform_err X \\<le> n;\n     0 < real_of_float (lower (ivl_of_aform_err p X));\n     min_range_mono p Sqrt (\\<lambda>x. Half (Inverse (Sqrt x)))\n      (lower (ivl_of_aform_err p X)) (upper (ivl_of_aform_err p X)) X =\n     Some Y\\<rbrakk>\n    \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_min_range_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma degree_aform_err_arctan_aform_err:\n  assumes \"arctan_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  arctan_aform_err p X = Some Y\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "apply (auto simp: arctan_aform_err_def bind_eq_Some_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>min_range_mono p Arctan (\\<lambda>x. 1 / (Num 1 + x * x))\n              (Inf_aform_err p X) (Sup_aform_err p X) X =\n             Some Y;\n     degree_aform_err X \\<le> n\\<rbrakk>\n    \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_min_range_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma degree_aform_err_exp_aform_err:\n  assumes \"exp_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  exp_aform_err p X = Some Y\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "apply (auto simp: exp_aform_err_def bind_eq_Some_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(let ivl = ivl_of_aform_err p X\n              in min_range_mono p Exp Exp (lower ivl) (upper ivl) X) =\n             Some Y;\n     degree_aform_err X \\<le> n\\<rbrakk>\n    \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_min_range_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma degree_aform_err_ln_aform_err:\n  assumes \"ln_aform_err p X = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  ln_aform_err p X = Some Y\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "apply (auto simp: ln_aform_err_def Let_def split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>degree_aform_err X \\<le> n;\n     0 < real_of_float (lower (ivl_of_aform_err p X));\n     min_range_mono p Ln inverse (lower (ivl_of_aform_err p X))\n      (upper (ivl_of_aform_err p X)) X =\n     Some Y\\<rbrakk>\n    \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_err_add_aform' degree_aform_err_min_range_mono degree_aform_ivl_err zero_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma degree_aform_err_power_aform_err:\n  assumes \"degree_aform_err X \\<le> n\"\n  shows \"degree_aform_err (power_aform_err p X m) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err (power_aform_err p X m) \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err (power_aform_err p X m) \\<le> n", "by (auto simp: power_aform_err_def Let_def trunc_bound_pdevs_def degree_trunc_pdevs_le\n      split: if_splits prod.splits)"], ["", "lemma degree_aform_err_powr_aform_err:\n  assumes \"powr_aform_err p X Z = Some Y\"\n  assumes \"degree_aform_err X \\<le> n\"\n  assumes \"degree_aform_err Z \\<le> n\"\n  shows \"degree_aform_err Y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  powr_aform_err p X Z = Some Y\n  degree_aform_err X \\<le> n\n  degree_aform_err Z \\<le> n\n\ngoal (1 subgoal):\n 1. degree_aform_err Y \\<le> n", "apply (auto simp: powr_aform_err_def bind_eq_Some_conv degree_aform_mult_aform'\n      dest!: degree_aform_err_ln_aform_err degree_aform_err_exp_aform_err\n      split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>degree_aform_err X \\<le> n; degree_aform_err Z \\<le> n;\n        0 < real_of_float (Inf_aform_err p X);\n        degree_aform_err Y\n        \\<le> degree_aform_err (mult_aform' p Z ((a, b), ba));\n        degree b \\<le> n\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err Y \\<le> n\n 2. \\<lbrakk>degree_aform_err X \\<le> n; degree_aform_err Z \\<le> n;\n     \\<not> 0 < real_of_float (Inf_aform_err p X);\n     approx_bin p (powr_float_interval p) X Z = Some Y\\<rbrakk>\n    \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (metis degree_aform_mult_aform' fst_conv order_trans snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>degree_aform_err X \\<le> n; degree_aform_err Z \\<le> n;\n     \\<not> 0 < real_of_float (Inf_aform_err p X);\n     approx_bin p (powr_float_interval p) X Z = Some Y\\<rbrakk>\n    \\<Longrightarrow> degree_aform_err Y \\<le> n", "apply (rule degree_aform_approx_bin, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>degree_aform_err X \\<le> n; degree_aform_err Z \\<le> n;\n     \\<not> 0 < real_of_float (Inf_aform_err p X);\n     approx_bin p (powr_float_interval p) X Z = Some Y\\<rbrakk>\n    \\<Longrightarrow> degree_aform_err X \\<le> n\n 2. \\<lbrakk>degree_aform_err X \\<le> n; degree_aform_err Z \\<le> n;\n     \\<not> 0 < real_of_float (Inf_aform_err p X);\n     approx_bin p (powr_float_interval p) X Z = Some Y\\<rbrakk>\n    \\<Longrightarrow> degree_aform_err Z \\<le> n", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma approx_floatarith_degree:\n  assumes \"approx_floatarith p ra VS = Some X\"\n  assumes \"\\<And>V. V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\"\n  shows \"degree_aform_err X \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "using assms"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "proof (induction ra arbitrary: X)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Add ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Minus ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>X.\n        \\<lbrakk>approx_floatarith p Pi VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 18 subgoals...", "case (Add ra1 ra2)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Add ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (18 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Add ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Minus ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>X.\n        \\<lbrakk>approx_floatarith p Pi VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Add ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Add ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro!: degree_aform_err_add_aform' degree_aform_acc_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (17 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Minus ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Sqrt ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Minus ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Sqrt ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 17 subgoals...", "case (Minus ra)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Minus ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (17 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Minus ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Sqrt ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Minus ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Minus ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (16 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Exp ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Exp ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 16 subgoals...", "case (Mult ra1 ra2)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Mult ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (16 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Exp ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Mult ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Mult ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro!: degree_aform_mult_aform' degree_aform_acc_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (15 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra1 ra2 X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         \\<And>X.\n            \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n             \\<And>V.\n                V \\<in> set VS \\<Longrightarrow>\n                degree_aform_err V \\<le> d\\<rbrakk>\n            \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Powr ra1 ra2) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra1 ra2 X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         \\<And>X.\n            \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n             \\<And>V.\n                V \\<in> set VS \\<Longrightarrow>\n                degree_aform_err V \\<le> d\\<rbrakk>\n            \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Powr ra1 ra2) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 15 subgoals...", "case (Inverse ra)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Inverse ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (15 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Inverse ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra1 ra2 X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         \\<And>X.\n            \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n             \\<And>V.\n                V \\<in> set VS \\<Longrightarrow>\n                degree_aform_err V \\<le> d\\<rbrakk>\n            \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Powr ra1 ra2) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Inverse ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Inverse ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro: degree_aform_err_inverse_aform_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (14 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Ln ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Ln ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 14 subgoals...", "case (Cos ra)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Cos ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (14 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Cos ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Ln ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Cos ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Cos ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro: degree_aform_err_cos_aform_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (13 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra x2a X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Power ra x2a) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra x2a X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Power ra x2a) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 13 subgoals...", "case (Arctan ra)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Arctan ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (13 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Arctan ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra x2a X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Power ra x2a) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Arctan ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Arctan ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro: degree_aform_err_arctan_aform_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Floor ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Floor ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 12 subgoals...", "case (Abs ra)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Abs ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Abs ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    \\<lbrakk>approx_floatarith p ra VS = Some X;\n                     \\<And>V.\n                        V \\<in> set VS \\<Longrightarrow>\n                        degree_aform_err V \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> degree_aform_err X \\<le> d;\n         approx_floatarith p (Floor ra) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Abs ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Abs ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv Let_def Basis_list_real_def\n        intro!: order_trans[OF degree_aform_independent_from] order_trans[OF degree_aform_of_ivl]\n          degree_aform_acc_err\n        split: if_splits)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>x X.\n        \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>x X.\n        \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 11 subgoals...", "case (Max ra1 ra2)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Max ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Max ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>x X.\n        \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Max ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Max ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro!: degree_max_aform degree_aform_acc_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>x X.\n        \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>x X.\n        \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d", "case (Min ra1 ra2)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Min ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Min ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 10. \\<And>x X.\n        \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n         \\<And>V.\n            V \\<in> set VS \\<Longrightarrow>\n            degree_aform_err V \\<le> d\\<rbrakk>\n        \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Min ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Min ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro!: degree_min_aform degree_aform_acc_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (9 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "case Pi"], ["proof (state)\nthis:\n  approx_floatarith p Pi VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (9 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>approx_floatarith p Pi VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 9. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p Pi VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p Pi VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv Let_def Basis_list_real_def\n        intro!: order_trans[OF degree_aform_independent_from] order_trans[OF degree_aform_of_ivl]\n          degree_aform_acc_err\n        split: if_splits)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (8 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "case (Sqrt ra)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Sqrt ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (8 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Sqrt ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 8. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Sqrt ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Sqrt ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro: degree_aform_err_sqrt_aform_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (7 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "case (Exp ra)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Exp ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (7 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Exp ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 7. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Exp ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Exp ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro: degree_aform_err_exp_aform_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (6 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "case (Powr ra1 ra2)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Powr ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (6 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra1 VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        \\<And>X.\n           \\<lbrakk>approx_floatarith p ra2 VS = Some X;\n            \\<And>V.\n               V \\<in> set VS \\<Longrightarrow>\n               degree_aform_err V \\<le> d\\<rbrakk>\n           \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 6. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Powr ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra1 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  \\<lbrakk>approx_floatarith p ra2 VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Powr ra1 ra2) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro: degree_aform_err_powr_aform_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (5 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "case (Ln ra)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Ln ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (5 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Ln ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 5. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Ln ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Ln ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: bind_eq_Some_conv intro: degree_aform_err_ln_aform_err)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (4 subgoals):\n 1. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "case (Power ra x2a)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Power ra x2a) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (4 subgoals):\n 1. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Power ra x2a) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 4. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Power ra x2a) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Power ra x2a) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto intro!: degree_aform_err_power_aform_err simp: bind_eq_Some_conv split: if_splits)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (3 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "case (Floor ra)"], ["proof (state)\nthis:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Floor ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (3 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>approx_floatarith p ra VS = Some X;\n                    \\<And>V.\n                       V \\<in> set VS \\<Longrightarrow>\n                       degree_aform_err V \\<le> d\\<rbrakk>\n                   \\<Longrightarrow> degree_aform_err X \\<le> d;\n        approx_floatarith p (Floor ra) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 3. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Floor ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_floatarith p ra VS = Some ?X;\n   \\<And>V.\n      V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n  \\<Longrightarrow> degree_aform_err ?X \\<le> d\n  approx_floatarith p (Floor ra) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>X.\n                \\<lbrakk>approx_floatarith p ra VS = Some X;\n                 \\<And>V.\n                    V \\<in> set VS \\<Longrightarrow>\n                    degree_aform_err V \\<le> d\\<rbrakk>\n                \\<Longrightarrow> degree_aform_err X \\<le> d;\n     approx_floatarith p (Floor ra) VS = Some X;\n     \\<And>V.\n        V \\<in> set VS \\<Longrightarrow> degree_aform_err V \\<le> d\\<rbrakk>\n    \\<Longrightarrow> degree_aform_err X \\<le> d", "by (rule degree_aform_approx_un) (auto split: option.splits)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "case (Var x)"], ["proof (state)\nthis:\n  approx_floatarith p (Var x) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d\n 2. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p (Var x) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p (Var x) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by (auto simp: max_def split: if_splits)\n      (use Var.prems(2) nat_le_linear nth_mem order_trans in blast)+"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "case (Num x)"], ["proof (state)\nthis:\n  approx_floatarith p (Num x) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>approx_floatarith p (Num x) VS = Some X;\n        \\<And>V.\n           V \\<in> set VS \\<Longrightarrow>\n           degree_aform_err V \\<le> d\\<rbrakk>\n       \\<Longrightarrow> degree_aform_err X \\<le> d", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p (Num x) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p (Num x) VS = Some X\n  ?V \\<in> set VS \\<Longrightarrow> degree_aform_err ?V \\<le> d\n\ngoal (1 subgoal):\n 1. degree_aform_err X \\<le> d", "by auto"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["", "definition affine_extension2 where\n  \"affine_extension2 fnctn_aff fnctn \\<longleftrightarrow> (\n    \\<forall>d a1 a2 X e2.\n      fnctn_aff d a1 a2 = Some X \\<longrightarrow>\n      e2 \\<in> UNIV \\<rightarrow> {- 1..1} \\<longrightarrow>\n      d \\<ge> degree_aform a1 \\<longrightarrow>\n      d \\<ge> degree_aform a2 \\<longrightarrow>\n      (\\<exists>e3 \\<in> UNIV \\<rightarrow> {- 1..1}.\n        (fnctn (aform_val e2 a1) (aform_val e2 a2) = aform_val e3 X \\<and>\n          (\\<forall>n. n < d \\<longrightarrow> e3 n = e2 n) \\<and>\n          aform_val e2 a1 = aform_val e3 a1 \\<and> aform_val e2 a2 = aform_val e3 a2)))\""], ["", "lemma affine_extension2E:\n  assumes \"affine_extension2 fnctn_aff fnctn\"\n  assumes \"fnctn_aff d a1 a2 = Some X\"\n    \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n    \"d \\<ge> degree_aform a1\"\n    \"d \\<ge> degree_aform a2\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> {- 1..1}\"\n    \"fnctn (aform_val e a1) (aform_val e a2) = aform_val e' X\"\n    \"\\<And>n. n < d \\<Longrightarrow> e' n = e n\"\n    \"aform_val e a1 = aform_val e' a1\"\n    \"aform_val e a2 = aform_val e' a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n         fnctn (aform_val e a1) (aform_val e a2) = aform_val e' X;\n         \\<And>n. n < d \\<Longrightarrow> e' n = e n;\n         aform_val e a1 = aform_val e' a1;\n         aform_val e a2 = aform_val e' a2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  affine_extension2 fnctn_aff fnctn\n  fnctn_aff d a1 a2 = Some X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  degree_aform a1 \\<le> d\n  degree_aform a2 \\<le> d\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n         fnctn (aform_val e a1) (aform_val e a2) = aform_val e' X;\n         \\<And>n. n < d \\<Longrightarrow> e' n = e n;\n         aform_val e a1 = aform_val e' a1;\n         aform_val e a2 = aform_val e' a2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding affine_extension2_def"], ["proof (prove)\nusing this:\n  \\<forall>d a1 a2 X e2.\n     fnctn_aff d a1 a2 = Some X \\<longrightarrow>\n     e2 \\<in> UNIV \\<rightarrow> {- 1..1} \\<longrightarrow>\n     degree_aform a1 \\<le> d \\<longrightarrow>\n     degree_aform a2 \\<le> d \\<longrightarrow>\n     (\\<exists>e3\\<in>UNIV \\<rightarrow> {- 1..1}.\n         fnctn (aform_val e2 a1) (aform_val e2 a2) = aform_val e3 X \\<and>\n         (\\<forall>n<d. e3 n = e2 n) \\<and>\n         aform_val e2 a1 = aform_val e3 a1 \\<and>\n         aform_val e2 a2 = aform_val e3 a2)\n  fnctn_aff d a1 a2 = Some X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  degree_aform a1 \\<le> d\n  degree_aform a2 \\<le> d\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n         fnctn (aform_val e a1) (aform_val e a2) = aform_val e' X;\n         \\<And>n. n < d \\<Longrightarrow> e' n = e n;\n         aform_val e a1 = aform_val e' a1;\n         aform_val e a2 = aform_val e' a2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["", "lemma aform_err_uminus_aform:\n  \"- x \\<in> aform_err e (uminus_aform X, ba)\"\n  if \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\" \"x \\<in> aform_err e (X, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<in> aform_err e (uminus_aform X, ba)", "using that"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  x \\<in> aform_err e (X, ba)\n\ngoal (1 subgoal):\n 1. - x \\<in> aform_err e (uminus_aform X, ba)", "by (auto simp: aform_err_def)"], ["", "definition \"aforms_err e (xs::aform_err list) = listset (map (aform_err e) xs)\""], ["", "lemma aforms_err_Nil[simp]: \"aforms_err e [] = {[]}\"\n  and aforms_err_Cons: \"aforms_err e (x#xs) = set_Cons (aform_err e x) (aforms_err e xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aforms_err e [] = {[]} &&&\n    aforms_err e (x # xs) = set_Cons (aform_err e x) (aforms_err e xs)", "by (auto simp: aforms_err_def)"], ["", "lemma in_set_ConsI: \"a#b \\<in> set_Cons A B\"\n  if \"a \\<in> A\" and \"b \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # b \\<in> set_Cons A B", "using that"], ["proof (prove)\nusing this:\n  a \\<in> A\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. a # b \\<in> set_Cons A B", "by (auto simp: set_Cons_def)"], ["", "lemma mem_aforms_err_Cons_iff[simp]: \"x#xs \\<in> aforms_err e (X#XS) \\<longleftrightarrow> x \\<in> aform_err e X \\<and> xs \\<in> aforms_err e XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs \\<in> aforms_err e (X # XS)) =\n    (x \\<in> aform_err e X \\<and> xs \\<in> aforms_err e XS)", "by (auto simp: aforms_err_Cons set_Cons_def)"], ["", "lemma mem_aforms_err_Cons_iff_Ex_conv: \"x \\<in> aforms_err e (X#XS) \\<longleftrightarrow> (\\<exists>y ys. x = y#ys \\<and> y \\<in> aform_err e X \\<and> ys \\<in> aforms_err e XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> aforms_err e (X # XS)) =\n    (\\<exists>y ys.\n        x = y # ys \\<and>\n        y \\<in> aform_err e X \\<and> ys \\<in> aforms_err e XS)", "by (auto simp: aforms_err_Cons set_Cons_def)"], ["", "lemma listset_Cons_mem_conv:\n  \"a # vs \\<in> listset AVS \\<longleftrightarrow> (\\<exists>A VS. AVS = A # VS \\<and> a \\<in> A \\<and> vs \\<in> listset VS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # vs \\<in> listset AVS) =\n    (\\<exists>A VS.\n        AVS = A # VS \\<and> a \\<in> A \\<and> vs \\<in> listset VS)", "by (induction AVS) (auto simp: set_Cons_def)"], ["", "lemma listset_Nil_mem_conv[simp]:\n  \"[] \\<in> listset AVS \\<longleftrightarrow> AVS = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] \\<in> listset AVS) = (AVS = [])", "by (induction AVS) (auto simp: set_Cons_def)"], ["", "lemma listset_nthD: \"vs \\<in> listset VS \\<Longrightarrow> i < length vs \\<Longrightarrow> vs ! i \\<in> VS ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs \\<in> listset VS; i < length vs\\<rbrakk>\n    \\<Longrightarrow> vs ! i \\<in> VS ! i", "by (induction vs arbitrary: VS i)\n     (auto simp: nth_Cons listset_Cons_mem_conv split: nat.splits)"], ["", "lemma length_listsetD:\n  \"vs \\<in> listset VS \\<Longrightarrow> length vs = length VS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> listset VS \\<Longrightarrow> length vs = length VS", "by (induction vs arbitrary: VS) (auto simp: listset_Cons_mem_conv)"], ["", "lemma length_aforms_errD:\n  \"vs \\<in> aforms_err e VS \\<Longrightarrow> length vs = length VS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> aforms_err e VS \\<Longrightarrow> length vs = length VS", "by (auto simp: aforms_err_def length_listsetD)"], ["", "lemma nth_aforms_errI:\n  \"vs ! i \\<in> aform_err e (VS ! i)\"\n  if \"vs \\<in> aforms_err e VS\" \"i < length vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs ! i \\<in> aform_err e (VS ! i)", "using that"], ["proof (prove)\nusing this:\n  vs \\<in> aforms_err e VS\n  i < length vs\n\ngoal (1 subgoal):\n 1. vs ! i \\<in> aform_err e (VS ! i)", "unfolding aforms_err_def"], ["proof (prove)\nusing this:\n  vs \\<in> listset (map (aform_err e) VS)\n  i < length vs\n\ngoal (1 subgoal):\n 1. vs ! i \\<in> aform_err e (VS ! i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs \\<in> listset (map (aform_err e) VS); i < length vs\\<rbrakk>\n    \\<Longrightarrow> vs ! i \\<in> aform_err e (VS ! i)", "apply (frule listset_nthD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs \\<in> listset (map (aform_err e) VS); i < length vs;\n     vs ! i \\<in> map (aform_err e) VS ! i\\<rbrakk>\n    \\<Longrightarrow> vs ! i \\<in> aform_err e (VS ! i)", "by (auto simp: aforms_err_def length_listsetD )"], ["", "lemma eucl_truncate_down_float[simp]: \"eucl_truncate_down p x \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_truncate_down p x \\<in> float", "by (auto simp: eucl_truncate_down_def)"], ["", "lemma eucl_truncate_up_float[simp]: \"eucl_truncate_up p x \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_truncate_up p x \\<in> float", "by (auto simp: eucl_truncate_up_def)"], ["", "lemma trunc_bound_eucl_float[simp]: \"fst (trunc_bound_eucl p x) \\<in> float\"\n  \"snd (trunc_bound_eucl p x) \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (trunc_bound_eucl p x) \\<in> float &&&\n    snd (trunc_bound_eucl p x) \\<in> float", "by (auto simp: trunc_bound_eucl_def Let_def)"], ["", "lemma add_aform'_float:\n  \"add_aform' p x y = ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n  \"add_aform' p x y = ((a, b), ba) \\<Longrightarrow> ba \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_aform' p x y = ((a, b), ba) \\<Longrightarrow> a \\<in> float) &&&\n    (add_aform' p x y = ((a, b), ba) \\<Longrightarrow> ba \\<in> float)", "by (auto simp: add_aform'_def Let_def)"], ["", "lemma uminus_aform_float: \"uminus_aform (aa, bb) = (a, b) \\<Longrightarrow> aa \\<in> float \\<Longrightarrow> a \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uminus_aform (aa, bb) = (a, b); aa \\<in> float\\<rbrakk>\n    \\<Longrightarrow> a \\<in> float", "by (auto simp: uminus_aform_def)"], ["", "lemma mult_aform'_float: \"mult_aform' p x y = ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n   \"mult_aform' p x y = ((a, b), ba) \\<Longrightarrow> ba \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mult_aform' p x y = ((a, b), ba) \\<Longrightarrow> a \\<in> float) &&&\n    (mult_aform' p x y = ((a, b), ba) \\<Longrightarrow> ba \\<in> float)", "by (auto simp: mult_aform'_def Let_def split_beta')"], ["", "lemma inverse_aform'_float: \"inverse_aform' p x = ((a, bb), baa) \\<Longrightarrow> a \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_aform' p x = ((a, bb), baa) \\<Longrightarrow> a \\<in> float", "using [[linarith_split_limit=256]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_aform' p x = ((a, bb), baa) \\<Longrightarrow> a \\<in> float", "by (auto simp: inverse_aform'_def Let_def)"], ["", "lemma inverse_aform_float:\n  \"inverse_aform p x = Some ((a, bb), baa) \\<Longrightarrow> a \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_aform p x = Some ((a, bb), baa) \\<Longrightarrow> a \\<in> float", "by (auto simp: inverse_aform_def Let_def apfst_def map_prod_def uminus_aform_def\n      inverse_aform'_float\n      split: if_splits prod.splits)"], ["", "lemma inverse_aform_err_float: \"inverse_aform_err p x = Some ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n   \"inverse_aform_err p x = Some ((a, b), ba) \\<Longrightarrow> ba \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse_aform_err p x = Some ((a, b), ba) \\<Longrightarrow>\n     a \\<in> float) &&&\n    (inverse_aform_err p x = Some ((a, b), ba) \\<Longrightarrow>\n     ba \\<in> float)", "by (auto simp: inverse_aform_err_def map_aform_err_def acc_err_def bind_eq_Some_conv\n      aform_err_to_aform_def aform_to_aform_err_def inverse_aform_float)"], ["", "lemma affine_unop_float:\n  \"affine_unop p asdf aaa bba h = ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n  \"affine_unop p asdf aaa bba h = ((a, b), ba) \\<Longrightarrow> ba \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (affine_unop p asdf aaa bba h = ((a, b), ba) \\<Longrightarrow>\n     a \\<in> float) &&&\n    (affine_unop p asdf aaa bba h = ((a, b), ba) \\<Longrightarrow>\n     ba \\<in> float)", "by (auto simp: affine_unop_def trunc_bound_eucl_def Let_def split: prod.splits)"], ["", "lemma min_range_antimono_float:\n  \"min_range_antimono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n  \"min_range_antimono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow> ba \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_range_antimono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow>\n     a \\<in> float) &&&\n    (min_range_antimono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow>\n     ba \\<in> float)", "by (auto simp: min_range_antimono_def Let_def bind_eq_Some_conv mid_err_def\n      affine_unop_float split: prod.splits)"], ["", "lemma min_range_mono_float:\n  \"min_range_mono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow> a \\<in> float\"\n  \"min_range_mono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow> ba \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_range_mono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow>\n     a \\<in> float) &&&\n    (min_range_mono p f f' i g h = Some ((a, b), ba) \\<Longrightarrow>\n     ba \\<in> float)", "by (auto simp: min_range_mono_def Let_def bind_eq_Some_conv mid_err_def\n      affine_unop_float split: prod.splits)"], ["", "lemma in_float_timesI: \"a \\<in> float\" if \"b = a * 2\" \"b \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> float", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> float", "from that"], ["proof (chain)\npicking this:\n  b = a * 2\n  b \\<in> float", "have \"a = b / 2\""], ["proof (prove)\nusing this:\n  b = a * 2\n  b \\<in> float\n\ngoal (1 subgoal):\n 1. a = b / 2", "by simp"], ["proof (state)\nthis:\n  a = b / 2\n\ngoal (1 subgoal):\n 1. a \\<in> float", "also"], ["proof (state)\nthis:\n  a = b / 2\n\ngoal (1 subgoal):\n 1. a \\<in> float", "have \"\\<dots> \\<in> float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b / 2 \\<in> float", "using that(2)"], ["proof (prove)\nusing this:\n  b \\<in> float\n\ngoal (1 subgoal):\n 1. b / 2 \\<in> float", "by auto"], ["proof (state)\nthis:\n  b / 2 \\<in> float\n\ngoal (1 subgoal):\n 1. a \\<in> float", "finally"], ["proof (chain)\npicking this:\n  a \\<in> float", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> float\n\ngoal (1 subgoal):\n 1. a \\<in> float", "."], ["proof (state)\nthis:\n  a \\<in> float\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interval_extension_floor: \"interval_extension1 (\\<lambda>ivl. Some (floor_float_interval ivl)) floor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interval_extension1 (\\<lambda>ivl. Some (floor_float_interval ivl))\n     (\\<lambda>x. real_of_int \\<lfloor>x\\<rfloor>)", "by (auto simp: interval_extension1_def floor_float_intervalI)"], ["", "lemma approx_floatarith_Elem:\n  assumes \"approx_floatarith p ra VS = Some X\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"vs \\<in> aforms_err e VS\"\n  shows \"interpret_floatarith ra vs \\<in> aform_err e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatarith ra vs \\<in> aform_err e X", "using assms(1)"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith ra vs \\<in> aform_err e X", "proof (induction ra arbitrary: X)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Add ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Add ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Minus ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Minus ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Mult ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 10. \\<And>X.\n        approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n        interpret_floatarith Pi vs \\<in> aform_err e X\nA total of 18 subgoals...", "case (Add ra1 ra2)"], ["proof (state)\nthis:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Add ra1 ra2) VS = Some X\n\ngoal (18 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Add ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Add ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Minus ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Minus ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Mult ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 10. \\<And>X.\n        approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n        interpret_floatarith Pi vs \\<in> aform_err e X\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Add ra1 ra2) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Add ra1 ra2) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Add ra1 ra2) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: add_aform'[OF e])"], ["proof (state)\nthis:\n  interpret_floatarith (Add ra1 ra2) vs \\<in> aform_err e X\n\ngoal (17 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Minus ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Minus ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Mult ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 9. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                          \\<in> aform_err e X\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Minus ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Minus ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Mult ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 9. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                          \\<in> aform_err e X\nA total of 17 subgoals...", "case (Minus ra)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Minus ra) VS = Some X\n\ngoal (17 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Minus ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Minus ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Mult ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 9. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                          \\<in> aform_err e X\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Minus ra) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Minus ra) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Minus ra) vs \\<in> aform_err e X", "by (auto intro!: aform_err_uminus_aform[OF e])"], ["proof (state)\nthis:\n  interpret_floatarith (Minus ra) vs \\<in> aform_err e X\n\ngoal (16 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Mult ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                          \\<in> aform_err e X\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Mult ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                          \\<in> aform_err e X\nA total of 16 subgoals...", "case (Mult ra1 ra2)"], ["proof (state)\nthis:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Mult ra1 ra2) VS = Some X\n\ngoal (16 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Mult ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Mult ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                          \\<in> aform_err e X\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Mult ra1 ra2) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Mult ra1 ra2) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Mult ra1 ra2) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: mult_aform'E[OF e])"], ["proof (state)\nthis:\n  interpret_floatarith (Mult ra1 ra2) vs \\<in> aform_err e X\n\ngoal (15 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra1 ra2 X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra1 vs \\<in> aform_err e X;\n         \\<And>X.\n            approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n            interpret_floatarith ra2 vs \\<in> aform_err e X;\n         approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                          \\<in> aform_err e X\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra1 ra2 X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra1 vs \\<in> aform_err e X;\n         \\<And>X.\n            approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n            interpret_floatarith ra2 vs \\<in> aform_err e X;\n         approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                          \\<in> aform_err e X\nA total of 15 subgoals...", "case (Inverse ra)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Inverse ra) VS = Some X\n\ngoal (15 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Inverse ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Inverse ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra1 ra2 X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra1 vs \\<in> aform_err e X;\n         \\<And>X.\n            approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n            interpret_floatarith ra2 vs \\<in> aform_err e X;\n         approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                          \\<in> aform_err e X\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Inverse ra) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Inverse ra) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Inverse ra) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: inverse_aform_err[OF e])"], ["proof (state)\nthis:\n  interpret_floatarith (Inverse ra) vs \\<in> aform_err e X\n\ngoal (14 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Ln ra) vs\n                          \\<in> aform_err e X\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Ln ra) vs\n                          \\<in> aform_err e X\nA total of 14 subgoals...", "case (Cos ra)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Cos ra) VS = Some X\n\ngoal (14 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Cos ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Cos ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Ln ra) vs\n                          \\<in> aform_err e X\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Cos ra) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Cos ra) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Cos ra) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: cos_aform_err[OF _ _ e])"], ["proof (state)\nthis:\n  interpret_floatarith (Cos ra) vs \\<in> aform_err e X\n\ngoal (13 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 5. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 10. \\<And>ra x2a X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                          \\<in> aform_err e X\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 5. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 10. \\<And>ra x2a X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                          \\<in> aform_err e X\nA total of 13 subgoals...", "case (Arctan ra)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Arctan ra) VS = Some X\n\ngoal (13 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Arctan ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Arctan ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 5. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 10. \\<And>ra x2a X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                          \\<in> aform_err e X\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Arctan ra) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Arctan ra) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Arctan ra) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: arctan_aform_err[OF _ _ e])"], ["proof (state)\nthis:\n  interpret_floatarith (Arctan ra) vs \\<in> aform_err e X\n\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                          \\<in> aform_err e X\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                          \\<in> aform_err e X\nA total of 12 subgoals...", "case (Abs fa)"], ["proof (state)\nthis:\n  approx_floatarith p fa VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith fa vs \\<in> aform_err e ?X\n  approx_floatarith p (Abs fa) VS = Some X\n\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                          \\<in> aform_err e X\nA total of 12 subgoals...", "from Abs.prems"], ["proof (chain)\npicking this:\n  approx_floatarith p (Abs fa) VS = Some X", "obtain a where a: \"approx_floatarith p fa VS = Some a\""], ["proof (prove)\nusing this:\n  approx_floatarith p (Abs fa) VS = Some X\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        approx_floatarith p fa VS = Some a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: Let_def bind_eq_Some_conv)"], ["proof (state)\nthis:\n  approx_floatarith p fa VS = Some a\n\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                          \\<in> aform_err e X\nA total of 12 subgoals...", "from Abs.IH[OF a]"], ["proof (chain)\npicking this:\n  interpret_floatarith fa vs \\<in> aform_err e a", "have mem: \"interpret_floatarith fa vs \\<in> aform_err e a\""], ["proof (prove)\nusing this:\n  interpret_floatarith fa vs \\<in> aform_err e a\n\ngoal (1 subgoal):\n 1. interpret_floatarith fa vs \\<in> aform_err e a", "by auto"], ["proof (state)\nthis:\n  interpret_floatarith fa vs \\<in> aform_err e a\n\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                          \\<in> aform_err e X\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  interpret_floatarith fa vs \\<in> aform_err e a", "have mem': \"-interpret_floatarith fa vs \\<in> aform_err e (apfst uminus_aform a)\""], ["proof (prove)\nusing this:\n  interpret_floatarith fa vs \\<in> aform_err e a\n\ngoal (1 subgoal):\n 1. - interpret_floatarith fa vs \\<in> aform_err e (apfst uminus_aform a)", "by (auto simp: aform_err_def)"], ["proof (state)\nthis:\n  - interpret_floatarith fa vs \\<in> aform_err e (apfst uminus_aform a)\n\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                          \\<in> aform_err e X\nA total of 12 subgoals...", "let ?i = \"lower (ivl_of_aform_err p a)\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                          \\<in> aform_err e X\nA total of 12 subgoals...", "let ?s = \"upper (ivl_of_aform_err p a)\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                          \\<in> aform_err e X\nA total of 12 subgoals...", "consider \"?i > 0\" | \"?i \\<le> 0\" \"?s < 0\" | \"?i \\<le> 0\" \"?s \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < lower (ivl_of_aform_err p a) \\<Longrightarrow> thesis;\n     \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n      upper (ivl_of_aform_err p a) < 0\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n      0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>0 < lower (ivl_of_aform_err p a) \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n    upper (ivl_of_aform_err p a) < 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n    0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (12 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Abs ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Abs ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 9. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 10. \\<And>ra X.\n        \\<lbrakk>\\<And>X.\n                    approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                    interpret_floatarith ra vs \\<in> aform_err e X;\n         approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n        \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                          \\<in> aform_err e X\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < lower (ivl_of_aform_err p a) \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n    upper (ivl_of_aform_err p a) < 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n    0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < lower (ivl_of_aform_err p a) \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n    upper (ivl_of_aform_err p a) < 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n    0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < lower (ivl_of_aform_err p a) \\<Longrightarrow>\n    interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n 2. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     upper (ivl_of_aform_err p a) < 0\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n 3. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "case hyps: 1"], ["proof (state)\nthis:\n  0 < lower (ivl_of_aform_err p a)\n\ngoal (3 subgoals):\n 1. 0 < lower (ivl_of_aform_err p a) \\<Longrightarrow>\n    interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n 2. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     upper (ivl_of_aform_err p a) < 0\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n 3. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  0 < lower (ivl_of_aform_err p a)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < lower (ivl_of_aform_err p a)\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "using Abs.prems mem ivl_of_aform_err[OF e mem, of p]"], ["proof (prove)\nusing this:\n  0 < lower (ivl_of_aform_err p a)\n  approx_floatarith p (Abs fa) VS = Some X\n  interpret_floatarith fa vs \\<in> aform_err e a\n  interpret_floatarith fa vs \\<in>\\<^sub>r ivl_of_aform_err p a\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "by (auto simp: a set_of_eq)"], ["proof (state)\nthis:\n  interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     upper (ivl_of_aform_err p a) < 0\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n 2. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     upper (ivl_of_aform_err p a) < 0\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n 2. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "case hyps: 2"], ["proof (state)\nthis:\n  lower (ivl_of_aform_err p a) \\<le> 0\n  upper (ivl_of_aform_err p a) < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     upper (ivl_of_aform_err p a) < 0\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n 2. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  lower (ivl_of_aform_err p a) \\<le> 0\n  upper (ivl_of_aform_err p a) < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  lower (ivl_of_aform_err p a) \\<le> 0\n  upper (ivl_of_aform_err p a) < 0\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "using Abs.prems mem ivl_of_aform_err[OF e mem, of p]\n          ivl_of_aform_err[OF e mem', of p]"], ["proof (prove)\nusing this:\n  lower (ivl_of_aform_err p a) \\<le> 0\n  upper (ivl_of_aform_err p a) < 0\n  approx_floatarith p (Abs fa) VS = Some X\n  interpret_floatarith fa vs \\<in> aform_err e a\n  interpret_floatarith fa vs \\<in>\\<^sub>r ivl_of_aform_err p a\n  - interpret_floatarith fa vs\n  \\<in>\\<^sub>r ivl_of_aform_err p (apfst uminus_aform a)\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "by (cases a) (auto simp: a abs_real_def set_of_eq intro!: aform_err_uminus_aform[OF e])"], ["proof (state)\nthis:\n  interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "case hyps: 3"], ["proof (state)\nthis:\n  lower (ivl_of_aform_err p a) \\<le> 0\n  0 \\<le> upper (ivl_of_aform_err p a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lower (ivl_of_aform_err p a) \\<le> 0;\n     0 \\<le> upper (ivl_of_aform_err p a)\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  lower (ivl_of_aform_err p a) \\<le> 0\n  0 \\<le> upper (ivl_of_aform_err p a)", "show ?thesis"], ["proof (prove)\nusing this:\n  lower (ivl_of_aform_err p a) \\<le> 0\n  0 \\<le> upper (ivl_of_aform_err p a)\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "using Abs.prems mem ivl_of_aform_err[OF e mem, of p]"], ["proof (prove)\nusing this:\n  lower (ivl_of_aform_err p a) \\<le> 0\n  0 \\<le> upper (ivl_of_aform_err p a)\n  approx_floatarith p (Abs fa) VS = Some X\n  interpret_floatarith fa vs \\<in> aform_err e a\n  interpret_floatarith fa vs \\<in>\\<^sub>r ivl_of_aform_err p a\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Abs fa) vs \\<in> aform_err e X", "by (auto simp: a abs_real_def max_def Let_def set_of_eq)"], ["proof (state)\nthis:\n  interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  interpret_floatarith (Abs fa) vs \\<in> aform_err e X\n\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "case (Max ra1 ra2)"], ["proof (state)\nthis:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Max ra1 ra2) VS = Some X\n\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "from Max.prems"], ["proof (chain)\npicking this:\n  approx_floatarith p (Max ra1 ra2) VS = Some X", "obtain a b where a: \"approx_floatarith p ra1 VS = Some a\"\n    and b: \"approx_floatarith p ra2 VS = Some b\""], ["proof (prove)\nusing this:\n  approx_floatarith p (Max ra1 ra2) VS = Some X\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>approx_floatarith p ra1 VS = Some a;\n         approx_floatarith p ra2 VS = Some b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: Let_def bind_eq_Some_conv)"], ["proof (state)\nthis:\n  approx_floatarith p ra1 VS = Some a\n  approx_floatarith p ra2 VS = Some b\n\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "from Max.IH(1)[OF a] Max.IH(2)[OF b]"], ["proof (chain)\npicking this:\n  interpret_floatarith ra1 vs \\<in> aform_err e a\n  interpret_floatarith ra2 vs \\<in> aform_err e b", "have mem: \"interpret_floatarith ra1 vs \\<in> aform_err e a\"\n    \"interpret_floatarith ra2 vs \\<in> aform_err e b\""], ["proof (prove)\nusing this:\n  interpret_floatarith ra1 vs \\<in> aform_err e a\n  interpret_floatarith ra2 vs \\<in> aform_err e b\n\ngoal (1 subgoal):\n 1. interpret_floatarith ra1 vs \\<in> aform_err e a &&&\n    interpret_floatarith ra2 vs \\<in> aform_err e b", "by auto"], ["proof (state)\nthis:\n  interpret_floatarith ra1 vs \\<in> aform_err e a\n  interpret_floatarith ra2 vs \\<in> aform_err e b\n\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "let ?ia = \"lower (ivl_of_aform_err p a)\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "let ?sa = \"upper (ivl_of_aform_err p a)\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "let ?ib = \"lower (ivl_of_aform_err p b)\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "let ?sb = \"upper (ivl_of_aform_err p b)\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "consider \"?sa < ?ib\" | \"?sa \\<ge> ?ib\" \"?sb < ?ia\" | \"?sa \\<ge> ?ib\" \"?sb \\<ge> ?ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>upper (ivl_of_aform_err p a)\n             < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n             thesis;\n     \\<lbrakk>lower (ivl_of_aform_err p b)\n              \\<le> upper (ivl_of_aform_err p a);\n      upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>lower (ivl_of_aform_err p b)\n              \\<le> upper (ivl_of_aform_err p a);\n      lower (ivl_of_aform_err p a)\n      \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>upper (ivl_of_aform_err p a)\n           < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    lower (ivl_of_aform_err p a) \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (11 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Max ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Max ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 8. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 9. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Var x) vs \\<in> aform_err e X\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>upper (ivl_of_aform_err p a)\n           < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    lower (ivl_of_aform_err p a) \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>upper (ivl_of_aform_err p a)\n           < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    lower (ivl_of_aform_err p a) \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Max ra1 ra2) vs \\<in> aform_err e X", "using Max.prems mem ivl_of_aform_err[OF e mem(1), of p] ivl_of_aform_err[OF e mem(2), of p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>upper (ivl_of_aform_err p a)\n           < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    lower (ivl_of_aform_err p a) \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  approx_floatarith p (Max ra1 ra2) VS = Some X\n  interpret_floatarith ra1 vs \\<in> aform_err e a\n  interpret_floatarith ra2 vs \\<in> aform_err e b\n  interpret_floatarith ra1 vs \\<in>\\<^sub>r ivl_of_aform_err p a\n  interpret_floatarith ra2 vs \\<in>\\<^sub>r ivl_of_aform_err p b\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Max ra1 ra2) vs \\<in> aform_err e X", "by cases (auto simp: a b max_def max_aform_err_def set_of_eq)"], ["proof (state)\nthis:\n  interpret_floatarith (Max ra1 ra2) vs \\<in> aform_err e X\n\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "case (Min ra1 ra2)"], ["proof (state)\nthis:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Min ra1 ra2) VS = Some X\n\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "from Min.prems"], ["proof (chain)\npicking this:\n  approx_floatarith p (Min ra1 ra2) VS = Some X", "obtain a b where a: \"approx_floatarith p ra1 VS = Some a\"\n    and b: \"approx_floatarith p ra2 VS = Some b\""], ["proof (prove)\nusing this:\n  approx_floatarith p (Min ra1 ra2) VS = Some X\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>approx_floatarith p ra1 VS = Some a;\n         approx_floatarith p ra2 VS = Some b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: Let_def bind_eq_Some_conv)"], ["proof (state)\nthis:\n  approx_floatarith p ra1 VS = Some a\n  approx_floatarith p ra2 VS = Some b\n\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "from Min.IH(1)[OF a] Min.IH(2)[OF b]"], ["proof (chain)\npicking this:\n  interpret_floatarith ra1 vs \\<in> aform_err e a\n  interpret_floatarith ra2 vs \\<in> aform_err e b", "have mem: \"interpret_floatarith ra1 vs \\<in> aform_err e a\"\n    \"interpret_floatarith ra2 vs \\<in> aform_err e b\""], ["proof (prove)\nusing this:\n  interpret_floatarith ra1 vs \\<in> aform_err e a\n  interpret_floatarith ra2 vs \\<in> aform_err e b\n\ngoal (1 subgoal):\n 1. interpret_floatarith ra1 vs \\<in> aform_err e a &&&\n    interpret_floatarith ra2 vs \\<in> aform_err e b", "by auto"], ["proof (state)\nthis:\n  interpret_floatarith ra1 vs \\<in> aform_err e a\n  interpret_floatarith ra2 vs \\<in> aform_err e b\n\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "let ?ia = \"lower (ivl_of_aform_err p a)\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "let ?sa = \"upper (ivl_of_aform_err p a)\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "let ?ib = \"lower (ivl_of_aform_err p b)\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "let ?sb = \"upper (ivl_of_aform_err p b)\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "consider \"?sa < ?ib\" | \"?sa \\<ge> ?ib\" \"?sb < ?ia\" | \"?sa \\<ge> ?ib\" \"?sb \\<ge> ?ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>upper (ivl_of_aform_err p a)\n             < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n             thesis;\n     \\<lbrakk>lower (ivl_of_aform_err p b)\n              \\<le> upper (ivl_of_aform_err p a);\n      upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>lower (ivl_of_aform_err p b)\n              \\<le> upper (ivl_of_aform_err p a);\n      lower (ivl_of_aform_err p a)\n      \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>upper (ivl_of_aform_err p a)\n           < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    lower (ivl_of_aform_err p a) \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (10 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Min ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Min ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 7. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 8. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 10. \\<And>x X.\n        approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n        interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>upper (ivl_of_aform_err p a)\n           < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    lower (ivl_of_aform_err p a) \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>upper (ivl_of_aform_err p a)\n           < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    lower (ivl_of_aform_err p a) \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Min ra1 ra2) vs \\<in> aform_err e X", "using Min.prems mem ivl_of_aform_err[OF e mem(1), of p] ivl_of_aform_err[OF e mem(2), of p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>upper (ivl_of_aform_err p a)\n           < lower (ivl_of_aform_err p b) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    upper (ivl_of_aform_err p b) < lower (ivl_of_aform_err p a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>lower (ivl_of_aform_err p b) \\<le> upper (ivl_of_aform_err p a);\n    lower (ivl_of_aform_err p a) \\<le> upper (ivl_of_aform_err p b)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  approx_floatarith p (Min ra1 ra2) VS = Some X\n  interpret_floatarith ra1 vs \\<in> aform_err e a\n  interpret_floatarith ra2 vs \\<in> aform_err e b\n  interpret_floatarith ra1 vs \\<in>\\<^sub>r ivl_of_aform_err p a\n  interpret_floatarith ra2 vs \\<in>\\<^sub>r ivl_of_aform_err p b\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Min ra1 ra2) vs \\<in> aform_err e X", "by cases (auto simp: a b min_def min_aform_err_def set_of_eq)"], ["proof (state)\nthis:\n  interpret_floatarith (Min ra1 ra2) vs \\<in> aform_err e X\n\ngoal (9 subgoals):\n 1. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 6. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 6. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "case Pi"], ["proof (state)\nthis:\n  approx_floatarith p Pi VS = Some X\n\ngoal (9 subgoals):\n 1. \\<And>X.\n       approx_floatarith p Pi VS = Some X \\<Longrightarrow>\n       interpret_floatarith Pi vs \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 6. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 7. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 8. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 9. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p Pi VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p Pi VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith Pi vs \\<in> aform_err e X", "using pi_float_interval"], ["proof (prove)\nusing this:\n  approx_floatarith p Pi VS = Some X\n  pi \\<in>\\<^sub>r pi_float_interval ?prec\n\ngoal (1 subgoal):\n 1. interpret_floatarith Pi vs \\<in> aform_err e X", "by (auto simp: )"], ["proof (state)\nthis:\n  interpret_floatarith Pi vs \\<in> aform_err e X\n\ngoal (8 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 5. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 8. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 5. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 8. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "case (Sqrt ra)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Sqrt ra) VS = Some X\n\ngoal (8 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Sqrt ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Sqrt ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 5. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 6. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 7. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 8. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Sqrt ra) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Sqrt ra) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Sqrt ra) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: sqrt_aform_err[OF _ _ e])"], ["proof (state)\nthis:\n  interpret_floatarith (Sqrt ra) vs \\<in> aform_err e X\n\ngoal (7 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 4. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 7. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 4. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 7. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "case (Exp ra)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Exp ra) VS = Some X\n\ngoal (7 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Exp ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Exp ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 4. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 5. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 6. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 7. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Exp ra) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Exp ra) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Exp ra) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: exp_aform_err[OF _ _ e])"], ["proof (state)\nthis:\n  interpret_floatarith (Exp ra) vs \\<in> aform_err e X\n\ngoal (6 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 3. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 6. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 3. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 6. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "case (Powr ra1 ra2)"], ["proof (state)\nthis:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Powr ra1 ra2) VS = Some X\n\ngoal (6 subgoals):\n 1. \\<And>ra1 ra2 X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra1 VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra1 vs \\<in> aform_err e X;\n        \\<And>X.\n           approx_floatarith p ra2 VS = Some X \\<Longrightarrow>\n           interpret_floatarith ra2 vs \\<in> aform_err e X;\n        approx_floatarith p (Powr ra1 ra2) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Powr ra1 ra2) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 3. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 4. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 5. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 6. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Powr ra1 ra2) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra1 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra1 vs \\<in> aform_err e ?X\n  approx_floatarith p ra2 VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra2 vs \\<in> aform_err e ?X\n  approx_floatarith p (Powr ra1 ra2) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Powr ra1 ra2) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: powr_aform_err[OF _ _ e])"], ["proof (state)\nthis:\n  interpret_floatarith (Powr ra1 ra2) vs \\<in> aform_err e X\n\ngoal (5 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 2. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 5. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 2. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 5. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "case (Ln ra)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Ln ra) VS = Some X\n\ngoal (5 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Ln ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n 2. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 3. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 4. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 5. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Ln ra) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Ln ra) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Ln ra) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: ln_aform_err[OF _ _ e])"], ["proof (state)\nthis:\n  interpret_floatarith (Ln ra) vs \\<in> aform_err e X\n\ngoal (4 subgoals):\n 1. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 4. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 4. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "case (Power ra x2a)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Power ra x2a) VS = Some X\n\ngoal (4 subgoals):\n 1. \\<And>ra x2a X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Power ra x2a) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Power ra x2a) vs\n                         \\<in> aform_err e X\n 2. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 3. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 4. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Power ra x2a) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Power ra x2a) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Power ra x2a) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv is_float_def\n        intro!: power_aform_err[OF _ _ _ e] split: if_splits)"], ["proof (state)\nthis:\n  interpret_floatarith (Power ra x2a) vs \\<in> aform_err e X\n\ngoal (3 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 3. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 3. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "case (Floor ra)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Floor ra) VS = Some X\n\ngoal (3 subgoals):\n 1. \\<And>ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatarith p ra VS = Some X \\<Longrightarrow>\n                   interpret_floatarith ra vs \\<in> aform_err e X;\n        approx_floatarith p (Floor ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatarith (Floor ra) vs\n                         \\<in> aform_err e X\n 2. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 3. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Floor ra) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some ?X \\<Longrightarrow>\n  interpret_floatarith ra vs \\<in> aform_err e ?X\n  approx_floatarith p (Floor ra) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Floor ra) vs \\<in> aform_err e X", "by (auto simp: bind_eq_Some_conv intro!: approx_unE[OF interval_extension_floor e]\n        split: option.splits)"], ["proof (state)\nthis:\n  interpret_floatarith (Floor ra) vs \\<in> aform_err e X\n\ngoal (2 subgoals):\n 1. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 2. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 2. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "case (Var x)"], ["proof (state)\nthis:\n  approx_floatarith p (Var x) VS = Some X\n\ngoal (2 subgoals):\n 1. \\<And>x X.\n       approx_floatarith p (Var x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Var x) vs \\<in> aform_err e X\n 2. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p (Var x) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p (Var x) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Var x) vs \\<in> aform_err e X", "using assms(3)"], ["proof (prove)\nusing this:\n  approx_floatarith p (Var x) VS = Some X\n  vs \\<in> aforms_err e VS\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Var x) vs \\<in> aform_err e X", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n     vs \\<in> aforms_err e VS\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Var x) vs \\<in> aform_err e X", "apply (frule length_aforms_errD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>approx_floatarith p (Var x) VS = Some X;\n     vs \\<in> aforms_err e VS; length vs = length VS\\<rbrakk>\n    \\<Longrightarrow> interpret_floatarith (Var x) vs \\<in> aform_err e X", "by (auto split: if_splits simp: aform_err_def dest!: nth_aforms_errI[where i=x])"], ["proof (state)\nthis:\n  interpret_floatarith (Var x) vs \\<in> aform_err e X\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "case (Num x)"], ["proof (state)\nthis:\n  approx_floatarith p (Num x) VS = Some X\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       approx_floatarith p (Num x) VS = Some X \\<Longrightarrow>\n       interpret_floatarith (Num x) vs \\<in> aform_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p (Num x) VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p (Num x) VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatarith (Num x) vs \\<in> aform_err e X", "by (auto split: if_splits simp: aform_err_def num_aform_def aform_val_def)"], ["proof (state)\nthis:\n  interpret_floatarith (Num x) vs \\<in> aform_err e X\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec approx_floatariths_aformerr ::\n  \"nat \\<Rightarrow> floatarith list \\<Rightarrow> aform_err list \\<Rightarrow> aform_err list option\"\n  where\n    \"approx_floatariths_aformerr _ [] _ = Some []\"\n  | \"approx_floatariths_aformerr p (a#bs) vs =\n      do {\n        a \\<leftarrow> approx_floatarith p a vs;\n        r \\<leftarrow> approx_floatariths_aformerr p bs vs;\n        Some (a#r)\n      }\""], ["", "lemma approx_floatariths_Elem:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"approx_floatariths_aformerr p ra VS = Some X\"\n  assumes \"vs \\<in> aforms_err e VS\"\n  shows \"interpret_floatariths ra vs \\<in> aforms_err e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatariths ra vs \\<in> aforms_err e X", "using assms(2)"], ["proof (prove)\nusing this:\n  approx_floatariths_aformerr p ra VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatariths ra vs \\<in> aforms_err e X", "proof (induction ra arbitrary: X)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       approx_floatariths_aformerr p [] VS = Some X \\<Longrightarrow>\n       interpret_floatariths [] vs \\<in> aforms_err e X\n 2. \\<And>a ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatariths_aformerr p ra VS =\n                   Some X \\<Longrightarrow>\n                   interpret_floatariths ra vs \\<in> aforms_err e X;\n        approx_floatariths_aformerr p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatariths (a # ra) vs\n                         \\<in> aforms_err e X", "case Nil"], ["proof (state)\nthis:\n  approx_floatariths_aformerr p [] VS = Some X\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       approx_floatariths_aformerr p [] VS = Some X \\<Longrightarrow>\n       interpret_floatariths [] vs \\<in> aforms_err e X\n 2. \\<And>a ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatariths_aformerr p ra VS =\n                   Some X \\<Longrightarrow>\n                   interpret_floatariths ra vs \\<in> aforms_err e X;\n        approx_floatariths_aformerr p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatariths (a # ra) vs\n                         \\<in> aforms_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatariths_aformerr p [] VS = Some X", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatariths_aformerr p [] VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_floatariths [] vs \\<in> aforms_err e X", "by simp"], ["proof (state)\nthis:\n  interpret_floatariths [] vs \\<in> aforms_err e X\n\ngoal (1 subgoal):\n 1. \\<And>a ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatariths_aformerr p ra VS =\n                   Some X \\<Longrightarrow>\n                   interpret_floatariths ra vs \\<in> aforms_err e X;\n        approx_floatariths_aformerr p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatariths (a # ra) vs\n                         \\<in> aforms_err e X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatariths_aformerr p ra VS =\n                   Some X \\<Longrightarrow>\n                   interpret_floatariths ra vs \\<in> aforms_err e X;\n        approx_floatariths_aformerr p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatariths (a # ra) vs\n                         \\<in> aforms_err e X", "case (Cons ra ras)"], ["proof (state)\nthis:\n  approx_floatariths_aformerr p ras VS = Some ?X \\<Longrightarrow>\n  interpret_floatariths ras vs \\<in> aforms_err e ?X\n  approx_floatariths_aformerr p (ra # ras) VS = Some X\n\ngoal (1 subgoal):\n 1. \\<And>a ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatariths_aformerr p ra VS =\n                   Some X \\<Longrightarrow>\n                   interpret_floatariths ra vs \\<in> aforms_err e X;\n        approx_floatariths_aformerr p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatariths (a # ra) vs\n                         \\<in> aforms_err e X", "from Cons.prems"], ["proof (chain)\npicking this:\n  approx_floatariths_aformerr p (ra # ras) VS = Some X", "obtain a r where a: \"approx_floatarith p ra VS = Some a\"\n    and r: \"approx_floatariths_aformerr p ras VS = Some r\"\n    and X: \"X = a # r\""], ["proof (prove)\nusing this:\n  approx_floatariths_aformerr p (ra # ras) VS = Some X\n\ngoal (1 subgoal):\n 1. (\\<And>a r.\n        \\<lbrakk>approx_floatarith p ra VS = Some a;\n         approx_floatariths_aformerr p ras VS = Some r; X = a # r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: bind_eq_Some_conv)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some a\n  approx_floatariths_aformerr p ras VS = Some r\n  X = a # r\n\ngoal (1 subgoal):\n 1. \\<And>a ra X.\n       \\<lbrakk>\\<And>X.\n                   approx_floatariths_aformerr p ra VS =\n                   Some X \\<Longrightarrow>\n                   interpret_floatariths ra vs \\<in> aforms_err e X;\n        approx_floatariths_aformerr p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_floatariths (a # ra) vs\n                         \\<in> aforms_err e X", "then"], ["proof (chain)\npicking this:\n  approx_floatarith p ra VS = Some a\n  approx_floatariths_aformerr p ras VS = Some r\n  X = a # r", "show ?case"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some a\n  approx_floatariths_aformerr p ras VS = Some r\n  X = a # r\n\ngoal (1 subgoal):\n 1. interpret_floatariths (ra # ras) vs \\<in> aforms_err e X", "using assms(1)"], ["proof (prove)\nusing this:\n  approx_floatarith p ra VS = Some a\n  approx_floatariths_aformerr p ras VS = Some r\n  X = a # r\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. interpret_floatariths (ra # ras) vs \\<in> aforms_err e X", "by (auto simp: X Cons.IH intro!: approx_floatarith_Elem assms)"], ["proof (state)\nthis:\n  interpret_floatariths (ra # ras) vs \\<in> aforms_err e X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_max_mono:\n  fixes x::\"'a::linorder\"\n  shows \"x \\<le> y \\<Longrightarrow> fold max zs x \\<le> fold max zs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> fold max zs x \\<le> fold max zs y", "by (induct zs arbitrary: x y) (auto intro!: Cons simp: max_def)"], ["", "lemma fold_max_le_self:\n  fixes y::\"'a::linorder\"\n  shows \"y \\<le> fold max ys y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> fold max ys y", "by (induct ys) (auto intro: order_trans[OF _ fold_max_mono])"], ["", "lemma fold_max_le:\n  fixes x::\"'a::linorder\"\n  shows \"x \\<in> set xs \\<Longrightarrow> x \\<le> fold max xs z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<le> fold max xs z", "by (induct xs arbitrary: x z) (auto intro: order_trans[OF _ fold_max_le_self])"], ["", "abbreviation \"degree_aforms_err \\<equiv> degrees o map (snd o fst)\""], ["", "definition \"aforms_err_to_aforms d xs =\n  (map (\\<lambda>(d, x). aform_err_to_aform x d) (zip [d..<d + length xs] xs))\""], ["", "lemma aform_vals_empty[simp]: \"aform_vals e' [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_vals e' [] = []", "by (auto simp: aform_vals_def)"], ["", "lemma aforms_err_to_aforms_Nil[simp]: \"(aforms_err_to_aforms n []) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aforms_err_to_aforms n [] = []", "by (auto simp: aforms_err_to_aforms_def)"], ["", "lemma aforms_err_to_aforms_Cons[simp]:\n  \"aforms_err_to_aforms n (X # XS) = aform_err_to_aform X n # aforms_err_to_aforms (Suc n) XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aforms_err_to_aforms n (X # XS) =\n    aform_err_to_aform X n # aforms_err_to_aforms (Suc n) XS", "by (auto simp: aforms_err_to_aforms_def not_le nth_append nth_Cons \n      intro!: nth_equalityI split: nat.splits)"], ["", "lemma degree_aform_err_to_aform_le:\n  \"degree_aform (aform_err_to_aform X n) \\<le> max (degree_aform_err X) (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform (aform_err_to_aform X n)\n    \\<le> max (degree_aform_err X) (Suc n)", "by (auto simp: aform_err_to_aform_def intro!: degree_le)"], ["", "lemma less_degree_aform_aform_err_to_aformD: \"i < degree_aform (aform_err_to_aform X n) \\<Longrightarrow> i < max (Suc n) (degree_aform_err X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < degree_aform (aform_err_to_aform X n) \\<Longrightarrow>\n    i < max (Suc n) (degree_aform_err X)", "using degree_aform_err_to_aform_le[of X n]"], ["proof (prove)\nusing this:\n  degree_aform (aform_err_to_aform X n)\n  \\<le> max (degree_aform_err X) (Suc n)\n\ngoal (1 subgoal):\n 1. i < degree_aform (aform_err_to_aform X n) \\<Longrightarrow>\n    i < max (Suc n) (degree_aform_err X)", "by auto"], ["", "lemma pdevs_domain_aform_err_to_aform:\n  \"pdevs_domain (snd (aform_err_to_aform X n)) = pdevs_domain (snd (fst X)) \\<union> (if snd X = 0 then {} else {n})\"\n  if \"n \\<ge> degree_aform_err X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain (snd (aform_err_to_aform X n)) =\n    pdevs_domain (snd (fst X)) \\<union> (if snd X = 0 then {} else {n})", "using that"], ["proof (prove)\nusing this:\n  degree_aform_err X \\<le> n\n\ngoal (1 subgoal):\n 1. pdevs_domain (snd (aform_err_to_aform X n)) =\n    pdevs_domain (snd (fst X)) \\<union> (if snd X = 0 then {} else {n})", "by (auto simp: aform_err_to_aform_def split: if_splits)"], ["", "lemma length_aforms_err_to_aforms[simp]: \"length (aforms_err_to_aforms i XS) = length XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (aforms_err_to_aforms i XS) = length XS", "by (auto simp: aforms_err_to_aforms_def)"], ["", "lemma aforms_err_to_aforms_ex:\n  assumes X: \"x \\<in> aforms_err e X\"\n  assumes deg: \"degree_aforms_err X \\<le> n\"\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"\\<exists>e'\\<in> UNIV \\<rightarrow> {-1 .. 1}. x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n    (\\<forall>i < n. e' i = e i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n       x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n       (\\<forall>i<n. e' i = e i)", "using X deg"], ["proof (prove)\nusing this:\n  x \\<in> aforms_err e X\n  degree_aforms_err X \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n       x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n       (\\<forall>i<n. e' i = e i)", "proof (induction X arbitrary: x n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>x \\<in> aforms_err e [];\n        degree_aforms_err [] \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e' (aforms_err_to_aforms n []) \\<and>\n                            (\\<forall>i<n. e' i = e i)\n 2. \\<And>a X x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>x \\<in> aforms_err e X;\n                    degree_aforms_err X \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'\n        \\<in>UNIV \\<rightarrow> {- 1..1}.\n  x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n  (\\<forall>i<n. e' i = e i);\n        x \\<in> aforms_err e (a # X);\n        degree_aforms_err (a # X) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e'\n                             (aforms_err_to_aforms n (a # X)) \\<and>\n                            (\\<forall>i<n. e' i = e i)", "case Nil"], ["proof (state)\nthis:\n  x \\<in> aforms_err e []\n  degree_aforms_err [] \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>x \\<in> aforms_err e [];\n        degree_aforms_err [] \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e' (aforms_err_to_aforms n []) \\<and>\n                            (\\<forall>i<n. e' i = e i)\n 2. \\<And>a X x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>x \\<in> aforms_err e X;\n                    degree_aforms_err X \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'\n        \\<in>UNIV \\<rightarrow> {- 1..1}.\n  x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n  (\\<forall>i<n. e' i = e i);\n        x \\<in> aforms_err e (a # X);\n        degree_aforms_err (a # X) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e'\n                             (aforms_err_to_aforms n (a # X)) \\<and>\n                            (\\<forall>i<n. e' i = e i)", "then"], ["proof (chain)\npicking this:\n  x \\<in> aforms_err e []\n  degree_aforms_err [] \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> aforms_err e []\n  degree_aforms_err [] \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n       x = aform_vals e' (aforms_err_to_aforms n []) \\<and>\n       (\\<forall>i<n. e' i = e i)", "using e"], ["proof (prove)\nusing this:\n  x \\<in> aforms_err e []\n  degree_aforms_err [] \\<le> n\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n       x = aform_vals e' (aforms_err_to_aforms n []) \\<and>\n       (\\<forall>i<n. e' i = e i)", "by (auto simp: o_def degrees_def intro!: bexI[where x=\"\\<lambda>i. e i\"])"], ["proof (state)\nthis:\n  \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n     x = aform_vals e' (aforms_err_to_aforms n []) \\<and>\n     (\\<forall>i<n. e' i = e i)\n\ngoal (1 subgoal):\n 1. \\<And>a X x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>x \\<in> aforms_err e X;\n                    degree_aforms_err X \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'\n        \\<in>UNIV \\<rightarrow> {- 1..1}.\n  x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n  (\\<forall>i<n. e' i = e i);\n        x \\<in> aforms_err e (a # X);\n        degree_aforms_err (a # X) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e'\n                             (aforms_err_to_aforms n (a # X)) \\<and>\n                            (\\<forall>i<n. e' i = e i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a X x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>x \\<in> aforms_err e X;\n                    degree_aforms_err X \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'\n        \\<in>UNIV \\<rightarrow> {- 1..1}.\n  x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n  (\\<forall>i<n. e' i = e i);\n        x \\<in> aforms_err e (a # X);\n        degree_aforms_err (a # X) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e'\n                             (aforms_err_to_aforms n (a # X)) \\<and>\n                            (\\<forall>i<n. e' i = e i)", "case (Cons X XS)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> aforms_err e XS; degree_aforms_err XS \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                       ?x =\n                       aform_vals e' (aforms_err_to_aforms ?n XS) \\<and>\n                       (\\<forall>i<?n. e' i = e i)\n  x \\<in> aforms_err e (X # XS)\n  degree_aforms_err (X # XS) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>a X x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>x \\<in> aforms_err e X;\n                    degree_aforms_err X \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'\n        \\<in>UNIV \\<rightarrow> {- 1..1}.\n  x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n  (\\<forall>i<n. e' i = e i);\n        x \\<in> aforms_err e (a # X);\n        degree_aforms_err (a # X) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e'\n                             (aforms_err_to_aforms n (a # X)) \\<and>\n                            (\\<forall>i<n. e' i = e i)", "from Cons.prems"], ["proof (chain)\npicking this:\n  x \\<in> aforms_err e (X # XS)\n  degree_aforms_err (X # XS) \\<le> n", "obtain y ys where ys:\n    \"degree_aform_err X \\<le> n\"\n    \"degree_aforms_err XS \\<le> n\"\n    \"x = y # ys\" \"y \\<in> aform_err e X\" \"ys \\<in> aforms_err e XS\""], ["proof (prove)\nusing this:\n  x \\<in> aforms_err e (X # XS)\n  degree_aforms_err (X # XS) \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>degree_aform_err X \\<le> n; degree_aforms_err XS \\<le> n;\n         x = y # ys; y \\<in> aform_err e X;\n         ys \\<in> aforms_err e XS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mem_aforms_err_Cons_iff_Ex_conv degrees_def)"], ["proof (state)\nthis:\n  degree_aform_err X \\<le> n\n  degree_aforms_err XS \\<le> n\n  x = y # ys\n  y \\<in> aform_err e X\n  ys \\<in> aforms_err e XS\n\ngoal (1 subgoal):\n 1. \\<And>a X x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>x \\<in> aforms_err e X;\n                    degree_aforms_err X \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'\n        \\<in>UNIV \\<rightarrow> {- 1..1}.\n  x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n  (\\<forall>i<n. e' i = e i);\n        x \\<in> aforms_err e (a # X);\n        degree_aforms_err (a # X) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e'\n                             (aforms_err_to_aforms n (a # X)) \\<and>\n                            (\\<forall>i<n. e' i = e i)", "then"], ["proof (chain)\npicking this:\n  degree_aform_err X \\<le> n\n  degree_aforms_err XS \\<le> n\n  x = y # ys\n  y \\<in> aform_err e X\n  ys \\<in> aforms_err e XS", "have \"degree_aforms_err XS \\<le> Suc n\""], ["proof (prove)\nusing this:\n  degree_aform_err X \\<le> n\n  degree_aforms_err XS \\<le> n\n  x = y # ys\n  y \\<in> aform_err e X\n  ys \\<in> aforms_err e XS\n\ngoal (1 subgoal):\n 1. degree_aforms_err XS \\<le> Suc n", "by auto"], ["proof (state)\nthis:\n  degree_aforms_err XS \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>a X x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>x \\<in> aforms_err e X;\n                    degree_aforms_err X \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'\n        \\<in>UNIV \\<rightarrow> {- 1..1}.\n  x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n  (\\<forall>i<n. e' i = e i);\n        x \\<in> aforms_err e (a # X);\n        degree_aforms_err (a # X) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e'\n                             (aforms_err_to_aforms n (a # X)) \\<and>\n                            (\\<forall>i<n. e' i = e i)", "from Cons.IH[OF ys(5) this]"], ["proof (chain)\npicking this:\n  \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n     ys = aform_vals e' (aforms_err_to_aforms (Suc n) XS) \\<and>\n     (\\<forall>i<Suc n. e' i = e i)", "obtain e' where e': \"e'\\<in>UNIV \\<rightarrow> {- 1..1}\" \"ys = aform_vals e' (aforms_err_to_aforms (Suc n) XS)\"\n    \"(\\<forall>i<n. e' i = e i)\""], ["proof (prove)\nusing this:\n  \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n     ys = aform_vals e' (aforms_err_to_aforms (Suc n) XS) \\<and>\n     (\\<forall>i<Suc n. e' i = e i)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> {- 1..1};\n         ys = aform_vals e' (aforms_err_to_aforms (Suc n) XS);\n         \\<forall>i<n. e' i = e i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  ys = aform_vals e' (aforms_err_to_aforms (Suc n) XS)\n  \\<forall>i<n. e' i = e i\n\ngoal (1 subgoal):\n 1. \\<And>a X x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>x \\<in> aforms_err e X;\n                    degree_aforms_err X \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'\n        \\<in>UNIV \\<rightarrow> {- 1..1}.\n  x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n  (\\<forall>i<n. e' i = e i);\n        x \\<in> aforms_err e (a # X);\n        degree_aforms_err (a # X) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e'\n                             (aforms_err_to_aforms n (a # X)) \\<and>\n                            (\\<forall>i<n. e' i = e i)", "from aform_err_to_aformE[OF ys(4,1)]"], ["proof (chain)\npicking this:\n  (\\<And>err.\n      \\<lbrakk>y = aform_val (e(n := err)) (aform_err_to_aform X n);\n       - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain err where err:\n    \"y = aform_val (e(n := err)) (aform_err_to_aform X n)\" \"- 1 \\<le> err\" \"err \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<And>err.\n      \\<lbrakk>y = aform_val (e(n := err)) (aform_err_to_aform X n);\n       - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>err.\n        \\<lbrakk>y = aform_val (e(n := err)) (aform_err_to_aform X n);\n         - 1 \\<le> err; err \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = aform_val (e(n := err)) (aform_err_to_aform X n)\n  - 1 \\<le> err\n  err \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>a X x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>x \\<in> aforms_err e X;\n                    degree_aforms_err X \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e'\n        \\<in>UNIV \\<rightarrow> {- 1..1}.\n  x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n  (\\<forall>i<n. e' i = e i);\n        x \\<in> aforms_err e (a # X);\n        degree_aforms_err (a # X) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n                            x =\n                            aform_vals e'\n                             (aforms_err_to_aforms n (a # X)) \\<and>\n                            (\\<forall>i<n. e' i = e i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n       x = aform_vals e' (aforms_err_to_aforms n (X # XS)) \\<and>\n       (\\<forall>i<n. e' i = e i)", "proof (safe intro!: bexI[where x=\"e'(n:=err)\"], goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x = aform_vals (e'(n := err)) (aforms_err_to_aforms n (X # XS))\n 2. \\<And>i. i < n \\<Longrightarrow> (e'(n := err)) i = e i\n 3. \\<And>x. x \\<in> UNIV \\<Longrightarrow> (e'(n := err)) x \\<in> {- 1..1}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. x = aform_vals (e'(n := err)) (aforms_err_to_aforms n (X # XS))\n 2. \\<And>i. i < n \\<Longrightarrow> (e'(n := err)) i = e i\n 3. \\<And>x. x \\<in> UNIV \\<Longrightarrow> (e'(n := err)) x \\<in> {- 1..1}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = aform_vals (e'(n := err)) (aforms_err_to_aforms n (X # XS))", "unfolding ys e' err"], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val (e(n := err)) (aform_err_to_aform X n) #\n    aform_vals e' (aforms_err_to_aforms (Suc n) XS) =\n    aform_vals (e'(n := err)) (aforms_err_to_aforms n (X # XS))", "apply (auto simp: aform_vals_def  aform_val_def simp del:  pdevs_val_upd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pdevs_val (e(n := err)) (snd (aform_err_to_aform X n)) =\n    pdevs_val (\\<lambda>a. if a = n then err else e' a)\n     (snd (aform_err_to_aform X n))\n 2. \\<And>a b.\n       (a, b) \\<in> set (aforms_err_to_aforms (Suc n) XS) \\<Longrightarrow>\n       pdevs_val e' b =\n       pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "apply (rule pdevs_val_degree_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. snd (aform_err_to_aform X n) = snd (aform_err_to_aform X n)\n 2. \\<And>i.\n       i < degree_aform (aform_err_to_aform X n) \\<Longrightarrow>\n       (e(n := err)) i = (if i = n then err else e' i)\n 3. \\<And>a b.\n       (a, b) \\<in> set (aforms_err_to_aforms (Suc n) XS) \\<Longrightarrow>\n       pdevs_val e' b =\n       pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < degree_aform (aform_err_to_aform X n) \\<Longrightarrow>\n       (e(n := err)) i = (if i = n then err else e' i)\n 2. \\<And>a b.\n       (a, b) \\<in> set (aforms_err_to_aforms (Suc n) XS) \\<Longrightarrow>\n       pdevs_val e' b =\n       pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. i_ < degree_aform (aform_err_to_aform X n) \\<Longrightarrow>\n    (e(n := err)) i_ = (if i_ = n then err else e' i_)", "using ys e'"], ["proof (prove)\nusing this:\n  degree_aform_err X \\<le> n\n  degree_aforms_err XS \\<le> n\n  x = y # ys\n  y \\<in> aform_err e X\n  ys \\<in> aforms_err e XS\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  ys = aform_vals e' (aforms_err_to_aforms (Suc n) XS)\n  \\<forall>i<n. e' i = e i\n\ngoal (1 subgoal):\n 1. i_ < degree_aform (aform_err_to_aform X n) \\<Longrightarrow>\n    (e(n := err)) i_ = (if i_ = n then err else e' i_)", "by (auto dest!: less_degree_aform_aform_err_to_aformD simp: max_def split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (aforms_err_to_aforms (Suc n) XS) \\<Longrightarrow>\n       pdevs_val e' b =\n       pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "subgoal premises prems for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "have \"pdevs_val (\\<lambda>a. if a = n then err else e' a) b = pdevs_val (e'(n:=err)) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>a. if a = n then err else e' a) b =\n    pdevs_val (e'(n := err)) b", "unfolding fun_upd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>a. if a = n then err else e' a) b =\n    pdevs_val (\\<lambda>x. if x = n then err else e' x) b", "by simp"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>a. if a = n then err else e' a) b =\n  pdevs_val (e'(n := err)) b\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "also"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>a. if a = n then err else e' a) b =\n  pdevs_val (e'(n := err)) b\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "have \"\\<dots> = pdevs_val e' b - e' n * pdevs_apply b n + err * pdevs_apply b n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (e'(n := err)) b =\n    pdevs_val e' b - e' n * pdevs_apply b n + err * pdevs_apply b n", "by simp"], ["proof (state)\nthis:\n  pdevs_val (e'(n := err)) b =\n  pdevs_val e' b - e' n * pdevs_apply b n + err * pdevs_apply b n\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "also"], ["proof (state)\nthis:\n  pdevs_val (e'(n := err)) b =\n  pdevs_val e' b - e' n * pdevs_apply b n + err * pdevs_apply b n\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "from prems"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set (aforms_err_to_aforms (Suc n) XS)", "obtain i where i: \"aforms_err_to_aforms (Suc n) XS ! i = (a, b)\"\n          \"i < length (aforms_err_to_aforms (Suc n) XS)\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> set (aforms_err_to_aforms (Suc n) XS)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>aforms_err_to_aforms (Suc n) XS ! i = (a, b);\n         i < length (aforms_err_to_aforms (Suc n) XS)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth )"], ["proof (state)\nthis:\n  aforms_err_to_aforms (Suc n) XS ! i = (a, b)\n  i < length (aforms_err_to_aforms (Suc n) XS)\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "{"], ["proof (state)\nthis:\n  aforms_err_to_aforms (Suc n) XS ! i = (a, b)\n  i < length (aforms_err_to_aforms (Suc n) XS)\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "note i(1)[symmetric]"], ["proof (state)\nthis:\n  (a, b) = aforms_err_to_aforms (Suc n) XS ! i\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "also"], ["proof (state)\nthis:\n  (a, b) = aforms_err_to_aforms (Suc n) XS ! i\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "have \"aforms_err_to_aforms (Suc n) XS ! i = aform_err_to_aform (XS ! i) (Suc n + i) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. aforms_err_to_aforms (Suc n) XS ! i =\n    aform_err_to_aform (XS ! i) (Suc n + i)", "unfolding aforms_err_to_aforms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<lambda>d x. aform_err_to_aform x d) [Suc n..<Suc n + length XS]\n     XS !\n    i =\n    aform_err_to_aform (XS ! i) (Suc n + i)", "using i"], ["proof (prove)\nusing this:\n  aforms_err_to_aforms (Suc n) XS ! i = (a, b)\n  i < length (aforms_err_to_aforms (Suc n) XS)\n\ngoal (1 subgoal):\n 1. map2 (\\<lambda>d x. aform_err_to_aform x d) [Suc n..<Suc n + length XS]\n     XS !\n    i =\n    aform_err_to_aform (XS ! i) (Suc n + i)", "by (simp del: upt_Suc)"], ["proof (state)\nthis:\n  aforms_err_to_aforms (Suc n) XS ! i =\n  aform_err_to_aform (XS ! i) (Suc n + i)\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "finally"], ["proof (chain)\npicking this:\n  (a, b) = aform_err_to_aform (XS ! i) (Suc n + i)", "have \"b = snd (aform_err_to_aform (XS ! i) (Suc n + i))\""], ["proof (prove)\nusing this:\n  (a, b) = aform_err_to_aform (XS ! i) (Suc n + i)\n\ngoal (1 subgoal):\n 1. b = snd (aform_err_to_aform (XS ! i) (Suc n + i))", "by (auto simp: prod_eq_iff)"], ["proof (state)\nthis:\n  b = snd (aform_err_to_aform (XS ! i) (Suc n + i))\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "}"], ["proof (state)\nthis:\n  b = snd (aform_err_to_aform (XS ! i) (Suc n + i))\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "note b = this"], ["proof (state)\nthis:\n  b = snd (aform_err_to_aform (XS ! i) (Suc n + i))\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "have \"degree_aform_err (XS ! i) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform_err (XS ! i) \\<le> n", "using ys(2) i"], ["proof (prove)\nusing this:\n  degree_aforms_err XS \\<le> n\n  aforms_err_to_aforms (Suc n) XS ! i = (a, b)\n  i < length (aforms_err_to_aforms (Suc n) XS)\n\ngoal (1 subgoal):\n 1. degree_aform_err (XS ! i) \\<le> n", "by (auto simp:  degrees_def)"], ["proof (state)\nthis:\n  degree_aform_err (XS ! i) \\<le> n\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "then"], ["proof (chain)\npicking this:\n  degree_aform_err (XS ! i) \\<le> n", "have \"n \\<notin> pdevs_domain b\""], ["proof (prove)\nusing this:\n  degree_aform_err (XS ! i) \\<le> n\n\ngoal (1 subgoal):\n 1. n \\<notin> pdevs_domain b", "unfolding b"], ["proof (prove)\nusing this:\n  degree_aform_err (XS ! i) \\<le> n\n\ngoal (1 subgoal):\n 1. n \\<notin> pdevs_domain (snd (aform_err_to_aform (XS ! i) (Suc n + i)))", "apply (subst pdevs_domain_aform_err_to_aform)"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree_aform_err (XS ! i) \\<le> n \\<Longrightarrow>\n    degree_aform_err (XS ! i) \\<le> Suc n + i\n 2. degree_aform_err (XS ! i) \\<le> n \\<Longrightarrow>\n    n \\<notin> pdevs_domain (snd (fst (XS ! i))) \\<union>\n               (if snd (XS ! i) = 0 then {} else {Suc n + i})", "by (auto intro!: degree)"], ["proof (state)\nthis:\n  n \\<notin> pdevs_domain b\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "then"], ["proof (chain)\npicking this:\n  n \\<notin> pdevs_domain b", "have \"pdevs_apply b n = 0\""], ["proof (prove)\nusing this:\n  n \\<notin> pdevs_domain b\n\ngoal (1 subgoal):\n 1. pdevs_apply b n = 0", "by simp"], ["proof (state)\nthis:\n  pdevs_apply b n = 0\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "finally"], ["proof (chain)\npicking this:\n  pdevs_val (\\<lambda>a. if a = n then err else e' a) b =\n  pdevs_val e' b - e' n * 0 + err * 0", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_val (\\<lambda>a. if a = n then err else e' a) b =\n  pdevs_val e' b - e' n * 0 + err * 0\n\ngoal (1 subgoal):\n 1. pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b", "by simp"], ["proof (state)\nthis:\n  pdevs_val e' b = pdevs_val (\\<lambda>a. if a = n then err else e' a) b\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x = aform_vals (e'(n := err)) (aforms_err_to_aforms n (X # XS))\n\ngoal (2 subgoals):\n 1. \\<And>i. i < n \\<Longrightarrow> (e'(n := err)) i = e i\n 2. \\<And>x. x \\<in> UNIV \\<Longrightarrow> (e'(n := err)) x \\<in> {- 1..1}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i < n \\<Longrightarrow> (e'(n := err)) i = e i\n 2. \\<And>x. x \\<in> UNIV \\<Longrightarrow> (e'(n := err)) x \\<in> {- 1..1}", "case (2 i)"], ["proof (state)\nthis:\n  i < n\n\ngoal (2 subgoals):\n 1. \\<And>i. i < n \\<Longrightarrow> (e'(n := err)) i = e i\n 2. \\<And>x. x \\<in> UNIV \\<Longrightarrow> (e'(n := err)) x \\<in> {- 1..1}", "then"], ["proof (chain)\npicking this:\n  i < n", "show ?case"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. (e'(n := err)) i = e i", "using e'"], ["proof (prove)\nusing this:\n  i < n\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  ys = aform_vals e' (aforms_err_to_aforms (Suc n) XS)\n  \\<forall>i<n. e' i = e i\n\ngoal (1 subgoal):\n 1. (e'(n := err)) i = e i", "by auto"], ["proof (state)\nthis:\n  (e'(n := err)) i = e i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> (e'(n := err)) x \\<in> {- 1..1}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> (e'(n := err)) x \\<in> {- 1..1}", "case (3 i)"], ["proof (state)\nthis:\n  i \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> (e'(n := err)) x \\<in> {- 1..1}", "then"], ["proof (chain)\npicking this:\n  i \\<in> UNIV", "show ?case"], ["proof (prove)\nusing this:\n  i \\<in> UNIV\n\ngoal (1 subgoal):\n 1. (e'(n := err)) i \\<in> {- 1..1}", "using e' err"], ["proof (prove)\nusing this:\n  i \\<in> UNIV\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  ys = aform_vals e' (aforms_err_to_aforms (Suc n) XS)\n  \\<forall>i<n. e' i = e i\n  y = aform_val (e(n := err)) (aform_err_to_aform X n)\n  - 1 \\<le> err\n  err \\<le> 1\n\ngoal (1 subgoal):\n 1. (e'(n := err)) i \\<in> {- 1..1}", "by auto"], ["proof (state)\nthis:\n  (e'(n := err)) i \\<in> {- 1..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n     x = aform_vals e' (aforms_err_to_aforms n (X # XS)) \\<and>\n     (\\<forall>i<n. e' i = e i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aforms_err_to_aformsE:\n  assumes X: \"x \\<in> aforms_err e X\"\n  assumes deg: \"degree_aforms_err X \\<le> n\"\n    assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  obtains e' where \"x = aform_vals e' (aforms_err_to_aforms n X)\" \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n    \"\\<And>i. i < n \\<Longrightarrow> e' i = e i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>x = aform_vals e' (aforms_err_to_aforms n X);\n         e' \\<in> UNIV \\<rightarrow> {- 1..1};\n         \\<And>i. i < n \\<Longrightarrow> e' i = e i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using aforms_err_to_aforms_ex[OF X deg e]"], ["proof (prove)\nusing this:\n  \\<exists>e'\\<in>UNIV \\<rightarrow> {- 1..1}.\n     x = aform_vals e' (aforms_err_to_aforms n X) \\<and>\n     (\\<forall>i<n. e' i = e i)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>x = aform_vals e' (aforms_err_to_aforms n X);\n         e' \\<in> UNIV \\<rightarrow> {- 1..1};\n         \\<And>i. i < n \\<Longrightarrow> e' i = e i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "definition \"approx_floatariths p ea as =\n  do {\n    let da = (degree_aforms as);\n    let aes = (map (\\<lambda>x. (x, 0)) as);\n    rs \\<leftarrow> approx_floatariths_aformerr p ea aes;\n    let d = max da (degree_aforms_err (rs));\n    Some (aforms_err_to_aforms d rs)\n  }\""], ["", "lemma listset_sings[simp]:\n  \"listset (map (\\<lambda>x. {f x}) as) = {map f as}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listset (map (\\<lambda>x. {f x}) as) = {map f as}", "by (induction as) (auto simp: set_Cons_def)"], ["", "lemma approx_floatariths_outer:\n  assumes \"approx_floatariths p ea as = Some XS\"\n  assumes \"vs \\<in> Joints as\"\n  shows \"(interpret_floatariths ea vs @ vs) \\<in> Joints (XS @ as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "from assms"], ["proof (chain)\npicking this:\n  approx_floatariths p ea as = Some XS\n  vs \\<in> Joints as", "obtain da aes rs d where\n     da: \"da = degree_aforms as\"\n    and aes: \"aes = (map (\\<lambda>x. (x, 0)) as)\"\n    and rs: \"approx_floatariths_aformerr p ea aes = Some rs\"\n    and d: \"d = max da (degree_aforms_err (rs))\"\n    and XS: \"aforms_err_to_aforms d rs = XS\""], ["proof (prove)\nusing this:\n  approx_floatariths p ea as = Some XS\n  vs \\<in> Joints as\n\ngoal (1 subgoal):\n 1. (\\<And>da aes rs d.\n        \\<lbrakk>da = degree_aforms as; aes = map (\\<lambda>x. (x, 0)) as;\n         approx_floatariths_aformerr p ea aes = Some rs;\n         d = max da (degree_aforms_err rs);\n         aforms_err_to_aforms d rs = XS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: approx_floatariths_def Let_def bind_eq_Some_conv)"], ["proof (state)\nthis:\n  da = degree_aforms as\n  aes = map (\\<lambda>x. (x, 0)) as\n  approx_floatariths_aformerr p ea aes = Some rs\n  d = max da (degree_aforms_err rs)\n  aforms_err_to_aforms d rs = XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "have abbd: \"(a, b) \\<in> set as \\<Longrightarrow> degree b \\<le> degree_aforms as\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set as \\<Longrightarrow> degree b \\<le> degree_aforms as", "apply (rule degrees_leD[OF order_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set as \\<Longrightarrow> b \\<in> set (map snd as)", "by force"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> set as \\<Longrightarrow> degree ?b \\<le> degree_aforms as\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "from da d"], ["proof (chain)\npicking this:\n  da = degree_aforms as\n  d = max da (degree_aforms_err rs)", "have i_less: \"(a, b) \\<in> set as \\<Longrightarrow> i < degree b \\<Longrightarrow> i < min d da\" for i a b"], ["proof (prove)\nusing this:\n  da = degree_aforms as\n  d = max da (degree_aforms_err rs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> set as; i < degree b\\<rbrakk>\n    \\<Longrightarrow> i < min d da", "by (auto dest!: abbd)"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?b) \\<in> set as; ?i < degree ?b\\<rbrakk>\n  \\<Longrightarrow> ?i < min d da\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "have abbd: \"(a, b) \\<in> set as \\<Longrightarrow> degree b \\<le> degree_aforms as\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set as \\<Longrightarrow> degree b \\<le> degree_aforms as", "apply (rule degrees_leD[OF order_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set as \\<Longrightarrow> b \\<in> set (map snd as)", "by force"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> set as \\<Longrightarrow> degree ?b \\<le> degree_aforms as\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "from assms"], ["proof (chain)\npicking this:\n  approx_floatariths p ea as = Some XS\n  vs \\<in> Joints as", "obtain e' where vs: \"vs = (map (aform_val e') as)\" and e': \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  approx_floatariths p ea as = Some XS\n  vs \\<in> Joints as\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>vs = map (aform_val e') as;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Joints_def valuate_def)"], ["proof (state)\nthis:\n  vs = map (aform_val e') as\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "note vs"], ["proof (state)\nthis:\n  vs = map (aform_val e') as\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "also"], ["proof (state)\nthis:\n  vs = map (aform_val e') as\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "have vs_aes: \"vs \\<in> aforms_err e' aes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> aforms_err e' aes", "unfolding aes"], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> aforms_err e' (map (\\<lambda>x. (x, 0)) as)", "by (auto simp: vs aforms_err_def o_def aform_err_def)"], ["proof (state)\nthis:\n  vs \\<in> aforms_err e' aes\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "from approx_floatariths_Elem[OF e' rs this]"], ["proof (chain)\npicking this:\n  interpret_floatariths ea vs \\<in> aforms_err e' rs", "have iars: \"interpret_floatariths ea (map (aform_val e') as) \\<in> aforms_err e' rs\""], ["proof (prove)\nusing this:\n  interpret_floatariths ea vs \\<in> aforms_err e' rs\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea (map (aform_val e') as) \\<in> aforms_err e' rs", "by (auto simp: vs)"], ["proof (state)\nthis:\n  interpret_floatariths ea (map (aform_val e') as) \\<in> aforms_err e' rs\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "have \"degree_aforms_err rs \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aforms_err rs \\<le> d", "by (auto simp: d da)"], ["proof (state)\nthis:\n  degree_aforms_err rs \\<le> d\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "from aforms_err_to_aformsE[OF iars this e']"], ["proof (chain)\npicking this:\n  (\\<And>e'a.\n      \\<lbrakk>interpret_floatariths ea (map (aform_val e') as) =\n               aform_vals e'a (aforms_err_to_aforms d rs);\n       e'a \\<in> UNIV \\<rightarrow> {- 1..1};\n       \\<And>i. i < d \\<Longrightarrow> e'a i = e' i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e where\n    \"interpret_floatariths ea (map (aform_val e') as) = aform_vals e XS\"\n    and e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\" \"\\<And>i. i < d \\<Longrightarrow> e i = e' i\""], ["proof (prove)\nusing this:\n  (\\<And>e'a.\n      \\<lbrakk>interpret_floatariths ea (map (aform_val e') as) =\n               aform_vals e'a (aforms_err_to_aforms d rs);\n       e'a \\<in> UNIV \\<rightarrow> {- 1..1};\n       \\<And>i. i < d \\<Longrightarrow> e'a i = e' i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>interpret_floatariths ea (map (aform_val e') as) =\n                 aform_vals e XS;\n         e \\<in> UNIV \\<rightarrow> {- 1..1};\n         \\<And>i. i < d \\<Longrightarrow> e i = e' i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: XS)"], ["proof (state)\nthis:\n  interpret_floatariths ea (map (aform_val e') as) = aform_vals e XS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d \\<Longrightarrow> e ?i = e' ?i\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "note this (1)"], ["proof (state)\nthis:\n  interpret_floatariths ea (map (aform_val e') as) = aform_vals e XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "finally"], ["proof (chain)\npicking this:\n  interpret_floatariths ea vs = aform_vals e XS", "have \"interpret_floatariths ea vs = aform_vals e XS\""], ["proof (prove)\nusing this:\n  interpret_floatariths ea vs = aform_vals e XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs = aform_vals e XS", "."], ["proof (state)\nthis:\n  interpret_floatariths ea vs = aform_vals e XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "moreover"], ["proof (state)\nthis:\n  interpret_floatariths ea vs = aform_vals e XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "from e"], ["proof (chain)\npicking this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d \\<Longrightarrow> e ?i = e' ?i", "have e'_eq: \"e' i = e i\" if \"i < min d da\" for i"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d \\<Longrightarrow> e ?i = e' ?i\n\ngoal (1 subgoal):\n 1. e' i = e i", "using that"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d \\<Longrightarrow> e ?i = e' ?i\n  i < min d da\n\ngoal (1 subgoal):\n 1. e' i = e i", "by (auto simp: min_def split: if_splits)"], ["proof (state)\nthis:\n  ?i < min d da \\<Longrightarrow> e' ?i = e ?i\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "then"], ["proof (chain)\npicking this:\n  ?i < min d da \\<Longrightarrow> e' ?i = e ?i", "have \"vs = aform_vals e as\""], ["proof (prove)\nusing this:\n  ?i < min d da \\<Longrightarrow> e' ?i = e ?i\n\ngoal (1 subgoal):\n 1. vs = aform_vals e as", "by (auto simp: vs aform_vals_def aform_val_def intro!: pdevs_val_degree_cong e'_eq i_less)"], ["proof (state)\nthis:\n  vs = aform_vals e as\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "ultimately"], ["proof (chain)\npicking this:\n  interpret_floatariths ea vs = aform_vals e XS\n  vs = aform_vals e as", "show ?thesis"], ["proof (prove)\nusing this:\n  interpret_floatariths ea vs = aform_vals e XS\n  vs = aform_vals e as\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "using e(1)"], ["proof (prove)\nusing this:\n  interpret_floatariths ea vs = aform_vals e XS\n  vs = aform_vals e as\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)", "by (auto simp: Joints_def valuate_def aform_vals_def intro!: image_eqI[where x=e])"], ["proof (state)\nthis:\n  interpret_floatariths ea vs @ vs \\<in> Joints (XS @ as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_eq_NilI: \"length [] = length []\"\n  and length_eq_ConsI: \"length xs = length ys \\<Longrightarrow> length (x#xs) = length (y#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] = length [] &&&\n    (length xs = length ys \\<Longrightarrow>\n     length (x # xs) = length (y # ys))", "by auto"], ["", "subsection \\<open>Generic operations on Affine Forms in Euclidean Space\\<close>"], ["", "lemma pdevs_val_domain_cong:\n  assumes \"b = d\"\n  assumes \"\\<And>i. i \\<in> pdevs_domain b \\<Longrightarrow> a i = c i\"\n  shows \"pdevs_val a b = pdevs_val c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val a b = pdevs_val c d", "using assms"], ["proof (prove)\nusing this:\n  b = d\n  ?i \\<in> pdevs_domain b \\<Longrightarrow> a ?i = c ?i\n\ngoal (1 subgoal):\n 1. pdevs_val a b = pdevs_val c d", "by (auto simp: pdevs_val_pdevs_domain)"], ["", "lemma fresh_JointsI:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"list_all (\\<lambda>Y. pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {}) XS\"\n  assumes \"x \\<in> Affine X\"\n  shows \"x#xs \\<in> Joints (X#XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x # xs \\<in> Joints (X # XS)", "using assms"], ["proof (prove)\nusing this:\n  xs \\<in> Joints XS\n  list_all\n   (\\<lambda>Y. pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {}) XS\n  x \\<in> Affine X\n\ngoal (1 subgoal):\n 1. x # xs \\<in> Joints (X # XS)", "unfolding Joints_def Affine_def valuate_def"], ["proof (prove)\nusing this:\n  xs \\<in> (\\<lambda>e. map (aform_val e) XS) `\n           (UNIV \\<rightarrow> {- 1..1})\n  list_all\n   (\\<lambda>Y. pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {}) XS\n  x \\<in> (\\<lambda>e. aform_val e X) ` (UNIV \\<rightarrow> {- 1..1})\n\ngoal (1 subgoal):\n 1. x # xs\n    \\<in> (\\<lambda>e. map (aform_val e) (X # XS)) `\n          (UNIV \\<rightarrow> {- 1..1})", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e ea.\n       \\<lbrakk>list_all\n                 (\\<lambda>Y.\n                     pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) =\n                     {})\n                 XS;\n        e \\<in> UNIV \\<rightarrow> {- 1..1}; xs = map (aform_val e) XS;\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; x = aform_val ea X\\<rbrakk>\n       \\<Longrightarrow> aform_val ea X # map (aform_val e) XS\n                         \\<in> (\\<lambda>e. map (aform_val e) (X # XS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "fix e e'::\"nat \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e ea.\n       \\<lbrakk>list_all\n                 (\\<lambda>Y.\n                     pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) =\n                     {})\n                 XS;\n        e \\<in> UNIV \\<rightarrow> {- 1..1}; xs = map (aform_val e) XS;\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; x = aform_val ea X\\<rbrakk>\n       \\<Longrightarrow> aform_val ea X # map (aform_val e) XS\n                         \\<in> (\\<lambda>e. map (aform_val e) (X # XS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "assume H: \"list_all (\\<lambda>Y. pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {}) XS\"\n    \"e \\<in> UNIV \\<rightarrow> {- 1..1}\"\n    \"e' \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>Y. pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {}) XS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>e ea.\n       \\<lbrakk>list_all\n                 (\\<lambda>Y.\n                     pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) =\n                     {})\n                 XS;\n        e \\<in> UNIV \\<rightarrow> {- 1..1}; xs = map (aform_val e) XS;\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; x = aform_val ea X\\<rbrakk>\n       \\<Longrightarrow> aform_val ea X # map (aform_val e) XS\n                         \\<in> (\\<lambda>e. map (aform_val e) (X # XS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "have \"\\<And>a b i. \\<forall>Y\\<in>set XS. pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {} \\<Longrightarrow>\n       pdevs_apply b i \\<noteq> 0 \\<Longrightarrow>\n       pdevs_apply (snd X) i \\<noteq> 0 \\<Longrightarrow>\n       (a, b) \\<notin> set XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b i.\n       \\<lbrakk>\\<forall>Y\\<in>set XS.\n                   pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {};\n        pdevs_apply b i \\<noteq> (0::'a);\n        pdevs_apply (snd X) i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<notin> set XS", "by (metis (poly_guards_query) IntI all_not_in_conv in_pdevs_domain snd_eqD)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>Y\\<in>set XS.\n              pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {};\n   pdevs_apply ?b ?i \\<noteq> (0::'a);\n   pdevs_apply (snd X) ?i \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<notin> set XS\n\ngoal (1 subgoal):\n 1. \\<And>e ea.\n       \\<lbrakk>list_all\n                 (\\<lambda>Y.\n                     pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) =\n                     {})\n                 XS;\n        e \\<in> UNIV \\<rightarrow> {- 1..1}; xs = map (aform_val e) XS;\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; x = aform_val ea X\\<rbrakk>\n       \\<Longrightarrow> aform_val ea X # map (aform_val e) XS\n                         \\<in> (\\<lambda>e. map (aform_val e) (X # XS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "with H"], ["proof (chain)\npicking this:\n  list_all\n   (\\<lambda>Y. pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {}) XS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  \\<lbrakk>\\<forall>Y\\<in>set XS.\n              pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {};\n   pdevs_apply ?b ?i \\<noteq> (0::'a);\n   pdevs_apply (snd X) ?i \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<notin> set XS", "show\n    \"aform_val e' X # map (aform_val e) XS \\<in> (\\<lambda>e. map (aform_val e) (X # XS)) ` (UNIV \\<rightarrow> {- 1..1})\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>Y. pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {}) XS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n  \\<lbrakk>\\<forall>Y\\<in>set XS.\n              pdevs_domain (snd X) \\<inter> pdevs_domain (snd Y) = {};\n   pdevs_apply ?b ?i \\<noteq> (0::'a);\n   pdevs_apply (snd X) ?i \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<notin> set XS\n\ngoal (1 subgoal):\n 1. aform_val e' X # map (aform_val e) XS\n    \\<in> (\\<lambda>e. map (aform_val e) (X # XS)) `\n          (UNIV \\<rightarrow> {- 1..1})", "by (intro image_eqI[where x = \"\\<lambda>i. if i \\<in> pdevs_domain (snd X) then e' i else e i\"])\n      (auto simp: aform_val_def list_all_iff Pi_iff intro!: pdevs_val_domain_cong)"], ["proof (state)\nthis:\n  aform_val e' X # map (aform_val e) XS\n  \\<in> (\\<lambda>e. map (aform_val e) (X # XS)) `\n        (UNIV \\<rightarrow> {- 1..1})\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec approx_slp::\"nat \\<Rightarrow> slp \\<Rightarrow> aform_err list \\<Rightarrow> aform_err list option\"\nwhere\n  \"approx_slp p [] xs = Some xs\"\n| \"approx_slp p (ea # eas) xs =\n    do {\n      r \\<leftarrow> approx_floatarith p ea xs;\n      approx_slp p eas (r#xs)\n    }\""], ["", "lemma Nil_mem_Joints[intro, simp]: \"[] \\<in> Joints []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> Joints []", "by (force simp: Joints_def valuate_def)"], ["", "lemma map_nth_Joints: \"xs \\<in> Joints XS \\<Longrightarrow> (\\<And>i. i \\<in> set is \\<Longrightarrow> i < length XS) \\<Longrightarrow> map (nth xs) is @ xs \\<in> Joints (map (nth XS) is @ XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> Joints XS;\n     \\<And>i. i \\<in> set is \\<Longrightarrow> i < length XS\\<rbrakk>\n    \\<Longrightarrow> map ((!) xs) is @ xs\n                      \\<in> Joints (map ((!) XS) is @ XS)", "by (auto simp: Joints_def valuate_def)"], ["", "lemma map_nth_Joints': \"xs \\<in> Joints XS \\<Longrightarrow> (\\<And>i. i \\<in> set is \\<Longrightarrow> i < length XS) \\<Longrightarrow> map (nth xs) is \\<in> Joints (map (nth XS) is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> Joints XS;\n     \\<And>i. i \\<in> set is \\<Longrightarrow> i < length XS\\<rbrakk>\n    \\<Longrightarrow> map ((!) xs) is \\<in> Joints (map ((!) XS) is)", "by (rule Joints_appendD2[OF map_nth_Joints]) auto"], ["", "lemma approx_slp_Elem:\n  assumes e: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"vs \\<in> aforms_err e VS\"\n  assumes \"approx_slp p ra VS = Some X\"\n  shows \"interpret_slp ra vs \\<in> aforms_err e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_slp ra vs \\<in> aforms_err e X", "using assms(2-)"], ["proof (prove)\nusing this:\n  vs \\<in> aforms_err e VS\n  approx_slp p ra VS = Some X\n\ngoal (1 subgoal):\n 1. interpret_slp ra vs \\<in> aforms_err e X", "proof (induction ra arbitrary: X vs VS)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X vs VS.\n       \\<lbrakk>vs \\<in> aforms_err e VS;\n        approx_slp p [] VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp [] vs \\<in> aforms_err e X\n 2. \\<And>a ra X vs VS.\n       \\<lbrakk>\\<And>X vs VS.\n                   \\<lbrakk>vs \\<in> aforms_err e VS;\n                    approx_slp p ra VS = Some X\\<rbrakk>\n                   \\<Longrightarrow> interpret_slp ra vs\n                                     \\<in> aforms_err e X;\n        vs \\<in> aforms_err e VS; approx_slp p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp (a # ra) vs \\<in> aforms_err e X", "case (Cons ra ras)"], ["proof (state)\nthis:\n  \\<lbrakk>?vs \\<in> aforms_err e ?VS;\n   approx_slp p ras ?VS = Some ?X\\<rbrakk>\n  \\<Longrightarrow> interpret_slp ras ?vs \\<in> aforms_err e ?X\n  vs \\<in> aforms_err e VS\n  approx_slp p (ra # ras) VS = Some X\n\ngoal (2 subgoals):\n 1. \\<And>X vs VS.\n       \\<lbrakk>vs \\<in> aforms_err e VS;\n        approx_slp p [] VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp [] vs \\<in> aforms_err e X\n 2. \\<And>a ra X vs VS.\n       \\<lbrakk>\\<And>X vs VS.\n                   \\<lbrakk>vs \\<in> aforms_err e VS;\n                    approx_slp p ra VS = Some X\\<rbrakk>\n                   \\<Longrightarrow> interpret_slp ra vs\n                                     \\<in> aforms_err e X;\n        vs \\<in> aforms_err e VS; approx_slp p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp (a # ra) vs \\<in> aforms_err e X", "from Cons.prems"], ["proof (chain)\npicking this:\n  vs \\<in> aforms_err e VS\n  approx_slp p (ra # ras) VS = Some X", "obtain a where a: \"approx_floatarith p ra VS = Some a\"\n    and r: \"approx_slp p ras (a # VS) = Some X\""], ["proof (prove)\nusing this:\n  vs \\<in> aforms_err e VS\n  approx_slp p (ra # ras) VS = Some X\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>approx_floatarith p ra VS = Some a;\n         approx_slp p ras (a # VS) = Some X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: bind_eq_Some_conv)"], ["proof (state)\nthis:\n  approx_floatarith p ra VS = Some a\n  approx_slp p ras (a # VS) = Some X\n\ngoal (2 subgoals):\n 1. \\<And>X vs VS.\n       \\<lbrakk>vs \\<in> aforms_err e VS;\n        approx_slp p [] VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp [] vs \\<in> aforms_err e X\n 2. \\<And>a ra X vs VS.\n       \\<lbrakk>\\<And>X vs VS.\n                   \\<lbrakk>vs \\<in> aforms_err e VS;\n                    approx_slp p ra VS = Some X\\<rbrakk>\n                   \\<Longrightarrow> interpret_slp ra vs\n                                     \\<in> aforms_err e X;\n        vs \\<in> aforms_err e VS; approx_slp p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp (a # ra) vs \\<in> aforms_err e X", "from approx_floatarith_Elem[OF a e Cons.prems(1)]"], ["proof (chain)\npicking this:\n  interpret_floatarith ra vs \\<in> aform_err e a", "have \"interpret_floatarith ra vs \\<in> aform_err e a\""], ["proof (prove)\nusing this:\n  interpret_floatarith ra vs \\<in> aform_err e a\n\ngoal (1 subgoal):\n 1. interpret_floatarith ra vs \\<in> aform_err e a", "by auto"], ["proof (state)\nthis:\n  interpret_floatarith ra vs \\<in> aform_err e a\n\ngoal (2 subgoals):\n 1. \\<And>X vs VS.\n       \\<lbrakk>vs \\<in> aforms_err e VS;\n        approx_slp p [] VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp [] vs \\<in> aforms_err e X\n 2. \\<And>a ra X vs VS.\n       \\<lbrakk>\\<And>X vs VS.\n                   \\<lbrakk>vs \\<in> aforms_err e VS;\n                    approx_slp p ra VS = Some X\\<rbrakk>\n                   \\<Longrightarrow> interpret_slp ra vs\n                                     \\<in> aforms_err e X;\n        vs \\<in> aforms_err e VS; approx_slp p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp (a # ra) vs \\<in> aforms_err e X", "then"], ["proof (chain)\npicking this:\n  interpret_floatarith ra vs \\<in> aform_err e a", "have 1: \"interpret_floatarith ra vs#vs \\<in> aforms_err e (a#VS)\""], ["proof (prove)\nusing this:\n  interpret_floatarith ra vs \\<in> aform_err e a\n\ngoal (1 subgoal):\n 1. interpret_floatarith ra vs # vs \\<in> aforms_err e (a # VS)", "unfolding mem_aforms_err_Cons_iff"], ["proof (prove)\nusing this:\n  interpret_floatarith ra vs \\<in> aform_err e a\n\ngoal (1 subgoal):\n 1. interpret_floatarith ra vs \\<in> aform_err e a \\<and>\n    vs \\<in> aforms_err e VS", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  interpret_floatarith ra vs \\<in> aform_err e a\n  vs \\<in> aforms_err e VS\n\ngoal (1 subgoal):\n 1. interpret_floatarith ra vs \\<in> aform_err e a \\<and>\n    vs \\<in> aforms_err e VS", "by auto"], ["proof (state)\nthis:\n  interpret_floatarith ra vs # vs \\<in> aforms_err e (a # VS)\n\ngoal (2 subgoals):\n 1. \\<And>X vs VS.\n       \\<lbrakk>vs \\<in> aforms_err e VS;\n        approx_slp p [] VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp [] vs \\<in> aforms_err e X\n 2. \\<And>a ra X vs VS.\n       \\<lbrakk>\\<And>X vs VS.\n                   \\<lbrakk>vs \\<in> aforms_err e VS;\n                    approx_slp p ra VS = Some X\\<rbrakk>\n                   \\<Longrightarrow> interpret_slp ra vs\n                                     \\<in> aforms_err e X;\n        vs \\<in> aforms_err e VS; approx_slp p (a # ra) VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp (a # ra) vs \\<in> aforms_err e X", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_slp (ra # ras) vs \\<in> aforms_err e X", "by (auto intro!: Cons.IH 1 r)"], ["proof (state)\nthis:\n  interpret_slp (ra # ras) vs \\<in> aforms_err e X\n\ngoal (1 subgoal):\n 1. \\<And>X vs VS.\n       \\<lbrakk>vs \\<in> aforms_err e VS;\n        approx_slp p [] VS = Some X\\<rbrakk>\n       \\<Longrightarrow> interpret_slp [] vs \\<in> aforms_err e X", "qed auto"], ["", "definition \"approx_slp_outer p n slp XS =\n  do {\n    let d = degree_aforms XS;\n    let XSe = (map (\\<lambda>x. (x, 0)) XS);\n    rs \\<leftarrow> approx_slp p slp XSe;\n    let rs' = take n rs;\n    let d' = max d (degree_aforms_err rs');\n    Some (aforms_err_to_aforms d' rs')\n  }\""], ["", "lemma take_in_listsetI: \"xs \\<in> listset XS \\<Longrightarrow> take n xs \\<in> listset (take n XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> listset XS \\<Longrightarrow>\n    take n xs \\<in> listset (take n XS)", "by (induction XS arbitrary: xs n) (auto simp: take_Cons listset_Cons_mem_conv set_Cons_def split: nat.splits)"], ["", "lemma take_in_aforms_errI: \"take n xs \\<in> aforms_err e (take n XS)\"\n  if \"xs \\<in> aforms_err e XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n xs \\<in> aforms_err e (take n XS)", "using that"], ["proof (prove)\nusing this:\n  xs \\<in> aforms_err e XS\n\ngoal (1 subgoal):\n 1. take n xs \\<in> aforms_err e (take n XS)", "by (auto simp: aforms_err_def take_map[symmetric] intro!: take_in_listsetI)"], ["", "theorem approx_slp_outer:\n  assumes \"approx_slp_outer p n slp XS = Some RS\"\n  assumes slp: \"slp = slp_of_fas fas\" \"n = length fas\"\n  assumes \"xs \\<in> Joints XS\"\n  shows \"interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "from assms"], ["proof (chain)\npicking this:\n  approx_slp_outer p n slp XS = Some RS\n  slp = slp_of_fas fas\n  n = length fas\n  xs \\<in> Joints XS", "obtain d XSe rs rs' d' where\n    d: \"d = degree_aforms XS\"\n    and XSe: \"XSe = (map (\\<lambda>x. (x, 0)) XS)\"\n    and rs: \"approx_slp p (slp_of_fas fas) XSe = Some rs\"\n    and rs': \"rs' = take (length fas) rs\"\n    and d': \"d' = max d (degree_aforms_err rs')\"\n    and RS: \"aforms_err_to_aforms d' rs' = RS\""], ["proof (prove)\nusing this:\n  approx_slp_outer p n slp XS = Some RS\n  slp = slp_of_fas fas\n  n = length fas\n  xs \\<in> Joints XS\n\ngoal (1 subgoal):\n 1. (\\<And>d XSe rs rs' d'.\n        \\<lbrakk>d = degree_aforms XS; XSe = map (\\<lambda>x. (x, 0)) XS;\n         approx_slp p (slp_of_fas fas) XSe = Some rs;\n         rs' = take (length fas) rs; d' = max d (degree_aforms_err rs');\n         aforms_err_to_aforms d' rs' = RS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: approx_slp_outer_def Let_def bind_eq_Some_conv)"], ["proof (state)\nthis:\n  d = degree_aforms XS\n  XSe = map (\\<lambda>x. (x, 0)) XS\n  approx_slp p (slp_of_fas fas) XSe = Some rs\n  rs' = take (length fas) rs\n  d' = max d (degree_aforms_err rs')\n  aforms_err_to_aforms d' rs' = RS\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "have abbd: \"(a, b) \\<in> set XS \\<Longrightarrow> degree b \\<le> degree_aforms XS\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set XS \\<Longrightarrow> degree b \\<le> degree_aforms XS", "apply (rule degrees_leD[OF order_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set XS \\<Longrightarrow> b \\<in> set (map snd XS)", "by force"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> set XS \\<Longrightarrow> degree ?b \\<le> degree_aforms XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "from d' d"], ["proof (chain)\npicking this:\n  d' = max d (degree_aforms_err rs')\n  d = degree_aforms XS", "have i_less: \"(a, b) \\<in> set XS \\<Longrightarrow> i < degree b \\<Longrightarrow> i < min d d'\" for i a b"], ["proof (prove)\nusing this:\n  d' = max d (degree_aforms_err rs')\n  d = degree_aforms XS\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> set XS; i < degree b\\<rbrakk>\n    \\<Longrightarrow> i < min d d'", "by (auto dest!: abbd)"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?b) \\<in> set XS; ?i < degree ?b\\<rbrakk>\n  \\<Longrightarrow> ?i < min d d'\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "from assms"], ["proof (chain)\npicking this:\n  approx_slp_outer p n slp XS = Some RS\n  slp = slp_of_fas fas\n  n = length fas\n  xs \\<in> Joints XS", "obtain e' where vs: \"xs = (map (aform_val e') XS)\" and e': \"e' \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  approx_slp_outer p n slp XS = Some RS\n  slp = slp_of_fas fas\n  n = length fas\n  xs \\<in> Joints XS\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>xs = map (aform_val e') XS;\n         e' \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Joints_def valuate_def)"], ["proof (state)\nthis:\n  xs = map (aform_val e') XS\n  e' \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "from d"], ["proof (chain)\npicking this:\n  d = degree_aforms XS", "have d: \"V \\<in> set XS \\<Longrightarrow> degree_aform V \\<le> d\" for V"], ["proof (prove)\nusing this:\n  d = degree_aforms XS\n\ngoal (1 subgoal):\n 1. V \\<in> set XS \\<Longrightarrow> degree_aform V \\<le> d", "by (auto intro!: degrees_leD)"], ["proof (state)\nthis:\n  ?V \\<in> set XS \\<Longrightarrow> degree_aform ?V \\<le> d\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "have xs_XSe: \"xs \\<in> aforms_err e' XSe\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> aforms_err e' XSe", "by (auto simp: vs aforms_err_def XSe o_def aform_err_def)"], ["proof (state)\nthis:\n  xs \\<in> aforms_err e' XSe\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "from approx_slp_Elem[OF e' xs_XSe rs]"], ["proof (chain)\npicking this:\n  interpret_slp (slp_of_fas fas) xs \\<in> aforms_err e' rs", "have aforms_err: \"interpret_slp (slp_of_fas fas) xs \\<in> aforms_err e' rs\""], ["proof (prove)\nusing this:\n  interpret_slp (slp_of_fas fas) xs \\<in> aforms_err e' rs\n\ngoal (1 subgoal):\n 1. interpret_slp (slp_of_fas fas) xs \\<in> aforms_err e' rs", "."], ["proof (state)\nthis:\n  interpret_slp (slp_of_fas fas) xs \\<in> aforms_err e' rs\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "have \"interpret_floatariths fas xs = take (length fas) (interpret_slp (slp_of_fas fas) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs =\n    take (length fas) (interpret_slp (slp_of_fas fas) xs)", "using assms"], ["proof (prove)\nusing this:\n  approx_slp_outer p n slp XS = Some RS\n  slp = slp_of_fas fas\n  n = length fas\n  xs \\<in> Joints XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs =\n    take (length fas) (interpret_slp (slp_of_fas fas) xs)", "by (simp add: slp_of_fas)"], ["proof (state)\nthis:\n  interpret_floatariths fas xs =\n  take (length fas) (interpret_slp (slp_of_fas fas) xs)\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "also"], ["proof (state)\nthis:\n  interpret_floatariths fas xs =\n  take (length fas) (interpret_slp (slp_of_fas fas) xs)\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "from aforms_err"], ["proof (chain)\npicking this:\n  interpret_slp (slp_of_fas fas) xs \\<in> aforms_err e' rs", "have \"take (length fas) (interpret_slp (slp_of_fas fas) xs) \\<in> aforms_err e' rs'\""], ["proof (prove)\nusing this:\n  interpret_slp (slp_of_fas fas) xs \\<in> aforms_err e' rs\n\ngoal (1 subgoal):\n 1. take (length fas) (interpret_slp (slp_of_fas fas) xs)\n    \\<in> aforms_err e' rs'", "unfolding rs'"], ["proof (prove)\nusing this:\n  interpret_slp (slp_of_fas fas) xs \\<in> aforms_err e' rs\n\ngoal (1 subgoal):\n 1. take (length fas) (interpret_slp (slp_of_fas fas) xs)\n    \\<in> aforms_err e' (take (length fas) rs)", "by (auto simp: take_map intro!: take_in_aforms_errI)"], ["proof (state)\nthis:\n  take (length fas) (interpret_slp (slp_of_fas fas) xs)\n  \\<in> aforms_err e' rs'\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "finally"], ["proof (chain)\npicking this:\n  interpret_floatariths fas xs \\<in> aforms_err e' rs'", "have ier: \"interpret_floatariths fas xs \\<in> aforms_err e' rs'\""], ["proof (prove)\nusing this:\n  interpret_floatariths fas xs \\<in> aforms_err e' rs'\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs \\<in> aforms_err e' rs'", "."], ["proof (state)\nthis:\n  interpret_floatariths fas xs \\<in> aforms_err e' rs'\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "have \"degree_aforms_err rs' \\<le> d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aforms_err rs' \\<le> d'", "using d'"], ["proof (prove)\nusing this:\n  d' = max d (degree_aforms_err rs')\n\ngoal (1 subgoal):\n 1. degree_aforms_err rs' \\<le> d'", "by auto"], ["proof (state)\nthis:\n  degree_aforms_err rs' \\<le> d'\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "from aforms_err_to_aformsE[OF ier this e']"], ["proof (chain)\npicking this:\n  (\\<And>e'a.\n      \\<lbrakk>interpret_floatariths fas xs =\n               aform_vals e'a (aforms_err_to_aforms d' rs');\n       e'a \\<in> UNIV \\<rightarrow> {- 1..1};\n       \\<And>i. i < d' \\<Longrightarrow> e'a i = e' i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e where\n    \"interpret_floatariths fas xs = aform_vals e RS\"\n    and e: \"e \\<in> UNIV \\<rightarrow> {- 1..1}\" \"\\<And>i. i < d' \\<Longrightarrow> e i = e' i\""], ["proof (prove)\nusing this:\n  (\\<And>e'a.\n      \\<lbrakk>interpret_floatariths fas xs =\n               aform_vals e'a (aforms_err_to_aforms d' rs');\n       e'a \\<in> UNIV \\<rightarrow> {- 1..1};\n       \\<And>i. i < d' \\<Longrightarrow> e'a i = e' i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>interpret_floatariths fas xs = aform_vals e RS;\n         e \\<in> UNIV \\<rightarrow> {- 1..1};\n         \\<And>i. i < d' \\<Longrightarrow> e i = e' i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding RS"], ["proof (prove)\nusing this:\n  (\\<And>e'a.\n      \\<lbrakk>interpret_floatariths fas xs = aform_vals e'a RS;\n       e'a \\<in> UNIV \\<rightarrow> {- 1..1};\n       \\<And>i. i < d' \\<Longrightarrow> e'a i = e' i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>interpret_floatariths fas xs = aform_vals e RS;\n         e \\<in> UNIV \\<rightarrow> {- 1..1};\n         \\<And>i. i < d' \\<Longrightarrow> e i = e' i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: )"], ["proof (state)\nthis:\n  interpret_floatariths fas xs = aform_vals e RS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d' \\<Longrightarrow> e ?i = e' ?i\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "moreover"], ["proof (state)\nthis:\n  interpret_floatariths fas xs = aform_vals e RS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d' \\<Longrightarrow> e ?i = e' ?i\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "from e"], ["proof (chain)\npicking this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d' \\<Longrightarrow> e ?i = e' ?i", "have e'_eq: \"e' i = e i\" if \"i < min d d'\" for i"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d' \\<Longrightarrow> e ?i = e' ?i\n\ngoal (1 subgoal):\n 1. e' i = e i", "using that"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d' \\<Longrightarrow> e ?i = e' ?i\n  i < min d d'\n\ngoal (1 subgoal):\n 1. e' i = e i", "by (auto simp: min_def split: if_splits)"], ["proof (state)\nthis:\n  ?i < min d d' \\<Longrightarrow> e' ?i = e ?i\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "then"], ["proof (chain)\npicking this:\n  ?i < min d d' \\<Longrightarrow> e' ?i = e ?i", "have \"xs = aform_vals e XS\""], ["proof (prove)\nusing this:\n  ?i < min d d' \\<Longrightarrow> e' ?i = e ?i\n\ngoal (1 subgoal):\n 1. xs = aform_vals e XS", "by (auto simp: vs aform_vals_def aform_val_def intro!: pdevs_val_degree_cong e'_eq i_less)"], ["proof (state)\nthis:\n  xs = aform_vals e XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "ultimately"], ["proof (chain)\npicking this:\n  interpret_floatariths fas xs = aform_vals e RS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d' \\<Longrightarrow> e ?i = e' ?i\n  xs = aform_vals e XS", "show ?thesis"], ["proof (prove)\nusing this:\n  interpret_floatariths fas xs = aform_vals e RS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d' \\<Longrightarrow> e ?i = e' ?i\n  xs = aform_vals e XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "using e(1)"], ["proof (prove)\nusing this:\n  interpret_floatariths fas xs = aform_vals e RS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ?i < d' \\<Longrightarrow> e ?i = e' ?i\n  xs = aform_vals e XS\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "by (auto simp: Joints_def valuate_def aform_vals_def intro!: image_eqI[where x=e])"], ["proof (state)\nthis:\n  interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem approx_slp_outer_plain:\n  assumes \"approx_slp_outer p n slp XS = Some RS\"\n  assumes slp: \"slp = slp_of_fas fas\" \"n = length fas\"\n  assumes \"xs \\<in> Joints XS\"\n  shows \"interpret_floatariths fas xs \\<in> Joints RS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs \\<in> Joints RS", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs \\<in> Joints RS", "have \"length fas = length RS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length fas = length RS", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length fas = length RS", "have f1: \"length xs = length XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length XS", "using Joints_imp_length_eq assms(4)"], ["proof (prove)\nusing this:\n  ?xs \\<in> Joints ?XS \\<Longrightarrow> length ?xs = length ?XS\n  xs \\<in> Joints XS\n\ngoal (1 subgoal):\n 1. length xs = length XS", "by blast"], ["proof (state)\nthis:\n  length xs = length XS\n\ngoal (1 subgoal):\n 1. length fas = length RS", "have \"interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "using approx_slp_outer assms(1) assms(2) assms(3) assms(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>approx_slp_outer ?p ?n ?slp ?XS = Some ?RS;\n   ?slp = slp_of_fas ?fas; ?n = length ?fas; ?xs \\<in> Joints ?XS\\<rbrakk>\n  \\<Longrightarrow> interpret_floatariths ?fas ?xs @ ?xs\n                    \\<in> Joints (?RS @ ?XS)\n  approx_slp_outer p n slp XS = Some RS\n  slp = slp_of_fas fas\n  n = length fas\n  xs \\<in> Joints XS\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "by blast"], ["proof (state)\nthis:\n  interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)\n\ngoal (1 subgoal):\n 1. length fas = length RS", "then"], ["proof (chain)\npicking this:\n  interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)", "show ?thesis"], ["proof (prove)\nusing this:\n  interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)\n\ngoal (1 subgoal):\n 1. length fas = length RS", "using f1 Joints_imp_length_eq"], ["proof (prove)\nusing this:\n  interpret_floatariths fas xs @ xs \\<in> Joints (RS @ XS)\n  length xs = length XS\n  ?xs \\<in> Joints ?XS \\<Longrightarrow> length ?xs = length ?XS\n\ngoal (1 subgoal):\n 1. length fas = length RS", "by fastforce"], ["proof (state)\nthis:\n  length fas = length RS\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length fas = length RS\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs \\<in> Joints RS", "with Joints_appendD2[OF approx_slp_outer[OF assms]]"], ["proof (chain)\npicking this:\n  length (interpret_floatariths fas xs) = length RS \\<Longrightarrow>\n  interpret_floatariths fas xs \\<in> Joints RS\n  length fas = length RS", "show ?thesis"], ["proof (prove)\nusing this:\n  length (interpret_floatariths fas xs) = length RS \\<Longrightarrow>\n  interpret_floatariths fas xs \\<in> Joints RS\n  length fas = length RS\n\ngoal (1 subgoal):\n 1. interpret_floatariths fas xs \\<in> Joints RS", "by simp"], ["proof (state)\nthis:\n  interpret_floatariths fas xs \\<in> Joints RS\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}