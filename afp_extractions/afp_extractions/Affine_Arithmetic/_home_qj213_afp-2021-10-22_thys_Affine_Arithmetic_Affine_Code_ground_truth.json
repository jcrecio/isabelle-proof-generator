{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Affine_Code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma finite_dom_map_of_slist[intro, simp]: \"finite (dom (map_of_slist xs))\"", "lemma nonzeros_Pdevs_raw_subset: \"{i. Pdevs_raw xs i \\<noteq> 0} \\<subseteq> dom (map_of xs)\"", "lemma degree_list_eq_zeroD:\n  assumes \"degree_list xs = 0\"\n  shows \"the_default 0 (map_of xs i) = 0\"", "lemma degree_slist_eq_zeroD: \"degree_slist xs = 0 \\<Longrightarrow> degree (Pdevs xs) = 0\"", "lemma degree_slist_eq_SucD: \"degree_slist xs = Suc n \\<Longrightarrow> pdevs_apply (Pdevs xs) n \\<noteq> 0\"", "lemma degree_slist_zero:\n  \"degree_slist xs = n \\<Longrightarrow> n \\<le> j \\<Longrightarrow> pdevs_apply (Pdevs xs) j = 0\"", "lemma compute_degree[code]: \"degree (Pdevs xs) = degree_slist xs\"", "lemma set_binop_elemD1:\n  \"(a, b) \\<in> set (binop f z1 z2 xs ys) \\<Longrightarrow> (a \\<in> set (map fst xs) \\<or> a \\<in> set (map fst ys))\"", "lemma set_binop_elemD2:\n  \"(a, b) \\<in> set (binop f z1 z2 xs ys) \\<Longrightarrow>\n    (\\<exists>x\\<in>set (map snd xs). b = f x z2) \\<or>\n    (\\<exists>y\\<in>set (map snd ys). b = f z1 y) \\<or>\n    (\\<exists>x\\<in>set (map snd xs). \\<exists>y\\<in>set (map snd ys). b = f x y)\"", "lemma rsorted_binop:\n  fixes xs::\"('a::linorder * 'b) list\" and ys::\"('a::linorder * 'c) list\"\n  assumes \"rsorted ((map fst xs))\"\n  assumes \"rsorted ((map fst ys))\"\n  shows \"rsorted ((map fst (binop f z1 z2 xs ys)))\"", "lemma distinct_binop:\n  fixes xs::\"('a::linorder * 'b) list\" and ys::\"('a::linorder * 'c) list\"\n  assumes \"distinct (map fst xs)\"\n  assumes \"distinct (map fst ys)\"\n  assumes \"rsorted ((map fst xs))\"\n  assumes \"rsorted ((map fst ys))\"\n  shows \"distinct (map fst (binop f z1 z2 xs ys))\"", "lemma binop_plus:\n  fixes b::\"(nat * 'a::euclidean_space) list\"\n  shows\n    \"(\\<Sum>(i, y)\\<leftarrow>binop (+) 0 0 b ba. e i *\\<^sub>R y) = (\\<Sum>(i, y)\\<leftarrow>b. e i *\\<^sub>R y) + (\\<Sum>(i, y)\\<leftarrow>ba. e i *\\<^sub>R y)\"", "lemma binop_compose:\n  \"binop (\\<lambda>x y. f (g x y)) z1 z2 xs ys = map (apsnd f) (binop g z1 z2 xs ys)\"", "lemma linear_cmul_left[intro, simp]: \"linear ((*) x::real \\<Rightarrow> _)\"", "lemma length_merge_sorted_eq:\n  \"length (binop f z1 z2 xs ys) = length (binop g y1 y2 xs ys)\"", "lemma map_of_binop[simp]: \"rsorted (map fst xs) \\<Longrightarrow> rsorted (map fst ys) \\<Longrightarrow>\n  distinct (map fst xs) \\<Longrightarrow> distinct (map fst ys) \\<Longrightarrow>\n  map_of (binop f z1 z2 xs ys) i =\n  (case map_of xs i of\n    Some x \\<Rightarrow> Some (f x (case map_of ys i of Some x \\<Rightarrow> x | None \\<Rightarrow> z2))\n  | None \\<Rightarrow> (case map_of ys i of Some y \\<Rightarrow> Some (f z1 y) | None \\<Rightarrow> None))\"", "lemma pdevs_apply_Pdevs_add_slist[simp]:\n  fixes xs ys::\"(nat, 'a::monoid_add) slist\"\n  shows \"pdevs_apply (Pdevs (add_slist xs ys)) i =\n    pdevs_apply (Pdevs xs) i + pdevs_apply (Pdevs ys) i\"", "lemma compute_add_pdevs[code]: \"add_pdevs (Pdevs xs) (Pdevs ys) = Pdevs (add_slist xs ys)\"", "lemma pdevs_apply_Pdevs_prod_slist[simp]:\n  \"pdevs_apply (Pdevs (prod_slist xs ys)) i = (pdevs_apply (Pdevs xs) i, pdevs_apply (Pdevs ys) i)\"", "lemma compute_prod_of_pdevs[code]: \"prod_of_pdevs (Pdevs xs) (Pdevs ys) = Pdevs (prod_slist xs ys)\"", "lemma finite_set_slist[intro, simp]: \"finite (set_slist xs)\"", "lemma compute_pdevs_domain[code]: \"pdevs_domain (Pdevs xs) = set (map fst (list_of_slist xs))\"", "lemma sort_rev_eq_sort: \"distinct xs \\<Longrightarrow> sort (rev xs) = sort xs\"", "lemma compute_list_of_pdevs[code]: \"list_of_pdevs (Pdevs xs) = list_of_slist xs\"", "lemma compute_pdevs_apply[code]: \"pdevs_apply (Pdevs x) i = slist_apply x i\"", "lemma tdev_slist_sum: \"tdev_slist xs = sum (abs \\<circ> snd) (set_slist xs)\"", "lemma pdevs_apply_set_slist: \"x \\<in> set_slist xs \\<Longrightarrow> snd x = pdevs_apply (Pdevs xs) (fst x)\"", "lemma\n  tdev_list_eq_zeroI:\n  shows \"(\\<And>i. pdevs_apply (Pdevs xs) i = 0) \\<Longrightarrow> tdev_slist xs = 0\"", "lemma inj_on_fst_set_slist: \"inj_on fst (set_slist xs)\"", "lemma pdevs_apply_Pdevs_eq_0:\n  \"pdevs_apply (Pdevs xs) i = 0 \\<longleftrightarrow> ((\\<forall>x. (i, x) \\<in> set_slist xs \\<longrightarrow> x = 0))\"", "lemma compute_tdev[code]: \"tdev (Pdevs xs) = tdev_slist xs\"", "lemma dropWhile_rsorted_eq_filter:\n  \"rsorted (map fst xs) \\<Longrightarrow> dropWhile (\\<lambda>(i, x). i \\<ge> (m::nat)) xs = filter (\\<lambda>(i, x). i < m) xs\"\n  (is \"_ \\<Longrightarrow> ?lhs xs = ?rhs xs\")", "lemma slist_apply_msum_slist:\n  \"slist_apply (msum_slist m xs ys) i =\n    (if i < m then slist_apply xs i else slist_apply ys (i - m))\"", "lemma pdevs_apply_msum_slist:\n  \"pdevs_apply (Pdevs (msum_slist m xs ys)) i =\n    (if i < m then pdevs_apply (Pdevs xs) i else pdevs_apply (Pdevs ys) (i - m))\"", "lemma compute_msum_pdevs[code]: \"msum_pdevs m (Pdevs xs) (Pdevs ys) = Pdevs (msum_slist m xs ys)\"", "lemma pdevs_apply_map_slist:\n  \"f 0 = 0 \\<Longrightarrow> pdevs_apply (Pdevs (map_slist f xs)) i = f (pdevs_apply (Pdevs xs) i)\"", "lemma compute_scaleR_pdves[code]: \"scaleR_pdevs r (Pdevs xs) = Pdevs (map_slist (\\<lambda>x. r *\\<^sub>R x) xs)\"\n  and compute_pdevs_scaleR[code]: \"pdevs_scaleR (Pdevs rs) x = Pdevs (map_slist (\\<lambda>r. r *\\<^sub>R x) rs)\"\n  and compute_uminus_pdevs[code]: \"uminus_pdevs (Pdevs xs) = Pdevs (map_slist (\\<lambda>x. - x) xs)\"\n  and compute_abs_pdevs[code]: \"abs_pdevs (Pdevs xs) = Pdevs (map_slist abs xs)\"\n  and compute_pdevs_inner[code]: \"pdevs_inner (Pdevs xs) b = Pdevs (map_slist (\\<lambda>x. x \\<bullet> b) xs)\"\n  and compute_pdevs_inner2[code]:\n    \"pdevs_inner2 (Pdevs xs) b c = Pdevs (map_slist (\\<lambda>x. (x \\<bullet> b, x \\<bullet> c)) xs)\"\n  and compute_inner_scaleR_pdevs[code]:\n    \"inner_scaleR_pdevs x (Pdevs ys) = Pdevs (map_slist (\\<lambda>y. (x \\<bullet> y) *\\<^sub>R y) ys)\"\n  and compute_trunc_pdevs[code]:\n    \"trunc_pdevs p (Pdevs xs) = Pdevs (map_slist (\\<lambda>x. eucl_truncate_down p x) xs)\"\n  and compute_trunc_err_pdevs[code]:\n    \"trunc_err_pdevs p (Pdevs xs) = Pdevs (map_slist (\\<lambda>x. eucl_truncate_down p x - x) xs)\"", "lemma slist_apply_filter_slist: \"slist_apply (filter_slist P xs) i =\n  (if P i (slist_apply xs i) then slist_apply xs i else 0)\"", "lemma pdevs_apply_filter_slist: \"pdevs_apply (Pdevs (filter_slist P xs)) i =\n  (if P i (pdevs_apply (Pdevs xs) i) then pdevs_apply (Pdevs xs) i else 0)\"", "lemma compute_filter_pdevs[code]: \"filter_pdevs P (Pdevs xs) = Pdevs (filter_slist P xs)\"", "lemma compute_zero_pdevs[code]: \"zero_pdevs = Pdevs (zero_slist)\"", "lemma\n  map_of_rev_zip_upto_length_eq_nth:\n  assumes \"i < length B\" \"d = length B\"\n  shows \"(map_of (rev (zip [0..<d] B)) i) = Some (B ! i)\"", "lemma\n  map_of_rev_zip_upto_length_eq_None:\n  assumes \"\\<not>i < length B\"\n  assumes \"d = length B\"\n  shows \"(map_of (rev (zip [0..<d] B)) i) = None\"", "lemma pdevs_apply_One_slist:\n  \"pdevs_apply (Pdevs One_slist) i =\n    (if i < length (Basis_list::'a::executable_euclidean_space list)\n    then (Basis_list::'a list) ! i\n    else 0)\"", "lemma compute_One_pdevs[code]: \"One_pdevs = Pdevs One_slist\"", "lemma compute_coord_pdevs[code]: \"coord_pdevs i = Pdevs (coord_slist i)\"", "lemma map_of_update_list[simp]: \"map_of (update_list n x ys) = (map_of ys)(n:=Some x)\"", "lemma in_set_update_listD:\n  assumes \"y \\<in> set (update_list n x ys)\"\n  shows \"y = (n, x) \\<or> (y \\<in> set ys)\"", "lemma in_set_update_listI:\n  \"y = (n, x) \\<or> (fst y \\<noteq> n \\<and> y \\<in> set ys) \\<Longrightarrow> y \\<in> set (update_list n x ys)\"", "lemma in_set_update_list: \"(n, x) \\<in> set (update_list n x xs)\"", "lemma overwrite_update_list: \"(a, b) \\<in> set xs \\<Longrightarrow> (a, b) \\<notin> set (update_list n x xs) \\<Longrightarrow> a = n\"", "lemma insert_update_list:\n  \"distinct (map fst xs) \\<Longrightarrow> rsorted (map fst xs) \\<Longrightarrow> (a, b) \\<in> set (update_list a x xs) \\<Longrightarrow> b = x\"", "lemma set_update_list_eq: \"distinct (map fst xs) \\<Longrightarrow> rsorted (map fst xs) \\<Longrightarrow>\n    set (update_list n x xs) = insert (n, x) (set xs - {x. fst x = n})\"", "lemma pdevs_apply_update_slist: \"pdevs_apply (Pdevs (update_slist n x xs)) i =\n  (if i = n then x else pdevs_apply (Pdevs xs) i)\"", "lemma compute_pdev_upd[code]: \"pdev_upd (Pdevs xs) n x = Pdevs (update_slist n x xs)\"", "lemma Pdevs_raw_Cons:\n  \"Pdevs_raw ((a, b) # xs) = (\\<lambda>i. if i = a then b else Pdevs_raw xs i)\"", "lemma zeros_aux: \"- (\\<lambda>i. if i = a then b else Pdevs_raw xs i) -` {0} \\<subseteq>\n  - Pdevs_raw xs -` {0} \\<union> {a}\"", "lemma compute_tdev'[code]:\n  \"tdev' p (Pdevs xs) = fold_slist (\\<lambda>a b. eucl_truncate_up p (\\<bar>a\\<bar> + b)) xs 0\"", "lemma slist_apply_list_of_slist_eq: \"slist_apply a i = the_default 0 (map_of (list_of_slist a) i)\"", "lemma compute_equal_pdevs[code]:\n  \"equal_class.equal (Pdevs a) (Pdevs b) \\<longleftrightarrow> (list_of_slist a) = (list_of_slist b)\"", "lemma slist_apply_slist_of_list:\n  \"slist_apply (slist_of_list xs) i = (if i < length xs then xs ! i else 0)\"", "lemma compute_pdevs_of_list[code]: \"pdevs_of_list xs = Pdevs (slist_of_list xs)\"", "lemma [code_post]: \"Abs_slist = slist\"", "lemma [code]: \"slist = (\\<lambda>xs.\n  (if distinct (map fst xs) \\<and> rsorted (map fst xs) then abs_slist_if xs else Code.abort (STR '''') (\\<lambda>_. slist xs)))\"", "lemma Pdevs_raw_map: \"f 0 = 0 \\<Longrightarrow> Pdevs_raw (map (\\<lambda>(i, x). (i, f x)) xs) i = f (Pdevs_raw xs i)\"", "lemma compute_nlex_pdevs[code]: \"nlex_pdevs (Pdevs x) = Pdevs (nlex_slist x)\""], "translations": [["", "lemma finite_dom_map_of_slist[intro, simp]: \"finite (dom (map_of_slist xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (map_of_slist xs))", "by transfer (auto simp: finite_dom_map_of)"], ["", "abbreviation \"the_default a x \\<equiv> (case x of None \\<Rightarrow> a | Some b \\<Rightarrow> b)\""], ["", "definition \"Pdevs_raw xs i = the_default 0 (map_of xs i)\""], ["", "lemma nonzeros_Pdevs_raw_subset: \"{i. Pdevs_raw xs i \\<noteq> 0} \\<subseteq> dom (map_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. Pdevs_raw xs i \\<noteq> (0::'b)} \\<subseteq> dom (map_of xs)", "unfolding Pdevs_raw_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. the_default (0::'b) (map_of xs i) \\<noteq> (0::'b)}\n    \\<subseteq> dom (map_of xs)", "by transfer (auto simp: Pdevs_raw_def split: option.split_asm)"], ["", "lift_definition Pdevs::\"(nat, 'a::zero) slist \\<Rightarrow> 'a pdevs\"\n  is Pdevs_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       distinct (map fst list) \\<and>\n       sorted (rev (map fst list)) \\<Longrightarrow>\n       finite {i. Pdevs_raw list i \\<noteq> (0::'a)}", "by (rule finite_subset[OF nonzeros_Pdevs_raw_subset]) (simp add: finite_dom_map_of)"], ["", "code_datatype Pdevs"], ["", "subsection \\<open>Degree\\<close>"], ["", "primrec degree_list::\"(nat \\<times> 'a::zero) list \\<Rightarrow> nat\" where\n  \"degree_list [] = 0\"\n| \"degree_list (x#xs) = (if snd x = 0 then degree_list xs else Suc (fst x))\""], ["", "lift_definition degree_slist::\"(nat, 'a::zero) slist \\<Rightarrow> nat\" is degree_list"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma degree_list_eq_zeroD:\n  assumes \"degree_list xs = 0\"\n  shows \"the_default 0 (map_of xs i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_default (0::'a) (map_of xs i) = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  degree_list xs = 0\n\ngoal (1 subgoal):\n 1. the_default (0::'a) (map_of xs i) = (0::'a)", "by (induct xs) (auto simp: Pdevs_raw_def sorted_append split: if_split_asm)"], ["", "lemma degree_slist_eq_zeroD: \"degree_slist xs = 0 \\<Longrightarrow> degree (Pdevs xs) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_slist xs = 0 \\<Longrightarrow> degree (Pdevs xs) = 0", "unfolding degree_eq_Suc_max"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_slist xs = 0 \\<Longrightarrow>\n    (if \\<forall>i. pdevs_apply (Pdevs xs) i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply (Pdevs xs) i \\<noteq> (0::'a)})) =\n    0", "by transfer (auto dest: degree_list_eq_zeroD simp: Pdevs_raw_def)"], ["", "lemma degree_slist_eq_SucD: \"degree_slist xs = Suc n \\<Longrightarrow> pdevs_apply (Pdevs xs) n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_slist xs = Suc n \\<Longrightarrow>\n    pdevs_apply (Pdevs xs) n \\<noteq> (0::'a)", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>distinct (map fst xs) \\<and> sorted (rev (map fst xs));\n        degree_list xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> Pdevs_raw xs n \\<noteq> (0::'a)", "case (1 xs n)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<and> sorted (rev (map fst xs))\n  degree_list xs = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>distinct (map fst xs) \\<and> sorted (rev (map fst xs));\n        degree_list xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> Pdevs_raw xs n \\<noteq> (0::'a)", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst xs) \\<and> sorted (rev (map fst xs))\n  degree_list xs = Suc n\n\ngoal (1 subgoal):\n 1. Pdevs_raw xs n \\<noteq> (0::'a)", "by (induct xs)\n      (auto simp: Pdevs_raw_def sorted_append map_of_eq_None_iff[symmetric]\n        split: if_split_asm option.split_asm)"], ["proof (state)\nthis:\n  Pdevs_raw xs n \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_slist_zero:\n  \"degree_slist xs = n \\<Longrightarrow> n \\<le> j \\<Longrightarrow> pdevs_apply (Pdevs xs) j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>degree_slist xs = n; n \\<le> j\\<rbrakk>\n    \\<Longrightarrow> pdevs_apply (Pdevs xs) j = (0::'a)", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n j.\n       \\<lbrakk>distinct (map fst xs) \\<and> sorted (rev (map fst xs));\n        degree_list xs = n; n \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Pdevs_raw xs j = (0::'a)", "case (1 xs n j)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<and> sorted (rev (map fst xs))\n  degree_list xs = n\n  n \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>xs n j.\n       \\<lbrakk>distinct (map fst xs) \\<and> sorted (rev (map fst xs));\n        degree_list xs = n; n \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Pdevs_raw xs j = (0::'a)", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst xs) \\<and> sorted (rev (map fst xs))\n  degree_list xs = n\n  n \\<le> j\n\ngoal (1 subgoal):\n 1. Pdevs_raw xs j = (0::'a)", "by (induct xs)\n      (auto simp: Pdevs_raw_def sorted_append split: if_split_asm option.split)"], ["proof (state)\nthis:\n  Pdevs_raw xs j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compute_degree[code]: \"degree (Pdevs xs) = degree_slist xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Pdevs xs) = degree_slist xs", "by (cases \"degree_slist xs\")\n    (auto dest: degree_slist_eq_zeroD degree_slist_eq_SucD intro!: degree_eqI degree_slist_zero)"], ["", "subsection \\<open>Auxiliary Definitions\\<close>"], ["", "fun binop where\n  \"binop f z1 z2 [] [] = []\"\n| \"binop f z1 z2 ((i, x)#xs) [] = (i, f x z2) # binop f z1 z2 xs []\"\n| \"binop f z1 z2 [] ((i, y)#ys) = (i, f z1 y) # binop f z1 z2 [] ys\"\n| \"binop f z1 z2 ((i, x)#xs) ((j, y)#ys) =\n    (if (i = j)     then (i, f x y) # binop f z1 z2 xs ys\n    else if (i > j) then (i, f x z2) # binop f z1 z2 xs ((j, y)#ys)\n    else                 (j, f z1 y) # binop f z1 z2 ((i, x)#xs) ys)\""], ["", "lemma set_binop_elemD1:\n  \"(a, b) \\<in> set (binop f z1 z2 xs ys) \\<Longrightarrow> (a \\<in> set (map fst xs) \\<or> a \\<in> set (map fst ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set (binop f z1 z2 xs ys) \\<Longrightarrow>\n    a \\<in> set (map fst xs) \\<or> a \\<in> set (map fst ys)", "by (induct f z1 z2 xs ys rule: binop.induct) (auto split: if_split_asm)"], ["", "lemma set_binop_elemD2:\n  \"(a, b) \\<in> set (binop f z1 z2 xs ys) \\<Longrightarrow>\n    (\\<exists>x\\<in>set (map snd xs). b = f x z2) \\<or>\n    (\\<exists>y\\<in>set (map snd ys). b = f z1 y) \\<or>\n    (\\<exists>x\\<in>set (map snd xs). \\<exists>y\\<in>set (map snd ys). b = f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set (binop f z1 z2 xs ys) \\<Longrightarrow>\n    (\\<exists>x\\<in>set (map snd xs). b = f x z2) \\<or>\n    (\\<exists>y\\<in>set (map snd ys). b = f z1 y) \\<or>\n    (\\<exists>x\\<in>set (map snd xs).\n        \\<exists>y\\<in>set (map snd ys). b = f x y)", "by (induct f z1 z2 xs ys rule: binop.induct) (auto split: if_split_asm)"], ["", "abbreviation \"rsorted\\<equiv>\\<lambda>x. sorted (rev x)\""], ["", "lemma rsorted_binop:\n  fixes xs::\"('a::linorder * 'b) list\" and ys::\"('a::linorder * 'c) list\"\n  assumes \"rsorted ((map fst xs))\"\n  assumes \"rsorted ((map fst ys))\"\n  shows \"rsorted ((map fst (binop f z1 z2 xs ys)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsorted (map fst (binop f z1 z2 xs ys))", "using assms"], ["proof (prove)\nusing this:\n  rsorted (map fst xs)\n  rsorted (map fst ys)\n\ngoal (1 subgoal):\n 1. rsorted (map fst (binop f z1 z2 xs ys))", "by (induct f z1 z2 xs ys rule: binop.induct) (force simp: sorted_append dest!: set_binop_elemD1)+"], ["", "lemma distinct_binop:\n  fixes xs::\"('a::linorder * 'b) list\" and ys::\"('a::linorder * 'c) list\"\n  assumes \"distinct (map fst xs)\"\n  assumes \"distinct (map fst ys)\"\n  assumes \"rsorted ((map fst xs))\"\n  assumes \"rsorted ((map fst ys))\"\n  shows \"distinct (map fst (binop f z1 z2 xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (binop f z1 z2 xs ys))", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n  distinct (map fst ys)\n  rsorted (map fst xs)\n  rsorted (map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst (binop f z1 z2 xs ys))", "by (induct f z1 z2 xs ys rule: binop.induct)\n    (force dest!: set_binop_elemD1 simp: sorted_append)+"], ["", "lemma binop_plus:\n  fixes b::\"(nat * 'a::euclidean_space) list\"\n  shows\n    \"(\\<Sum>(i, y)\\<leftarrow>binop (+) 0 0 b ba. e i *\\<^sub>R y) = (\\<Sum>(i, y)\\<leftarrow>b. e i *\\<^sub>R y) + (\\<Sum>(i, y)\\<leftarrow>ba. e i *\\<^sub>R y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i,\n        y)\\<leftarrow>binop (+) (0::'a) (0::'a) b ba. e i *\\<^sub>R y) =\n    (\\<Sum>(i, y)\\<leftarrow>b. e i *\\<^sub>R y) +\n    (\\<Sum>(i, y)\\<leftarrow>ba. e i *\\<^sub>R y)", "by (induct \"(+) ::'a\\<Rightarrow>_\" \"0::'a\" \"0::'a\" b ba rule: binop.induct)\n    (auto simp: algebra_simps)"], ["", "lemma binop_compose:\n  \"binop (\\<lambda>x y. f (g x y)) z1 z2 xs ys = map (apsnd f) (binop g z1 z2 xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binop (\\<lambda>x y. f (g x y)) z1 z2 xs ys =\n    map (apsnd f) (binop g z1 z2 xs ys)", "by (induct \"\\<lambda>x y. f (g x y)\" z1 z2 xs ys rule: binop.induct) auto"], ["", "lemma linear_cmul_left[intro, simp]: \"linear ((*) x::real \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear ((*) x)", "by (auto intro!: linearI simp: algebra_simps)"], ["", "lemma length_merge_sorted_eq:\n  \"length (binop f z1 z2 xs ys) = length (binop g y1 y2 xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (binop f z1 z2 xs ys) = length (binop g y1 y2 xs ys)", "by (induction f z1 z2 xs ys rule: binop.induct) auto"], ["", "subsection \\<open>Pointswise Addition\\<close>"], ["", "lift_definition add_slist::\"(nat, 'a::{plus, zero}) slist \\<Rightarrow> (nat, 'a) slist \\<Rightarrow> (nat, 'a) slist\" is\n  \"\\<lambda>xs ys. binop (+) 0 0 xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>distinct (map fst list1) \\<and> rsorted (map fst list1);\n        distinct (map fst list2) \\<and> rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (binop (+) (0::'a) (0::'a) list1 list2)) \\<and>\n                         rsorted\n                          (map fst (binop (+) (0::'a) (0::'a) list1 list2))", "by (auto simp: intro!: distinct_binop rsorted_binop)"], ["", "lemma map_of_binop[simp]: \"rsorted (map fst xs) \\<Longrightarrow> rsorted (map fst ys) \\<Longrightarrow>\n  distinct (map fst xs) \\<Longrightarrow> distinct (map fst ys) \\<Longrightarrow>\n  map_of (binop f z1 z2 xs ys) i =\n  (case map_of xs i of\n    Some x \\<Rightarrow> Some (f x (case map_of ys i of Some x \\<Rightarrow> x | None \\<Rightarrow> z2))\n  | None \\<Rightarrow> (case map_of ys i of Some y \\<Rightarrow> Some (f z1 y) | None \\<Rightarrow> None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rsorted (map fst xs); rsorted (map fst ys);\n     distinct (map fst xs); distinct (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of (binop f z1 z2 xs ys) i =\n                      (case map_of xs i of\n                       None \\<Rightarrow>\n                         case map_of ys i of None \\<Rightarrow> None\n                         | Some y \\<Rightarrow> Some (f z1 y)\n                       | Some x \\<Rightarrow>\n                           Some (f x (the_default z2 (map_of ys i))))", "by (induct f z1 z2 xs ys rule: binop.induct)\n    (auto split: option.split option.split_asm simp: sorted_append)"], ["", "lemma pdevs_apply_Pdevs_add_slist[simp]:\n  fixes xs ys::\"(nat, 'a::monoid_add) slist\"\n  shows \"pdevs_apply (Pdevs (add_slist xs ys)) i =\n    pdevs_apply (Pdevs xs) i + pdevs_apply (Pdevs ys) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (Pdevs (add_slist xs ys)) i =\n    pdevs_apply (Pdevs xs) i + pdevs_apply (Pdevs ys) i", "by (transfer) (auto simp: Pdevs_raw_def split: option.split)"], ["", "lemma compute_add_pdevs[code]: \"add_pdevs (Pdevs xs) (Pdevs ys) = Pdevs (add_slist xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_pdevs (Pdevs xs) (Pdevs ys) = Pdevs (add_slist xs ys)", "by (rule pdevs_eqI) simp"], ["", "subsection \\<open>prod of pdevs\\<close>"], ["", "lift_definition prod_slist::\"(nat, 'a::zero) slist \\<Rightarrow> (nat, 'b::zero) slist \\<Rightarrow> (nat, ('a \\<times> 'b)) slist\" is\n  \"\\<lambda>xs ys. binop Pair 0 0 xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>distinct (map fst list1) \\<and> rsorted (map fst list1);\n        distinct (map fst list2) \\<and> rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (binop Pair (0::'a) (0::'b) list1 list2)) \\<and>\n                         rsorted\n                          (map fst (binop Pair (0::'a) (0::'b) list1 list2))", "by (auto simp: intro!: distinct_binop rsorted_binop)"], ["", "lemma pdevs_apply_Pdevs_prod_slist[simp]:\n  \"pdevs_apply (Pdevs (prod_slist xs ys)) i = (pdevs_apply (Pdevs xs) i, pdevs_apply (Pdevs ys) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (Pdevs (prod_slist xs ys)) i =\n    (pdevs_apply (Pdevs xs) i, pdevs_apply (Pdevs ys) i)", "by transfer (auto simp: Pdevs_raw_def zero_prod_def split: option.splits)"], ["", "lemma compute_prod_of_pdevs[code]: \"prod_of_pdevs (Pdevs xs) (Pdevs ys) = Pdevs (prod_slist xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_of_pdevs (Pdevs xs) (Pdevs ys) = Pdevs (prod_slist xs ys)", "by (rule pdevs_eqI) simp"], ["", "subsection \\<open>Set of Coefficients\\<close>"], ["", "lift_definition set_slist::\"(nat, 'a::real_vector) slist \\<Rightarrow> (nat * 'a) set\" is set"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma finite_set_slist[intro, simp]: \"finite (set_slist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_slist xs)", "by transfer simp"], ["", "subsection \\<open>Domain\\<close>"], ["", "lift_definition list_of_slist::\"('a::linorder, 'b::zero) slist \\<Rightarrow> ('a * 'b) list\"\n  is \"\\<lambda>xs. filter (\\<lambda>x. snd x \\<noteq> 0) xs\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma compute_pdevs_domain[code]: \"pdevs_domain (Pdevs xs) = set (map fst (list_of_slist xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain (Pdevs xs) = set (map fst (list_of_slist xs))", "unfolding pdevs_domain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. pdevs_apply (Pdevs xs) i \\<noteq> (0::'a)} =\n    set (map fst (list_of_slist xs))", "by transfer (force simp: Pdevs_raw_def split: option.split_asm)"], ["", "lemma sort_rev_eq_sort: \"distinct xs \\<Longrightarrow> sort (rev xs) = sort xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> sort (rev xs) = sort xs", "by (rule sorted_distinct_set_unique) auto"], ["", "lemma compute_list_of_pdevs[code]: \"list_of_pdevs (Pdevs xs) = list_of_slist xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_pdevs (Pdevs xs) = list_of_slist xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_pdevs (Pdevs xs) = list_of_slist xs", "have \"list_of_pdevs (Pdevs xs) =\n    map (\\<lambda>i. (i, pdevs_apply (Pdevs xs) i)) (rev (sorted_list_of_set (pdevs_domain (Pdevs xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_pdevs (Pdevs xs) =\n    map (\\<lambda>i. (i, pdevs_apply (Pdevs xs) i))\n     (rev (sorted_list_of_set (pdevs_domain (Pdevs xs))))", "by (simp add: list_of_pdevs_def)"], ["proof (state)\nthis:\n  list_of_pdevs (Pdevs xs) =\n  map (\\<lambda>i. (i, pdevs_apply (Pdevs xs) i))\n   (rev (sorted_list_of_set (pdevs_domain (Pdevs xs))))\n\ngoal (1 subgoal):\n 1. list_of_pdevs (Pdevs xs) = list_of_slist xs", "also"], ["proof (state)\nthis:\n  list_of_pdevs (Pdevs xs) =\n  map (\\<lambda>i. (i, pdevs_apply (Pdevs xs) i))\n   (rev (sorted_list_of_set (pdevs_domain (Pdevs xs))))\n\ngoal (1 subgoal):\n 1. list_of_pdevs (Pdevs xs) = list_of_slist xs", "have \"(sorted_list_of_set (pdevs_domain (Pdevs xs))) = rev (map fst (list_of_slist xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (pdevs_domain (Pdevs xs)) =\n    rev (map fst (list_of_slist xs))", "unfolding compute_pdevs_domain sorted_list_of_set_sort_remdups"], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (remdups (map fst (list_of_slist xs))) =\n    rev (map fst (list_of_slist xs))", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       distinct (map fst xs) \\<and> rsorted (map fst xs) \\<Longrightarrow>\n       sort\n        (remdups\n          (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))) =\n       rev (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))", "case prems: (1 xs)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       distinct (map fst xs) \\<and> rsorted (map fst xs) \\<Longrightarrow>\n       sort\n        (remdups\n          (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))) =\n       rev (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))", "hence distinct: \"distinct (map fst [x\\<leftarrow>xs . snd x \\<noteq> 0])\""], ["proof (prove)\nusing this:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))", "by (auto simp: filter_map distinct_map intro: subset_inj_on)"], ["proof (state)\nthis:\n  distinct (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       distinct (map fst xs) \\<and> rsorted (map fst xs) \\<Longrightarrow>\n       sort\n        (remdups\n          (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))) =\n       rev (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))", "with prems"], ["proof (chain)\npicking this:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n  distinct (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n  distinct (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))\n\ngoal (1 subgoal):\n 1. sort\n     (remdups (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))) =\n    rev (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))", "using sort_rev_eq_sort[symmetric, OF distinct]"], ["proof (prove)\nusing this:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n  distinct (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))\n  sort (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs)) =\n  sort (rev (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs)))\n\ngoal (1 subgoal):\n 1. sort\n     (remdups (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))) =\n    rev (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))", "by (auto simp: rev_map rev_filter distinct_map distinct_remdups_id\n        intro!: sorted_sort_id sorted_filter)"], ["proof (state)\nthis:\n  sort\n   (remdups (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))) =\n  rev (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_list_of_set (pdevs_domain (Pdevs xs)) =\n  rev (map fst (list_of_slist xs))\n\ngoal (1 subgoal):\n 1. list_of_pdevs (Pdevs xs) = list_of_slist xs", "also"], ["proof (state)\nthis:\n  sorted_list_of_set (pdevs_domain (Pdevs xs)) =\n  rev (map fst (list_of_slist xs))\n\ngoal (1 subgoal):\n 1. list_of_pdevs (Pdevs xs) = list_of_slist xs", "have \"map (\\<lambda>i. (i, pdevs_apply (Pdevs xs) i)) (rev \\<dots>) = list_of_slist xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (i, pdevs_apply (Pdevs xs) i))\n     (rev (rev (map fst (list_of_slist xs)))) =\n    list_of_slist xs", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       distinct (map fst xs) \\<and> rsorted (map fst xs) \\<Longrightarrow>\n       map (\\<lambda>i. (i, Pdevs_raw xs i))\n        (rev (rev (map fst\n                    (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs)))) =\n       filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs", "case (1 xs)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       distinct (map fst xs) \\<and> rsorted (map fst xs) \\<Longrightarrow>\n       map (\\<lambda>i. (i, Pdevs_raw xs i))\n        (rev (rev (map fst\n                    (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs)))) =\n       filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (i, Pdevs_raw xs i))\n     (rev (rev (map fst\n                 (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs)))) =\n    filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs", "unfolding Pdevs_raw_def o_def rev_rev_ident map_map"], ["proof (prove)\nusing this:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. (fst x, the_default (0::'a) (map_of xs (fst x))))\n     (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs) =\n    filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs", "by (subst map_cong[where g=\"\\<lambda>x. x\"]) (auto simp: map_filter_map_filter)"], ["proof (state)\nthis:\n  map (\\<lambda>i. (i, Pdevs_raw xs i))\n   (rev (rev (map fst (filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs)))) =\n  filter (\\<lambda>x. snd x \\<noteq> (0::'a)) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>i. (i, pdevs_apply (Pdevs xs) i))\n   (rev (rev (map fst (list_of_slist xs)))) =\n  list_of_slist xs\n\ngoal (1 subgoal):\n 1. list_of_pdevs (Pdevs xs) = list_of_slist xs", "finally"], ["proof (chain)\npicking this:\n  list_of_pdevs (Pdevs xs) = list_of_slist xs", "show ?thesis"], ["proof (prove)\nusing this:\n  list_of_pdevs (Pdevs xs) = list_of_slist xs\n\ngoal (1 subgoal):\n 1. list_of_pdevs (Pdevs xs) = list_of_slist xs", "."], ["proof (state)\nthis:\n  list_of_pdevs (Pdevs xs) = list_of_slist xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition slist_of_pdevs::\"'a pdevs \\<Rightarrow> (nat, 'a::real_vector) slist\" is list_of_pdevs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pdevs.\n       distinct (map fst (list_of_pdevs pdevs)) \\<and>\n       rsorted (map fst (list_of_pdevs pdevs))", "by (auto simp: list_of_pdevs_def rev_map rev_filter\n    filter_map o_def distinct_map image_def\n    intro!: distinct_filter sorted_filter[of \"\\<lambda>x. x\", simplified])"], ["", "subsection \\<open>Application\\<close>"], ["", "lift_definition slist_apply::\"('a::linorder, 'b::zero) slist \\<Rightarrow> 'a \\<Rightarrow> 'b\" is\n  \"\\<lambda>xs i. the_default 0 (map_of xs i)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma compute_pdevs_apply[code]: \"pdevs_apply (Pdevs x) i = slist_apply x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (Pdevs x) i = slist_apply x i", "by transfer (auto simp: Pdevs_raw_def)"], ["", "subsection \\<open>Total Deviation\\<close>"], ["", "lift_definition tdev_slist::\"(nat, 'a::ordered_euclidean_space) slist \\<Rightarrow> 'a\" is\n  \"sum_list o map (abs o snd)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma tdev_slist_sum: \"tdev_slist xs = sum (abs \\<circ> snd) (set_slist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev_slist xs = sum (abs \\<circ> snd) (set_slist xs)", "by transfer (auto simp: distinct_map sum_list_distinct_conv_sum_set[symmetric] o_def)"], ["", "lemma pdevs_apply_set_slist: \"x \\<in> set_slist xs \\<Longrightarrow> snd x = pdevs_apply (Pdevs xs) (fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set_slist xs \\<Longrightarrow>\n    snd x = pdevs_apply (Pdevs xs) (fst x)", "by transfer (auto simp: Pdevs_raw_def)"], ["", "lemma\n  tdev_list_eq_zeroI:\n  shows \"(\\<And>i. pdevs_apply (Pdevs xs) i = 0) \\<Longrightarrow> tdev_slist xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. pdevs_apply (Pdevs xs) i = (0::'a)) \\<Longrightarrow>\n    tdev_slist xs = (0::'a)", "unfolding tdev_slist_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. pdevs_apply (Pdevs xs) i = (0::'a)) \\<Longrightarrow>\n    sum (abs \\<circ> snd) (set_slist xs) = (0::'a)", "by (auto simp: pdevs_apply_set_slist)"], ["", "lemma inj_on_fst_set_slist: \"inj_on fst (set_slist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fst (set_slist xs)", "by transfer (simp add: distinct_map)"], ["", "lemma pdevs_apply_Pdevs_eq_0:\n  \"pdevs_apply (Pdevs xs) i = 0 \\<longleftrightarrow> ((\\<forall>x. (i, x) \\<in> set_slist xs \\<longrightarrow> x = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pdevs_apply (Pdevs xs) i = (0::'a)) =\n    (\\<forall>x. (i, x) \\<in> set_slist xs \\<longrightarrow> x = (0::'a))", "by transfer (safe, auto simp: Pdevs_raw_def split: option.split)"], ["", "lemma compute_tdev[code]: \"tdev (Pdevs xs) = tdev_slist xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "have \"tdev (Pdevs xs) = (\\<Sum>i<degree (Pdevs xs). \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) =\n    (\\<Sum>i<degree (Pdevs xs). \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)", "by (simp add: tdev_def)"], ["proof (state)\nthis:\n  tdev (Pdevs xs) =\n  (\\<Sum>i<degree (Pdevs xs). \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "also"], ["proof (state)\nthis:\n  tdev (Pdevs xs) =\n  (\\<Sum>i<degree (Pdevs xs). \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "have \"\\<dots> =\n    (\\<Sum>i <degree (Pdevs xs).\n      if pdevs_apply (Pdevs xs) i = 0 then 0 else \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (Pdevs xs). \\<bar>pdevs_apply (Pdevs xs) i\\<bar>) =\n    (\\<Sum>i<degree (Pdevs xs).\n        if pdevs_apply (Pdevs xs) i = (0::'a) then 0::'a\n        else \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)", "by (auto intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (Pdevs xs). \\<bar>pdevs_apply (Pdevs xs) i\\<bar>) =\n  (\\<Sum>i<degree (Pdevs xs).\n      if pdevs_apply (Pdevs xs) i = (0::'a) then 0::'a\n      else \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (Pdevs xs). \\<bar>pdevs_apply (Pdevs xs) i\\<bar>) =\n  (\\<Sum>i<degree (Pdevs xs).\n      if pdevs_apply (Pdevs xs) i = (0::'a) then 0::'a\n      else \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "have \"\\<dots> =\n    (\\<Sum>i\\<in>{0..<degree (Pdevs xs)} \\<inter> {x. pdevs_apply (Pdevs xs) x \\<noteq> 0}.\n      \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (Pdevs xs).\n        if pdevs_apply (Pdevs xs) i = (0::'a) then 0::'a\n        else \\<bar>pdevs_apply (Pdevs xs) i\\<bar>) =\n    (\\<Sum>i\\<in>{0..<degree (Pdevs xs)} \\<inter>\n                 {x. pdevs_apply (Pdevs xs) x \\<noteq> (0::'a)}.\n       \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)", "by (auto simp: sum.If_cases Collect_neg_eq atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (Pdevs xs).\n      if pdevs_apply (Pdevs xs) i = (0::'a) then 0::'a\n      else \\<bar>pdevs_apply (Pdevs xs) i\\<bar>) =\n  (\\<Sum>i\\<in>{0..<degree (Pdevs xs)} \\<inter>\n               {x. pdevs_apply (Pdevs xs) x \\<noteq> (0::'a)}.\n     \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (Pdevs xs).\n      if pdevs_apply (Pdevs xs) i = (0::'a) then 0::'a\n      else \\<bar>pdevs_apply (Pdevs xs) i\\<bar>) =\n  (\\<Sum>i\\<in>{0..<degree (Pdevs xs)} \\<inter>\n               {x. pdevs_apply (Pdevs xs) x \\<noteq> (0::'a)}.\n     \\<bar>pdevs_apply (Pdevs xs) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "have \"\\<dots> = (\\<Sum>x\\<in>fst ` set_slist xs. \\<bar>pdevs_apply (Pdevs xs) x\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{0..<degree (Pdevs xs)} \\<inter>\n                 {x. pdevs_apply (Pdevs xs) x \\<noteq> (0::'a)}.\n       \\<bar>pdevs_apply (Pdevs xs) i\\<bar>) =\n    (\\<Sum>x\\<in>fst ` set_slist xs. \\<bar>pdevs_apply (Pdevs xs) x\\<bar>)", "by (rule sum.mono_neutral_cong_left)\n      (force simp: pdevs_apply_Pdevs_eq_0 intro!: imageI degree_gt)+"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{0..<degree (Pdevs xs)} \\<inter>\n               {x. pdevs_apply (Pdevs xs) x \\<noteq> (0::'a)}.\n     \\<bar>pdevs_apply (Pdevs xs) i\\<bar>) =\n  (\\<Sum>x\\<in>fst ` set_slist xs. \\<bar>pdevs_apply (Pdevs xs) x\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{0..<degree (Pdevs xs)} \\<inter>\n               {x. pdevs_apply (Pdevs xs) x \\<noteq> (0::'a)}.\n     \\<bar>pdevs_apply (Pdevs xs) i\\<bar>) =\n  (\\<Sum>x\\<in>fst ` set_slist xs. \\<bar>pdevs_apply (Pdevs xs) x\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "have \"\\<dots> = (\\<Sum>x\\<in>set_slist xs. \\<bar>pdevs_apply (Pdevs xs) (fst x)\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>fst ` set_slist xs. \\<bar>pdevs_apply (Pdevs xs) x\\<bar>) =\n    (\\<Sum>x\\<in>set_slist xs. \\<bar>pdevs_apply (Pdevs xs) (fst x)\\<bar>)", "by (rule sum.reindex_cong[of fst]) (auto simp: inj_on_fst_set_slist)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>fst ` set_slist xs. \\<bar>pdevs_apply (Pdevs xs) x\\<bar>) =\n  (\\<Sum>x\\<in>set_slist xs. \\<bar>pdevs_apply (Pdevs xs) (fst x)\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>fst ` set_slist xs. \\<bar>pdevs_apply (Pdevs xs) x\\<bar>) =\n  (\\<Sum>x\\<in>set_slist xs. \\<bar>pdevs_apply (Pdevs xs) (fst x)\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "have \"\\<dots> = tdev_slist xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_slist xs. \\<bar>pdevs_apply (Pdevs xs) (fst x)\\<bar>) =\n    tdev_slist xs", "by (simp add: tdev_slist_sum pdevs_apply_set_slist)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_slist xs. \\<bar>pdevs_apply (Pdevs xs) (fst x)\\<bar>) =\n  tdev_slist xs\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "finally"], ["proof (chain)\npicking this:\n  tdev (Pdevs xs) = tdev_slist xs", "show ?thesis"], ["proof (prove)\nusing this:\n  tdev (Pdevs xs) = tdev_slist xs\n\ngoal (1 subgoal):\n 1. tdev (Pdevs xs) = tdev_slist xs", "."], ["proof (state)\nthis:\n  tdev (Pdevs xs) = tdev_slist xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Minkowski Sum\\<close>"], ["", "lemma dropWhile_rsorted_eq_filter:\n  \"rsorted (map fst xs) \\<Longrightarrow> dropWhile (\\<lambda>(i, x). i \\<ge> (m::nat)) xs = filter (\\<lambda>(i, x). i < m) xs\"\n  (is \"_ \\<Longrightarrow> ?lhs xs = ?rhs xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rsorted (map fst xs) \\<Longrightarrow>\n    dropWhile (\\<lambda>(i, x). m \\<le> i) xs =\n    filter (\\<lambda>(i, x). i < m) xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. rsorted (map fst []) \\<Longrightarrow>\n    dropWhile (\\<lambda>(i, x). m \\<le> i) [] =\n    filter (\\<lambda>(i, x). i < m) []\n 2. \\<And>a xs.\n       \\<lbrakk>rsorted (map fst xs) \\<Longrightarrow>\n                dropWhile (\\<lambda>(i, x). m \\<le> i) xs =\n                filter (\\<lambda>(i, x). i < m) xs;\n        rsorted (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> dropWhile (\\<lambda>(i, x). m \\<le> i) (a # xs) =\n                         filter (\\<lambda>(i, x). i < m) (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  rsorted (map fst xs) \\<Longrightarrow>\n  dropWhile (\\<lambda>a. case a of (i, x) \\<Rightarrow> m \\<le> i) xs =\n  filter (\\<lambda>a. case a of (i, x) \\<Rightarrow> i < m) xs\n  rsorted (map fst (x # xs))\n\ngoal (2 subgoals):\n 1. rsorted (map fst []) \\<Longrightarrow>\n    dropWhile (\\<lambda>(i, x). m \\<le> i) [] =\n    filter (\\<lambda>(i, x). i < m) []\n 2. \\<And>a xs.\n       \\<lbrakk>rsorted (map fst xs) \\<Longrightarrow>\n                dropWhile (\\<lambda>(i, x). m \\<le> i) xs =\n                filter (\\<lambda>(i, x). i < m) xs;\n        rsorted (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> dropWhile (\\<lambda>(i, x). m \\<le> i) (a # xs) =\n                         filter (\\<lambda>(i, x). i < m) (a # xs)", "hence \"?rhs (x#xs) = ?lhs (x#xs)\""], ["proof (prove)\nusing this:\n  rsorted (map fst xs) \\<Longrightarrow>\n  dropWhile (\\<lambda>a. case a of (i, x) \\<Rightarrow> m \\<le> i) xs =\n  filter (\\<lambda>a. case a of (i, x) \\<Rightarrow> i < m) xs\n  rsorted (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>a. case a of (i, x) \\<Rightarrow> i < m) (x # xs) =\n    dropWhile (\\<lambda>a. case a of (i, x) \\<Rightarrow> m \\<le> i)\n     (x # xs)", "by (auto simp: sorted_append filter_id_conv intro: sym)"], ["proof (state)\nthis:\n  filter (\\<lambda>a. case a of (i, x) \\<Rightarrow> i < m) (x # xs) =\n  dropWhile (\\<lambda>a. case a of (i, x) \\<Rightarrow> m \\<le> i) (x # xs)\n\ngoal (2 subgoals):\n 1. rsorted (map fst []) \\<Longrightarrow>\n    dropWhile (\\<lambda>(i, x). m \\<le> i) [] =\n    filter (\\<lambda>(i, x). i < m) []\n 2. \\<And>a xs.\n       \\<lbrakk>rsorted (map fst xs) \\<Longrightarrow>\n                dropWhile (\\<lambda>(i, x). m \\<le> i) xs =\n                filter (\\<lambda>(i, x). i < m) xs;\n        rsorted (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> dropWhile (\\<lambda>(i, x). m \\<le> i) (a # xs) =\n                         filter (\\<lambda>(i, x). i < m) (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  filter (\\<lambda>a. case a of (i, x) \\<Rightarrow> i < m) (x # xs) =\n  dropWhile (\\<lambda>a. case a of (i, x) \\<Rightarrow> m \\<le> i) (x # xs)\n\ngoal (1 subgoal):\n 1. dropWhile (\\<lambda>a. case a of (i, x) \\<Rightarrow> m \\<le> i)\n     (x # xs) =\n    filter (\\<lambda>a. case a of (i, x) \\<Rightarrow> i < m) (x # xs)", ".."], ["proof (state)\nthis:\n  dropWhile (\\<lambda>a. case a of (i, x) \\<Rightarrow> m \\<le> i)\n   (x # xs) =\n  filter (\\<lambda>a. case a of (i, x) \\<Rightarrow> i < m) (x # xs)\n\ngoal (1 subgoal):\n 1. rsorted (map fst []) \\<Longrightarrow>\n    dropWhile (\\<lambda>(i, x). m \\<le> i) [] =\n    filter (\\<lambda>(i, x). i < m) []", "qed simp"], ["", "lift_definition msum_slist::\"nat \\<Rightarrow> (nat, 'a) slist \\<Rightarrow> (nat, 'a) slist \\<Rightarrow> (nat, 'a) slist\"\n  is \"\\<lambda>m xs ys. map (apfst (\\<lambda>n. n + m)) ys @ dropWhile (\\<lambda>(i, x). i \\<ge> m) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1) \\<and> rsorted (map fst list1);\n        distinct (map fst list2) \\<and> rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1)) \\<and>\n                         rsorted\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))", "proof (safe, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))\n 2. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> rsorted\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))", "case (1 n l1 l2)"], ["proof (state)\nthis:\n  distinct (map fst l1)\n  rsorted (map fst l1)\n  distinct (map fst l2)\n  rsorted (map fst l2)\n\ngoal (2 subgoals):\n 1. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))\n 2. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> rsorted\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))", "then"], ["proof (chain)\npicking this:\n  distinct (map fst l1)\n  rsorted (map fst l1)\n  distinct (map fst l2)\n  rsorted (map fst l2)", "have \"set (dropWhile (\\<lambda>(i, x). n \\<le> i) l1) \\<subseteq> set l1\""], ["proof (prove)\nusing this:\n  distinct (map fst l1)\n  rsorted (map fst l1)\n  distinct (map fst l2)\n  rsorted (map fst l2)\n\ngoal (1 subgoal):\n 1. set (dropWhile (\\<lambda>(i, x). n \\<le> i) l1) \\<subseteq> set l1", "by (simp add: set_dropWhileD subrelI)"], ["proof (state)\nthis:\n  set (dropWhile (\\<lambda>(i, x). n \\<le> i) l1) \\<subseteq> set l1\n\ngoal (2 subgoals):\n 1. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))\n 2. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> rsorted\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))", "with 1"], ["proof (chain)\npicking this:\n  distinct (map fst l1)\n  rsorted (map fst l1)\n  distinct (map fst l2)\n  rsorted (map fst l2)\n  set (dropWhile (\\<lambda>(i, x). n \\<le> i) l1) \\<subseteq> set l1", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst l1)\n  rsorted (map fst l1)\n  distinct (map fst l2)\n  rsorted (map fst l2)\n  set (dropWhile (\\<lambda>(i, x). n \\<le> i) l1) \\<subseteq> set l1\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map (apfst (\\<lambda>na. na + n)) l2 @\n        dropWhile (\\<lambda>(i, x). n \\<le> i) l1))", "by (auto simp add: distinct_map add.commute [of _ n] intro!: comp_inj_on intro: subset_inj_on)\n      (simp add: dropWhile_rsorted_eq_filter)"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (map (apfst (\\<lambda>na. na + n)) l2 @\n      dropWhile (\\<lambda>(i, x). n \\<le> i) l1))\n\ngoal (1 subgoal):\n 1. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> rsorted\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> rsorted\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))", "case prems: (2 n l1 l2)"], ["proof (state)\nthis:\n  distinct (map fst l1)\n  rsorted (map fst l1)\n  distinct (map fst l2)\n  rsorted (map fst l2)\n\ngoal (1 subgoal):\n 1. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> rsorted\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))", "hence \"sorted (map ((\\<lambda>na. na + n) \\<circ> fst) (rev l2))\""], ["proof (prove)\nusing this:\n  distinct (map fst l1)\n  rsorted (map fst l1)\n  distinct (map fst l2)\n  rsorted (map fst l2)\n\ngoal (1 subgoal):\n 1. sorted (map ((\\<lambda>na. na + n) \\<circ> fst) (rev l2))", "by(simp add: sorted_iff_nth_mono rev_map)"], ["proof (state)\nthis:\n  sorted (map ((\\<lambda>na. na + n) \\<circ> fst) (rev l2))\n\ngoal (1 subgoal):\n 1. \\<And>nat list1 list2.\n       \\<lbrakk>distinct (map fst list1); rsorted (map fst list1);\n        distinct (map fst list2); rsorted (map fst list2)\\<rbrakk>\n       \\<Longrightarrow> rsorted\n                          (map fst\n                            (map (apfst (\\<lambda>n. n + nat)) list2 @\n                             dropWhile (\\<lambda>(i, x). nat \\<le> i)\n                              list1))", "with prems"], ["proof (chain)\npicking this:\n  distinct (map fst l1)\n  rsorted (map fst l1)\n  distinct (map fst l2)\n  rsorted (map fst l2)\n  sorted (map ((\\<lambda>na. na + n) \\<circ> fst) (rev l2))", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst l1)\n  rsorted (map fst l1)\n  distinct (map fst l2)\n  rsorted (map fst l2)\n  sorted (map ((\\<lambda>na. na + n) \\<circ> fst) (rev l2))\n\ngoal (1 subgoal):\n 1. rsorted\n     (map fst\n       (map (apfst (\\<lambda>na. na + n)) l2 @\n        dropWhile (\\<lambda>(i, x). n \\<le> i) l1))", "by (auto simp: sorted_append dropWhile_rsorted_eq_filter rev_map rev_filter sorted_filter)"], ["proof (state)\nthis:\n  rsorted\n   (map fst\n     (map (apfst (\\<lambda>na. na + n)) l2 @\n      dropWhile (\\<lambda>(i, x). n \\<le> i) l1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slist_apply_msum_slist:\n  \"slist_apply (msum_slist m xs ys) i =\n    (if i < m then slist_apply xs i else slist_apply ys (i - m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slist_apply (msum_slist m xs ys) i =\n    (if i < m then slist_apply xs i else slist_apply ys (i - m))", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m xs ys i.\n       \\<lbrakk>distinct (map fst xs) \\<and> rsorted (map fst xs);\n        distinct (map fst ys) \\<and> rsorted (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> the_default (0::'a)\n                          (map_of\n                            (map (apfst (\\<lambda>n. n + m)) ys @\n                             dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n                            i) =\n                         (if i < m then the_default (0::'a) (map_of xs i)\n                          else the_default (0::'a) (map_of ys (i - m)))", "case prems: (1 m xs ys i)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n  distinct (map fst ys) \\<and> rsorted (map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>m xs ys i.\n       \\<lbrakk>distinct (map fst xs) \\<and> rsorted (map fst xs);\n        distinct (map fst ys) \\<and> rsorted (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> the_default (0::'a)\n                          (map_of\n                            (map (apfst (\\<lambda>n. n + m)) ys @\n                             dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n                            i) =\n                         (if i < m then the_default (0::'a) (map_of xs i)\n                          else the_default (0::'a) (map_of ys (i - m)))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n  distinct (map fst ys) \\<and> rsorted (map fst ys)\n\ngoal (1 subgoal):\n 1. the_default (0::'a)\n     (map_of\n       (map (apfst (\\<lambda>n. n + m)) ys @\n        dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n       i) =\n    (if i < m then the_default (0::'a) (map_of xs i)\n     else the_default (0::'a) (map_of ys (i - m)))", "proof (cases \"i \\<in> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst xs) \\<and> rsorted (map fst xs);\n     distinct (map fst ys) \\<and> rsorted (map fst ys);\n     i \\<in> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\\<rbrakk>\n    \\<Longrightarrow> the_default (0::'a)\n                       (map_of\n                         (map (apfst (\\<lambda>n. n + m)) ys @\n                          dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n                         i) =\n                      (if i < m then the_default (0::'a) (map_of xs i)\n                       else the_default (0::'a) (map_of ys (i - m)))\n 2. \\<lbrakk>distinct (map fst xs) \\<and> rsorted (map fst xs);\n     distinct (map fst ys) \\<and> rsorted (map fst ys);\n     i \\<notin> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\\<rbrakk>\n    \\<Longrightarrow> the_default (0::'a)\n                       (map_of\n                         (map (apfst (\\<lambda>n. n + m)) ys @\n                          dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n                         i) =\n                      (if i < m then the_default (0::'a) (map_of xs i)\n                       else the_default (0::'a) (map_of ys (i - m)))", "case False"], ["proof (state)\nthis:\n  i \\<notin> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst xs) \\<and> rsorted (map fst xs);\n     distinct (map fst ys) \\<and> rsorted (map fst ys);\n     i \\<in> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\\<rbrakk>\n    \\<Longrightarrow> the_default (0::'a)\n                       (map_of\n                         (map (apfst (\\<lambda>n. n + m)) ys @\n                          dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n                         i) =\n                      (if i < m then the_default (0::'a) (map_of xs i)\n                       else the_default (0::'a) (map_of ys (i - m)))\n 2. \\<lbrakk>distinct (map fst xs) \\<and> rsorted (map fst xs);\n     distinct (map fst ys) \\<and> rsorted (map fst ys);\n     i \\<notin> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\\<rbrakk>\n    \\<Longrightarrow> the_default (0::'a)\n                       (map_of\n                         (map (apfst (\\<lambda>n. n + m)) ys @\n                          dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n                         i) =\n                      (if i < m then the_default (0::'a) (map_of xs i)\n                       else the_default (0::'a) (map_of ys (i - m)))", "have \"\\<And>a. i < m \\<Longrightarrow> i \\<notin> fst ` {x \\<in> set xs. case x of (i, x) \\<Rightarrow> i < m} \\<Longrightarrow> (i, a) \\<notin> set xs\"\n      \"\\<And>a. i \\<notin> fst ` set xs \\<Longrightarrow> (i, a) \\<notin> set xs\"\n      \"\\<And>a. m \\<le> i \\<Longrightarrow> i \\<notin> fst ` (\\<lambda>(x, y). (x + m, y)) ` set ys \\<Longrightarrow> (i - m, a) \\<notin> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>i < m;\n         i \\<notin> fst `\n                    {x \\<in> set xs.\n                     case x of (i, x) \\<Rightarrow> i < m}\\<rbrakk>\n        \\<Longrightarrow> (i, a) \\<notin> set xs) &&&\n    (\\<And>a.\n        i \\<notin> fst ` set xs \\<Longrightarrow>\n        (i, a) \\<notin> set xs) &&&\n    (\\<And>a.\n        \\<lbrakk>m \\<le> i;\n         i \\<notin> fst ` (\\<lambda>(x, y). (x + m, y)) ` set ys\\<rbrakk>\n        \\<Longrightarrow> (i - m, a) \\<notin> set ys)", "by force+"], ["proof (state)\nthis:\n  \\<lbrakk>i < m;\n   i \\<notin> fst `\n              {x \\<in> set xs.\n               case x of (i, x) \\<Rightarrow> i < m}\\<rbrakk>\n  \\<Longrightarrow> (i, ?a) \\<notin> set xs\n  i \\<notin> fst ` set xs \\<Longrightarrow> (i, ?a) \\<notin> set xs\n  \\<lbrakk>m \\<le> i;\n   i \\<notin> fst ` (\\<lambda>(x, y). (x + m, y)) ` set ys\\<rbrakk>\n  \\<Longrightarrow> (i - m, ?a) \\<notin> set ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst xs) \\<and> rsorted (map fst xs);\n     distinct (map fst ys) \\<and> rsorted (map fst ys);\n     i \\<in> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\\<rbrakk>\n    \\<Longrightarrow> the_default (0::'a)\n                       (map_of\n                         (map (apfst (\\<lambda>n. n + m)) ys @\n                          dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n                         i) =\n                      (if i < m then the_default (0::'a) (map_of xs i)\n                       else the_default (0::'a) (map_of ys (i - m)))\n 2. \\<lbrakk>distinct (map fst xs) \\<and> rsorted (map fst xs);\n     distinct (map fst ys) \\<and> rsorted (map fst ys);\n     i \\<notin> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\\<rbrakk>\n    \\<Longrightarrow> the_default (0::'a)\n                       (map_of\n                         (map (apfst (\\<lambda>n. n + m)) ys @\n                          dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n                         i) =\n                      (if i < m then the_default (0::'a) (map_of xs i)\n                       else the_default (0::'a) (map_of ys (i - m)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < m;\n   i \\<notin> fst `\n              {x \\<in> set xs.\n               case x of (i, x) \\<Rightarrow> i < m}\\<rbrakk>\n  \\<Longrightarrow> (i, ?a) \\<notin> set xs\n  i \\<notin> fst ` set xs \\<Longrightarrow> (i, ?a) \\<notin> set xs\n  \\<lbrakk>m \\<le> i;\n   i \\<notin> fst ` (\\<lambda>(x, y). (x + m, y)) ` set ys\\<rbrakk>\n  \\<Longrightarrow> (i - m, ?a) \\<notin> set ys\n\ngoal (1 subgoal):\n 1. the_default (0::'a)\n     (map_of\n       (map (apfst (\\<lambda>n. n + m)) ys @\n        dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n       i) =\n    (if i < m then the_default (0::'a) (map_of xs i)\n     else the_default (0::'a) (map_of ys (i - m)))", "using prems False"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < m;\n   i \\<notin> fst `\n              {x \\<in> set xs.\n               case x of (i, x) \\<Rightarrow> i < m}\\<rbrakk>\n  \\<Longrightarrow> (i, ?a) \\<notin> set xs\n  i \\<notin> fst ` set xs \\<Longrightarrow> (i, ?a) \\<notin> set xs\n  \\<lbrakk>m \\<le> i;\n   i \\<notin> fst ` (\\<lambda>(x, y). (x + m, y)) ` set ys\\<rbrakk>\n  \\<Longrightarrow> (i - m, ?a) \\<notin> set ys\n  distinct (map fst xs) \\<and> rsorted (map fst xs)\n  distinct (map fst ys) \\<and> rsorted (map fst ys)\n  i \\<notin> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\n\ngoal (1 subgoal):\n 1. the_default (0::'a)\n     (map_of\n       (map (apfst (\\<lambda>n. n + m)) ys @\n        dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n       i) =\n    (if i < m then the_default (0::'a) (map_of xs i)\n     else the_default (0::'a) (map_of ys (i - m)))", "by (auto simp add: dropWhile_rsorted_eq_filter map_of_eq_None_iff distinct_map_fst_snd_eqD\n        split: option.split dest!: map_of_SomeD)"], ["proof (state)\nthis:\n  the_default (0::'a)\n   (map_of\n     (map (apfst (\\<lambda>n. n + m)) ys @\n      dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n     i) =\n  (if i < m then the_default (0::'a) (map_of xs i)\n   else the_default (0::'a) (map_of ys (i - m)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs) \\<and> rsorted (map fst xs);\n     distinct (map fst ys) \\<and> rsorted (map fst ys);\n     i \\<in> dom (map_of (map (\\<lambda>(x, y). (x + m, y)) ys))\\<rbrakk>\n    \\<Longrightarrow> the_default (0::'a)\n                       (map_of\n                         (map (apfst (\\<lambda>n. n + m)) ys @\n                          dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n                         i) =\n                      (if i < m then the_default (0::'a) (map_of xs i)\n                       else the_default (0::'a) (map_of ys (i - m)))", "qed (force simp: map_of_eq_None_iff distinct_map_fst_snd_eqD\n    split: option.split\n    dest!: map_of_SomeD)"], ["proof (state)\nthis:\n  the_default (0::'a)\n   (map_of\n     (map (apfst (\\<lambda>n. n + m)) ys @\n      dropWhile (\\<lambda>(i, x). m \\<le> i) xs)\n     i) =\n  (if i < m then the_default (0::'a) (map_of xs i)\n   else the_default (0::'a) (map_of ys (i - m)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_apply_msum_slist:\n  \"pdevs_apply (Pdevs (msum_slist m xs ys)) i =\n    (if i < m then pdevs_apply (Pdevs xs) i else pdevs_apply (Pdevs ys) (i - m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (Pdevs (msum_slist m xs ys)) i =\n    (if i < m then pdevs_apply (Pdevs xs) i\n     else pdevs_apply (Pdevs ys) (i - m))", "by (auto simp: compute_pdevs_apply slist_apply_msum_slist)"], ["", "lemma compute_msum_pdevs[code]: \"msum_pdevs m (Pdevs xs) (Pdevs ys) = Pdevs (msum_slist m xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msum_pdevs m (Pdevs xs) (Pdevs ys) = Pdevs (msum_slist m xs ys)", "by (rule pdevs_eqI) (auto simp: pdevs_apply_msum_slist pdevs_apply_msum_pdevs)"], ["", "subsection \\<open>Unary Operations\\<close>"], ["", "lift_definition map_slist::\"('a \\<Rightarrow> 'b) \\<Rightarrow> (nat, 'a) slist \\<Rightarrow> (nat, 'b) slist\" is \"\\<lambda>f. map (apsnd f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun list.\n       distinct (map fst list) \\<and>\n       rsorted (map fst list) \\<Longrightarrow>\n       distinct (map fst (map (apsnd fun) list)) \\<and>\n       rsorted (map fst (map (apsnd fun) list))", "by simp"], ["", "lemma pdevs_apply_map_slist:\n  \"f 0 = 0 \\<Longrightarrow> pdevs_apply (Pdevs (map_slist f xs)) i = f (pdevs_apply (Pdevs xs) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (0::'b) = (0::'a) \\<Longrightarrow>\n    pdevs_apply (Pdevs (map_slist f xs)) i = f (pdevs_apply (Pdevs xs) i)", "by transfer\n    (force simp: Pdevs_raw_def map_of_eq_None_iff distinct_map_fst_snd_eqD image_def\n      split: option.split dest: distinct_map_fst_snd_eqD)"], ["", "lemma compute_scaleR_pdves[code]: \"scaleR_pdevs r (Pdevs xs) = Pdevs (map_slist (\\<lambda>x. r *\\<^sub>R x) xs)\"\n  and compute_pdevs_scaleR[code]: \"pdevs_scaleR (Pdevs rs) x = Pdevs (map_slist (\\<lambda>r. r *\\<^sub>R x) rs)\"\n  and compute_uminus_pdevs[code]: \"uminus_pdevs (Pdevs xs) = Pdevs (map_slist (\\<lambda>x. - x) xs)\"\n  and compute_abs_pdevs[code]: \"abs_pdevs (Pdevs xs) = Pdevs (map_slist abs xs)\"\n  and compute_pdevs_inner[code]: \"pdevs_inner (Pdevs xs) b = Pdevs (map_slist (\\<lambda>x. x \\<bullet> b) xs)\"\n  and compute_pdevs_inner2[code]:\n    \"pdevs_inner2 (Pdevs xs) b c = Pdevs (map_slist (\\<lambda>x. (x \\<bullet> b, x \\<bullet> c)) xs)\"\n  and compute_inner_scaleR_pdevs[code]:\n    \"inner_scaleR_pdevs x (Pdevs ys) = Pdevs (map_slist (\\<lambda>y. (x \\<bullet> y) *\\<^sub>R y) ys)\"\n  and compute_trunc_pdevs[code]:\n    \"trunc_pdevs p (Pdevs xs) = Pdevs (map_slist (\\<lambda>x. eucl_truncate_down p x) xs)\"\n  and compute_trunc_err_pdevs[code]:\n    \"trunc_err_pdevs p (Pdevs xs) = Pdevs (map_slist (\\<lambda>x. eucl_truncate_down p x - x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((scaleR_pdevs r (Pdevs xs) = Pdevs (map_slist ((*\\<^sub>R) r) xs) &&&\n      pdevs_scaleR (Pdevs rs) x =\n      Pdevs (map_slist (\\<lambda>r. r *\\<^sub>R x) rs)) &&&\n     uminus_pdevs (Pdevs xs) = Pdevs (map_slist uminus xs) &&&\n     abs_pdevs (Pdevs xs) = Pdevs (map_slist abs xs)) &&&\n    (pdevs_inner (Pdevs xs) b =\n     Pdevs (map_slist (\\<lambda>x. x \\<bullet> b) xs) &&&\n     pdevs_inner2 (Pdevs xs) b c =\n     Pdevs (map_slist (\\<lambda>x. (x \\<bullet> b, x \\<bullet> c)) xs)) &&&\n    inner_scaleR_pdevs x (Pdevs ys) =\n    Pdevs (map_slist (\\<lambda>y. (x \\<bullet> y) *\\<^sub>R y) ys) &&&\n    trunc_pdevs p (Pdevs xs) =\n    Pdevs (map_slist (eucl_truncate_down p) xs) &&&\n    trunc_err_pdevs p (Pdevs xs) =\n    Pdevs (map_slist (\\<lambda>x. eucl_truncate_down p x - x) xs)", "by (auto intro!: pdevs_eqI simp: pdevs_apply_map_slist zero_prod_def abs_pdevs_def)"], ["", "subsection \\<open>Filter\\<close>"], ["", "lift_definition filter_slist::\"(nat \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> (nat, 'a) slist \\<Rightarrow> (nat, 'a) slist\"\n  is \"\\<lambda>P xs. filter (\\<lambda>(i, x). (P i x)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun list.\n       distinct (map fst list) \\<and>\n       rsorted (map fst list) \\<Longrightarrow>\n       distinct (map fst (filter (\\<lambda>(x, y). fun x y) list)) \\<and>\n       rsorted (map fst (filter (\\<lambda>(x, y). fun x y) list))", "by (auto simp: o_def filter_map distinct_map rev_map rev_filter sorted_filter\n    intro: subset_inj_on)"], ["", "lemma slist_apply_filter_slist: \"slist_apply (filter_slist P xs) i =\n  (if P i (slist_apply xs i) then slist_apply xs i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slist_apply (filter_slist P xs) i =\n    (if P i (slist_apply xs i) then slist_apply xs i else (0::'a))", "by transfer (force simp: Pdevs_raw_def o_def map_of_eq_None_iff distinct_map_fst_snd_eqD\n    dest: map_of_SomeD distinct_map_fst_snd_eqD split: option.split)"], ["", "lemma pdevs_apply_filter_slist: \"pdevs_apply (Pdevs (filter_slist P xs)) i =\n  (if P i (pdevs_apply (Pdevs xs) i) then pdevs_apply (Pdevs xs) i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (Pdevs (filter_slist P xs)) i =\n    (if P i (pdevs_apply (Pdevs xs) i) then pdevs_apply (Pdevs xs) i\n     else (0::'a))", "by (simp add: compute_pdevs_apply slist_apply_filter_slist)"], ["", "lemma compute_filter_pdevs[code]: \"filter_pdevs P (Pdevs xs) = Pdevs (filter_slist P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_pdevs P (Pdevs xs) = Pdevs (filter_slist P xs)", "by (auto simp: pdevs_apply_filter_slist intro!: pdevs_eqI)"], ["", "subsection \\<open>Constant\\<close>"], ["", "lift_definition zero_slist::\"(nat, 'a) slist\" is \"[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst []) \\<and> rsorted (map fst [])", "by simp"], ["", "lemma compute_zero_pdevs[code]: \"zero_pdevs = Pdevs (zero_slist)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_pdevs = Pdevs zero_slist", "by transfer (auto simp: Pdevs_raw_def)"], ["", "lift_definition One_slist::\"(nat, 'a::executable_euclidean_space) slist\"\n  is \"rev (zip [0..<length (Basis_list::'a list)] (Basis_list::'a list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (rev (zip [0..<length Basis_list] Basis_list))) \\<and>\n    rsorted (map fst (rev (zip [0..<length Basis_list] Basis_list)))", "by (simp add: zip_rev[symmetric])"], ["", "lemma\n  map_of_rev_zip_upto_length_eq_nth:\n  assumes \"i < length B\" \"d = length B\"\n  shows \"(map_of (rev (zip [0..<d] B)) i) = Some (B ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (rev (zip [0..<d] B)) i = Some (B ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (rev (zip [0..<d] B)) i = Some (B ! i)", "have \"length (rev [0..<length B]) = length (rev B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rev [0..<length B]) = length (rev B)", "by simp"], ["proof (state)\nthis:\n  length (rev [0..<length B]) = length (rev B)\n\ngoal (1 subgoal):\n 1. map_of (rev (zip [0..<d] B)) i = Some (B ! i)", "from map_of_zip_is_Some[OF this, of i] assms"], ["proof (chain)\npicking this:\n  (i \\<in> set (rev [0..<length B])) =\n  (\\<exists>y. map_of (zip (rev [0..<length B]) (rev B)) i = Some y)\n  i < length B\n  d = length B", "obtain y where y: \"map_of (zip (rev [0..<length B]) (rev B)) i = Some y\""], ["proof (prove)\nusing this:\n  (i \\<in> set (rev [0..<length B])) =\n  (\\<exists>y. map_of (zip (rev [0..<length B]) (rev B)) i = Some y)\n  i < length B\n  d = length B\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        map_of (zip (rev [0..<length B]) (rev B)) i =\n        Some y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: zip_rev)"], ["proof (state)\nthis:\n  map_of (zip (rev [0..<length B]) (rev B)) i = Some y\n\ngoal (1 subgoal):\n 1. map_of (rev (zip [0..<d] B)) i = Some (B ! i)", "hence \"y = B ! i\""], ["proof (prove)\nusing this:\n  map_of (zip (rev [0..<length B]) (rev B)) i = Some y\n\ngoal (1 subgoal):\n 1. y = B ! i", "by (auto simp: in_set_zip rev_nth)"], ["proof (state)\nthis:\n  y = B ! i\n\ngoal (1 subgoal):\n 1. map_of (rev (zip [0..<d] B)) i = Some (B ! i)", "with y"], ["proof (chain)\npicking this:\n  map_of (zip (rev [0..<length B]) (rev B)) i = Some y\n  y = B ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (zip (rev [0..<length B]) (rev B)) i = Some y\n  y = B ! i\n\ngoal (1 subgoal):\n 1. map_of (rev (zip [0..<d] B)) i = Some (B ! i)", "by (simp add: zip_rev assms)"], ["proof (state)\nthis:\n  map_of (rev (zip [0..<d] B)) i = Some (B ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  map_of_rev_zip_upto_length_eq_None:\n  assumes \"\\<not>i < length B\"\n  assumes \"d = length B\"\n  shows \"(map_of (rev (zip [0..<d] B)) i) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (rev (zip [0..<d] B)) i = None", "using assms"], ["proof (prove)\nusing this:\n  \\<not> i < length B\n  d = length B\n\ngoal (1 subgoal):\n 1. map_of (rev (zip [0..<d] B)) i = None", "by (auto simp: map_of_eq_None_iff in_set_zip)"], ["", "lemma pdevs_apply_One_slist:\n  \"pdevs_apply (Pdevs One_slist) i =\n    (if i < length (Basis_list::'a::executable_euclidean_space list)\n    then (Basis_list::'a list) ! i\n    else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (Pdevs One_slist) i =\n    (if i < length Basis_list then Basis_list ! i else (0::'a))", "by transfer (auto simp: Pdevs_raw_def map_of_rev_zip_upto_length_eq_nth map_of_rev_zip_upto_length_eq_None\n      in_set_zip split: option.split)"], ["", "lemma compute_One_pdevs[code]: \"One_pdevs = Pdevs One_slist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. One_pdevs = Pdevs One_slist", "by (rule pdevs_eqI) (simp add: pdevs_apply_One_slist)"], ["", "lift_definition coord_slist::\"nat \\<Rightarrow> (nat, real) slist\" is \"\\<lambda>i. [(i, 1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       distinct (map fst [(nat, 1)]) \\<and> rsorted (map fst [(nat, 1)])", "by simp"], ["", "lemma compute_coord_pdevs[code]: \"coord_pdevs i = Pdevs (coord_slist i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coord_pdevs i = Pdevs (coord_slist i)", "by transfer (auto simp: Pdevs_raw_def)"], ["", "subsection \\<open>Update\\<close>"], ["", "primrec update_list::\"nat \\<Rightarrow> 'a \\<Rightarrow> (nat * 'a) list \\<Rightarrow> (nat * 'a) list\"\n  where\n  \"update_list n x [] = [(n, x)]\"\n| \"update_list n x (y#ys) =\n    (if n > fst y then (n, x)#y#ys\n    else if n = fst y then (n, x)#ys\n    else y#(update_list n x ys))\""], ["", "lemma map_of_update_list[simp]: \"map_of (update_list n x ys) = (map_of ys)(n:=Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (update_list n x ys) = map_of ys(n \\<mapsto> x)", "by (induct ys) auto"], ["", "lemma in_set_update_listD:\n  assumes \"y \\<in> set (update_list n x ys)\"\n  shows \"y = (n, x) \\<or> (y \\<in> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = (n, x) \\<or> y \\<in> set ys", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> set (update_list n x ys)\n\ngoal (1 subgoal):\n 1. y = (n, x) \\<or> y \\<in> set ys", "by (induct ys) (auto split: if_split_asm)"], ["", "lemma in_set_update_listI:\n  \"y = (n, x) \\<or> (fst y \\<noteq> n \\<and> y \\<in> set ys) \\<Longrightarrow> y \\<in> set (update_list n x ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = (n, x) \\<or>\n    fst y \\<noteq> n \\<and> y \\<in> set ys \\<Longrightarrow>\n    y \\<in> set (update_list n x ys)", "by (induct ys) (auto split: if_split_asm)"], ["", "lemma in_set_update_list: \"(n, x) \\<in> set (update_list n x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n, x) \\<in> set (update_list n x xs)", "by (induct xs) simp_all"], ["", "lemma overwrite_update_list: \"(a, b) \\<in> set xs \\<Longrightarrow> (a, b) \\<notin> set (update_list n x xs) \\<Longrightarrow> a = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> set xs;\n     (a, b) \\<notin> set (update_list n x xs)\\<rbrakk>\n    \\<Longrightarrow> a = n", "by (induct xs) (auto split: if_split_asm)"], ["", "lemma insert_update_list:\n  \"distinct (map fst xs) \\<Longrightarrow> rsorted (map fst xs) \\<Longrightarrow> (a, b) \\<in> set (update_list a x xs) \\<Longrightarrow> b = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); rsorted (map fst xs);\n     (a, b) \\<in> set (update_list a x xs)\\<rbrakk>\n    \\<Longrightarrow> b = x", "by (induct xs) (force split: if_split_asm simp: sorted_append)+"], ["", "lemma set_update_list_eq: \"distinct (map fst xs) \\<Longrightarrow> rsorted (map fst xs) \\<Longrightarrow>\n    set (update_list n x xs) = insert (n, x) (set xs - {x. fst x = n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); rsorted (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> set (update_list n x xs) =\n                      insert (n, x) (set xs - {x. fst x = n})", "by (auto intro!: in_set_update_listI dest: in_set_update_listD simp: insert_update_list)"], ["", "lift_definition update_slist::\"nat \\<Rightarrow> 'a \\<Rightarrow> (nat, 'a) slist \\<Rightarrow> (nat, 'a) slist\" is update_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat a list.\n       distinct (map fst list) \\<and>\n       rsorted (map fst list) \\<Longrightarrow>\n       distinct (map fst (update_list nat a list)) \\<and>\n       rsorted (map fst (update_list nat a list))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat a list.\n       distinct (map fst list) \\<and>\n       rsorted (map fst list) \\<Longrightarrow>\n       distinct (map fst (update_list nat a list)) \\<and>\n       rsorted (map fst (update_list nat a list))", "case (1 n a l)"], ["proof (state)\nthis:\n  distinct (map fst l) \\<and> rsorted (map fst l)\n\ngoal (1 subgoal):\n 1. \\<And>nat a list.\n       distinct (map fst list) \\<and>\n       rsorted (map fst list) \\<Longrightarrow>\n       distinct (map fst (update_list nat a list)) \\<and>\n       rsorted (map fst (update_list nat a list))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst l) \\<and> rsorted (map fst l)\n\ngoal (1 subgoal):\n 1. distinct (map fst (update_list n a l)) \\<and>\n    rsorted (map fst (update_list n a l))", "by (induct l) (force simp: sorted_append distinct_map not_less dest!: in_set_update_listD)+"], ["proof (state)\nthis:\n  distinct (map fst (update_list n a l)) \\<and>\n  rsorted (map fst (update_list n a l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_apply_update_slist: \"pdevs_apply (Pdevs (update_slist n x xs)) i =\n  (if i = n then x else pdevs_apply (Pdevs xs) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (Pdevs (update_slist n x xs)) i =\n    (if i = n then x else pdevs_apply (Pdevs xs) i)", "by transfer (auto simp: Pdevs_raw_def)"], ["", "lemma compute_pdev_upd[code]: \"pdev_upd (Pdevs xs) n x = Pdevs (update_slist n x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdev_upd (Pdevs xs) n x = Pdevs (update_slist n x xs)", "by (rule pdevs_eqI) (auto simp: pdevs_apply_update_slist)"], ["", "subsection \\<open>Approximate Total Deviation\\<close>"], ["", "lift_definition fold_slist::\"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> (nat, 'a::zero) slist \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n  is \"\\<lambda>f xs z. fold (f o snd) (filter (\\<lambda>x. snd x \\<noteq> 0) xs) z\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Pdevs_raw_Cons:\n  \"Pdevs_raw ((a, b) # xs) = (\\<lambda>i. if i = a then b else Pdevs_raw xs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pdevs_raw ((a, b) # xs) =\n    (\\<lambda>i. if i = a then b else Pdevs_raw xs i)", "by (auto simp: Pdevs_raw_def map_of_eq_None_iff\n    dest!: map_of_SomeD\n    split: option.split)"], ["", "lemma zeros_aux: \"- (\\<lambda>i. if i = a then b else Pdevs_raw xs i) -` {0} \\<subseteq>\n  - Pdevs_raw xs -` {0} \\<union> {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<lambda>i. if i = a then b else Pdevs_raw xs i) -` {0::'b}\n    \\<subseteq> - Pdevs_raw xs -` {0::'b} \\<union> {a}", "by auto"], ["", "lemma compute_tdev'[code]:\n  \"tdev' p (Pdevs xs) = fold_slist (\\<lambda>a b. eucl_truncate_up p (\\<bar>a\\<bar> + b)) xs 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev' p (Pdevs xs) =\n    fold_slist (\\<lambda>a b. eucl_truncate_up p (\\<bar>a\\<bar> + b)) xs\n     (0::'a)", "unfolding tdev'_def sum_list'_def compute_list_of_pdevs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>a b. eucl_truncate_up p (a + b))\n     (map (abs \\<circ> snd) (list_of_slist xs)) (0::'a) =\n    fold_slist (\\<lambda>a b. eucl_truncate_up p (\\<bar>a\\<bar> + b)) xs\n     (0::'a)", "by transfer (auto simp: o_def fold_map)"], ["", "subsection \\<open>Equality\\<close>"], ["", "lemma slist_apply_list_of_slist_eq: \"slist_apply a i = the_default 0 (map_of (list_of_slist a) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slist_apply a i = the_default (0::'a) (map_of (list_of_slist a) i)", "by (transfer)\n    (force split: option.split simp: map_of_eq_None_iff distinct_map_fst_snd_eqD\n      dest!: map_of_SomeD)"], ["", "lemma compute_equal_pdevs[code]:\n  \"equal_class.equal (Pdevs a) (Pdevs b) \\<longleftrightarrow> (list_of_slist a) = (list_of_slist b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (Pdevs a) (Pdevs b) =\n    (list_of_slist a = list_of_slist b)", "by (auto intro!: pdevs_eqI simp: equal_pdevs_def compute_pdevs_apply slist_apply_list_of_slist_eq\n    compute_list_of_pdevs[symmetric])"], ["", "subsection \\<open>From List of Generators\\<close>"], ["", "lift_definition slist_of_list::\"'a::zero list \\<Rightarrow> (nat, 'a) slist\"\n  is \"\\<lambda>xs. rev (zip [0..<length xs] xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       distinct (map fst (rev (zip [0..<length list] list))) \\<and>\n       rsorted (map fst (rev (zip [0..<length list] list)))", "by (auto simp: rev_map[symmetric] )"], ["", "lemma slist_apply_slist_of_list:\n  \"slist_apply (slist_of_list xs) i = (if i < length xs then xs ! i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slist_apply (slist_of_list xs) i =\n    (if i < length xs then xs ! i else (0::'a))", "by transfer (auto simp: in_set_zip map_of_rev_zip_upto_length_eq_nth map_of_rev_zip_upto_length_eq_None)"], ["", "lemma compute_pdevs_of_list[code]: \"pdevs_of_list xs = Pdevs (slist_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_list xs = Pdevs (slist_of_list xs)", "by (rule pdevs_eqI)\n    (auto simp: compute_pdevs_apply slist_apply_slist_of_list pdevs_apply_pdevs_of_list)"], ["", "text \\<open>abstraction function which can be used in code equations\\<close>"], ["", "lift_definition abs_slist_if::\"('a::linorder\\<times>'b) list \\<Rightarrow> ('a, 'b) slist\"\n  is \"\\<lambda>list. if distinct (map fst list) \\<and> rsorted (map fst list) then list else []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       distinct\n        (map fst\n          (if distinct (map fst list) \\<and> rsorted (map fst list)\n           then list else [])) \\<and>\n       rsorted\n        (map fst\n          (if distinct (map fst list) \\<and> rsorted (map fst list)\n           then list else []))", "by auto"], ["", "definition \"slist = Abs_slist\""], ["", "lemma [code_post]: \"Abs_slist = slist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_slist = slist", "by (simp add: slist_def)"], ["", "lemma [code]: \"slist = (\\<lambda>xs.\n  (if distinct (map fst xs) \\<and> rsorted (map fst xs) then abs_slist_if xs else Code.abort (STR '''') (\\<lambda>_. slist xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slist =\n    (\\<lambda>xs.\n        if distinct (map fst xs) \\<and> rsorted (map fst xs)\n        then abs_slist_if xs\n        else Code.abort STR '''' (\\<lambda>_. slist xs))", "by (auto simp add: slist_def abs_slist_if.abs_eq)"], ["", "abbreviation \"pdevs \\<equiv> (\\<lambda>x. Pdevs (slist x))\""], ["", "lift_definition nlex_slist::\"(nat, point) slist \\<Rightarrow> (nat, point) slist\" is\n  \"map (\\<lambda>(i, x). (i, if lex 0 x then - x else x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       distinct (map fst list) \\<and>\n       rsorted (map fst list) \\<Longrightarrow>\n       distinct\n        (map fst\n          (map (\\<lambda>(i, x).\n                   (i, if Counterclockwise_2D_Arbitrary.lex 0 x then - x\n                       else x))\n            list)) \\<and>\n       rsorted\n        (map fst\n          (map (\\<lambda>(i, x).\n                   (i, if Counterclockwise_2D_Arbitrary.lex 0 x then - x\n                       else x))\n            list))", "by (auto simp: o_def split_beta')"], ["", "lemma Pdevs_raw_map: \"f 0 = 0 \\<Longrightarrow> Pdevs_raw (map (\\<lambda>(i, x). (i, f x)) xs) i = f (Pdevs_raw xs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (0::'b) = (0::'a) \\<Longrightarrow>\n    Pdevs_raw (map (\\<lambda>(i, x). (i, f x)) xs) i = f (Pdevs_raw xs i)", "by (auto simp: Pdevs_raw_def map_of_map split: option.split)"], ["", "lemma compute_nlex_pdevs[code]: \"nlex_pdevs (Pdevs x) = Pdevs (nlex_slist x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nlex_pdevs (Pdevs x) = Pdevs (nlex_slist x)", "by transfer (auto simp: Pdevs_raw_map)"], ["", "end"]]}