{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Float_Real.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma of_rat_numeral_eq [code_abbrev]:\n  \"real_of_float (numeral w) = Ratreal (numeral w)\"", "lemma zero_real_code [code]:\n  \"0 = real_of_float 0\"", "lemma one_real_code [code]:\n  \"1 = real_of_float 1\"", "lemma [code_abbrev]:\n  \"(real_of_float (of_int a) :: real) = (Ratreal (Rat.of_int a) :: real)\"", "lemma [code_abbrev]:\n  \"real_of_float 0 \\<equiv> Ratreal 0\"", "lemma [code_abbrev]:\n  \"real_of_float 1 = Ratreal 1\"", "lemmas compute_real_of_float[code del]", "lemmas [code del] =\n  real_equal_code\n  real_less_eq_code\n  real_less_code\n  real_plus_code\n  real_times_code\n  real_uminus_code\n  real_minus_code\n  real_inverse_code\n  real_divide_code\n  real_floor_code\n  Float.compute_truncate_down\n  Float.compute_truncate_up", "lemma real_equal_code [code]:\n  \"HOL.equal (real_of_float x) (real_of_float y) \\<longleftrightarrow> HOL.equal x y\"", "lemma real_less_eq_code' [code]: \"real_of_float x \\<le> real_of_float y \\<longleftrightarrow> x \\<le> y\"\n  and real_less_code' [code]: \"real_of_float x < real_of_float y \\<longleftrightarrow> x < y\"\n  and real_plus_code' [code]: \"real_of_float x + real_of_float y = real_of_float (x + y)\"\n  and real_times_code' [code]: \"real_of_float x * real_of_float y = real_of_float (x * y)\"\n  and real_uminus_code' [code]: \"- real_of_float x = real_of_float (- x)\"\n  and real_minus_code' [code]: \"real_of_float x - real_of_float y = real_of_float (x - y)\"\n  and real_inverse_code' [code]: \"inverse (FloatR a b) =\n    (if FloatR a b = 2 then FloatR 1 (-1) else\n    if a = 1 then FloatR 1 (- b) else\n    Code.abort (STR ''inverse not of 2'') (\\<lambda>_. inverse (FloatR a b)))\"\n  and real_divide_code' [code]: \"FloatR a b / FloatR c d =\n    (if FloatR c d = 2 then if a mod 2 = 0 then FloatR (a div 2) b else FloatR a (b - 1) else\n    if c = 1 then FloatR a (b - d) else\n    Code.abort (STR ''division not by 2'') (\\<lambda>_. FloatR a b / FloatR c d))\"\n  and real_floor_code' [code]: \"floor (real_of_float x) = int_floor_fl x\"\n  and real_abs_code' [code]: \"abs (real_of_float x) = real_of_float (abs x)\"", "lemma compute_round_down[code]: \"round_down prec (real_of_float f) = real_of_float (float_down prec f)\"", "lemma compute_round_up[code]: \"round_up prec (real_of_float f) = real_of_float (float_up prec f)\"", "lemma compute_truncate_down[code]:\n  \"truncate_down prec (real_of_float f) = real_of_float (float_round_down prec f)\"", "lemma compute_truncate_up[code]:\n  \"truncate_up prec (real_of_float f) = real_of_float (float_round_up prec f)\"", "lemma [code]: \"real_divl p (real_of_float x) (real_of_float y) = real_of_float (float_divl p x y)\"", "lemma [code]: \"real_divr p (real_of_float x) (real_of_float y) = real_of_float (float_divr p x y)\"", "lemmas [code] = real_of_float_inverse"], "translations": [["", "lemma of_rat_numeral_eq [code_abbrev]:\n  \"real_of_float (numeral w) = Ratreal (numeral w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float (numeral w) = Ratreal (numeral w)", "by simp"], ["", "lemma zero_real_code [code]:\n  \"0 = real_of_float 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = real_of_float 0", "by simp"], ["", "lemma one_real_code [code]:\n  \"1 = real_of_float 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = real_of_float 1", "by simp"], ["", "lemma [code_abbrev]:\n  \"(real_of_float (of_int a) :: real) = (Ratreal (Rat.of_int a) :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float (float_of_int a) = Ratreal (Rat.of_int a)", "by (auto simp: Rat.of_int_def )"], ["", "lemma [code_abbrev]:\n  \"real_of_float 0 \\<equiv> Ratreal 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float 0 \\<equiv> Ratreal 0", "by simp"], ["", "lemma [code_abbrev]:\n  \"real_of_float 1 = Ratreal 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float 1 = Ratreal 1", "by simp"], ["", "lemmas compute_real_of_float[code del]"], ["", "lemmas [code del] =\n  real_equal_code\n  real_less_eq_code\n  real_less_code\n  real_plus_code\n  real_times_code\n  real_uminus_code\n  real_minus_code\n  real_inverse_code\n  real_divide_code\n  real_floor_code\n  Float.compute_truncate_down\n  Float.compute_truncate_up"], ["", "lemma real_equal_code [code]:\n  \"HOL.equal (real_of_float x) (real_of_float y) \\<longleftrightarrow> HOL.equal x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (real_of_float x) (real_of_float y) =\n    equal_class.equal x y", "by (metis (poly_guards_query) equal real_of_float_inverse)"], ["", "abbreviation FloatR::\"int\\<Rightarrow>int\\<Rightarrow>real\" where\n  \"FloatR a b \\<equiv> real_of_float (Float a b)\""], ["", "lemma real_less_eq_code' [code]: \"real_of_float x \\<le> real_of_float y \\<longleftrightarrow> x \\<le> y\"\n  and real_less_code' [code]: \"real_of_float x < real_of_float y \\<longleftrightarrow> x < y\"\n  and real_plus_code' [code]: \"real_of_float x + real_of_float y = real_of_float (x + y)\"\n  and real_times_code' [code]: \"real_of_float x * real_of_float y = real_of_float (x * y)\"\n  and real_uminus_code' [code]: \"- real_of_float x = real_of_float (- x)\"\n  and real_minus_code' [code]: \"real_of_float x - real_of_float y = real_of_float (x - y)\"\n  and real_inverse_code' [code]: \"inverse (FloatR a b) =\n    (if FloatR a b = 2 then FloatR 1 (-1) else\n    if a = 1 then FloatR 1 (- b) else\n    Code.abort (STR ''inverse not of 2'') (\\<lambda>_. inverse (FloatR a b)))\"\n  and real_divide_code' [code]: \"FloatR a b / FloatR c d =\n    (if FloatR c d = 2 then if a mod 2 = 0 then FloatR (a div 2) b else FloatR a (b - 1) else\n    if c = 1 then FloatR a (b - d) else\n    Code.abort (STR ''division not by 2'') (\\<lambda>_. FloatR a b / FloatR c d))\"\n  and real_floor_code' [code]: \"floor (real_of_float x) = int_floor_fl x\"\n  and real_abs_code' [code]: \"abs (real_of_float x) = real_of_float (abs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((real_of_float x \\<le> real_of_float y) = (x \\<le> y) &&&\n      (real_of_float x < real_of_float y) = (x < y)) &&&\n     real_of_float x + real_of_float y = real_of_float (x + y) &&&\n     real_of_float x * real_of_float y = real_of_float (x * y) &&&\n     - real_of_float x = real_of_float (- x)) &&&\n    (real_of_float x - real_of_float y = real_of_float (x - y) &&&\n     inverse (FloatR a b) =\n     (if FloatR a b = 2 then FloatR 1 (- 1)\n      else if a = 1 then FloatR 1 (- b)\n           else Code.abort STR ''inverse not of 2''\n                 (\\<lambda>_. inverse (FloatR a b)))) &&&\n    FloatR a b / FloatR c d =\n    (if FloatR c d = 2\n     then if a mod 2 = 0 then FloatR (a div 2) b else FloatR a (b - 1)\n     else if c = 1 then FloatR a (b - d)\n          else Code.abort STR ''division not by 2''\n                (\\<lambda>_. FloatR a b / FloatR c d)) &&&\n    \\<lfloor>real_of_float x\\<rfloor> = int_floor_fl x &&&\n    \\<bar>real_of_float x\\<bar> = real_of_float \\<bar>x\\<bar>", "by (auto simp add: int_floor_fl.rep_eq powr_diff powr_minus inverse_eq_divide)"], ["", "lemma compute_round_down[code]: \"round_down prec (real_of_float f) = real_of_float (float_down prec f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_down prec (real_of_float f) = real_of_float (float_down prec f)", "by simp"], ["", "lemma compute_round_up[code]: \"round_up prec (real_of_float f) = real_of_float (float_up prec f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_up prec (real_of_float f) = real_of_float (float_up prec f)", "by simp"], ["", "lemma compute_truncate_down[code]:\n  \"truncate_down prec (real_of_float f) = real_of_float (float_round_down prec f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. truncate_down prec (real_of_float f) =\n    real_of_float (float_round_down prec f)", "by (simp add: Float.float_round_down.rep_eq truncate_down_def)"], ["", "lemma compute_truncate_up[code]:\n  \"truncate_up prec (real_of_float f) = real_of_float (float_round_up prec f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. truncate_up prec (real_of_float f) =\n    real_of_float (float_round_up prec f)", "by (simp add: float_round_up.rep_eq truncate_up_def)"], ["", "lemma [code]: \"real_divl p (real_of_float x) (real_of_float y) = real_of_float (float_divl p x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_divl p (real_of_float x) (real_of_float y) =\n    real_of_float (float_divl p x y)", "by (simp add: float_divl.rep_eq real_divl_def)"], ["", "lemma [code]: \"real_divr p (real_of_float x) (real_of_float y) = real_of_float (float_divr p x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_divr p (real_of_float x) (real_of_float y) =\n    real_of_float (float_divr p x y)", "by (simp add: float_divr.rep_eq real_divr_def)"], ["", "lemmas [code] = real_of_float_inverse"], ["", "end"]]}