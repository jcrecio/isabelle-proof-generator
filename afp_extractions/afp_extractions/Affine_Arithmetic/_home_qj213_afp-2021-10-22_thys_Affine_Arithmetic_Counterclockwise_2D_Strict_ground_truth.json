{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Counterclockwise_2D_Strict.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma det3_def':\n  \"det3 p q r = fst p * snd q + snd p * fst r + fst q * snd r -\n    snd q * fst r - snd p * fst q - fst p * snd r\"", "lemma det3_eq_det: \"det3 (xa, ya) (xb, yb) (xc, yc) =\n  det (vector [vector [xa, ya, 1], vector [xb, yb, 1], vector [xc, yc, 1]]::real^3^3)\"", "lemma det3_self23[simp]: \"det3 a b b = 0\"\n  and det3_self12[simp]: \"det3 b b a = 0\"", "lemma\n  coll_ex_scaling:\n  assumes \"b \\<noteq> c\"\n  assumes d: \"det3 a b c = 0\"\n  shows \"\\<exists>r. a = b + r *\\<^sub>R (c - b)\"", "lemma cramer: \"\\<not>det3 s t q = 0 \\<Longrightarrow>\n  (det3 t p r) = ((det3 t q r) * (det3 s t p) + (det3 t p q) * (det3 s t r))/(det3 s t q)\"", "lemma convex_comb_dets:\n  assumes \"det3 p q r > 0\"\n  shows \"s = (det3 s q r / det3 p q r) *\\<^sub>R p + (det3 p s r /  det3 p q r) *\\<^sub>R q +\n      (det3 p q s / det3 p q r) *\\<^sub>R r\"\n    (is \"?lhs = ?rhs\")", "lemma four_points_aligned:\n  assumes c: \"det3 t p q = 0\" \"det3 t q r = 0\"\n  assumes distinct: \"distinct5 t s p q r\"\n  shows \"det3 t r p = 0\" \"det3 p q r = 0\"", "lemma det_identity:\n  \"det3 t p q * det3 t s r + det3 t q r * det3 t s p + det3 t r p * det3 t s q = 0\"", "lemma det3_eq_zeroI:\n  assumes \"p = q + x *\\<^sub>R (t - q)\"\n  shows \"det3 q t p = 0\"", "lemma det3_rotate: \"det3 a b c = det3 c a b\"", "lemma det3_switch: \"det3 a b c = - det3 a c b\"", "lemma det3_switch': \"det3 a b c = - det3 b a c\"", "lemma det3_pos_transitive_coll:\n  \"det3 t s p > 0 \\<Longrightarrow> det3 t s r \\<ge> 0 \\<Longrightarrow> det3 t p q \\<ge> 0 \\<Longrightarrow>\n  det3 t q r > 0 \\<Longrightarrow> det3 t s q = 0 \\<Longrightarrow> det3 t p r > 0\"", "lemma det3_pos_transitive:\n  \"det3 t s p > 0 \\<Longrightarrow> det3 t s q \\<ge> 0 \\<Longrightarrow> det3 t s r \\<ge> 0 \\<Longrightarrow> det3 t p q \\<ge> 0 \\<Longrightarrow>\n  det3 t q r > 0 \\<Longrightarrow> det3 t p r > 0\"", "lemma det3_zero_translate_plus[simp]: \"det3 (a + x) (b + x) (c + x) = 0 \\<longleftrightarrow> det3 a b c = 0\"", "lemma det3_zero_translate_plus'[simp]: \"det3 (a) (a + b) (a + c) = 0 \\<longleftrightarrow> det3 0 b c = 0\"", "lemma\n  det30_zero_scaleR1:\n  \"0 < e \\<Longrightarrow> det3 0 xr P = 0 \\<Longrightarrow> det3 0 (e *\\<^sub>R xr) P = 0\"", "lemma det3_same[simp]: \"det3 a x x = 0\"", "lemma\n  det30_zero_scaleR2:\n  \"0 < e \\<Longrightarrow> det3 0 P xr = 0 \\<Longrightarrow> det3 0 P (e *\\<^sub>R xr) = 0\"", "lemma det3_eq_zero: \"e \\<noteq> 0 \\<Longrightarrow> det3 0 xr (e *\\<^sub>R Q) = 0 \\<longleftrightarrow> det3 0 xr Q = 0\"", "lemma det30_plus_scaled3[simp]: \"det3 0 a (b + x *\\<^sub>R a) = 0 \\<longleftrightarrow> det3 0 a b = 0\"", "lemma det30_plus_scaled2[simp]:\n  shows \"det3 0 (a + x *\\<^sub>R a) b = 0 \\<longleftrightarrow> (if x = -1 then True else det3 0 a b = 0)\"\n    (is \"?lhs = ?rhs\")", "lemma det30_uminus2[simp]: \"det3 0 (-a) (b) = 0 \\<longleftrightarrow> det3 0 a b = 0\"\n  and det30_uminus3[simp]: \"det3 0 a (-b) = 0 \\<longleftrightarrow> det3 0 a b = 0\"", "lemma det30_minus_scaled3[simp]: \"det3 0 a (b - x *\\<^sub>R a) = 0 \\<longleftrightarrow> det3 0 a b = 0\"", "lemma det30_scaled_minus3[simp]: \"det3 0 a (e *\\<^sub>R a - b) = 0 \\<longleftrightarrow> det3 0 a b = 0\"", "lemma det30_minus_scaled2[simp]:\n  \"det3 0 (a - x *\\<^sub>R a) b = 0 \\<longleftrightarrow> (if x = 1 then True else det3 0 a b = 0)\"", "lemma det3_nonneg_scaleR1:\n  \"0 < e \\<Longrightarrow> det3 0 xr P \\<ge> 0 \\<Longrightarrow> det3 0 (e*\\<^sub>Rxr) P \\<ge> 0\"", "lemma det3_nonneg_scaleR1_eq:\n  \"0 < e \\<Longrightarrow> det3 0 (e*\\<^sub>Rxr) P \\<ge> 0 \\<longleftrightarrow> det3 0 xr P \\<ge> 0\"", "lemma det3_translate_origin: \"NO_MATCH 0 p \\<Longrightarrow> det3 p q r = det3 0 (q - p) (r - p)\"", "lemma det3_nonneg_scaleR_segment2:\n  assumes \"det3 x y z \\<ge> 0\"\n  assumes \"a > 0\"\n  shows \"det3 x ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) z \\<ge> 0\"", "lemma det3_nonneg_scaleR_segment1:\n  assumes \"det3 x y z \\<ge> 0\"\n  assumes \"0 \\<le> a\" \"a < 1\"\n  shows \"det3 ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) y z \\<ge> 0\"", "lemma ccw'_contra: \"ccw' t r q \\<Longrightarrow> ccw' t q r = False\"", "lemma not_ccw'_eq: \"\\<not> ccw' t p s \\<longleftrightarrow> ccw' t s p \\<or> det3 t s p = 0\"", "lemma neq_left_right_of: \"ccw' a b c \\<Longrightarrow> ccw' a c d \\<Longrightarrow> b \\<noteq> d\"", "lemma ccw'_subst_collinear:\n  assumes \"det3 t r s = 0\"\n  assumes \"s \\<noteq> t\"\n  assumes \"ccw' t r p\"\n  shows \"ccw' t s p \\<or> ccw' t p s\"", "lemma ccw'_sorted_scaleR: \"ccw'.sortedP 0 xs \\<Longrightarrow> r > 0 \\<Longrightarrow> ccw'.sortedP 0 (map ((*\\<^sub>R) r) xs)\"", "lemma coll_zero[intro, simp]: \"coll 0 z 0\"", "lemma coll_zero1[intro, simp]: \"coll 0 0 z\"", "lemma coll_self[intro, simp]: \"coll 0 z z\"", "lemma ccw'_not_coll:\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll a b c\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll a c b\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll b a c\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll b c a\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll c a b\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll c b a\"", "lemma coll_add: \"coll 0 x y \\<Longrightarrow> coll 0 x z \\<Longrightarrow> coll 0 x (y + z)\"", "lemma coll_scaleR_left_eq[simp]: \"coll 0 (r *\\<^sub>R x) y \\<longleftrightarrow> r = 0 \\<or> coll 0 x y\"", "lemma coll_scaleR_right_eq[simp]: \"coll 0 y (r *\\<^sub>R x) \\<longleftrightarrow> r = 0 \\<or> coll 0 y x\"", "lemma coll_scaleR: \"coll 0 x y \\<Longrightarrow> coll 0 (r *\\<^sub>R x) y\"", "lemma coll_sum_list: \"(\\<And>y. y \\<in> set ys \\<Longrightarrow> coll 0 x y) \\<Longrightarrow> coll 0 x (sum_list ys)\"", "lemma scaleR_left_normalize:\n  fixes a ::real and b c::\"'a::real_vector\"\n  shows \"a *\\<^sub>R b = c \\<longleftrightarrow> (if a = 0 then c = 0 else b = c /\\<^sub>R a)\"", "lemma coll_scale_pair: \"coll 0 (a, b) (c, d) \\<Longrightarrow> (a, b) \\<noteq> 0 \\<Longrightarrow> (\\<exists>x. (c, d) = x *\\<^sub>R (a, b))\"", "lemma coll_scale: \"coll 0 r q \\<Longrightarrow> r \\<noteq> 0 \\<Longrightarrow> (\\<exists>x. q = x *\\<^sub>R r)\"", "lemma coll_add_trans:\n  assumes \"coll 0 x (y + z)\"\n  assumes \"coll 0 y z\"\n  assumes \"x \\<noteq> 0\"\n  assumes \"y \\<noteq> 0\"\n  assumes \"z \\<noteq> 0\"\n  assumes \"y + z \\<noteq> 0\"\n  shows \"coll 0 x z\"", "lemma coll_commute: \"coll 0 a b \\<longleftrightarrow> coll 0 b a\"", "lemma coll_add_cancel: \"coll 0 a (a + b) \\<Longrightarrow> coll 0 a b\"", "lemma coll_trans:\n  \"coll 0 a b \\<Longrightarrow> coll 0 a c \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> coll 0 b c\"", "lemma sum_list_posI:\n  fixes xs::\"'a::ordered_comm_monoid_add list\"\n  shows \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x > 0) \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> sum_list xs > 0\"", "lemma nonzero_fstI[intro, simp]: \"fst x \\<noteq> 0 \\<Longrightarrow> x \\<noteq> 0\"\n  and nonzero_sndI[intro, simp]: \"snd x \\<noteq> 0 \\<Longrightarrow> x \\<noteq> 0\"", "lemma coll_sum_list_trans:\n  \"xs \\<noteq> [] \\<Longrightarrow> coll 0 a (sum_list xs) \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y) \\<Longrightarrow>\n    (\\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs)) \\<Longrightarrow>\n    (\\<And>x. x \\<in> set xs \\<Longrightarrow> snd x > 0) \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> coll 0 a y\"", "lemma sum_list_coll_ex_scale:\n  assumes coll: \"\\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 z x\"\n  assumes nz: \"z \\<noteq> 0\"\n  shows \"\\<exists>r. sum_list xs = r *\\<^sub>R z\"", "lemma sum_list_filter_coll_ex_scale: \"z \\<noteq> 0 \\<Longrightarrow> \\<exists>r. sum_list (filter (coll 0 z) zs) = r *\\<^sub>R z\""], "translations": [["", "lemma det3_def':\n  \"det3 p q r = fst p * snd q + snd p * fst r + fst q * snd r -\n    snd q * fst r - snd p * fst q - fst p * snd r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 p q r =\n    fst p * snd q + snd p * fst r + fst q * snd r - snd q * fst r -\n    snd p * fst q -\n    fst p * snd r", "by (cases p q r rule: prod.exhaust[case_product prod.exhaust[case_product prod.exhaust]]) auto"], ["", "lemma det3_eq_det: \"det3 (xa, ya) (xb, yb) (xc, yc) =\n  det (vector [vector [xa, ya, 1], vector [xb, yb, 1], vector [xc, yc, 1]]::real^3^3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 (xa, ya) (xb, yb) (xc, yc) =\n    det (vector\n          [vector [xa, ya, 1], vector [xb, yb, 1], vector [xc, yc, 1]])", "unfolding Determinants.det_def UNIV_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 (xa, ya) (xb, yb) (xc, yc) =\n    (\\<Sum>p | p permutes {1, 2, 3}.\n       real_of_int (sign p) *\n       (\\<Prod>i\\<in>{1, 2, 3}.\n          vector\n           [vector [xa, ya, 1], vector [xb, yb, 1], vector [xc, yc, 1]] $\n          i $\n          p i))", "by (auto simp: sum_over_permutations_insert\n    vector_3 sign_swap_id permutation_swap_id sign_compose)"], ["", "declare det3.simps[simp del]"], ["", "lemma det3_self23[simp]: \"det3 a b b = 0\"\n  and det3_self12[simp]: \"det3 b b a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 a b b = 0 &&& det3 b b a = 0", "by (auto simp: det3_def')"], ["", "lemma\n  coll_ex_scaling:\n  assumes \"b \\<noteq> c\"\n  assumes d: \"det3 a b c = 0\"\n  shows \"\\<exists>r. a = b + r *\\<^sub>R (c - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. a = b + r *\\<^sub>R (c - b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. a = b + r *\\<^sub>R (c - b)", "from assms"], ["proof (chain)\npicking this:\n  b \\<noteq> c\n  det3 a b c = 0", "have \"fst b \\<noteq> fst c \\<or> snd b \\<noteq> snd c\""], ["proof (prove)\nusing this:\n  b \\<noteq> c\n  det3 a b c = 0\n\ngoal (1 subgoal):\n 1. fst b \\<noteq> fst c \\<or> snd b \\<noteq> snd c", "by (auto simp: prod_eq_iff)"], ["proof (state)\nthis:\n  fst b \\<noteq> fst c \\<or> snd b \\<noteq> snd c\n\ngoal (1 subgoal):\n 1. \\<exists>r. a = b + r *\\<^sub>R (c - b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst b \\<noteq> fst c \\<or> snd b \\<noteq> snd c\n\ngoal (1 subgoal):\n 1. \\<exists>r. a = b + r *\\<^sub>R (c - b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "assume neq: \"fst b \\<noteq> fst c\""], ["proof (state)\nthis:\n  fst b \\<noteq> fst c\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "with d"], ["proof (chain)\npicking this:\n  det3 a b c = 0\n  fst b \\<noteq> fst c", "have \"snd a = ((fst a - fst b) * snd c + (fst c - fst a) * snd b) / (fst c - fst b)\""], ["proof (prove)\nusing this:\n  det3 a b c = 0\n  fst b \\<noteq> fst c\n\ngoal (1 subgoal):\n 1. snd a =\n    ((fst a - fst b) * snd c + (fst c - fst a) * snd b) / (fst c - fst b)", "by (auto simp: det3_def' field_simps)"], ["proof (state)\nthis:\n  snd a =\n  ((fst a - fst b) * snd c + (fst c - fst a) * snd b) / (fst c - fst b)\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "hence \"snd a = ((fst a - fst b)/ (fst c - fst b)) * snd c +\n      ((fst c - fst a)/ (fst c - fst b)) * snd b\""], ["proof (prove)\nusing this:\n  snd a =\n  ((fst a - fst b) * snd c + (fst c - fst a) * snd b) / (fst c - fst b)\n\ngoal (1 subgoal):\n 1. snd a =\n    (fst a - fst b) / (fst c - fst b) * snd c +\n    (fst c - fst a) / (fst c - fst b) * snd b", "by (simp add: add_divide_distrib)"], ["proof (state)\nthis:\n  snd a =\n  (fst a - fst b) / (fst c - fst b) * snd c +\n  (fst c - fst a) / (fst c - fst b) * snd b\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "hence \"snd a = snd b + (fst a - fst b) * snd c / (fst c - fst b) +\n      ((fst c - fst a) - (fst c - fst b)) * snd b / (fst c - fst b)\""], ["proof (prove)\nusing this:\n  snd a =\n  (fst a - fst b) / (fst c - fst b) * snd c +\n  (fst c - fst a) / (fst c - fst b) * snd b\n\ngoal (1 subgoal):\n 1. snd a =\n    snd b + (fst a - fst b) * snd c / (fst c - fst b) +\n    (fst c - fst a - (fst c - fst b)) * snd b / (fst c - fst b)", "using neq"], ["proof (prove)\nusing this:\n  snd a =\n  (fst a - fst b) / (fst c - fst b) * snd c +\n  (fst c - fst a) / (fst c - fst b) * snd b\n  fst b \\<noteq> fst c\n\ngoal (1 subgoal):\n 1. snd a =\n    snd b + (fst a - fst b) * snd c / (fst c - fst b) +\n    (fst c - fst a - (fst c - fst b)) * snd b / (fst c - fst b)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  snd a =\n  snd b + (fst a - fst b) * snd c / (fst c - fst b) +\n  (fst c - fst a - (fst c - fst b)) * snd b / (fst c - fst b)\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "hence \"snd a = snd b + ((fst a - fst b) * snd c + (- fst a + fst b) * snd b) / (fst c - fst b)\""], ["proof (prove)\nusing this:\n  snd a =\n  snd b + (fst a - fst b) * snd c / (fst c - fst b) +\n  (fst c - fst a - (fst c - fst b)) * snd b / (fst c - fst b)\n\ngoal (1 subgoal):\n 1. snd a =\n    snd b +\n    ((fst a - fst b) * snd c + (- fst a + fst b) * snd b) / (fst c - fst b)", "unfolding add_divide_distrib"], ["proof (prove)\nusing this:\n  snd a =\n  snd b + (fst a - fst b) * snd c / (fst c - fst b) +\n  (fst c - fst a - (fst c - fst b)) * snd b / (fst c - fst b)\n\ngoal (1 subgoal):\n 1. snd a =\n    snd b +\n    ((fst a - fst b) * snd c / (fst c - fst b) +\n     (- fst a + fst b) * snd b / (fst c - fst b))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  snd a =\n  snd b +\n  ((fst a - fst b) * snd c + (- fst a + fst b) * snd b) / (fst c - fst b)\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "also"], ["proof (state)\nthis:\n  snd a =\n  snd b +\n  ((fst a - fst b) * snd c + (- fst a + fst b) * snd b) / (fst c - fst b)\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "have \"(fst a - fst b) * snd c + (- fst a + fst b) * snd b = (fst a - fst b) * (snd c - snd b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst a - fst b) * snd c + (- fst a + fst b) * snd b =\n    (fst a - fst b) * (snd c - snd b)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (fst a - fst b) * snd c + (- fst a + fst b) * snd b =\n  (fst a - fst b) * (snd c - snd b)\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "finally"], ["proof (chain)\npicking this:\n  snd a = snd b + (fst a - fst b) * (snd c - snd b) / (fst c - fst b)", "have \"snd a = snd b + (fst a - fst b) / (fst c - fst b) * (snd c - snd b)\""], ["proof (prove)\nusing this:\n  snd a = snd b + (fst a - fst b) * (snd c - snd b) / (fst c - fst b)\n\ngoal (1 subgoal):\n 1. snd a = snd b + (fst a - fst b) / (fst c - fst b) * (snd c - snd b)", "by simp"], ["proof (state)\nthis:\n  snd a = snd b + (fst a - fst b) / (fst c - fst b) * (snd c - snd b)\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "moreover"], ["proof (state)\nthis:\n  snd a = snd b + (fst a - fst b) / (fst c - fst b) * (snd c - snd b)\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "hence \"fst a = fst b + (fst a - fst b) / (fst c - fst b) * (fst c - fst b)\""], ["proof (prove)\nusing this:\n  snd a = snd b + (fst a - fst b) / (fst c - fst b) * (snd c - snd b)\n\ngoal (1 subgoal):\n 1. fst a = fst b + (fst a - fst b) / (fst c - fst b) * (fst c - fst b)", "using neq"], ["proof (prove)\nusing this:\n  snd a = snd b + (fst a - fst b) / (fst c - fst b) * (snd c - snd b)\n  fst b \\<noteq> fst c\n\ngoal (1 subgoal):\n 1. fst a = fst b + (fst a - fst b) / (fst c - fst b) * (fst c - fst b)", "by simp"], ["proof (state)\nthis:\n  fst a = fst b + (fst a - fst b) / (fst c - fst b) * (fst c - fst b)\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "ultimately"], ["proof (chain)\npicking this:\n  snd a = snd b + (fst a - fst b) / (fst c - fst b) * (snd c - snd b)\n  fst a = fst b + (fst a - fst b) / (fst c - fst b) * (fst c - fst b)", "have \"a = b + ((fst a - fst b) / (fst c - fst b)) *\\<^sub>R (c - b)\""], ["proof (prove)\nusing this:\n  snd a = snd b + (fst a - fst b) / (fst c - fst b) * (snd c - snd b)\n  fst a = fst b + (fst a - fst b) / (fst c - fst b) * (fst c - fst b)\n\ngoal (1 subgoal):\n 1. a = b + ((fst a - fst b) / (fst c - fst b)) *\\<^sub>R (c - b)", "by (auto simp: prod_eq_iff)"], ["proof (state)\nthis:\n  a = b + ((fst a - fst b) / (fst c - fst b)) *\\<^sub>R (c - b)\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> fst c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)\n 2. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = b + ((fst a - fst b) / (fst c - fst b)) *\\<^sub>R (c - b)\n\ngoal (1 subgoal):\n 1. \\<exists>r. a = b + r *\\<^sub>R (c - b)", "by blast"], ["proof (state)\nthis:\n  \\<exists>r. a = b + r *\\<^sub>R (c - b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "assume neq: \"snd b \\<noteq> snd c\""], ["proof (state)\nthis:\n  snd b \\<noteq> snd c\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "with d"], ["proof (chain)\npicking this:\n  det3 a b c = 0\n  snd b \\<noteq> snd c", "have \"fst a = ((snd a - snd b) * fst c + (snd c - snd a) * fst b) / (snd c - snd b)\""], ["proof (prove)\nusing this:\n  det3 a b c = 0\n  snd b \\<noteq> snd c\n\ngoal (1 subgoal):\n 1. fst a =\n    ((snd a - snd b) * fst c + (snd c - snd a) * fst b) / (snd c - snd b)", "by (auto simp: det3_def' field_simps)"], ["proof (state)\nthis:\n  fst a =\n  ((snd a - snd b) * fst c + (snd c - snd a) * fst b) / (snd c - snd b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "hence \"fst a = ((snd a - snd b)/ (snd c - snd b)) * fst c +\n      ((snd c - snd a)/ (snd c - snd b)) * fst b\""], ["proof (prove)\nusing this:\n  fst a =\n  ((snd a - snd b) * fst c + (snd c - snd a) * fst b) / (snd c - snd b)\n\ngoal (1 subgoal):\n 1. fst a =\n    (snd a - snd b) / (snd c - snd b) * fst c +\n    (snd c - snd a) / (snd c - snd b) * fst b", "by (simp add: add_divide_distrib)"], ["proof (state)\nthis:\n  fst a =\n  (snd a - snd b) / (snd c - snd b) * fst c +\n  (snd c - snd a) / (snd c - snd b) * fst b\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "hence \"fst a = fst b + (snd a - snd b) * fst c / (snd c - snd b) +\n      ((snd c - snd a) - (snd c - snd b)) * fst b / (snd c - snd b)\""], ["proof (prove)\nusing this:\n  fst a =\n  (snd a - snd b) / (snd c - snd b) * fst c +\n  (snd c - snd a) / (snd c - snd b) * fst b\n\ngoal (1 subgoal):\n 1. fst a =\n    fst b + (snd a - snd b) * fst c / (snd c - snd b) +\n    (snd c - snd a - (snd c - snd b)) * fst b / (snd c - snd b)", "using neq"], ["proof (prove)\nusing this:\n  fst a =\n  (snd a - snd b) / (snd c - snd b) * fst c +\n  (snd c - snd a) / (snd c - snd b) * fst b\n  snd b \\<noteq> snd c\n\ngoal (1 subgoal):\n 1. fst a =\n    fst b + (snd a - snd b) * fst c / (snd c - snd b) +\n    (snd c - snd a - (snd c - snd b)) * fst b / (snd c - snd b)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  fst a =\n  fst b + (snd a - snd b) * fst c / (snd c - snd b) +\n  (snd c - snd a - (snd c - snd b)) * fst b / (snd c - snd b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "hence \"fst a = fst b + ((snd a - snd b) * fst c + (- snd a + snd b) * fst b) / (snd c - snd b)\""], ["proof (prove)\nusing this:\n  fst a =\n  fst b + (snd a - snd b) * fst c / (snd c - snd b) +\n  (snd c - snd a - (snd c - snd b)) * fst b / (snd c - snd b)\n\ngoal (1 subgoal):\n 1. fst a =\n    fst b +\n    ((snd a - snd b) * fst c + (- snd a + snd b) * fst b) / (snd c - snd b)", "unfolding add_divide_distrib"], ["proof (prove)\nusing this:\n  fst a =\n  fst b + (snd a - snd b) * fst c / (snd c - snd b) +\n  (snd c - snd a - (snd c - snd b)) * fst b / (snd c - snd b)\n\ngoal (1 subgoal):\n 1. fst a =\n    fst b +\n    ((snd a - snd b) * fst c / (snd c - snd b) +\n     (- snd a + snd b) * fst b / (snd c - snd b))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  fst a =\n  fst b +\n  ((snd a - snd b) * fst c + (- snd a + snd b) * fst b) / (snd c - snd b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "also"], ["proof (state)\nthis:\n  fst a =\n  fst b +\n  ((snd a - snd b) * fst c + (- snd a + snd b) * fst b) / (snd c - snd b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "have \"(snd a - snd b) * fst c + (- snd a + snd b) * fst b = (snd a - snd b) * (fst c - fst b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd a - snd b) * fst c + (- snd a + snd b) * fst b =\n    (snd a - snd b) * (fst c - fst b)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (snd a - snd b) * fst c + (- snd a + snd b) * fst b =\n  (snd a - snd b) * (fst c - fst b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "finally"], ["proof (chain)\npicking this:\n  fst a = fst b + (snd a - snd b) * (fst c - fst b) / (snd c - snd b)", "have \"fst a = fst b + (snd a - snd b) / (snd c - snd b) * (fst c - fst b)\""], ["proof (prove)\nusing this:\n  fst a = fst b + (snd a - snd b) * (fst c - fst b) / (snd c - snd b)\n\ngoal (1 subgoal):\n 1. fst a = fst b + (snd a - snd b) / (snd c - snd b) * (fst c - fst b)", "by simp"], ["proof (state)\nthis:\n  fst a = fst b + (snd a - snd b) / (snd c - snd b) * (fst c - fst b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "moreover"], ["proof (state)\nthis:\n  fst a = fst b + (snd a - snd b) / (snd c - snd b) * (fst c - fst b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "hence \"snd a = snd b + (snd a - snd b) / (snd c - snd b) * (snd c - snd b)\""], ["proof (prove)\nusing this:\n  fst a = fst b + (snd a - snd b) / (snd c - snd b) * (fst c - fst b)\n\ngoal (1 subgoal):\n 1. snd a = snd b + (snd a - snd b) / (snd c - snd b) * (snd c - snd b)", "using neq"], ["proof (prove)\nusing this:\n  fst a = fst b + (snd a - snd b) / (snd c - snd b) * (fst c - fst b)\n  snd b \\<noteq> snd c\n\ngoal (1 subgoal):\n 1. snd a = snd b + (snd a - snd b) / (snd c - snd b) * (snd c - snd b)", "by simp"], ["proof (state)\nthis:\n  snd a = snd b + (snd a - snd b) / (snd c - snd b) * (snd c - snd b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "ultimately"], ["proof (chain)\npicking this:\n  fst a = fst b + (snd a - snd b) / (snd c - snd b) * (fst c - fst b)\n  snd a = snd b + (snd a - snd b) / (snd c - snd b) * (snd c - snd b)", "have \"a = b + ((snd a - snd b) / (snd c - snd b)) *\\<^sub>R (c - b)\""], ["proof (prove)\nusing this:\n  fst a = fst b + (snd a - snd b) / (snd c - snd b) * (fst c - fst b)\n  snd a = snd b + (snd a - snd b) / (snd c - snd b) * (snd c - snd b)\n\ngoal (1 subgoal):\n 1. a = b + ((snd a - snd b) / (snd c - snd b)) *\\<^sub>R (c - b)", "by (auto simp: prod_eq_iff)"], ["proof (state)\nthis:\n  a = b + ((snd a - snd b) / (snd c - snd b)) *\\<^sub>R (c - b)\n\ngoal (1 subgoal):\n 1. snd b \\<noteq> snd c \\<Longrightarrow>\n    \\<exists>r. a = b + r *\\<^sub>R (c - b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = b + ((snd a - snd b) / (snd c - snd b)) *\\<^sub>R (c - b)\n\ngoal (1 subgoal):\n 1. \\<exists>r. a = b + r *\\<^sub>R (c - b)", "by blast"], ["proof (state)\nthis:\n  \\<exists>r. a = b + r *\\<^sub>R (c - b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r. a = b + r *\\<^sub>R (c - b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cramer: \"\\<not>det3 s t q = 0 \\<Longrightarrow>\n  (det3 t p r) = ((det3 t q r) * (det3 s t p) + (det3 t p q) * (det3 s t r))/(det3 s t q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 s t q \\<noteq> 0 \\<Longrightarrow>\n    det3 t p r =\n    (det3 t q r * det3 s t p + det3 t p q * det3 s t r) / det3 s t q", "by (auto simp: det3_def' field_simps)"], ["", "lemma convex_comb_dets:\n  assumes \"det3 p q r > 0\"\n  shows \"s = (det3 s q r / det3 p q r) *\\<^sub>R p + (det3 p s r /  det3 p q r) *\\<^sub>R q +\n      (det3 p q s / det3 p q r) *\\<^sub>R r\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. s =\n    (det3 s q r / det3 p q r) *\\<^sub>R p +\n    (det3 p s r / det3 p q r) *\\<^sub>R q +\n    (det3 p q s / det3 p q r) *\\<^sub>R r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s =\n    (det3 s q r / det3 p q r) *\\<^sub>R p +\n    (det3 p s r / det3 p q r) *\\<^sub>R q +\n    (det3 p q s / det3 p q r) *\\<^sub>R r", "from assms"], ["proof (chain)\npicking this:\n  0 < det3 p q r", "have \"det3 p q r *\\<^sub>R ?lhs = det3 p q r *\\<^sub>R ?rhs\""], ["proof (prove)\nusing this:\n  0 < det3 p q r\n\ngoal (1 subgoal):\n 1. det3 p q r *\\<^sub>R s =\n    det3 p q r *\\<^sub>R\n    ((det3 s q r / det3 p q r) *\\<^sub>R p +\n     (det3 p s r / det3 p q r) *\\<^sub>R q +\n     (det3 p q s / det3 p q r) *\\<^sub>R r)", "by (simp add: field_simps prod_eq_iff scaleR_add_right) (simp add: algebra_simps det3_def')"], ["proof (state)\nthis:\n  det3 p q r *\\<^sub>R s =\n  det3 p q r *\\<^sub>R\n  ((det3 s q r / det3 p q r) *\\<^sub>R p +\n   (det3 p s r / det3 p q r) *\\<^sub>R q +\n   (det3 p q s / det3 p q r) *\\<^sub>R r)\n\ngoal (1 subgoal):\n 1. s =\n    (det3 s q r / det3 p q r) *\\<^sub>R p +\n    (det3 p s r / det3 p q r) *\\<^sub>R q +\n    (det3 p q s / det3 p q r) *\\<^sub>R r", "thus ?thesis"], ["proof (prove)\nusing this:\n  det3 p q r *\\<^sub>R s =\n  det3 p q r *\\<^sub>R\n  ((det3 s q r / det3 p q r) *\\<^sub>R p +\n   (det3 p s r / det3 p q r) *\\<^sub>R q +\n   (det3 p q s / det3 p q r) *\\<^sub>R r)\n\ngoal (1 subgoal):\n 1. s =\n    (det3 s q r / det3 p q r) *\\<^sub>R p +\n    (det3 p s r / det3 p q r) *\\<^sub>R q +\n    (det3 p q s / det3 p q r) *\\<^sub>R r", "using assms"], ["proof (prove)\nusing this:\n  det3 p q r *\\<^sub>R s =\n  det3 p q r *\\<^sub>R\n  ((det3 s q r / det3 p q r) *\\<^sub>R p +\n   (det3 p s r / det3 p q r) *\\<^sub>R q +\n   (det3 p q s / det3 p q r) *\\<^sub>R r)\n  0 < det3 p q r\n\ngoal (1 subgoal):\n 1. s =\n    (det3 s q r / det3 p q r) *\\<^sub>R p +\n    (det3 p s r / det3 p q r) *\\<^sub>R q +\n    (det3 p q s / det3 p q r) *\\<^sub>R r", "by simp"], ["proof (state)\nthis:\n  s =\n  (det3 s q r / det3 p q r) *\\<^sub>R p +\n  (det3 p s r / det3 p q r) *\\<^sub>R q +\n  (det3 p q s / det3 p q r) *\\<^sub>R r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma four_points_aligned:\n  assumes c: \"det3 t p q = 0\" \"det3 t q r = 0\"\n  assumes distinct: \"distinct5 t s p q r\"\n  shows \"det3 t r p = 0\" \"det3 p q r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 t r p = 0 &&& det3 p q r = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "from distinct"], ["proof (chain)\npicking this:\n  distinct5 t s p q r", "have d: \"p \\<noteq> q\" \"q \\<noteq> r\""], ["proof (prove)\nusing this:\n  distinct5 t s p q r\n\ngoal (1 subgoal):\n 1. p \\<noteq> q &&& q \\<noteq> r", "by (auto)"], ["proof (state)\nthis:\n  p \\<noteq> q\n  q \\<noteq> r\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "from coll_ex_scaling[OF d(1) c(1)]"], ["proof (chain)\npicking this:\n  \\<exists>r. t = p + r *\\<^sub>R (q - p)", "obtain s1 where s1: \"t = p + s1 *\\<^sub>R (q - p)\""], ["proof (prove)\nusing this:\n  \\<exists>r. t = p + r *\\<^sub>R (q - p)\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        t = p + s1 *\\<^sub>R (q - p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = p + s1 *\\<^sub>R (q - p)\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "from coll_ex_scaling[OF d(2) c(2)]"], ["proof (chain)\npicking this:\n  \\<exists>ra. t = q + ra *\\<^sub>R (r - q)", "obtain s2 where s2: \"t = q + s2 *\\<^sub>R (r - q)\""], ["proof (prove)\nusing this:\n  \\<exists>ra. t = q + ra *\\<^sub>R (r - q)\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        t = q + s2 *\\<^sub>R (r - q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = q + s2 *\\<^sub>R (r - q)\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "from distinct s1"], ["proof (chain)\npicking this:\n  distinct5 t s p q r\n  t = p + s1 *\\<^sub>R (q - p)", "have ne: \"1 - s1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  distinct5 t s p q r\n  t = p + s1 *\\<^sub>R (q - p)\n\ngoal (1 subgoal):\n 1. 1 - s1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 - s1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "from s1 s2"], ["proof (chain)\npicking this:\n  t = p + s1 *\\<^sub>R (q - p)\n  t = q + s2 *\\<^sub>R (r - q)", "have \"(1 - s1) *\\<^sub>R p = (1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r\""], ["proof (prove)\nusing this:\n  t = p + s1 *\\<^sub>R (q - p)\n  t = q + s2 *\\<^sub>R (r - q)\n\ngoal (1 subgoal):\n 1. (1 - s1) *\\<^sub>R p = (1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (1 - s1) *\\<^sub>R p = (1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "hence \"(1 - s1) *\\<^sub>R p /\\<^sub>R (1 - s1)= ((1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r) /\\<^sub>R (1 - s1)\""], ["proof (prove)\nusing this:\n  (1 - s1) *\\<^sub>R p = (1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r\n\ngoal (1 subgoal):\n 1. (1 - s1) *\\<^sub>R p /\\<^sub>R (1 - s1) =\n    ((1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r) /\\<^sub>R (1 - s1)", "by simp"], ["proof (state)\nthis:\n  (1 - s1) *\\<^sub>R p /\\<^sub>R (1 - s1) =\n  ((1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r) /\\<^sub>R (1 - s1)\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "with ne"], ["proof (chain)\npicking this:\n  1 - s1 \\<noteq> 0\n  (1 - s1) *\\<^sub>R p /\\<^sub>R (1 - s1) =\n  ((1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r) /\\<^sub>R (1 - s1)", "have p: \"p = ((1 - s1 - s2) / (1 - s1)) *\\<^sub>R q + (s2 / (1 - s1)) *\\<^sub>R r\""], ["proof (prove)\nusing this:\n  1 - s1 \\<noteq> 0\n  (1 - s1) *\\<^sub>R p /\\<^sub>R (1 - s1) =\n  ((1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r) /\\<^sub>R (1 - s1)\n\ngoal (1 subgoal):\n 1. p = ((1 - s1 - s2) / (1 - s1)) *\\<^sub>R q + (s2 / (1 - s1)) *\\<^sub>R r", "using ne"], ["proof (prove)\nusing this:\n  1 - s1 \\<noteq> 0\n  (1 - s1) *\\<^sub>R p /\\<^sub>R (1 - s1) =\n  ((1 - s1 - s2) *\\<^sub>R q + s2 *\\<^sub>R r) /\\<^sub>R (1 - s1)\n  1 - s1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = ((1 - s1 - s2) / (1 - s1)) *\\<^sub>R q + (s2 / (1 - s1)) *\\<^sub>R r", "by (simp add: prod_eq_iff inverse_eq_divide add_divide_distrib)"], ["proof (state)\nthis:\n  p = ((1 - s1 - s2) / (1 - s1)) *\\<^sub>R q + (s2 / (1 - s1)) *\\<^sub>R r\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "define k1 where \"k1 = (1 - s1 - s2) / (1 - s1)\""], ["proof (state)\nthis:\n  k1 = (1 - s1 - s2) / (1 - s1)\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "define k2 where \"k2 = s2 / (1 - s1)\""], ["proof (state)\nthis:\n  k2 = s2 / (1 - s1)\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "have \"det3 t r p = det3 0 (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r)\n    (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r + (- s1 * (k1 - 1)) *\\<^sub>R q - (s1 * k2) *\\<^sub>R r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 t r p =\n    det3 0 (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r)\n     (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r +\n      (- s1 * (k1 - 1)) *\\<^sub>R q -\n      (s1 * k2) *\\<^sub>R r)", "unfolding s1 p k1_def[symmetric] k2_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det3\n     (k1 *\\<^sub>R q + k2 *\\<^sub>R r +\n      s1 *\\<^sub>R (q - (k1 *\\<^sub>R q + k2 *\\<^sub>R r)))\n     r (k1 *\\<^sub>R q + k2 *\\<^sub>R r) =\n    det3 0 (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r)\n     (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r +\n      (- s1 * (k1 - 1)) *\\<^sub>R q -\n      (s1 * k2) *\\<^sub>R r)", "by (simp add: algebra_simps det3_def')"], ["proof (state)\nthis:\n  det3 t r p =\n  det3 0 (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r)\n   (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r + (- s1 * (k1 - 1)) *\\<^sub>R q -\n    (s1 * k2) *\\<^sub>R r)\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "also"], ["proof (state)\nthis:\n  det3 t r p =\n  det3 0 (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r)\n   (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r + (- s1 * (k1 - 1)) *\\<^sub>R q -\n    (s1 * k2) *\\<^sub>R r)\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "have \"- s1 * (k1 - 1) = s1 * k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - s1 * (k1 - 1) = s1 * k2", "using ne"], ["proof (prove)\nusing this:\n  1 - s1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. - s1 * (k1 - 1) = s1 * k2", "by (auto simp: k1_def field_simps k2_def)"], ["proof (state)\nthis:\n  - s1 * (k1 - 1) = s1 * k2\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "also"], ["proof (state)\nthis:\n  - s1 * (k1 - 1) = s1 * k2\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "have \"1 - k1 = k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - k1 = k2", "using ne"], ["proof (prove)\nusing this:\n  1 - s1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 - k1 = k2", "by (auto simp: k2_def k1_def field_simps)"], ["proof (state)\nthis:\n  1 - k1 = k2\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "have k21: \"k2 - 1 = -k1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k2 - 1 = - k1", "using ne"], ["proof (prove)\nusing this:\n  1 - s1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k2 - 1 = - k1", "by (auto simp: k2_def k1_def field_simps)"], ["proof (state)\nthis:\n  k2 - 1 = - k1\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "finally"], ["proof (chain)\npicking this:\n  det3 t r p =\n  det3 0 (k1 *\\<^sub>R q + - k1 *\\<^sub>R r)\n   (k1 *\\<^sub>R q + - k1 *\\<^sub>R r + (s1 * k2) *\\<^sub>R q -\n    (s1 * k2) *\\<^sub>R r)", "have \"det3 t r p = det3 0 (k1 *\\<^sub>R (q - r)) ((k1 + (s1 * k2)) *\\<^sub>R (q - r))\""], ["proof (prove)\nusing this:\n  det3 t r p =\n  det3 0 (k1 *\\<^sub>R q + - k1 *\\<^sub>R r)\n   (k1 *\\<^sub>R q + - k1 *\\<^sub>R r + (s1 * k2) *\\<^sub>R q -\n    (s1 * k2) *\\<^sub>R r)\n\ngoal (1 subgoal):\n 1. det3 t r p =\n    det3 0 (k1 *\\<^sub>R (q - r)) ((k1 + s1 * k2) *\\<^sub>R (q - r))", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  det3 t r p =\n  det3 0 (k1 *\\<^sub>R (q - r)) ((k1 + s1 * k2) *\\<^sub>R (q - r))\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "also"], ["proof (state)\nthis:\n  det3 t r p =\n  det3 0 (k1 *\\<^sub>R (q - r)) ((k1 + s1 * k2) *\\<^sub>R (q - r))\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 0 (k1 *\\<^sub>R (q - r)) ((k1 + s1 * k2) *\\<^sub>R (q - r)) = 0", "by (simp add: algebra_simps det3_def')"], ["proof (state)\nthis:\n  det3 0 (k1 *\\<^sub>R (q - r)) ((k1 + s1 * k2) *\\<^sub>R (q - r)) = 0\n\ngoal (2 subgoals):\n 1. det3 t r p = 0\n 2. det3 p q r = 0", "finally"], ["proof (chain)\npicking this:\n  det3 t r p = 0", "show \"det3 t r p = 0\""], ["proof (prove)\nusing this:\n  det3 t r p = 0\n\ngoal (1 subgoal):\n 1. det3 t r p = 0", "."], ["proof (state)\nthis:\n  det3 t r p = 0\n\ngoal (1 subgoal):\n 1. det3 p q r = 0", "have \"det3 p q r = det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 p q r = det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r", "unfolding p k1_def[symmetric] k2_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r =\n    det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r", ".."], ["proof (state)\nthis:\n  det3 p q r = det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r\n\ngoal (1 subgoal):\n 1. det3 p q r = 0", "also"], ["proof (state)\nthis:\n  det3 p q r = det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r\n\ngoal (1 subgoal):\n 1. det3 p q r = 0", "have \"\\<dots> = det3 0 (r - q) (k1 *\\<^sub>R q + (-k1) *\\<^sub>R r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r =\n    det3 0 (r - q) (k1 *\\<^sub>R q + - k1 *\\<^sub>R r)", "unfolding k21[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r =\n    det3 0 (r - q) (k1 *\\<^sub>R q + (k2 - 1) *\\<^sub>R r)", "by (auto simp: algebra_simps det3_def')"], ["proof (state)\nthis:\n  det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r =\n  det3 0 (r - q) (k1 *\\<^sub>R q + - k1 *\\<^sub>R r)\n\ngoal (1 subgoal):\n 1. det3 p q r = 0", "also"], ["proof (state)\nthis:\n  det3 (k1 *\\<^sub>R q + k2 *\\<^sub>R r) q r =\n  det3 0 (r - q) (k1 *\\<^sub>R q + - k1 *\\<^sub>R r)\n\ngoal (1 subgoal):\n 1. det3 p q r = 0", "have \"\\<dots> = det3 0 (r - q) (-k1 *\\<^sub>R (r - q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 0 (r - q) (k1 *\\<^sub>R q + - k1 *\\<^sub>R r) =\n    det3 0 (r - q) (- k1 *\\<^sub>R (r - q))", "by (auto simp: det3_def' algebra_simps)"], ["proof (state)\nthis:\n  det3 0 (r - q) (k1 *\\<^sub>R q + - k1 *\\<^sub>R r) =\n  det3 0 (r - q) (- k1 *\\<^sub>R (r - q))\n\ngoal (1 subgoal):\n 1. det3 p q r = 0", "also"], ["proof (state)\nthis:\n  det3 0 (r - q) (k1 *\\<^sub>R q + - k1 *\\<^sub>R r) =\n  det3 0 (r - q) (- k1 *\\<^sub>R (r - q))\n\ngoal (1 subgoal):\n 1. det3 p q r = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 0 (r - q) (- k1 *\\<^sub>R (r - q)) = 0", "by (auto simp: det3_def')"], ["proof (state)\nthis:\n  det3 0 (r - q) (- k1 *\\<^sub>R (r - q)) = 0\n\ngoal (1 subgoal):\n 1. det3 p q r = 0", "finally"], ["proof (chain)\npicking this:\n  det3 p q r = 0", "show \"det3 p q r = 0\""], ["proof (prove)\nusing this:\n  det3 p q r = 0\n\ngoal (1 subgoal):\n 1. det3 p q r = 0", "."], ["proof (state)\nthis:\n  det3 p q r = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_identity:\n  \"det3 t p q * det3 t s r + det3 t q r * det3 t s p + det3 t r p * det3 t s q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 t p q * det3 t s r + det3 t q r * det3 t s p +\n    det3 t r p * det3 t s q =\n    0", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma det3_eq_zeroI:\n  assumes \"p = q + x *\\<^sub>R (t - q)\"\n  shows \"det3 q t p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 q t p = 0", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 q t (q + x *\\<^sub>R (t - q)) = 0", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma det3_rotate: \"det3 a b c = det3 c a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 a b c = det3 c a b", "by (auto simp: det3_def')"], ["", "lemma det3_switch: \"det3 a b c = - det3 a c b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 a b c = - det3 a c b", "by (auto simp: det3_def')"], ["", "lemma det3_switch': \"det3 a b c = - det3 b a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 a b c = - det3 b a c", "by (auto simp: det3_def')"], ["", "lemma det3_pos_transitive_coll:\n  \"det3 t s p > 0 \\<Longrightarrow> det3 t s r \\<ge> 0 \\<Longrightarrow> det3 t p q \\<ge> 0 \\<Longrightarrow>\n  det3 t q r > 0 \\<Longrightarrow> det3 t s q = 0 \\<Longrightarrow> det3 t p r > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < det3 t s p; 0 \\<le> det3 t s r; 0 \\<le> det3 t p q;\n     0 < det3 t q r; det3 t s q = 0\\<rbrakk>\n    \\<Longrightarrow> 0 < det3 t p r", "using det_identity[of t p q s r]"], ["proof (prove)\nusing this:\n  det3 t p q * det3 t s r + det3 t q r * det3 t s p +\n  det3 t r p * det3 t s q =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < det3 t s p; 0 \\<le> det3 t s r; 0 \\<le> det3 t p q;\n     0 < det3 t q r; det3 t s q = 0\\<rbrakk>\n    \\<Longrightarrow> 0 < det3 t p r", "by (metis add.commute add_less_same_cancel1 det3_switch det3_switch' less_eq_real_def\n    less_not_sym monoid_add_class.add.left_neutral mult_pos_pos mult_zero_left mult_zero_right)"], ["", "lemma det3_pos_transitive:\n  \"det3 t s p > 0 \\<Longrightarrow> det3 t s q \\<ge> 0 \\<Longrightarrow> det3 t s r \\<ge> 0 \\<Longrightarrow> det3 t p q \\<ge> 0 \\<Longrightarrow>\n  det3 t q r > 0 \\<Longrightarrow> det3 t p r > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < det3 t s p; 0 \\<le> det3 t s q; 0 \\<le> det3 t s r;\n     0 \\<le> det3 t p q; 0 < det3 t q r\\<rbrakk>\n    \\<Longrightarrow> 0 < det3 t p r", "apply (cases \"det3 t s q \\<noteq> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < det3 t s p; 0 \\<le> det3 t s q; 0 \\<le> det3 t s r;\n     0 \\<le> det3 t p q; 0 < det3 t q r; det3 t s q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < det3 t p r\n 2. \\<lbrakk>0 < det3 t s p; 0 \\<le> det3 t s q; 0 \\<le> det3 t s r;\n     0 \\<le> det3 t p q; 0 < det3 t q r;\n     \\<not> det3 t s q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < det3 t p r", "using cramer[of q t s p r]"], ["proof (prove)\nusing this:\n  det3 q t s \\<noteq> 0 \\<Longrightarrow>\n  det3 t p r =\n  (det3 t s r * det3 q t p + det3 t p s * det3 q t r) / det3 q t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < det3 t s p; 0 \\<le> det3 t s q; 0 \\<le> det3 t s r;\n     0 \\<le> det3 t p q; 0 < det3 t q r; det3 t s q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < det3 t p r\n 2. \\<lbrakk>0 < det3 t s p; 0 \\<le> det3 t s q; 0 \\<le> det3 t s r;\n     0 \\<le> det3 t p q; 0 < det3 t q r;\n     \\<not> det3 t s q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < det3 t p r", "apply (force simp: det3_rotate[of q t p] det3_rotate[of p q t] det3_switch[of t p s]\n     det3_switch'[of q t r] det3_rotate[of q t s] det3_rotate[of s q t]\n     intro!: divide_pos_pos add_nonneg_pos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < det3 t s p; 0 \\<le> det3 t s q; 0 \\<le> det3 t s r;\n     0 \\<le> det3 t p q; 0 < det3 t q r;\n     \\<not> det3 t s q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < det3 t p r", "apply (metis det3_pos_transitive_coll)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma det3_zero_translate_plus[simp]: \"det3 (a + x) (b + x) (c + x) = 0 \\<longleftrightarrow> det3 a b c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det3 (a + x) (b + x) (c + x) = 0) = (det3 a b c = 0)", "by (auto simp: algebra_simps det3_def')"], ["", "lemma det3_zero_translate_plus'[simp]: \"det3 (a) (a + b) (a + c) = 0 \\<longleftrightarrow> det3 0 b c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det3 a (a + b) (a + c) = 0) = (det3 0 b c = 0)", "by (auto simp: algebra_simps det3_def')"], ["", "lemma\n  det30_zero_scaleR1:\n  \"0 < e \\<Longrightarrow> det3 0 xr P = 0 \\<Longrightarrow> det3 0 (e *\\<^sub>R xr) P = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < e; det3 0 xr P = 0\\<rbrakk>\n    \\<Longrightarrow> det3 0 (e *\\<^sub>R xr) P = 0", "by (auto simp: zero_prod_def algebra_simps det3_def')"], ["", "lemma det3_same[simp]: \"det3 a x x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det3 a x x = 0", "by (auto simp: det3_def')"], ["", "lemma\n  det30_zero_scaleR2:\n  \"0 < e \\<Longrightarrow> det3 0 P xr = 0 \\<Longrightarrow> det3 0 P (e *\\<^sub>R xr) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < e; det3 0 P xr = 0\\<rbrakk>\n    \\<Longrightarrow> det3 0 P (e *\\<^sub>R xr) = 0", "by (auto simp: zero_prod_def algebra_simps det3_def')"], ["", "lemma det3_eq_zero: \"e \\<noteq> 0 \\<Longrightarrow> det3 0 xr (e *\\<^sub>R Q) = 0 \\<longleftrightarrow> det3 0 xr Q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (det3 0 xr (e *\\<^sub>R Q) = 0) = (det3 0 xr Q = 0)", "by (auto simp: det3_def')"], ["", "lemma det30_plus_scaled3[simp]: \"det3 0 a (b + x *\\<^sub>R a) = 0 \\<longleftrightarrow> det3 0 a b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det3 0 a (b + x *\\<^sub>R a) = 0) = (det3 0 a b = 0)", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma det30_plus_scaled2[simp]:\n  shows \"det3 0 (a + x *\\<^sub>R a) b = 0 \\<longleftrightarrow> (if x = -1 then True else det3 0 a b = 0)\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (det3 0 (a + x *\\<^sub>R a) b = 0) =\n    (if x = - 1 then True else det3 0 a b = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. det3 0 (a + x *\\<^sub>R a) b = 0 \\<Longrightarrow>\n    if x = - 1 then True else det3 0 a b = 0\n 2. if x = - 1 then True else det3 0 a b = 0 \\<Longrightarrow>\n    det3 0 (a + x *\\<^sub>R a) b = 0", "assume \"det3 0 (a + x *\\<^sub>R a) b = 0\""], ["proof (state)\nthis:\n  det3 0 (a + x *\\<^sub>R a) b = 0\n\ngoal (2 subgoals):\n 1. det3 0 (a + x *\\<^sub>R a) b = 0 \\<Longrightarrow>\n    if x = - 1 then True else det3 0 a b = 0\n 2. if x = - 1 then True else det3 0 a b = 0 \\<Longrightarrow>\n    det3 0 (a + x *\\<^sub>R a) b = 0", "hence \"fst a * snd b * (1 + x) = fst b * snd a * (1 + x)\""], ["proof (prove)\nusing this:\n  det3 0 (a + x *\\<^sub>R a) b = 0\n\ngoal (1 subgoal):\n 1. fst a * snd b * (1 + x) = fst b * snd a * (1 + x)", "by (simp add: algebra_simps det3_def')"], ["proof (state)\nthis:\n  fst a * snd b * (1 + x) = fst b * snd a * (1 + x)\n\ngoal (2 subgoals):\n 1. det3 0 (a + x *\\<^sub>R a) b = 0 \\<Longrightarrow>\n    if x = - 1 then True else det3 0 a b = 0\n 2. if x = - 1 then True else det3 0 a b = 0 \\<Longrightarrow>\n    det3 0 (a + x *\\<^sub>R a) b = 0", "thus ?rhs"], ["proof (prove)\nusing this:\n  fst a * snd b * (1 + x) = fst b * snd a * (1 + x)\n\ngoal (1 subgoal):\n 1. if x = - 1 then True else det3 0 a b = 0", "by (auto simp add: det3_def')"], ["proof (state)\nthis:\n  if x = - 1 then True else det3 0 a b = 0\n\ngoal (1 subgoal):\n 1. if x = - 1 then True else det3 0 a b = 0 \\<Longrightarrow>\n    det3 0 (a + x *\\<^sub>R a) b = 0", "qed (auto simp: det3_def' algebra_simps split: if_split_asm)"], ["", "lemma det30_uminus2[simp]: \"det3 0 (-a) (b) = 0 \\<longleftrightarrow> det3 0 a b = 0\"\n  and det30_uminus3[simp]: \"det3 0 a (-b) = 0 \\<longleftrightarrow> det3 0 a b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det3 0 (- a) b = 0) = (det3 0 a b = 0) &&&\n    (det3 0 a (- b) = 0) = (det3 0 a b = 0)", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma det30_minus_scaled3[simp]: \"det3 0 a (b - x *\\<^sub>R a) = 0 \\<longleftrightarrow> det3 0 a b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det3 0 a (b - x *\\<^sub>R a) = 0) = (det3 0 a b = 0)", "using det30_plus_scaled3[of a b \"-x\"]"], ["proof (prove)\nusing this:\n  (det3 0 a (b + - x *\\<^sub>R a) = 0) = (det3 0 a b = 0)\n\ngoal (1 subgoal):\n 1. (det3 0 a (b - x *\\<^sub>R a) = 0) = (det3 0 a b = 0)", "by simp"], ["", "lemma det30_scaled_minus3[simp]: \"det3 0 a (e *\\<^sub>R a - b) = 0 \\<longleftrightarrow> det3 0 a b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det3 0 a (e *\\<^sub>R a - b) = 0) = (det3 0 a b = 0)", "using det30_plus_scaled3[of a \"-b\" e]"], ["proof (prove)\nusing this:\n  (det3 0 a (- b + e *\\<^sub>R a) = 0) = (det3 0 a (- b) = 0)\n\ngoal (1 subgoal):\n 1. (det3 0 a (e *\\<^sub>R a - b) = 0) = (det3 0 a b = 0)", "by (simp add: algebra_simps)"], ["", "lemma det30_minus_scaled2[simp]:\n  \"det3 0 (a - x *\\<^sub>R a) b = 0 \\<longleftrightarrow> (if x = 1 then True else det3 0 a b = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det3 0 (a - x *\\<^sub>R a) b = 0) =\n    (if x = 1 then True else det3 0 a b = 0)", "using det30_plus_scaled2[of a  \"-x\" b]"], ["proof (prove)\nusing this:\n  (det3 0 (a + - x *\\<^sub>R a) b = 0) =\n  (if - x = - 1 then True else det3 0 a b = 0)\n\ngoal (1 subgoal):\n 1. (det3 0 (a - x *\\<^sub>R a) b = 0) =\n    (if x = 1 then True else det3 0 a b = 0)", "by simp"], ["", "lemma det3_nonneg_scaleR1:\n  \"0 < e \\<Longrightarrow> det3 0 xr P \\<ge> 0 \\<Longrightarrow> det3 0 (e*\\<^sub>Rxr) P \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < e; 0 \\<le> det3 0 xr P\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> det3 0 (e *\\<^sub>R xr) P", "by (auto simp add: det3_def' algebra_simps)"], ["", "lemma det3_nonneg_scaleR1_eq:\n  \"0 < e \\<Longrightarrow> det3 0 (e*\\<^sub>Rxr) P \\<ge> 0 \\<longleftrightarrow> det3 0 xr P \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e \\<Longrightarrow>\n    (0 \\<le> det3 0 (e *\\<^sub>R xr) P) = (0 \\<le> det3 0 xr P)", "by (auto simp add: det3_def' algebra_simps)"], ["", "lemma det3_translate_origin: \"NO_MATCH 0 p \\<Longrightarrow> det3 p q r = det3 0 (q - p) (r - p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH (0::'a) p \\<Longrightarrow> det3 p q r = det3 0 (q - p) (r - p)", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma det3_nonneg_scaleR_segment2:\n  assumes \"det3 x y z \\<ge> 0\"\n  assumes \"a > 0\"\n  shows \"det3 x ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) z \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 x ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 x ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) z", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> det3 x y z\n  0 < a", "have \"0 \\<le> det3 0 (a *\\<^sub>R (y - x)) (z - x)\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 x y z\n  0 < a\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 0 (a *\\<^sub>R (y - x)) (z - x)", "by (intro det3_nonneg_scaleR1) (simp_all add: det3_translate_origin)"], ["proof (state)\nthis:\n  0 \\<le> det3 0 (a *\\<^sub>R (y - x)) (z - x)\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 x ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) z", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> det3 0 (a *\\<^sub>R (y - x)) (z - x)\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 x ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) z", "by (simp add: algebra_simps det3_translate_origin)"], ["proof (state)\nthis:\n  0 \\<le> det3 x ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det3_nonneg_scaleR_segment1:\n  assumes \"det3 x y z \\<ge> 0\"\n  assumes \"0 \\<le> a\" \"a < 1\"\n  shows \"det3 ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) y z \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> det3 ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) y z", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> det3 x y z\n  0 \\<le> a\n  a < 1", "have \"det3 0 ((1 - a) *\\<^sub>R (y - x)) (z - x + (- a) *\\<^sub>R (y - x)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> det3 x y z\n  0 \\<le> a\n  a < 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 0 ((1 - a) *\\<^sub>R (y - x))\n             (z - x + - a *\\<^sub>R (y - x))", "by (subst det3_nonneg_scaleR1_eq) (auto simp add: det3_def' algebra_simps)"], ["proof (state)\nthis:\n  0 \\<le> det3 0 ((1 - a) *\\<^sub>R (y - x)) (z - x + - a *\\<^sub>R (y - x))\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) y z", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> det3 0 ((1 - a) *\\<^sub>R (y - x)) (z - x + - a *\\<^sub>R (y - x))\n\ngoal (1 subgoal):\n 1. 0 \\<le> det3 ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) y z", "by (auto simp: algebra_simps det3_translate_origin)"], ["proof (state)\nthis:\n  0 \\<le> det3 ((1 - a) *\\<^sub>R x + a *\\<^sub>R y) y z\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Strict CCW Predicate\\<close>"], ["", "definition \"ccw' p q r \\<longleftrightarrow> 0 < det3 p q r\""], ["", "interpretation ccw': ccw_vector_space ccw'"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw_vector_space ccw' S", "by unfold_locales (auto simp: ccw'_def det3_def' algebra_simps)"], ["", "interpretation ccw': linorder_list0 \"ccw' x\" for x"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ccw'_contra: \"ccw' t r q \\<Longrightarrow> ccw' t q r = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' t r q \\<Longrightarrow> ccw' t q r = False", "by (auto simp: ccw'_def det3_def' algebra_simps)"], ["", "lemma not_ccw'_eq: \"\\<not> ccw' t p s \\<longleftrightarrow> ccw' t s p \\<or> det3 t s p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> ccw' t p s) = (ccw' t s p \\<or> det3 t s p = 0)", "by (auto simp: ccw'_def det3_def' algebra_simps)"], ["", "lemma neq_left_right_of: \"ccw' a b c \\<Longrightarrow> ccw' a c d \\<Longrightarrow> b \\<noteq> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ccw' a b c; ccw' a c d\\<rbrakk> \\<Longrightarrow> b \\<noteq> d", "by (auto simp: ccw'_def det3_def' algebra_simps)"], ["", "lemma ccw'_subst_collinear:\n  assumes \"det3 t r s = 0\"\n  assumes \"s \\<noteq> t\"\n  assumes \"ccw' t r p\"\n  shows \"ccw' t s p \\<or> ccw' t p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccw' t s p \\<or> ccw' t p s", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "assume \"r \\<noteq> s\""], ["proof (state)\nthis:\n  r \\<noteq> s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "from assms"], ["proof (chain)\npicking this:\n  det3 t r s = 0\n  s \\<noteq> t\n  ccw' t r p", "have \"det3 r s t = 0\""], ["proof (prove)\nusing this:\n  det3 t r s = 0\n  s \\<noteq> t\n  ccw' t r p\n\ngoal (1 subgoal):\n 1. det3 r s t = 0", "by (auto simp: algebra_simps det3_def')"], ["proof (state)\nthis:\n  det3 r s t = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "from coll_ex_scaling[OF assms(2) this]"], ["proof (chain)\npicking this:\n  \\<exists>ra. r = s + ra *\\<^sub>R (t - s)", "obtain x where s: \"r = s + x *\\<^sub>R (t - s)\""], ["proof (prove)\nusing this:\n  \\<exists>ra. r = s + ra *\\<^sub>R (t - s)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        r = s + x *\\<^sub>R (t - s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r = s + x *\\<^sub>R (t - s)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "from assms(3)[simplified ccw'_def s]"], ["proof (chain)\npicking this:\n  0 < det3 t (s + x *\\<^sub>R (t - s)) p", "have \"0 < det3 0 (s + x *\\<^sub>R (t - s) - t) (p - t)\""], ["proof (prove)\nusing this:\n  0 < det3 t (s + x *\\<^sub>R (t - s)) p\n\ngoal (1 subgoal):\n 1. 0 < det3 0 (s + x *\\<^sub>R (t - s) - t) (p - t)", "by (auto simp: algebra_simps det3_def')"], ["proof (state)\nthis:\n  0 < det3 0 (s + x *\\<^sub>R (t - s) - t) (p - t)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "also"], ["proof (state)\nthis:\n  0 < det3 0 (s + x *\\<^sub>R (t - s) - t) (p - t)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "have \"s + x *\\<^sub>R (t - s) - t = (1 - x) *\\<^sub>R (s - t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + x *\\<^sub>R (t - s) - t = (1 - x) *\\<^sub>R (s - t)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  s + x *\\<^sub>R (t - s) - t = (1 - x) *\\<^sub>R (s - t)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "finally"], ["proof (chain)\npicking this:\n  0 < det3 0 ((1 - x) *\\<^sub>R (s - t)) (p - t)", "have ccw': \"ccw' 0 ((1 - x) *\\<^sub>R (s - t)) (p - t)\""], ["proof (prove)\nusing this:\n  0 < det3 0 ((1 - x) *\\<^sub>R (s - t)) (p - t)\n\ngoal (1 subgoal):\n 1. ccw' 0 ((1 - x) *\\<^sub>R (s - t)) (p - t)", "by (simp add: ccw'_def)"], ["proof (state)\nthis:\n  ccw' 0 ((1 - x) *\\<^sub>R (s - t)) (p - t)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "hence \"x \\<noteq> 1\""], ["proof (prove)\nusing this:\n  ccw' 0 ((1 - x) *\\<^sub>R (s - t)) (p - t)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1", "by (auto simp add: det3_def' ccw'_def)"], ["proof (state)\nthis:\n  x \\<noteq> 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "{"], ["proof (state)\nthis:\n  x \\<noteq> 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "assume \"x < 1\""], ["proof (state)\nthis:\n  x < 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "hence ?thesis"], ["proof (prove)\nusing this:\n  x < 1\n\ngoal (1 subgoal):\n 1. ccw' t s p \\<or> ccw' t p s", "using ccw'"], ["proof (prove)\nusing this:\n  x < 1\n  ccw' 0 ((1 - x) *\\<^sub>R (s - t)) (p - t)\n\ngoal (1 subgoal):\n 1. ccw' t s p \\<or> ccw' t p s", "by (auto simp: not_ccw'_eq ccw'.translate_origin)"], ["proof (state)\nthis:\n  ccw' t s p \\<or> ccw' t p s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "}"], ["proof (state)\nthis:\n  x < 1 \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "moreover"], ["proof (state)\nthis:\n  x < 1 \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "{"], ["proof (state)\nthis:\n  x < 1 \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "assume \"x > 1\""], ["proof (state)\nthis:\n  1 < x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "hence ?thesis"], ["proof (prove)\nusing this:\n  1 < x\n\ngoal (1 subgoal):\n 1. ccw' t s p \\<or> ccw' t p s", "using ccw'"], ["proof (prove)\nusing this:\n  1 < x\n  ccw' 0 ((1 - x) *\\<^sub>R (s - t)) (p - t)\n\ngoal (1 subgoal):\n 1. ccw' t s p \\<or> ccw' t p s", "by (auto simp: not_ccw'_eq ccw'.translate_origin)"], ["proof (state)\nthis:\n  ccw' t s p \\<or> ccw' t p s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "}"], ["proof (state)\nthis:\n  1 < x \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n 2. \\<not> ?P \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "ultimately"], ["proof (chain)\npicking this:\n  x < 1 \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n  1 < x \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "show ?thesis"], ["proof (prove)\nusing this:\n  x < 1 \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n  1 < x \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n\ngoal (1 subgoal):\n 1. ccw' t s p \\<or> ccw' t p s", "using \\<open>x \\<noteq> 1\\<close>"], ["proof (prove)\nusing this:\n  x < 1 \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n  1 < x \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. ccw' t s p \\<or> ccw' t p s", "by arith"], ["proof (state)\nthis:\n  ccw' t s p \\<or> ccw' t p s\n\ngoal (1 subgoal):\n 1. \\<not> r \\<noteq> s \\<Longrightarrow> ccw' t s p \\<or> ccw' t p s", "qed (insert assms, simp)"], ["", "lemma ccw'_sorted_scaleR: \"ccw'.sortedP 0 xs \\<Longrightarrow> r > 0 \\<Longrightarrow> ccw'.sortedP 0 (map ((*\\<^sub>R) r) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ccw'.sortedP 0 xs; 0 < r\\<rbrakk>\n    \\<Longrightarrow> ccw'.sortedP 0 (map ((*\\<^sub>R) r) xs)", "by (induct xs) (auto intro!: ccw'.sortedP.Cons  elim!: ccw'.sortedP_Cons simp del: scaleR_Pair)"], ["", "subsection \\<open>Collinearity\\<close>"], ["", "abbreviation \"coll a b c \\<equiv> det3 a b c = 0\""], ["", "lemma coll_zero[intro, simp]: \"coll 0 z 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 z 0", "by (auto simp: det3_def')"], ["", "lemma coll_zero1[intro, simp]: \"coll 0 0 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 0 z", "by (auto simp: det3_def')"], ["", "lemma coll_self[intro, simp]: \"coll 0 z z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 z z", "by (auto simp: )"], ["", "lemma ccw'_not_coll:\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll a b c\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll a c b\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll b a c\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll b c a\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll c a b\"\n  \"ccw' a b c \\<Longrightarrow> \\<not>coll c b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ccw' a b c \\<Longrightarrow> det3 a b c \\<noteq> 0) &&&\n     (ccw' a b c \\<Longrightarrow> det3 a c b \\<noteq> 0) &&&\n     (ccw' a b c \\<Longrightarrow> det3 b a c \\<noteq> 0)) &&&\n    (ccw' a b c \\<Longrightarrow> det3 b c a \\<noteq> 0) &&&\n    (ccw' a b c \\<Longrightarrow> det3 c a b \\<noteq> 0) &&&\n    (ccw' a b c \\<Longrightarrow> det3 c b a \\<noteq> 0)", "by (auto simp: det3_def' ccw'_def algebra_simps)"], ["", "lemma coll_add: \"coll 0 x y \\<Longrightarrow> coll 0 x z \\<Longrightarrow> coll 0 x (y + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coll 0 x y; coll 0 x z\\<rbrakk>\n    \\<Longrightarrow> coll 0 x (y + z)", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma coll_scaleR_left_eq[simp]: \"coll 0 (r *\\<^sub>R x) y \\<longleftrightarrow> r = 0 \\<or> coll 0 x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 (r *\\<^sub>R x) y = (r = 0 \\<or> coll 0 x y)", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma coll_scaleR_right_eq[simp]: \"coll 0 y (r *\\<^sub>R x) \\<longleftrightarrow> r = 0 \\<or> coll 0 y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 y (r *\\<^sub>R x) = (r = 0 \\<or> coll 0 y x)", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma coll_scaleR: \"coll 0 x y \\<Longrightarrow> coll 0 (r *\\<^sub>R x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 x y \\<Longrightarrow> coll 0 (r *\\<^sub>R x) y", "by (auto simp: det3_def' algebra_simps)"], ["", "lemma coll_sum_list: \"(\\<And>y. y \\<in> set ys \\<Longrightarrow> coll 0 x y) \\<Longrightarrow> coll 0 x (sum_list ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> set ys \\<Longrightarrow> coll 0 x y) \\<Longrightarrow>\n    coll 0 x (sum_list ys)", "by (induct ys) (auto intro!: coll_add)"], ["", "lemma scaleR_left_normalize:\n  fixes a ::real and b c::\"'a::real_vector\"\n  shows \"a *\\<^sub>R b = c \\<longleftrightarrow> (if a = 0 then c = 0 else b = c /\\<^sub>R a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a *\\<^sub>R b = c) = (if a = 0 then c = (0::'a) else b = c /\\<^sub>R a)", "by (auto simp: field_simps)"], ["", "lemma coll_scale_pair: \"coll 0 (a, b) (c, d) \\<Longrightarrow> (a, b) \\<noteq> 0 \\<Longrightarrow> (\\<exists>x. (c, d) = x *\\<^sub>R (a, b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coll 0 (a, b) (c, d); (a, b) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. (c, d) = x *\\<^sub>R (a, b)", "by (auto intro: exI[where x=\"c/a\"] exI[where x=\"d/b\"] simp: det3_def' field_simps prod_eq_iff)"], ["", "lemma coll_scale: \"coll 0 r q \\<Longrightarrow> r \\<noteq> 0 \\<Longrightarrow> (\\<exists>x. q = x *\\<^sub>R r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coll 0 r q; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. q = x *\\<^sub>R r", "using coll_scale_pair[of \"fst r\" \"snd r\" \"fst q\" \"snd q\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>coll 0 (fst r, snd r) (fst q, snd q);\n   (fst r, snd r) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. (fst q, snd q) = x *\\<^sub>R (fst r, snd r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coll 0 r q; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. q = x *\\<^sub>R r", "by simp"], ["", "lemma coll_add_trans:\n  assumes \"coll 0 x (y + z)\"\n  assumes \"coll 0 y z\"\n  assumes \"x \\<noteq> 0\"\n  assumes \"y \\<noteq> 0\"\n  assumes \"z \\<noteq> 0\"\n  assumes \"y + z \\<noteq> 0\"\n  shows \"coll 0 x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 x z", "proof (cases \"snd z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd z = 0 \\<Longrightarrow> coll 0 x z\n 2. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "case True"], ["proof (state)\nthis:\n  snd z = 0\n\ngoal (2 subgoals):\n 1. snd z = 0 \\<Longrightarrow> coll 0 x z\n 2. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "hence \"snd y = 0\""], ["proof (prove)\nusing this:\n  snd z = 0\n\ngoal (1 subgoal):\n 1. snd y = 0", "using assms"], ["proof (prove)\nusing this:\n  snd z = 0\n  coll 0 x (y + z)\n  coll 0 y z\n  x \\<noteq> 0\n  y \\<noteq> 0\n  z \\<noteq> 0\n  y + z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd y = 0", "by (cases z) (auto simp add: zero_prod_def det3_def')"], ["proof (state)\nthis:\n  snd y = 0\n\ngoal (2 subgoals):\n 1. snd z = 0 \\<Longrightarrow> coll 0 x z\n 2. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "with True assms"], ["proof (chain)\npicking this:\n  snd z = 0\n  coll 0 x (y + z)\n  coll 0 y z\n  x \\<noteq> 0\n  y \\<noteq> 0\n  z \\<noteq> 0\n  y + z \\<noteq> 0\n  snd y = 0", "have \"snd x = 0\""], ["proof (prove)\nusing this:\n  snd z = 0\n  coll 0 x (y + z)\n  coll 0 y z\n  x \\<noteq> 0\n  y \\<noteq> 0\n  z \\<noteq> 0\n  y + z \\<noteq> 0\n  snd y = 0\n\ngoal (1 subgoal):\n 1. snd x = 0", "by (cases y, cases z) (auto simp add: zero_prod_def det3_def')"], ["proof (state)\nthis:\n  snd x = 0\n\ngoal (2 subgoals):\n 1. snd z = 0 \\<Longrightarrow> coll 0 x z\n 2. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "from \\<open>snd x = 0\\<close> \\<open>snd y = 0\\<close> \\<open>snd z = 0\\<close>"], ["proof (chain)\npicking this:\n  snd x = 0\n  snd y = 0\n  snd z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  snd x = 0\n  snd y = 0\n  snd z = 0\n\ngoal (1 subgoal):\n 1. coll 0 x z", "by (auto simp add: zero_prod_def det3_def')"], ["proof (state)\nthis:\n  coll 0 x z\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "case False"], ["proof (state)\nthis:\n  snd z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "note z = False"], ["proof (state)\nthis:\n  snd z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "hence \"snd y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  snd z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd y \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  snd z \\<noteq> 0\n  coll 0 x (y + z)\n  coll 0 y z\n  x \\<noteq> 0\n  y \\<noteq> 0\n  z \\<noteq> 0\n  y + z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd y \\<noteq> 0", "by (cases y) (auto simp add: zero_prod_def det3_def')"], ["proof (state)\nthis:\n  snd y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "with False assms"], ["proof (chain)\npicking this:\n  snd z \\<noteq> 0\n  coll 0 x (y + z)\n  coll 0 y z\n  x \\<noteq> 0\n  y \\<noteq> 0\n  z \\<noteq> 0\n  y + z \\<noteq> 0\n  snd y \\<noteq> 0", "have \"snd x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  snd z \\<noteq> 0\n  coll 0 x (y + z)\n  coll 0 y z\n  x \\<noteq> 0\n  y \\<noteq> 0\n  z \\<noteq> 0\n  y + z \\<noteq> 0\n  snd y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd x \\<noteq> 0", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>snd z \\<noteq> 0; coll 0 x (y + z); coll 0 y z;\n        x \\<noteq> 0; y \\<noteq> 0; z \\<noteq> 0; y + z \\<noteq> 0;\n        snd y \\<noteq> 0; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> snd x \\<noteq> 0", "apply (cases y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>snd z \\<noteq> 0; coll 0 x (y + z); coll 0 y z;\n        x \\<noteq> 0; y \\<noteq> 0; z \\<noteq> 0; y + z \\<noteq> 0;\n        snd y \\<noteq> 0; x = (a, b); y = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> snd x \\<noteq> 0", "apply (cases z)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>snd z \\<noteq> 0; coll 0 x (y + z); coll 0 y z;\n        x \\<noteq> 0; y \\<noteq> 0; z \\<noteq> 0; y + z \\<noteq> 0;\n        snd y \\<noteq> 0; x = (a, b); y = (aa, ba); z = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> snd x \\<noteq> 0", "apply (auto simp add: zero_prod_def det3_def')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba ab bb.\n       \\<lbrakk>bb \\<noteq> 0; ba + bb = 0; aa * bb = ba * ab; x = (a, 0);\n        y = (aa, ba); z = (ab, bb); a \\<noteq> 0;\n        aa + ab \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis mult.commute mult_eq_0_iff ring_class.ring_distribs(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  snd x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "with False assms \\<open>snd y \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  snd z \\<noteq> 0\n  coll 0 x (y + z)\n  coll 0 y z\n  x \\<noteq> 0\n  y \\<noteq> 0\n  z \\<noteq> 0\n  y + z \\<noteq> 0\n  snd y \\<noteq> 0\n  snd x \\<noteq> 0", "have yz: \"snd (y + z) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  snd z \\<noteq> 0\n  coll 0 x (y + z)\n  coll 0 y z\n  x \\<noteq> 0\n  y \\<noteq> 0\n  z \\<noteq> 0\n  y + z \\<noteq> 0\n  snd y \\<noteq> 0\n  snd x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd (y + z) \\<noteq> 0", "by (cases x; cases y; cases z) (auto simp add: det3_def' zero_prod_def)"], ["proof (state)\nthis:\n  snd (y + z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "from coll_scale[OF assms(1) assms(3)] coll_scale[OF assms(2) assms(4)]"], ["proof (chain)\npicking this:\n  \\<exists>xa. y + z = xa *\\<^sub>R x\n  \\<exists>x. z = x *\\<^sub>R y", "obtain r s where rs: \"y + z = r *\\<^sub>R x\" \"z = s *\\<^sub>R y\""], ["proof (prove)\nusing this:\n  \\<exists>xa. y + z = xa *\\<^sub>R x\n  \\<exists>x. z = x *\\<^sub>R y\n\ngoal (1 subgoal):\n 1. (\\<And>r s.\n        \\<lbrakk>y + z = r *\\<^sub>R x; z = s *\\<^sub>R y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y + z = r *\\<^sub>R x\n  z = s *\\<^sub>R y\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "with z"], ["proof (chain)\npicking this:\n  snd z \\<noteq> 0\n  y + z = r *\\<^sub>R x\n  z = s *\\<^sub>R y", "have \"s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  snd z \\<noteq> 0\n  y + z = r *\\<^sub>R x\n  z = s *\\<^sub>R y\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0", "by (cases x; cases y; cases z) (auto simp: zero_prod_def)"], ["proof (state)\nthis:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "with rs z yz"], ["proof (chain)\npicking this:\n  y + z = r *\\<^sub>R x\n  z = s *\\<^sub>R y\n  snd z \\<noteq> 0\n  snd (y + z) \\<noteq> 0\n  s \\<noteq> 0", "have \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y + z = r *\\<^sub>R x\n  z = s *\\<^sub>R y\n  snd z \\<noteq> 0\n  snd (y + z) \\<noteq> 0\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by (cases x; cases y; cases z) (auto simp: zero_prod_def)"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "from \\<open>s \\<noteq> 0\\<close> rs"], ["proof (chain)\npicking this:\n  s \\<noteq> 0\n  y + z = r *\\<^sub>R x\n  z = s *\\<^sub>R y", "have \"y = r *\\<^sub>R x - z\" \"y = z /\\<^sub>R s\""], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  y + z = r *\\<^sub>R x\n  z = s *\\<^sub>R y\n\ngoal (1 subgoal):\n 1. y = r *\\<^sub>R x - z &&& y = z /\\<^sub>R s", "by (auto simp: inverse_eq_divide algebra_simps)"], ["proof (state)\nthis:\n  y = r *\\<^sub>R x - z\n  y = z /\\<^sub>R s\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "hence \"r *\\<^sub>R x - z = z /\\<^sub>R s\""], ["proof (prove)\nusing this:\n  y = r *\\<^sub>R x - z\n  y = z /\\<^sub>R s\n\ngoal (1 subgoal):\n 1. r *\\<^sub>R x - z = z /\\<^sub>R s", "by simp"], ["proof (state)\nthis:\n  r *\\<^sub>R x - z = z /\\<^sub>R s\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "hence \"r *\\<^sub>R x = (1 + inverse s) *\\<^sub>R z\""], ["proof (prove)\nusing this:\n  r *\\<^sub>R x - z = z /\\<^sub>R s\n\ngoal (1 subgoal):\n 1. r *\\<^sub>R x = (1 + inverse s) *\\<^sub>R z", "by (auto simp: inverse_eq_divide algebra_simps)"], ["proof (state)\nthis:\n  r *\\<^sub>R x = (1 + inverse s) *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "hence \"x = (inverse r * (1 + inverse s)) *\\<^sub>R z\""], ["proof (prove)\nusing this:\n  r *\\<^sub>R x = (1 + inverse s) *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. x = (inverse r * (1 + inverse s)) *\\<^sub>R z", "using \\<open>r \\<noteq> 0\\<close> \\<open>s \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  r *\\<^sub>R x = (1 + inverse s) *\\<^sub>R z\n  r \\<noteq> 0\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = (inverse r * (1 + inverse s)) *\\<^sub>R z", "by (auto simp: field_simps scaleR_left_normalize)"], ["proof (state)\nthis:\n  x = (inverse r * (1 + inverse s)) *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> coll 0 x z", "from this"], ["proof (chain)\npicking this:\n  x = (inverse r * (1 + inverse s)) *\\<^sub>R z", "show ?thesis"], ["proof (prove)\nusing this:\n  x = (inverse r * (1 + inverse s)) *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. coll 0 x z", "by (auto intro: coll_scaleR)"], ["proof (state)\nthis:\n  coll 0 x z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coll_commute: \"coll 0 a b \\<longleftrightarrow> coll 0 b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 a b = coll 0 b a", "by (metis det3_rotate det3_switch' diff_0 diff_self)"], ["", "lemma coll_add_cancel: \"coll 0 a (a + b) \\<Longrightarrow> coll 0 a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 a (a + b) \\<Longrightarrow> coll 0 a b", "by (cases a, cases b) (auto simp: det3_def' algebra_simps)"], ["", "lemma coll_trans:\n  \"coll 0 a b \\<Longrightarrow> coll 0 a c \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> coll 0 b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coll 0 a b; coll 0 a c; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> coll 0 b c", "by (metis coll_scale coll_scaleR)"], ["", "lemma sum_list_posI:\n  fixes xs::\"'a::ordered_comm_monoid_add list\"\n  shows \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x > 0) \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> sum_list xs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> (0::'a) < x;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (0::'a) < sum_list xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. x \\<in> set [] \\<Longrightarrow> (0::'a) < x;\n     [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (0::'a) < sum_list []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow> (0::'a) < x;\n                 xs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> (0::'a) < sum_list xs;\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> (0::'a) < x;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < sum_list (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> (0::'a) < x;\n   xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (0::'a) < sum_list xs\n  ?x \\<in> set (x # xs) \\<Longrightarrow> (0::'a) < ?x\n  x # xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. x \\<in> set [] \\<Longrightarrow> (0::'a) < x;\n     [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (0::'a) < sum_list []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow> (0::'a) < x;\n                 xs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> (0::'a) < sum_list xs;\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> (0::'a) < x;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < sum_list (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> (0::'a) < x;\n   xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (0::'a) < sum_list xs\n  ?x \\<in> set (x # xs) \\<Longrightarrow> (0::'a) < ?x\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (0::'a) < sum_list (x # xs)", "by (cases \"xs = []\") (auto intro!: add_pos_pos)"], ["proof (state)\nthis:\n  (0::'a) < sum_list (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> set [] \\<Longrightarrow> (0::'a) < x;\n     [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (0::'a) < sum_list []", "qed simp"], ["", "lemma nonzero_fstI[intro, simp]: \"fst x \\<noteq> 0 \\<Longrightarrow> x \\<noteq> 0\"\n  and nonzero_sndI[intro, simp]: \"snd x \\<noteq> 0 \\<Longrightarrow> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x \\<noteq> (0::'a) \\<Longrightarrow> x \\<noteq> 0) &&&\n    (snd x \\<noteq> (0::'b) \\<Longrightarrow> x \\<noteq> 0)", "by auto"], ["", "lemma coll_sum_list_trans:\n  \"xs \\<noteq> [] \\<Longrightarrow> coll 0 a (sum_list xs) \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y) \\<Longrightarrow>\n    (\\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs)) \\<Longrightarrow>\n    (\\<And>x. x \\<in> set xs \\<Longrightarrow> snd x > 0) \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> coll 0 a y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; coll 0 a (sum_list xs);\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n     a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> coll 0 a y", "proof (induct xs rule: list_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>coll 0 a (sum_list [x]);\n        \\<And>xa. xa \\<in> set [x] \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set [x] \\<Longrightarrow> coll 0 xa (sum_list [x]);\n        \\<And>xa. xa \\<in> set [x] \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "case (single x)"], ["proof (state)\nthis:\n  coll 0 a (sum_list [x])\n  ?x \\<in> set [x] \\<Longrightarrow> coll 0 ?x y\n  ?x \\<in> set [x] \\<Longrightarrow> coll 0 ?x (sum_list [x])\n  ?x \\<in> set [x] \\<Longrightarrow> 0 < snd ?x\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>coll 0 a (sum_list [x]);\n        \\<And>xa. xa \\<in> set [x] \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set [x] \\<Longrightarrow> coll 0 xa (sum_list [x]);\n        \\<And>xa. xa \\<in> set [x] \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "from single(1) single(2)[of x] single(4)[of x]"], ["proof (chain)\npicking this:\n  coll 0 a (sum_list [x])\n  x \\<in> set [x] \\<Longrightarrow> coll 0 x y\n  x \\<in> set [x] \\<Longrightarrow> 0 < snd x", "have \"coll 0 x a\" \"coll 0 x y\" \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  coll 0 a (sum_list [x])\n  x \\<in> set [x] \\<Longrightarrow> coll 0 x y\n  x \\<in> set [x] \\<Longrightarrow> 0 < snd x\n\ngoal (1 subgoal):\n 1. coll 0 x a &&& coll 0 x y &&& x \\<noteq> 0", "by (auto simp: coll_commute)"], ["proof (state)\nthis:\n  coll 0 x a\n  coll 0 x y\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>coll 0 a (sum_list [x]);\n        \\<And>xa. xa \\<in> set [x] \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set [x] \\<Longrightarrow> coll 0 xa (sum_list [x]);\n        \\<And>xa. xa \\<in> set [x] \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "thus ?case"], ["proof (prove)\nusing this:\n  coll 0 x a\n  coll 0 x y\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coll 0 a y", "by (rule coll_trans)"], ["proof (state)\nthis:\n  coll 0 a y\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "case (cons x xs)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  \\<lbrakk>coll 0 a (sum_list xs);\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n   a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coll 0 a y\n  coll 0 a (sum_list (x # xs))\n  ?x \\<in> set (x # xs) \\<Longrightarrow> coll 0 ?x y\n  ?x \\<in> set (x # xs) \\<Longrightarrow> coll 0 ?x (sum_list (x # xs))\n  ?x \\<in> set (x # xs) \\<Longrightarrow> 0 < snd ?x\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "from cons(5)[of x] \\<open>a \\<noteq> 0\\<close> cons(6)[of x]"], ["proof (chain)\npicking this:\n  x \\<in> set (x # xs) \\<Longrightarrow> coll 0 x (sum_list (x # xs))\n  a \\<noteq> 0\n  x \\<in> set (x # xs) \\<Longrightarrow> 0 < snd x", "have *: \"coll 0 x (sum_list xs)\" \"a \\<noteq> 0\" \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> set (x # xs) \\<Longrightarrow> coll 0 x (sum_list (x # xs))\n  a \\<noteq> 0\n  x \\<in> set (x # xs) \\<Longrightarrow> 0 < snd x\n\ngoal (1 subgoal):\n 1. coll 0 x (sum_list xs) &&& a \\<noteq> 0 &&& x \\<noteq> 0", "by (force simp add: coll_add_cancel)+"], ["proof (state)\nthis:\n  coll 0 x (sum_list xs)\n  a \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "have \"0 < snd (sum_list (x#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < snd (sum_list (x # xs))", "unfolding snd_sum_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sum_list (map snd (x # xs))", "by (rule sum_list_posI) (auto intro!: add_pos_pos cons simp: snd_sum_list)"], ["proof (state)\nthis:\n  0 < snd (sum_list (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "hence \"x + sum_list xs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < snd (sum_list (x # xs))\n\ngoal (1 subgoal):\n 1. x + sum_list xs \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  x + sum_list xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "from coll_add_trans[OF cons(3)[simplified] * _ this]"], ["proof (chain)\npicking this:\n  sum_list xs \\<noteq> 0 \\<Longrightarrow> coll 0 a (sum_list xs)", "have cH: \"coll 0 a (sum_list xs)\""], ["proof (prove)\nusing this:\n  sum_list xs \\<noteq> 0 \\<Longrightarrow> coll 0 a (sum_list xs)\n\ngoal (1 subgoal):\n 1. coll 0 a (sum_list xs)", "by (cases \"sum_list xs = 0\") auto"], ["proof (state)\nthis:\n  coll 0 a (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "from cons(4)"], ["proof (chain)\npicking this:\n  ?x \\<in> set (x # xs) \\<Longrightarrow> coll 0 ?x y", "have cy: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y)\""], ["proof (prove)\nusing this:\n  ?x \\<in> set (x # xs) \\<Longrightarrow> coll 0 ?x y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y", "by simp"], ["proof (state)\nthis:\n  ?x \\<in> set xs \\<Longrightarrow> coll 0 ?x y\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "{"], ["proof (state)\nthis:\n  ?x \\<in> set xs \\<Longrightarrow> coll 0 ?x y\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "hence \"snd (sum_list xs) > 0\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. 0 < snd (sum_list xs)", "unfolding snd_sum_list"], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. 0 < sum_list (map snd xs)", "by (intro sum_list_posI) (auto intro!: add_pos_pos cons simp: snd_sum_list)"], ["proof (state)\nthis:\n  0 < snd (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "hence \"sum_list xs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < snd (sum_list xs)\n\ngoal (1 subgoal):\n 1. sum_list xs \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  sum_list xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "from cons(5)[of x]"], ["proof (chain)\npicking this:\n  x \\<in> set (x # xs) \\<Longrightarrow> coll 0 x (sum_list (x # xs))", "have \"coll 0 x (sum_list xs)\""], ["proof (prove)\nusing this:\n  x \\<in> set (x # xs) \\<Longrightarrow> coll 0 x (sum_list (x # xs))\n\ngoal (1 subgoal):\n 1. coll 0 x (sum_list xs)", "by (simp add: coll_add_cancel)"], ["proof (state)\nthis:\n  coll 0 x (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "from cons(5)[of y]"], ["proof (chain)\npicking this:\n  y \\<in> set (x # xs) \\<Longrightarrow> coll 0 y (sum_list (x # xs))", "have \"coll 0 y (sum_list xs)\""], ["proof (prove)\nusing this:\n  y \\<in> set (x # xs) \\<Longrightarrow> coll 0 y (sum_list (x # xs))\n\ngoal (1 subgoal):\n 1. coll 0 y (sum_list xs)", "using \\<open>y \\<in> set xs\\<close> cons(6)[of y] \\<open>x + sum_list xs \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> set (x # xs) \\<Longrightarrow> coll 0 y (sum_list (x # xs))\n  y \\<in> set xs\n  y \\<in> set (x # xs) \\<Longrightarrow> 0 < snd y\n  x + sum_list xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coll 0 y (sum_list xs)", "apply (cases \"y = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<in> set (x # xs) \\<Longrightarrow>\n             coll 0 y (sum_list (x # xs));\n     y \\<in> set xs; y \\<in> set (x # xs) \\<Longrightarrow> 0 < snd y;\n     x + sum_list xs \\<noteq> 0; y = x\\<rbrakk>\n    \\<Longrightarrow> coll 0 y (sum_list xs)\n 2. \\<lbrakk>y \\<in> set (x # xs) \\<Longrightarrow>\n             coll 0 y (sum_list (x # xs));\n     y \\<in> set xs; y \\<in> set (x # xs) \\<Longrightarrow> 0 < snd y;\n     x + sum_list xs \\<noteq> 0; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> coll 0 y (sum_list xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set (x # xs) \\<Longrightarrow>\n             coll 0 y (sum_list (x # xs));\n     y \\<in> set xs; y \\<in> set (x # xs) \\<Longrightarrow> 0 < snd y;\n     x + sum_list xs \\<noteq> 0; y = x\\<rbrakk>\n    \\<Longrightarrow> coll 0 y (sum_list xs)", "by (force simp add: coll_add_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set (x # xs) \\<Longrightarrow>\n             coll 0 y (sum_list (x # xs));\n     y \\<in> set xs; y \\<in> set (x # xs) \\<Longrightarrow> 0 < snd y;\n     x + sum_list xs \\<noteq> 0; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> coll 0 y (sum_list xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set (x # xs) \\<Longrightarrow>\n             coll 0 y (sum_list (x # xs));\n     y \\<in> set xs; y \\<in> set (x # xs) \\<Longrightarrow> 0 < snd y;\n     x + sum_list xs \\<noteq> 0; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> coll 0 y (sum_list xs)", "by (force simp: dest!: coll_add_trans[OF _ *(1) _ *(3)])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  coll 0 y (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "}"], ["proof (state)\nthis:\n  ?ya2 \\<in> set xs \\<Longrightarrow> coll 0 ?ya2 (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "note cl = this"], ["proof (state)\nthis:\n  ?ya2 \\<in> set xs \\<Longrightarrow> coll 0 ?ya2 (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>coll 0 a (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x y;\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 x (sum_list xs);\n         \\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < snd x;\n         a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> coll 0 a y;\n        coll 0 a (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> coll 0 xa y;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow>\n           coll 0 xa (sum_list (x # xs));\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> 0 < snd xa;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> coll 0 a y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. coll 0 a y", "by (rule cons(2)[OF cH cy cl cons(6) \\<open>a \\<noteq> 0\\<close>]) auto"], ["proof (state)\nthis:\n  coll 0 a y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_coll_ex_scale:\n  assumes coll: \"\\<And>x. x \\<in> set xs \\<Longrightarrow> coll 0 z x\"\n  assumes nz: \"z \\<noteq> 0\"\n  shows \"\\<exists>r. sum_list xs = r *\\<^sub>R z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "assume i: \"i < length xs\""], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "hence nth: \"xs ! i \\<in> set xs\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. xs ! i \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  xs ! i \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "note coll_scale[OF coll[OF nth] \\<open>z \\<noteq> 0\\<close>]"], ["proof (state)\nthis:\n  \\<exists>x. xs ! i = x *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "}"], ["proof (state)\nthis:\n  ?i2 < length xs \\<Longrightarrow> \\<exists>x. xs ! ?i2 = x *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "then"], ["proof (chain)\npicking this:\n  ?i2 < length xs \\<Longrightarrow> \\<exists>x. xs ! ?i2 = x *\\<^sub>R z", "obtain r where r: \"\\<And>i. i < length xs \\<Longrightarrow> r i *\\<^sub>R z = xs ! i\""], ["proof (prove)\nusing this:\n  ?i2 < length xs \\<Longrightarrow> \\<exists>x. xs ! ?i2 = x *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            r i *\\<^sub>R z = xs ! i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow> r ?i *\\<^sub>R z = xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "have \"xs = map ((!) xs) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map ((!) xs) [0..<length xs]", "by (simp add: map_nth)"], ["proof (state)\nthis:\n  xs = map ((!) xs) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "also"], ["proof (state)\nthis:\n  xs = map ((!) xs) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "have \"\\<dots> = map (\\<lambda>i. r i *\\<^sub>R z) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) xs) [0..<length xs] =\n    map (\\<lambda>i. r i *\\<^sub>R z) [0..<length xs]", "by (auto simp: r)"], ["proof (state)\nthis:\n  map ((!) xs) [0..<length xs] =\n  map (\\<lambda>i. r i *\\<^sub>R z) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "also"], ["proof (state)\nthis:\n  map ((!) xs) [0..<length xs] =\n  map (\\<lambda>i. r i *\\<^sub>R z) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "have \"sum_list \\<dots> = (\\<Sum>i\\<leftarrow>[0..<length xs]. r i) *\\<^sub>R z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<length xs]. r i *\\<^sub>R z) =\n    sum_list (map r [0..<length xs]) *\\<^sub>R z", "by (simp add: sum_list_sum_nth scaleR_sum_left)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>[0..<length xs]. r i *\\<^sub>R z) =\n  sum_list (map r [0..<length xs]) *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", "finally"], ["proof (chain)\npicking this:\n  sum_list xs = sum_list (map r [0..<length xs]) *\\<^sub>R z", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list xs = sum_list (map r [0..<length xs]) *\\<^sub>R z\n\ngoal (1 subgoal):\n 1. \\<exists>r. sum_list xs = r *\\<^sub>R z", ".."], ["proof (state)\nthis:\n  \\<exists>r. sum_list xs = r *\\<^sub>R z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_filter_coll_ex_scale: \"z \\<noteq> 0 \\<Longrightarrow> \\<exists>r. sum_list (filter (coll 0 z) zs) = r *\\<^sub>R z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. sum_list (filter (coll 0 z) zs) = r *\\<^sub>R z", "by (rule sum_list_coll_ex_scale) simp"], ["", "end"]]}