{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Affine_Form.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma sum_list_mono:\n  fixes xs ys::\"'a::ordered_ab_group_add list\"\n  shows\n    \"length xs = length ys \\<Longrightarrow> (\\<And>x y. (x, y) \\<in> set (zip xs ys) \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n      sum_list xs \\<le> sum_list ys\"", "lemma\n  fixes xs::\"'a::ordered_comm_monoid_add list\"\n  shows sum_list_nonneg: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<ge> 0) \\<Longrightarrow> sum_list xs \\<ge> 0\"", "lemma map_filter:\n  \"map f (filter (\\<lambda>x. P (f x)) xs) = filter P (map f xs)\"", "lemma\n  map_of_zip_upto2_length_eq_nth:\n  assumes \"distinct B\"\n  assumes \"i < length B\"\n  shows \"(map_of (zip B [0..<length B]) (B ! i)) = Some i\"", "lemma distinct_map_fst_snd_eqD:\n  \"distinct (map fst xs) \\<Longrightarrow> (i, a) \\<in> set xs \\<Longrightarrow> (i, b) \\<in> set xs \\<Longrightarrow> a = b\"", "lemma length_filter_snd_zip:\n  \"length ys = length xs \\<Longrightarrow> length (filter (p \\<circ> snd) (zip ys xs)) = length (filter p xs)\"", "lemma filter_snd_nth:\n  \"length ys = length xs \\<Longrightarrow> n < length (filter p xs) \\<Longrightarrow>\n    snd (filter (p \\<circ> snd) (zip ys xs) ! n) = filter p xs ! n\"", "lemma distinct_map_snd_fst_eqD:\n  \"distinct (map snd xs) \\<Longrightarrow> (i, a) \\<in> set xs \\<Longrightarrow> (j, a) \\<in> set xs \\<Longrightarrow> i = j\"", "lemma map_of_mapk_inj_on_SomeI:\n  \"inj_on f (fst ` (set t)) \\<Longrightarrow> map_of t k = Some x \\<Longrightarrow>\n    map_of (map (case_prod (\\<lambda>k. Pair (f k))) t) (f k) = Some x\"", "lemma map_abs_nonneg[simp]:\n  fixes xs::\"'a::ordered_ab_group_add_abs list\"\n  shows \"list_all (\\<lambda>x. x \\<ge> 0) xs \\<Longrightarrow> map abs xs = xs\"", "lemma the_inv_into_image_eq: \"inj_on f A \\<Longrightarrow> Y \\<subseteq> f ` A \\<Longrightarrow> the_inv_into A f ` Y = f -` Y \\<inter> A\"", "lemma image_fst_zip: \"length ys = length xs \\<Longrightarrow> fst ` set (zip ys xs) = set ys\"", "lemma inj_on_fst_set_zip_distinct[simp]:\n  \"distinct xs \\<Longrightarrow> length xs = length ys \\<Longrightarrow> inj_on fst (set (zip xs ys))\"", "lemma mem_greaterThanLessThan_absI:\n  fixes x::real\n  assumes \"abs x < 1\"\n  shows \"x \\<in> {-1 <..< 1}\"", "lemma minus_one_less_divideI: \"b > 0 \\<Longrightarrow> -b < a \\<Longrightarrow> -1 < a / (b::real)\"", "lemma divide_less_oneI: \"b > 0 \\<Longrightarrow> b > a \\<Longrightarrow> a / (b::real) < 1\"", "lemma closed_segment_real:\n  fixes a b::real\n  shows \"closed_segment a b = (if a \\<le> b then {a .. b} else {b .. a})\" (is \"_ = ?if\")", "lemma pdevs_eqI: \"(\\<And>i. pdevs_apply x i = pdevs_apply y i) \\<Longrightarrow> x = y\"", "lemma valuate_ex: \"x \\<in> valuate f \\<longleftrightarrow> (\\<exists>e. (\\<forall>i. e i \\<in> {-1 .. 1}) \\<and> x = f e)\"", "lemma Joints_nthE:\n  assumes \"zs \\<in> Joints ZS\"\n  obtains e where\n    \"\\<And>i. i < length zs \\<Longrightarrow> zs ! i = aform_val e (ZS ! i)\"\n    \"\\<And>i. e i \\<in> {-1..1}\"", "lemma Joints_mapE:\n  assumes \"ys \\<in> Joints YS\"\n  obtains e where\n    \"ys = map (\\<lambda>x. aform_val e x) YS\"\n    \"\\<And>i. e i \\<in> {-1 .. 1}\"", "lemma\n  zipped_subset_mapped_Elem:\n  assumes \"xs = map (aform_val e) XS\"\n  assumes e: \"\\<And>i. e i \\<in> {-1 .. 1}\"\n  assumes [simp]: \"length xs = length XS\"\n  assumes [simp]: \"length ys = length YS\"\n  assumes \"set (zip ys YS) \\<subseteq> set (zip xs XS)\"\n  shows \"ys = map (aform_val e) YS\"", "lemma Joints_set_zip_subset:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"length xs = length XS\"\n  assumes \"length ys = length YS\"\n  assumes \"set (zip ys YS) \\<subseteq> set (zip xs XS)\"\n  shows \"ys \\<in> Joints YS\"", "lemma Joints_set_zip:\n  assumes \"ys \\<in> Joints YS\"\n  assumes \"length xs = length XS\"\n  assumes \"length YS = length XS\"\n  assumes sets_eq: \"set (zip xs XS) = set (zip ys YS)\"\n  shows \"xs \\<in> Joints XS\"", "lemma Joints2E:\n  assumes \"zs_y \\<in> Joints2 ZS Y\"\n  obtains e where\n    \"\\<And>i. i < length (fst zs_y) \\<Longrightarrow> (fst zs_y) ! i = aform_val e (ZS ! i)\"\n    \"snd (zs_y) = aform_val e Y\"\n    \"\\<And>i. e i \\<in> {-1..1}\"", "lemma nth_in_AffineI:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"i < length XS\"\n  shows \"xs ! i \\<in> Affine (XS ! i)\"", "lemma Cons_nth_in_Joints1:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"i < length XS\"\n  shows \"((xs ! i) # xs) \\<in> Joints ((XS ! i) # XS)\"", "lemma Cons_nth_in_Joints2:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"i < length XS\"\n  assumes \"j < length XS\"\n  shows \"((xs ! i) #(xs ! j) # xs) \\<in> Joints ((XS ! i)#(XS ! j) # XS)\"", "lemma Joints_swap:\n  \"x#y#xs\\<in>Joints (X#Y#XS) \\<longleftrightarrow> y#x#xs \\<in> Joints (Y#X#XS)\"", "lemma Joints_swap_Cons_append:\n  \"length xs = length XS \\<Longrightarrow> x#ys@xs\\<in>Joints (X#YS@XS) \\<longleftrightarrow> ys@x#xs \\<in> Joints (YS@X#XS)\"", "lemma Joints_ConsD:\n  \"x#xs\\<in>Joints (X#XS) \\<Longrightarrow> xs \\<in> Joints XS\"", "lemma Joints_appendD1:\n  \"ys@xs\\<in>Joints (YS@XS) \\<Longrightarrow> length xs = length XS \\<Longrightarrow> xs \\<in> Joints XS\"", "lemma Joints_appendD2:\n  \"ys@xs\\<in>Joints (YS@XS) \\<Longrightarrow> length ys = length YS \\<Longrightarrow> ys \\<in> Joints YS\"", "lemma Joints_imp_length_eq: \"xs \\<in> Joints XS \\<Longrightarrow> length xs = length XS\"", "lemma Joints_rotate[simp]: \"xs@[x] \\<in> Joints (XS @[X]) \\<longleftrightarrow> x#xs \\<in> Joints (X#XS)\"", "lemma finite_pdevs_domain[intro, simp]: \"finite (pdevs_domain x)\"", "lemma in_pdevs_domain[simp]: \"i \\<in> pdevs_domain x \\<longleftrightarrow> pdevs_apply x i \\<noteq> 0\"", "lemma degree[rule_format, intro, simp]:\n  shows \"\\<forall>j\\<ge>degree x. pdevs_apply x j = 0\"", "lemma degree_le:\n  assumes d: \"\\<forall>j \\<ge> d. pdevs_apply x j = 0\"\n  shows \"degree x \\<le> d\"", "lemma degree_gt: \"pdevs_apply x j \\<noteq> 0 \\<Longrightarrow> degree x > j\"", "lemma pdevs_val_pdevs_domain: \"pdevs_val e X = (\\<Sum>i\\<in>pdevs_domain X. e i *\\<^sub>R pdevs_apply X i)\"", "lemma pdevs_val_sum_le: \"degree X \\<le> d \\<Longrightarrow> pdevs_val e X = (\\<Sum>i < d. e i *\\<^sub>R pdevs_apply X i)\"", "lemmas pdevs_val_sum = pdevs_val_sum_le[OF order_refl]", "lemma pdevs_val_zero[simp]: \"pdevs_val (\\<lambda>_. 0) x = 0\"", "lemma degree_eqI:\n  assumes \"pdevs_apply x d \\<noteq> 0\"\n  assumes \"\\<And>j. j > d \\<Longrightarrow> pdevs_apply x j = 0\"\n  shows \"degree x = Suc d\"", "lemma finite_degree_nonzero[intro, simp]: \"finite {i. pdevs_apply x i \\<noteq> 0}\"", "lemma degree_eq_Suc_max:\n  \"degree x = (if (\\<forall>i. pdevs_apply x i = 0) then 0 else Suc (Max {i. pdevs_apply x i \\<noteq> 0}))\"", "lemma pdevs_val_degree_cong:\n  assumes \"b = d\"\n  assumes \"\\<And>i. i < degree b \\<Longrightarrow> a i = c i\"\n  shows \"pdevs_val a b = pdevs_val c d\"", "lemma degree_cong: \"(\\<And>i. (pdevs_apply x i = 0) = (pdevs_apply y i = 0)) \\<Longrightarrow> degree x = degree y\"", "lemma Least_True_nat[intro, simp]: \"(LEAST i::nat. True) = 0\"", "lemma sorted_list_of_pdevs_domain_eq:\n  \"sorted_list_of_set (pdevs_domain X) = filter ((\\<noteq>) 0 o pdevs_apply X) [0..<degree X]\"", "lemma abs_pdevs_val_le_tdev: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1} \\<Longrightarrow> \\<bar>pdevs_val e x\\<bar> \\<le> tdev x\"", "lemma nonzeros_binop_pdevs_subset:\n  \"{i. binop_pdevs_raw f x y i \\<noteq> 0} \\<subseteq> {i. x i \\<noteq> 0} \\<union> {i. y i \\<noteq> 0}\"", "lemma pdevs_apply_binop_pdevs[simp]: \"pdevs_apply (binop_pdevs f x y) i =\n  (if pdevs_apply x i = 0 \\<and> pdevs_apply y i = 0 then 0 else f (pdevs_apply x i) (pdevs_apply y i))\"", "lemma pdevs_apply_add_pdevs[simp]:\n  \"pdevs_apply (add_pdevs X Y) n = pdevs_apply X n + pdevs_apply Y n\"", "lemma pdevs_val_add_pdevs[simp]:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y\"", "lemma tdev_eq_zero_iff: fixes X::\"real pdevs\" shows \"tdev X = 0 \\<longleftrightarrow> (\\<forall>e. pdevs_val e X = 0)\"", "lemma tdev_nonneg[intro, simp]: \"tdev X \\<ge> 0\"", "lemma tdev_nonpos_iff[simp]: \"tdev X \\<le> 0 \\<longleftrightarrow> tdev X = 0\"", "lemma nonzeros_unop_pdevs_subset: \"{i. unop_pdevs_raw f x i \\<noteq> 0} \\<subseteq> {i. x i \\<noteq> 0}\"", "lemma pdevs_apply_unop_pdevs[simp]: \"pdevs_apply (unop_pdevs f x) i =\n  (if pdevs_apply x i = 0 then 0 else f (pdevs_apply x i))\"", "lemma pdevs_domain_unop_linear:\n  assumes \"linear f\"\n  shows \"pdevs_domain (unop_pdevs f x) \\<subseteq> pdevs_domain x\"", "lemma\n  pdevs_val_unop_linear:\n  assumes \"linear f\"\n  shows \"pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)\"", "lemma pdevs_apply_scaleR_pdevs[simp]:\n  \"pdevs_apply (scaleR_pdevs x Y) n = x *\\<^sub>R pdevs_apply Y n\"", "lemma degree_scaleR_pdevs[simp]: \"degree (scaleR_pdevs r x) = (if r = 0 then 0 else degree x)\"", "lemma pdevs_val_scaleR_pdevs[simp]:\n  fixes x::real and Y::\"'a::real_normed_vector pdevs\"\n  shows \"pdevs_val e (scaleR_pdevs x Y) = x *\\<^sub>R pdevs_val e Y\"", "lemma pdevs_apply_pdevs_scaleR[simp]:\n  \"pdevs_apply (pdevs_scaleR X y) n = pdevs_apply X n *\\<^sub>R y\"", "lemma degree_pdevs_scaleR[simp]: \"degree (pdevs_scaleR r x) = (if x = 0 then 0 else degree r)\"", "lemma pdevs_val_pdevs_scaleR[simp]:\n  fixes X::\"real pdevs\" and y::\"'a::real_normed_vector\"\n  shows \"pdevs_val e (pdevs_scaleR X y) = pdevs_val e X *\\<^sub>R y\"", "lemma pdevs_apply_uminus_pdevs[simp]: \"pdevs_apply (uminus_pdevs x) = - pdevs_apply x\"", "lemma degree_uminus_pdevs[simp]: \"degree (uminus_pdevs x) = degree x\"", "lemma pdevs_val_uminus_pdevs[simp]: \"pdevs_val e (uminus_pdevs x) = - pdevs_val e x\"", "lemma fst_uminus_aform[simp]: \"fst (uminus_aform Y) = - fst Y\"", "lemma aform_val_uminus_aform[simp]: \"aform_val e (uminus_aform X) = - aform_val e X\"", "lemma pdevs_apply_zero_pdevs[simp]: \"pdevs_apply zero_pdevs i = 0\"", "lemma pdevs_val_zero_pdevs[simp]: \"pdevs_val e zero_pdevs = 0\"", "lemma pdevs_apply_pdevs_inner[simp]: \"pdevs_apply (pdevs_inner p a) i = pdevs_apply p i \\<bullet> a\"", "lemma pdevs_val_pdevs_inner[simp]: \"pdevs_val e (pdevs_inner p a) = pdevs_val e p \\<bullet> a\"", "lemma pdevs_apply_pdevs_inner2[simp]: \"pdevs_apply (pdevs_inner2 p a b) i = (pdevs_apply p i \\<bullet> a, pdevs_apply p i \\<bullet> b)\"", "lemma linear_inner2[intro, simp]: \"linear (\\<lambda>x. inner2 x n i)\"", "lemma aform_val_inner2_aform[simp]: \"aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i\"", "lemma pdevs_val_upd[simp]:\n  \"pdevs_val (e(n := e')) X = pdevs_val e X - e n * pdevs_apply X n + e' * pdevs_apply X n\"", "lemma nonzeros_fun_upd:\n  \"{i. (f(n := a)) i \\<noteq> 0} \\<subseteq> {i. f i \\<noteq> 0} \\<union> {n}\"", "lemma pdevs_apply_pdev_upd[simp]:\n  \"pdevs_apply (pdev_upd X n x) = (pdevs_apply X)(n:=x)\"", "lemma pdevs_val_pdev_upd[simp]:\n  \"pdevs_val e (pdev_upd X n x) = pdevs_val e X + e n *\\<^sub>R x - e n *\\<^sub>R pdevs_apply X n\"", "lemma degree_pdev_upd:\n  assumes \"x = 0 \\<longleftrightarrow> pdevs_apply X n = 0\"\n  shows \"degree (pdev_upd X n x) = degree X\"", "lemma degree_pdev_upd_le:\n  assumes \"degree X \\<le> n\"\n  shows \"degree (pdev_upd X n x) \\<le> Suc n\"", "lemma Inf_aform:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"Inf_aform X \\<le> aform_val e X\"", "lemma Sup_aform:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"aform_val e X \\<le> Sup_aform X\"", "lemma nonzeros_msum_pdevs_raw:\n  \"{i. msum_pdevs_raw n f g i \\<noteq> 0} = ({0..<n} \\<inter> {i. f i \\<noteq> 0}) \\<union> (+) n ` ({i. g i \\<noteq> 0})\"", "lemma pdevs_apply_msum_pdevs: \"pdevs_apply (msum_pdevs n f g) i =\n  (if i < n then pdevs_apply f i else pdevs_apply g (i - n))\"", "lemma degree_least_nonzero:\n  assumes \"degree f \\<noteq> 0\"\n  shows \"pdevs_apply f (degree f - 1) \\<noteq> 0\"", "lemma degree_leI:\n  assumes \"(\\<And>i. pdevs_apply y i = 0 \\<Longrightarrow> pdevs_apply x i = 0)\"\n  shows \"degree x \\<le> degree y\"", "lemma degree_msum_pdevs_ge1:\n  shows \"degree f \\<le> n \\<Longrightarrow> degree f \\<le> degree (msum_pdevs n f g)\"", "lemma degree_msum_pdevs_ge2:\n  assumes \"degree f \\<le> n\"\n  shows \"degree g \\<le> degree (msum_pdevs n f g) - n\"", "lemma degree_msum_pdevs_le:\n  shows \"degree (msum_pdevs n f g) \\<le> n + degree g\"", "lemma\n  sum_msum_pdevs_cases:\n  assumes \"degree f \\<le> n\"\n  assumes [simp]: \"\\<And>i. e i 0 = 0\"\n  shows\n    \"(\\<Sum>i <degree (msum_pdevs n f g).\n      e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i <degree f. e i (pdevs_apply f i)) + (\\<Sum>i <degree g. e (i + n) (pdevs_apply g i))\"\n  (is \"?lhs = ?rhs\")", "lemma tdev_msum_pdevs: \"degree f \\<le> n \\<Longrightarrow> tdev (msum_pdevs n f g) = tdev f + tdev g\"", "lemma pdevs_val_msum_pdevs:\n  \"degree f \\<le> n \\<Longrightarrow> pdevs_val e (msum_pdevs n f g) = pdevs_val e f + pdevs_val (\\<lambda>i. e (i + n)) g\"", "lemma fst_msum_aform[simp]: \"fst (msum_aform n f g) = fst f + fst g\"", "lemma snd_msum_aform[simp]: \"snd (msum_aform n f g) = msum_pdevs n (snd f) (snd g)\"", "lemma finite_nonzero_summable: \"finite {i. f i \\<noteq> 0} \\<Longrightarrow> summable f\"", "lemma aform_val_msum_aform:\n  assumes \"degree_aform f \\<le> n\"\n  shows \"aform_val e (msum_aform n f g) = aform_val e f + aform_val (\\<lambda>i. e (i + n)) g\"", "lemma Inf_aform_msum_aform:\n  \"degree_aform X \\<le> n \\<Longrightarrow> Inf_aform (msum_aform n X Y) = Inf_aform X + Inf_aform Y\"", "lemma Sup_aform_msum_aform:\n  \"degree_aform X \\<le> n \\<Longrightarrow> Sup_aform (msum_aform n X Y) = Sup_aform X + Sup_aform Y\"", "lemma degree_zero_pdevs[simp]: \"degree zero_pdevs = 0\"", "lemma independent_aform_Joints:\n  assumes \"x \\<in> Affine X\"\n  assumes \"y \\<in> Affine Y\"\n  shows \"[x, y] \\<in> Joints [X, independent_aform X Y]\"", "lemma msum_aform_Joints:\n  assumes \"d \\<ge> degree_aform X\"\n  assumes \"\\<And>X. X \\<in> set XS \\<Longrightarrow> d \\<ge> degree_aform X\"\n  assumes \"(x#xs) \\<in> Joints (X#XS)\"\n  assumes \"y \\<in> Affine Y\"\n  shows \"((x + y)#x#xs) \\<in> Joints (msum_aform d X Y#X#XS)\"", "lemma Joints_msum_aform:\n  assumes \"d \\<ge> degree_aform X\"\n  assumes \"\\<And>Y. Y \\<in> set YS \\<Longrightarrow> d \\<ge> degree_aform Y\"\n  shows \"Joints (msum_aform d X Y#YS) = {((x + y)#ys) |x y ys. y \\<in> Affine Y \\<and> x#ys \\<in> Joints (X#YS)}\"", "lemma Joints_singleton_image: \"Joints [x] = (\\<lambda>x. [x]) ` Affine x\"", "lemma Collect_extract_image: \"{g (f x y) |x y. P x y} = g ` {f x y |x y. P x y}\"", "lemma inj_Cons: \"inj (\\<lambda>x. x#xs)\"", "lemma Joints_Nil[simp]: \"Joints [] = {[]}\"", "lemma msum_pdevs_zero_ident[simp]: \"msum_pdevs 0 zero_pdevs x = x\"", "lemma msum_aform_zero_ident[simp]: \"msum_aform 0 (0, zero_pdevs) x = x\"", "lemma mem_Joints_singleton: \"(x \\<in> Joints [X]) = (\\<exists>y. x = [y] \\<and> y \\<in> Affine X)\"", "lemma singleton_mem_Joints[simp]: \"[x] \\<in> Joints [X] \\<longleftrightarrow> x \\<in> Affine X\"", "lemma msum_aform_Joints_without_first:\n  assumes \"d \\<ge> degree_aform X\"\n  assumes \"\\<And>X. X \\<in> set XS \\<Longrightarrow> d \\<ge> degree_aform X\"\n  assumes \"(x#xs) \\<in> Joints (X#XS)\"\n  assumes \"y \\<in> Affine Y\"\n  assumes \"z = x + y\"\n  shows \"z#xs \\<in> Joints (msum_aform d X Y#XS)\"", "lemma Affine_msum_aform:\n  assumes \"d \\<ge> degree_aform X\"\n  shows \"Affine (msum_aform d X Y) = {x + y |x y. x \\<in> Affine X \\<and> y \\<in> Affine Y}\"", "lemma Affine_zero_pdevs[simp]: \"Affine (0, zero_pdevs) = {0}\"", "lemma Affine_independent_aform:\n  \"Affine (independent_aform X Y) = Affine Y\"", "lemma\n  abs_diff_eq1:\n  fixes l u::\"'a::ordered_euclidean_space\"\n  shows \"l \\<le> u \\<Longrightarrow> \\<bar>u - l\\<bar> = u - l\"", "lemma compact_sum:\n  fixes f :: \"'a \\<Rightarrow> 'b::topological_space \\<Rightarrow> 'c::real_normed_vector\"\n  assumes \"finite I\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i)\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i)\"\n  assumes \"I \\<subseteq> J\"\n  shows \"compact {\\<Sum>i\\<in>I. f i (x i) | x. x \\<in> Pi J S}\"", "lemma compact_Affine:\n  fixes X::\"'a::ordered_euclidean_space aform\"\n  shows \"compact (Affine X)\"", "lemma Joints2_JointsI:\n  \"(xs, x) \\<in> Joints2 XS X \\<Longrightarrow> x#xs \\<in> Joints (X#XS)\"", "lemma split_aformE:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"x = aform_val e X\"\n  obtains err where \"x = aform_val (e(i:=err)) (fst (split_aform X i))\" \"err \\<in> {-1 .. 1}\"\n    | err where \"x = aform_val (e(i:=err)) (snd (split_aform X i))\" \"err \\<in> {-1 .. 1}\"", "lemma pdevs_val_add: \"pdevs_val (\\<lambda>i. e i + f i) xs = pdevs_val e xs + pdevs_val f xs\"", "lemma pdevs_val_minus: \"pdevs_val (\\<lambda>i. e i - f i) xs = pdevs_val e xs - pdevs_val f xs\"", "lemma pdevs_val_cmul: \"pdevs_val (\\<lambda>i. u * e i) xs = u *\\<^sub>R pdevs_val e xs\"", "lemma atLeastAtMost_absI: \"- a \\<le> a \\<Longrightarrow> \\<bar>x::real\\<bar> \\<le> \\<bar>a\\<bar> \\<Longrightarrow> x \\<in> atLeastAtMost (- a) a\"", "lemma divide_atLeastAtMost_1_absI: \"\\<bar>x::real\\<bar> \\<le> \\<bar>a\\<bar> \\<Longrightarrow> x/a \\<in> {-1 .. 1}\"", "lemma convex_scaleR_aux: \"u + v = 1 \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R x = (x::'a::real_vector)\"", "lemma convex_mult_aux: \"u + v = 1 \\<Longrightarrow> u * x + v * x = (x::real)\"", "lemma convex_Affine: \"convex (Affine X)\"", "lemma segment_in_aform_val:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"f \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"closed_segment (aform_val e X) (aform_val f X) \\<subseteq> Affine X\"", "lemma pdevs_apply_pdevs_of_list:\n  \"pdevs_apply (pdevs_of_list xs) i = (if i < length xs then xs ! i else 0)\"", "lemma pdevs_apply_pdevs_of_list_Nil[simp]:\n  \"pdevs_apply (pdevs_of_list []) i = 0\"", "lemma pdevs_apply_pdevs_of_list_Cons:\n  \"pdevs_apply (pdevs_of_list (x # xs)) i =\n    (if i = 0 then x else pdevs_apply (pdevs_of_list xs) (i - 1))\"", "lemma pdevs_domain_pdevs_of_list_Cons[simp]: \"pdevs_domain (pdevs_of_list (x # xs)) =\n  (if x = 0 then {} else {0}) \\<union> (+) 1 ` pdevs_domain (pdevs_of_list xs)\"", "lemma pdevs_val_pdevs_of_list_eq[simp]:\n  \"pdevs_val e (pdevs_of_list (x # xs)) = e 0 *\\<^sub>R x + pdevs_val (e o (+) 1) (pdevs_of_list xs)\"", "lemma\n  less_degree_pdevs_of_list_imp_less_length:\n  assumes \"i < degree (pdevs_of_list xs)\"\n  shows \"i < length xs\"", "lemma tdev_pdevs_of_list[simp]: \"tdev (pdevs_of_list xs) = sum_list (map abs xs)\"", "lemma pdevs_of_list_Nil[simp]: \"pdevs_of_list [] = zero_pdevs\"", "lemma pdevs_val_inj_sumI:\n  fixes K::\"'a set\" and g::\"'a \\<Rightarrow> nat\"\n  assumes \"finite K\"\n  assumes \"inj_on g K\"\n  assumes \"pdevs_domain x \\<subseteq> g ` K\"\n  assumes \"\\<And>i. i \\<in> K \\<Longrightarrow> g i \\<notin> pdevs_domain x \\<Longrightarrow> f i = 0\"\n  assumes \"\\<And>i. i \\<in> K \\<Longrightarrow> g i \\<in> pdevs_domain x \\<Longrightarrow> f i = e (g i) *\\<^sub>R pdevs_apply x (g i)\"\n  shows \"pdevs_val e x = (\\<Sum>i\\<in>K. f i)\"", "lemma pdevs_domain_pdevs_of_list_le: \"pdevs_domain (pdevs_of_list xs) \\<subseteq> {0..<length xs}\"", "lemma pdevs_val_zip: \"pdevs_val e (pdevs_of_list xs) = (\\<Sum>(i,x)\\<leftarrow>zip [0..<length xs] xs. e i *\\<^sub>R x)\"", "lemma scaleR_sum_list:\n  fixes xs::\"'a::real_vector list\"\n  shows \"a *\\<^sub>R sum_list xs = sum_list (map (scaleR a) xs)\"", "lemma pdevs_val_const_pdevs_of_list: \"pdevs_val (\\<lambda>_. c) (pdevs_of_list xs) = c *\\<^sub>R sum_list xs\"", "lemma pdevs_val_partition:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains f g where \"pdevs_val e (pdevs_of_list xs) =\n    pdevs_val f (pdevs_of_list (filter p xs)) +\n    pdevs_val g (pdevs_of_list (filter (Not o p) xs))\"\n    \"f \\<in> UNIV \\<rightarrow> I\"\n    \"g \\<in> UNIV \\<rightarrow> I\"", "lemma pdevs_apply_pdevs_of_list_append:\n  \"pdevs_apply (pdevs_of_list (xs @ zs)) i =\n    (if i < length xs\n    then pdevs_apply (pdevs_of_list xs) i else pdevs_apply (pdevs_of_list zs) (i - length xs))\"", "lemma degree_pdevs_of_list_le_length[intro, simp]: \"degree (pdevs_of_list xs) \\<le> length xs\"", "lemma degree_pdevs_of_list_append:\n  \"degree (pdevs_of_list (xs @ ys)) \\<le> length xs + degree (pdevs_of_list ys)\"", "lemma pdevs_val_pdevs_of_list_append:\n  assumes \"f \\<in> UNIV \\<rightarrow> I\"\n  assumes \"g \\<in> UNIV \\<rightarrow> I\"\n  obtains e where\n    \"pdevs_val f (pdevs_of_list xs) + pdevs_val g (pdevs_of_list ys) =\n      pdevs_val e (pdevs_of_list (xs @ ys))\"\n    \"e \\<in> UNIV \\<rightarrow> I\"", "lemma\n  sum_general_mono:\n  fixes f::\"'a\\<Rightarrow>('b::ordered_ab_group_add)\"\n  assumes [simp,intro]: \"finite s\" \"finite t\"\n  assumes f: \"\\<And>x. x \\<in> s - t \\<Longrightarrow> f x \\<le> 0\"\n  assumes g: \"\\<And>x. x \\<in> t - s \\<Longrightarrow> g x \\<ge> 0\"\n  assumes fg: \"\\<And>x. x \\<in> s \\<inter> t \\<Longrightarrow> f x \\<le> g x\"\n  shows \"(\\<Sum>x \\<in> s. f x) \\<le> (\\<Sum>x \\<in> t. g x)\"", "lemma pdevs_val_perm_ex:\n  assumes \"xs <~~> ys\"\n  assumes mem: \"e \\<in> UNIV \\<rightarrow> I\"\n  shows \"\\<exists>e'. e' \\<in> UNIV \\<rightarrow> I \\<and> pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\"", "lemma pdevs_val_perm:\n  assumes \"xs <~~> ys\"\n  assumes mem: \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n    \"pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\"", "lemma set_distinct_permI: \"set xs = set ys \\<Longrightarrow> distinct xs \\<Longrightarrow> distinct ys \\<Longrightarrow> xs <~~> ys\"", "lemmas pdevs_val_permute = pdevs_val_perm[OF set_distinct_permI]", "lemma partition_permI:\n  \"filter p xs @ filter (Not o p) xs <~~> xs\"", "lemma pdevs_val_eqI:\n  assumes \"\\<And>i. i \\<in> pdevs_domain y \\<Longrightarrow> i \\<in> pdevs_domain x \\<Longrightarrow>\n      e i *\\<^sub>R pdevs_apply x i = f i *\\<^sub>R pdevs_apply y i\"\n  assumes \"\\<And>i. i \\<in> pdevs_domain y \\<Longrightarrow> i \\<notin> pdevs_domain x \\<Longrightarrow> f i *\\<^sub>R pdevs_apply y i = 0\"\n  assumes \"\\<And>i. i \\<in> pdevs_domain x \\<Longrightarrow> i \\<notin> pdevs_domain y \\<Longrightarrow> e i *\\<^sub>R pdevs_apply x i = 0\"\n  shows \"pdevs_val e x = pdevs_val f y\"", "lemma filter_pdevs_raw_nonzeros: \"{i. filter_pdevs_raw s f i \\<noteq> 0} = {i. f i \\<noteq> 0} \\<inter> {x. s x (f x)}\"", "lemma pdevs_apply_filter_pdevs[simp]:\n  \"pdevs_apply (filter_pdevs I x) i = (if I i (pdevs_apply x i) then pdevs_apply x i else 0)\"", "lemma degree_filter_pdevs_le: \"degree (filter_pdevs I x) \\<le> degree x\"", "lemma pdevs_val_filter_pdevs:\n  \"pdevs_val e (filter_pdevs I x) =\n    (\\<Sum>i \\<in> {..<degree x} \\<inter> {i. I i (pdevs_apply x i)}. e i *\\<^sub>R pdevs_apply x i)\"", "lemma pdevs_val_filter_pdevs_dom:\n  \"pdevs_val e (filter_pdevs I x) =\n    (\\<Sum>i \\<in> pdevs_domain x \\<inter> {i. I i (pdevs_apply x i)}. e i *\\<^sub>R pdevs_apply x i)\"", "lemma pdevs_val_filter_pdevs_eval:\n  \"pdevs_val e (filter_pdevs p x) = pdevs_val (\\<lambda>i. if p i (pdevs_apply x i) then e i else 0) x\"", "lemma pdevs_applys_filter_pdevs_list[simp]:\n  \"pdevs_applys (filter_pdevs_list I X) i = (if I i (pdevs_applys X i) then pdevs_applys X i else\n    map (\\<lambda>_. 0) X)\"", "lemma degrees_leI:\n  assumes \"\\<And>x. x \\<in> set X \\<Longrightarrow> degree x \\<le> K\"\n  shows \"degrees X \\<le> K\"", "lemma degrees_leD:\n  assumes \"degrees X \\<le> K\"\n  shows \"\\<And>x. x \\<in> set X \\<Longrightarrow> degree x \\<le> K\"", "lemma degree_filter_pdevs_list_le: \"degrees (filter_pdevs_list I x) \\<le> degrees x\"", "lemma list_of_pdevs_zero_pdevs[simp]: \"list_of_pdevs zero_pdevs = []\"", "lemma sum_list_list_of_pdevs: \"sum_list (map snd (list_of_pdevs x)) = sum_list (dense_list_of_pdevs x)\"", "lemma sum_list_filter_dense_list_of_pdevs[symmetric]:\n  \"sum_list (map snd (filter (p o snd) (list_of_pdevs x))) =\n    sum_list (filter p (dense_list_of_pdevs x))\"", "lemma pdevs_of_list_dense_list_of_pdevs: \"pdevs_of_list (dense_list_of_pdevs x) = x\"", "lemma pdevs_val_sum_list: \"pdevs_val (\\<lambda>_. c) X = c *\\<^sub>R sum_list (map snd (list_of_pdevs X))\"", "lemma list_of_pdevs_all_nonzero: \"list_all (\\<lambda>x. x \\<noteq> 0) (map snd (list_of_pdevs xs))\"", "lemma list_of_pdevs_nonzero: \"x \\<in> set (map snd (list_of_pdevs xs)) \\<Longrightarrow> x \\<noteq> 0\"", "lemma pdevs_of_list_scaleR_0[simp]:\n  fixes xs::\"'a::real_vector list\"\n  shows \"pdevs_of_list (map ((*\\<^sub>R) 0) xs) = zero_pdevs\"", "lemma degree_pdevs_of_list_scaleR:\n  \"degree (pdevs_of_list (map ((*\\<^sub>R) c) xs)) = (if c \\<noteq> 0 then degree (pdevs_of_list xs) else 0)\"", "lemma list_of_pdevs_eq:\n  \"rev (list_of_pdevs X) = (filter ((\\<noteq>) 0 o snd) (map (\\<lambda>i. (i, pdevs_apply X i)) [0..<degree X]))\"\n  (is \"_ = filter ?P (map ?f ?xs)\")", "lemma sum_list_take_pdevs_val_eq:\n  \"sum_list (take d xs) = pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)\"", "lemma zero_in_range_pdevs_apply[intro, simp]:\n  fixes X::\"'a::real_vector pdevs\" shows \"0 \\<in> range (pdevs_apply X)\"", "lemma dense_list_in_range: \"x \\<in> set (dense_list_of_pdevs X) \\<Longrightarrow> x \\<in> range (pdevs_apply X)\"", "lemma not_in_dense_list_zeroD:\n  assumes \"pdevs_apply X i \\<notin> set (dense_list_of_pdevs X)\"\n  shows \"pdevs_apply X i = 0\"", "lemma list_all_list_of_pdevsI:\n  assumes \"\\<And>i. i \\<in> pdevs_domain X \\<Longrightarrow> P (pdevs_apply X i)\"\n  shows \"list_all (\\<lambda>x. P x) (map snd (list_of_pdevs X))\"", "lemma pdevs_of_list_map_scaleR:\n  \"pdevs_of_list (map (scaleR r) xs) = scaleR_pdevs r (pdevs_of_list xs)\"", "lemma\n  map_permI:\n  assumes \"xs <~~> ys\"\n  shows \"map f xs <~~> map f ys\"", "lemma rev_perm: \"rev xs <~~> ys \\<longleftrightarrow> xs <~~> ys\"", "lemma list_of_pdevs_perm_filter_nonzero:\n  \"map snd (list_of_pdevs X) <~~> (filter ((\\<noteq>) 0) (dense_list_of_pdevs X))\"", "lemma pdevs_val_filter:\n  assumes mem: \"e \\<in> UNIV \\<rightarrow> I\"\n  assumes \"0 \\<in> I\"\n  obtains e' where\n    \"pdevs_val e (pdevs_of_list (filter p xs)) = pdevs_val e' (pdevs_of_list xs)\"\n    \"e' \\<in> UNIV \\<rightarrow> I\"", "lemma\n  pdevs_val_of_list_of_pdevs:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  assumes \"0 \\<in> I\"\n  obtains e' where\n    \"pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) = pdevs_val e' X\"\n    \"e' \\<in> UNIV \\<rightarrow> I\"", "lemma\n  pdevs_val_of_list_of_pdevs2:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains e' where\n    \"pdevs_val e X = pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)))\"\n    \"e' \\<in> UNIV \\<rightarrow> I\"", "lemma dense_list_of_pdevs_scaleR:\n  \"r \\<noteq> 0 \\<Longrightarrow> map ((*\\<^sub>R) r) (dense_list_of_pdevs x) = dense_list_of_pdevs (scaleR_pdevs r x)\"", "lemma degree_pdevs_of_list_eq:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0) \\<Longrightarrow> degree (pdevs_of_list xs) = length xs\"", "lemma dense_list_of_pdevs_pdevs_of_list:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0) \\<Longrightarrow> dense_list_of_pdevs (pdevs_of_list xs) = xs\"", "lemma pdevs_of_list_sum:\n  assumes \"distinct xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains f where \"f \\<in> UNIV \\<rightarrow> I\" \"pdevs_val e (pdevs_of_list xs) = (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\"", "lemma pdevs_domain_eq_pdevs_of_list:\n  assumes nz: \"\\<And>x. x \\<in> set (xs) \\<Longrightarrow> x \\<noteq> 0\"\n  shows \"pdevs_domain (pdevs_of_list xs) = {0..<length xs}\"", "lemma length_list_of_pdevs_pdevs_of_list:\n  assumes nz: \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0\"\n  shows \"length (list_of_pdevs (pdevs_of_list xs)) = length xs\"", "lemma nth_list_of_pdevs_pdevs_of_list:\n  assumes nz: \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0\"\n  assumes l: \"n < length xs\"\n  shows \"list_of_pdevs (pdevs_of_list xs) ! n  = ((length xs - Suc n), xs ! (length xs - Suc n))\"", "lemma list_of_pdevs_pdevs_of_list_eq:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0) \\<Longrightarrow>\n    list_of_pdevs (pdevs_of_list xs) = zip (rev [0..<length xs]) (rev xs)\"", "lemma sum_list_filter_list_of_pdevs_of_list:\n  fixes xs::\"'a::comm_monoid_add list\"\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0\"\n  shows \"sum_list (filter p (map snd (list_of_pdevs (pdevs_of_list xs)))) = sum_list (filter p xs)\"", "lemma\n  sum_list_partition:\n  fixes xs::\"'a::comm_monoid_add list\"\n  shows \"sum_list (filter p xs) + sum_list (filter (Not o p) xs) = sum_list xs\"", "lemma apply_pdevs_prod_of_pdevs[simp]:\n  \"pdevs_apply (prod_of_pdevs x y) i = (pdevs_apply x i, pdevs_apply y i)\"", "lemma pdevs_domain_prod_of_pdevs[simp]:\n  \"pdevs_domain (prod_of_pdevs x y) = pdevs_domain x \\<union> pdevs_domain y\"", "lemma pdevs_val_prod_of_pdevs[simp]:\n  \"pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)\"", "lemma zeros_One_pdevs_raw:\n  \"One_pdevs_raw -` {0::'a::executable_euclidean_space} = {length (Basis_list::'a list)..}\"", "lemma nonzeros_One_pdevs_raw:\n  \"{i. One_pdevs_raw i \\<noteq> (0::'a::executable_euclidean_space)} = - {length (Basis_list::'a list)..}\"", "lemma pdevs_apply_One_pdevs[simp]: \"pdevs_apply One_pdevs i =\n  (if i < length (Basis_list::'a::executable_euclidean_space list) then Basis_list ! i else 0::'a)\"", "lemma Max_Collect_less_nat: \"Max {i::nat. i < k} = (if k = 0 then Max {} else k - 1)\"", "lemma degree_One_pdevs[simp]: \"degree (One_pdevs::'a pdevs) =\n    length (Basis_list::'a::executable_euclidean_space list)\"", "lemma pdevs_apply_inner_scaleR_pdevs[simp]:\n  \"pdevs_apply (inner_scaleR_pdevs a x) i = (a \\<bullet> (pdevs_apply x i)) *\\<^sub>R (pdevs_apply x i)\"", "lemma degree_inner_scaleR_pdevs_le:\n  \"degree (inner_scaleR_pdevs (l::'a::executable_euclidean_space) One_pdevs) \\<le>\n    degree (One_pdevs::'a pdevs)\"", "lemma degree_pdevs_of_ivl_le:\n  \"degree (pdevs_of_ivl l u::'a::executable_euclidean_space pdevs) \\<le> DIM('a)\"", "lemma pdevs_apply_pdevs_of_ivl:\n  defines \"B \\<equiv> Basis_list::'a::executable_euclidean_space list\"\n  shows \"pdevs_apply (pdevs_of_ivl l u) i = (if i < length B then ((u - l)\\<bullet>(B!i)/2)*\\<^sub>R(B!i) else 0)\"", "lemma deg_length_less_imp[simp]:\n  \"k < degree (pdevs_of_ivl l u::'a::executable_euclidean_space pdevs) \\<Longrightarrow>\n    k < length (Basis_list::'a list)\"", "lemma tdev_pdevs_of_ivl: \"tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2\"", "lemma Elem_affine_of_ivl_le:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"l \\<le> u\"\n  shows \"l \\<le> aform_val e (aform_of_ivl l u)\"", "lemma Elem_affine_of_ivl_ge:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"l \\<le> u\"\n  shows \"aform_val e (aform_of_ivl l u) \\<le> u\"", "lemma\n  map_of_zip_upto_length_eq_nth:\n  assumes \"i < length B\"\n  assumes \"d = length B\"\n  shows \"(map_of (zip [0..<d] B) i) = Some (B ! i)\"", "lemma in_ivl_affine_of_ivlE:\n  assumes \"k \\<in> {l .. u}\"\n  obtains e where \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\" \"k = aform_val e (aform_of_ivl l u)\"", "lemma Inf_aform_aform_of_ivl:\n  assumes \"l \\<le> u\"\n  shows \"Inf_aform (aform_of_ivl l u) = l\"", "lemma Sup_aform_aform_of_ivl:\n  assumes \"l \\<le> u\"\n  shows \"Sup_aform (aform_of_ivl l u) = u\"", "lemma Affine_aform_of_ivl:\n  \"a \\<le> b \\<Longrightarrow> Affine (aform_of_ivl a b) = {a .. b}\""], "translations": [["", "lemma sum_list_mono:\n  fixes xs ys::\"'a::ordered_ab_group_add list\"\n  shows\n    \"length xs = length ys \\<Longrightarrow> (\\<And>x y. (x, y) \\<in> set (zip xs ys) \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n      sum_list xs \\<le> sum_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys;\n     \\<And>x y.\n        (x, y) \\<in> set (zip xs ys) \\<Longrightarrow> x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> sum_list xs \\<le> sum_list ys", "by (induct xs ys rule: list_induct2) (auto simp: algebra_simps intro: add_mono)"], ["", "lemma\n  fixes xs::\"'a::ordered_comm_monoid_add list\"\n  shows sum_list_nonneg: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<ge> 0) \\<Longrightarrow> sum_list xs \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> (0::'a) \\<le> x) \\<Longrightarrow>\n    (0::'a) \\<le> sum_list xs", "by (induct xs) (auto intro!: add_nonneg_nonneg)"], ["", "lemma map_filter:\n  \"map f (filter (\\<lambda>x. P (f x)) xs) = filter P (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (filter (\\<lambda>x. P (f x)) xs) = filter P (map f xs)", "by (induct xs) simp_all"], ["", "lemma\n  map_of_zip_upto2_length_eq_nth:\n  assumes \"distinct B\"\n  assumes \"i < length B\"\n  shows \"(map_of (zip B [0..<length B]) (B ! i)) = Some i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (zip B [0..<length B]) (B ! i) = Some i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (zip B [0..<length B]) (B ! i) = Some i", "have \"length [0..<length B] = length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<length B] = length B", "by simp"], ["proof (state)\nthis:\n  length [0..<length B] = length B\n\ngoal (1 subgoal):\n 1. map_of (zip B [0..<length B]) (B ! i) = Some i", "from map_of_zip_is_Some[OF this, of i] assms"], ["proof (chain)\npicking this:\n  (i \\<in> set [0..<length B]) =\n  (\\<exists>y. map_of (zip [0..<length B] B) i = Some y)\n  distinct B\n  i < length B", "have \"map_of (zip B [0..<length B]) (B ! i) = Some i\""], ["proof (prove)\nusing this:\n  (i \\<in> set [0..<length B]) =\n  (\\<exists>y. map_of (zip [0..<length B] B) i = Some y)\n  distinct B\n  i < length B\n\ngoal (1 subgoal):\n 1. map_of (zip B [0..<length B]) (B ! i) = Some i", "using assms"], ["proof (prove)\nusing this:\n  (i \\<in> set [0..<length B]) =\n  (\\<exists>y. map_of (zip [0..<length B] B) i = Some y)\n  distinct B\n  i < length B\n  distinct B\n  i < length B\n\ngoal (1 subgoal):\n 1. map_of (zip B [0..<length B]) (B ! i) = Some i", "by (auto simp: in_set_zip)"], ["proof (state)\nthis:\n  map_of (zip B [0..<length B]) (B ! i) = Some i\n\ngoal (1 subgoal):\n 1. map_of (zip B [0..<length B]) (B ! i) = Some i", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of (zip B [0..<length B]) (B ! i) = Some i\n\ngoal (1 subgoal):\n 1. map_of (zip B [0..<length B]) (B ! i) = Some i", "by simp"], ["proof (state)\nthis:\n  map_of (zip B [0..<length B]) (B ! i) = Some i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_map_fst_snd_eqD:\n  \"distinct (map fst xs) \\<Longrightarrow> (i, a) \\<in> set xs \\<Longrightarrow> (i, b) \\<in> set xs \\<Longrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); (i, a) \\<in> set xs;\n     (i, b) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> a = b", "by (metis (lifting) map_of_is_SomeI option.inject)"], ["", "lemma length_filter_snd_zip:\n  \"length ys = length xs \\<Longrightarrow> length (filter (p \\<circ> snd) (zip ys xs)) = length (filter p xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length xs \\<Longrightarrow>\n    length (filter (p \\<circ> snd) (zip ys xs)) = length (filter p xs)", "by (induct ys xs rule: list_induct2) (auto )"], ["", "lemma filter_snd_nth:\n  \"length ys = length xs \\<Longrightarrow> n < length (filter p xs) \\<Longrightarrow>\n    snd (filter (p \\<circ> snd) (zip ys xs) ! n) = filter p xs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ys = length xs; n < length (filter p xs)\\<rbrakk>\n    \\<Longrightarrow> snd (filter (p \\<circ> snd) (zip ys xs) ! n) =\n                      filter p xs ! n", "by (induct ys xs arbitrary: n rule: list_induct2) (auto simp: o_def nth_Cons split: nat.split)"], ["", "lemma distinct_map_snd_fst_eqD:\n  \"distinct (map snd xs) \\<Longrightarrow> (i, a) \\<in> set xs \\<Longrightarrow> (j, a) \\<in> set xs \\<Longrightarrow> i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map snd xs); (i, a) \\<in> set xs;\n     (j, a) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> i = j", "by (metis Pair_inject inj_on_contraD snd_conv distinct_map)"], ["", "lemma map_of_mapk_inj_on_SomeI:\n  \"inj_on f (fst ` (set t)) \\<Longrightarrow> map_of t k = Some x \\<Longrightarrow>\n    map_of (map (case_prod (\\<lambda>k. Pair (f k))) t) (f k) = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (fst ` set t); map_of t k = Some x\\<rbrakk>\n    \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) t) (f k) =\n                      Some x", "by (induct t) (auto simp add: inj_on_def dest!: map_of_SomeD split: if_split_asm)"], ["", "lemma map_abs_nonneg[simp]:\n  fixes xs::\"'a::ordered_ab_group_add_abs list\"\n  shows \"list_all (\\<lambda>x. x \\<ge> 0) xs \\<Longrightarrow> map abs xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all ((\\<le>) (0::'a)) xs \\<Longrightarrow> map abs xs = xs", "by (induct xs) auto"], ["", "lemma the_inv_into_image_eq: \"inj_on f A \\<Longrightarrow> Y \\<subseteq> f ` A \\<Longrightarrow> the_inv_into A f ` Y = f -` Y \\<inter> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; Y \\<subseteq> f ` A\\<rbrakk>\n    \\<Longrightarrow> the_inv_into A f ` Y = f -` Y \\<inter> A", "using f_the_inv_into_f the_inv_into_f_f[where f = f and A = A]"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on ?f ?A; ?y \\<in> ?f ` ?A\\<rbrakk>\n  \\<Longrightarrow> ?f (the_inv_into ?A ?f ?y) = ?y\n  \\<lbrakk>inj_on f A; ?x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> the_inv_into A f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; Y \\<subseteq> f ` A\\<rbrakk>\n    \\<Longrightarrow> the_inv_into A f ` Y = f -` Y \\<inter> A", "by force"], ["", "lemma image_fst_zip: \"length ys = length xs \\<Longrightarrow> fst ` set (zip ys xs) = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length xs \\<Longrightarrow> fst ` set (zip ys xs) = set ys", "by (metis dom_map_of_conv_image_fst dom_map_of_zip)"], ["", "lemma inj_on_fst_set_zip_distinct[simp]:\n  \"distinct xs \\<Longrightarrow> length xs = length ys \\<Longrightarrow> inj_on fst (set (zip xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; length xs = length ys\\<rbrakk>\n    \\<Longrightarrow> inj_on fst (set (zip xs ys))", "by (force simp add: in_set_zip distinct_conv_nth intro!: inj_onI)"], ["", "lemma mem_greaterThanLessThan_absI:\n  fixes x::real\n  assumes \"abs x < 1\"\n  shows \"x \\<in> {-1 <..< 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {- 1<..<1}", "using assms"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> < 1\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1<..<1}", "by (auto simp: abs_real_def split: if_split_asm)"], ["", "lemma minus_one_less_divideI: \"b > 0 \\<Longrightarrow> -b < a \\<Longrightarrow> -1 < a / (b::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < b; - b < a\\<rbrakk> \\<Longrightarrow> - 1 < a / b", "by (auto simp: field_simps)"], ["", "lemma divide_less_oneI: \"b > 0 \\<Longrightarrow> b > a \\<Longrightarrow> a / (b::real) < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < b; a < b\\<rbrakk> \\<Longrightarrow> a / b < 1", "by (auto simp: field_simps)"], ["", "lemma closed_segment_real:\n  fixes a b::real\n  shows \"closed_segment a b = (if a \\<le> b then {a .. b} else {b .. a})\" (is \"_ = ?if\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment a b = (if a \\<le> b then {a..b} else {b..a})", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> closed_segment a b \\<Longrightarrow>\n       x \\<in> (if a \\<le> b then {a..b} else {b..a})\n 2. \\<And>x.\n       x \\<in> (if a \\<le> b then {a..b} else {b..a}) \\<Longrightarrow>\n       x \\<in> closed_segment a b", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> closed_segment a b \\<Longrightarrow>\n       x \\<in> (if a \\<le> b then {a..b} else {b..a})\n 2. \\<And>x.\n       x \\<in> (if a \\<le> b then {a..b} else {b..a}) \\<Longrightarrow>\n       x \\<in> closed_segment a b", "assume \"x \\<in> closed_segment a b\""], ["proof (state)\nthis:\n  x \\<in> closed_segment a b\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> closed_segment a b \\<Longrightarrow>\n       x \\<in> (if a \\<le> b then {a..b} else {b..a})\n 2. \\<And>x.\n       x \\<in> (if a \\<le> b then {a..b} else {b..a}) \\<Longrightarrow>\n       x \\<in> closed_segment a b", "from segment_bound[OF this]"], ["proof (chain)\npicking this:\n  norm (x - a) \\<le> norm (b - a)\n  norm (x - b) \\<le> norm (b - a)", "show \"x \\<in> ?if\""], ["proof (prove)\nusing this:\n  norm (x - a) \\<le> norm (b - a)\n  norm (x - b) \\<le> norm (b - a)\n\ngoal (1 subgoal):\n 1. x \\<in> (if a \\<le> b then {a..b} else {b..a})", "by (auto simp: abs_real_def split: if_split_asm)"], ["proof (state)\nthis:\n  x \\<in> (if a \\<le> b then {a..b} else {b..a})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (if a \\<le> b then {a..b} else {b..a}) \\<Longrightarrow>\n       x \\<in> closed_segment a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (if a \\<le> b then {a..b} else {b..a}) \\<Longrightarrow>\n       x \\<in> closed_segment a b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (if a \\<le> b then {a..b} else {b..a}) \\<Longrightarrow>\n       x \\<in> closed_segment a b", "assume \"x \\<in> ?if\""], ["proof (state)\nthis:\n  x \\<in> (if a \\<le> b then {a..b} else {b..a})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (if a \\<le> b then {a..b} else {b..a}) \\<Longrightarrow>\n       x \\<in> closed_segment a b", "thus \"x \\<in> closed_segment a b\""], ["proof (prove)\nusing this:\n  x \\<in> (if a \\<le> b then {a..b} else {b..a})\n\ngoal (1 subgoal):\n 1. x \\<in> closed_segment a b", "by (auto simp: closed_segment_def intro!: exI[where x=\"(x - a)/(b - a)\"]\n      simp: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  x \\<in> closed_segment a b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Partial Deviations\\<close>"], ["", "typedef (overloaded) 'a pdevs = \"{x::nat \\<Rightarrow> 'a::zero. finite {i. x i \\<noteq> 0}}\"\n  \\<comment> \\<open>TODO: unify with polynomials\\<close>\n  morphisms pdevs_apply Abs_pdev"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {x. finite {i. x i \\<noteq> (0::'a)}}", "by (auto intro!: exI[where x=\"\\<lambda>x. 0\"])"], ["", "setup_lifting type_definition_pdevs"], ["", "lemma pdevs_eqI: \"(\\<And>i. pdevs_apply x i = pdevs_apply y i) \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. pdevs_apply x i = pdevs_apply y i) \\<Longrightarrow> x = y", "by transfer auto"], ["", "definition pdevs_val :: \"(nat \\<Rightarrow> real) \\<Rightarrow> 'a::real_normed_vector pdevs \\<Rightarrow> 'a\"\n  where \"pdevs_val e x = (\\<Sum>i. e i *\\<^sub>R pdevs_apply x i)\""], ["", "definition valuate:: \"((nat \\<Rightarrow> real) \\<Rightarrow> 'a) \\<Rightarrow> 'a set\"\n  where \"valuate x = x ` (UNIV \\<rightarrow> {-1 .. 1})\""], ["", "lemma valuate_ex: \"x \\<in> valuate f \\<longleftrightarrow> (\\<exists>e. (\\<forall>i. e i \\<in> {-1 .. 1}) \\<and> x = f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> valuate f) =\n    (\\<exists>e. (\\<forall>i. e i \\<in> {- 1..1}) \\<and> x = f e)", "unfolding valuate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> f ` (UNIV \\<rightarrow> {- 1..1})) =\n    (\\<exists>e. (\\<forall>i. e i \\<in> {- 1..1}) \\<and> x = f e)", "by (auto simp add: valuate_def Pi_iff) blast"], ["", "instantiation pdevs :: (equal) equal\nbegin"], ["", "definition equal_pdevs::\"'a pdevs \\<Rightarrow> 'a pdevs \\<Rightarrow> bool\"\n  where \"equal_pdevs a b \\<longleftrightarrow> a = b\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a pdevs, equal_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "qed (simp add: equal_pdevs_def)"], ["", "end"], ["", "subsection \\<open>Affine Forms\\<close>"], ["", "text \\<open>The data structure of affine forms represents particular sets, zonotopes\\<close>"], ["", "type_synonym 'a aform = \"'a \\<times> 'a pdevs\""], ["", "subsection \\<open>Evaluation, Range, Joint Range\\<close>"], ["", "definition aform_val :: \"(nat \\<Rightarrow> real) \\<Rightarrow> 'a::real_normed_vector aform \\<Rightarrow> 'a\"\n  where \"aform_val e X = fst X + pdevs_val e (snd X)\""], ["", "definition Affine ::\n    \"'a::real_normed_vector aform \\<Rightarrow> 'a set\"\n  where \"Affine X = valuate (\\<lambda>e. aform_val e X)\""], ["", "definition Joints ::\n    \"'a::real_normed_vector aform list \\<Rightarrow> 'a list set\"\n  where \"Joints XS = valuate (\\<lambda>e. map (aform_val e) XS)\""], ["", "lemma Joints_nthE:\n  assumes \"zs \\<in> Joints ZS\"\n  obtains e where\n    \"\\<And>i. i < length zs \\<Longrightarrow> zs ! i = aform_val e (ZS ! i)\"\n    \"\\<And>i. e i \\<in> {-1..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>\\<And>i.\n                    i < length zs \\<Longrightarrow>\n                    zs ! i = aform_val e (ZS ! i);\n         \\<And>i. e i \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  zs \\<in> Joints ZS\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>\\<And>i.\n                    i < length zs \\<Longrightarrow>\n                    zs ! i = aform_val e (ZS ! i);\n         \\<And>i. e i \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto simp: Joints_def Pi_iff valuate_ex)"], ["", "lemma Joints_mapE:\n  assumes \"ys \\<in> Joints YS\"\n  obtains e where\n    \"ys = map (\\<lambda>x. aform_val e x) YS\"\n    \"\\<And>i. e i \\<in> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>ys = map (aform_val e) YS;\n         \\<And>i. e i \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ys \\<in> Joints YS\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>ys = map (aform_val e) YS;\n         \\<And>i. e i \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: Joints_def valuate_def)"], ["", "lemma\n  zipped_subset_mapped_Elem:\n  assumes \"xs = map (aform_val e) XS\"\n  assumes e: \"\\<And>i. e i \\<in> {-1 .. 1}\"\n  assumes [simp]: \"length xs = length XS\"\n  assumes [simp]: \"length ys = length YS\"\n  assumes \"set (zip ys YS) \\<subseteq> set (zip xs XS)\"\n  shows \"ys = map (aform_val e) YS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = map (aform_val e) YS", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ys = map (aform_val e) YS", "from assms"], ["proof (chain)\npicking this:\n  xs = map (aform_val e) XS\n  e ?i \\<in> {- 1..1}\n  length xs = length XS\n  length ys = length YS\n  set (zip ys YS) \\<subseteq> set (zip xs XS)", "have ys: \"\\<And>i. i < length xs \\<Longrightarrow> xs ! i = aform_val e (XS ! i)\""], ["proof (prove)\nusing this:\n  xs = map (aform_val e) XS\n  e ?i \\<in> {- 1..1}\n  length xs = length XS\n  length ys = length YS\n  set (zip ys YS) \\<subseteq> set (zip xs XS)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length xs \\<Longrightarrow> xs ! i = aform_val e (XS ! i)", "by auto"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow> xs ! ?i = aform_val e (XS ! ?i)\n\ngoal (1 subgoal):\n 1. ys = map (aform_val e) YS", "from assms"], ["proof (chain)\npicking this:\n  xs = map (aform_val e) XS\n  e ?i \\<in> {- 1..1}\n  length xs = length XS\n  length ys = length YS\n  set (zip ys YS) \\<subseteq> set (zip xs XS)", "have set_eq: \"{(ys ! i, YS ! i) |i. i < length ys \\<and> i < length YS} \\<subseteq>\n    {(xs ! i, XS ! i) |i. i < length xs \\<and> i < length XS}\""], ["proof (prove)\nusing this:\n  xs = map (aform_val e) XS\n  e ?i \\<in> {- 1..1}\n  length xs = length XS\n  length ys = length YS\n  set (zip ys YS) \\<subseteq> set (zip xs XS)\n\ngoal (1 subgoal):\n 1. {(ys ! i, YS ! i) |i. i < length ys \\<and> i < length YS}\n    \\<subseteq> {(xs ! i, XS ! i) |i. i < length xs \\<and> i < length XS}", "using assms(2)"], ["proof (prove)\nusing this:\n  xs = map (aform_val e) XS\n  e ?i \\<in> {- 1..1}\n  length xs = length XS\n  length ys = length YS\n  set (zip ys YS) \\<subseteq> set (zip xs XS)\n  e ?i \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. {(ys ! i, YS ! i) |i. i < length ys \\<and> i < length YS}\n    \\<subseteq> {(xs ! i, XS ! i) |i. i < length xs \\<and> i < length XS}", "by (auto simp: set_zip)"], ["proof (state)\nthis:\n  {(ys ! i, YS ! i) |i. i < length ys \\<and> i < length YS}\n  \\<subseteq> {(xs ! i, XS ! i) |i. i < length xs \\<and> i < length XS}\n\ngoal (1 subgoal):\n 1. ys = map (aform_val e) YS", "hence \"\\<forall>i<length YS. \\<exists>j<length XS. ys ! i = xs ! j \\<and> YS ! i = XS ! j\""], ["proof (prove)\nusing this:\n  {(ys ! i, YS ! i) |i. i < length ys \\<and> i < length YS}\n  \\<subseteq> {(xs ! i, XS ! i) |i. i < length xs \\<and> i < length XS}\n\ngoal (1 subgoal):\n 1. \\<forall>i<length YS.\n       \\<exists>j<length XS. ys ! i = xs ! j \\<and> YS ! i = XS ! j", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length YS.\n     \\<exists>j<length XS. ys ! i = xs ! j \\<and> YS ! i = XS ! j\n\ngoal (1 subgoal):\n 1. ys = map (aform_val e) YS", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length YS.\n     \\<exists>j<length XS. ys ! i = xs ! j \\<and> YS ! i = XS ! j", "obtain j where j: \"\\<And>i. i < length YS \\<Longrightarrow> ys ! i = xs ! (j i)\"\n    \"\\<And>i. i < length YS \\<Longrightarrow> YS ! i = XS ! (j i)\"\n    \"\\<And>i. i < length YS \\<Longrightarrow> j i < length XS\""], ["proof (prove)\nusing this:\n  \\<forall>i<length YS.\n     \\<exists>j<length XS. ys ! i = xs ! j \\<and> YS ! i = XS ! j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>\\<And>i. i < length YS \\<Longrightarrow> ys ! i = xs ! j i;\n         \\<And>i. i < length YS \\<Longrightarrow> YS ! i = XS ! j i;\n         \\<And>i. i < length YS \\<Longrightarrow> j i < length XS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?i < length YS \\<Longrightarrow> ys ! ?i = xs ! j ?i\n  ?i < length YS \\<Longrightarrow> YS ! ?i = XS ! j ?i\n  ?i < length YS \\<Longrightarrow> j ?i < length XS\n\ngoal (1 subgoal):\n 1. ys = map (aform_val e) YS", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = map (aform_val e) YS", "using assms"], ["proof (prove)\nusing this:\n  xs = map (aform_val e) XS\n  e ?i \\<in> {- 1..1}\n  length xs = length XS\n  length ys = length YS\n  set (zip ys YS) \\<subseteq> set (zip xs XS)\n\ngoal (1 subgoal):\n 1. ys = map (aform_val e) YS", "by (auto simp: Joints_def j ys intro!: exI[where x=e] nth_equalityI)"], ["proof (state)\nthis:\n  ys = map (aform_val e) YS\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Joints_set_zip_subset:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"length xs = length XS\"\n  assumes \"length ys = length YS\"\n  assumes \"set (zip ys YS) \\<subseteq> set (zip xs XS)\"\n  shows \"ys \\<in> Joints YS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> Joints YS", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ys \\<in> Joints YS", "from Joints_mapE assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?ys \\<in> Joints ?YS;\n   \\<And>e.\n      \\<lbrakk>?ys = map (aform_val e) ?YS;\n       \\<And>i. e i \\<in> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  xs \\<in> Joints XS\n  length xs = length XS\n  length ys = length YS\n  set (zip ys YS) \\<subseteq> set (zip xs XS)", "obtain e where\n    ys: \"xs = map (\\<lambda>x. aform_val e x) XS\"\n    and e: \"\\<And>i. e i \\<in> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ys \\<in> Joints ?YS;\n   \\<And>e.\n      \\<lbrakk>?ys = map (aform_val e) ?YS;\n       \\<And>i. e i \\<in> {- 1..1}\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  xs \\<in> Joints XS\n  length xs = length XS\n  length ys = length YS\n  set (zip ys YS) \\<subseteq> set (zip xs XS)\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>xs = map (aform_val e) XS;\n         \\<And>i. e i \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = map (aform_val e) XS\n  e ?i \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. ys \\<in> Joints YS", "show \"ys \\<in> Joints YS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> Joints YS", "using e zipped_subset_mapped_Elem[OF ys e assms(2-4)]"], ["proof (prove)\nusing this:\n  e ?i \\<in> {- 1..1}\n  ys = map (aform_val e) YS\n\ngoal (1 subgoal):\n 1. ys \\<in> Joints YS", "by (auto simp: Joints_def valuate_def intro!: exI[where x=e])"], ["proof (state)\nthis:\n  ys \\<in> Joints YS\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Joints_set_zip:\n  assumes \"ys \\<in> Joints YS\"\n  assumes \"length xs = length XS\"\n  assumes \"length YS = length XS\"\n  assumes sets_eq: \"set (zip xs XS) = set (zip ys YS)\"\n  shows \"xs \\<in> Joints XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> Joints XS", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<in> Joints XS", "from assms"], ["proof (chain)\npicking this:\n  ys \\<in> Joints YS\n  length xs = length XS\n  length YS = length XS\n  set (zip xs XS) = set (zip ys YS)", "have \"length ys = length YS\""], ["proof (prove)\nusing this:\n  ys \\<in> Joints YS\n  length xs = length XS\n  length YS = length XS\n  set (zip xs XS) = set (zip ys YS)\n\ngoal (1 subgoal):\n 1. length ys = length YS", "by (auto simp: Joints_def valuate_def)"], ["proof (state)\nthis:\n  length ys = length YS\n\ngoal (1 subgoal):\n 1. xs \\<in> Joints XS", "from assms(1) this assms(2)"], ["proof (chain)\npicking this:\n  ys \\<in> Joints YS\n  length ys = length YS\n  length xs = length XS", "show ?thesis"], ["proof (prove)\nusing this:\n  ys \\<in> Joints YS\n  length ys = length YS\n  length xs = length XS\n\ngoal (1 subgoal):\n 1. xs \\<in> Joints XS", "by (rule Joints_set_zip_subset) (simp add: assms)"], ["proof (state)\nthis:\n  xs \\<in> Joints XS\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Joints2 ::\n    \"'a::real_normed_vector aform list \\<Rightarrow>'b::real_normed_vector aform \\<Rightarrow> ('a list \\<times> 'b) set\"\n  where \"Joints2 XS Y = valuate (\\<lambda>e. (map (aform_val e) XS, aform_val e Y))\""], ["", "lemma Joints2E:\n  assumes \"zs_y \\<in> Joints2 ZS Y\"\n  obtains e where\n    \"\\<And>i. i < length (fst zs_y) \\<Longrightarrow> (fst zs_y) ! i = aform_val e (ZS ! i)\"\n    \"snd (zs_y) = aform_val e Y\"\n    \"\\<And>i. e i \\<in> {-1..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>\\<And>i.\n                    i < length (fst zs_y) \\<Longrightarrow>\n                    fst zs_y ! i = aform_val e (ZS ! i);\n         snd zs_y = aform_val e Y; \\<And>i. e i \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  zs_y \\<in> Joints2 ZS Y\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>\\<And>i.\n                    i < length (fst zs_y) \\<Longrightarrow>\n                    fst zs_y ! i = aform_val e (ZS ! i);\n         snd zs_y = aform_val e Y; \\<And>i. e i \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto simp: Joints2_def Pi_iff valuate_ex)"], ["", "lemma nth_in_AffineI:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"i < length XS\"\n  shows \"xs ! i \\<in> Affine (XS ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! i \\<in> Affine (XS ! i)", "using assms"], ["proof (prove)\nusing this:\n  xs \\<in> Joints XS\n  i < length XS\n\ngoal (1 subgoal):\n 1. xs ! i \\<in> Affine (XS ! i)", "by (force simp: Affine_def Joints_def valuate_def)"], ["", "lemma Cons_nth_in_Joints1:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"i < length XS\"\n  shows \"((xs ! i) # xs) \\<in> Joints ((XS ! i) # XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! i # xs \\<in> Joints (XS ! i # XS)", "using assms"], ["proof (prove)\nusing this:\n  xs \\<in> Joints XS\n  i < length XS\n\ngoal (1 subgoal):\n 1. xs ! i # xs \\<in> Joints (XS ! i # XS)", "by (force simp: Joints_def valuate_def)"], ["", "lemma Cons_nth_in_Joints2:\n  assumes \"xs \\<in> Joints XS\"\n  assumes \"i < length XS\"\n  assumes \"j < length XS\"\n  shows \"((xs ! i) #(xs ! j) # xs) \\<in> Joints ((XS ! i)#(XS ! j) # XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! i # xs ! j # xs \\<in> Joints (XS ! i # XS ! j # XS)", "using assms"], ["proof (prove)\nusing this:\n  xs \\<in> Joints XS\n  i < length XS\n  j < length XS\n\ngoal (1 subgoal):\n 1. xs ! i # xs ! j # xs \\<in> Joints (XS ! i # XS ! j # XS)", "by (force simp: Joints_def valuate_def)"], ["", "lemma Joints_swap:\n  \"x#y#xs\\<in>Joints (X#Y#XS) \\<longleftrightarrow> y#x#xs \\<in> Joints (Y#X#XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # y # xs \\<in> Joints (X # Y # XS)) =\n    (y # x # xs \\<in> Joints (Y # X # XS))", "by (force simp: Joints_def valuate_def)"], ["", "lemma Joints_swap_Cons_append:\n  \"length xs = length XS \\<Longrightarrow> x#ys@xs\\<in>Joints (X#YS@XS) \\<longleftrightarrow> ys@x#xs \\<in> Joints (YS@X#XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length XS \\<Longrightarrow>\n    (x # ys @ xs \\<in> Joints (X # YS @ XS)) =\n    (ys @ x # xs \\<in> Joints (YS @ X # XS))", "by (auto simp: Joints_def valuate_def)"], ["", "lemma Joints_ConsD:\n  \"x#xs\\<in>Joints (X#XS) \\<Longrightarrow> xs \\<in> Joints XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x # xs \\<in> Joints (X # XS) \\<Longrightarrow> xs \\<in> Joints XS", "by (force simp: Joints_def valuate_def)"], ["", "lemma Joints_appendD1:\n  \"ys@xs\\<in>Joints (YS@XS) \\<Longrightarrow> length xs = length XS \\<Longrightarrow> xs \\<in> Joints XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys @ xs \\<in> Joints (YS @ XS); length xs = length XS\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> Joints XS", "by (force simp: Joints_def valuate_def)"], ["", "lemma Joints_appendD2:\n  \"ys@xs\\<in>Joints (YS@XS) \\<Longrightarrow> length ys = length YS \\<Longrightarrow> ys \\<in> Joints YS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys @ xs \\<in> Joints (YS @ XS); length ys = length YS\\<rbrakk>\n    \\<Longrightarrow> ys \\<in> Joints YS", "by (force simp: Joints_def valuate_def)"], ["", "lemma Joints_imp_length_eq: \"xs \\<in> Joints XS \\<Longrightarrow> length xs = length XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> Joints XS \\<Longrightarrow> length xs = length XS", "by (auto simp: Joints_def valuate_def)"], ["", "lemma Joints_rotate[simp]: \"xs@[x] \\<in> Joints (XS @[X]) \\<longleftrightarrow> x#xs \\<in> Joints (X#XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ [x] \\<in> Joints (XS @ [X])) = (x # xs \\<in> Joints (X # XS))", "by (auto simp: Joints_def valuate_def)"], ["", "subsection \\<open>Domain\\<close>"], ["", "definition \"pdevs_domain x = {i. pdevs_apply x i \\<noteq> 0}\""], ["", "lemma finite_pdevs_domain[intro, simp]: \"finite (pdevs_domain x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (pdevs_domain x)", "unfolding pdevs_domain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. pdevs_apply x i \\<noteq> (0::'a)}", "by transfer"], ["", "lemma in_pdevs_domain[simp]: \"i \\<in> pdevs_domain x \\<longleftrightarrow> pdevs_apply x i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> pdevs_domain x) = (pdevs_apply x i \\<noteq> (0::'a))", "by (auto simp: pdevs_domain_def)"], ["", "subsection \\<open>Least Fresh Index\\<close>"], ["", "definition degree::\"'a::real_vector pdevs \\<Rightarrow> nat\"\n  where \"degree x = (LEAST i. \\<forall>j\\<ge>i. pdevs_apply x j = 0)\""], ["", "lemma degree[rule_format, intro, simp]:\n  shows \"\\<forall>j\\<ge>degree x. pdevs_apply x j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>degree x. pdevs_apply x j = (0::'a)", "unfolding degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>LEAST i. \\<forall>j\\<ge>i. pdevs_apply x j = (0::'a).\n       pdevs_apply x j = (0::'a)", "proof (rule LeastI_ex)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xa. \\<forall>j\\<ge>xa. pdevs_apply x j = (0::'a)", "have \"\\<And>j. j > Max (pdevs_domain x) \\<Longrightarrow> j \\<notin> (pdevs_domain x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       Max (pdevs_domain x) < j \\<Longrightarrow> j \\<notin> pdevs_domain x", "by (metis Max_less_iff all_not_in_conv less_irrefl_nat finite_pdevs_domain)"], ["proof (state)\nthis:\n  Max (pdevs_domain x) < ?j \\<Longrightarrow> ?j \\<notin> pdevs_domain x\n\ngoal (1 subgoal):\n 1. \\<exists>xa. \\<forall>j\\<ge>xa. pdevs_apply x j = (0::'a)", "then"], ["proof (chain)\npicking this:\n  Max (pdevs_domain x) < ?j \\<Longrightarrow> ?j \\<notin> pdevs_domain x", "show \"\\<exists>xa. \\<forall>j\\<ge>xa. pdevs_apply x j = 0\""], ["proof (prove)\nusing this:\n  Max (pdevs_domain x) < ?j \\<Longrightarrow> ?j \\<notin> pdevs_domain x\n\ngoal (1 subgoal):\n 1. \\<exists>xa. \\<forall>j\\<ge>xa. pdevs_apply x j = (0::'a)", "by (auto intro!: exI[where x=\"Max (pdevs_domain x) + 1\"])"], ["proof (state)\nthis:\n  \\<exists>xa. \\<forall>j\\<ge>xa. pdevs_apply x j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_le:\n  assumes d: \"\\<forall>j \\<ge> d. pdevs_apply x j = 0\"\n  shows \"degree x \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x \\<le> d", "unfolding degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i. \\<forall>j\\<ge>i. pdevs_apply x j = (0::'a)) \\<le> d", "by (rule Least_le) (rule d)"], ["", "lemma degree_gt: \"pdevs_apply x j \\<noteq> 0 \\<Longrightarrow> degree x > j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply x j \\<noteq> (0::'a) \\<Longrightarrow> j < degree x", "by auto"], ["", "lemma pdevs_val_pdevs_domain: \"pdevs_val e X = (\\<Sum>i\\<in>pdevs_domain X. e i *\\<^sub>R pdevs_apply X i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e X =\n    (\\<Sum>i\\<in>pdevs_domain X. e i *\\<^sub>R pdevs_apply X i)", "by (auto simp: pdevs_val_def intro!: suminf_finite)"], ["", "lemma pdevs_val_sum_le: \"degree X \\<le> d \\<Longrightarrow> pdevs_val e X = (\\<Sum>i < d. e i *\\<^sub>R pdevs_apply X i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree X \\<le> d \\<Longrightarrow>\n    pdevs_val e X = (\\<Sum>i<d. e i *\\<^sub>R pdevs_apply X i)", "by (force intro!: degree_gt sum.mono_neutral_cong_left simp: pdevs_val_pdevs_domain)"], ["", "lemmas pdevs_val_sum = pdevs_val_sum_le[OF order_refl]"], ["", "lemma pdevs_val_zero[simp]: \"pdevs_val (\\<lambda>_. 0) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>_. 0) x = (0::'a)", "by (auto simp: pdevs_val_sum)"], ["", "lemma degree_eqI:\n  assumes \"pdevs_apply x d \\<noteq> 0\"\n  assumes \"\\<And>j. j > d \\<Longrightarrow> pdevs_apply x j = 0\"\n  shows \"degree x = Suc d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x = Suc d", "unfolding eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x \\<le> Suc d \\<and> Suc d \\<le> degree x", "by (auto intro!: degree_gt degree_le assms simp: Suc_le_eq)"], ["", "lemma finite_degree_nonzero[intro, simp]: \"finite {i. pdevs_apply x i \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. pdevs_apply x i \\<noteq> (0::'a)}", "by transfer (auto simp: vimage_def Collect_neg_eq)"], ["", "lemma degree_eq_Suc_max:\n  \"degree x = (if (\\<forall>i. pdevs_apply x i = 0) then 0 else Suc (Max {i. pdevs_apply x i \\<noteq> 0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "assume \"\\<And>i. pdevs_apply x i = 0\""], ["proof (state)\nthis:\n  pdevs_apply x ?i = (0::'a)\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "hence ?thesis"], ["proof (prove)\nusing this:\n  pdevs_apply x ?i = (0::'a)\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "by auto (metis degree_le le_0_eq)"], ["proof (state)\nthis:\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "}"], ["proof (state)\nthis:\n  (\\<And>i. pdevs_apply x i = (0::'a)) \\<Longrightarrow>\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "moreover"], ["proof (state)\nthis:\n  (\\<And>i. pdevs_apply x i = (0::'a)) \\<Longrightarrow>\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "{"], ["proof (state)\nthis:\n  (\\<And>i. pdevs_apply x i = (0::'a)) \\<Longrightarrow>\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "assume \"pdevs_apply x i \\<noteq> 0\""], ["proof (state)\nthis:\n  pdevs_apply x i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "hence ?thesis"], ["proof (prove)\nusing this:\n  pdevs_apply x i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "using Max_in[OF finite_degree_nonzero, of x]"], ["proof (prove)\nusing this:\n  pdevs_apply x i \\<noteq> (0::'a)\n  {i. pdevs_apply x i \\<noteq> (0::'a)} \\<noteq> {} \\<Longrightarrow>\n  Max {i. pdevs_apply x i \\<noteq> (0::'a)}\n  \\<in> {i. pdevs_apply x i \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "by (auto intro!: degree_eqI) (metis Max.coboundedI[OF finite_degree_nonzero] in_pdevs_domain\n        le_eq_less_or_eq less_asym pdevs_domain_def)"], ["proof (state)\nthis:\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "}"], ["proof (state)\nthis:\n  pdevs_apply x ?i2 \\<noteq> (0::'a) \\<Longrightarrow>\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<And>i. pdevs_apply x i = (0::'a)) \\<Longrightarrow>\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n  pdevs_apply x ?i2 \\<noteq> (0::'a) \\<Longrightarrow>\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>i. pdevs_apply x i = (0::'a)) \\<Longrightarrow>\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n  pdevs_apply x ?i2 \\<noteq> (0::'a) \\<Longrightarrow>\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n\ngoal (1 subgoal):\n 1. degree x =\n    (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n     else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))", "by blast"], ["proof (state)\nthis:\n  degree x =\n  (if \\<forall>i. pdevs_apply x i = (0::'a) then 0\n   else Suc (Max {i. pdevs_apply x i \\<noteq> (0::'a)}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_val_degree_cong:\n  assumes \"b = d\"\n  assumes \"\\<And>i. i < degree b \\<Longrightarrow> a i = c i\"\n  shows \"pdevs_val a b = pdevs_val c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val a b = pdevs_val c d", "using assms"], ["proof (prove)\nusing this:\n  b = d\n  ?i < degree b \\<Longrightarrow> a ?i = c ?i\n\ngoal (1 subgoal):\n 1. pdevs_val a b = pdevs_val c d", "by (auto simp: pdevs_val_sum)"], ["", "abbreviation degree_aform::\"'a::real_vector aform \\<Rightarrow> nat\"\n  where \"degree_aform X \\<equiv> degree (snd X)\""], ["", "lemma degree_cong: \"(\\<And>i. (pdevs_apply x i = 0) = (pdevs_apply y i = 0)) \\<Longrightarrow> degree x = degree y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (pdevs_apply x i = (0::'a)) =\n        (pdevs_apply y i = (0::'b))) \\<Longrightarrow>\n    degree x = degree y", "unfolding degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (pdevs_apply x i = (0::'a)) =\n        (pdevs_apply y i = (0::'b))) \\<Longrightarrow>\n    (LEAST i. \\<forall>j\\<ge>i. pdevs_apply x j = (0::'a)) =\n    (LEAST i. \\<forall>j\\<ge>i. pdevs_apply y j = (0::'b))", "by auto"], ["", "lemma Least_True_nat[intro, simp]: \"(LEAST i::nat. True) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i. True) = 0", "by (metis (lifting) One_nat_def less_one not_less_Least not_less_eq)"], ["", "lemma sorted_list_of_pdevs_domain_eq:\n  \"sorted_list_of_set (pdevs_domain X) = filter ((\\<noteq>) 0 o pdevs_apply X) [0..<degree X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (pdevs_domain X) =\n    filter ((\\<noteq>) (0::'a) \\<circ> pdevs_apply X) [0..<degree X]", "by (auto simp: degree_gt intro!: sorted_distinct_set_unique sorted_filter[of \"\\<lambda>x. x\", simplified])"], ["", "subsection \\<open>Total Deviation\\<close>"], ["", "definition tdev::\"'a::ordered_euclidean_space pdevs \\<Rightarrow> 'a\" where\n  \"tdev x = (\\<Sum>i<degree x. \\<bar>pdevs_apply x i\\<bar>)\""], ["", "lemma abs_pdevs_val_le_tdev: \"e \\<in> UNIV \\<rightarrow> {-1 .. 1} \\<Longrightarrow> \\<bar>pdevs_val e x\\<bar> \\<le> tdev x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n    \\<bar>pdevs_val e x\\<bar> \\<le> tdev x", "by (force simp: pdevs_val_sum tdev_def abs_scaleR Pi_iff\n    intro!: order_trans[OF sum_abs] sum_mono scaleR_left_le_one_le\n    intro: abs_leI)"], ["", "subsection \\<open>Binary Pointwise Operations\\<close>"], ["", "definition binop_pdevs_raw::\"('a::zero \\<Rightarrow> 'b::zero \\<Rightarrow> 'c::zero) \\<Rightarrow>\n    (nat \\<Rightarrow> 'a) \\<Rightarrow> (nat \\<Rightarrow> 'b) \\<Rightarrow> nat \\<Rightarrow> 'c\"\n  where \"binop_pdevs_raw f x y i = (if x i = 0 \\<and> y i = 0 then 0 else f (x i) (y i))\""], ["", "lemma nonzeros_binop_pdevs_subset:\n  \"{i. binop_pdevs_raw f x y i \\<noteq> 0} \\<subseteq> {i. x i \\<noteq> 0} \\<union> {i. y i \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. binop_pdevs_raw f x y i \\<noteq> (0::'a)}\n    \\<subseteq> {i. x i \\<noteq> (0::'b)} \\<union> {i. y i \\<noteq> (0::'c)}", "by (auto simp: binop_pdevs_raw_def)"], ["", "lift_definition binop_pdevs::\n    \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> 'a::zero pdevs \\<Rightarrow> 'b::zero pdevs \\<Rightarrow> 'c::zero pdevs\"\n  is binop_pdevs_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3.\n       \\<lbrakk>finite {i. fun2 i \\<noteq> (0::'a)};\n        finite {i. fun3 i \\<noteq> (0::'b)}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {i. binop_pdevs_raw fun1 fun2 fun3 i \\<noteq>\n                              (0::'c)}", "using nonzeros_binop_pdevs_subset"], ["proof (prove)\nusing this:\n  {i. binop_pdevs_raw ?f ?x ?y i \\<noteq> (0::?'a)}\n  \\<subseteq> {i. ?x i \\<noteq> (0::?'b)} \\<union>\n              {i. ?y i \\<noteq> (0::?'c)}\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3.\n       \\<lbrakk>finite {i. fun2 i \\<noteq> (0::'a)};\n        finite {i. fun3 i \\<noteq> (0::'b)}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {i. binop_pdevs_raw fun1 fun2 fun3 i \\<noteq>\n                              (0::'c)}", "by (rule finite_subset) auto"], ["", "lemma pdevs_apply_binop_pdevs[simp]: \"pdevs_apply (binop_pdevs f x y) i =\n  (if pdevs_apply x i = 0 \\<and> pdevs_apply y i = 0 then 0 else f (pdevs_apply x i) (pdevs_apply y i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (binop_pdevs f x y) i =\n    (if pdevs_apply x i = (0::'b) \\<and> pdevs_apply y i = (0::'c)\n     then 0::'a else f (pdevs_apply x i) (pdevs_apply y i))", "by transfer (auto simp: binop_pdevs_raw_def)"], ["", "subsection \\<open>Addition\\<close>"], ["", "definition add_pdevs::\"'a::real_vector pdevs \\<Rightarrow> 'a pdevs \\<Rightarrow> 'a pdevs\"\n  where \"add_pdevs = binop_pdevs (+)\""], ["", "lemma pdevs_apply_add_pdevs[simp]:\n  \"pdevs_apply (add_pdevs X Y) n = pdevs_apply X n + pdevs_apply Y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (add_pdevs X Y) n = pdevs_apply X n + pdevs_apply Y n", "by (auto simp: add_pdevs_def)"], ["", "lemma pdevs_val_add_pdevs[simp]:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "let ?sum = \"\\<lambda>m X. \\<Sum>i < m. e i *\\<^sub>R pdevs_apply X i\""], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "let ?m = \"max (degree X) (degree Y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "have \"pdevs_val e X + pdevs_val e Y = ?sum (degree X) X + ?sum (degree Y) Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e X + pdevs_val e Y =\n    (\\<Sum>i<degree X. e i *\\<^sub>R pdevs_apply X i) +\n    (\\<Sum>i<degree Y. e i *\\<^sub>R pdevs_apply Y i)", "by (simp add: pdevs_val_sum)"], ["proof (state)\nthis:\n  pdevs_val e X + pdevs_val e Y =\n  (\\<Sum>i<degree X. e i *\\<^sub>R pdevs_apply X i) +\n  (\\<Sum>i<degree Y. e i *\\<^sub>R pdevs_apply Y i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "also"], ["proof (state)\nthis:\n  pdevs_val e X + pdevs_val e Y =\n  (\\<Sum>i<degree X. e i *\\<^sub>R pdevs_apply X i) +\n  (\\<Sum>i<degree Y. e i *\\<^sub>R pdevs_apply Y i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "have \"?sum (degree X) X = ?sum ?m X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree X. e i *\\<^sub>R pdevs_apply X i) =\n    (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply X i)", "by (rule sum.mono_neutral_cong_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>i<degree X. e i *\\<^sub>R pdevs_apply X i) =\n  (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply X i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree X. e i *\\<^sub>R pdevs_apply X i) =\n  (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply X i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "have \"?sum (degree Y) Y = ?sum ?m Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree Y. e i *\\<^sub>R pdevs_apply Y i) =\n    (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply Y i)", "by (rule sum.mono_neutral_cong_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>i<degree Y. e i *\\<^sub>R pdevs_apply Y i) =\n  (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply Y i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree Y. e i *\\<^sub>R pdevs_apply Y i) =\n  (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply Y i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "have \"?sum ?m X + ?sum ?m Y = (\\<Sum>i < ?m. e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply X i) +\n    (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply Y i) =\n    (\\<Sum>i<max (degree X) (degree Y).\n        e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i))", "by (simp add: scaleR_right_distrib sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply X i) +\n  (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply Y i) =\n  (\\<Sum>i<max (degree X) (degree Y).\n      e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i))\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply X i) +\n  (\\<Sum>i<max (degree X) (degree Y). e i *\\<^sub>R pdevs_apply Y i) =\n  (\\<Sum>i<max (degree X) (degree Y).\n      e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i))\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "have \"\\<dots> = (\\<Sum>i. e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<max (degree X) (degree Y).\n        e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i)) =\n    (\\<Sum>i. e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i))", "by (rule suminf_finite[symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Sum>i<max (degree X) (degree Y).\n      e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i)) =\n  (\\<Sum>i. e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i))\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<max (degree X) (degree Y).\n      e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i)) =\n  (\\<Sum>i. e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i))\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "have \"\\<dots> = pdevs_val e (add_pdevs X Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i)) =\n    pdevs_val e (add_pdevs X Y)", "by (simp add: pdevs_val_def)"], ["proof (state)\nthis:\n  (\\<Sum>i. e i *\\<^sub>R (pdevs_apply X i + pdevs_apply Y i)) =\n  pdevs_val e (add_pdevs X Y)\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e X + pdevs_val e Y = pdevs_val e (add_pdevs X Y)", "show \"pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y\""], ["proof (prove)\nusing this:\n  pdevs_val e X + pdevs_val e Y = pdevs_val e (add_pdevs X Y)\n\ngoal (1 subgoal):\n 1. pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y", "by simp"], ["proof (state)\nthis:\n  pdevs_val e (add_pdevs X Y) = pdevs_val e X + pdevs_val e Y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Total Deviation\\<close>"], ["", "lemma tdev_eq_zero_iff: fixes X::\"real pdevs\" shows \"tdev X = 0 \\<longleftrightarrow> (\\<forall>e. pdevs_val e X = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tdev X = 0) = (\\<forall>e. pdevs_val e X = 0)", "by (force simp add: pdevs_val_sum tdev_def sum_nonneg_eq_0_iff\n    dest!: spec[where x=\"\\<lambda>i. if pdevs_apply X i \\<ge> 0 then 1 else -1\"] split: if_split_asm)"], ["", "lemma tdev_nonneg[intro, simp]: \"tdev X \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> tdev X", "by (auto simp: tdev_def)"], ["", "lemma tdev_nonpos_iff[simp]: \"tdev X \\<le> 0 \\<longleftrightarrow> tdev X = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tdev X \\<le> (0::'a)) = (tdev X = (0::'a))", "by (auto simp: order.antisym)"], ["", "subsection \\<open>Unary Operations\\<close>"], ["", "definition unop_pdevs_raw::\n    \"('a::zero \\<Rightarrow> 'b::zero) \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> nat \\<Rightarrow> 'b\"\n  where \"unop_pdevs_raw f x i = (if x i = 0 then 0 else f (x i))\""], ["", "lemma nonzeros_unop_pdevs_subset: \"{i. unop_pdevs_raw f x i \\<noteq> 0} \\<subseteq> {i. x i \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. unop_pdevs_raw f x i \\<noteq> (0::'a)}\n    \\<subseteq> {i. x i \\<noteq> (0::'b)}", "by (auto simp: unop_pdevs_raw_def)"], ["", "lift_definition unop_pdevs::\n    \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a::zero pdevs \\<Rightarrow> 'b::zero pdevs\"\n  is unop_pdevs_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       finite {i. fun2 i \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {i. unop_pdevs_raw fun1 fun2 i \\<noteq> (0::'b)}", "using nonzeros_unop_pdevs_subset"], ["proof (prove)\nusing this:\n  {i. unop_pdevs_raw ?f ?x i \\<noteq> (0::?'a)}\n  \\<subseteq> {i. ?x i \\<noteq> (0::?'b)}\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       finite {i. fun2 i \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {i. unop_pdevs_raw fun1 fun2 i \\<noteq> (0::'b)}", "by (rule finite_subset) auto"], ["", "lemma pdevs_apply_unop_pdevs[simp]: \"pdevs_apply (unop_pdevs f x) i =\n  (if pdevs_apply x i = 0 then 0 else f (pdevs_apply x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (unop_pdevs f x) i =\n    (if pdevs_apply x i = (0::'b) then 0::'a else f (pdevs_apply x i))", "by transfer (auto simp: unop_pdevs_raw_def)"], ["", "lemma pdevs_domain_unop_linear:\n  assumes \"linear f\"\n  shows \"pdevs_domain (unop_pdevs f x) \\<subseteq> pdevs_domain x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain (unop_pdevs f x) \\<subseteq> pdevs_domain x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_domain (unop_pdevs f x) \\<subseteq> pdevs_domain x", "interpret f: linear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear f", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_domain (unop_pdevs f x) \\<subseteq> pdevs_domain x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain (unop_pdevs f x) \\<subseteq> pdevs_domain x", "by (auto simp: f.zero)"], ["proof (state)\nthis:\n  pdevs_domain (unop_pdevs f x) \\<subseteq> pdevs_domain x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  pdevs_val_unop_linear:\n  assumes \"linear f\"\n  shows \"pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "interpret f: linear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear f", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "have *: \"\\<And>i. (if pdevs_apply x i = 0 then 0 else f (pdevs_apply x i)) = f (pdevs_apply x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (if pdevs_apply x i = (0::'a) then 0::'b else f (pdevs_apply x i)) =\n       f (pdevs_apply x i)", "by (auto simp: f.zero)"], ["proof (state)\nthis:\n  (if pdevs_apply x ?i = (0::'a) then 0::'b else f (pdevs_apply x ?i)) =\n  f (pdevs_apply x ?i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "have \"pdevs_val e (unop_pdevs f x) =\n      (\\<Sum>i\\<in>pdevs_domain (unop_pdevs f x). e i *\\<^sub>R f (pdevs_apply x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) =\n    (\\<Sum>i\\<in>pdevs_domain (unop_pdevs f x).\n       e i *\\<^sub>R f (pdevs_apply x i))", "by (auto simp add: pdevs_val_pdevs_domain *)"], ["proof (state)\nthis:\n  pdevs_val e (unop_pdevs f x) =\n  (\\<Sum>i\\<in>pdevs_domain (unop_pdevs f x).\n     e i *\\<^sub>R f (pdevs_apply x i))\n\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "also"], ["proof (state)\nthis:\n  pdevs_val e (unop_pdevs f x) =\n  (\\<Sum>i\\<in>pdevs_domain (unop_pdevs f x).\n     e i *\\<^sub>R f (pdevs_apply x i))\n\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "have \"\\<dots> = (\\<Sum>xa\\<in>pdevs_domain x. e xa *\\<^sub>R f (pdevs_apply x xa))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>pdevs_domain (unop_pdevs f x).\n       e i *\\<^sub>R f (pdevs_apply x i)) =\n    (\\<Sum>xa\\<in>pdevs_domain x. e xa *\\<^sub>R f (pdevs_apply x xa))", "by (auto intro!: sum.mono_neutral_cong_left)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain (unop_pdevs f x).\n     e i *\\<^sub>R f (pdevs_apply x i)) =\n  (\\<Sum>xa\\<in>pdevs_domain x. e xa *\\<^sub>R f (pdevs_apply x xa))\n\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain (unop_pdevs f x).\n     e i *\\<^sub>R f (pdevs_apply x i)) =\n  (\\<Sum>xa\\<in>pdevs_domain x. e xa *\\<^sub>R f (pdevs_apply x xa))\n\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "have \"\\<dots> = f (pdevs_val e x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<in>pdevs_domain x. e xa *\\<^sub>R f (pdevs_apply x xa)) =\n    f (pdevs_val e x)", "by (auto simp add: pdevs_val_pdevs_domain f.sum f.scaleR)"], ["proof (state)\nthis:\n  (\\<Sum>xa\\<in>pdevs_domain x. e xa *\\<^sub>R f (pdevs_apply x xa)) =\n  f (pdevs_val e x)\n\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)\n\ngoal (1 subgoal):\n 1. pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)", "."], ["proof (state)\nthis:\n  pdevs_val e (unop_pdevs f x) = f (pdevs_val e x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Pointwise Scaling of Partial Deviations\\<close>"], ["", "definition scaleR_pdevs::\"real \\<Rightarrow> 'a::real_vector pdevs \\<Rightarrow> 'a pdevs\"\n  where \"scaleR_pdevs r x = unop_pdevs ((*\\<^sub>R) r) x\""], ["", "lemma pdevs_apply_scaleR_pdevs[simp]:\n  \"pdevs_apply (scaleR_pdevs x Y) n = x *\\<^sub>R pdevs_apply Y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (scaleR_pdevs x Y) n = x *\\<^sub>R pdevs_apply Y n", "by (auto simp: scaleR_pdevs_def)"], ["", "lemma degree_scaleR_pdevs[simp]: \"degree (scaleR_pdevs r x) = (if r = 0 then 0 else degree x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (scaleR_pdevs r x) = (if r = 0 then 0 else degree x)", "unfolding degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i.\n        \\<forall>j\\<ge>i. pdevs_apply (scaleR_pdevs r x) j = (0::'a)) =\n    (if r = 0 then 0\n     else LEAST i. \\<forall>j\\<ge>i. pdevs_apply x j = (0::'a))", "by auto"], ["", "lemma pdevs_val_scaleR_pdevs[simp]:\n  fixes x::real and Y::\"'a::real_normed_vector pdevs\"\n  shows \"pdevs_val e (scaleR_pdevs x Y) = x *\\<^sub>R pdevs_val e Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (scaleR_pdevs x Y) = x *\\<^sub>R pdevs_val e Y", "by (auto simp: pdevs_val_sum scaleR_sum_right ac_simps)"], ["", "subsection \\<open>Partial Deviations Scale Pointwise\\<close>"], ["", "definition pdevs_scaleR::\"real pdevs \\<Rightarrow> 'a::real_vector \\<Rightarrow> 'a pdevs\"\n  where \"pdevs_scaleR r x = unop_pdevs (\\<lambda>r. r *\\<^sub>R x) r\""], ["", "lemma pdevs_apply_pdevs_scaleR[simp]:\n  \"pdevs_apply (pdevs_scaleR X y) n = pdevs_apply X n *\\<^sub>R y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (pdevs_scaleR X y) n = pdevs_apply X n *\\<^sub>R y", "by (auto simp: pdevs_scaleR_def)"], ["", "lemma degree_pdevs_scaleR[simp]: \"degree (pdevs_scaleR r x) = (if x = 0 then 0 else degree r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pdevs_scaleR r x) = (if x = (0::'a) then 0 else degree r)", "unfolding degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i.\n        \\<forall>j\\<ge>i. pdevs_apply (pdevs_scaleR r x) j = (0::'a)) =\n    (if x = (0::'a) then 0\n     else LEAST i. \\<forall>j\\<ge>i. pdevs_apply r j = 0)", "by auto"], ["", "lemma pdevs_val_pdevs_scaleR[simp]:\n  fixes X::\"real pdevs\" and y::\"'a::real_normed_vector\"\n  shows \"pdevs_val e (pdevs_scaleR X y) = pdevs_val e X *\\<^sub>R y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_scaleR X y) = pdevs_val e X *\\<^sub>R y", "by (auto simp: pdevs_val_sum scaleR_sum_left)"], ["", "subsection \\<open>Pointwise Unary Minus\\<close>"], ["", "definition uminus_pdevs::\"'a::real_vector pdevs \\<Rightarrow> 'a pdevs\"\n  where \"uminus_pdevs = unop_pdevs uminus\""], ["", "lemma pdevs_apply_uminus_pdevs[simp]: \"pdevs_apply (uminus_pdevs x) = - pdevs_apply x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (uminus_pdevs x) = - pdevs_apply x", "by (auto simp: uminus_pdevs_def)"], ["", "lemma degree_uminus_pdevs[simp]: \"degree (uminus_pdevs x) = degree x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (uminus_pdevs x) = degree x", "by (rule degree_cong) simp"], ["", "lemma pdevs_val_uminus_pdevs[simp]: \"pdevs_val e (uminus_pdevs x) = - pdevs_val e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (uminus_pdevs x) = - pdevs_val e x", "unfolding pdevs_val_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (uminus_pdevs x).\n        e i *\\<^sub>R pdevs_apply (uminus_pdevs x) i) =\n    - (\\<Sum>i<degree x. e i *\\<^sub>R pdevs_apply x i)", "by (auto simp: sum_negf)"], ["", "definition \"uminus_aform X = (- fst X, uminus_pdevs (snd X))\""], ["", "lemma fst_uminus_aform[simp]: \"fst (uminus_aform Y) = - fst Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (uminus_aform Y) = - fst Y", "by (simp add: uminus_aform_def)"], ["", "lemma aform_val_uminus_aform[simp]: \"aform_val e (uminus_aform X) = - aform_val e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (uminus_aform X) = - aform_val e X", "by (auto simp: uminus_aform_def aform_val_def)"], ["", "subsection \\<open>Constant\\<close>"], ["", "lift_definition zero_pdevs::\"'a::zero pdevs\" is \"\\<lambda>_. 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. (0::'a) \\<noteq> (0::'a)}", "by simp"], ["", "lemma pdevs_apply_zero_pdevs[simp]: \"pdevs_apply zero_pdevs i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply zero_pdevs i = (0::'a)", "by transfer simp"], ["", "lemma pdevs_val_zero_pdevs[simp]: \"pdevs_val e zero_pdevs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e zero_pdevs = (0::'a)", "by (auto simp: pdevs_val_def)"], ["", "definition \"num_aform f = (f, zero_pdevs)\""], ["", "subsection \\<open>Inner Product\\<close>"], ["", "definition pdevs_inner::\"'a::euclidean_space pdevs \\<Rightarrow> 'a \\<Rightarrow> real pdevs\"\n  where \"pdevs_inner x b = unop_pdevs (\\<lambda>x. x \\<bullet> b) x\""], ["", "lemma pdevs_apply_pdevs_inner[simp]: \"pdevs_apply (pdevs_inner p a) i = pdevs_apply p i \\<bullet> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (pdevs_inner p a) i = pdevs_apply p i \\<bullet> a", "by (simp add: pdevs_inner_def)"], ["", "lemma pdevs_val_pdevs_inner[simp]: \"pdevs_val e (pdevs_inner p a) = pdevs_val e p \\<bullet> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_inner p a) = pdevs_val e p \\<bullet> a", "by (auto simp add: inner_sum_left pdevs_val_pdevs_domain intro!: sum.mono_neutral_cong_left)"], ["", "definition inner_aform::\"'a::euclidean_space aform \\<Rightarrow> 'a \\<Rightarrow> real aform\"\n  where \"inner_aform X b = (fst X \\<bullet> b, pdevs_inner (snd X) b)\""], ["", "subsection \\<open>Inner Product Pair\\<close>"], ["", "definition inner2::\"'a::euclidean_space \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> real*real\"\n  where \"inner2 x n l = (x \\<bullet> n, x \\<bullet> l)\""], ["", "definition pdevs_inner2::\"'a::euclidean_space pdevs \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> (real*real) pdevs\"\n  where \"pdevs_inner2 X n l = unop_pdevs (\\<lambda>x. inner2 x n l) X\""], ["", "lemma pdevs_apply_pdevs_inner2[simp]: \"pdevs_apply (pdevs_inner2 p a b) i = (pdevs_apply p i \\<bullet> a, pdevs_apply p i \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (pdevs_inner2 p a b) i =\n    (pdevs_apply p i \\<bullet> a, pdevs_apply p i \\<bullet> b)", "by (simp add: pdevs_inner2_def inner2_def zero_prod_def)"], ["", "definition inner2_aform::\"'a::euclidean_space aform \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> (real*real) aform\"\n  where \"inner2_aform X a b = (inner2 (fst X) a b, pdevs_inner2 (snd X) a b)\""], ["", "lemma linear_inner2[intro, simp]: \"linear (\\<lambda>x. inner2 x n i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (\\<lambda>x. inner2 x n i)", "by unfold_locales (auto simp: inner2_def algebra_simps)"], ["", "lemma aform_val_inner2_aform[simp]: \"aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i", "have \"aform_val e (inner2_aform Z n i) = inner2 (fst Z) n i + inner2 (pdevs_val e (snd Z)) n i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (inner2_aform Z n i) =\n    inner2 (fst Z) n i + inner2 (pdevs_val e (snd Z)) n i", "by (auto simp: aform_val_def inner2_aform_def pdevs_inner2_def pdevs_val_unop_linear)"], ["proof (state)\nthis:\n  aform_val e (inner2_aform Z n i) =\n  inner2 (fst Z) n i + inner2 (pdevs_val e (snd Z)) n i\n\ngoal (1 subgoal):\n 1. aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i", "also"], ["proof (state)\nthis:\n  aform_val e (inner2_aform Z n i) =\n  inner2 (fst Z) n i + inner2 (pdevs_val e (snd Z)) n i\n\ngoal (1 subgoal):\n 1. aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i", "have \"\\<dots> = inner2 (aform_val e Z) n i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner2 (fst Z) n i + inner2 (pdevs_val e (snd Z)) n i =\n    inner2 (aform_val e Z) n i", "by (simp add: inner2_def algebra_simps aform_val_def)"], ["proof (state)\nthis:\n  inner2 (fst Z) n i + inner2 (pdevs_val e (snd Z)) n i =\n  inner2 (aform_val e Z) n i\n\ngoal (1 subgoal):\n 1. aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i", "finally"], ["proof (chain)\npicking this:\n  aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i", "show ?thesis"], ["proof (prove)\nusing this:\n  aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i\n\ngoal (1 subgoal):\n 1. aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i", "."], ["proof (state)\nthis:\n  aform_val e (inner2_aform Z n i) = inner2 (aform_val e Z) n i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Update\\<close>"], ["", "lemma pdevs_val_upd[simp]:\n  \"pdevs_val (e(n := e')) X = pdevs_val e X - e n * pdevs_apply X n + e' * pdevs_apply X n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (e(n := e')) X =\n    pdevs_val e X - e n * pdevs_apply X n + e' * pdevs_apply X n", "unfolding pdevs_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. (e(n := e')) i *\\<^sub>R pdevs_apply X i) =\n    (\\<Sum>i. e i *\\<^sub>R pdevs_apply X i) - e n * pdevs_apply X n +\n    e' * pdevs_apply X n", "by (subst suminf_finite[OF finite.insertI[OF finite_degree_nonzero], of n X],\n    auto simp: pdevs_val_def sum.insert_remove)+"], ["", "lemma nonzeros_fun_upd:\n  \"{i. (f(n := a)) i \\<noteq> 0} \\<subseteq> {i. f i \\<noteq> 0} \\<union> {n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. (f(n := a)) i \\<noteq> (0::'b)}\n    \\<subseteq> {i. f i \\<noteq> (0::'b)} \\<union> {n}", "by (auto split: if_split_asm)"], ["", "lift_definition pdev_upd::\"'a::real_vector pdevs \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a pdevs\"\n  is \"\\<lambda>x n a. x(n:=a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun nat a.\n       finite {i. fun i \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {i. (fun(nat := a)) i \\<noteq> (0::'a)}", "by (rule finite_subset[OF nonzeros_fun_upd]) simp"], ["", "lemma pdevs_apply_pdev_upd[simp]:\n  \"pdevs_apply (pdev_upd X n x) = (pdevs_apply X)(n:=x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (pdev_upd X n x) = (pdevs_apply X)(n := x)", "by transfer simp"], ["", "lemma pdevs_val_pdev_upd[simp]:\n  \"pdevs_val e (pdev_upd X n x) = pdevs_val e X + e n *\\<^sub>R x - e n *\\<^sub>R pdevs_apply X n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdev_upd X n x) =\n    pdevs_val e X + e n *\\<^sub>R x - e n *\\<^sub>R pdevs_apply X n", "unfolding pdevs_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. e i *\\<^sub>R pdevs_apply (pdev_upd X n x) i) =\n    (\\<Sum>i. e i *\\<^sub>R pdevs_apply X i) + e n *\\<^sub>R x -\n    e n *\\<^sub>R pdevs_apply X n", "by (subst suminf_finite[OF finite.insertI[OF finite_degree_nonzero], of n X],\n    auto simp: pdevs_val_def sum.insert_remove)+"], ["", "lemma degree_pdev_upd:\n  assumes \"x = 0 \\<longleftrightarrow> pdevs_apply X n = 0\"\n  shows \"degree (pdev_upd X n x) = degree X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pdev_upd X n x) = degree X", "using assms"], ["proof (prove)\nusing this:\n  (x = (0::'a)) = (pdevs_apply X n = (0::'a))\n\ngoal (1 subgoal):\n 1. degree (pdev_upd X n x) = degree X", "by (auto intro!: degree_cong split: if_split_asm)"], ["", "lemma degree_pdev_upd_le:\n  assumes \"degree X \\<le> n\"\n  shows \"degree (pdev_upd X n x) \\<le> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pdev_upd X n x) \\<le> Suc n", "using assms"], ["proof (prove)\nusing this:\n  degree X \\<le> n\n\ngoal (1 subgoal):\n 1. degree (pdev_upd X n x) \\<le> Suc n", "by (auto intro!: degree_le)"], ["", "subsection \\<open>Inf/Sup\\<close>"], ["", "definition \"Inf_aform X = fst X - tdev (snd X)\""], ["", "definition \"Sup_aform X = fst X + tdev (snd X)\""], ["", "lemma Inf_aform:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"Inf_aform X \\<le> aform_val e X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_aform X \\<le> aform_val e X", "using order_trans[OF abs_ge_minus_self abs_pdevs_val_le_tdev[OF assms]]"], ["proof (prove)\nusing this:\n  - pdevs_val e ?x1 \\<le> tdev ?x1\n\ngoal (1 subgoal):\n 1. Inf_aform X \\<le> aform_val e X", "by (auto simp: Inf_aform_def aform_val_def minus_le_iff)"], ["", "lemma Sup_aform:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"aform_val e X \\<le> Sup_aform X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e X \\<le> Sup_aform X", "using order_trans[OF abs_ge_self abs_pdevs_val_le_tdev[OF assms]]"], ["proof (prove)\nusing this:\n  pdevs_val e ?x1 \\<le> tdev ?x1\n\ngoal (1 subgoal):\n 1. aform_val e X \\<le> Sup_aform X", "by (auto simp: Sup_aform_def aform_val_def)"], ["", "subsection \\<open>Minkowski Sum\\<close>"], ["", "definition msum_pdevs_raw::\"nat\\<Rightarrow>(nat \\<Rightarrow> 'a::real_vector)\\<Rightarrow>(nat \\<Rightarrow> 'a)\\<Rightarrow>(nat\\<Rightarrow>'a)\" where\n  \"msum_pdevs_raw n x y i = (if i < n then x i else y (i - n))\""], ["", "lemma nonzeros_msum_pdevs_raw:\n  \"{i. msum_pdevs_raw n f g i \\<noteq> 0} = ({0..<n} \\<inter> {i. f i \\<noteq> 0}) \\<union> (+) n ` ({i. g i \\<noteq> 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. msum_pdevs_raw n f g i \\<noteq> (0::'a)} =\n    {0..<n} \\<inter> {i. f i \\<noteq> (0::'a)} \\<union>\n    (+) n ` {i. g i \\<noteq> (0::'a)}", "by (force simp: msum_pdevs_raw_def not_less split: if_split_asm)"], ["", "lift_definition msum_pdevs::\"nat\\<Rightarrow>'a::real_vector pdevs\\<Rightarrow>'a pdevs\\<Rightarrow>'a pdevs\" is msum_pdevs_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat fun1 fun2.\n       \\<lbrakk>finite {i. fun1 i \\<noteq> (0::'a)};\n        finite {i. fun2 i \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {i. msum_pdevs_raw nat fun1 fun2 i \\<noteq>\n                              (0::'a)}", "unfolding nonzeros_msum_pdevs_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat fun1 fun2.\n       \\<lbrakk>finite {i. fun1 i \\<noteq> (0::'a)};\n        finite {i. fun2 i \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          ({0..<nat} \\<inter>\n                           {i. fun1 i \\<noteq> (0::'a)} \\<union>\n                           (+) nat ` {i. fun2 i \\<noteq> (0::'a)})", "by simp"], ["", "lemma pdevs_apply_msum_pdevs: \"pdevs_apply (msum_pdevs n f g) i =\n  (if i < n then pdevs_apply f i else pdevs_apply g (i - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (msum_pdevs n f g) i =\n    (if i < n then pdevs_apply f i else pdevs_apply g (i - n))", "by transfer (auto simp: msum_pdevs_raw_def)"], ["", "lemma degree_least_nonzero:\n  assumes \"degree f \\<noteq> 0\"\n  shows \"pdevs_apply f (degree f - 1) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply f (degree f - 1) \\<noteq> (0::'a)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_apply f (degree f - 1) = (0::'a) \\<Longrightarrow> False", "assume H: \"pdevs_apply f (degree f - 1) = 0\""], ["proof (state)\nthis:\n  pdevs_apply f (degree f - 1) = (0::'a)\n\ngoal (1 subgoal):\n 1. pdevs_apply f (degree f - 1) = (0::'a) \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  pdevs_apply f (degree f - 1) = (0::'a)\n\ngoal (1 subgoal):\n 1. pdevs_apply f (degree f - 1) = (0::'a) \\<Longrightarrow> False", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_apply f (degree f - 1) = (0::'a) \\<Longrightarrow> False", "assume \"j\\<ge>degree f - 1\""], ["proof (state)\nthis:\n  degree f - 1 \\<le> j\n\ngoal (1 subgoal):\n 1. pdevs_apply f (degree f - 1) = (0::'a) \\<Longrightarrow> False", "with H"], ["proof (chain)\npicking this:\n  pdevs_apply f (degree f - 1) = (0::'a)\n  degree f - 1 \\<le> j", "have \"pdevs_apply f j = 0\""], ["proof (prove)\nusing this:\n  pdevs_apply f (degree f - 1) = (0::'a)\n  degree f - 1 \\<le> j\n\ngoal (1 subgoal):\n 1. pdevs_apply f j = (0::'a)", "by (cases \"degree f - 1 = j\") auto"], ["proof (state)\nthis:\n  pdevs_apply f j = (0::'a)\n\ngoal (1 subgoal):\n 1. pdevs_apply f (degree f - 1) = (0::'a) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  degree f - 1 \\<le> ?j2 \\<Longrightarrow> pdevs_apply f ?j2 = (0::'a)\n\ngoal (1 subgoal):\n 1. pdevs_apply f (degree f - 1) = (0::'a) \\<Longrightarrow> False", "from degree_le[rule_format, OF this]"], ["proof (chain)\npicking this:\n  (\\<And>j.\n      ?d \\<le> j \\<Longrightarrow> degree f - 1 \\<le> j) \\<Longrightarrow>\n  degree f \\<le> ?d", "have \"degree f \\<le> degree f - 1\""], ["proof (prove)\nusing this:\n  (\\<And>j.\n      ?d \\<le> j \\<Longrightarrow> degree f - 1 \\<le> j) \\<Longrightarrow>\n  degree f \\<le> ?d\n\ngoal (1 subgoal):\n 1. degree f \\<le> degree f - 1", "by blast"], ["proof (state)\nthis:\n  degree f \\<le> degree f - 1\n\ngoal (1 subgoal):\n 1. pdevs_apply f (degree f - 1) = (0::'a) \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  degree f \\<noteq> 0\n  degree f \\<le> degree f - 1", "show False"], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n  degree f \\<le> degree f - 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_leI:\n  assumes \"(\\<And>i. pdevs_apply y i = 0 \\<Longrightarrow> pdevs_apply x i = 0)\"\n  shows \"degree x \\<le> degree y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x \\<le> degree y", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> degree x \\<le> degree y\n 2. \\<not> ?P \\<Longrightarrow> degree x \\<le> degree y", "assume \"degree x \\<noteq> 0\""], ["proof (state)\nthis:\n  degree x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> degree x \\<le> degree y\n 2. \\<not> ?P \\<Longrightarrow> degree x \\<le> degree y", "from degree_least_nonzero[OF this]"], ["proof (chain)\npicking this:\n  pdevs_apply x (degree x - 1) \\<noteq> (0::'b)", "have \"pdevs_apply y (degree x - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pdevs_apply x (degree x - 1) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. pdevs_apply y (degree x - 1) \\<noteq> (0::'a)", "by (auto simp: assms split: if_split_asm)"], ["proof (state)\nthis:\n  pdevs_apply y (degree x - 1) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> degree x \\<le> degree y\n 2. \\<not> ?P \\<Longrightarrow> degree x \\<le> degree y", "from degree_gt[OF this]"], ["proof (chain)\npicking this:\n  degree x - 1 < degree y", "show ?thesis"], ["proof (prove)\nusing this:\n  degree x - 1 < degree y\n\ngoal (1 subgoal):\n 1. degree x \\<le> degree y", "by simp"], ["proof (state)\nthis:\n  degree x \\<le> degree y\n\ngoal (1 subgoal):\n 1. \\<not> degree x \\<noteq> 0 \\<Longrightarrow> degree x \\<le> degree y", "qed simp"], ["", "lemma degree_msum_pdevs_ge1:\n  shows \"degree f \\<le> n \\<Longrightarrow> degree f \\<le> degree (msum_pdevs n f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f \\<le> n \\<Longrightarrow>\n    degree f \\<le> degree (msum_pdevs n f g)", "by (rule degree_leI) (auto simp: pdevs_apply_msum_pdevs split: if_split_asm)"], ["", "lemma degree_msum_pdevs_ge2:\n  assumes \"degree f \\<le> n\"\n  shows \"degree g \\<le> degree (msum_pdevs n f g) - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree g \\<le> degree (msum_pdevs n f g) - n", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> degree g \\<le> degree (msum_pdevs n f g) - n\n 2. \\<not> ?P \\<Longrightarrow> degree g \\<le> degree (msum_pdevs n f g) - n", "assume \"degree g \\<noteq> 0\""], ["proof (state)\nthis:\n  degree g \\<noteq> 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> degree g \\<le> degree (msum_pdevs n f g) - n\n 2. \\<not> ?P \\<Longrightarrow> degree g \\<le> degree (msum_pdevs n f g) - n", "hence \"pdevs_apply g (degree g - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pdevs_apply g (degree g - 1) \\<noteq> (0::'a)", "by (rule degree_least_nonzero)"], ["proof (state)\nthis:\n  pdevs_apply g (degree g - 1) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> degree g \\<le> degree (msum_pdevs n f g) - n\n 2. \\<not> ?P \\<Longrightarrow> degree g \\<le> degree (msum_pdevs n f g) - n", "hence \"pdevs_apply (msum_pdevs n f g) (n + degree g - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pdevs_apply g (degree g - 1) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. pdevs_apply (msum_pdevs n f g) (n + degree g - 1) \\<noteq> (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  pdevs_apply g (degree g - 1) \\<noteq> (0::'a)\n  degree f \\<le> n\n\ngoal (1 subgoal):\n 1. pdevs_apply (msum_pdevs n f g) (n + degree g - 1) \\<noteq> (0::'a)", "by (auto simp: pdevs_apply_msum_pdevs)"], ["proof (state)\nthis:\n  pdevs_apply (msum_pdevs n f g) (n + degree g - 1) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> degree g \\<le> degree (msum_pdevs n f g) - n\n 2. \\<not> ?P \\<Longrightarrow> degree g \\<le> degree (msum_pdevs n f g) - n", "from degree_gt[OF this]"], ["proof (chain)\npicking this:\n  n + degree g - 1 < degree (msum_pdevs n f g)", "show ?thesis"], ["proof (prove)\nusing this:\n  n + degree g - 1 < degree (msum_pdevs n f g)\n\ngoal (1 subgoal):\n 1. degree g \\<le> degree (msum_pdevs n f g) - n", "by simp"], ["proof (state)\nthis:\n  degree g \\<le> degree (msum_pdevs n f g) - n\n\ngoal (1 subgoal):\n 1. \\<not> degree g \\<noteq> 0 \\<Longrightarrow>\n    degree g \\<le> degree (msum_pdevs n f g) - n", "qed simp"], ["", "lemma degree_msum_pdevs_le:\n  shows \"degree (msum_pdevs n f g) \\<le> n + degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (msum_pdevs n f g) \\<le> n + degree g", "by (auto intro!: degree_le simp: pdevs_apply_msum_pdevs)"], ["", "lemma\n  sum_msum_pdevs_cases:\n  assumes \"degree f \\<le> n\"\n  assumes [simp]: \"\\<And>i. e i 0 = 0\"\n  shows\n    \"(\\<Sum>i <degree (msum_pdevs n f g).\n      e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i <degree f. e i (pdevs_apply f i)) + (\\<Sum>i <degree g. e (i + n) (pdevs_apply g i))\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "have \"?lhs = (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> {i. i < n}. e i (pdevs_apply f i)) +\n    (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> - {i. i < n}. e i (pdevs_apply g (i - n)))\"\n    (is \"_ = ?sum_f + ?sum_g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> {i. i < n}.\n       e i (pdevs_apply f i)) +\n    (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> - {i. i < n}.\n       e i (pdevs_apply g (i - n)))", "by (simp add: sum.If_cases if_distrib)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (msum_pdevs n f g).\n      e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n  (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> {i. i < n}.\n     e i (pdevs_apply f i)) +\n  (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> - {i. i < n}.\n     e i (pdevs_apply g (i - n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (msum_pdevs n f g).\n      e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n  (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> {i. i < n}.\n     e i (pdevs_apply f i)) +\n  (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> - {i. i < n}.\n     e i (pdevs_apply g (i - n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "have \"?sum_f = (\\<Sum>i = 0..<degree f. e i (pdevs_apply f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> {i. i < n}.\n       e i (pdevs_apply f i)) =\n    (\\<Sum>i = 0..<degree f. e i (pdevs_apply f i))", "using assms degree_msum_pdevs_ge1[of f n g]"], ["proof (prove)\nusing this:\n  degree f \\<le> n\n  e ?i (0::'a) = (0::'b)\n  degree f \\<le> n \\<Longrightarrow>\n  degree f \\<le> degree (msum_pdevs n f g)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> {i. i < n}.\n       e i (pdevs_apply f i)) =\n    (\\<Sum>i = 0..<degree f. e i (pdevs_apply f i))", "by (intro sum.mono_neutral_cong_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> {i. i < n}.\n     e i (pdevs_apply f i)) =\n  (\\<Sum>i = 0..<degree f. e i (pdevs_apply f i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> {i. i < n}.\n     e i (pdevs_apply f i)) =\n  (\\<Sum>i = 0..<degree f. e i (pdevs_apply f i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "have \"?sum_g = (\\<Sum>i\\<in>{0 + n..<degree (msum_pdevs n f g) - n + n}. e i (pdevs_apply g (i - n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> - {i. i < n}.\n       e i (pdevs_apply g (i - n))) =\n    (\\<Sum>i = 0 + n..<degree (msum_pdevs n f g) - n + n.\n        e i (pdevs_apply g (i - n)))", "by (rule sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> - {i. i < n}.\n     e i (pdevs_apply g (i - n))) =\n  (\\<Sum>i = 0 + n..<degree (msum_pdevs n f g) - n + n.\n      e i (pdevs_apply g (i - n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<degree (msum_pdevs n f g)} \\<inter> - {i. i < n}.\n     e i (pdevs_apply g (i - n))) =\n  (\\<Sum>i = 0 + n..<degree (msum_pdevs n f g) - n + n.\n      e i (pdevs_apply g (i - n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "have \"\\<dots> = (\\<Sum>i = 0..<degree (msum_pdevs n f g) - n. e (i + n) (pdevs_apply g (i + n - n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0 + n..<degree (msum_pdevs n f g) - n + n.\n        e i (pdevs_apply g (i - n))) =\n    (\\<Sum>i = 0..<degree (msum_pdevs n f g) - n.\n        e (i + n) (pdevs_apply g (i + n - n)))", "by (rule sum.shift_bounds_nat_ivl)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0 + n..<degree (msum_pdevs n f g) - n + n.\n      e i (pdevs_apply g (i - n))) =\n  (\\<Sum>i = 0..<degree (msum_pdevs n f g) - n.\n      e (i + n) (pdevs_apply g (i + n - n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0 + n..<degree (msum_pdevs n f g) - n + n.\n      e i (pdevs_apply g (i - n))) =\n  (\\<Sum>i = 0..<degree (msum_pdevs n f g) - n.\n      e (i + n) (pdevs_apply g (i + n - n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "have \"\\<dots> = (\\<Sum>i = 0..<degree g. e (i + n) (pdevs_apply g i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<degree (msum_pdevs n f g) - n.\n        e (i + n) (pdevs_apply g (i + n - n))) =\n    (\\<Sum>i = 0..<degree g. e (i + n) (pdevs_apply g i))", "using assms degree_msum_pdevs_ge2[of f n]"], ["proof (prove)\nusing this:\n  degree f \\<le> n\n  e ?i (0::'a) = (0::'b)\n  degree f \\<le> n \\<Longrightarrow>\n  degree ?g \\<le> degree (msum_pdevs n f ?g) - n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<degree (msum_pdevs n f g) - n.\n        e (i + n) (pdevs_apply g (i + n - n))) =\n    (\\<Sum>i = 0..<degree g. e (i + n) (pdevs_apply g i))", "by (intro sum.mono_neutral_cong_right) (auto intro!: sum.mono_neutral_cong_right)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<degree (msum_pdevs n f g) - n.\n      e (i + n) (pdevs_apply g (i + n - n))) =\n  (\\<Sum>i = 0..<degree g. e (i + n) (pdevs_apply g i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<degree (msum_pdevs n f g).\n      e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n  (\\<Sum>i = 0..<degree f. e i (pdevs_apply f i)) +\n  (\\<Sum>i = 0..<degree g. e (i + n) (pdevs_apply g i))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i<degree (msum_pdevs n f g).\n      e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n  (\\<Sum>i = 0..<degree f. e i (pdevs_apply f i)) +\n  (\\<Sum>i = 0..<degree g. e (i + n) (pdevs_apply g i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (msum_pdevs n f g).\n        e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n    (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n    (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))", "by (simp add: atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (msum_pdevs n f g).\n      e i (if i < n then pdevs_apply f i else pdevs_apply g (i - n))) =\n  (\\<Sum>i<degree f. e i (pdevs_apply f i)) +\n  (\\<Sum>i<degree g. e (i + n) (pdevs_apply g i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tdev_msum_pdevs: \"degree f \\<le> n \\<Longrightarrow> tdev (msum_pdevs n f g) = tdev f + tdev g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f \\<le> n \\<Longrightarrow>\n    tdev (msum_pdevs n f g) = tdev f + tdev g", "by (auto simp: tdev_def pdevs_apply_msum_pdevs intro!: sum_msum_pdevs_cases)"], ["", "lemma pdevs_val_msum_pdevs:\n  \"degree f \\<le> n \\<Longrightarrow> pdevs_val e (msum_pdevs n f g) = pdevs_val e f + pdevs_val (\\<lambda>i. e (i + n)) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f \\<le> n \\<Longrightarrow>\n    pdevs_val e (msum_pdevs n f g) =\n    pdevs_val e f + pdevs_val (\\<lambda>i. e (i + n)) g", "by (auto simp: pdevs_val_sum pdevs_apply_msum_pdevs intro!: sum_msum_pdevs_cases)"], ["", "definition msum_aform::\"nat \\<Rightarrow> 'a::real_vector aform \\<Rightarrow> 'a aform \\<Rightarrow> 'a aform\"\n  where \"msum_aform n f g = (fst f + fst g, msum_pdevs n (snd f) (snd g))\""], ["", "lemma fst_msum_aform[simp]: \"fst (msum_aform n f g) = fst f + fst g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (msum_aform n f g) = fst f + fst g", "by (simp add: msum_aform_def)"], ["", "lemma snd_msum_aform[simp]: \"snd (msum_aform n f g) = msum_pdevs n (snd f) (snd g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (msum_aform n f g) = msum_pdevs n (snd f) (snd g)", "by (simp add: msum_aform_def)"], ["", "lemma finite_nonzero_summable: \"finite {i. f i \\<noteq> 0} \\<Longrightarrow> summable f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. f i \\<noteq> (0::'a)} \\<Longrightarrow> summable f", "by (auto intro!: sums_summable sums_finite)"], ["", "lemma aform_val_msum_aform:\n  assumes \"degree_aform f \\<le> n\"\n  shows \"aform_val e (msum_aform n f g) = aform_val e f + aform_val (\\<lambda>i. e (i + n)) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (msum_aform n f g) =\n    aform_val e f + aform_val (\\<lambda>i. e (i + n)) g", "using assms"], ["proof (prove)\nusing this:\n  degree_aform f \\<le> n\n\ngoal (1 subgoal):\n 1. aform_val e (msum_aform n f g) =\n    aform_val e f + aform_val (\\<lambda>i. e (i + n)) g", "by (auto simp: pdevs_val_msum_pdevs aform_val_def)"], ["", "lemma Inf_aform_msum_aform:\n  \"degree_aform X \\<le> n \\<Longrightarrow> Inf_aform (msum_aform n X Y) = Inf_aform X + Inf_aform Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform X \\<le> n \\<Longrightarrow>\n    Inf_aform (msum_aform n X Y) = Inf_aform X + Inf_aform Y", "by (simp add: Inf_aform_def tdev_msum_pdevs)"], ["", "lemma Sup_aform_msum_aform:\n  \"degree_aform X \\<le> n \\<Longrightarrow> Sup_aform (msum_aform n X Y) = Sup_aform X + Sup_aform Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_aform X \\<le> n \\<Longrightarrow>\n    Sup_aform (msum_aform n X Y) = Sup_aform X + Sup_aform Y", "by (simp add: Sup_aform_def tdev_msum_pdevs)"], ["", "definition \"independent_from d Y = msum_aform d (0, zero_pdevs) Y\""], ["", "definition \"independent_aform X Y = independent_from (degree_aform X) Y\""], ["", "lemma degree_zero_pdevs[simp]: \"degree zero_pdevs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree zero_pdevs = 0", "by (metis degree_least_nonzero pdevs_apply_zero_pdevs)"], ["", "lemma independent_aform_Joints:\n  assumes \"x \\<in> Affine X\"\n  assumes \"y \\<in> Affine Y\"\n  shows \"[x, y] \\<in> Joints [X, independent_aform X Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x, y] \\<in> Joints [X, independent_aform X Y]", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Affine X\n  y \\<in> Affine Y\n\ngoal (1 subgoal):\n 1. [x, y] \\<in> Joints [X, independent_aform X Y]", "unfolding Affine_def valuate_def Joints_def"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>e. aform_val e X) ` (UNIV \\<rightarrow> {- 1..1})\n  y \\<in> (\\<lambda>e. aform_val e Y) ` (UNIV \\<rightarrow> {- 1..1})\n\ngoal (1 subgoal):\n 1. [x, y]\n    \\<in> (\\<lambda>e. map (aform_val e) [X, independent_aform X Y]) `\n          (UNIV \\<rightarrow> {- 1..1})", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e ea.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1}; x = aform_val e X;\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; y = aform_val ea Y\\<rbrakk>\n       \\<Longrightarrow> [aform_val e X, aform_val ea Y]\n                         \\<in> (\\<lambda>e.\n                                   map (aform_val e)\n                                    [X, independent_aform X Y]) `\n                               (UNIV \\<rightarrow> {- 1..1})", "subgoal premises prems for e ea"], ["proof (prove)\ngoal (1 subgoal):\n 1. [aform_val e X, aform_val ea Y]\n    \\<in> (\\<lambda>e. map (aform_val e) [X, independent_aform X Y]) `\n          (UNIV \\<rightarrow> {- 1..1})", "using prems"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  x = aform_val e X\n  ea \\<in> UNIV \\<rightarrow> {- 1..1}\n  y = aform_val ea Y\n\ngoal (1 subgoal):\n 1. [aform_val e X, aform_val ea Y]\n    \\<in> (\\<lambda>e. map (aform_val e) [X, independent_aform X Y]) `\n          (UNIV \\<rightarrow> {- 1..1})", "by (intro image_eqI[where x=\"\\<lambda>i. if i < degree_aform X then e i else ea (i - degree_aform X)\"])\n      (auto simp: aform_val_def pdevs_val_msum_pdevs Pi_iff\n      independent_aform_def independent_from_def intro!: pdevs_val_degree_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma msum_aform_Joints:\n  assumes \"d \\<ge> degree_aform X\"\n  assumes \"\\<And>X. X \\<in> set XS \\<Longrightarrow> d \\<ge> degree_aform X\"\n  assumes \"(x#xs) \\<in> Joints (X#XS)\"\n  assumes \"y \\<in> Affine Y\"\n  shows \"((x + y)#x#xs) \\<in> Joints (msum_aform d X Y#X#XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) # x # xs \\<in> Joints (msum_aform d X Y # X # XS)", "using assms"], ["proof (prove)\nusing this:\n  degree_aform X \\<le> d\n  ?X \\<in> set XS \\<Longrightarrow> degree_aform ?X \\<le> d\n  x # xs \\<in> Joints (X # XS)\n  y \\<in> Affine Y\n\ngoal (1 subgoal):\n 1. (x + y) # x # xs \\<in> Joints (msum_aform d X Y # X # XS)", "unfolding Joints_def valuate_def Affine_def"], ["proof (prove)\nusing this:\n  degree_aform X \\<le> d\n  ?X \\<in> set XS \\<Longrightarrow> degree_aform ?X \\<le> d\n  x # xs\n  \\<in> (\\<lambda>e. map (aform_val e) (X # XS)) `\n        (UNIV \\<rightarrow> {- 1..1})\n  y \\<in> (\\<lambda>e. aform_val e Y) ` (UNIV \\<rightarrow> {- 1..1})\n\ngoal (1 subgoal):\n 1. (x + y) # x # xs\n    \\<in> (\\<lambda>e. map (aform_val e) (msum_aform d X Y # X # XS)) `\n          (UNIV \\<rightarrow> {- 1..1})", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e ea a b zs.\n       \\<lbrakk>degree_aform (a, b) \\<le> d;\n        \\<And>a b.\n           (a, b) \\<in> set XS \\<Longrightarrow>\n           degree_aform (a, b) \\<le> d;\n        e \\<in> UNIV \\<rightarrow> {- 1..1};\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; y = aform_val ea Y;\n        xs = map (aform_val e) XS; x = aform_val e (a, b);\n        X = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (aform_val e (a, b) + aform_val ea Y) #\n                         aform_val e (a, b) # map (aform_val e) XS\n                         \\<in> (\\<lambda>e.\n                                   map (aform_val e)\n                                    (msum_aform d (a, b) Y # (a, b) # XS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "case (1 e ea a b zs)"], ["proof (state)\nthis:\n  degree_aform (a, b) \\<le> d\n  (?a, ?b) \\<in> set XS \\<Longrightarrow> degree_aform (?a, ?b) \\<le> d\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ea \\<in> UNIV \\<rightarrow> {- 1..1}\n  y = aform_val ea Y\n  xs = map (aform_val e) XS\n  x = aform_val e (a, b)\n  X = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>e ea a b zs.\n       \\<lbrakk>degree_aform (a, b) \\<le> d;\n        \\<And>a b.\n           (a, b) \\<in> set XS \\<Longrightarrow>\n           degree_aform (a, b) \\<le> d;\n        e \\<in> UNIV \\<rightarrow> {- 1..1};\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; y = aform_val ea Y;\n        xs = map (aform_val e) XS; x = aform_val e (a, b);\n        X = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (aform_val e (a, b) + aform_val ea Y) #\n                         aform_val e (a, b) # map (aform_val e) XS\n                         \\<in> (\\<lambda>e.\n                                   map (aform_val e)\n                                    (msum_aform d (a, b) Y # (a, b) # XS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "then"], ["proof (chain)\npicking this:\n  degree_aform (a, b) \\<le> d\n  (?a, ?b) \\<in> set XS \\<Longrightarrow> degree_aform (?a, ?b) \\<le> d\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ea \\<in> UNIV \\<rightarrow> {- 1..1}\n  y = aform_val ea Y\n  xs = map (aform_val e) XS\n  x = aform_val e (a, b)\n  X = (a, b)", "show ?case"], ["proof (prove)\nusing this:\n  degree_aform (a, b) \\<le> d\n  (?a, ?b) \\<in> set XS \\<Longrightarrow> degree_aform (?a, ?b) \\<le> d\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ea \\<in> UNIV \\<rightarrow> {- 1..1}\n  y = aform_val ea Y\n  xs = map (aform_val e) XS\n  x = aform_val e (a, b)\n  X = (a, b)\n\ngoal (1 subgoal):\n 1. (aform_val e (a, b) + aform_val ea Y) #\n    aform_val e (a, b) # map (aform_val e) XS\n    \\<in> (\\<lambda>e.\n              map (aform_val e) (msum_aform d (a, b) Y # (a, b) # XS)) `\n          (UNIV \\<rightarrow> {- 1..1})", "by (intro image_eqI[where x = \"\\<lambda>i. if i < d then e i else ea (i - d)\"])\n      (force simp: aform_val_def pdevs_val_msum_pdevs intro!: intro!: pdevs_val_degree_cong)+"], ["proof (state)\nthis:\n  (aform_val e (a, b) + aform_val ea Y) #\n  aform_val e (a, b) # map (aform_val e) XS\n  \\<in> (\\<lambda>e.\n            map (aform_val e) (msum_aform d (a, b) Y # (a, b) # XS)) `\n        (UNIV \\<rightarrow> {- 1..1})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Joints_msum_aform:\n  assumes \"d \\<ge> degree_aform X\"\n  assumes \"\\<And>Y. Y \\<in> set YS \\<Longrightarrow> d \\<ge> degree_aform Y\"\n  shows \"Joints (msum_aform d X Y#YS) = {((x + y)#ys) |x y ys. y \\<in> Affine Y \\<and> x#ys \\<in> Joints (X#YS)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Joints (msum_aform d X Y # YS) =\n    {(x + y) # ys |x y ys.\n     y \\<in> Affine Y \\<and> x # ys \\<in> Joints (X # YS)}", "unfolding Affine_def valuate_def Joints_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>e. map (aform_val e) (msum_aform d X Y # YS)) `\n    (UNIV \\<rightarrow> {- 1..1}) =\n    {(x + y) # ys |x y ys.\n     y \\<in> (\\<lambda>e. aform_val e Y) `\n             (UNIV \\<rightarrow> {- 1..1}) \\<and>\n     x # ys\n     \\<in> (\\<lambda>e. map (aform_val e) (X # YS)) `\n           (UNIV \\<rightarrow> {- 1..1})}", "proof (safe, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n       \\<exists>x y ys.\n          map (aform_val e) (msum_aform d X Y # YS) = (x + y) # ys \\<and>\n          y \\<in> (\\<lambda>e. aform_val e Y) `\n                  (UNIV \\<rightarrow> {- 1..1}) \\<and>\n          x # ys\n          \\<in> (\\<lambda>e. map (aform_val e) (X # YS)) `\n                (UNIV \\<rightarrow> {- 1..1})\n 2. \\<And>x xa y ys e ea a b zs.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; X = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (aform_val ea (a, b) + aform_val e Y) #\n                         map (aform_val ea) YS\n                         \\<in> (\\<lambda>e.\n                                   map (aform_val e)\n                                    (msum_aform d (a, b) Y # YS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "case (1 x e)"], ["proof (state)\nthis:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (2 subgoals):\n 1. \\<And>x e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<Longrightarrow>\n       \\<exists>x y ys.\n          map (aform_val e) (msum_aform d X Y # YS) = (x + y) # ys \\<and>\n          y \\<in> (\\<lambda>e. aform_val e Y) `\n                  (UNIV \\<rightarrow> {- 1..1}) \\<and>\n          x # ys\n          \\<in> (\\<lambda>e. map (aform_val e) (X # YS)) `\n                (UNIV \\<rightarrow> {- 1..1})\n 2. \\<And>x xa y ys e ea a b zs.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; X = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (aform_val ea (a, b) + aform_val e Y) #\n                         map (aform_val ea) YS\n                         \\<in> (\\<lambda>e.\n                                   map (aform_val e)\n                                    (msum_aform d (a, b) Y # YS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "thus ?case"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>x y ys.\n       map (aform_val e) (msum_aform d X Y # YS) = (x + y) # ys \\<and>\n       y \\<in> (\\<lambda>e. aform_val e Y) `\n               (UNIV \\<rightarrow> {- 1..1}) \\<and>\n       x # ys\n       \\<in> (\\<lambda>e. map (aform_val e) (X # YS)) `\n             (UNIV \\<rightarrow> {- 1..1})", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  degree_aform X \\<le> d\n  ?Y \\<in> set YS \\<Longrightarrow> degree_aform ?Y \\<le> d\n\ngoal (1 subgoal):\n 1. \\<exists>x y ys.\n       map (aform_val e) (msum_aform d X Y # YS) = (x + y) # ys \\<and>\n       y \\<in> (\\<lambda>e. aform_val e Y) `\n               (UNIV \\<rightarrow> {- 1..1}) \\<and>\n       x # ys\n       \\<in> (\\<lambda>e. map (aform_val e) (X # YS)) `\n             (UNIV \\<rightarrow> {- 1..1})", "by (intro exI[where x = \"aform_val e X\"] exI[where x = \"aform_val ((\\<lambda>i. e (i + d))) Y\"])\n      (auto simp add: aform_val_def pdevs_val_msum_pdevs)"], ["proof (state)\nthis:\n  \\<exists>x y ys.\n     map (aform_val e) (msum_aform d X Y # YS) = (x + y) # ys \\<and>\n     y \\<in> (\\<lambda>e. aform_val e Y) `\n             (UNIV \\<rightarrow> {- 1..1}) \\<and>\n     x # ys\n     \\<in> (\\<lambda>e. map (aform_val e) (X # YS)) `\n           (UNIV \\<rightarrow> {- 1..1})\n\ngoal (1 subgoal):\n 1. \\<And>x xa y ys e ea a b zs.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; X = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (aform_val ea (a, b) + aform_val e Y) #\n                         map (aform_val ea) YS\n                         \\<in> (\\<lambda>e.\n                                   map (aform_val e)\n                                    (msum_aform d (a, b) Y # YS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa y ys e ea a b zs.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; X = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (aform_val ea (a, b) + aform_val e Y) #\n                         map (aform_val ea) YS\n                         \\<in> (\\<lambda>e.\n                                   map (aform_val e)\n                                    (msum_aform d (a, b) Y # YS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "case (2 x xa y ys e ea)"], ["proof (state)\nthis:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ea \\<in> UNIV \\<rightarrow> {- 1..1}\n  X = (a_, b_)\n\ngoal (1 subgoal):\n 1. \\<And>x xa y ys e ea a b zs.\n       \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n        ea \\<in> UNIV \\<rightarrow> {- 1..1}; X = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (aform_val ea (a, b) + aform_val e Y) #\n                         map (aform_val ea) YS\n                         \\<in> (\\<lambda>e.\n                                   map (aform_val e)\n                                    (msum_aform d (a, b) Y # YS)) `\n                               (UNIV \\<rightarrow> {- 1..1})", "thus ?case"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ea \\<in> UNIV \\<rightarrow> {- 1..1}\n  X = (a_, b_)\n\ngoal (1 subgoal):\n 1. (aform_val ea (a_, b_) + aform_val e Y) # map (aform_val ea) YS\n    \\<in> (\\<lambda>e. map (aform_val e) (msum_aform d (a_, b_) Y # YS)) `\n          (UNIV \\<rightarrow> {- 1..1})", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  ea \\<in> UNIV \\<rightarrow> {- 1..1}\n  X = (a_, b_)\n  degree_aform X \\<le> d\n  ?Y \\<in> set YS \\<Longrightarrow> degree_aform ?Y \\<le> d\n\ngoal (1 subgoal):\n 1. (aform_val ea (a_, b_) + aform_val e Y) # map (aform_val ea) YS\n    \\<in> (\\<lambda>e. map (aform_val e) (msum_aform d (a_, b_) Y # YS)) `\n          (UNIV \\<rightarrow> {- 1..1})", "by (intro image_eqI[where x=\"\\<lambda>i. if i < d then ea i else e (i - d)\"])\n       (force simp: aform_val_def pdevs_val_msum_pdevs Pi_iff intro!: pdevs_val_degree_cong)+"], ["proof (state)\nthis:\n  (aform_val ea (a_, b_) + aform_val e Y) # map (aform_val ea) YS\n  \\<in> (\\<lambda>e. map (aform_val e) (msum_aform d (a_, b_) Y # YS)) `\n        (UNIV \\<rightarrow> {- 1..1})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Joints_singleton_image: \"Joints [x] = (\\<lambda>x. [x]) ` Affine x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Joints [x] = (\\<lambda>x. [x]) ` Affine x", "by (auto simp: Joints_def Affine_def valuate_def)"], ["", "lemma Collect_extract_image: \"{g (f x y) |x y. P x y} = g ` {f x y |x y. P x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {g (f x y) |x y. P x y} = g ` {f x y |x y. P x y}", "by auto"], ["", "lemma inj_Cons: \"inj (\\<lambda>x. x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>x. x # xs)", "by (auto intro!: injI)"], ["", "lemma Joints_Nil[simp]: \"Joints [] = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Joints [] = {[]}", "by (force simp: Joints_def valuate_def)"], ["", "lemma msum_pdevs_zero_ident[simp]: \"msum_pdevs 0 zero_pdevs x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msum_pdevs 0 zero_pdevs x = x", "by transfer (auto simp: msum_pdevs_raw_def)"], ["", "lemma msum_aform_zero_ident[simp]: \"msum_aform 0 (0, zero_pdevs) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msum_aform 0 (0::'a, zero_pdevs) x = x", "by (simp add: msum_aform_def)"], ["", "lemma mem_Joints_singleton: \"(x \\<in> Joints [X]) = (\\<exists>y. x = [y] \\<and> y \\<in> Affine X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> Joints [X]) = (\\<exists>y. x = [y] \\<and> y \\<in> Affine X)", "by (auto simp: Affine_def valuate_def Joints_def)"], ["", "lemma singleton_mem_Joints[simp]: \"[x] \\<in> Joints [X] \\<longleftrightarrow> x \\<in> Affine X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([x] \\<in> Joints [X]) = (x \\<in> Affine X)", "by (auto simp: mem_Joints_singleton)"], ["", "lemma msum_aform_Joints_without_first:\n  assumes \"d \\<ge> degree_aform X\"\n  assumes \"\\<And>X. X \\<in> set XS \\<Longrightarrow> d \\<ge> degree_aform X\"\n  assumes \"(x#xs) \\<in> Joints (X#XS)\"\n  assumes \"y \\<in> Affine Y\"\n  assumes \"z = x + y\"\n  shows \"z#xs \\<in> Joints (msum_aform d X Y#XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z # xs \\<in> Joints (msum_aform d X Y # XS)", "unfolding \\<open>z = x + y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) # xs \\<in> Joints (msum_aform d X Y # XS)", "using msum_aform_Joints[OF assms(1-4)]"], ["proof (prove)\nusing this:\n  (\\<And>X.\n      X \\<in> set XS \\<Longrightarrow> X \\<in> set XS) \\<Longrightarrow>\n  (x + y) # x # xs \\<in> Joints (msum_aform d X Y # X # XS)\n\ngoal (1 subgoal):\n 1. (x + y) # xs \\<in> Joints (msum_aform d X Y # XS)", "by (force simp: Joints_def valuate_def)"], ["", "lemma Affine_msum_aform:\n  assumes \"d \\<ge> degree_aform X\"\n  shows \"Affine (msum_aform d X Y) = {x + y |x y. x \\<in> Affine X \\<and> y \\<in> Affine Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Affine (msum_aform d X Y) =\n    {x + y |x y. x \\<in> Affine X \\<and> y \\<in> Affine Y}", "using Joints_msum_aform[OF assms, of Nil Y, simplified, unfolded mem_Joints_singleton]"], ["proof (prove)\nusing this:\n  Joints [msum_aform d X Y] =\n  {(x + y) # ys |x y ys.\n   y \\<in> Affine Y \\<and>\n   (\\<exists>y. x # ys = [y] \\<and> y \\<in> Affine X)}\n\ngoal (1 subgoal):\n 1. Affine (msum_aform d X Y) =\n    {x + y |x y. x \\<in> Affine X \\<and> y \\<in> Affine Y}", "by (auto simp add: Joints_singleton_image Collect_extract_image[where g=\"\\<lambda>x. [x]\"]\n    inj_image_eq_iff[OF inj_Cons] )"], ["", "lemma Affine_zero_pdevs[simp]: \"Affine (0, zero_pdevs) = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Affine (0::'a, zero_pdevs) = {0::'a}", "by (force simp: Affine_def valuate_def aform_val_def)"], ["", "lemma Affine_independent_aform:\n  \"Affine (independent_aform X Y) = Affine Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Affine (independent_aform X Y) = Affine Y", "by (auto simp: independent_aform_def independent_from_def Affine_msum_aform)"], ["", "lemma\n  abs_diff_eq1:\n  fixes l u::\"'a::ordered_euclidean_space\"\n  shows \"l \\<le> u \\<Longrightarrow> \\<bar>u - l\\<bar> = u - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> u \\<Longrightarrow> \\<bar>u - l\\<bar> = u - l", "by (metis abs_of_nonneg diff_add_cancel le_add_same_cancel2)"], ["", "lemma compact_sum:\n  fixes f :: \"'a \\<Rightarrow> 'b::topological_space \\<Rightarrow> 'c::real_normed_vector\"\n  assumes \"finite I\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i)\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i)\"\n  assumes \"I \\<subseteq> J\"\n  shows \"compact {\\<Sum>i\\<in>I. f i (x i) | x. x \\<in> Pi J S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}", "using assms"], ["proof (prove)\nusing this:\n  finite I\n  ?i \\<in> I \\<Longrightarrow> compact (S ?i)\n  ?i \\<in> I \\<Longrightarrow> continuous_on (S ?i) (f ?i)\n  I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. compact {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}", "proof (induct I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i. i \\<in> {} \\<Longrightarrow> compact (S i);\n     \\<And>i. i \\<in> {} \\<Longrightarrow> continuous_on (S i) (f i);\n     {} \\<subseteq> J\\<rbrakk>\n    \\<Longrightarrow> compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> F \\<Longrightarrow> continuous_on (S i) (f i);\n         F \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>F. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> continuous_on (S i) (f i);\n        insert x F \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> compact\n                          {\\<Sum>i\\<in>insert x F. f i (xa i) |xa.\n                           xa \\<in> Pi J S}", "case empty"], ["proof (state)\nthis:\n  ?i \\<in> {} \\<Longrightarrow> compact (S ?i)\n  ?i \\<in> {} \\<Longrightarrow> continuous_on (S ?i) (f ?i)\n  {} \\<subseteq> J\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i. i \\<in> {} \\<Longrightarrow> compact (S i);\n     \\<And>i. i \\<in> {} \\<Longrightarrow> continuous_on (S i) (f i);\n     {} \\<subseteq> J\\<rbrakk>\n    \\<Longrightarrow> compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> F \\<Longrightarrow> continuous_on (S i) (f i);\n         F \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>F. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> continuous_on (S i) (f i);\n        insert x F \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> compact\n                          {\\<Sum>i\\<in>insert x F. f i (xa i) |xa.\n                           xa \\<in> Pi J S}", "thus ?case"], ["proof (prove)\nusing this:\n  ?i \\<in> {} \\<Longrightarrow> compact (S ?i)\n  ?i \\<in> {} \\<Longrightarrow> continuous_on (S ?i) (f ?i)\n  {} \\<subseteq> J\n\ngoal (1 subgoal):\n 1. compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}", "proof (cases \"\\<exists>x. x \\<in> Pi J S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i. i \\<in> {} \\<Longrightarrow> compact (S i);\n     \\<And>i. i \\<in> {} \\<Longrightarrow> continuous_on (S i) (f i);\n     {} \\<subseteq> J; \\<exists>x. x \\<in> Pi J S\\<rbrakk>\n    \\<Longrightarrow> compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}\n 2. \\<lbrakk>\\<And>i. i \\<in> {} \\<Longrightarrow> compact (S i);\n     \\<And>i. i \\<in> {} \\<Longrightarrow> continuous_on (S i) (f i);\n     {} \\<subseteq> J; \\<nexists>x. x \\<in> Pi J S\\<rbrakk>\n    \\<Longrightarrow> compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}", "case False"], ["proof (state)\nthis:\n  \\<nexists>x. x \\<in> Pi J S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i. i \\<in> {} \\<Longrightarrow> compact (S i);\n     \\<And>i. i \\<in> {} \\<Longrightarrow> continuous_on (S i) (f i);\n     {} \\<subseteq> J; \\<exists>x. x \\<in> Pi J S\\<rbrakk>\n    \\<Longrightarrow> compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}\n 2. \\<lbrakk>\\<And>i. i \\<in> {} \\<Longrightarrow> compact (S i);\n     \\<And>i. i \\<in> {} \\<Longrightarrow> continuous_on (S i) (f i);\n     {} \\<subseteq> J; \\<nexists>x. x \\<in> Pi J S\\<rbrakk>\n    \\<Longrightarrow> compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}", "hence *: \"{\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S} = {}\""], ["proof (prove)\nusing this:\n  \\<nexists>x. x \\<in> Pi J S\n\ngoal (1 subgoal):\n 1. {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S} = {}", "by (auto simp: Pi_iff)"], ["proof (state)\nthis:\n  {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S} = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i. i \\<in> {} \\<Longrightarrow> compact (S i);\n     \\<And>i. i \\<in> {} \\<Longrightarrow> continuous_on (S i) (f i);\n     {} \\<subseteq> J; \\<exists>x. x \\<in> Pi J S\\<rbrakk>\n    \\<Longrightarrow> compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}\n 2. \\<lbrakk>\\<And>i. i \\<in> {} \\<Longrightarrow> compact (S i);\n     \\<And>i. i \\<in> {} \\<Longrightarrow> continuous_on (S i) (f i);\n     {} \\<subseteq> J; \\<nexists>x. x \\<in> Pi J S\\<rbrakk>\n    \\<Longrightarrow> compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. compact {}", "by simp"], ["proof (state)\nthis:\n  compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i. i \\<in> {} \\<Longrightarrow> compact (S i);\n     \\<And>i. i \\<in> {} \\<Longrightarrow> continuous_on (S i) (f i);\n     {} \\<subseteq> J; \\<exists>x. x \\<in> Pi J S\\<rbrakk>\n    \\<Longrightarrow> compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}", "qed auto"], ["proof (state)\nthis:\n  compact {\\<Sum>i\\<in>{}. f i (x i) |x. x \\<in> Pi J S}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> F \\<Longrightarrow> continuous_on (S i) (f i);\n         F \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>F. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> continuous_on (S i) (f i);\n        insert x F \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> compact\n                          {\\<Sum>i\\<in>insert x F. f i (xa i) |xa.\n                           xa \\<in> Pi J S}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> F \\<Longrightarrow> continuous_on (S i) (f i);\n         F \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>F. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> continuous_on (S i) (f i);\n        insert x F \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> compact\n                          {\\<Sum>i\\<in>insert x F. f i (xa i) |xa.\n                           xa \\<in> Pi J S}", "case (insert a I)"], ["proof (state)\nthis:\n  finite I\n  a \\<notin> I\n  \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n   \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n   I \\<subseteq> J\\<rbrakk>\n  \\<Longrightarrow> compact {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}\n  ?i \\<in> insert a I \\<Longrightarrow> compact (S ?i)\n  ?i \\<in> insert a I \\<Longrightarrow> continuous_on (S ?i) (f ?i)\n  insert a I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> F \\<Longrightarrow> continuous_on (S i) (f i);\n         F \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>F. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> continuous_on (S i) (f i);\n        insert x F \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> compact\n                          {\\<Sum>i\\<in>insert x F. f i (xa i) |xa.\n                           xa \\<in> Pi J S}", "hence \"{\\<Sum>i\\<in>insert a I. f i (xa i) |xa. xa \\<in> Pi J S}\n    = {x + y |x y. x \\<in> f a ` S a \\<and> y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}}\""], ["proof (prove)\nusing this:\n  finite I\n  a \\<notin> I\n  \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n   \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n   I \\<subseteq> J\\<rbrakk>\n  \\<Longrightarrow> compact {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}\n  ?i \\<in> insert a I \\<Longrightarrow> compact (S ?i)\n  ?i \\<in> insert a I \\<Longrightarrow> continuous_on (S ?i) (f ?i)\n  insert a I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. {\\<Sum>i\\<in>insert a I. f i (xa i) |xa. xa \\<in> Pi J S} =\n    {x + y |x y.\n     x \\<in> f a ` S a \\<and>\n     y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>finite I; a \\<notin> I;\n        \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n         I \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert a I \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert a I \\<Longrightarrow> continuous_on (S i) (f i);\n        insert a I \\<subseteq> J; xa \\<in> Pi J S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (\\<Sum>i\\<in>insert a I. f i (xa i)) =\n                            x + y \\<and>\n                            x \\<in> f a ` S a \\<and>\n                            y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x.\n                                     x \\<in> Pi J S}\n 2. \\<And>x xa y xb xc.\n       \\<lbrakk>finite I; a \\<notin> I;\n        \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n         I \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert a I \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert a I \\<Longrightarrow> continuous_on (S i) (f i);\n        insert a I \\<subseteq> J; xb \\<in> S a; xc \\<in> Pi J S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            f a xb + (\\<Sum>i\\<in>I. f i (xc i)) =\n                            (\\<Sum>i\\<in>insert a I. f i (xa i)) \\<and>\n                            xa \\<in> Pi J S", "fix s x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>finite I; a \\<notin> I;\n        \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n         I \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert a I \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert a I \\<Longrightarrow> continuous_on (S i) (f i);\n        insert a I \\<subseteq> J; xa \\<in> Pi J S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (\\<Sum>i\\<in>insert a I. f i (xa i)) =\n                            x + y \\<and>\n                            x \\<in> f a ` S a \\<and>\n                            y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x.\n                                     x \\<in> Pi J S}\n 2. \\<And>x xa y xb xc.\n       \\<lbrakk>finite I; a \\<notin> I;\n        \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n         I \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert a I \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert a I \\<Longrightarrow> continuous_on (S i) (f i);\n        insert a I \\<subseteq> J; xb \\<in> S a; xc \\<in> Pi J S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            f a xb + (\\<Sum>i\\<in>I. f i (xc i)) =\n                            (\\<Sum>i\\<in>insert a I. f i (xa i)) \\<and>\n                            xa \\<in> Pi J S", "assume \"s \\<in> S a\" \"x \\<in> Pi J S\""], ["proof (state)\nthis:\n  s \\<in> S a\n  x \\<in> Pi J S\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>finite I; a \\<notin> I;\n        \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n         I \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert a I \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert a I \\<Longrightarrow> continuous_on (S i) (f i);\n        insert a I \\<subseteq> J; xa \\<in> Pi J S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (\\<Sum>i\\<in>insert a I. f i (xa i)) =\n                            x + y \\<and>\n                            x \\<in> f a ` S a \\<and>\n                            y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x.\n                                     x \\<in> Pi J S}\n 2. \\<And>x xa y xb xc.\n       \\<lbrakk>finite I; a \\<notin> I;\n        \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n         I \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert a I \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert a I \\<Longrightarrow> continuous_on (S i) (f i);\n        insert a I \\<subseteq> J; xb \\<in> S a; xc \\<in> Pi J S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            f a xb + (\\<Sum>i\\<in>I. f i (xc i)) =\n                            (\\<Sum>i\\<in>insert a I. f i (xa i)) \\<and>\n                            xa \\<in> Pi J S", "thus \"\\<exists>xa. f a s + (\\<Sum>i\\<in>I. f i (x i)) = (\\<Sum>i\\<in>insert a I. f i (xa i)) \\<and> xa \\<in> Pi J S\""], ["proof (prove)\nusing this:\n  s \\<in> S a\n  x \\<in> Pi J S\n\ngoal (1 subgoal):\n 1. \\<exists>xa.\n       f a s + (\\<Sum>i\\<in>I. f i (x i)) =\n       (\\<Sum>i\\<in>insert a I. f i (xa i)) \\<and>\n       xa \\<in> Pi J S", "using insert"], ["proof (prove)\nusing this:\n  s \\<in> S a\n  x \\<in> Pi J S\n  finite I\n  a \\<notin> I\n  \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n   \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n   I \\<subseteq> J\\<rbrakk>\n  \\<Longrightarrow> compact {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}\n  ?i \\<in> insert a I \\<Longrightarrow> compact (S ?i)\n  ?i \\<in> insert a I \\<Longrightarrow> continuous_on (S ?i) (f ?i)\n  insert a I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. \\<exists>xa.\n       f a s + (\\<Sum>i\\<in>I. f i (x i)) =\n       (\\<Sum>i\\<in>insert a I. f i (xa i)) \\<and>\n       xa \\<in> Pi J S", "by (auto intro!: exI[where x=\"x(a:=s)\"] sum.cong)"], ["proof (state)\nthis:\n  \\<exists>xa.\n     f a s + (\\<Sum>i\\<in>I. f i (x i)) =\n     (\\<Sum>i\\<in>insert a I. f i (xa i)) \\<and>\n     xa \\<in> Pi J S\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>finite I; a \\<notin> I;\n        \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n         I \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert a I \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert a I \\<Longrightarrow> continuous_on (S i) (f i);\n        insert a I \\<subseteq> J; xa \\<in> Pi J S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (\\<Sum>i\\<in>insert a I. f i (xa i)) =\n                            x + y \\<and>\n                            x \\<in> f a ` S a \\<and>\n                            y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x.\n                                     x \\<in> Pi J S}", "qed force"], ["proof (state)\nthis:\n  {\\<Sum>i\\<in>insert a I. f i (xa i) |xa. xa \\<in> Pi J S} =\n  {x + y |x y.\n   x \\<in> f a ` S a \\<and>\n   y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> F \\<Longrightarrow> continuous_on (S i) (f i);\n         F \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>F. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> continuous_on (S i) (f i);\n        insert x F \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> compact\n                          {\\<Sum>i\\<in>insert x F. f i (xa i) |xa.\n                           xa \\<in> Pi J S}", "also"], ["proof (state)\nthis:\n  {\\<Sum>i\\<in>insert a I. f i (xa i) |xa. xa \\<in> Pi J S} =\n  {x + y |x y.\n   x \\<in> f a ` S a \\<and>\n   y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> F \\<Longrightarrow> continuous_on (S i) (f i);\n         F \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>F. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> continuous_on (S i) (f i);\n        insert x F \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> compact\n                          {\\<Sum>i\\<in>insert x F. f i (xa i) |xa.\n                           xa \\<in> Pi J S}", "have \"compact \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact\n     {x + y |x y.\n      x \\<in> f a ` S a \\<and>\n      y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}}", "using insert"], ["proof (prove)\nusing this:\n  finite I\n  a \\<notin> I\n  \\<lbrakk>\\<And>i. i \\<in> I \\<Longrightarrow> compact (S i);\n   \\<And>i. i \\<in> I \\<Longrightarrow> continuous_on (S i) (f i);\n   I \\<subseteq> J\\<rbrakk>\n  \\<Longrightarrow> compact {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}\n  ?i \\<in> insert a I \\<Longrightarrow> compact (S ?i)\n  ?i \\<in> insert a I \\<Longrightarrow> continuous_on (S ?i) (f ?i)\n  insert a I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. compact\n     {x + y |x y.\n      x \\<in> f a ` S a \\<and>\n      y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}}", "by (intro compact_sums) (auto intro!: compact_continuous_image)"], ["proof (state)\nthis:\n  compact\n   {x + y |x y.\n    x \\<in> f a ` S a \\<and>\n    y \\<in> {\\<Sum>i\\<in>I. f i (x i) |x. x \\<in> Pi J S}}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> compact (S i);\n         \\<And>i. i \\<in> F \\<Longrightarrow> continuous_on (S i) (f i);\n         F \\<subseteq> J\\<rbrakk>\n        \\<Longrightarrow> compact\n                           {\\<Sum>i\\<in>F. f i (x i) |x. x \\<in> Pi J S};\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> compact (S i);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> continuous_on (S i) (f i);\n        insert x F \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> compact\n                          {\\<Sum>i\\<in>insert x F. f i (xa i) |xa.\n                           xa \\<in> Pi J S}", "finally"], ["proof (chain)\npicking this:\n  compact {\\<Sum>i\\<in>insert a I. f i (xa i) |xa. xa \\<in> Pi J S}", "show ?case"], ["proof (prove)\nusing this:\n  compact {\\<Sum>i\\<in>insert a I. f i (xa i) |xa. xa \\<in> Pi J S}\n\ngoal (1 subgoal):\n 1. compact {\\<Sum>i\\<in>insert a I. f i (x i) |x. x \\<in> Pi J S}", "."], ["proof (state)\nthis:\n  compact {\\<Sum>i\\<in>insert a I. f i (x i) |x. x \\<in> Pi J S}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compact_Affine:\n  fixes X::\"'a::ordered_euclidean_space aform\"\n  shows \"compact (Affine X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact (Affine X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. compact (Affine X)", "have \"Affine X = {x + y|x y. x \\<in> {fst X} \\<and>\n      y \\<in> {(\\<Sum>i \\<in> {0..<degree_aform X}. e i *\\<^sub>R pdevs_apply (snd X) i) | e. e \\<in> UNIV \\<rightarrow> {-1 .. 1}}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Affine X =\n    {x + y |x y.\n     x \\<in> {fst X} \\<and>\n     y \\<in> {\\<Sum>i = 0..<degree_aform X.\n                 e i *\\<^sub>R pdevs_apply (snd X) i |\n              e. e \\<in> UNIV \\<rightarrow> {- 1..1}}}", "by (auto simp: Affine_def valuate_def aform_val_def pdevs_val_sum atLeast0LessThan)"], ["proof (state)\nthis:\n  Affine X =\n  {x + y |x y.\n   x \\<in> {fst X} \\<and>\n   y \\<in> {\\<Sum>i = 0..<degree_aform X.\n               e i *\\<^sub>R pdevs_apply (snd X) i |\n            e. e \\<in> UNIV \\<rightarrow> {- 1..1}}}\n\ngoal (1 subgoal):\n 1. compact (Affine X)", "also"], ["proof (state)\nthis:\n  Affine X =\n  {x + y |x y.\n   x \\<in> {fst X} \\<and>\n   y \\<in> {\\<Sum>i = 0..<degree_aform X.\n               e i *\\<^sub>R pdevs_apply (snd X) i |\n            e. e \\<in> UNIV \\<rightarrow> {- 1..1}}}\n\ngoal (1 subgoal):\n 1. compact (Affine X)", "have \"compact \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact\n     {x + y |x y.\n      x \\<in> {fst X} \\<and>\n      y \\<in> {\\<Sum>i = 0..<degree_aform X.\n                  e i *\\<^sub>R pdevs_apply (snd X) i |\n               e. e \\<in> UNIV \\<rightarrow> {- 1..1}}}", "by (rule compact_sums) (auto intro!: compact_sum continuous_intros)"], ["proof (state)\nthis:\n  compact\n   {x + y |x y.\n    x \\<in> {fst X} \\<and>\n    y \\<in> {\\<Sum>i = 0..<degree_aform X.\n                e i *\\<^sub>R pdevs_apply (snd X) i |\n             e. e \\<in> UNIV \\<rightarrow> {- 1..1}}}\n\ngoal (1 subgoal):\n 1. compact (Affine X)", "finally"], ["proof (chain)\npicking this:\n  compact (Affine X)", "show ?thesis"], ["proof (prove)\nusing this:\n  compact (Affine X)\n\ngoal (1 subgoal):\n 1. compact (Affine X)", "."], ["proof (state)\nthis:\n  compact (Affine X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Joints2_JointsI:\n  \"(xs, x) \\<in> Joints2 XS X \\<Longrightarrow> x#xs \\<in> Joints (X#XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, x) \\<in> Joints2 XS X \\<Longrightarrow>\n    x # xs \\<in> Joints (X # XS)", "by (auto simp: Joints_def Joints2_def valuate_def)"], ["", "subsection \\<open>Splitting\\<close>"], ["", "definition \"split_aform X i =\n  (let xi = pdevs_apply (snd X) i /\\<^sub>R 2\n  in ((fst X - xi, pdev_upd (snd X) i xi), (fst X + xi, pdev_upd (snd X) i xi)))\""], ["", "lemma split_aformE:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"x = aform_val e X\"\n  obtains err where \"x = aform_val (e(i:=err)) (fst (split_aform X i))\" \"err \\<in> {-1 .. 1}\"\n    | err where \"x = aform_val (e(i:=err)) (snd (split_aform X i))\" \"err \\<in> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>err.\n                \\<lbrakk>x =\n                         aform_val (e(i := err)) (fst (split_aform X i));\n                 err \\<in> {- 1..1}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>err.\n        \\<lbrakk>x = aform_val (e(i := err)) (snd (split_aform X i));\n         err \\<in> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "let ?thesis = \"(\\<exists>err. x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and> err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err. x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and> err \\<in> {- 1..1})\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "assume \"pdevs_apply (snd X) i = 0\""], ["proof (state)\nthis:\n  pdevs_apply (snd X) i = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "hence \"X = fst (split_aform X i)\""], ["proof (prove)\nusing this:\n  pdevs_apply (snd X) i = (0::'a)\n\ngoal (1 subgoal):\n 1. X = fst (split_aform X i)", "by (auto simp: split_aform_def intro!: prod_eqI pdevs_eqI)"], ["proof (state)\nthis:\n  X = fst (split_aform X i)\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "with assms"], ["proof (chain)\npicking this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  x = aform_val e X\n  X = fst (split_aform X i)", "have ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  x = aform_val e X\n  X = fst (split_aform X i)\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "by (auto intro!: exI[where x=\"e i\"])"], ["proof (state)\nthis:\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "}"], ["proof (state)\nthis:\n  pdevs_apply (snd X) i = (0::'a) \\<Longrightarrow>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "moreover"], ["proof (state)\nthis:\n  pdevs_apply (snd X) i = (0::'a) \\<Longrightarrow>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "{"], ["proof (state)\nthis:\n  pdevs_apply (snd X) i = (0::'a) \\<Longrightarrow>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "assume \"pdevs_apply (snd X) i \\<noteq> 0\""], ["proof (state)\nthis:\n  pdevs_apply (snd X) i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "hence [simp]: \"degree_aform X > i\""], ["proof (prove)\nusing this:\n  pdevs_apply (snd X) i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. i < degree_aform X", "by (rule degree_gt)"], ["proof (state)\nthis:\n  i < degree_aform X\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "note assms(2)"], ["proof (state)\nthis:\n  x = aform_val e X\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "also"], ["proof (state)\nthis:\n  x = aform_val e X\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "have \"aform_val e X = fst X + (\\<Sum>i<degree_aform X. e i *\\<^sub>R pdevs_apply (snd X) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e X =\n    fst X + (\\<Sum>i<degree_aform X. e i *\\<^sub>R pdevs_apply (snd X) i)", "by (simp add: aform_val_def pdevs_val_sum)"], ["proof (state)\nthis:\n  aform_val e X =\n  fst X + (\\<Sum>i<degree_aform X. e i *\\<^sub>R pdevs_apply (snd X) i)\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "also"], ["proof (state)\nthis:\n  aform_val e X =\n  fst X + (\\<Sum>i<degree_aform X. e i *\\<^sub>R pdevs_apply (snd X) i)\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "have rewr: \"{..<degree_aform X} = {0..<degree_aform X} - {i} \\<union> {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<degree_aform X} = {0..<degree_aform X} - {i} \\<union> {i}", "by auto"], ["proof (state)\nthis:\n  {..<degree_aform X} = {0..<degree_aform X} - {i} \\<union> {i}\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "have \"(\\<Sum>i<degree_aform X. e i *\\<^sub>R pdevs_apply (snd X) i) =\n        (\\<Sum>i \\<in> {0..<degree_aform X} - {i}. e i *\\<^sub>R pdevs_apply (snd X) i) +\n        e i *\\<^sub>R pdevs_apply (snd X) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree_aform X. e i *\\<^sub>R pdevs_apply (snd X) i) =\n    (\\<Sum>i\\<in>{0..<degree_aform X} - {i}.\n       e i *\\<^sub>R pdevs_apply (snd X) i) +\n    e i *\\<^sub>R pdevs_apply (snd X) i", "by (subst rewr, subst sum.union_disjoint) auto"], ["proof (state)\nthis:\n  (\\<Sum>i<degree_aform X. e i *\\<^sub>R pdevs_apply (snd X) i) =\n  (\\<Sum>i\\<in>{0..<degree_aform X} - {i}.\n     e i *\\<^sub>R pdevs_apply (snd X) i) +\n  e i *\\<^sub>R pdevs_apply (snd X) i\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "finally"], ["proof (chain)\npicking this:\n  x =\n  fst X +\n  ((\\<Sum>i\\<in>{0..<degree_aform X} - {i}.\n      e i *\\<^sub>R pdevs_apply (snd X) i) +\n   e i *\\<^sub>R pdevs_apply (snd X) i)", "have \"x = fst X + \\<dots>\""], ["proof (prove)\nusing this:\n  x =\n  fst X +\n  ((\\<Sum>i\\<in>{0..<degree_aform X} - {i}.\n      e i *\\<^sub>R pdevs_apply (snd X) i) +\n   e i *\\<^sub>R pdevs_apply (snd X) i)\n\ngoal (1 subgoal):\n 1. x =\n    fst X +\n    ((\\<Sum>i\\<in>{0..<degree_aform X} - {i}.\n        e i *\\<^sub>R pdevs_apply (snd X) i) +\n     e i *\\<^sub>R pdevs_apply (snd X) i)", "."], ["proof (state)\nthis:\n  x =\n  fst X +\n  ((\\<Sum>i\\<in>{0..<degree_aform X} - {i}.\n      e i *\\<^sub>R pdevs_apply (snd X) i) +\n   e i *\\<^sub>R pdevs_apply (snd X) i)\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "hence \"x = aform_val (e(i:=2 * e i - 1)) (snd (split_aform X i))\"\n        \"x = aform_val (e(i:=2 * e i + 1)) (fst (split_aform X i))\""], ["proof (prove)\nusing this:\n  x =\n  fst X +\n  ((\\<Sum>i\\<in>{0..<degree_aform X} - {i}.\n      e i *\\<^sub>R pdevs_apply (snd X) i) +\n   e i *\\<^sub>R pdevs_apply (snd X) i)\n\ngoal (1 subgoal):\n 1. x = aform_val (e(i := 2 * e i - 1)) (snd (split_aform X i)) &&&\n    x = aform_val (e(i := 2 * e i + 1)) (fst (split_aform X i))", "by (auto simp: aform_val_def split_aform_def Let_def pdevs_val_sum atLeast0LessThan\n        Diff_eq degree_pdev_upd if_distrib sum.If_cases field_simps\n        scaleR_left_distrib[symmetric])"], ["proof (state)\nthis:\n  x = aform_val (e(i := 2 * e i - 1)) (snd (split_aform X i))\n  x = aform_val (e(i := 2 * e i + 1)) (fst (split_aform X i))\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "moreover"], ["proof (state)\nthis:\n  x = aform_val (e(i := 2 * e i - 1)) (snd (split_aform X i))\n  x = aform_val (e(i := 2 * e i + 1)) (fst (split_aform X i))\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "have \"2 * e i - 1 \\<in> {-1 .. 1} \\<or> 2 * e i + 1 \\<in> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * e i - 1 \\<in> {- 1..1} \\<or> 2 * e i + 1 \\<in> {- 1..1}", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  x = aform_val e X\n\ngoal (1 subgoal):\n 1. 2 * e i - 1 \\<in> {- 1..1} \\<or> 2 * e i + 1 \\<in> {- 1..1}", "by (auto simp: not_le Pi_iff dest!: spec[where x=i])"], ["proof (state)\nthis:\n  2 * e i - 1 \\<in> {- 1..1} \\<or> 2 * e i + 1 \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "ultimately"], ["proof (chain)\npicking this:\n  x = aform_val (e(i := 2 * e i - 1)) (snd (split_aform X i))\n  x = aform_val (e(i := 2 * e i + 1)) (fst (split_aform X i))\n  2 * e i - 1 \\<in> {- 1..1} \\<or> 2 * e i + 1 \\<in> {- 1..1}", "have ?thesis"], ["proof (prove)\nusing this:\n  x = aform_val (e(i := 2 * e i - 1)) (snd (split_aform X i))\n  x = aform_val (e(i := 2 * e i + 1)) (fst (split_aform X i))\n  2 * e i - 1 \\<in> {- 1..1} \\<or> 2 * e i + 1 \\<in> {- 1..1}\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "by blast"], ["proof (state)\nthis:\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "}"], ["proof (state)\nthis:\n  pdevs_apply (snd X) i \\<noteq> (0::'a) \\<Longrightarrow>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "ultimately"], ["proof (chain)\npicking this:\n  pdevs_apply (snd X) i = (0::'a) \\<Longrightarrow>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n  pdevs_apply (snd X) i \\<noteq> (0::'a) \\<Longrightarrow>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_apply (snd X) i = (0::'a) \\<Longrightarrow>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n  pdevs_apply (snd X) i \\<noteq> (0::'a) \\<Longrightarrow>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n\ngoal (1 subgoal):\n 1. (\\<exists>err.\n        x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n        err \\<in> {- 1..1}) \\<or>\n    (\\<exists>err.\n        x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n        err \\<in> {- 1..1})", "by blast"], ["proof (state)\nthis:\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (fst (split_aform X i)) \\<and>\n      err \\<in> {- 1..1}) \\<or>\n  (\\<exists>err.\n      x = aform_val (e(i := err)) (snd (split_aform X i)) \\<and>\n      err \\<in> {- 1..1})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_val_add: \"pdevs_val (\\<lambda>i. e i + f i) xs = pdevs_val e xs + pdevs_val f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>i. e i + f i) xs = pdevs_val e xs + pdevs_val f xs", "by (auto simp: pdevs_val_pdevs_domain algebra_simps sum.distrib)"], ["", "lemma pdevs_val_minus: \"pdevs_val (\\<lambda>i. e i - f i) xs = pdevs_val e xs - pdevs_val f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>i. e i - f i) xs = pdevs_val e xs - pdevs_val f xs", "by (auto simp: pdevs_val_pdevs_domain algebra_simps sum_subtractf)"], ["", "lemma pdevs_val_cmul: \"pdevs_val (\\<lambda>i. u * e i) xs = u *\\<^sub>R pdevs_val e xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>i. u * e i) xs = u *\\<^sub>R pdevs_val e xs", "by (auto simp: pdevs_val_pdevs_domain scaleR_sum_right)"], ["", "lemma atLeastAtMost_absI: \"- a \\<le> a \\<Longrightarrow> \\<bar>x::real\\<bar> \\<le> \\<bar>a\\<bar> \\<Longrightarrow> x \\<in> atLeastAtMost (- a) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- a \\<le> a; \\<bar>x\\<bar> \\<le> \\<bar>a\\<bar>\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {- a..a}", "by auto"], ["", "lemma divide_atLeastAtMost_1_absI: \"\\<bar>x::real\\<bar> \\<le> \\<bar>a\\<bar> \\<Longrightarrow> x/a \\<in> {-1 .. 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>a\\<bar> \\<Longrightarrow> x / a \\<in> {- 1..1}", "by (intro atLeastAtMost_absI) (auto simp: divide_le_eq_1)"], ["", "lemma convex_scaleR_aux: \"u + v = 1 \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R x = (x::'a::real_vector)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u + v = 1 \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R x = x", "by (metis scaleR_add_left scaleR_one)"], ["", "lemma convex_mult_aux: \"u + v = 1 \\<Longrightarrow> u * x + v * x = (x::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u + v = 1 \\<Longrightarrow> u * x + v * x = x", "using convex_scaleR_aux[of u v x]"], ["proof (prove)\nusing this:\n  u + v = 1 \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R x = x\n\ngoal (1 subgoal):\n 1. u + v = 1 \\<Longrightarrow> u * x + v * x = x", "by simp"], ["", "lemma convex_Affine: \"convex (Affine X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex (Affine X)", "proof (rule convexI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "fix x y::'a and u v::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "assume \"x \\<in> Affine X\" \"y \\<in> Affine X\" and convex: \"0 \\<le> u\" \"0 \\<le> v\" \"u + v = 1\""], ["proof (state)\nthis:\n  x \\<in> Affine X\n  y \\<in> Affine X\n  0 \\<le> u\n  0 \\<le> v\n  u + v = 1\n\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "then"], ["proof (chain)\npicking this:\n  x \\<in> Affine X\n  y \\<in> Affine X\n  0 \\<le> u\n  0 \\<le> v\n  u + v = 1", "obtain e f where x: \"x = aform_val e X\" \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n    and y: \"y = aform_val f X\" \"f \\<in> UNIV \\<rightarrow> {-1 .. 1}\""], ["proof (prove)\nusing this:\n  x \\<in> Affine X\n  y \\<in> Affine X\n  0 \\<le> u\n  0 \\<le> v\n  u + v = 1\n\ngoal (1 subgoal):\n 1. (\\<And>e f.\n        \\<lbrakk>x = aform_val e X; e \\<in> UNIV \\<rightarrow> {- 1..1};\n         y = aform_val f X; f \\<in> UNIV \\<rightarrow> {- 1..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Affine_def valuate_def)"], ["proof (state)\nthis:\n  x = aform_val e X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  y = aform_val f X\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "let ?conv = \"\\<lambda>i. u * e i + v * f i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "have \"\\<bar>?conv i\\<bar> \\<le> u * \\<bar>e i\\<bar> + v * \\<bar>f i\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>u * e i + v * f i\\<bar>\n    \\<le> u * \\<bar>e i\\<bar> + v * \\<bar>f i\\<bar>", "using convex"], ["proof (prove)\nusing this:\n  0 \\<le> u\n  0 \\<le> v\n  u + v = 1\n\ngoal (1 subgoal):\n 1. \\<bar>u * e i + v * f i\\<bar>\n    \\<le> u * \\<bar>e i\\<bar> + v * \\<bar>f i\\<bar>", "by (intro order_trans[OF abs_triangle_ineq]) (simp add: abs_mult)"], ["proof (state)\nthis:\n  \\<bar>u * e i + v * f i\\<bar>\n  \\<le> u * \\<bar>e i\\<bar> + v * \\<bar>f i\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "also"], ["proof (state)\nthis:\n  \\<bar>u * e i + v * f i\\<bar>\n  \\<le> u * \\<bar>e i\\<bar> + v * \\<bar>f i\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "have \"\\<dots> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u * \\<bar>e i\\<bar> + v * \\<bar>f i\\<bar> \\<le> 1", "using convex x y"], ["proof (prove)\nusing this:\n  0 \\<le> u\n  0 \\<le> v\n  u + v = 1\n  x = aform_val e X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  y = aform_val f X\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. u * \\<bar>e i\\<bar> + v * \\<bar>f i\\<bar> \\<le> 1", "by (intro convex_bound_le) (auto simp: Pi_iff abs_real_def)"], ["proof (state)\nthis:\n  u * \\<bar>e i\\<bar> + v * \\<bar>f i\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "finally"], ["proof (chain)\npicking this:\n  \\<bar>u * e i + v * f i\\<bar> \\<le> 1", "have \"?conv i \\<le> 1\" \"-1 \\<le> ?conv i\""], ["proof (prove)\nusing this:\n  \\<bar>u * e i + v * f i\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. u * e i + v * f i \\<le> 1 &&& - 1 \\<le> u * e i + v * f i", "by (auto simp: abs_real_def split: if_split_asm)"], ["proof (state)\nthis:\n  u * e i + v * f i \\<le> 1\n  - 1 \\<le> u * e i + v * f i\n\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "}"], ["proof (state)\nthis:\n  u * e ?i2 + v * f ?i2 \\<le> 1\n  - 1 \\<le> u * e ?i2 + v * f ?i2\n\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>x \\<in> Affine X; y \\<in> Affine X; 0 \\<le> u; 0 \\<le> v;\n        u + v = 1\\<rbrakk>\n       \\<Longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "thus \"u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X\""], ["proof (prove)\nusing this:\n  u * e ?i2 + v * f ?i2 \\<le> 1\n  - 1 \\<le> u * e ?i2 + v * f ?i2\n\ngoal (1 subgoal):\n 1. u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "using convex x y"], ["proof (prove)\nusing this:\n  u * e ?i2 + v * f ?i2 \\<le> 1\n  - 1 \\<le> u * e ?i2 + v * f ?i2\n  0 \\<le> u\n  0 \\<le> v\n  u + v = 1\n  x = aform_val e X\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  y = aform_val f X\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X", "by (auto simp: Affine_def valuate_def aform_val_def pdevs_val_add pdevs_val_cmul algebra_simps\n      convex_scaleR_aux intro!: image_eqI[where x=\"?conv\"])"], ["proof (state)\nthis:\n  u *\\<^sub>R x + v *\\<^sub>R y \\<in> Affine X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma segment_in_aform_val:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"f \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  shows \"closed_segment (aform_val e X) (aform_val f X) \\<subseteq> Affine X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment (aform_val e X) (aform_val f X) \\<subseteq> Affine X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_segment (aform_val e X) (aform_val f X) \\<subseteq> Affine X", "have \"aform_val e X \\<in> Affine X\" \"aform_val f X \\<in> Affine X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e X \\<in> Affine X &&& aform_val f X \\<in> Affine X", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n  f \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. aform_val e X \\<in> Affine X &&& aform_val f X \\<in> Affine X", "by (auto simp: Affine_def valuate_def)"], ["proof (state)\nthis:\n  aform_val e X \\<in> Affine X\n  aform_val f X \\<in> Affine X\n\ngoal (1 subgoal):\n 1. closed_segment (aform_val e X) (aform_val f X) \\<subseteq> Affine X", "with convex_Affine[of X, simplified convex_contains_segment]"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>Affine X.\n     \\<forall>b\\<in>Affine X. closed_segment a b \\<subseteq> Affine X\n  aform_val e X \\<in> Affine X\n  aform_val f X \\<in> Affine X", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>Affine X.\n     \\<forall>b\\<in>Affine X. closed_segment a b \\<subseteq> Affine X\n  aform_val e X \\<in> Affine X\n  aform_val f X \\<in> Affine X\n\ngoal (1 subgoal):\n 1. closed_segment (aform_val e X) (aform_val f X) \\<subseteq> Affine X", "by simp"], ["proof (state)\nthis:\n  closed_segment (aform_val e X) (aform_val f X) \\<subseteq> Affine X\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>From List of Generators\\<close>"], ["", "lift_definition pdevs_of_list::\"'a::zero list \\<Rightarrow> 'a pdevs\"\n  is \"\\<lambda>xs i. if i < length xs then xs ! i else 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       finite\n        {i. (if i < length list then list ! i else (0::'a)) \\<noteq>\n            (0::'a)}", "by auto"], ["", "lemma pdevs_apply_pdevs_of_list:\n  \"pdevs_apply (pdevs_of_list xs) i = (if i < length xs then xs ! i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (pdevs_of_list xs) i =\n    (if i < length xs then xs ! i else (0::'a))", "by transfer simp"], ["", "lemma pdevs_apply_pdevs_of_list_Nil[simp]:\n  \"pdevs_apply (pdevs_of_list []) i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (pdevs_of_list []) i = (0::'a)", "by transfer auto"], ["", "lemma pdevs_apply_pdevs_of_list_Cons:\n  \"pdevs_apply (pdevs_of_list (x # xs)) i =\n    (if i = 0 then x else pdevs_apply (pdevs_of_list xs) (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (pdevs_of_list (x # xs)) i =\n    (if i = 0 then x else pdevs_apply (pdevs_of_list xs) (i - 1))", "by transfer auto"], ["", "lemma pdevs_domain_pdevs_of_list_Cons[simp]: \"pdevs_domain (pdevs_of_list (x # xs)) =\n  (if x = 0 then {} else {0}) \\<union> (+) 1 ` pdevs_domain (pdevs_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain (pdevs_of_list (x # xs)) =\n    (if x = (0::'a) then {} else {0}) \\<union>\n    (+) 1 ` pdevs_domain (pdevs_of_list xs)", "by (force simp: pdevs_apply_pdevs_of_list_Cons split: if_split_asm)"], ["", "lemma pdevs_val_pdevs_of_list_eq[simp]:\n  \"pdevs_val e (pdevs_of_list (x # xs)) = e 0 *\\<^sub>R x + pdevs_val (e o (+) 1) (pdevs_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "have \"pdevs_val e (pdevs_of_list (x # xs)) =\n    (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> {0}. e i *\\<^sub>R x) +\n    (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> - {0}.\n      e i *\\<^sub>R pdevs_apply (pdevs_of_list xs) (i - Suc 0))\"\n    (is \"_ = ?l + ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> {0}.\n       e i *\\<^sub>R x) +\n    (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> - {0}.\n       e i *\\<^sub>R pdevs_apply (pdevs_of_list xs) (i - Suc 0))", "by (simp add: pdevs_val_pdevs_domain if_distrib sum.If_cases pdevs_apply_pdevs_of_list_Cons)"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> {0}.\n     e i *\\<^sub>R x) +\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> - {0}.\n     e i *\\<^sub>R pdevs_apply (pdevs_of_list xs) (i - Suc 0))\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> {0}.\n     e i *\\<^sub>R x) +\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> - {0}.\n     e i *\\<^sub>R pdevs_apply (pdevs_of_list xs) (i - Suc 0))\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "have \"?r = (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list xs). e (Suc i) *\\<^sub>R pdevs_apply (pdevs_of_list xs) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> - {0}.\n       e i *\\<^sub>R pdevs_apply (pdevs_of_list xs) (i - Suc 0)) =\n    (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list xs).\n       e (Suc i) *\\<^sub>R pdevs_apply (pdevs_of_list xs) i)", "by (rule sum.reindex_cong[of \"\\<lambda>i. i + 1\"]) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> - {0}.\n     e i *\\<^sub>R pdevs_apply (pdevs_of_list xs) (i - Suc 0)) =\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list xs).\n     e (Suc i) *\\<^sub>R pdevs_apply (pdevs_of_list xs) i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> - {0}.\n     e i *\\<^sub>R pdevs_apply (pdevs_of_list xs) (i - Suc 0)) =\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list xs).\n     e (Suc i) *\\<^sub>R pdevs_apply (pdevs_of_list xs) i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "have \"\\<dots> = pdevs_val (e o (+) 1) (pdevs_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list xs).\n       e (Suc i) *\\<^sub>R pdevs_apply (pdevs_of_list xs) i) =\n    pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "by (simp add: pdevs_val_pdevs_domain  )"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list xs).\n     e (Suc i) *\\<^sub>R pdevs_apply (pdevs_of_list xs) i) =\n  pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list xs).\n     e (Suc i) *\\<^sub>R pdevs_apply (pdevs_of_list xs) i) =\n  pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "have \"?l = (\\<Sum>i\\<in>{0}. e i *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> {0}.\n       e i *\\<^sub>R x) =\n    (\\<Sum>i\\<in>{0}. e i *\\<^sub>R x)", "by (rule sum.mono_neutral_cong_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> {0}.\n     e i *\\<^sub>R x) =\n  (\\<Sum>i\\<in>{0}. e i *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain (pdevs_of_list (x # xs)) \\<inter> {0}.\n     e i *\\<^sub>R x) =\n  (\\<Sum>i\\<in>{0}. e i *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "have \"\\<dots> = e 0 *\\<^sub>R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{0}. e i *\\<^sub>R x) = e 0 *\\<^sub>R x", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{0}. e i *\\<^sub>R x) = e 0 *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (x # xs)) =\n    e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)", "."], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (x # xs)) =\n  e 0 *\\<^sub>R x + pdevs_val (e \\<circ> (+) 1) (pdevs_of_list xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  less_degree_pdevs_of_list_imp_less_length:\n  assumes \"i < degree (pdevs_of_list xs)\"\n  shows \"i < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length xs", "from assms"], ["proof (chain)\npicking this:\n  i < degree (pdevs_of_list xs)", "have \"pdevs_apply (pdevs_of_list xs) (degree (pdevs_of_list xs) - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i < degree (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. pdevs_apply (pdevs_of_list xs) (degree (pdevs_of_list xs) - 1) \\<noteq>\n    (0::'a)", "by (metis degree_least_nonzero less_nat_zero_code)"], ["proof (state)\nthis:\n  pdevs_apply (pdevs_of_list xs) (degree (pdevs_of_list xs) - 1) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. i < length xs", "hence \"degree (pdevs_of_list xs) - 1 < length xs\""], ["proof (prove)\nusing this:\n  pdevs_apply (pdevs_of_list xs) (degree (pdevs_of_list xs) - 1) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. degree (pdevs_of_list xs) - 1 < length xs", "by (simp add: pdevs_apply_pdevs_of_list split: if_split_asm)"], ["proof (state)\nthis:\n  degree (pdevs_of_list xs) - 1 < length xs\n\ngoal (1 subgoal):\n 1. i < length xs", "with assms"], ["proof (chain)\npicking this:\n  i < degree (pdevs_of_list xs)\n  degree (pdevs_of_list xs) - 1 < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  i < degree (pdevs_of_list xs)\n  degree (pdevs_of_list xs) - 1 < length xs\n\ngoal (1 subgoal):\n 1. i < length xs", "by simp"], ["proof (state)\nthis:\n  i < length xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tdev_pdevs_of_list[simp]: \"tdev (pdevs_of_list xs) = sum_list (map abs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev (pdevs_of_list xs) = sum_list (map abs xs)", "by (auto simp: tdev_def pdevs_apply_pdevs_of_list sum_list_sum_nth\n    less_degree_pdevs_of_list_imp_less_length\n    intro!: sum.mono_neutral_cong_left degree_gt)"], ["", "lemma pdevs_of_list_Nil[simp]: \"pdevs_of_list [] = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_list [] = zero_pdevs", "by (auto intro!: pdevs_eqI)"], ["", "lemma pdevs_val_inj_sumI:\n  fixes K::\"'a set\" and g::\"'a \\<Rightarrow> nat\"\n  assumes \"finite K\"\n  assumes \"inj_on g K\"\n  assumes \"pdevs_domain x \\<subseteq> g ` K\"\n  assumes \"\\<And>i. i \\<in> K \\<Longrightarrow> g i \\<notin> pdevs_domain x \\<Longrightarrow> f i = 0\"\n  assumes \"\\<And>i. i \\<in> K \\<Longrightarrow> g i \\<in> pdevs_domain x \\<Longrightarrow> f i = e (g i) *\\<^sub>R pdevs_apply x (g i)\"\n  shows \"pdevs_val e x = (\\<Sum>i\\<in>K. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "have [simp]: \"inj_on (the_inv_into K g) (pdevs_domain x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (the_inv_into K g) (pdevs_domain x)", "using assms"], ["proof (prove)\nusing this:\n  finite K\n  inj_on g K\n  pdevs_domain x \\<subseteq> g ` K\n  \\<lbrakk>?i \\<in> K; g ?i \\<notin> pdevs_domain x\\<rbrakk>\n  \\<Longrightarrow> f ?i = (0::'b)\n  \\<lbrakk>?i \\<in> K; g ?i \\<in> pdevs_domain x\\<rbrakk>\n  \\<Longrightarrow> f ?i = e (g ?i) *\\<^sub>R pdevs_apply x (g ?i)\n\ngoal (1 subgoal):\n 1. inj_on (the_inv_into K g) (pdevs_domain x)", "by (auto simp: intro!: subset_inj_on[OF inj_on_the_inv_into])"], ["proof (state)\nthis:\n  inj_on (the_inv_into K g) (pdevs_domain x)\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "{"], ["proof (state)\nthis:\n  inj_on (the_inv_into K g) (pdevs_domain x)\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "assume y: \"y \\<in> pdevs_domain x\""], ["proof (state)\nthis:\n  y \\<in> pdevs_domain x\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "have g_inv: \"g (the_inv_into K g y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (the_inv_into K g y) = y", "by (meson assms(2) assms(3) y f_the_inv_into_f subset_eq)"], ["proof (state)\nthis:\n  g (the_inv_into K g y) = y\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "have inv_in: \"the_inv_into K g y \\<in> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv_into K g y \\<in> K", "by (meson assms(2) assms(3) y subset_iff in_pdevs_domain the_inv_into_into)"], ["proof (state)\nthis:\n  the_inv_into K g y \\<in> K\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "have inv3: \"the_inv_into (pdevs_domain x) (the_inv_into K g) (the_inv_into K g y) =\n        g (the_inv_into K g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv_into (pdevs_domain x) (the_inv_into K g) (the_inv_into K g y) =\n    g (the_inv_into K g y)", "using assms y"], ["proof (prove)\nusing this:\n  finite K\n  inj_on g K\n  pdevs_domain x \\<subseteq> g ` K\n  \\<lbrakk>?i \\<in> K; g ?i \\<notin> pdevs_domain x\\<rbrakk>\n  \\<Longrightarrow> f ?i = (0::'b)\n  \\<lbrakk>?i \\<in> K; g ?i \\<in> pdevs_domain x\\<rbrakk>\n  \\<Longrightarrow> f ?i = e (g ?i) *\\<^sub>R pdevs_apply x (g ?i)\n  y \\<in> pdevs_domain x\n\ngoal (1 subgoal):\n 1. the_inv_into (pdevs_domain x) (the_inv_into K g) (the_inv_into K g y) =\n    g (the_inv_into K g y)", "by (subst the_inv_into_f_f) (auto simp: f_the_inv_into_f[OF assms(2)])"], ["proof (state)\nthis:\n  the_inv_into (pdevs_domain x) (the_inv_into K g) (the_inv_into K g y) =\n  g (the_inv_into K g y)\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "note g_inv inv_in inv3"], ["proof (state)\nthis:\n  g (the_inv_into K g y) = y\n  the_inv_into K g y \\<in> K\n  the_inv_into (pdevs_domain x) (the_inv_into K g) (the_inv_into K g y) =\n  g (the_inv_into K g y)\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> pdevs_domain x \\<Longrightarrow> g (the_inv_into K g ?y2) = ?y2\n  ?y2 \\<in> pdevs_domain x \\<Longrightarrow> the_inv_into K g ?y2 \\<in> K\n  ?y2 \\<in> pdevs_domain x \\<Longrightarrow>\n  the_inv_into (pdevs_domain x) (the_inv_into K g) (the_inv_into K g ?y2) =\n  g (the_inv_into K g ?y2)\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "note this[simp]"], ["proof (state)\nthis:\n  ?y2 \\<in> pdevs_domain x \\<Longrightarrow> g (the_inv_into K g ?y2) = ?y2\n  ?y2 \\<in> pdevs_domain x \\<Longrightarrow> the_inv_into K g ?y2 \\<in> K\n  ?y2 \\<in> pdevs_domain x \\<Longrightarrow>\n  the_inv_into (pdevs_domain x) (the_inv_into K g) (the_inv_into K g ?y2) =\n  g (the_inv_into K g ?y2)\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "have \"pdevs_val e x = (\\<Sum>i\\<in>pdevs_domain x. e i *\\<^sub>R pdevs_apply x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e x =\n    (\\<Sum>i\\<in>pdevs_domain x. e i *\\<^sub>R pdevs_apply x i)", "by (simp add: pdevs_val_pdevs_domain)"], ["proof (state)\nthis:\n  pdevs_val e x =\n  (\\<Sum>i\\<in>pdevs_domain x. e i *\\<^sub>R pdevs_apply x i)\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "also"], ["proof (state)\nthis:\n  pdevs_val e x =\n  (\\<Sum>i\\<in>pdevs_domain x. e i *\\<^sub>R pdevs_apply x i)\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "have \"\\<dots> = (\\<Sum>i \\<in> the_inv_into K g ` pdevs_domain x. e (g i) *\\<^sub>R pdevs_apply x (g i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>pdevs_domain x. e i *\\<^sub>R pdevs_apply x i) =\n    (\\<Sum>i\\<in>the_inv_into K g ` pdevs_domain x.\n       e (g i) *\\<^sub>R pdevs_apply x (g i))", "by (rule sum.reindex_cong[OF inj_on_the_inv_into]) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain x. e i *\\<^sub>R pdevs_apply x i) =\n  (\\<Sum>i\\<in>the_inv_into K g ` pdevs_domain x.\n     e (g i) *\\<^sub>R pdevs_apply x (g i))\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain x. e i *\\<^sub>R pdevs_apply x i) =\n  (\\<Sum>i\\<in>the_inv_into K g ` pdevs_domain x.\n     e (g i) *\\<^sub>R pdevs_apply x (g i))\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "have \"\\<dots> = (\\<Sum>i\\<in>K. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>the_inv_into K g ` pdevs_domain x.\n       e (g i) *\\<^sub>R pdevs_apply x (g i)) =\n    sum f K", "using assms"], ["proof (prove)\nusing this:\n  finite K\n  inj_on g K\n  pdevs_domain x \\<subseteq> g ` K\n  \\<lbrakk>?i \\<in> K; g ?i \\<notin> pdevs_domain x\\<rbrakk>\n  \\<Longrightarrow> f ?i = (0::'b)\n  \\<lbrakk>?i \\<in> K; g ?i \\<in> pdevs_domain x\\<rbrakk>\n  \\<Longrightarrow> f ?i = e (g ?i) *\\<^sub>R pdevs_apply x (g ?i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>the_inv_into K g ` pdevs_domain x.\n       e (g i) *\\<^sub>R pdevs_apply x (g i)) =\n    sum f K", "by (intro sum.mono_neutral_cong_left) (auto simp: the_inv_into_image_eq)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>the_inv_into K g ` pdevs_domain x.\n     e (g i) *\\<^sub>R pdevs_apply x (g i)) =\n  sum f K\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e x = sum f K", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_val e x = sum f K\n\ngoal (1 subgoal):\n 1. pdevs_val e x = sum f K", "."], ["proof (state)\nthis:\n  pdevs_val e x = sum f K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_domain_pdevs_of_list_le: \"pdevs_domain (pdevs_of_list xs) \\<subseteq> {0..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain (pdevs_of_list xs) \\<subseteq> {0..<length xs}", "by (auto simp: pdevs_apply_pdevs_of_list split: if_split_asm)"], ["", "lemma pdevs_val_zip: \"pdevs_val e (pdevs_of_list xs) = (\\<Sum>(i,x)\\<leftarrow>zip [0..<length xs] xs. e i *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list xs) =\n    sum_list (map2 (\\<lambda>i. (*\\<^sub>R) (e i)) [0..<length xs] xs)", "by (auto simp: sum_list_distinct_conv_sum_set\n    in_set_zip image_fst_zip pdevs_apply_pdevs_of_list distinct_zipI1\n    intro!: pdevs_val_inj_sumI[of _ fst]\n    split: if_split_asm)"], ["", "lemma scaleR_sum_list:\n  fixes xs::\"'a::real_vector list\"\n  shows \"a *\\<^sub>R sum_list xs = sum_list (map (scaleR a) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>R sum_list xs = sum_list (map ((*\\<^sub>R) a) xs)", "by (induct xs) (auto simp: algebra_simps)"], ["", "lemma pdevs_val_const_pdevs_of_list: \"pdevs_val (\\<lambda>_. c) (pdevs_of_list xs) = c *\\<^sub>R sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>_. c) (pdevs_of_list xs) = c *\\<^sub>R sum_list xs", "unfolding pdevs_val_zip split_beta' scaleR_sum_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>zip [0..<length xs] xs. c *\\<^sub>R snd x) =\n    sum_list (map ((*\\<^sub>R) c) xs)", "by (rule arg_cong) (auto intro!: nth_equalityI)"], ["", "lemma pdevs_val_partition:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains f g where \"pdevs_val e (pdevs_of_list xs) =\n    pdevs_val f (pdevs_of_list (filter p xs)) +\n    pdevs_val g (pdevs_of_list (filter (Not o p) xs))\"\n    \"f \\<in> UNIV \\<rightarrow> I\"\n    \"g \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>pdevs_val e (pdevs_of_list xs) =\n                 pdevs_val f (pdevs_of_list (filter p xs)) +\n                 pdevs_val g (pdevs_of_list (filter (Not \\<circ> p) xs));\n         f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>pdevs_val e (pdevs_of_list xs) =\n                 pdevs_val f (pdevs_of_list (filter p xs)) +\n                 pdevs_val g (pdevs_of_list (filter (Not \\<circ> p) xs));\n         f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain i where i: \"i \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> I \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis assms funcset_mem iso_tuple_UNIV_I)"], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>pdevs_val e (pdevs_of_list xs) =\n                 pdevs_val f (pdevs_of_list (filter p xs)) +\n                 pdevs_val g (pdevs_of_list (filter (Not \\<circ> p) xs));\n         f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?zip = \"zip [0..<length xs] xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>pdevs_val e (pdevs_of_list xs) =\n                 pdevs_val f (pdevs_of_list (filter p xs)) +\n                 pdevs_val g (pdevs_of_list (filter (Not \\<circ> p) xs));\n         f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define part where \"part = partition (p \\<circ> snd) ?zip\""], ["proof (state)\nthis:\n  part = partition (p \\<circ> snd) (zip [0..<length xs] xs)\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>pdevs_val e (pdevs_of_list xs) =\n                 pdevs_val f (pdevs_of_list (filter p xs)) +\n                 pdevs_val g (pdevs_of_list (filter (Not \\<circ> p) xs));\n         f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f =\n    \"(\\<lambda>n. if n < degree (pdevs_of_list (filter p xs)) then e (map fst (fst part) ! n) else i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>pdevs_val e (pdevs_of_list xs) =\n                 pdevs_val f (pdevs_of_list (filter p xs)) +\n                 pdevs_val g (pdevs_of_list (filter (Not \\<circ> p) xs));\n         f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?g =\n    \"(\\<lambda>n. if n < degree (pdevs_of_list (filter (Not \\<circ> p) xs))\n      then e (map fst (snd part) ! n)\n      else i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>pdevs_val e (pdevs_of_list xs) =\n                 pdevs_val f (pdevs_of_list (filter p xs)) +\n                 pdevs_val g (pdevs_of_list (filter (Not \\<circ> p) xs));\n         f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"pdevs_val e (pdevs_of_list xs) = (\\<Sum>(i,x)\\<leftarrow>?zip. e i *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list xs) =\n    sum_list (map2 (\\<lambda>i. (*\\<^sub>R) (e i)) [0..<length xs] xs)", "by (rule pdevs_val_zip)"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list xs) =\n  sum_list (map2 (\\<lambda>i. (*\\<^sub>R) (e i)) [0..<length xs] xs)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list xs) =\n  sum_list (map2 (\\<lambda>i. (*\\<^sub>R) (e i)) [0..<length xs] xs)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"\\<dots> = (\\<Sum>(i, x)\\<in>set ?zip. e i *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (\\<lambda>i. (*\\<^sub>R) (e i)) [0..<length xs] xs) =\n    (\\<Sum>(i, x)\\<in>set (zip [0..<length xs] xs). e i *\\<^sub>R x)", "by (simp add: sum_list_distinct_conv_sum_set distinct_zipI1)"], ["proof (state)\nthis:\n  sum_list (map2 (\\<lambda>i. (*\\<^sub>R) (e i)) [0..<length xs] xs) =\n  (\\<Sum>(i, x)\\<in>set (zip [0..<length xs] xs). e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  sum_list (map2 (\\<lambda>i. (*\\<^sub>R) (e i)) [0..<length xs] xs) =\n  (\\<Sum>(i, x)\\<in>set (zip [0..<length xs] xs). e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have [simp]: \"set (fst part) \\<inter> set (snd part) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst part) \\<inter> set (snd part) = {}", "by (auto simp: part_def)"], ["proof (state)\nthis:\n  set (fst part) \\<inter> set (snd part) = {}\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "from partition_set[of \"p o snd\" ?zip \"fst part\" \"snd part\"]"], ["proof (chain)\npicking this:\n  partition (p \\<circ> snd) (zip [0..<length xs] xs) =\n  (fst part, snd part) \\<Longrightarrow>\n  set (fst part) \\<union> set (snd part) = set (zip [0..<length xs] xs)", "have \"set ?zip = set (fst part) \\<union> set (snd part)\""], ["proof (prove)\nusing this:\n  partition (p \\<circ> snd) (zip [0..<length xs] xs) =\n  (fst part, snd part) \\<Longrightarrow>\n  set (fst part) \\<union> set (snd part) = set (zip [0..<length xs] xs)\n\ngoal (1 subgoal):\n 1. set (zip [0..<length xs] xs) = set (fst part) \\<union> set (snd part)", "by (auto simp: part_def)"], ["proof (state)\nthis:\n  set (zip [0..<length xs] xs) = set (fst part) \\<union> set (snd part)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  set (zip [0..<length xs] xs) = set (fst part) \\<union> set (snd part)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"(\\<Sum>a\\<in>set (fst part) \\<union> set (snd part). case a of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n        (\\<Sum>(i, x)\\<in>set (fst part). e i *\\<^sub>R x) + (\\<Sum>(i, x)\\<in>set (snd part). e i *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>set (fst part) \\<union> set (snd part).\n       case a of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n    (\\<Sum>(i, x)\\<in>set (fst part). e i *\\<^sub>R x) +\n    (\\<Sum>(i, x)\\<in>set (snd part). e i *\\<^sub>R x)", "by (auto simp: split_beta sum_Un)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>set (fst part) \\<union> set (snd part).\n     case a of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n  (\\<Sum>(i, x)\\<in>set (fst part). e i *\\<^sub>R x) +\n  (\\<Sum>(i, x)\\<in>set (snd part). e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>set (fst part) \\<union> set (snd part).\n     case a of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n  (\\<Sum>(i, x)\\<in>set (fst part). e i *\\<^sub>R x) +\n  (\\<Sum>(i, x)\\<in>set (snd part). e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"(\\<Sum>(i, x)\\<in>set (fst part). e i *\\<^sub>R x) = (\\<Sum>(i, x)\\<leftarrow>(fst part). e i *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, x)\\<in>set (fst part). e i *\\<^sub>R x) =\n    (\\<Sum>(i, x)\\<leftarrow>fst part. e i *\\<^sub>R x)", "by (simp add: sum_list_distinct_conv_sum_set distinct_zipI1 part_def)"], ["proof (state)\nthis:\n  (\\<Sum>(i, x)\\<in>set (fst part). e i *\\<^sub>R x) =\n  (\\<Sum>(i, x)\\<leftarrow>fst part. e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, x)\\<in>set (fst part). e i *\\<^sub>R x) =\n  (\\<Sum>(i, x)\\<leftarrow>fst part. e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"\\<dots> = (\\<Sum>i<length (fst part). case (fst part ! i) of (i, x) \\<Rightarrow> e i *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, x)\\<leftarrow>fst part. e i *\\<^sub>R x) =\n    (\\<Sum>i<length (fst part).\n        case fst part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x)", "by (subst sum_list_sum_nth) (simp add: split_beta' atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Sum>(i, x)\\<leftarrow>fst part. e i *\\<^sub>R x) =\n  (\\<Sum>i<length (fst part).\n      case fst part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, x)\\<leftarrow>fst part. e i *\\<^sub>R x) =\n  (\\<Sum>i<length (fst part).\n      case fst part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"\\<dots> =\n      pdevs_val (\\<lambda>n. e (map fst (fst part) ! n)) (pdevs_of_list (map snd (fst part)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (fst part).\n        case fst part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n    pdevs_val (\\<lambda>n. e (map fst (fst part) ! n))\n     (pdevs_of_list (map snd (fst part)))", "by (force\n        simp: pdevs_val_zip sum_list_distinct_conv_sum_set distinct_zipI1 split_beta' in_set_zip\n        intro!:\n          sum.reindex_cong[where l=fst] image_eqI[where x = \"(x, map snd (fst part) ! x)\" for x])"], ["proof (state)\nthis:\n  (\\<Sum>i<length (fst part).\n      case fst part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n  pdevs_val (\\<lambda>n. e (map fst (fst part) ! n))\n   (pdevs_of_list (map snd (fst part)))\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length (fst part).\n      case fst part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n  pdevs_val (\\<lambda>n. e (map fst (fst part) ! n))\n   (pdevs_of_list (map snd (fst part)))\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"(\\<Sum>(i, x)\\<in>set (snd part). e i *\\<^sub>R x) = (\\<Sum>(i, x)\\<leftarrow>(snd part). e i *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, x)\\<in>set (snd part). e i *\\<^sub>R x) =\n    (\\<Sum>(i, x)\\<leftarrow>snd part. e i *\\<^sub>R x)", "by (simp add: sum_list_distinct_conv_sum_set distinct_zipI1 part_def)"], ["proof (state)\nthis:\n  (\\<Sum>(i, x)\\<in>set (snd part). e i *\\<^sub>R x) =\n  (\\<Sum>(i, x)\\<leftarrow>snd part. e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, x)\\<in>set (snd part). e i *\\<^sub>R x) =\n  (\\<Sum>(i, x)\\<leftarrow>snd part. e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"\\<dots> = (\\<Sum>i<length (snd part). case (snd part ! i) of (i, x) \\<Rightarrow> e i *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, x)\\<leftarrow>snd part. e i *\\<^sub>R x) =\n    (\\<Sum>i<length (snd part).\n        case snd part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x)", "by (subst sum_list_sum_nth) (simp add: split_beta' atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Sum>(i, x)\\<leftarrow>snd part. e i *\\<^sub>R x) =\n  (\\<Sum>i<length (snd part).\n      case snd part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, x)\\<leftarrow>snd part. e i *\\<^sub>R x) =\n  (\\<Sum>i<length (snd part).\n      case snd part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x)\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"\\<dots> =\n      pdevs_val (\\<lambda>n. e (map fst (snd part) ! n)) (pdevs_of_list (map snd (snd part)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (snd part).\n        case snd part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n    pdevs_val (\\<lambda>n. e (map fst (snd part) ! n))\n     (pdevs_of_list (map snd (snd part)))", "by (force simp: pdevs_val_zip sum_list_distinct_conv_sum_set distinct_zipI1 split_beta'\n        in_set_zip\n        intro!: sum.reindex_cong[where l=fst]\n          image_eqI[where x = \"(x, map snd (snd part) ! x)\" for x])"], ["proof (state)\nthis:\n  (\\<Sum>i<length (snd part).\n      case snd part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n  pdevs_val (\\<lambda>n. e (map fst (snd part) ! n))\n   (pdevs_of_list (map snd (snd part)))\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length (snd part).\n      case snd part ! i of (i, x) \\<Rightarrow> e i *\\<^sub>R x) =\n  pdevs_val (\\<lambda>n. e (map fst (snd part) ! n))\n   (pdevs_of_list (map snd (snd part)))\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"pdevs_val (\\<lambda>n. e (map fst (fst part) ! n)) (pdevs_of_list (map snd (fst part))) =\n      pdevs_val (\\<lambda>n.\n          if n < degree (pdevs_of_list (map snd (fst part))) then e (map fst (fst part) ! n) else i)\n        (pdevs_of_list (map snd (fst part)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>n. e (map fst (fst part) ! n))\n     (pdevs_of_list (map snd (fst part))) =\n    pdevs_val\n     (\\<lambda>n.\n         if n < degree (pdevs_of_list (map snd (fst part)))\n         then e (map fst (fst part) ! n) else i)\n     (pdevs_of_list (map snd (fst part)))", "by (rule pdevs_val_degree_cong) simp_all"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>n. e (map fst (fst part) ! n))\n   (pdevs_of_list (map snd (fst part))) =\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (map snd (fst part)))\n       then e (map fst (fst part) ! n) else i)\n   (pdevs_of_list (map snd (fst part)))\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>n. e (map fst (fst part) ! n))\n   (pdevs_of_list (map snd (fst part))) =\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (map snd (fst part)))\n       then e (map fst (fst part) ! n) else i)\n   (pdevs_of_list (map snd (fst part)))\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"pdevs_val (\\<lambda>n. e (map fst (snd part) ! n)) (pdevs_of_list (map snd (snd part))) =\n      pdevs_val (\\<lambda>n.\n          if n < degree (pdevs_of_list (map snd (snd part))) then e (map fst (snd part) ! n) else i)\n        (pdevs_of_list (map snd (snd part)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>n. e (map fst (snd part) ! n))\n     (pdevs_of_list (map snd (snd part))) =\n    pdevs_val\n     (\\<lambda>n.\n         if n < degree (pdevs_of_list (map snd (snd part)))\n         then e (map fst (snd part) ! n) else i)\n     (pdevs_of_list (map snd (snd part)))", "by (rule pdevs_val_degree_cong) simp_all"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>n. e (map fst (snd part) ! n))\n   (pdevs_of_list (map snd (snd part))) =\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (map snd (snd part)))\n       then e (map fst (snd part) ! n) else i)\n   (pdevs_of_list (map snd (snd part)))\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>n. e (map fst (snd part) ! n))\n   (pdevs_of_list (map snd (snd part))) =\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (map snd (snd part)))\n       then e (map fst (snd part) ! n) else i)\n   (pdevs_of_list (map snd (snd part)))\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"map snd (snd part) = filter (Not o p) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (snd part) = filter (Not \\<circ> p) xs", "by (simp add: part_def filter_map[symmetric] o_assoc)"], ["proof (state)\nthis:\n  map snd (snd part) = filter (Not \\<circ> p) xs\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "also"], ["proof (state)\nthis:\n  map snd (snd part) = filter (Not \\<circ> p) xs\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "have \"map snd (fst part) = filter p xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (fst part) = filter p xs", "by (simp add: part_def filter_map[symmetric])"], ["proof (state)\nthis:\n  map snd (fst part) = filter p xs\n\ngoal (3 subgoals):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val ?f (pdevs_of_list (filter p xs)) +\n    pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\n 2. ?f \\<in> UNIV \\<rightarrow> I\n 3. ?g \\<in> UNIV \\<rightarrow> I", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list xs) =\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (filter p xs))\n       then e (map fst (fst part) ! n) else i)\n   (pdevs_of_list (filter p xs)) +\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (filter (Not \\<circ> p) xs))\n       then e (map fst (snd part) ! n) else i)\n   (pdevs_of_list (filter (Not \\<circ> p) xs))", "show\n      \"pdevs_val e (pdevs_of_list xs) =\n        pdevs_val ?f (pdevs_of_list (filter p xs)) +\n        pdevs_val ?g (pdevs_of_list (filter (Not \\<circ> p) xs))\""], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list xs) =\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (filter p xs))\n       then e (map fst (fst part) ! n) else i)\n   (pdevs_of_list (filter p xs)) +\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (filter (Not \\<circ> p) xs))\n       then e (map fst (snd part) ! n) else i)\n   (pdevs_of_list (filter (Not \\<circ> p) xs))\n\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list xs) =\n    pdevs_val\n     (\\<lambda>n.\n         if n < degree (pdevs_of_list (filter p xs))\n         then e (map fst (fst part) ! n) else i)\n     (pdevs_of_list (filter p xs)) +\n    pdevs_val\n     (\\<lambda>n.\n         if n < degree (pdevs_of_list (filter (Not \\<circ> p) xs))\n         then e (map fst (snd part) ! n) else i)\n     (pdevs_of_list (filter (Not \\<circ> p) xs))", "."], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list xs) =\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (filter p xs))\n       then e (map fst (fst part) ! n) else i)\n   (pdevs_of_list (filter p xs)) +\n  pdevs_val\n   (\\<lambda>n.\n       if n < degree (pdevs_of_list (filter (Not \\<circ> p) xs))\n       then e (map fst (snd part) ! n) else i)\n   (pdevs_of_list (filter (Not \\<circ> p) xs))\n\ngoal (2 subgoals):\n 1. (\\<lambda>n.\n        if n < degree (pdevs_of_list (filter p xs))\n        then e (map fst (fst part) ! n) else i)\n    \\<in> UNIV \\<rightarrow> I\n 2. (\\<lambda>n.\n        if n < degree (pdevs_of_list (filter (Not \\<circ> p) xs))\n        then e (map fst (snd part) ! n) else i)\n    \\<in> UNIV \\<rightarrow> I", "show \"?f \\<in> UNIV \\<rightarrow> I\" \"?g \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        if n < degree (pdevs_of_list (filter p xs))\n        then e (map fst (fst part) ! n) else i)\n    \\<in> UNIV \\<rightarrow> I &&&\n    (\\<lambda>n.\n        if n < degree (pdevs_of_list (filter (Not \\<circ> p) xs))\n        then e (map fst (snd part) ! n) else i)\n    \\<in> UNIV \\<rightarrow> I", "using assms \\<open>i\\<in>I\\<close>"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> I\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        if n < degree (pdevs_of_list (filter p xs))\n        then e (map fst (fst part) ! n) else i)\n    \\<in> UNIV \\<rightarrow> I &&&\n    (\\<lambda>n.\n        if n < degree (pdevs_of_list (filter (Not \\<circ> p) xs))\n        then e (map fst (snd part) ! n) else i)\n    \\<in> UNIV \\<rightarrow> I", "by (auto simp: Pi_iff)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      if n < degree (pdevs_of_list (filter p xs))\n      then e (map fst (fst part) ! n) else i)\n  \\<in> UNIV \\<rightarrow> I\n  (\\<lambda>n.\n      if n < degree (pdevs_of_list (filter (Not \\<circ> p) xs))\n      then e (map fst (snd part) ! n) else i)\n  \\<in> UNIV \\<rightarrow> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_apply_pdevs_of_list_append:\n  \"pdevs_apply (pdevs_of_list (xs @ zs)) i =\n    (if i < length xs\n    then pdevs_apply (pdevs_of_list xs) i else pdevs_apply (pdevs_of_list zs) (i - length xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (pdevs_of_list (xs @ zs)) i =\n    (if i < length xs then pdevs_apply (pdevs_of_list xs) i\n     else pdevs_apply (pdevs_of_list zs) (i - length xs))", "by (auto simp: pdevs_apply_pdevs_of_list nth_append)"], ["", "lemma degree_pdevs_of_list_le_length[intro, simp]: \"degree (pdevs_of_list xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pdevs_of_list xs) \\<le> length xs", "by (metis less_irrefl_nat le_less_linear less_degree_pdevs_of_list_imp_less_length)"], ["", "lemma degree_pdevs_of_list_append:\n  \"degree (pdevs_of_list (xs @ ys)) \\<le> length xs + degree (pdevs_of_list ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pdevs_of_list (xs @ ys))\n    \\<le> length xs + degree (pdevs_of_list ys)", "by (rule degree_le) (auto simp: pdevs_apply_pdevs_of_list_append)"], ["", "lemma pdevs_val_pdevs_of_list_append:\n  assumes \"f \\<in> UNIV \\<rightarrow> I\"\n  assumes \"g \\<in> UNIV \\<rightarrow> I\"\n  obtains e where\n    \"pdevs_val f (pdevs_of_list xs) + pdevs_val g (pdevs_of_list ys) =\n      pdevs_val e (pdevs_of_list (xs @ ys))\"\n    \"e \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pdevs_val f (pdevs_of_list xs) + pdevs_val g (pdevs_of_list ys) =\n    pdevs_val ?e2 (pdevs_of_list (xs @ ys))\n 2. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?e2 \\<in> UNIV \\<rightarrow> I", "let ?e = \"(\\<lambda>i. if i < length xs then f i else g (i - length xs))\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pdevs_val f (pdevs_of_list xs) + pdevs_val g (pdevs_of_list ys) =\n    pdevs_val ?e2 (pdevs_of_list (xs @ ys))\n 2. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?e2 \\<in> UNIV \\<rightarrow> I", "have f: \"pdevs_val f (pdevs_of_list xs) =\n      (\\<Sum>i\\<in>{..<length xs}. ?e i *\\<^sub>R pdevs_apply (pdevs_of_list (xs @ ys)) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list xs) =\n    (\\<Sum>i<length xs.\n        (if i < length xs then f i else g (i - length xs)) *\\<^sub>R\n        pdevs_apply (pdevs_of_list (xs @ ys)) i)", "by (auto simp: pdevs_val_sum degree_gt pdevs_apply_pdevs_of_list_append\n      intro: sum.mono_neutral_cong_left)"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) =\n  (\\<Sum>i<length xs.\n      (if i < length xs then f i else g (i - length xs)) *\\<^sub>R\n      pdevs_apply (pdevs_of_list (xs @ ys)) i)\n\ngoal (2 subgoals):\n 1. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pdevs_val f (pdevs_of_list xs) + pdevs_val g (pdevs_of_list ys) =\n    pdevs_val ?e2 (pdevs_of_list (xs @ ys))\n 2. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?e2 \\<in> UNIV \\<rightarrow> I", "have g: \"pdevs_val g (pdevs_of_list ys) =\n      (\\<Sum>i=length xs ..<length xs + degree (pdevs_of_list ys).\n        ?e i *\\<^sub>R pdevs_apply (pdevs_of_list (xs @ ys)) i)\"\n    (is \"_ = ?sg\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val g (pdevs_of_list ys) =\n    (\\<Sum>i = length xs..<length xs + degree (pdevs_of_list ys).\n        (if i < length xs then f i else g (i - length xs)) *\\<^sub>R\n        pdevs_apply (pdevs_of_list (xs @ ys)) i)", "by (auto simp: pdevs_val_sum pdevs_apply_pdevs_of_list_append\n      intro!: inj_onI image_eqI[where x=\"length xs + x\" for x]\n        sum.reindex_cong[where l=\"\\<lambda>i. i - length xs\"])"], ["proof (state)\nthis:\n  pdevs_val g (pdevs_of_list ys) =\n  (\\<Sum>i = length xs..<length xs + degree (pdevs_of_list ys).\n      (if i < length xs then f i else g (i - length xs)) *\\<^sub>R\n      pdevs_apply (pdevs_of_list (xs @ ys)) i)\n\ngoal (2 subgoals):\n 1. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pdevs_val f (pdevs_of_list xs) + pdevs_val g (pdevs_of_list ys) =\n    pdevs_val ?e2 (pdevs_of_list (xs @ ys))\n 2. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?e2 \\<in> UNIV \\<rightarrow> I", "show \"pdevs_val f (pdevs_of_list xs) + pdevs_val g (pdevs_of_list ys) =\n      pdevs_val ?e (pdevs_of_list (xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val f (pdevs_of_list xs) + pdevs_val g (pdevs_of_list ys) =\n    pdevs_val (\\<lambda>i. if i < length xs then f i else g (i - length xs))\n     (pdevs_of_list (xs @ ys))", "unfolding f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xs.\n        (if i < length xs then f i else g (i - length xs)) *\\<^sub>R\n        pdevs_apply (pdevs_of_list (xs @ ys)) i) +\n    (\\<Sum>i = length xs..<length xs + degree (pdevs_of_list ys).\n        (if i < length xs then f i else g (i - length xs)) *\\<^sub>R\n        pdevs_apply (pdevs_of_list (xs @ ys)) i) =\n    pdevs_val (\\<lambda>i. if i < length xs then f i else g (i - length xs))\n     (pdevs_of_list (xs @ ys))", "by (subst sum.union_disjoint[symmetric])\n      (force simp: pdevs_val_sum ivl_disj_un degree_pdevs_of_list_append\n        intro!: sum.mono_neutral_cong_right\n        split: if_split_asm)+"], ["proof (state)\nthis:\n  pdevs_val f (pdevs_of_list xs) + pdevs_val g (pdevs_of_list ys) =\n  pdevs_val (\\<lambda>i. if i < length xs then f i else g (i - length xs))\n   (pdevs_of_list (xs @ ys))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>pdevs_val f (pdevs_of_list xs) +\n                 pdevs_val g (pdevs_of_list ys) =\n                 pdevs_val e (pdevs_of_list (xs @ ys));\n         e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    (\\<lambda>i. if i < length xs then f i else g (i - length xs))\n    \\<in> UNIV \\<rightarrow> I", "show \"?e \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i < length xs then f i else g (i - length xs))\n    \\<in> UNIV \\<rightarrow> I", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> UNIV \\<rightarrow> I\n  g \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i < length xs then f i else g (i - length xs))\n    \\<in> UNIV \\<rightarrow> I", "by (auto simp: Pi_iff)"], ["proof (state)\nthis:\n  (\\<lambda>i. if i < length xs then f i else g (i - length xs))\n  \\<in> UNIV \\<rightarrow> I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  sum_general_mono:\n  fixes f::\"'a\\<Rightarrow>('b::ordered_ab_group_add)\"\n  assumes [simp,intro]: \"finite s\" \"finite t\"\n  assumes f: \"\\<And>x. x \\<in> s - t \\<Longrightarrow> f x \\<le> 0\"\n  assumes g: \"\\<And>x. x \\<in> t - s \\<Longrightarrow> g x \\<ge> 0\"\n  assumes fg: \"\\<And>x. x \\<in> s \\<inter> t \\<Longrightarrow> f x \\<le> g x\"\n  shows \"(\\<Sum>x \\<in> s. f x) \\<le> (\\<Sum>x \\<in> t. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "have \"s = (s - t) \\<union> (s \\<inter> t)\" and [intro, simp]: \"(s - t) \\<inter> (s \\<inter> t) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = s - t \\<union> s \\<inter> t &&& (s - t) \\<inter> (s \\<inter> t) = {}", "by auto"], ["proof (state)\nthis:\n  s = s - t \\<union> s \\<inter> t\n  (s - t) \\<inter> (s \\<inter> t) = {}\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "hence \"(\\<Sum>x \\<in> s. f x) = (\\<Sum>x \\<in> s - t \\<union> s \\<inter> t. f x)\""], ["proof (prove)\nusing this:\n  s = s - t \\<union> s \\<inter> t\n  (s - t) \\<inter> (s \\<inter> t) = {}\n\ngoal (1 subgoal):\n 1. sum f s = sum f (s - t \\<union> s \\<inter> t)", "using assms"], ["proof (prove)\nusing this:\n  s = s - t \\<union> s \\<inter> t\n  (s - t) \\<inter> (s \\<inter> t) = {}\n  finite s\n  finite t\n  ?x \\<in> s - t \\<Longrightarrow> f ?x \\<le> (0::'b)\n  ?x \\<in> t - s \\<Longrightarrow> (0::'b) \\<le> g ?x\n  ?x \\<in> s \\<inter> t \\<Longrightarrow> f ?x \\<le> g ?x\n\ngoal (1 subgoal):\n 1. sum f s = sum f (s - t \\<union> s \\<inter> t)", "by simp"], ["proof (state)\nthis:\n  sum f s = sum f (s - t \\<union> s \\<inter> t)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "also"], ["proof (state)\nthis:\n  sum f s = sum f (s - t \\<union> s \\<inter> t)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "have \"\\<dots> = (\\<Sum>x \\<in> s - t. f x) + (\\<Sum>x \\<in> s \\<inter> t. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (s - t \\<union> s \\<inter> t) =\n    sum f (s - t) + sum f (s \\<inter> t)", "by (simp add: sum_Un)"], ["proof (state)\nthis:\n  sum f (s - t \\<union> s \\<inter> t) = sum f (s - t) + sum f (s \\<inter> t)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "also"], ["proof (state)\nthis:\n  sum f (s - t \\<union> s \\<inter> t) = sum f (s - t) + sum f (s \\<inter> t)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "have \"(\\<Sum>x \\<in> s - t. f x) \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (s - t) \\<le> (0::'b)", "by (auto intro!: sum_nonpos f)"], ["proof (state)\nthis:\n  sum f (s - t) \\<le> (0::'b)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "also"], ["proof (state)\nthis:\n  sum f (s - t) \\<le> (0::'b)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "have \"0 \\<le> (\\<Sum>x \\<in> t - s. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> sum g (t - s)", "by (auto intro!: sum_nonneg g)"], ["proof (state)\nthis:\n  (0::'b) \\<le> sum g (t - s)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "also"], ["proof (state)\nthis:\n  (0::'b) \\<le> sum g (t - s)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "have \"(\\<Sum>x \\<in> s \\<inter> t. f x) \\<le> (\\<Sum>x \\<in> s \\<inter> t. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (s \\<inter> t) \\<le> sum g (s \\<inter> t)", "by (auto intro!: sum_mono fg)"], ["proof (state)\nthis:\n  sum f (s \\<inter> t) \\<le> sum g (s \\<inter> t)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "also"], ["proof (state)\nthis:\n  sum f (s \\<inter> t) \\<le> sum g (s \\<inter> t)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "have [intro, simp]: \"(t - s) \\<inter> (s \\<inter> t) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - s) \\<inter> (s \\<inter> t) = {}", "by auto"], ["proof (state)\nthis:\n  (t - s) \\<inter> (s \\<inter> t) = {}\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "hence \"sum g (t - s) + sum g (s \\<inter> t) = sum g ((t - s) \\<union> (s \\<inter> t))\""], ["proof (prove)\nusing this:\n  (t - s) \\<inter> (s \\<inter> t) = {}\n\ngoal (1 subgoal):\n 1. sum g (t - s) + sum g (s \\<inter> t) =\n    sum g (t - s \\<union> s \\<inter> t)", "by (simp add: sum_Un)"], ["proof (state)\nthis:\n  sum g (t - s) + sum g (s \\<inter> t) = sum g (t - s \\<union> s \\<inter> t)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "also"], ["proof (state)\nthis:\n  sum g (t - s) + sum g (s \\<inter> t) = sum g (t - s \\<union> s \\<inter> t)\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "have \"\\<dots> = sum g t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g (t - s \\<union> s \\<inter> t) = sum g t", "by (auto intro!: sum.cong)"], ["proof (state)\nthis:\n  sum g (t - s \\<union> s \\<inter> t) = sum g t\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + sum f (s \\<inter> t) \\<le> y + sum f (s \\<inter> t);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + sum f (s \\<inter> t) \\<le> y + sum f (s \\<inter> t);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      sum g (t - s) + x \\<le> sum g (t - s) + y\\<rbrakk>\n  \\<Longrightarrow> sum f s \\<le> sum g t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + sum f (s \\<inter> t) \\<le> y + sum f (s \\<inter> t);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + sum f (s \\<inter> t) \\<le> y + sum f (s \\<inter> t);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      sum g (t - s) + x \\<le> sum g (t - s) + y\\<rbrakk>\n  \\<Longrightarrow> sum f s \\<le> sum g t\n\ngoal (1 subgoal):\n 1. sum f s \\<le> sum g t", "by simp"], ["proof (state)\nthis:\n  sum f s \\<le> sum g t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_val_perm_ex:\n  assumes \"xs <~~> ys\"\n  assumes mem: \"e \\<in> UNIV \\<rightarrow> I\"\n  shows \"\\<exists>e'. e' \\<in> UNIV \\<rightarrow> I \\<and> pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)", "using assms"], ["proof (prove)\nusing this:\n  xs <~~> ys\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)", "proof (induct arbitrary: e)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list []) = pdevs_val e' (pdevs_of_list [])\n 2. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 3. \\<And>xs ys z e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list (z # xs)) =\n                            pdevs_val e' (pdevs_of_list (z # ys))\n 4. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "case Nil"], ["proof (state)\nthis:\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list []) = pdevs_val e' (pdevs_of_list [])\n 2. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 3. \\<And>xs ys z e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list (z # xs)) =\n                            pdevs_val e' (pdevs_of_list (z # ys))\n 4. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "thus ?case"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list []) = pdevs_val e' (pdevs_of_list [])", "by auto"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val e (pdevs_of_list []) = pdevs_val e' (pdevs_of_list [])\n\ngoal (3 subgoals):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 2. \\<And>xs ys z e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list (z # xs)) =\n                            pdevs_val e' (pdevs_of_list (z # ys))\n 3. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 2. \\<And>xs ys z e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list (z # xs)) =\n                            pdevs_val e' (pdevs_of_list (z # ys))\n 3. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "case (Cons xs ys z)"], ["proof (state)\nthis:\n  xs <~~> ys\n  ?e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val ?e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (3 subgoals):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 2. \\<And>xs ys z e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list (z # xs)) =\n                            pdevs_val e' (pdevs_of_list (z # ys))\n 3. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "hence \"(e \\<circ> (+) (Suc 0)) \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\nusing this:\n  xs <~~> ys\n  ?e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val ?e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. e \\<circ> (+) (Suc 0) \\<in> UNIV \\<rightarrow> I", "by auto"], ["proof (state)\nthis:\n  e \\<circ> (+) (Suc 0) \\<in> UNIV \\<rightarrow> I\n\ngoal (3 subgoals):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 2. \\<And>xs ys z e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list (z # xs)) =\n                            pdevs_val e' (pdevs_of_list (z # ys))\n 3. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "from Cons(2)[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val (e \\<circ> (+) (Suc 0)) (pdevs_of_list xs) =\n     pdevs_val e' (pdevs_of_list ys)", "obtain e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n      \"pdevs_val (e \\<circ> (+) (Suc 0)) (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\""], ["proof (prove)\nusing this:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val (e \\<circ> (+) (Suc 0)) (pdevs_of_list xs) =\n     pdevs_val e' (pdevs_of_list ys)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val (e \\<circ> (+) (Suc 0)) (pdevs_of_list xs) =\n         pdevs_val e' (pdevs_of_list ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val (e \\<circ> (+) (Suc 0)) (pdevs_of_list xs) =\n  pdevs_val e' (pdevs_of_list ys)\n\ngoal (3 subgoals):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 2. \\<And>xs ys z e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list (z # xs)) =\n                            pdevs_val e' (pdevs_of_list (z # ys))\n 3. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "thus ?case"], ["proof (prove)\nusing this:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val (e \\<circ> (+) (Suc 0)) (pdevs_of_list xs) =\n  pdevs_val e' (pdevs_of_list ys)\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list (z # xs)) =\n       pdevs_val e' (pdevs_of_list (z # ys))", "using Cons"], ["proof (prove)\nusing this:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val (e \\<circ> (+) (Suc 0)) (pdevs_of_list xs) =\n  pdevs_val e' (pdevs_of_list ys)\n  xs <~~> ys\n  ?e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val ?e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list (z # xs)) =\n       pdevs_val e' (pdevs_of_list (z # ys))", "by (auto intro!: exI[where x=\"\\<lambda>x. if x = 0 then e 0 else e' (x - 1)\"] simp: o_def Pi_iff)"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val e (pdevs_of_list (z # xs)) =\n     pdevs_val e' (pdevs_of_list (z # ys))\n\ngoal (2 subgoals):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 2. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 2. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "case (trans xs ys zs)"], ["proof (state)\nthis:\n  xs <~~> ys\n  ?e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val ?e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\n  ys <~~> zs\n  ?e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val ?e (pdevs_of_list ys) = pdevs_val e' (pdevs_of_list zs)\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (2 subgoals):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))\n 2. \\<And>xs ys zs e.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list xs) =\n              pdevs_val e' (pdevs_of_list ys);\n        ys <~~> zs;\n        \\<And>e.\n           e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n           \\<exists>e'.\n              e' \\<in> UNIV \\<rightarrow> I \\<and>\n              pdevs_val e (pdevs_of_list ys) =\n              pdevs_val e' (pdevs_of_list zs);\n        e \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            e' \\<in> UNIV \\<rightarrow> I \\<and>\n                            pdevs_val e (pdevs_of_list xs) =\n                            pdevs_val e' (pdevs_of_list zs)", "thus ?case"], ["proof (prove)\nusing this:\n  xs <~~> ys\n  ?e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val ?e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\n  ys <~~> zs\n  ?e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val ?e (pdevs_of_list ys) = pdevs_val e' (pdevs_of_list zs)\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list zs)", "by metis"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list zs)\n\ngoal (1 subgoal):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))", "case (swap y x l)"], ["proof (state)\nthis:\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<And>y x l e.\n       e \\<in> UNIV \\<rightarrow> I \\<Longrightarrow>\n       \\<exists>e'.\n          e' \\<in> UNIV \\<rightarrow> I \\<and>\n          pdevs_val e (pdevs_of_list (y # x # l)) =\n          pdevs_val e' (pdevs_of_list (x # y # l))", "thus ?case"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. \\<exists>e'.\n       e' \\<in> UNIV \\<rightarrow> I \\<and>\n       pdevs_val e (pdevs_of_list (y # x # l)) =\n       pdevs_val e' (pdevs_of_list (x # y # l))", "by (auto intro!: exI[where x=\"\\<lambda>i. if i = 0 then e 1 else if i = 1 then e 0 else e i\"]\n      simp: o_def Pi_iff)"], ["proof (state)\nthis:\n  \\<exists>e'.\n     e' \\<in> UNIV \\<rightarrow> I \\<and>\n     pdevs_val e (pdevs_of_list (y # x # l)) =\n     pdevs_val e' (pdevs_of_list (x # y # l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_val_perm:\n  assumes \"xs <~~> ys\"\n  assumes mem: \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n    \"pdevs_val e (pdevs_of_list xs) = pdevs_val e' (pdevs_of_list ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         pdevs_val e' (pdevs_of_list ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  xs <~~> ys\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         pdevs_val e' (pdevs_of_list ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis pdevs_val_perm_ex)"], ["", "lemma set_distinct_permI: \"set xs = set ys \\<Longrightarrow> distinct xs \\<Longrightarrow> distinct ys \\<Longrightarrow> xs <~~> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs = set ys; distinct xs; distinct ys\\<rbrakk>\n    \\<Longrightarrow> xs <~~> ys", "by (metis eq_set_perm_remdups remdups_id_iff_distinct)"], ["", "lemmas pdevs_val_permute = pdevs_val_perm[OF set_distinct_permI]"], ["", "lemma partition_permI:\n  \"filter p xs @ filter (Not o p) xs <~~> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter p xs @ filter (Not \\<circ> p) xs <~~> xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. filter p [] @ filter (Not \\<circ> p) [] <~~> []\n 2. \\<And>a xs.\n       filter p xs @ filter (Not \\<circ> p) xs <~~> xs \\<Longrightarrow>\n       filter p (a # xs) @ filter (Not \\<circ> p) (a # xs) <~~> a # xs", "case (Cons x xs)"], ["proof (state)\nthis:\n  filter p xs @ filter (Not \\<circ> p) xs <~~> xs\n\ngoal (2 subgoals):\n 1. filter p [] @ filter (Not \\<circ> p) [] <~~> []\n 2. \\<And>a xs.\n       filter p xs @ filter (Not \\<circ> p) xs <~~> xs \\<Longrightarrow>\n       filter p (a # xs) @ filter (Not \\<circ> p) (a # xs) <~~> a # xs", "have swap_app_Cons: \"filter p xs @ x # [a\\<leftarrow>xs . \\<not> p a] <~~> x # filter p xs @ [a\\<leftarrow>xs . \\<not> p a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter p xs @ x # filter (\\<lambda>a. \\<not> p a) xs <~~>\n    x # filter p xs @ filter (\\<lambda>a. \\<not> p a) xs", "by (metis perm_sym perm_append_Cons)"], ["proof (state)\nthis:\n  filter p xs @ x # filter (\\<lambda>a. \\<not> p a) xs <~~>\n  x # filter p xs @ filter (\\<lambda>a. \\<not> p a) xs\n\ngoal (2 subgoals):\n 1. filter p [] @ filter (Not \\<circ> p) [] <~~> []\n 2. \\<And>a xs.\n       filter p xs @ filter (Not \\<circ> p) xs <~~> xs \\<Longrightarrow>\n       filter p (a # xs) @ filter (Not \\<circ> p) (a # xs) <~~> a # xs", "also"], ["proof (state)\nthis:\n  filter p xs @ x # filter (\\<lambda>a. \\<not> p a) xs <~~>\n  x # filter p xs @ filter (\\<lambda>a. \\<not> p a) xs\n\ngoal (2 subgoals):\n 1. filter p [] @ filter (Not \\<circ> p) [] <~~> []\n 2. \\<And>a xs.\n       filter p xs @ filter (Not \\<circ> p) xs <~~> xs \\<Longrightarrow>\n       filter p (a # xs) @ filter (Not \\<circ> p) (a # xs) <~~> a # xs", "have \"\\<dots> <~~> x#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x # filter p xs @ filter (\\<lambda>a. \\<not> p a) xs <~~> x # xs", "using Cons"], ["proof (prove)\nusing this:\n  filter p xs @ filter (Not \\<circ> p) xs <~~> xs\n\ngoal (1 subgoal):\n 1. x # filter p xs @ filter (\\<lambda>a. \\<not> p a) xs <~~> x # xs", "by auto"], ["proof (state)\nthis:\n  x # filter p xs @ filter (\\<lambda>a. \\<not> p a) xs <~~> x # xs\n\ngoal (2 subgoals):\n 1. filter p [] @ filter (Not \\<circ> p) [] <~~> []\n 2. \\<And>a xs.\n       filter p xs @ filter (Not \\<circ> p) xs <~~> xs \\<Longrightarrow>\n       filter p (a # xs) @ filter (Not \\<circ> p) (a # xs) <~~> a # xs", "finally (trans)"], ["proof (chain)\npicking this:\n  filter p xs @ x # filter (\\<lambda>a. \\<not> p a) xs <~~> x # xs", "show ?case"], ["proof (prove)\nusing this:\n  filter p xs @ x # filter (\\<lambda>a. \\<not> p a) xs <~~> x # xs\n\ngoal (1 subgoal):\n 1. filter p (x # xs) @ filter (Not \\<circ> p) (x # xs) <~~> x # xs", "using Cons"], ["proof (prove)\nusing this:\n  filter p xs @ x # filter (\\<lambda>a. \\<not> p a) xs <~~> x # xs\n  filter p xs @ filter (Not \\<circ> p) xs <~~> xs\n\ngoal (1 subgoal):\n 1. filter p (x # xs) @ filter (Not \\<circ> p) (x # xs) <~~> x # xs", "by simp"], ["proof (state)\nthis:\n  filter p (x # xs) @ filter (Not \\<circ> p) (x # xs) <~~> x # xs\n\ngoal (1 subgoal):\n 1. filter p [] @ filter (Not \\<circ> p) [] <~~> []", "qed simp"], ["", "lemma pdevs_val_eqI:\n  assumes \"\\<And>i. i \\<in> pdevs_domain y \\<Longrightarrow> i \\<in> pdevs_domain x \\<Longrightarrow>\n      e i *\\<^sub>R pdevs_apply x i = f i *\\<^sub>R pdevs_apply y i\"\n  assumes \"\\<And>i. i \\<in> pdevs_domain y \\<Longrightarrow> i \\<notin> pdevs_domain x \\<Longrightarrow> f i *\\<^sub>R pdevs_apply y i = 0\"\n  assumes \"\\<And>i. i \\<in> pdevs_domain x \\<Longrightarrow> i \\<notin> pdevs_domain y \\<Longrightarrow> e i *\\<^sub>R pdevs_apply x i = 0\"\n  shows \"pdevs_val e x = pdevs_val f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e x = pdevs_val f y", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> pdevs_domain y; ?i \\<in> pdevs_domain x\\<rbrakk>\n  \\<Longrightarrow> e ?i *\\<^sub>R pdevs_apply x ?i =\n                    f ?i *\\<^sub>R pdevs_apply y ?i\n  \\<lbrakk>?i \\<in> pdevs_domain y; ?i \\<notin> pdevs_domain x\\<rbrakk>\n  \\<Longrightarrow> f ?i *\\<^sub>R pdevs_apply y ?i = (0::'a)\n  \\<lbrakk>?i \\<in> pdevs_domain x; ?i \\<notin> pdevs_domain y\\<rbrakk>\n  \\<Longrightarrow> e ?i *\\<^sub>R pdevs_apply x ?i = (0::'a)\n\ngoal (1 subgoal):\n 1. pdevs_val e x = pdevs_val f y", "by (force simp: pdevs_val_pdevs_domain\n    intro!:\n      sum.reindex_bij_witness_not_neutral[where\n        i=id and j = id and\n        S'=\"pdevs_domain x - pdevs_domain y\" and\n        T'=\"pdevs_domain y - pdevs_domain x\"])"], ["", "definition\n  filter_pdevs_raw::\"(nat \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> (nat \\<Rightarrow> 'a::real_vector) \\<Rightarrow> (nat \\<Rightarrow> 'a)\"\n  where \"filter_pdevs_raw I X = (\\<lambda>i. if I i (X i) then X i else 0)\""], ["", "lemma filter_pdevs_raw_nonzeros: \"{i. filter_pdevs_raw s f i \\<noteq> 0} = {i. f i \\<noteq> 0} \\<inter> {x. s x (f x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. filter_pdevs_raw s f i \\<noteq> (0::'a)} =\n    {i. f i \\<noteq> (0::'a)} \\<inter> {x. s x (f x)}", "by (auto simp: filter_pdevs_raw_def)"], ["", "lift_definition filter_pdevs::\"(nat \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a::real_vector pdevs \\<Rightarrow> 'a pdevs\"\n  is filter_pdevs_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       finite {i. fun2 i \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {i. filter_pdevs_raw fun1 fun2 i \\<noteq> (0::'a)}", "by (simp add: filter_pdevs_raw_nonzeros)"], ["", "lemma pdevs_apply_filter_pdevs[simp]:\n  \"pdevs_apply (filter_pdevs I x) i = (if I i (pdevs_apply x i) then pdevs_apply x i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (filter_pdevs I x) i =\n    (if I i (pdevs_apply x i) then pdevs_apply x i else (0::'a))", "by transfer (auto simp: filter_pdevs_raw_def)"], ["", "lemma degree_filter_pdevs_le: \"degree (filter_pdevs I x) \\<le> degree x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (filter_pdevs I x) \\<le> degree x", "by (rule degree_leI) (simp split: if_split_asm)"], ["", "lemma pdevs_val_filter_pdevs:\n  \"pdevs_val e (filter_pdevs I x) =\n    (\\<Sum>i \\<in> {..<degree x} \\<inter> {i. I i (pdevs_apply x i)}. e i *\\<^sub>R pdevs_apply x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (filter_pdevs I x) =\n    (\\<Sum>i\\<in>{..<degree x} \\<inter> {i. I i (pdevs_apply x i)}.\n       e i *\\<^sub>R pdevs_apply x i)", "by (auto simp: pdevs_val_sum if_distrib sum.inter_restrict degree_filter_pdevs_le degree_gt\n    intro!: sum.mono_neutral_cong_left split: if_split_asm)"], ["", "lemma pdevs_val_filter_pdevs_dom:\n  \"pdevs_val e (filter_pdevs I x) =\n    (\\<Sum>i \\<in> pdevs_domain x \\<inter> {i. I i (pdevs_apply x i)}. e i *\\<^sub>R pdevs_apply x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (filter_pdevs I x) =\n    (\\<Sum>i\\<in>pdevs_domain x \\<inter> {i. I i (pdevs_apply x i)}.\n       e i *\\<^sub>R pdevs_apply x i)", "by (auto\n    simp: pdevs_val_pdevs_domain if_distrib sum.inter_restrict degree_filter_pdevs_le degree_gt\n    intro!: sum.mono_neutral_cong_left split: if_split_asm)"], ["", "lemma pdevs_val_filter_pdevs_eval:\n  \"pdevs_val e (filter_pdevs p x) = pdevs_val (\\<lambda>i. if p i (pdevs_apply x i) then e i else 0) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (filter_pdevs p x) =\n    pdevs_val (\\<lambda>i. if p i (pdevs_apply x i) then e i else 0) x", "by (auto split: if_split_asm intro!: pdevs_val_eqI)"], ["", "definition \"pdevs_applys X i = map (\\<lambda>x. pdevs_apply x i) X\""], ["", "definition \"pdevs_vals e X = map (pdevs_val e) X\""], ["", "definition \"aform_vals e X = map (aform_val e) X\""], ["", "definition \"filter_pdevs_list I X = map (filter_pdevs (\\<lambda>i _. I i (pdevs_applys X i))) X\""], ["", "lemma pdevs_applys_filter_pdevs_list[simp]:\n  \"pdevs_applys (filter_pdevs_list I X) i = (if I i (pdevs_applys X i) then pdevs_applys X i else\n    map (\\<lambda>_. 0) X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_applys (filter_pdevs_list I X) i =\n    (if I i (pdevs_applys X i) then pdevs_applys X i\n     else map (\\<lambda>_. 0::'a) X)", "by (auto simp: filter_pdevs_list_def o_def pdevs_applys_def)"], ["", "definition \"degrees X = Max (insert 0 (degree ` set X))\""], ["", "abbreviation \"degree_aforms X \\<equiv> degrees (map snd X)\""], ["", "lemma degrees_leI:\n  assumes \"\\<And>x. x \\<in> set X \\<Longrightarrow> degree x \\<le> K\"\n  shows \"degrees X \\<le> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degrees X \\<le> K", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set X \\<Longrightarrow> degree ?x \\<le> K\n\ngoal (1 subgoal):\n 1. degrees X \\<le> K", "by (auto simp: degrees_def intro!: Max.boundedI)"], ["", "lemma degrees_leD:\n  assumes \"degrees X \\<le> K\"\n  shows \"\\<And>x. x \\<in> set X \\<Longrightarrow> degree x \\<le> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set X \\<Longrightarrow> degree x \\<le> K", "using assms"], ["proof (prove)\nusing this:\n  degrees X \\<le> K\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set X \\<Longrightarrow> degree x \\<le> K", "by (auto simp: degrees_def intro!: Max.boundedI)"], ["", "lemma degree_filter_pdevs_list_le: \"degrees (filter_pdevs_list I x) \\<le> degrees x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degrees (filter_pdevs_list I x) \\<le> degrees x", "by (rule degrees_leI) (auto simp: filter_pdevs_list_def intro!: degree_le dest!: degrees_leD)"], ["", "definition \"dense_list_of_pdevs x = map (\\<lambda>i. pdevs_apply x i) [0..<degree x]\""], ["", "subsubsection \\<open>(reverse) ordered coefficients as list\\<close>"], ["", "definition \"list_of_pdevs x =\n  map (\\<lambda>i. (i, pdevs_apply x i)) (rev (sorted_list_of_set (pdevs_domain x)))\""], ["", "lemma list_of_pdevs_zero_pdevs[simp]: \"list_of_pdevs zero_pdevs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_pdevs zero_pdevs = []", "by (auto simp: list_of_pdevs_def)"], ["", "lemma sum_list_list_of_pdevs: \"sum_list (map snd (list_of_pdevs x)) = sum_list (dense_list_of_pdevs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map snd (list_of_pdevs x)) = sum_list (dense_list_of_pdevs x)", "by (auto intro!: sum.mono_neutral_cong_left\n    simp add: degree_gt sum_list_distinct_conv_sum_set dense_list_of_pdevs_def list_of_pdevs_def)"], ["", "lemma sum_list_filter_dense_list_of_pdevs[symmetric]:\n  \"sum_list (map snd (filter (p o snd) (list_of_pdevs x))) =\n    sum_list (filter p (dense_list_of_pdevs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map snd (filter (p \\<circ> snd) (list_of_pdevs x))) =\n    sum_list (filter p (dense_list_of_pdevs x))", "by (auto intro!: sum.mono_neutral_cong_left\n    simp add: degree_gt sum_list_distinct_conv_sum_set dense_list_of_pdevs_def list_of_pdevs_def\n      o_def filter_map)"], ["", "lemma pdevs_of_list_dense_list_of_pdevs: \"pdevs_of_list (dense_list_of_pdevs x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_list (dense_list_of_pdevs x) = x", "by (auto simp: pdevs_apply_pdevs_of_list dense_list_of_pdevs_def pdevs_eqI)"], ["", "lemma pdevs_val_sum_list: \"pdevs_val (\\<lambda>_. c) X = c *\\<^sub>R sum_list (map snd (list_of_pdevs X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>_. c) X =\n    c *\\<^sub>R sum_list (map snd (list_of_pdevs X))", "by (auto simp: pdevs_val_sum sum_list_list_of_pdevs pdevs_val_const_pdevs_of_list[symmetric]\n    pdevs_of_list_dense_list_of_pdevs)"], ["", "lemma list_of_pdevs_all_nonzero: \"list_all (\\<lambda>x. x \\<noteq> 0) (map snd (list_of_pdevs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x \\<noteq> (0::'a)) (map snd (list_of_pdevs xs))", "by (auto simp: list_of_pdevs_def list_all_iff)"], ["", "lemma list_of_pdevs_nonzero: \"x \\<in> set (map snd (list_of_pdevs xs)) \\<Longrightarrow> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (map snd (list_of_pdevs xs)) \\<Longrightarrow>\n    x \\<noteq> (0::'a)", "by (auto simp: list_of_pdevs_def)"], ["", "lemma pdevs_of_list_scaleR_0[simp]:\n  fixes xs::\"'a::real_vector list\"\n  shows \"pdevs_of_list (map ((*\\<^sub>R) 0) xs) = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_list (map ((*\\<^sub>R) 0) xs) = zero_pdevs", "by (auto simp: pdevs_apply_pdevs_of_list intro!: pdevs_eqI)"], ["", "lemma degree_pdevs_of_list_scaleR:\n  \"degree (pdevs_of_list (map ((*\\<^sub>R) c) xs)) = (if c \\<noteq> 0 then degree (pdevs_of_list xs) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pdevs_of_list (map ((*\\<^sub>R) c) xs)) =\n    (if c \\<noteq> 0 then degree (pdevs_of_list xs) else 0)", "by (auto simp: pdevs_apply_pdevs_of_list intro!: degree_cong)"], ["", "lemma list_of_pdevs_eq:\n  \"rev (list_of_pdevs X) = (filter ((\\<noteq>) 0 o snd) (map (\\<lambda>i. (i, pdevs_apply X i)) [0..<degree X]))\"\n  (is \"_ = filter ?P (map ?f ?xs)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (list_of_pdevs X) =\n    filter ((\\<noteq>) (0::'a) \\<circ> snd)\n     (map (\\<lambda>i. (i, pdevs_apply X i)) [0..<degree X])", "using map_filter[of ?f ?P ?xs]"], ["proof (prove)\nusing this:\n  map (\\<lambda>i. (i, pdevs_apply X i))\n   (filter\n     (\\<lambda>x. ((\\<noteq>) (0::'a) \\<circ> snd) (x, pdevs_apply X x))\n     [0..<degree X]) =\n  filter ((\\<noteq>) (0::'a) \\<circ> snd)\n   (map (\\<lambda>i. (i, pdevs_apply X i)) [0..<degree X])\n\ngoal (1 subgoal):\n 1. rev (list_of_pdevs X) =\n    filter ((\\<noteq>) (0::'a) \\<circ> snd)\n     (map (\\<lambda>i. (i, pdevs_apply X i)) [0..<degree X])", "by (auto simp: list_of_pdevs_def o_def sorted_list_of_pdevs_domain_eq rev_map)"], ["", "lemma sum_list_take_pdevs_val_eq:\n  \"sum_list (take d xs) = pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (take d xs) =\n    pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (take d xs) =\n    pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "have \"sum_list (take d xs) = 1 *\\<^sub>R sum_list (take d xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (take d xs) = 1 *\\<^sub>R sum_list (take d xs)", "by simp"], ["proof (state)\nthis:\n  sum_list (take d xs) = 1 *\\<^sub>R sum_list (take d xs)\n\ngoal (1 subgoal):\n 1. sum_list (take d xs) =\n    pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "also"], ["proof (state)\nthis:\n  sum_list (take d xs) = 1 *\\<^sub>R sum_list (take d xs)\n\ngoal (1 subgoal):\n 1. sum_list (take d xs) =\n    pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "note pdevs_val_const_pdevs_of_list[symmetric]"], ["proof (state)\nthis:\n  ?c *\\<^sub>R sum_list ?xs = pdevs_val (\\<lambda>_. ?c) (pdevs_of_list ?xs)\n\ngoal (1 subgoal):\n 1. sum_list (take d xs) =\n    pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "also"], ["proof (state)\nthis:\n  ?c *\\<^sub>R sum_list ?xs = pdevs_val (\\<lambda>_. ?c) (pdevs_of_list ?xs)\n\ngoal (1 subgoal):\n 1. sum_list (take d xs) =\n    pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "have \"pdevs_val (\\<lambda>_. 1) (pdevs_of_list (take d xs)) =\n      pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val (\\<lambda>_. 1) (pdevs_of_list (take d xs)) =\n    pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "by (auto simp: pdevs_apply_pdevs_of_list split: if_split_asm intro!: pdevs_val_eqI)"], ["proof (state)\nthis:\n  pdevs_val (\\<lambda>_. 1) (pdevs_of_list (take d xs)) =\n  pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. sum_list (take d xs) =\n    pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "finally"], ["proof (chain)\npicking this:\n  sum_list (take d xs) =\n  pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (take d xs) =\n  pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. sum_list (take d xs) =\n    pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)", "."], ["proof (state)\nthis:\n  sum_list (take d xs) =\n  pdevs_val (\\<lambda>i. if i < d then 1 else 0) (pdevs_of_list xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_in_range_pdevs_apply[intro, simp]:\n  fixes X::\"'a::real_vector pdevs\" shows \"0 \\<in> range (pdevs_apply X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> range (pdevs_apply X)", "by (metis degree_gt less_irrefl rangeI)"], ["", "lemma dense_list_in_range: \"x \\<in> set (dense_list_of_pdevs X) \\<Longrightarrow> x \\<in> range (pdevs_apply X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (dense_list_of_pdevs X) \\<Longrightarrow>\n    x \\<in> range (pdevs_apply X)", "by (auto simp: dense_list_of_pdevs_def)"], ["", "lemma not_in_dense_list_zeroD:\n  assumes \"pdevs_apply X i \\<notin> set (dense_list_of_pdevs X)\"\n  shows \"pdevs_apply X i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply X i = (0::'a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_apply X i \\<noteq> (0::'a) \\<Longrightarrow> False", "assume \"pdevs_apply X i \\<noteq> 0\""], ["proof (state)\nthis:\n  pdevs_apply X i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. pdevs_apply X i \\<noteq> (0::'a) \\<Longrightarrow> False", "hence \"i < degree X\""], ["proof (prove)\nusing this:\n  pdevs_apply X i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. i < degree X", "by (rule degree_gt)"], ["proof (state)\nthis:\n  i < degree X\n\ngoal (1 subgoal):\n 1. pdevs_apply X i \\<noteq> (0::'a) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  i < degree X\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  i < degree X\n  pdevs_apply X i \\<notin> set (dense_list_of_pdevs X)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: dense_list_of_pdevs_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_all_list_of_pdevsI:\n  assumes \"\\<And>i. i \\<in> pdevs_domain X \\<Longrightarrow> P (pdevs_apply X i)\"\n  shows \"list_all (\\<lambda>x. P x) (map snd (list_of_pdevs X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P (map snd (list_of_pdevs X))", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> pdevs_domain X \\<Longrightarrow> P (pdevs_apply X ?i)\n\ngoal (1 subgoal):\n 1. list_all P (map snd (list_of_pdevs X))", "by (auto simp: list_all_iff list_of_pdevs_def)"], ["", "lemma pdevs_of_list_map_scaleR:\n  \"pdevs_of_list (map (scaleR r) xs) = scaleR_pdevs r (pdevs_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_list (map ((*\\<^sub>R) r) xs) =\n    scaleR_pdevs r (pdevs_of_list xs)", "by (auto intro!: pdevs_eqI simp: pdevs_apply_pdevs_of_list)"], ["", "lemma\n  map_permI:\n  assumes \"xs <~~> ys\"\n  shows \"map f xs <~~> map f ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f xs <~~> map f ys", "using assms"], ["proof (prove)\nusing this:\n  xs <~~> ys\n\ngoal (1 subgoal):\n 1. map f xs <~~> map f ys", "by induct auto"], ["", "lemma rev_perm: \"rev xs <~~> ys \\<longleftrightarrow> xs <~~> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev xs <~~> ys) = (xs <~~> ys)", "by (metis perm.trans perm_rev rev_rev_ident)"], ["", "lemma list_of_pdevs_perm_filter_nonzero:\n  \"map snd (list_of_pdevs X) <~~> (filter ((\\<noteq>) 0) (dense_list_of_pdevs X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (list_of_pdevs X) <~~>\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map snd (list_of_pdevs X) <~~>\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "have zip_map:\n    \"zip [0..<degree X] (dense_list_of_pdevs X) = map (\\<lambda>i. (i, pdevs_apply X i)) [0..<degree X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip [0..<degree X] (dense_list_of_pdevs X) =\n    map (\\<lambda>i. (i, pdevs_apply X i)) [0..<degree X]", "by (auto simp: dense_list_of_pdevs_def intro!: nth_equalityI)"], ["proof (state)\nthis:\n  zip [0..<degree X] (dense_list_of_pdevs X) =\n  map (\\<lambda>i. (i, pdevs_apply X i)) [0..<degree X]\n\ngoal (1 subgoal):\n 1. map snd (list_of_pdevs X) <~~>\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "have \"rev (list_of_pdevs X) <~~>\n      filter ((\\<noteq>) 0 o snd) (zip [0..<degree X] (dense_list_of_pdevs X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (list_of_pdevs X) <~~>\n    filter ((\\<noteq>) (0::'a) \\<circ> snd)\n     (zip [0..<degree X] (dense_list_of_pdevs X))", "by (auto simp: list_of_pdevs_eq o_def zip_map)"], ["proof (state)\nthis:\n  rev (list_of_pdevs X) <~~>\n  filter ((\\<noteq>) (0::'a) \\<circ> snd)\n   (zip [0..<degree X] (dense_list_of_pdevs X))\n\ngoal (1 subgoal):\n 1. map snd (list_of_pdevs X) <~~>\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "from map_permI[OF this, of snd]"], ["proof (chain)\npicking this:\n  map snd (rev (list_of_pdevs X)) <~~>\n  map snd\n   (filter ((\\<noteq>) (0::'a) \\<circ> snd)\n     (zip [0..<degree X] (dense_list_of_pdevs X)))", "have \"map snd (list_of_pdevs X) <~~>\n      map snd (filter ((\\<noteq>) 0 \\<circ> snd) (zip [0..<degree X] (dense_list_of_pdevs X)))\""], ["proof (prove)\nusing this:\n  map snd (rev (list_of_pdevs X)) <~~>\n  map snd\n   (filter ((\\<noteq>) (0::'a) \\<circ> snd)\n     (zip [0..<degree X] (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. map snd (list_of_pdevs X) <~~>\n    map snd\n     (filter ((\\<noteq>) (0::'a) \\<circ> snd)\n       (zip [0..<degree X] (dense_list_of_pdevs X)))", "by (simp add: rev_map[symmetric] rev_perm)"], ["proof (state)\nthis:\n  map snd (list_of_pdevs X) <~~>\n  map snd\n   (filter ((\\<noteq>) (0::'a) \\<circ> snd)\n     (zip [0..<degree X] (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. map snd (list_of_pdevs X) <~~>\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "also"], ["proof (state)\nthis:\n  map snd (list_of_pdevs X) <~~>\n  map snd\n   (filter ((\\<noteq>) (0::'a) \\<circ> snd)\n     (zip [0..<degree X] (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. map snd (list_of_pdevs X) <~~>\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "have \"map snd (filter ((\\<noteq>) 0 \\<circ> snd) (zip [0..<degree X] (dense_list_of_pdevs X))) =\n      filter ((\\<noteq>) 0) (dense_list_of_pdevs X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd\n     (filter ((\\<noteq>) (0::'a) \\<circ> snd)\n       (zip [0..<degree X] (dense_list_of_pdevs X))) =\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "using map_filter[of snd \"(\\<noteq>) 0\" \"(zip [0..<degree X] (dense_list_of_pdevs X))\"]"], ["proof (prove)\nusing this:\n  map snd\n   (filter (\\<lambda>x. (0::'a) \\<noteq> snd x)\n     (zip [0..<degree X] (dense_list_of_pdevs X))) =\n  filter ((\\<noteq>) (0::'a))\n   (map snd (zip [0..<degree X] (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. map snd\n     (filter ((\\<noteq>) (0::'a) \\<circ> snd)\n       (zip [0..<degree X] (dense_list_of_pdevs X))) =\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "by (simp add: o_def dense_list_of_pdevs_def)"], ["proof (state)\nthis:\n  map snd\n   (filter ((\\<noteq>) (0::'a) \\<circ> snd)\n     (zip [0..<degree X] (dense_list_of_pdevs X))) =\n  filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)\n\ngoal (1 subgoal):\n 1. map snd (list_of_pdevs X) <~~>\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "finally"], ["proof (chain)\npicking this:\n  map snd (list_of_pdevs X) <~~>\n  filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "show ?thesis"], ["proof (prove)\nusing this:\n  map snd (list_of_pdevs X) <~~>\n  filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)\n\ngoal (1 subgoal):\n 1. map snd (list_of_pdevs X) <~~>\n    filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "."], ["proof (state)\nthis:\n  map snd (list_of_pdevs X) <~~>\n  filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_val_filter:\n  assumes mem: \"e \\<in> UNIV \\<rightarrow> I\"\n  assumes \"0 \\<in> I\"\n  obtains e' where\n    \"pdevs_val e (pdevs_of_list (filter p xs)) = pdevs_val e' (pdevs_of_list xs)\"\n    \"e' \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding pdevs_val_filter_pdevs_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<lambda>_::nat. 0) \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. 0) \\<in> UNIV \\<rightarrow> I", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> UNIV \\<rightarrow> I\n  0 \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. 0) \\<in> UNIV \\<rightarrow> I", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>_. 0) \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"pdevs_val e (pdevs_of_list (filter p xs)) =\n      pdevs_val e (pdevs_of_list (filter p xs)) +\n      pdevs_val (\\<lambda>_. 0) (pdevs_of_list (filter (Not o p) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list (filter p xs)) =\n    pdevs_val e (pdevs_of_list (filter p xs)) +\n    pdevs_val (\\<lambda>_. 0) (pdevs_of_list (filter (Not \\<circ> p) xs))", "by (simp add: pdevs_val_sum)"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (filter p xs)) =\n  pdevs_val e (pdevs_of_list (filter p xs)) +\n  pdevs_val (\\<lambda>_. 0) (pdevs_of_list (filter (Not \\<circ> p) xs))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (filter p xs)) =\n  pdevs_val e (pdevs_of_list (filter p xs)) +\n  pdevs_val (\\<lambda>_. 0) (pdevs_of_list (filter (Not \\<circ> p) xs))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_pdevs_of_list_append[OF \\<open>e \\<in> _\\<close> \\<open>(\\<lambda>_. 0) \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>ea.\n      \\<lbrakk>pdevs_val e (pdevs_of_list ?xs) +\n               pdevs_val (\\<lambda>_. 0) (pdevs_of_list ?ys) =\n               pdevs_val ea (pdevs_of_list (?xs @ ?ys));\n       ea \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n      \"\\<dots> = pdevs_val e' (pdevs_of_list (filter p xs @ filter (Not o p) xs))\""], ["proof (prove)\nusing this:\n  (\\<And>ea.\n      \\<lbrakk>pdevs_val e (pdevs_of_list ?xs) +\n               pdevs_val (\\<lambda>_. 0) (pdevs_of_list ?ys) =\n               pdevs_val ea (pdevs_of_list (?xs @ ?ys));\n       ea \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list (filter p xs)) +\n         pdevs_val (\\<lambda>_. 0)\n          (pdevs_of_list (filter (Not \\<circ> p) xs)) =\n         pdevs_val e'\n          (pdevs_of_list (filter p xs @ filter (Not \\<circ> p) xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val e (pdevs_of_list (filter p xs)) +\n  pdevs_val (\\<lambda>_. 0) (pdevs_of_list (filter (Not \\<circ> p) xs)) =\n  pdevs_val e' (pdevs_of_list (filter p xs @ filter (Not \\<circ> p) xs))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (filter p xs)) +\n  pdevs_val (\\<lambda>_. 0) (pdevs_of_list (filter (Not \\<circ> p) xs)) =\n  pdevs_val e' (pdevs_of_list (filter p xs @ filter (Not \\<circ> p) xs))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (filter p xs)) +\n  pdevs_val (\\<lambda>_. 0) (pdevs_of_list (filter (Not \\<circ> p) xs)) =\n  pdevs_val e' (pdevs_of_list (filter p xs @ filter (Not \\<circ> p) xs))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_perm[OF partition_permI \\<open>e' \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>e'a.\n      \\<lbrakk>e'a \\<in> UNIV \\<rightarrow> I;\n       pdevs_val e'\n        (pdevs_of_list (filter ?p1 ?ys @ filter (Not \\<circ> ?p1) ?ys)) =\n       pdevs_val e'a (pdevs_of_list ?ys)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e'' where \"\\<dots> = pdevs_val e'' (pdevs_of_list xs)\" \"e'' \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\nusing this:\n  (\\<And>e'a.\n      \\<lbrakk>e'a \\<in> UNIV \\<rightarrow> I;\n       pdevs_val e'\n        (pdevs_of_list (filter ?p1 ?ys @ filter (Not \\<circ> ?p1) ?ys)) =\n       pdevs_val e'a (pdevs_of_list ?ys)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>pdevs_val e'\n                  (pdevs_of_list\n                    (filter p xs @ filter (Not \\<circ> p) xs)) =\n                 pdevs_val e'' (pdevs_of_list xs);\n         e'' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  pdevs_val e' (pdevs_of_list (filter p xs @ filter (Not \\<circ> p) xs)) =\n  pdevs_val e'' (pdevs_of_list xs)\n  e'' \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(1)"], ["proof (state)\nthis:\n  pdevs_val e' (pdevs_of_list (filter p xs @ filter (Not \\<circ> p) xs)) =\n  pdevs_val e'' (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (filter p xs)) =\n                 pdevs_val e' (pdevs_of_list xs);\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list (filter p xs)) =\n  pdevs_val e'' (pdevs_of_list xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (filter p xs)) =\n  pdevs_val e'' (pdevs_of_list xs)\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>e'' \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (filter p xs)) =\n  pdevs_val e'' (pdevs_of_list xs)\n  e'' \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  pdevs_val_of_list_of_pdevs:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  assumes \"0 \\<in> I\"\n  obtains e' where\n    \"pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) = pdevs_val e' X\"\n    \"e' \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n                 pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n                 pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n    and \"pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n      pdevs_val e' (pdevs_of_list (filter ((\\<noteq>) 0) (dense_list_of_pdevs X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n         pdevs_val e'\n          (pdevs_of_list\n            (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule pdevs_val_perm[OF list_of_pdevs_perm_filter_nonzero assms(1)])"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n  pdevs_val e'\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n                 pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n  pdevs_val e'\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n                 pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n  pdevs_val e'\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n                 pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_filter[OF \\<open>e' \\<in> _\\<close> \\<open>0 \\<in> I\\<close>, of \"(\\<noteq>) 0\" \"dense_list_of_pdevs X\"]"], ["proof (chain)\npicking this:\n  (\\<And>e'a.\n      \\<lbrakk>pdevs_val e'\n                (pdevs_of_list\n                  (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n               pdevs_val e'a (pdevs_of_list (dense_list_of_pdevs X));\n       e'a \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e'' where \"e'' \\<in> UNIV \\<rightarrow> I\"\n    and \"\\<dots> = pdevs_val e'' (pdevs_of_list (dense_list_of_pdevs X))\""], ["proof (prove)\nusing this:\n  (\\<And>e'a.\n      \\<lbrakk>pdevs_val e'\n                (pdevs_of_list\n                  (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n               pdevs_val e'a (pdevs_of_list (dense_list_of_pdevs X));\n       e'a \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>e'' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e'\n          (pdevs_of_list\n            (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n         pdevs_val e'' (pdevs_of_list (dense_list_of_pdevs X))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  e'' \\<in> UNIV \\<rightarrow> I\n  pdevs_val e'\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n  pdevs_val e'' (pdevs_of_list (dense_list_of_pdevs X))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n                 pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val e'\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n  pdevs_val e'' (pdevs_of_list (dense_list_of_pdevs X))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n                 pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e'\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n  pdevs_val e'' (pdevs_of_list (dense_list_of_pdevs X))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n                 pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = pdevs_val e'' X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e'' (pdevs_of_list (dense_list_of_pdevs X)) = pdevs_val e'' X", "by (simp add: pdevs_of_list_dense_list_of_pdevs)"], ["proof (state)\nthis:\n  pdevs_val e'' (pdevs_of_list (dense_list_of_pdevs X)) = pdevs_val e'' X\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) =\n                 pdevs_val e' X;\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) = pdevs_val e'' X", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) = pdevs_val e'' X\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>e'' \\<in> UNIV \\<rightarrow> I\\<close>"], ["proof (prove)\nusing this:\n  pdevs_val e (pdevs_of_list (map snd (list_of_pdevs X))) = pdevs_val e'' X\n  e'' \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  pdevs_val_of_list_of_pdevs2:\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains e' where\n    \"pdevs_val e X = pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)))\"\n    \"e' \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from list_of_pdevs_perm_filter_nonzero[of X]"], ["proof (chain)\npicking this:\n  map snd (list_of_pdevs X) <~~>\n  filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)", "have perm: \"(filter ((\\<noteq>) 0) (dense_list_of_pdevs X)) <~~> map snd (list_of_pdevs X)\""], ["proof (prove)\nusing this:\n  map snd (list_of_pdevs X) <~~>\n  filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X)\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X) <~~>\n    map snd (list_of_pdevs X)", "by (simp add: perm_sym)"], ["proof (state)\nthis:\n  filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X) <~~>\n  map snd (list_of_pdevs X)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"pdevs_val e X = pdevs_val e (pdevs_of_list (dense_list_of_pdevs X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e X = pdevs_val e (pdevs_of_list (dense_list_of_pdevs X))", "by (simp add: pdevs_of_list_dense_list_of_pdevs)"], ["proof (state)\nthis:\n  pdevs_val e X = pdevs_val e (pdevs_of_list (dense_list_of_pdevs X))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e X = pdevs_val e (pdevs_of_list (dense_list_of_pdevs X))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pdevs_val_partition[OF \\<open>e \\<in> _\\<close>, of \"dense_list_of_pdevs X\" \"(\\<noteq>) 0\"]"], ["proof (chain)\npicking this:\n  (\\<And>f g.\n      \\<lbrakk>pdevs_val e (pdevs_of_list (dense_list_of_pdevs X)) =\n               pdevs_val f\n                (pdevs_of_list\n                  (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) +\n               pdevs_val g\n                (pdevs_of_list\n                  (filter (Not \\<circ> (\\<noteq>) (0::'a))\n                    (dense_list_of_pdevs X)));\n       f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain f g where \"f \\<in> UNIV \\<rightarrow> I\" \"g \\<in> UNIV \\<rightarrow> I\"\n    \"\\<dots> = pdevs_val f (pdevs_of_list (filter ((\\<noteq>) 0) (dense_list_of_pdevs X))) +\n      pdevs_val g (pdevs_of_list (filter (Not \\<circ> (\\<noteq>) 0) (dense_list_of_pdevs X)))\"\n    (is \"_ = ?f + ?g\")"], ["proof (prove)\nusing this:\n  (\\<And>f g.\n      \\<lbrakk>pdevs_val e (pdevs_of_list (dense_list_of_pdevs X)) =\n               pdevs_val f\n                (pdevs_of_list\n                  (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) +\n               pdevs_val g\n                (pdevs_of_list\n                  (filter (Not \\<circ> (\\<noteq>) (0::'a))\n                    (dense_list_of_pdevs X)));\n       f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>f \\<in> UNIV \\<rightarrow> I; g \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list (dense_list_of_pdevs X)) =\n         pdevs_val f\n          (pdevs_of_list\n            (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) +\n         pdevs_val g\n          (pdevs_of_list\n            (filter (Not \\<circ> (\\<noteq>) (0::'a))\n              (dense_list_of_pdevs X)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  f \\<in> UNIV \\<rightarrow> I\n  g \\<in> UNIV \\<rightarrow> I\n  pdevs_val e (pdevs_of_list (dense_list_of_pdevs X)) =\n  pdevs_val f\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) +\n  pdevs_val g\n   (pdevs_of_list\n     (filter (Not \\<circ> (\\<noteq>) (0::'a)) (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(3)"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (dense_list_of_pdevs X)) =\n  pdevs_val f\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) +\n  pdevs_val g\n   (pdevs_of_list\n     (filter (Not \\<circ> (\\<noteq>) (0::'a)) (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list (dense_list_of_pdevs X)) =\n  pdevs_val f\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) +\n  pdevs_val g\n   (pdevs_of_list\n     (filter (Not \\<circ> (\\<noteq>) (0::'a)) (dense_list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"pdevs_of_list [x\\<leftarrow>dense_list_of_pdevs X . x = 0] = zero_pdevs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_of_list\n     (filter (\\<lambda>x. x = (0::'a)) (dense_list_of_pdevs X)) =\n    zero_pdevs", "by (auto intro!: pdevs_eqI simp: pdevs_apply_pdevs_of_list dest!: nth_mem)"], ["proof (state)\nthis:\n  pdevs_of_list (filter (\\<lambda>x. x = (0::'a)) (dense_list_of_pdevs X)) =\n  zero_pdevs\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"?g = 0\""], ["proof (prove)\nusing this:\n  pdevs_of_list (filter (\\<lambda>x. x = (0::'a)) (dense_list_of_pdevs X)) =\n  zero_pdevs\n\ngoal (1 subgoal):\n 1. pdevs_val g\n     (pdevs_of_list\n       (filter (Not \\<circ> (\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n    (0::'a)", "by (auto simp: o_def )"], ["proof (state)\nthis:\n  pdevs_val g\n   (pdevs_of_list\n     (filter (Not \\<circ> (\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  pdevs_val g\n   (pdevs_of_list\n     (filter (Not \\<circ> (\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain e' where \"e' \\<in> UNIV \\<rightarrow> I\"\n    and \"?f = pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> UNIV \\<rightarrow> I;\n         pdevs_val f\n          (pdevs_of_list\n            (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n         pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule pdevs_val_perm[OF perm \\<open>f \\<in> _\\<close>])"], ["proof (state)\nthis:\n  e' \\<in> UNIV \\<rightarrow> I\n  pdevs_val f\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  pdevs_val f\n   (pdevs_of_list (filter ((\\<noteq>) (0::'a)) (dense_list_of_pdevs X))) =\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>pdevs_val e X =\n                 pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X)));\n         e' \\<in> UNIV \\<rightarrow> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  pdevs_val e X =\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X))) + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  pdevs_val e X =\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X))) + (0::'a)\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>e' \\<in> UNIV \\<rightarrow> I\\<close>"], ["proof (prove)\nusing this:\n  pdevs_val e X =\n  pdevs_val e' (pdevs_of_list (map snd (list_of_pdevs X))) + (0::'a)\n  e' \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro!: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dense_list_of_pdevs_scaleR:\n  \"r \\<noteq> 0 \\<Longrightarrow> map ((*\\<^sub>R) r) (dense_list_of_pdevs x) = dense_list_of_pdevs (scaleR_pdevs r x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    map ((*\\<^sub>R) r) (dense_list_of_pdevs x) =\n    dense_list_of_pdevs (scaleR_pdevs r x)", "by (auto simp: dense_list_of_pdevs_def)"], ["", "lemma degree_pdevs_of_list_eq:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0) \\<Longrightarrow> degree (pdevs_of_list xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow>\n        x \\<noteq> (0::'a)) \\<Longrightarrow>\n    degree (pdevs_of_list xs) = length xs", "by (cases xs) (auto simp add: pdevs_apply_pdevs_of_list nth_Cons\n    intro!: degree_eqI\n    split: nat.split)"], ["", "lemma dense_list_of_pdevs_pdevs_of_list:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0) \\<Longrightarrow> dense_list_of_pdevs (pdevs_of_list xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow>\n        x \\<noteq> (0::'a)) \\<Longrightarrow>\n    dense_list_of_pdevs (pdevs_of_list xs) = xs", "by (auto simp: dense_list_of_pdevs_def degree_pdevs_of_list_eq pdevs_apply_pdevs_of_list\n    intro!: nth_equalityI)"], ["", "lemma pdevs_of_list_sum:\n  assumes \"distinct xs\"\n  assumes \"e \\<in> UNIV \\<rightarrow> I\"\n  obtains f where \"f \\<in> UNIV \\<rightarrow> I\" \"pdevs_val e (pdevs_of_list xs) = (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define f where \"f X = e (the (map_of (zip xs [0..<length xs]) X))\" for X"], ["proof (state)\nthis:\n  f ?X = e (the (map_of (zip xs [0..<length xs]) ?X))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  distinct xs\n  e \\<in> UNIV \\<rightarrow> I", "have \"f \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\nusing this:\n  distinct xs\n  e \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. f \\<in> UNIV \\<rightarrow> I", "by (auto simp: f_def)"], ["proof (state)\nthis:\n  f \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  f \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"pdevs_val e (pdevs_of_list xs) = (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (pdevs_of_list xs) = (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)", "by (auto simp add: pdevs_val_zip f_def assms sum_list_distinct_conv_sum_set[symmetric]\n      in_set_zip map_of_zip_upto2_length_eq_nth\n      intro!: sum_list_nth_eqI)"], ["proof (state)\nthis:\n  pdevs_val e (pdevs_of_list xs) = (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> UNIV \\<rightarrow> I;\n         pdevs_val e (pdevs_of_list xs) =\n         (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  f \\<in> UNIV \\<rightarrow> I\n  pdevs_val e (pdevs_of_list xs) = (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<in> UNIV \\<rightarrow> I\n  pdevs_val e (pdevs_of_list xs) = (\\<Sum>P\\<in>set xs. f P *\\<^sub>R P)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdevs_domain_eq_pdevs_of_list:\n  assumes nz: \"\\<And>x. x \\<in> set (xs) \\<Longrightarrow> x \\<noteq> 0\"\n  shows \"pdevs_domain (pdevs_of_list xs) = {0..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain (pdevs_of_list xs) = {0..<length xs}", "using nz"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. pdevs_domain (pdevs_of_list xs) = {0..<length xs}", "by (auto simp: pdevs_apply_pdevs_of_list split: if_split_asm)"], ["", "lemma length_list_of_pdevs_pdevs_of_list:\n  assumes nz: \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0\"\n  shows \"length (list_of_pdevs (pdevs_of_list xs)) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_of_pdevs (pdevs_of_list xs)) = length xs", "using nz"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. length (list_of_pdevs (pdevs_of_list xs)) = length xs", "by (auto simp: list_of_pdevs_def pdevs_domain_eq_pdevs_of_list)"], ["", "lemma nth_list_of_pdevs_pdevs_of_list:\n  assumes nz: \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0\"\n  assumes l: \"n < length xs\"\n  shows \"list_of_pdevs (pdevs_of_list xs) ! n  = ((length xs - Suc n), xs ! (length xs - Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_pdevs (pdevs_of_list xs) ! n =\n    (length xs - Suc n, xs ! (length xs - Suc n))", "using nz l"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<noteq> (0::'a)\n  n < length xs\n\ngoal (1 subgoal):\n 1. list_of_pdevs (pdevs_of_list xs) ! n =\n    (length xs - Suc n, xs ! (length xs - Suc n))", "by (auto simp: list_of_pdevs_def pdevs_domain_eq_pdevs_of_list rev_nth pdevs_apply_pdevs_of_list)"], ["", "lemma list_of_pdevs_pdevs_of_list_eq:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0) \\<Longrightarrow>\n    list_of_pdevs (pdevs_of_list xs) = zip (rev [0..<length xs]) (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow>\n        x \\<noteq> (0::'a)) \\<Longrightarrow>\n    list_of_pdevs (pdevs_of_list xs) = zip (rev [0..<length xs]) (rev xs)", "by (auto simp: nth_list_of_pdevs_pdevs_of_list length_list_of_pdevs_pdevs_of_list rev_nth\n    intro!: nth_equalityI)"], ["", "lemma sum_list_filter_list_of_pdevs_of_list:\n  fixes xs::\"'a::comm_monoid_add list\"\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<noteq> 0\"\n  shows \"sum_list (filter p (map snd (list_of_pdevs (pdevs_of_list xs)))) = sum_list (filter p xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (filter p (map snd (list_of_pdevs (pdevs_of_list xs)))) =\n    sum_list (filter p xs)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list (filter p (map snd (list_of_pdevs (pdevs_of_list xs)))) =\n    sum_list (filter p xs)", "by (auto simp: list_of_pdevs_pdevs_of_list_eq rev_filter[symmetric])"], ["", "lemma\n  sum_list_partition:\n  fixes xs::\"'a::comm_monoid_add list\"\n  shows \"sum_list (filter p xs) + sum_list (filter (Not o p) xs) = sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (filter p xs) + sum_list (filter (Not \\<circ> p) xs) =\n    sum_list xs", "by (induct xs) (auto simp: ac_simps)"], ["", "subsection \\<open>2d zonotopes\\<close>"], ["", "definition \"prod_of_pdevs x y = binop_pdevs Pair x y\""], ["", "lemma apply_pdevs_prod_of_pdevs[simp]:\n  \"pdevs_apply (prod_of_pdevs x y) i = (pdevs_apply x i, pdevs_apply y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (prod_of_pdevs x y) i = (pdevs_apply x i, pdevs_apply y i)", "unfolding prod_of_pdevs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (binop_pdevs Pair x y) i =\n    (pdevs_apply x i, pdevs_apply y i)", "by (simp add: zero_prod_def)"], ["", "lemma pdevs_domain_prod_of_pdevs[simp]:\n  \"pdevs_domain (prod_of_pdevs x y) = pdevs_domain x \\<union> pdevs_domain y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_domain (prod_of_pdevs x y) =\n    pdevs_domain x \\<union> pdevs_domain y", "by (auto simp: zero_prod_def)"], ["", "lemma pdevs_val_prod_of_pdevs[simp]:\n  \"pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)", "have \"pdevs_val e x = (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y. e i *\\<^sub>R pdevs_apply x i)\"\n    (is \"_ = ?x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e x =\n    (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n       e i *\\<^sub>R pdevs_apply x i)", "unfolding pdevs_val_pdevs_domain"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>pdevs_domain x. e i *\\<^sub>R pdevs_apply x i) =\n    (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n       e i *\\<^sub>R pdevs_apply x i)", "by (rule sum.mono_neutral_cong_left) auto"], ["proof (state)\nthis:\n  pdevs_val e x =\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply x i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)", "moreover"], ["proof (state)\nthis:\n  pdevs_val e x =\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply x i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)", "have \"pdevs_val e y = (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y. e i *\\<^sub>R pdevs_apply y i)\"\n    (is \"_ = ?y\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_val e y =\n    (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n       e i *\\<^sub>R pdevs_apply y i)", "unfolding pdevs_val_pdevs_domain"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>pdevs_domain y. e i *\\<^sub>R pdevs_apply y i) =\n    (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n       e i *\\<^sub>R pdevs_apply y i)", "by (rule sum.mono_neutral_cong_left) auto"], ["proof (state)\nthis:\n  pdevs_val e y =\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply y i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)", "ultimately"], ["proof (chain)\npicking this:\n  pdevs_val e x =\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply x i)\n  pdevs_val e y =\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply y i)", "have \"(pdevs_val e x, pdevs_val e y) = (?x, ?y)\""], ["proof (prove)\nusing this:\n  pdevs_val e x =\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply x i)\n  pdevs_val e y =\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply y i)\n\ngoal (1 subgoal):\n 1. (pdevs_val e x, pdevs_val e y) =\n    (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n       e i *\\<^sub>R pdevs_apply x i,\n     \\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n       e i *\\<^sub>R pdevs_apply y i)", "by auto"], ["proof (state)\nthis:\n  (pdevs_val e x, pdevs_val e y) =\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply x i,\n   \\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply y i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)", "also"], ["proof (state)\nthis:\n  (pdevs_val e x, pdevs_val e y) =\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply x i,\n   \\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply y i)\n\ngoal (1 subgoal):\n 1. pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)", "have \"\\<dots> = pdevs_val e (prod_of_pdevs x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n       e i *\\<^sub>R pdevs_apply x i,\n     \\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n       e i *\\<^sub>R pdevs_apply y i) =\n    pdevs_val e (prod_of_pdevs x y)", "by (simp add: sum_prod pdevs_val_pdevs_domain)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply x i,\n   \\<Sum>i\\<in>pdevs_domain x \\<union> pdevs_domain y.\n     e i *\\<^sub>R pdevs_apply y i) =\n  pdevs_val e (prod_of_pdevs x y)\n\ngoal (1 subgoal):\n 1. pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)", "finally"], ["proof (chain)\npicking this:\n  (pdevs_val e x, pdevs_val e y) = pdevs_val e (prod_of_pdevs x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  (pdevs_val e x, pdevs_val e y) = pdevs_val e (prod_of_pdevs x y)\n\ngoal (1 subgoal):\n 1. pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)", "by simp"], ["proof (state)\nthis:\n  pdevs_val e (prod_of_pdevs x y) = (pdevs_val e x, pdevs_val e y)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition prod_of_aforms (infixr \"\\<times>\\<^sub>a\" 80)\n  where \"prod_of_aforms x y = ((fst x, fst y), prod_of_pdevs (snd x) (snd y))\""], ["", "subsection \\<open>Intervals\\<close>"], ["", "definition One_pdevs_raw::\"nat \\<Rightarrow> 'a::executable_euclidean_space\"\n  where \"One_pdevs_raw i = (if i < length (Basis_list::'a list) then Basis_list ! i else 0)\""], ["", "lemma zeros_One_pdevs_raw:\n  \"One_pdevs_raw -` {0::'a::executable_euclidean_space} = {length (Basis_list::'a list)..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. One_pdevs_raw -` {0::'a} = {length Basis_list..}", "by (auto simp: One_pdevs_raw_def nonzero_Basis split: if_split_asm dest!: nth_mem)"], ["", "lemma nonzeros_One_pdevs_raw:\n  \"{i. One_pdevs_raw i \\<noteq> (0::'a::executable_euclidean_space)} = - {length (Basis_list::'a list)..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. One_pdevs_raw i \\<noteq> (0::'a)} = - {length Basis_list..}", "using zeros_One_pdevs_raw"], ["proof (prove)\nusing this:\n  One_pdevs_raw -` {0::?'a} = {length Basis_list..}\n\ngoal (1 subgoal):\n 1. {i. One_pdevs_raw i \\<noteq> (0::'a)} = - {length Basis_list..}", "by blast"], ["", "lift_definition One_pdevs::\"'a::executable_euclidean_space pdevs\" is One_pdevs_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. One_pdevs_raw i \\<noteq> (0::'a)}", "by (auto simp: nonzeros_One_pdevs_raw)"], ["", "lemma pdevs_apply_One_pdevs[simp]: \"pdevs_apply One_pdevs i =\n  (if i < length (Basis_list::'a::executable_euclidean_space list) then Basis_list ! i else 0::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply One_pdevs i =\n    (if i < length Basis_list then Basis_list ! i else (0::'a))", "by transfer (simp add: One_pdevs_raw_def)"], ["", "lemma Max_Collect_less_nat: \"Max {i::nat. i < k} = (if k = 0 then Max {} else k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {i. i < k} = (if k = 0 then Max {} else k - 1)", "by (auto intro!: Max_eqI)"], ["", "lemma degree_One_pdevs[simp]: \"degree (One_pdevs::'a pdevs) =\n    length (Basis_list::'a::executable_euclidean_space list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree One_pdevs = length Basis_list", "by (auto simp: degree_eq_Suc_max Basis_list_nth_nonzero Max_Collect_less_nat\n      intro!: Max_eqI DIM_positive)"], ["", "definition inner_scaleR_pdevs::\"'a::euclidean_space \\<Rightarrow> 'a pdevs \\<Rightarrow> 'a pdevs\"\n  where \"inner_scaleR_pdevs b x = unop_pdevs (\\<lambda>x. (b \\<bullet> x) *\\<^sub>R x) x\""], ["", "lemma pdevs_apply_inner_scaleR_pdevs[simp]:\n  \"pdevs_apply (inner_scaleR_pdevs a x) i = (a \\<bullet> (pdevs_apply x i)) *\\<^sub>R (pdevs_apply x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (inner_scaleR_pdevs a x) i =\n    (a \\<bullet> pdevs_apply x i) *\\<^sub>R pdevs_apply x i", "by (simp add: inner_scaleR_pdevs_def)"], ["", "lemma degree_inner_scaleR_pdevs_le:\n  \"degree (inner_scaleR_pdevs (l::'a::executable_euclidean_space) One_pdevs) \\<le>\n    degree (One_pdevs::'a pdevs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (inner_scaleR_pdevs l One_pdevs) \\<le> degree One_pdevs", "by (rule degree_leI) (auto simp: inner_scaleR_pdevs_def One_pdevs_raw_def)"], ["", "definition \"pdevs_of_ivl l u = scaleR_pdevs (1/2) (inner_scaleR_pdevs (u - l) One_pdevs)\""], ["", "lemma degree_pdevs_of_ivl_le:\n  \"degree (pdevs_of_ivl l u::'a::executable_euclidean_space pdevs) \\<le> DIM('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pdevs_of_ivl l u) \\<le> DIM('a)", "using degree_inner_scaleR_pdevs_le"], ["proof (prove)\nusing this:\n  degree (inner_scaleR_pdevs ?l One_pdevs) \\<le> degree One_pdevs\n\ngoal (1 subgoal):\n 1. degree (pdevs_of_ivl l u) \\<le> DIM('a)", "by (simp add: pdevs_of_ivl_def)"], ["", "lemma pdevs_apply_pdevs_of_ivl:\n  defines \"B \\<equiv> Basis_list::'a::executable_euclidean_space list\"\n  shows \"pdevs_apply (pdevs_of_ivl l u) i = (if i < length B then ((u - l)\\<bullet>(B!i)/2)*\\<^sub>R(B!i) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdevs_apply (pdevs_of_ivl l u) i =\n    (if i < length B then ((u - l) \\<bullet> B ! i / 2) *\\<^sub>R B ! i\n     else (0::'a))", "by (auto simp: pdevs_of_ivl_def B_def)"], ["", "lemma deg_length_less_imp[simp]:\n  \"k < degree (pdevs_of_ivl l u::'a::executable_euclidean_space pdevs) \\<Longrightarrow>\n    k < length (Basis_list::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < degree (pdevs_of_ivl l u) \\<Longrightarrow> k < length Basis_list", "by (metis (no_types, hide_lams) degree_One_pdevs degree_inner_scaleR_pdevs_le degree_scaleR_pdevs\n      dual_order.strict_trans length_Basis_list_pos nat_neq_iff not_le pdevs_of_ivl_def)"], ["", "lemma tdev_pdevs_of_ivl: \"tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "have \"tdev (pdevs_of_ivl l u) =\n    (\\<Sum>i <degree (pdevs_of_ivl l u). \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) =\n    (\\<Sum>i<degree (pdevs_of_ivl l u).\n        \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>)", "by (auto simp: tdev_def)"], ["proof (state)\nthis:\n  tdev (pdevs_of_ivl l u) =\n  (\\<Sum>i<degree (pdevs_of_ivl l u).\n      \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "also"], ["proof (state)\nthis:\n  tdev (pdevs_of_ivl l u) =\n  (\\<Sum>i<degree (pdevs_of_ivl l u).\n      \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "have \"\\<dots> = (\\<Sum>i = 0..<length (Basis_list::'a list). \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_ivl l u).\n        \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>) =\n    (\\<Sum>i = 0..<length Basis_list.\n        \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>)", "using degree_pdevs_of_ivl_le[of l u]"], ["proof (prove)\nusing this:\n  degree (pdevs_of_ivl l u) \\<le> DIM('a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree (pdevs_of_ivl l u).\n        \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>) =\n    (\\<Sum>i = 0..<length Basis_list.\n        \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>)", "by (intro sum.mono_neutral_cong_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_ivl l u).\n      \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>) =\n  (\\<Sum>i = 0..<length Basis_list.\n      \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree (pdevs_of_ivl l u).\n      \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>) =\n  (\\<Sum>i = 0..<length Basis_list.\n      \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "have \"\\<dots> = (\\<Sum>i = 0..<length (Basis_list::'a list).\n      \\<bar>((u - l) \\<bullet> Basis_list ! i / 2) *\\<^sub>R Basis_list ! i\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<length Basis_list.\n        \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>) =\n    (\\<Sum>i = 0..<length Basis_list.\n        \\<bar>((u - l) \\<bullet> Basis_list ! i / 2) *\\<^sub>R\n              Basis_list ! i\\<bar>)", "by (auto simp: pdevs_apply_pdevs_of_ivl)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<length Basis_list.\n      \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>) =\n  (\\<Sum>i = 0..<length Basis_list.\n      \\<bar>((u - l) \\<bullet> Basis_list ! i / 2) *\\<^sub>R\n            Basis_list ! i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<length Basis_list.\n      \\<bar>pdevs_apply (pdevs_of_ivl l u) i\\<bar>) =\n  (\\<Sum>i = 0..<length Basis_list.\n      \\<bar>((u - l) \\<bullet> Basis_list ! i / 2) *\\<^sub>R\n            Basis_list ! i\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "have \"\\<dots> = (\\<Sum>b \\<leftarrow> Basis_list. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R b\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<length Basis_list.\n        \\<bar>((u - l) \\<bullet> Basis_list ! i / 2) *\\<^sub>R\n              Basis_list ! i\\<bar>) =\n    (\\<Sum>b\\<leftarrow>Basis_list. \\<bar>((u - l) \\<bullet> b /\n     2) *\\<^sub>R\n    b\\<bar>)", "by (auto simp: sum_list_sum_nth)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<length Basis_list.\n      \\<bar>((u - l) \\<bullet> Basis_list ! i / 2) *\\<^sub>R\n            Basis_list ! i\\<bar>) =\n  (\\<Sum>b\\<leftarrow>Basis_list. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R\n  b\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<length Basis_list.\n      \\<bar>((u - l) \\<bullet> Basis_list ! i / 2) *\\<^sub>R\n            Basis_list ! i\\<bar>) =\n  (\\<Sum>b\\<leftarrow>Basis_list. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R\n  b\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "have \"\\<dots> = (\\<Sum>b\\<in>Basis. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R b\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<leftarrow>Basis_list. \\<bar>((u - l) \\<bullet> b /\n     2) *\\<^sub>R\n    b\\<bar>) =\n    (\\<Sum>b\\<in>Basis. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R b\\<bar>)", "by (auto simp: sum_list_distinct_conv_sum_set)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<leftarrow>Basis_list. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R\n  b\\<bar>) =\n  (\\<Sum>b\\<in>Basis. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R b\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<leftarrow>Basis_list. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R\n  b\\<bar>) =\n  (\\<Sum>b\\<in>Basis. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R b\\<bar>)\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "have \"\\<dots> = \\<bar>u - l\\<bar> /\\<^sub>R 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>Basis. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R b\\<bar>) =\n    \\<bar>u - l\\<bar> /\\<^sub>R 2", "by (subst euclidean_representation[symmetric, of \"\\<bar>u - l\\<bar> /\\<^sub>R 2\"])\n      (simp add:  abs_inner abs_scaleR)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>Basis. \\<bar>((u - l) \\<bullet> b / 2) *\\<^sub>R b\\<bar>) =\n  \\<bar>u - l\\<bar> /\\<^sub>R 2\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "finally"], ["proof (chain)\npicking this:\n  tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "show ?thesis"], ["proof (prove)\nusing this:\n  tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2\n\ngoal (1 subgoal):\n 1. tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2", "."], ["proof (state)\nthis:\n  tdev (pdevs_of_ivl l u) = \\<bar>u - l\\<bar> /\\<^sub>R 2\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"aform_of_ivl l u = ((l + u)/\\<^sub>R2, pdevs_of_ivl l u)\""], ["", "definition \"aform_of_point x = aform_of_ivl x x\""], ["", "lemma Elem_affine_of_ivl_le:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"l \\<le> u\"\n  shows \"l \\<le> aform_val e (aform_of_ivl l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> aform_val e (aform_of_ivl l u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<le> aform_val e (aform_of_ivl l u)", "have \"l =  (1 / 2) *\\<^sub>R l + (1 / 2) *\\<^sub>R l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = (1 / 2) *\\<^sub>R l + (1 / 2) *\\<^sub>R l", "by (simp add: scaleR_left_distrib[symmetric])"], ["proof (state)\nthis:\n  l = (1 / 2) *\\<^sub>R l + (1 / 2) *\\<^sub>R l\n\ngoal (1 subgoal):\n 1. l \\<le> aform_val e (aform_of_ivl l u)", "also"], ["proof (state)\nthis:\n  l = (1 / 2) *\\<^sub>R l + (1 / 2) *\\<^sub>R l\n\ngoal (1 subgoal):\n 1. l \\<le> aform_val e (aform_of_ivl l u)", "have \"\\<dots> = (l + u)/\\<^sub>R2 - tdev (pdevs_of_ivl l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R l + (1 / 2) *\\<^sub>R l =\n    (l + u) /\\<^sub>R 2 - tdev (pdevs_of_ivl l u)", "by (auto simp: assms tdev_pdevs_of_ivl algebra_simps)"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R l + (1 / 2) *\\<^sub>R l =\n  (l + u) /\\<^sub>R 2 - tdev (pdevs_of_ivl l u)\n\ngoal (1 subgoal):\n 1. l \\<le> aform_val e (aform_of_ivl l u)", "also"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R l + (1 / 2) *\\<^sub>R l =\n  (l + u) /\\<^sub>R 2 - tdev (pdevs_of_ivl l u)\n\ngoal (1 subgoal):\n 1. l \\<le> aform_val e (aform_of_ivl l u)", "have \"\\<dots> \\<le> aform_val e (aform_of_ivl l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l + u) /\\<^sub>R 2 - tdev (pdevs_of_ivl l u)\n    \\<le> aform_val e (aform_of_ivl l u)", "using abs_pdevs_val_le_tdev[OF assms(1), of \"pdevs_of_ivl l u\"]"], ["proof (prove)\nusing this:\n  \\<bar>pdevs_val e (pdevs_of_ivl l u)\\<bar> \\<le> tdev (pdevs_of_ivl l u)\n\ngoal (1 subgoal):\n 1. (l + u) /\\<^sub>R 2 - tdev (pdevs_of_ivl l u)\n    \\<le> aform_val e (aform_of_ivl l u)", "by (auto simp: aform_val_def aform_of_ivl_def minus_le_iff dest!: abs_le_D2)"], ["proof (state)\nthis:\n  (l + u) /\\<^sub>R 2 - tdev (pdevs_of_ivl l u)\n  \\<le> aform_val e (aform_of_ivl l u)\n\ngoal (1 subgoal):\n 1. l \\<le> aform_val e (aform_of_ivl l u)", "finally"], ["proof (chain)\npicking this:\n  l \\<le> aform_val e (aform_of_ivl l u)", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<le> aform_val e (aform_of_ivl l u)\n\ngoal (1 subgoal):\n 1. l \\<le> aform_val e (aform_of_ivl l u)", "."], ["proof (state)\nthis:\n  l \\<le> aform_val e (aform_of_ivl l u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Elem_affine_of_ivl_ge:\n  assumes \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\"\n  assumes \"l \\<le> u\"\n  shows \"aform_val e (aform_of_ivl l u) \\<le> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u) \\<le> u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u) \\<le> u", "have \"aform_val e (aform_of_ivl l u) \\<le>  (l + u)/\\<^sub>R2 + tdev (pdevs_of_ivl l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u)\n    \\<le> (l + u) /\\<^sub>R 2 + tdev (pdevs_of_ivl l u)", "using abs_pdevs_val_le_tdev[OF assms(1), of \"pdevs_of_ivl l u\"]"], ["proof (prove)\nusing this:\n  \\<bar>pdevs_val e (pdevs_of_ivl l u)\\<bar> \\<le> tdev (pdevs_of_ivl l u)\n\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u)\n    \\<le> (l + u) /\\<^sub>R 2 + tdev (pdevs_of_ivl l u)", "by (auto simp: aform_val_def aform_of_ivl_def minus_le_iff dest!: abs_le_D1)"], ["proof (state)\nthis:\n  aform_val e (aform_of_ivl l u)\n  \\<le> (l + u) /\\<^sub>R 2 + tdev (pdevs_of_ivl l u)\n\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u) \\<le> u", "also"], ["proof (state)\nthis:\n  aform_val e (aform_of_ivl l u)\n  \\<le> (l + u) /\\<^sub>R 2 + tdev (pdevs_of_ivl l u)\n\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u) \\<le> u", "have \"\\<dots> = (1 / 2) *\\<^sub>R u + (1 / 2) *\\<^sub>R u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l + u) /\\<^sub>R 2 + tdev (pdevs_of_ivl l u) =\n    (1 / 2) *\\<^sub>R u + (1 / 2) *\\<^sub>R u", "by (auto simp: assms tdev_pdevs_of_ivl algebra_simps)"], ["proof (state)\nthis:\n  (l + u) /\\<^sub>R 2 + tdev (pdevs_of_ivl l u) =\n  (1 / 2) *\\<^sub>R u + (1 / 2) *\\<^sub>R u\n\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u) \\<le> u", "also"], ["proof (state)\nthis:\n  (l + u) /\\<^sub>R 2 + tdev (pdevs_of_ivl l u) =\n  (1 / 2) *\\<^sub>R u + (1 / 2) *\\<^sub>R u\n\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u) \\<le> u", "have \"\\<dots> = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R u + (1 / 2) *\\<^sub>R u = u", "by (simp add: scaleR_left_distrib[symmetric])"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R u + (1 / 2) *\\<^sub>R u = u\n\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u) \\<le> u", "finally"], ["proof (chain)\npicking this:\n  aform_val e (aform_of_ivl l u) \\<le> u", "show ?thesis"], ["proof (prove)\nusing this:\n  aform_val e (aform_of_ivl l u) \\<le> u\n\ngoal (1 subgoal):\n 1. aform_val e (aform_of_ivl l u) \\<le> u", "."], ["proof (state)\nthis:\n  aform_val e (aform_of_ivl l u) \\<le> u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  map_of_zip_upto_length_eq_nth:\n  assumes \"i < length B\"\n  assumes \"d = length B\"\n  shows \"(map_of (zip [0..<d] B) i) = Some (B ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (zip [0..<d] B) i = Some (B ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (zip [0..<d] B) i = Some (B ! i)", "have \"length [0..<length B] = length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<length B] = length B", "by simp"], ["proof (state)\nthis:\n  length [0..<length B] = length B\n\ngoal (1 subgoal):\n 1. map_of (zip [0..<d] B) i = Some (B ! i)", "from map_of_zip_is_Some[OF this, of i] assms"], ["proof (chain)\npicking this:\n  (i \\<in> set [0..<length B]) =\n  (\\<exists>y. map_of (zip [0..<length B] B) i = Some y)\n  i < length B\n  d = length B", "have \"map_of (zip [0..<length B] B) i = Some (B ! i)\""], ["proof (prove)\nusing this:\n  (i \\<in> set [0..<length B]) =\n  (\\<exists>y. map_of (zip [0..<length B] B) i = Some y)\n  i < length B\n  d = length B\n\ngoal (1 subgoal):\n 1. map_of (zip [0..<length B] B) i = Some (B ! i)", "by (auto simp: in_set_zip)"], ["proof (state)\nthis:\n  map_of (zip [0..<length B] B) i = Some (B ! i)\n\ngoal (1 subgoal):\n 1. map_of (zip [0..<d] B) i = Some (B ! i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of (zip [0..<length B] B) i = Some (B ! i)\n\ngoal (1 subgoal):\n 1. map_of (zip [0..<d] B) i = Some (B ! i)", "by (simp add: assms)"], ["proof (state)\nthis:\n  map_of (zip [0..<d] B) i = Some (B ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_ivl_affine_of_ivlE:\n  assumes \"k \\<in> {l .. u}\"\n  obtains e where \"e \\<in> UNIV \\<rightarrow> {-1 .. 1}\" \"k = aform_val e (aform_of_ivl l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> UNIV \\<rightarrow> {- 1..1};\n         k = aform_val e (aform_of_ivl l u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "define e where [abs_def]: \"e i = (let b = if i <length (Basis_list::'a list) then\n    (the (map_of (zip [0..<length (Basis_list::'a list)] (Basis_list::'a list)) i)) else 0 in\n      ((k - (l + u) /\\<^sub>R 2) \\<bullet> b) / (((u - l) /\\<^sub>R 2) \\<bullet> b))\" for i"], ["proof (state)\nthis:\n  e \\<equiv>\n  \\<lambda>i.\n     let b = if i < length Basis_list\n             then the (map_of (zip [0..<length Basis_list] Basis_list) i)\n             else (0::'a)\n     in (k - (l + u) /\\<^sub>R 2) \\<bullet> b /\n        (((u - l) /\\<^sub>R 2) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "let ?B = \"Basis_list::'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "have \"k = (1 / 2) *\\<^sub>R (l + u) +\n      (\\<Sum>b \\<in> Basis. (if (u - l) \\<bullet> b = 0 then 0 else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b)) *\\<^sub>R b)\"\n    (is \"_ = _ + ?dots\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. k =\n    (1 / 2) *\\<^sub>R (l + u) +\n    (\\<Sum>b\\<in>Basis.\n       (if (u - l) \\<bullet> b = 0 then 0\n        else (k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R\n       b)", "using assms"], ["proof (prove)\nusing this:\n  k \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. k =\n    (1 / 2) *\\<^sub>R (l + u) +\n    (\\<Sum>b\\<in>Basis.\n       (if (u - l) \\<bullet> b = 0 then 0\n        else (k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R\n       b)", "by (force simp add: algebra_simps eucl_le[where 'a='a] intro!: euclidean_eqI[where 'a='a])"], ["proof (state)\nthis:\n  k =\n  (1 / 2) *\\<^sub>R (l + u) +\n  (\\<Sum>b\\<in>Basis.\n     (if (u - l) \\<bullet> b = 0 then 0\n      else (k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R\n     b)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "also"], ["proof (state)\nthis:\n  k =\n  (1 / 2) *\\<^sub>R (l + u) +\n  (\\<Sum>b\\<in>Basis.\n     (if (u - l) \\<bullet> b = 0 then 0\n      else (k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R\n     b)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "have\n    \"?dots = (\\<Sum>b \\<in> Basis. (if (u - l) \\<bullet> b = 0 then 0 else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>Basis.\n       (if (u - l) \\<bullet> b = 0 then 0\n        else (k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R\n       b) =\n    (\\<Sum>b\\<in>Basis.\n       if (u - l) \\<bullet> b = 0 then 0::'a\n       else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R b)", "by (auto intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>Basis.\n     (if (u - l) \\<bullet> b = 0 then 0\n      else (k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R\n     b) =\n  (\\<Sum>b\\<in>Basis.\n     if (u - l) \\<bullet> b = 0 then 0::'a\n     else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>Basis.\n     (if (u - l) \\<bullet> b = 0 then 0\n      else (k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R\n     b) =\n  (\\<Sum>b\\<in>Basis.\n     if (u - l) \\<bullet> b = 0 then 0::'a\n     else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "have \"\\<dots> = (\\<Sum>b \\<leftarrow> ?B. (if (u - l) \\<bullet> b = 0 then 0 else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>Basis.\n       if (u - l) \\<bullet> b = 0 then 0::'a\n       else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R b) =\n    (\\<Sum>b\\<leftarrow>Basis_list. if (u - l) \\<bullet> b = 0 then 0::'a\n                                    else ((k -\n     (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n    b) *\\<^sub>R\n   b)", "by (auto simp: sum_list_distinct_conv_sum_set)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>Basis.\n     if (u - l) \\<bullet> b = 0 then 0::'a\n     else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R b) =\n  (\\<Sum>b\\<leftarrow>Basis_list. if (u - l) \\<bullet> b = 0 then 0::'a\n                                  else ((k -\n   (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n  b) *\\<^sub>R\n b)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>Basis.\n     if (u - l) \\<bullet> b = 0 then 0::'a\n     else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> b) *\\<^sub>R b) =\n  (\\<Sum>b\\<leftarrow>Basis_list. if (u - l) \\<bullet> b = 0 then 0::'a\n                                  else ((k -\n   (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n  b) *\\<^sub>R\n b)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "have \"\\<dots> =\n    (\\<Sum>i = 0..<length ?B.\n        (if (u - l) \\<bullet> ?B ! i = 0 then 0 else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> ?B ! i) *\\<^sub>R ?B ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<leftarrow>Basis_list. if (u - l) \\<bullet> b = 0 then 0::'a\n                                    else ((k -\n     (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n    b) *\\<^sub>R\n   b) =\n    (\\<Sum>i = 0..<length Basis_list.\n        if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n        else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n              Basis_list ! i) *\\<^sub>R\n             Basis_list ! i)", "by (auto simp: sum_list_sum_nth)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<leftarrow>Basis_list. if (u - l) \\<bullet> b = 0 then 0::'a\n                                  else ((k -\n   (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n  b) *\\<^sub>R\n b) =\n  (\\<Sum>i = 0..<length Basis_list.\n      if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n      else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n            Basis_list ! i) *\\<^sub>R\n           Basis_list ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<leftarrow>Basis_list. if (u - l) \\<bullet> b = 0 then 0::'a\n                                  else ((k -\n   (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n  b) *\\<^sub>R\n b) =\n  (\\<Sum>i = 0..<length Basis_list.\n      if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n      else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n            Basis_list ! i) *\\<^sub>R\n           Basis_list ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "have \"\\<dots> =\n    (\\<Sum>i = 0..<degree (inner_scaleR_pdevs (u - l) One_pdevs).\n        (if (u - l) \\<bullet> Basis_list ! i = 0 then 0\n        else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> Basis_list ! i) *\\<^sub>R Basis_list ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<length Basis_list.\n        if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n        else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n              Basis_list ! i) *\\<^sub>R\n             Basis_list ! i) =\n    (\\<Sum>i = 0..<degree (inner_scaleR_pdevs (u - l) One_pdevs).\n        if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n        else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n              Basis_list ! i) *\\<^sub>R\n             Basis_list ! i)", "using degree_inner_scaleR_pdevs_le[of \"u - l\"]"], ["proof (prove)\nusing this:\n  degree (inner_scaleR_pdevs (u - l) One_pdevs) \\<le> degree One_pdevs\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<length Basis_list.\n        if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n        else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n              Basis_list ! i) *\\<^sub>R\n             Basis_list ! i) =\n    (\\<Sum>i = 0..<degree (inner_scaleR_pdevs (u - l) One_pdevs).\n        if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n        else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n              Basis_list ! i) *\\<^sub>R\n             Basis_list ! i)", "by (intro sum.mono_neutral_cong_right) (auto dest!: degree)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<length Basis_list.\n      if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n      else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n            Basis_list ! i) *\\<^sub>R\n           Basis_list ! i) =\n  (\\<Sum>i = 0..<degree (inner_scaleR_pdevs (u - l) One_pdevs).\n      if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n      else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n            Basis_list ! i) *\\<^sub>R\n           Basis_list ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<length Basis_list.\n      if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n      else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n            Basis_list ! i) *\\<^sub>R\n           Basis_list ! i) =\n  (\\<Sum>i = 0..<degree (inner_scaleR_pdevs (u - l) One_pdevs).\n      if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n      else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n            Basis_list ! i) *\\<^sub>R\n           Basis_list ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "have \"(1 / 2) *\\<^sub>R (l + u) +\n    (\\<Sum>i = 0..<degree (inner_scaleR_pdevs (u - l) One_pdevs).\n        (if (u - l) \\<bullet> Basis_list ! i = 0 then 0\n        else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet> Basis_list ! i) *\\<^sub>R Basis_list ! i)) =\n      aform_val e (aform_of_ivl l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R (l + u) +\n    (\\<Sum>i = 0..<degree (inner_scaleR_pdevs (u - l) One_pdevs).\n        if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n        else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n              Basis_list ! i) *\\<^sub>R\n             Basis_list ! i) =\n    aform_val e (aform_of_ivl l u)", "using degree_inner_scaleR_pdevs_le[of \"u - l\"]"], ["proof (prove)\nusing this:\n  degree (inner_scaleR_pdevs (u - l) One_pdevs) \\<le> degree One_pdevs\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R (l + u) +\n    (\\<Sum>i = 0..<degree (inner_scaleR_pdevs (u - l) One_pdevs).\n        if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n        else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n              Basis_list ! i) *\\<^sub>R\n             Basis_list ! i) =\n    aform_val e (aform_of_ivl l u)", "by (auto simp: aform_val_def aform_of_ivl_def pdevs_of_ivl_def map_of_zip_upto_length_eq_nth\n      e_def Let_def pdevs_val_sum\n      intro!: sum.cong)"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R (l + u) +\n  (\\<Sum>i = 0..<degree (inner_scaleR_pdevs (u - l) One_pdevs).\n      if (u - l) \\<bullet> Basis_list ! i = 0 then 0::'a\n      else ((k - (1 / 2) *\\<^sub>R (l + u)) \\<bullet>\n            Basis_list ! i) *\\<^sub>R\n           Basis_list ! i) =\n  aform_val e (aform_of_ivl l u)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "finally"], ["proof (chain)\npicking this:\n  k = aform_val e (aform_of_ivl l u)", "have \"k = aform_val e (aform_of_ivl l u)\""], ["proof (prove)\nusing this:\n  k = aform_val e (aform_of_ivl l u)\n\ngoal (1 subgoal):\n 1. k = aform_val e (aform_of_ivl l u)", "."], ["proof (state)\nthis:\n  k = aform_val e (aform_of_ivl l u)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "moreover"], ["proof (state)\nthis:\n  k = aform_val e (aform_of_ivl l u)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "{"], ["proof (state)\nthis:\n  k = aform_val e (aform_of_ivl l u)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "fix k l u::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "assume *: \"l \\<le> k\" \"k \\<le> u\""], ["proof (state)\nthis:\n  l \\<le> k\n  k \\<le> u\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "let ?m = \"l / 2 + u / 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "have \"\\<bar>k - ?m\\<bar> \\<le> \\<bar>if k \\<le> ?m then ?m - l else u - ?m\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>k - (l / 2 + u / 2)\\<bar>\n    \\<le> \\<bar>if k \\<le> l / 2 + u / 2 then l / 2 + u / 2 - l\n                else u - (l / 2 + u / 2)\\<bar>", "using *"], ["proof (prove)\nusing this:\n  l \\<le> k\n  k \\<le> u\n\ngoal (1 subgoal):\n 1. \\<bar>k - (l / 2 + u / 2)\\<bar>\n    \\<le> \\<bar>if k \\<le> l / 2 + u / 2 then l / 2 + u / 2 - l\n                else u - (l / 2 + u / 2)\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>k - (l / 2 + u / 2)\\<bar>\n  \\<le> \\<bar>if k \\<le> l / 2 + u / 2 then l / 2 + u / 2 - l\n              else u - (l / 2 + u / 2)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "also"], ["proof (state)\nthis:\n  \\<bar>k - (l / 2 + u / 2)\\<bar>\n  \\<le> \\<bar>if k \\<le> l / 2 + u / 2 then l / 2 + u / 2 - l\n              else u - (l / 2 + u / 2)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "have \"\\<dots> \\<le> \\<bar>u / 2 - l / 2\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>if k \\<le> l / 2 + u / 2 then l / 2 + u / 2 - l\n          else u - (l / 2 + u / 2)\\<bar>\n    \\<le> \\<bar>u / 2 - l / 2\\<bar>", "by (auto simp: abs_real_def)"], ["proof (state)\nthis:\n  \\<bar>if k \\<le> l / 2 + u / 2 then l / 2 + u / 2 - l\n        else u - (l / 2 + u / 2)\\<bar>\n  \\<le> \\<bar>u / 2 - l / 2\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>k - (l / 2 + u / 2)\\<bar> \\<le> \\<bar>u / 2 - l / 2\\<bar>", "have \"\\<bar>k - (l / 2 + u / 2)\\<bar> \\<le> \\<bar>u / 2 - l/2\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>k - (l / 2 + u / 2)\\<bar> \\<le> \\<bar>u / 2 - l / 2\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>k - (l / 2 + u / 2)\\<bar> \\<le> \\<bar>u / 2 - l / 2\\<bar>", "."], ["proof (state)\nthis:\n  \\<bar>k - (l / 2 + u / 2)\\<bar> \\<le> \\<bar>u / 2 - l / 2\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?la2 \\<le> ?ka2; ?ka2 \\<le> ?ua2\\<rbrakk>\n  \\<Longrightarrow> \\<bar>?ka2 - (?la2 / 2 + ?ua2 / 2)\\<bar>\n                    \\<le> \\<bar>?ua2 / 2 - ?la2 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "note midpoint_abs = this"], ["proof (state)\nthis:\n  \\<lbrakk>?la2 \\<le> ?ka2; ?ka2 \\<le> ?ua2\\<rbrakk>\n  \\<Longrightarrow> \\<bar>?ka2 - (?la2 / 2 + ?ua2 / 2)\\<bar>\n                    \\<le> \\<bar>?ua2 / 2 - ?la2 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "have \"e \\<in> UNIV \\<rightarrow> {- 1..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1}", "using assms"], ["proof (prove)\nusing this:\n  k \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. e \\<in> UNIV \\<rightarrow> {- 1..1}", "unfolding e_def Let_def"], ["proof (prove)\nusing this:\n  k \\<in> {l..u}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        (k - (l + u) /\\<^sub>R 2) \\<bullet>\n        (if i < length Basis_list\n         then the (map_of (zip [0..<length Basis_list] Basis_list) i)\n         else (0::'a)) /\n        (((u - l) /\\<^sub>R 2) \\<bullet>\n         (if i < length Basis_list\n          then the (map_of (zip [0..<length Basis_list] Basis_list) i)\n          else (0::'a))))\n    \\<in> UNIV \\<rightarrow> {- 1..1}", "by (intro Pi_I divide_atLeastAtMost_1_absI)\n      (auto simp: map_of_zip_upto_length_eq_nth eucl_le[where 'a='a]\n        divide_le_eq_1 not_less inner_Basis algebra_simps intro!: midpoint_abs\n        dest!: nth_mem)"], ["proof (state)\nthis:\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "ultimately"], ["proof (chain)\npicking this:\n  k = aform_val e (aform_of_ivl l u)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}", "show \"\\<exists>e. e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and> k = aform_val e (aform_of_ivl l u)\""], ["proof (prove)\nusing this:\n  k = aform_val e (aform_of_ivl l u)\n  e \\<in> UNIV \\<rightarrow> {- 1..1}\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n       k = aform_val e (aform_of_ivl l u)", "by blast"], ["proof (state)\nthis:\n  \\<exists>e.\n     e \\<in> UNIV \\<rightarrow> {- 1..1} \\<and>\n     k = aform_val e (aform_of_ivl l u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Inf_aform_aform_of_ivl:\n  assumes \"l \\<le> u\"\n  shows \"Inf_aform (aform_of_ivl l u) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_aform (aform_of_ivl l u) = l", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> u\n\ngoal (1 subgoal):\n 1. Inf_aform (aform_of_ivl l u) = l", "by (auto simp: Inf_aform_def aform_of_ivl_def tdev_pdevs_of_ivl abs_diff_eq1 algebra_simps)\n    (metis field_sum_of_halves scaleR_add_left scaleR_one)"], ["", "lemma Sup_aform_aform_of_ivl:\n  assumes \"l \\<le> u\"\n  shows \"Sup_aform (aform_of_ivl l u) = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_aform (aform_of_ivl l u) = u", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> u\n\ngoal (1 subgoal):\n 1. Sup_aform (aform_of_ivl l u) = u", "by (auto simp: Sup_aform_def aform_of_ivl_def tdev_pdevs_of_ivl abs_diff_eq1 algebra_simps)\n    (metis field_sum_of_halves scaleR_add_left scaleR_one)"], ["", "lemma Affine_aform_of_ivl:\n  \"a \\<le> b \\<Longrightarrow> Affine (aform_of_ivl a b) = {a .. b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> Affine (aform_of_ivl a b) = {a..b}", "by (force simp: Affine_def valuate_def intro!: Elem_affine_of_ivl_ge Elem_affine_of_ivl_le\n    elim!: in_ivl_affine_of_ivlE)"], ["", "end"]]}