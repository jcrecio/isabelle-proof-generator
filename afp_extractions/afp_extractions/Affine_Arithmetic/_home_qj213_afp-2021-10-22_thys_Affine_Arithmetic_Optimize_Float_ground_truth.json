{"file_name": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic/Optimize_Float.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Affine_Arithmetic", "problem_names": ["lemma compute_bitlen[code]: \"bitlen a = (if a > 0 then log2 a + 1 else 0)\"", "lemma compute_float_plus[code]: \"Float m1 e1 + Float m2 e2 =\n  (if m1 = 0 then Float m2 e2 else if m2 = 0 then Float m1 e1 else\n  if e1 \\<le> e2 then Float (m1 + m2 * power_int 2 (e2 - e1)) e1\n              else Float (m2 + m1 * power_int 2 (e1 - e2)) e2)\"", "lemma compute_real_of_float[code]:\n  \"real_of_float (Float m e) = (if e \\<ge> 0 then m * 2 ^ nat e else m / power_int 2 (-e))\"", "lemma compute_float_down[code]:\n  \"float_down p (Float m e) =\n    (if p + e < 0 then Float (m div power_int 2 (-(p + e))) (-p) else Float m e)\"", "lemma compute_lapprox_posrat[code]:\n  fixes prec::nat and x y::nat\n  shows \"lapprox_posrat prec x y =\n   (let\n       l = rat_precision prec x y;\n       d = if 0 \\<le> l then int x * power_int 2 l div y else int x div power_int 2 (- l) div y\n    in normfloat (Float d (- l)))\"", "lemma compute_rapprox_posrat[code]:\n  fixes prec x y\n  defines \"l \\<equiv> rat_precision prec x y\"\n  shows \"rapprox_posrat prec x y = (let\n     l = l ;\n     (r, s) = if 0 \\<le> l then (int x * power_int 2 l, int y) else (int x, int y * power_int 2 (-l)) ;\n     d = r div s ;\n     m = r mod s\n   in normfloat (Float (d + (if m = 0 \\<or> y = 0 then 0 else 1)) (- l)))\"", "lemma compute_float_truncate_down[code]:\n  \"float_round_down prec (Float m e) = (let d = bitlen (abs m) - int prec - 1 in\n    if 0 < d then let P = power_int 2 d ; n = m div P in Float n (e + d)\n             else Float m e)\"", "lemma compute_int_floor_fl[code]:\n  \"int_floor_fl (Float m e) = (if 0 \\<le> e then m * power_int 2 e else m div (power_int 2 (-e)))\"", "lemma compute_floor_fl[code]:\n  \"floor_fl (Float m e) = (if 0 \\<le> e then Float m e else Float (m div (power_int 2 ((-e)))) 0)\""], "translations": [["", "lemma compute_bitlen[code]: \"bitlen a = (if a > 0 then log2 a + 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitlen a = (if 0 < a then log2 a + 1 else 0)", "by (simp add: bitlen_alt_def log2_def)"], ["", "lemma compute_float_plus[code]: \"Float m1 e1 + Float m2 e2 =\n  (if m1 = 0 then Float m2 e2 else if m2 = 0 then Float m1 e1 else\n  if e1 \\<le> e2 then Float (m1 + m2 * power_int 2 (e2 - e1)) e1\n              else Float (m2 + m1 * power_int 2 (e1 - e2)) e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Float m1 e1 + Float m2 e2 =\n    (if m1 = 0 then Float m2 e2\n     else if m2 = 0 then Float m1 e1\n          else if e1 \\<le> e2\n               then Float (m1 + m2 * Optimize_Integer.power_int 2 (e2 - e1))\n                     e1\n               else Float (m2 + m1 * Optimize_Integer.power_int 2 (e1 - e2))\n                     e2)", "by (simp add: Float.compute_float_plus power_int_def)"], ["", "lemma compute_real_of_float[code]:\n  \"real_of_float (Float m e) = (if e \\<ge> 0 then m * 2 ^ nat e else m / power_int 2 (-e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float (Float m e) =\n    (if 0 \\<le> e then real_of_int m * 2 ^ nat e\n     else real_of_int m / real_of_int (Optimize_Integer.power_int 2 (- e)))", "unfolding power_int_def[symmetric, of 2 e]"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_float (Float m e) =\n    (if 0 \\<le> e then real_of_int m * 2 ^ nat e\n     else real_of_int m / real_of_int (Optimize_Integer.power_int 2 (- e)))", "using compute_real_of_float power_int_def"], ["proof (prove)\nusing this:\n  real_of_float (Float ?m ?e) =\n  (if 0 \\<le> ?e then real_of_int ?m * 2 ^ nat ?e\n   else real_of_int ?m / 2 ^ nat (- ?e))\n  Optimize_Integer.power_int ?a ?b = ?a ^ nat ?b\n\ngoal (1 subgoal):\n 1. real_of_float (Float m e) =\n    (if 0 \\<le> e then real_of_int m * 2 ^ nat e\n     else real_of_int m / real_of_int (Optimize_Integer.power_int 2 (- e)))", "by auto"], ["", "lemma compute_float_down[code]:\n  \"float_down p (Float m e) =\n    (if p + e < 0 then Float (m div power_int 2 (-(p + e))) (-p) else Float m e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. float_down p (Float m e) =\n    (if p + e < 0\n     then Float (m div Optimize_Integer.power_int 2 (- (p + e))) (- p)\n     else Float m e)", "by (simp add: Float.compute_float_down power_int_def)"], ["", "lemma compute_lapprox_posrat[code]:\n  fixes prec::nat and x y::nat\n  shows \"lapprox_posrat prec x y =\n   (let\n       l = rat_precision prec x y;\n       d = if 0 \\<le> l then int x * power_int 2 l div y else int x div power_int 2 (- l) div y\n    in normfloat (Float d (- l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lapprox_posrat prec x y =\n    (let l = rat_precision prec (int x) (int y);\n         d = if 0 \\<le> l\n             then int x * Optimize_Integer.power_int 2 l div int y\n             else int x div Optimize_Integer.power_int 2 (- l) div int y\n     in normfloat (Float d (- l)))", "by (auto simp add: Float.compute_lapprox_posrat power_int_def Let_def zdiv_int of_nat_power of_nat_mult)"], ["", "lemma compute_rapprox_posrat[code]:\n  fixes prec x y\n  defines \"l \\<equiv> rat_precision prec x y\"\n  shows \"rapprox_posrat prec x y = (let\n     l = l ;\n     (r, s) = if 0 \\<le> l then (int x * power_int 2 l, int y) else (int x, int y * power_int 2 (-l)) ;\n     d = r div s ;\n     m = r mod s\n   in normfloat (Float (d + (if m = 0 \\<or> y = 0 then 0 else 1)) (- l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rapprox_posrat prec x y =\n    (let l = l;\n         (r, s) =\n           if 0 \\<le> l then (int x * Optimize_Integer.power_int 2 l, int y)\n           else (int x, int y * Optimize_Integer.power_int 2 (- l));\n         d = r div s; m = r mod s\n     in normfloat (Float (d + (if m = 0 \\<or> y = 0 then 0 else 1)) (- l)))", "by (auto simp add: l_def Float.compute_rapprox_posrat power_int_def Let_def zdiv_int of_nat_power of_nat_mult)"], ["", "lemma compute_float_truncate_down[code]:\n  \"float_round_down prec (Float m e) = (let d = bitlen (abs m) - int prec - 1 in\n    if 0 < d then let P = power_int 2 d ; n = m div P in Float n (e + d)\n             else Float m e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. float_round_down prec (Float m e) =\n    (let d = bitlen \\<bar>m\\<bar> - int prec - 1\n     in if 0 < d\n        then let P = Optimize_Integer.power_int 2 d; n = m div P\n             in Float n (e + d)\n        else Float m e)", "by (simp add: Float.compute_float_round_down power_int_def cong: if_cong)"], ["", "lemma compute_int_floor_fl[code]:\n  \"int_floor_fl (Float m e) = (if 0 \\<le> e then m * power_int 2 e else m div (power_int 2 (-e)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_floor_fl (Float m e) =\n    (if 0 \\<le> e then m * Optimize_Integer.power_int 2 e\n     else m div Optimize_Integer.power_int 2 (- e))", "by (simp add: Float.compute_int_floor_fl power_int_def)"], ["", "lemma compute_floor_fl[code]:\n  \"floor_fl (Float m e) = (if 0 \\<le> e then Float m e else Float (m div (power_int 2 ((-e)))) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. floor_fl (Float m e) =\n    (if 0 \\<le> e then Float m e\n     else Float (m div Optimize_Integer.power_int 2 (- e)) 0)", "by (simp add: Float.compute_floor_fl power_int_def)"], ["", "end"]]}