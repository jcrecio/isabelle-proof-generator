{"file_name": "/home/qj213/afp-2021-10-22/thys/Landau_Symbols/Group_Sort.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Landau_Symbols", "problem_names": ["lemma groupsort_locale: \"groupsort f merge g\"", "lemmas part_aux_induct = part_aux.induct[split_format (complete), OF groupsort_locale]", "lemma part: \n  \"part p xs = (rev (filter (\\<lambda>x. f x < f p) xs), \n     p # filter (\\<lambda>x. f x = f p) xs, rev (filter (\\<lambda>x. f x > f p) xs))\"", "lemma filter_mset_union:\n  assumes \"\\<And>x. x \\<in># A \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<Longrightarrow> False\"\n  shows \"filter_mset P A + filter_mset Q A = filter_mset (\\<lambda>x. P x \\<or> Q x) A\" (is \"?lhs = ?rhs\")", "lemma multiset_of_sort: \"mset (sort xs) = mset xs\"", "lemma g_sort: \"g (sort xs) = g xs\"", "lemma set_sort: \"set (sort xs) = set xs\"", "lemma sorted_all_equal: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x = y) \\<Longrightarrow> sorted xs\"", "lemma sorted_sort: \"sorted (map f (sort xs))\"", "lemma f_fold_merge: \"(\\<And>y. y \\<in> set xs \\<Longrightarrow> f y = f x) \\<Longrightarrow> f (fold merge xs x) = f x\"", "lemma f_group: \"x \\<in> set (group xs) \\<Longrightarrow> \\<exists>x'\\<in>set xs. f x = f x'\"", "lemma sorted_group: \"sorted (map f xs) \\<Longrightarrow> sorted (map f (group xs))\"", "lemma distinct_group: \"distinct (map f (group xs))\"", "lemma g_fold_same:\n  assumes \"\\<And>z. z \\<in> set xs \\<Longrightarrow> f z = f x\"\n  shows   \"g (fold merge xs x # ys) = g (x#xs@ys)\"", "lemma g_group: \"g (group xs) = g xs\"", "lemmas group_part_aux_induct = \n  group_part_aux.induct[split_format (complete), OF groupsort_locale]", "lemma group_part: \n  \"group_part p xs = (rev (filter (\\<lambda>x. f x < f p) xs), \n     fold merge (filter (\\<lambda>x. f x = f p) xs) p, rev (filter (\\<lambda>x. f x > f p) xs))\"", "lemma group_append:\n  assumes \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> f x \\<noteq> f y\"\n  shows   \"group (xs @ ys) = group xs @ group ys\"", "lemma group_empty_iff [simp]: \"group xs = [] \\<longleftrightarrow> xs = []\"", "lemma group_sort_correct: \"group_sort xs = group (sort xs)\"", "lemma sorted_group_sort: \"sorted (map f (group_sort xs))\"", "lemma distinct_group_sort: \"distinct (map f (group_sort xs))\"", "lemma g_group_sort: \"g (group_sort xs) = g xs\"", "lemmas [simp del] = group_sort.simps group_part_aux.simps"], "translations": [["", "lemma groupsort_locale: \"groupsort f merge g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. groupsort f merge g", "by unfold_locales"], ["", "private"], ["", "lemmas part_aux_induct = part_aux.induct[split_format (complete), OF groupsort_locale]"], ["", "private"], ["", "definition part where \"part p xs = part_aux (f p) xs ([], [p], [])\""], ["", "private"], ["", "lemma part: \n  \"part p xs = (rev (filter (\\<lambda>x. f x < f p) xs), \n     p # filter (\\<lambda>x. f x = f p) xs, rev (filter (\\<lambda>x. f x > f p) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "fix p xs ls eq gs"], ["proof (state)\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "have \"fst (part_aux p xs (ls, eq, gs)) = rev (filter (\\<lambda>x. f x < p) xs) @ ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (part_aux p xs (ls, eq, gs)) =\n    rev (filter (\\<lambda>x. f x < p) xs) @ ls", "by (induction p xs ls eq gs rule: part_aux_induct) simp_all"], ["proof (state)\nthis:\n  fst (part_aux p xs (ls, eq, gs)) =\n  rev (filter (\\<lambda>x. f x < p) xs) @ ls\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "}"], ["proof (state)\nthis:\n  fst (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2)) =\n  rev (filter (\\<lambda>x. f x < ?pa2) ?xsa2) @ ?ls2\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "note A = this"], ["proof (state)\nthis:\n  fst (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2)) =\n  rev (filter (\\<lambda>x. f x < ?pa2) ?xsa2) @ ?ls2\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "{"], ["proof (state)\nthis:\n  fst (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2)) =\n  rev (filter (\\<lambda>x. f x < ?pa2) ?xsa2) @ ?ls2\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "fix p xs ls eq gs"], ["proof (state)\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "have \"snd (snd (part_aux p xs (ls, eq, gs))) = rev (filter (\\<lambda>x. f x > p) xs) @ gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (part_aux p xs (ls, eq, gs))) =\n    rev (filter (\\<lambda>x. p < f x) xs) @ gs", "by (induction p xs ls eq gs rule: part_aux_induct) simp_all"], ["proof (state)\nthis:\n  snd (snd (part_aux p xs (ls, eq, gs))) =\n  rev (filter (\\<lambda>x. p < f x) xs) @ gs\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "}"], ["proof (state)\nthis:\n  snd (snd (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  rev (filter (\\<lambda>x. ?pa2 < f x) ?xsa2) @ ?gs2\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "note B = this"], ["proof (state)\nthis:\n  snd (snd (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  rev (filter (\\<lambda>x. ?pa2 < f x) ?xsa2) @ ?gs2\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "{"], ["proof (state)\nthis:\n  snd (snd (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  rev (filter (\\<lambda>x. ?pa2 < f x) ?xsa2) @ ?gs2\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "fix p xs ls eq gs"], ["proof (state)\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "have \"fst (snd (part_aux p xs (ls, eq, gs))) = eq @ filter (\\<lambda>x. f x = p) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (part_aux p xs (ls, eq, gs))) =\n    eq @ filter (\\<lambda>x. f x = p) xs", "by (induction p xs ls eq gs rule: part_aux_induct) auto"], ["proof (state)\nthis:\n  fst (snd (part_aux p xs (ls, eq, gs))) =\n  eq @ filter (\\<lambda>x. f x = p) xs\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "}"], ["proof (state)\nthis:\n  fst (snd (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  ?eq2 @ filter (\\<lambda>x. f x = ?pa2) ?xsa2\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "note C = this"], ["proof (state)\nthis:\n  fst (snd (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  ?eq2 @ filter (\\<lambda>x. f x = ?pa2) ?xsa2\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "note ABC = A B C"], ["proof (state)\nthis:\n  fst (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2)) =\n  rev (filter (\\<lambda>x. f x < ?pa2) ?xsa2) @ ?ls2\n  snd (snd (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  rev (filter (\\<lambda>x. ?pa2 < f x) ?xsa2) @ ?gs2\n  fst (snd (part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  ?eq2 @ filter (\\<lambda>x. f x = ?pa2) ?xsa2\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "from ABC[of \"f p\" xs \"[]\" \"[p]\" \"[]\"]"], ["proof (chain)\npicking this:\n  fst (part_aux (f p) xs ([], [p], [])) =\n  rev (filter (\\<lambda>x. f x < f p) xs) @ []\n  snd (snd (part_aux (f p) xs ([], [p], []))) =\n  rev (filter (\\<lambda>x. f p < f x) xs) @ []\n  fst (snd (part_aux (f p) xs ([], [p], []))) =\n  [p] @ filter (\\<lambda>x. f x = f p) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (part_aux (f p) xs ([], [p], [])) =\n  rev (filter (\\<lambda>x. f x < f p) xs) @ []\n  snd (snd (part_aux (f p) xs ([], [p], []))) =\n  rev (filter (\\<lambda>x. f p < f x) xs) @ []\n  fst (snd (part_aux (f p) xs ([], [p], []))) =\n  [p] @ filter (\\<lambda>x. f x = f p) xs\n\ngoal (1 subgoal):\n 1. part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "unfolding part_def"], ["proof (prove)\nusing this:\n  fst (part_aux (f p) xs ([], [p], [])) =\n  rev (filter (\\<lambda>x. f x < f p) xs) @ []\n  snd (snd (part_aux (f p) xs ([], [p], []))) =\n  rev (filter (\\<lambda>x. f p < f x) xs) @ []\n  fst (snd (part_aux (f p) xs ([], [p], []))) =\n  [p] @ filter (\\<lambda>x. f x = f p) xs\n\ngoal (1 subgoal):\n 1. part_aux (f p) xs ([], [p], []) =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     p # filter (\\<lambda>x. f x = f p) xs,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "by (intro prod_eqI) simp_all"], ["proof (state)\nthis:\n  part p xs =\n  (rev (filter (\\<lambda>x. f x < f p) xs),\n   p # filter (\\<lambda>x. f x = f p) xs,\n   rev (filter (\\<lambda>x. f p < f x) xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "function sort :: \"'a list \\<Rightarrow> 'a list\" where\n  \"sort [] = []\"\n| \"sort (x#xs) = (case part x xs of (ls, eq, gs) \\<Rightarrow> sort ls @ eq @ sort gs)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>xa xs. x = xa # xs \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> [] = []\n 3. \\<And>x xs.\n       [] = x # xs \\<Longrightarrow>\n       [] =\n       (case part x xs of\n        (ls, eq, gs) \\<Rightarrow> sort_sumC ls @ eq @ sort_sumC gs)\n 4. \\<And>x xs xa xsa.\n       x # xs = xa # xsa \\<Longrightarrow>\n       (case part x xs of\n        (ls, eq, gs) \\<Rightarrow> sort_sumC ls @ eq @ sort_sumC gs) =\n       (case part xa xsa of\n        (ls, eq, gs) \\<Rightarrow> sort_sumC ls @ eq @ sort_sumC gs)", "by pat_completeness simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sort_dom", "by (relation \"Wellfounded.measure length\") (simp_all add: part less_Suc_eq_le)"], ["", "private"], ["", "lemma filter_mset_union:\n  assumes \"\\<And>x. x \\<in># A \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<Longrightarrow> False\"\n  shows \"filter_mset P A + filter_mset Q A = filter_mset (\\<lambda>x. P x \\<or> Q x) A\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P A + filter_mset Q A = {#x \\<in># A. P x \\<or> Q x#}", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in># A; P ?x; Q ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter_mset P A + filter_mset Q A = {#x \\<in># A. P x \\<or> Q x#}", "by (auto simp add: count_eq_zero_iff intro!: multiset_eqI) blast"], ["", "private"], ["", "lemma multiset_of_sort: \"mset (sort xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (local.sort xs) = mset xs", "proof (induction xs rule: sort.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. mset (local.sort []) = mset []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> mset (local.sort xa) = mset xa;\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> mset (local.sort ya) = mset ya\\<rbrakk>\n       \\<Longrightarrow> mset (local.sort (x # xs)) = mset (x # xs)", "case (2 x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = part x xs; (?xb, ?ya) = ?y\\<rbrakk>\n  \\<Longrightarrow> mset (local.sort ?xa) = mset ?xa\n  \\<lbrakk>(?xa, ?y) = part x xs; (?xb, ?ya) = ?y\\<rbrakk>\n  \\<Longrightarrow> mset (local.sort ?ya) = mset ?ya\n\ngoal (2 subgoals):\n 1. mset (local.sort []) = mset []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> mset (local.sort xa) = mset xa;\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> mset (local.sort ya) = mset ya\\<rbrakk>\n       \\<Longrightarrow> mset (local.sort (x # xs)) = mset (x # xs)", "let ?M = \"\\<lambda>oper. {#y:# mset xs. oper (f y) (f x)#}\""], ["proof (state)\ngoal (2 subgoals):\n 1. mset (local.sort []) = mset []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> mset (local.sort xa) = mset xa;\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> mset (local.sort ya) = mset ya\\<rbrakk>\n       \\<Longrightarrow> mset (local.sort (x # xs)) = mset (x # xs)", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xa, ?y) = part x xs; (?xb, ?ya) = ?y\\<rbrakk>\n  \\<Longrightarrow> mset (local.sort ?xa) = mset ?xa\n  \\<lbrakk>(?xa, ?y) = part x xs; (?xb, ?ya) = ?y\\<rbrakk>\n  \\<Longrightarrow> mset (local.sort ?ya) = mset ?ya", "have \"mset (sort (x#xs)) = ?M (<) + ?M (=) + ?M (>) + {#x#}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = part x xs; (?xb, ?ya) = ?y\\<rbrakk>\n  \\<Longrightarrow> mset (local.sort ?xa) = mset ?xa\n  \\<lbrakk>(?xa, ?y) = part x xs; (?xb, ?ya) = ?y\\<rbrakk>\n  \\<Longrightarrow> mset (local.sort ?ya) = mset ?ya\n\ngoal (1 subgoal):\n 1. mset (local.sort (x # xs)) =\n    {#y \\<in># mset xs. f y < f x#} + {#y \\<in># mset xs. f y = f x#} +\n    {#y \\<in># mset xs. f x < f y#} +\n    {#x#}", "by (simp add: part Multiset.union_assoc mset_filter)"], ["proof (state)\nthis:\n  mset (local.sort (x # xs)) =\n  {#y \\<in># mset xs. f y < f x#} + {#y \\<in># mset xs. f y = f x#} +\n  {#y \\<in># mset xs. f x < f y#} +\n  {#x#}\n\ngoal (2 subgoals):\n 1. mset (local.sort []) = mset []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> mset (local.sort xa) = mset xa;\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> mset (local.sort ya) = mset ya\\<rbrakk>\n       \\<Longrightarrow> mset (local.sort (x # xs)) = mset (x # xs)", "also"], ["proof (state)\nthis:\n  mset (local.sort (x # xs)) =\n  {#y \\<in># mset xs. f y < f x#} + {#y \\<in># mset xs. f y = f x#} +\n  {#y \\<in># mset xs. f x < f y#} +\n  {#x#}\n\ngoal (2 subgoals):\n 1. mset (local.sort []) = mset []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> mset (local.sort xa) = mset xa;\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> mset (local.sort ya) = mset ya\\<rbrakk>\n       \\<Longrightarrow> mset (local.sort (x # xs)) = mset (x # xs)", "have \"?M (<) + ?M (=) + ?M (>) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#y \\<in># mset xs. f y < f x#} + {#y \\<in># mset xs. f y = f x#} +\n    {#y \\<in># mset xs. f x < f y#} =\n    mset xs", "by ((subst filter_mset_union, force)+, subst multiset_eq_iff, force)"], ["proof (state)\nthis:\n  {#y \\<in># mset xs. f y < f x#} + {#y \\<in># mset xs. f y = f x#} +\n  {#y \\<in># mset xs. f x < f y#} =\n  mset xs\n\ngoal (2 subgoals):\n 1. mset (local.sort []) = mset []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> mset (local.sort xa) = mset xa;\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> mset (local.sort ya) = mset ya\\<rbrakk>\n       \\<Longrightarrow> mset (local.sort (x # xs)) = mset (x # xs)", "finally"], ["proof (chain)\npicking this:\n  mset (local.sort (x # xs)) = mset xs + {#x#}", "show ?case"], ["proof (prove)\nusing this:\n  mset (local.sort (x # xs)) = mset xs + {#x#}\n\ngoal (1 subgoal):\n 1. mset (local.sort (x # xs)) = mset (x # xs)", "by simp"], ["proof (state)\nthis:\n  mset (local.sort (x # xs)) = mset (x # xs)\n\ngoal (1 subgoal):\n 1. mset (local.sort []) = mset []", "qed simp"], ["", "private"], ["", "lemma g_sort: \"g (sort xs) = g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (local.sort xs) = g xs", "by (intro g_cong multiset_of_sort)"], ["", "private"], ["", "lemma set_sort: \"set (sort xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.sort xs) = set xs", "using arg_cong[OF multiset_of_sort[of xs], of \"set_mset\"]"], ["proof (prove)\nusing this:\n  set_mset (mset (local.sort xs)) = set_mset (mset xs)\n\ngoal (1 subgoal):\n 1. set (local.sort xs) = set xs", "by (simp only: set_mset_mset)"], ["", "private"], ["", "lemma sorted_all_equal: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x = y) \\<Longrightarrow> sorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set xs \\<Longrightarrow> x = y) \\<Longrightarrow>\n    sorted xs", "by (induction xs) (auto)"], ["", "private"], ["", "lemma sorted_sort: \"sorted (map f (sort xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map f (local.sort xs))", "apply (induction xs rule: sort.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sorted (map f (local.sort []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.sort xa));\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> sorted (map f (local.sort ya))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.sort (x # xs)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.sort xa));\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> sorted (map f (local.sort ya))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.sort (x # xs)))", "apply (simp only: sorted_append sort.simps part map_append split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) =\n                            (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                             x # filter (\\<lambda>xa. f xa = f x) xs,\n                             rev (filter (\\<lambda>xa. f x < f xa) xs));\n                    (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.sort xa));\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) =\n                    (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                     x # filter (\\<lambda>xa. f xa = f x) xs,\n                     rev (filter (\\<lambda>xa. f x < f xa) xs));\n            (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> sorted (map f (local.sort ya))\\<rbrakk>\n       \\<Longrightarrow> True \\<and>\n                         (sorted\n                           (map f\n                             (x #\n                              filter (\\<lambda>xa. f xa = f x) xs)) \\<and>\n                          True \\<and>\n                          (\\<forall>xa\\<in>set\n      (map f (x # filter (\\<lambda>xa. f xa = f x) xs)).\n                              \\<forall>y\n \\<in>set (map f (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))).\n                                 xa \\<le> y)) \\<and>\n                         (\\<forall>xa\\<in>set\n     (map f (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)))).\n                             \\<forall>y\n\\<in>set (map f (x # filter (\\<lambda>xa. f xa = f x) xs) @\n          map f (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))).\n                                xa \\<le> y)", "apply (intro conjI TrueI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) =\n                            (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                             x # filter (\\<lambda>xa. f xa = f x) xs,\n                             rev (filter (\\<lambda>xa. f x < f xa) xs));\n                    (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.sort xa));\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) =\n                    (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                     x # filter (\\<lambda>xa. f xa = f x) xs,\n                     rev (filter (\\<lambda>xa. f x < f xa) xs));\n            (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> sorted (map f (local.sort ya))\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (map f (x # filter (\\<lambda>xa. f xa = f x) xs))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) =\n                            (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                             x # filter (\\<lambda>xa. f xa = f x) xs,\n                             rev (filter (\\<lambda>xa. f x < f xa) xs));\n                    (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.sort xa));\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) =\n                    (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                     x # filter (\\<lambda>xa. f xa = f x) xs,\n                     rev (filter (\\<lambda>xa. f x < f xa) xs));\n            (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> sorted (map f (local.sort ya))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>set\n    (map f (x # filter (\\<lambda>xa. f xa = f x) xs)).\n                            \\<forall>y\\<in>set\n      (map f (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))).\n                               xa \\<le> y\n 3. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) =\n                            (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                             x # filter (\\<lambda>xa. f xa = f x) xs,\n                             rev (filter (\\<lambda>xa. f x < f xa) xs));\n                    (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.sort xa));\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) =\n                    (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                     x # filter (\\<lambda>xa. f xa = f x) xs,\n                     rev (filter (\\<lambda>xa. f x < f xa) xs));\n            (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> sorted (map f (local.sort ya))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>set\n    (map f (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)))).\n                            \\<forall>y\\<in>set\n      (map f (x # filter (\\<lambda>xa. f xa = f x) xs) @\n       map f (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))).\n                               xa \\<le> y", "using sorted_map_same"], ["proof (prove)\nusing this:\n  sorted (map ?f (filter (\\<lambda>x. ?f x = ?g ?xs) ?xs))\n\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) =\n                            (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                             x # filter (\\<lambda>xa. f xa = f x) xs,\n                             rev (filter (\\<lambda>xa. f x < f xa) xs));\n                    (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.sort xa));\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) =\n                    (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                     x # filter (\\<lambda>xa. f xa = f x) xs,\n                     rev (filter (\\<lambda>xa. f x < f xa) xs));\n            (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> sorted (map f (local.sort ya))\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (map f (x # filter (\\<lambda>xa. f xa = f x) xs))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) =\n                            (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                             x # filter (\\<lambda>xa. f xa = f x) xs,\n                             rev (filter (\\<lambda>xa. f x < f xa) xs));\n                    (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.sort xa));\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) =\n                    (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                     x # filter (\\<lambda>xa. f xa = f x) xs,\n                     rev (filter (\\<lambda>xa. f x < f xa) xs));\n            (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> sorted (map f (local.sort ya))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>set\n    (map f (x # filter (\\<lambda>xa. f xa = f x) xs)).\n                            \\<forall>y\\<in>set\n      (map f (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))).\n                               xa \\<le> y\n 3. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) =\n                            (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                             x # filter (\\<lambda>xa. f xa = f x) xs,\n                             rev (filter (\\<lambda>xa. f x < f xa) xs));\n                    (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.sort xa));\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) =\n                    (rev (filter (\\<lambda>xa. f xa < f x) xs),\n                     x # filter (\\<lambda>xa. f xa = f x) xs,\n                     rev (filter (\\<lambda>xa. f x < f xa) xs));\n            (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> sorted (map f (local.sort ya))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>set\n    (map f (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)))).\n                            \\<forall>y\\<in>set\n      (map f (x # filter (\\<lambda>xa. f xa = f x) xs) @\n       map f (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))).\n                               xa \\<le> y", "by (auto simp: set_sort)"], ["", "private"], ["", "fun group where\n  \"group [] = []\"\n| \"group (x#xs) = (case partition (\\<lambda>y. f y = f x) xs of (xs', xs'') \\<Rightarrow> \n                     fold merge xs' x # group xs'')\""], ["", "private"], ["", "lemma f_fold_merge: \"(\\<And>y. y \\<in> set xs \\<Longrightarrow> f y = f x) \\<Longrightarrow> f (fold merge xs x) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> set xs \\<Longrightarrow> f y = f x) \\<Longrightarrow>\n    f (fold merge xs x) = f x", "by (induction xs rule: rev_induct) (auto simp: f_merge)"], ["", "private"], ["", "lemma f_group: \"x \\<in> set (group xs) \\<Longrightarrow> \\<exists>x'\\<in>set xs. f x = f x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (local.group xs) \\<Longrightarrow>\n    \\<exists>x'\\<in>set xs. f x = f x'", "proof (induction xs rule: group.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set (local.group []) \\<Longrightarrow>\n    \\<exists>x'\\<in>set []. f x = f x'\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa y.\n                   \\<lbrakk>(xaa, y) =\n                            partition (\\<lambda>y. f y = f xa) xs;\n                    x \\<in> set (local.group y)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x'\\<in>set y. f x = f x';\n        x \\<in> set (local.group (xa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'\\<in>set (xa # xs). f x = f x'", "case (2 x' xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = partition (\\<lambda>y. f y = f x') xs;\n   x \\<in> set (local.group ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x'\\<in>set ?y. f x = f x'\n  x \\<in> set (local.group (x' # xs))\n\ngoal (2 subgoals):\n 1. x \\<in> set (local.group []) \\<Longrightarrow>\n    \\<exists>x'\\<in>set []. f x = f x'\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa y.\n                   \\<lbrakk>(xaa, y) =\n                            partition (\\<lambda>y. f y = f xa) xs;\n                    x \\<in> set (local.group y)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x'\\<in>set y. f x = f x';\n        x \\<in> set (local.group (xa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'\\<in>set (xa # xs). f x = f x'", "hence \"x = fold merge [y\\<leftarrow>xs . f y = f x'] x' \\<or> x \\<in> set (group [xa\\<leftarrow>xs . f xa \\<noteq> f x'])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = partition (\\<lambda>y. f y = f x') xs;\n   x \\<in> set (local.group ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x'\\<in>set ?y. f x = f x'\n  x \\<in> set (local.group (x' # xs))\n\ngoal (1 subgoal):\n 1. x = fold merge (filter (\\<lambda>y. f y = f x') xs) x' \\<or>\n    x \\<in> set (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x') xs))", "by (auto simp: o_def)"], ["proof (state)\nthis:\n  x = fold merge (filter (\\<lambda>y. f y = f x') xs) x' \\<or>\n  x \\<in> set (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x') xs))\n\ngoal (2 subgoals):\n 1. x \\<in> set (local.group []) \\<Longrightarrow>\n    \\<exists>x'\\<in>set []. f x = f x'\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<And>xaa y.\n                   \\<lbrakk>(xaa, y) =\n                            partition (\\<lambda>y. f y = f xa) xs;\n                    x \\<in> set (local.group y)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>x'\\<in>set y. f x = f x';\n        x \\<in> set (local.group (xa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'\\<in>set (xa # xs). f x = f x'", "thus ?case"], ["proof (prove)\nusing this:\n  x = fold merge (filter (\\<lambda>y. f y = f x') xs) x' \\<or>\n  x \\<in> set (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x') xs))\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>set (x' # xs). f x = f x'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x = fold merge (filter (\\<lambda>y. f y = f x') xs) x' \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'\n 2. x \\<in> set (local.group\n                  (filter (\\<lambda>xa. f xa \\<noteq> f x')\n                    xs)) \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'", "assume \"x = fold merge [y\\<leftarrow>xs . f y = f x'] x'\""], ["proof (state)\nthis:\n  x = fold merge (filter (\\<lambda>y. f y = f x') xs) x'\n\ngoal (2 subgoals):\n 1. x = fold merge (filter (\\<lambda>y. f y = f x') xs) x' \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'\n 2. x \\<in> set (local.group\n                  (filter (\\<lambda>xa. f xa \\<noteq> f x')\n                    xs)) \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'", "also"], ["proof (state)\nthis:\n  x = fold merge (filter (\\<lambda>y. f y = f x') xs) x'\n\ngoal (2 subgoals):\n 1. x = fold merge (filter (\\<lambda>y. f y = f x') xs) x' \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'\n 2. x \\<in> set (local.group\n                  (filter (\\<lambda>xa. f xa \\<noteq> f x')\n                    xs)) \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'", "have \"f ... = f x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (fold merge (filter (\\<lambda>y. f y = f x') xs) x') = f x'", "by (rule f_fold_merge) simp"], ["proof (state)\nthis:\n  f (fold merge (filter (\\<lambda>y. f y = f x') xs) x') = f x'\n\ngoal (2 subgoals):\n 1. x = fold merge (filter (\\<lambda>y. f y = f x') xs) x' \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'\n 2. x \\<in> set (local.group\n                  (filter (\\<lambda>xa. f xa \\<noteq> f x')\n                    xs)) \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'", "finally"], ["proof (chain)\npicking this:\n  f x = f x'", "show ?thesis"], ["proof (prove)\nusing this:\n  f x = f x'\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>set (x' # xs). f x = f x'", "by simp"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>set (x' # xs). f x = f x'\n\ngoal (1 subgoal):\n 1. x \\<in> set (local.group\n                  (filter (\\<lambda>xa. f xa \\<noteq> f x')\n                    xs)) \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set (local.group\n                  (filter (\\<lambda>xa. f xa \\<noteq> f x')\n                    xs)) \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'", "assume \"x \\<in> set (group [xa\\<leftarrow>xs . f xa \\<noteq> f x'])\""], ["proof (state)\nthis:\n  x \\<in> set (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x') xs))\n\ngoal (1 subgoal):\n 1. x \\<in> set (local.group\n                  (filter (\\<lambda>xa. f xa \\<noteq> f x')\n                    xs)) \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'", "from 2(1)[OF _ this]"], ["proof (chain)\npicking this:\n  (?xa, filter (\\<lambda>xa. f xa \\<noteq> f x') xs) =\n  partition (\\<lambda>y. f y = f x') xs \\<Longrightarrow>\n  \\<exists>x'\\<in>set (filter (\\<lambda>xa. f xa \\<noteq> f x') xs).\n     f x = f x'", "have \"\\<exists>x'\\<in>set [xa\\<leftarrow>xs . f xa \\<noteq> f x']. f x = f x'\""], ["proof (prove)\nusing this:\n  (?xa, filter (\\<lambda>xa. f xa \\<noteq> f x') xs) =\n  partition (\\<lambda>y. f y = f x') xs \\<Longrightarrow>\n  \\<exists>x'\\<in>set (filter (\\<lambda>xa. f xa \\<noteq> f x') xs).\n     f x = f x'\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>set (filter (\\<lambda>xa. f xa \\<noteq> f x') xs).\n       f x = f x'", "by (simp add: o_def)"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>set (filter (\\<lambda>xa. f xa \\<noteq> f x') xs).\n     f x = f x'\n\ngoal (1 subgoal):\n 1. x \\<in> set (local.group\n                  (filter (\\<lambda>xa. f xa \\<noteq> f x')\n                    xs)) \\<Longrightarrow>\n    \\<exists>x'\\<in>set (x' # xs). f x = f x'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x'\\<in>set (filter (\\<lambda>xa. f xa \\<noteq> f x') xs).\n     f x = f x'\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>set (x' # xs). f x = f x'", "by force"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>set (x' # xs). f x = f x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>set (x' # xs). f x = f x'\n\ngoal (1 subgoal):\n 1. x \\<in> set (local.group []) \\<Longrightarrow>\n    \\<exists>x'\\<in>set []. f x = f x'", "qed simp"], ["", "private"], ["", "lemma sorted_group: \"sorted (map f xs) \\<Longrightarrow> sorted (map f (group xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map f xs) \\<Longrightarrow> sorted (map f (local.group xs))", "proof (induction xs rule: group.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "case (2 x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = partition (\\<lambda>y. f y = f x) xs;\n   sorted (map f ?y)\\<rbrakk>\n  \\<Longrightarrow> sorted (map f (local.group ?y))\n  sorted (map f (x # xs))\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = partition (\\<lambda>y. f y = f x) xs;\n   sorted (map f ?y)\\<rbrakk>\n  \\<Longrightarrow> sorted (map f (local.group ?y))\n  sorted (map f (x # xs))\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "fix x'"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "assume x': \"x' \\<in> set (group [y\\<leftarrow>xs . f y \\<noteq> f x])\""], ["proof (state)\nthis:\n  x' \\<in> set (local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs))\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "with f_group"], ["proof (chain)\npicking this:\n  ?x \\<in> set (local.group ?xs) \\<Longrightarrow>\n  \\<exists>x'\\<in>set ?xs. f ?x = f x'\n  x' \\<in> set (local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs))", "obtain x'' where x'': \"x'' \\<in> set xs\" \"f x' = f x''\""], ["proof (prove)\nusing this:\n  ?x \\<in> set (local.group ?xs) \\<Longrightarrow>\n  \\<exists>x'\\<in>set ?xs. f ?x = f x'\n  x' \\<in> set (local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs))\n\ngoal (1 subgoal):\n 1. (\\<And>x''.\n        \\<lbrakk>x'' \\<in> set xs; f x' = f x''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x'' \\<in> set xs\n  f x' = f x''\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "have \"f (fold merge [y\\<leftarrow>xs . f y = f x] x) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) = f x", "by (subst f_fold_merge) simp_all"], ["proof (state)\nthis:\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) = f x\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "also"], ["proof (state)\nthis:\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) = f x\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "from 2(2) x''"], ["proof (chain)\npicking this:\n  sorted (map f (x # xs))\n  x'' \\<in> set xs\n  f x' = f x''", "have \"... \\<le> f x'\""], ["proof (prove)\nusing this:\n  sorted (map f (x # xs))\n  x'' \\<in> set xs\n  f x' = f x''\n\ngoal (1 subgoal):\n 1. f x \\<le> f x'", "by (auto)"], ["proof (state)\nthis:\n  f x \\<le> f x'\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "finally"], ["proof (chain)\npicking this:\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) \\<le> f x'", "have \"f (fold merge [y\\<leftarrow>xs . f y = f x] x) \\<le> f x'\""], ["proof (prove)\nusing this:\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) \\<le> f x'\n\ngoal (1 subgoal):\n 1. f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) \\<le> f x'", "."], ["proof (state)\nthis:\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) \\<le> f x'\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "}"], ["proof (state)\nthis:\n  ?x'2\n  \\<in> set (local.group\n              (filter (\\<lambda>y. f y \\<noteq> f x) xs)) \\<Longrightarrow>\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) \\<le> f ?x'2\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "moreover"], ["proof (state)\nthis:\n  ?x'2\n  \\<in> set (local.group\n              (filter (\\<lambda>y. f y \\<noteq> f x) xs)) \\<Longrightarrow>\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) \\<le> f ?x'2\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "from 2(2)"], ["proof (chain)\npicking this:\n  sorted (map f (x # xs))", "have \"sorted (map f (group [xa\\<leftarrow>xs . f xa \\<noteq> f x]))\""], ["proof (prove)\nusing this:\n  sorted (map f (x # xs))\n\ngoal (1 subgoal):\n 1. sorted\n     (map f (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))", "by (intro 2 sorted_filter) (simp_all add: o_def)"], ["proof (state)\nthis:\n  sorted (map f (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = partition (\\<lambda>y. f y = f x) xs;\n                    sorted (map f y)\\<rbrakk>\n                   \\<Longrightarrow> sorted (map f (local.group y));\n        sorted (map f (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (local.group (x # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  ?x'2\n  \\<in> set (local.group\n              (filter (\\<lambda>y. f y \\<noteq> f x) xs)) \\<Longrightarrow>\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) \\<le> f ?x'2\n  sorted (map f (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))", "show ?case"], ["proof (prove)\nusing this:\n  ?x'2\n  \\<in> set (local.group\n              (filter (\\<lambda>y. f y \\<noteq> f x) xs)) \\<Longrightarrow>\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x) \\<le> f ?x'2\n  sorted (map f (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))\n\ngoal (1 subgoal):\n 1. sorted (map f (local.group (x # xs)))", "by (simp add: o_def)"], ["proof (state)\nthis:\n  sorted (map f (local.group (x # xs)))\n\ngoal (1 subgoal):\n 1. sorted (map f []) \\<Longrightarrow> sorted (map f (local.group []))", "qed simp_all"], ["", "private"], ["", "lemma distinct_group: \"distinct (map f (group xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f (local.group xs))", "proof (induction xs rule: group.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map f (local.group []))\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           distinct (map f (local.group y))) \\<Longrightarrow>\n       distinct (map f (local.group (x # xs)))", "case (2 x xs)"], ["proof (state)\nthis:\n  (?xa, ?y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n  distinct (map f (local.group ?y))\n\ngoal (2 subgoals):\n 1. distinct (map f (local.group []))\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           distinct (map f (local.group y))) \\<Longrightarrow>\n       distinct (map f (local.group (x # xs)))", "have \"distinct (map f (group [xa\\<leftarrow>xs . f xa \\<noteq> f x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map f (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))", "by (intro 2) (simp_all add: o_def)"], ["proof (state)\nthis:\n  distinct\n   (map f (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))\n\ngoal (2 subgoals):\n 1. distinct (map f (local.group []))\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           distinct (map f (local.group y))) \\<Longrightarrow>\n       distinct (map f (local.group (x # xs)))", "moreover"], ["proof (state)\nthis:\n  distinct\n   (map f (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))\n\ngoal (2 subgoals):\n 1. distinct (map f (local.group []))\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           distinct (map f (local.group y))) \\<Longrightarrow>\n       distinct (map f (local.group (x # xs)))", "have \"f (fold merge [y\\<leftarrow>xs . f y = f x] x) \\<notin> set (map f (group [xa\\<leftarrow>xs . f xa \\<noteq> f x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (fold merge (filter (\\<lambda>y. f y = f x) xs) x)\n    \\<notin> set (map f\n                   (local.group\n                     (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))", "by (rule notI, subst (asm) f_fold_merge) (auto dest: f_group)"], ["proof (state)\nthis:\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x)\n  \\<notin> set (map f\n                 (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))\n\ngoal (2 subgoals):\n 1. distinct (map f (local.group []))\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           distinct (map f (local.group y))) \\<Longrightarrow>\n       distinct (map f (local.group (x # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  distinct\n   (map f (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x)\n  \\<notin> set (map f\n                 (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))", "show ?case"], ["proof (prove)\nusing this:\n  distinct\n   (map f (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))\n  f (fold merge (filter (\\<lambda>y. f y = f x) xs) x)\n  \\<notin> set (map f\n                 (local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)))\n\ngoal (1 subgoal):\n 1. distinct (map f (local.group (x # xs)))", "by (simp add: o_def)"], ["proof (state)\nthis:\n  distinct (map f (local.group (x # xs)))\n\ngoal (1 subgoal):\n 1. distinct (map f (local.group []))", "qed simp"], ["", "private"], ["", "lemma g_fold_same:\n  assumes \"\\<And>z. z \\<in> set xs \\<Longrightarrow> f z = f x\"\n  shows   \"g (fold merge xs x # ys) = g (x#xs@ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (fold merge xs x # ys) = g (x # xs @ ys)", "using assms"], ["proof (prove)\nusing this:\n  ?z \\<in> set xs \\<Longrightarrow> f ?z = f x\n\ngoal (1 subgoal):\n 1. g (fold merge xs x # ys) = g (x # xs @ ys)", "proof (induction xs arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "case (Cons y xs)"], ["proof (state)\nthis:\n  (\\<And>z. z \\<in> set xs \\<Longrightarrow> f z = f ?x) \\<Longrightarrow>\n  g (fold merge xs ?x # ys) = g (?x # xs @ ys)\n  ?z \\<in> set (y # xs) \\<Longrightarrow> f ?z = f x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "have \"g (x # y # xs @ ys) = g (y # x # xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x # y # xs @ ys) = g (y # x # xs @ ys)", "by (intro g_cong) (auto simp: add_ac)"], ["proof (state)\nthis:\n  g (x # y # xs @ ys) = g (y # x # xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "also"], ["proof (state)\nthis:\n  g (x # y # xs @ ys) = g (y # x # xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "have \"y # x # xs @ ys = [y,x] @ xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y # x # xs @ ys = [y, x] @ xs @ ys", "by simp"], ["proof (state)\nthis:\n  y # x # xs @ ys = [y, x] @ xs @ ys\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "also"], ["proof (state)\nthis:\n  y # x # xs @ ys = [y, x] @ xs @ ys\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "from Cons.prems"], ["proof (chain)\npicking this:\n  ?z \\<in> set (y # xs) \\<Longrightarrow> f ?z = f x", "have \"g ... = g ([merge y x] @ xs @ ys)\""], ["proof (prove)\nusing this:\n  ?z \\<in> set (y # xs) \\<Longrightarrow> f ?z = f x\n\ngoal (1 subgoal):\n 1. g ([y, x] @ xs @ ys) = g ([merge y x] @ xs @ ys)", "by (intro g_append_cong g_merge) auto"], ["proof (state)\nthis:\n  g ([y, x] @ xs @ ys) = g ([merge y x] @ xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "also"], ["proof (state)\nthis:\n  g ([y, x] @ xs @ ys) = g ([merge y x] @ xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "have \"[merge y x] @ xs @ ys = merge y x # xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [merge y x] @ xs @ ys = merge y x # xs @ ys", "by simp"], ["proof (state)\nthis:\n  [merge y x] @ xs @ ys = merge y x # xs @ ys\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "also"], ["proof (state)\nthis:\n  [merge y x] @ xs @ ys = merge y x # xs @ ys\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "from Cons.prems"], ["proof (chain)\npicking this:\n  ?z \\<in> set (y # xs) \\<Longrightarrow> f ?z = f x", "have \"g ... = g (fold merge xs (merge y x) # ys)\""], ["proof (prove)\nusing this:\n  ?z \\<in> set (y # xs) \\<Longrightarrow> f ?z = f x\n\ngoal (1 subgoal):\n 1. g (merge y x # xs @ ys) = g (fold merge xs (merge y x) # ys)", "by (intro Cons.IH[symmetric]) (auto simp: f_merge)"], ["proof (state)\nthis:\n  g (merge y x # xs @ ys) = g (fold merge xs (merge y x) # ys)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "also"], ["proof (state)\nthis:\n  g (merge y x # xs @ ys) = g (fold merge xs (merge y x) # ys)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "have \"... = g (fold merge (y # xs) x # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (fold merge xs (merge y x) # ys) = g (fold merge (y # xs) x # ys)", "by simp"], ["proof (state)\nthis:\n  g (fold merge xs (merge y x) # ys) = g (fold merge (y # xs) x # ys)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   (\\<And>z.\n                       z \\<in> set xs \\<Longrightarrow>\n                       f z = f x) \\<Longrightarrow>\n                   g (fold merge xs x # ys) = g (x # xs @ ys);\n        \\<And>z. z \\<in> set (a # xs) \\<Longrightarrow> f z = f x\\<rbrakk>\n       \\<Longrightarrow> g (fold merge (a # xs) x # ys) =\n                         g (x # (a # xs) @ ys)", "finally"], ["proof (chain)\npicking this:\n  g (x # y # xs @ ys) = g (fold merge (y # xs) x # ys)", "show ?case"], ["proof (prove)\nusing this:\n  g (x # y # xs @ ys) = g (fold merge (y # xs) x # ys)\n\ngoal (1 subgoal):\n 1. g (fold merge (y # xs) x # ys) = g (x # (y # xs) @ ys)", "by simp"], ["proof (state)\nthis:\n  g (fold merge (y # xs) x # ys) = g (x # (y # xs) @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>z.\n           z \\<in> set [] \\<Longrightarrow> f z = f x) \\<Longrightarrow>\n       g (fold merge [] x # ys) = g (x # [] @ ys)", "qed simp"], ["", "private"], ["", "lemma g_group: \"g (group xs) = g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (local.group xs) = g xs", "proof (induction xs rule: group.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "case (2 x xs)"], ["proof (state)\nthis:\n  (?xa, ?y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n  g (local.group ?y) = g ?y\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "have \"g (group (x#xs)) = g (fold merge [y\\<leftarrow>xs . f y = f x] x # group [xa\\<leftarrow>xs . f xa \\<noteq> f x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (local.group (x # xs)) =\n    g (fold merge (filter (\\<lambda>y. f y = f x) xs) x #\n       local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs))", "by (simp add: o_def)"], ["proof (state)\nthis:\n  g (local.group (x # xs)) =\n  g (fold merge (filter (\\<lambda>y. f y = f x) xs) x #\n     local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs))\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "also"], ["proof (state)\nthis:\n  g (local.group (x # xs)) =\n  g (fold merge (filter (\\<lambda>y. f y = f x) xs) x #\n     local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs))\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "have \"... = g (x # [y\\<leftarrow>xs . f y = f x] @ group [y\\<leftarrow>xs . f y \\<noteq> f x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (fold merge (filter (\\<lambda>y. f y = f x) xs) x #\n       local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)) =\n    g (x #\n       filter (\\<lambda>y. f y = f x) xs @\n       local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs))", "by (intro g_fold_same) simp_all"], ["proof (state)\nthis:\n  g (fold merge (filter (\\<lambda>y. f y = f x) xs) x #\n     local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)) =\n  g (x #\n     filter (\\<lambda>y. f y = f x) xs @\n     local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs))\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "also"], ["proof (state)\nthis:\n  g (fold merge (filter (\\<lambda>y. f y = f x) xs) x #\n     local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs)) =\n  g (x #\n     filter (\\<lambda>y. f y = f x) xs @\n     local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs))\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "have \"... = g ((x # [y\\<leftarrow>xs . f y = f x]) @ group [y\\<leftarrow>xs . f y \\<noteq> f x])\" (is \"_ = ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x #\n       filter (\\<lambda>y. f y = f x) xs @\n       local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs)) =\n    g ((x # filter (\\<lambda>y. f y = f x) xs) @\n       local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs))", "by simp"], ["proof (state)\nthis:\n  g (x #\n     filter (\\<lambda>y. f y = f x) xs @\n     local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs)) =\n  g ((x # filter (\\<lambda>y. f y = f x) xs) @\n     local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs))\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "also"], ["proof (state)\nthis:\n  g (x #\n     filter (\\<lambda>y. f y = f x) xs @\n     local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs)) =\n  g ((x # filter (\\<lambda>y. f y = f x) xs) @\n     local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs))\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "from 2"], ["proof (chain)\npicking this:\n  (?xa, ?y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n  g (local.group ?y) = g ?y", "have \"g (group [y\\<leftarrow>xs . f y \\<noteq> f x]) = g [y\\<leftarrow>xs . f y \\<noteq> f x]\""], ["proof (prove)\nusing this:\n  (?xa, ?y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n  g (local.group ?y) = g ?y\n\ngoal (1 subgoal):\n 1. g (local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs)) =\n    g (filter (\\<lambda>y. f y \\<noteq> f x) xs)", "by (simp add: o_def)"], ["proof (state)\nthis:\n  g (local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs)) =\n  g (filter (\\<lambda>y. f y \\<noteq> f x) xs)\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "hence \"?A = g ((x # [y\\<leftarrow>xs . f y = f x]) @ [y\\<leftarrow>xs . f y \\<noteq> f x])\""], ["proof (prove)\nusing this:\n  g (local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs)) =\n  g (filter (\\<lambda>y. f y \\<noteq> f x) xs)\n\ngoal (1 subgoal):\n 1. g ((x # filter (\\<lambda>y. f y = f x) xs) @\n       local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs)) =\n    g ((x # filter (\\<lambda>y. f y = f x) xs) @\n       filter (\\<lambda>y. f y \\<noteq> f x) xs)", "by (intro g_append_cong) simp_all"], ["proof (state)\nthis:\n  g ((x # filter (\\<lambda>y. f y = f x) xs) @\n     local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs)) =\n  g ((x # filter (\\<lambda>y. f y = f x) xs) @\n     filter (\\<lambda>y. f y \\<noteq> f x) xs)\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "also"], ["proof (state)\nthis:\n  g ((x # filter (\\<lambda>y. f y = f x) xs) @\n     local.group (filter (\\<lambda>y. f y \\<noteq> f x) xs)) =\n  g ((x # filter (\\<lambda>y. f y = f x) xs) @\n     filter (\\<lambda>y. f y \\<noteq> f x) xs)\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "have \"... = g (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ((x # filter (\\<lambda>y. f y = f x) xs) @\n       filter (\\<lambda>y. f y \\<noteq> f x) xs) =\n    g (x # xs)", "by (intro g_cong) (simp_all)"], ["proof (state)\nthis:\n  g ((x # filter (\\<lambda>y. f y = f x) xs) @\n     filter (\\<lambda>y. f y \\<noteq> f x) xs) =\n  g (x # xs)\n\ngoal (2 subgoals):\n 1. g (local.group []) = g []\n 2. \\<And>x xs.\n       (\\<And>xa y.\n           (xa, y) = partition (\\<lambda>y. f y = f x) xs \\<Longrightarrow>\n           g (local.group y) = g y) \\<Longrightarrow>\n       g (local.group (x # xs)) = g (x # xs)", "finally"], ["proof (chain)\npicking this:\n  g (local.group (x # xs)) = g (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  g (local.group (x # xs)) = g (x # xs)\n\ngoal (1 subgoal):\n 1. g (local.group (x # xs)) = g (x # xs)", "."], ["proof (state)\nthis:\n  g (local.group (x # xs)) = g (x # xs)\n\ngoal (1 subgoal):\n 1. g (local.group []) = g []", "qed simp"], ["", "function group_part_aux :: \n  \"'b \\<Rightarrow> 'a list \\<Rightarrow> ('a list) \\<times> 'a \\<times> ('a list) \\<Rightarrow> ('a list) \\<times> 'a \\<times> ('a list)\" \nwhere\n  \"group_part_aux p [] (ls, eq, gs) = (ls, eq, gs)\"\n| \"f x < p \\<Longrightarrow> group_part_aux p (x#xs) (ls, eq, gs) = group_part_aux p xs (x#ls, eq, gs)\"\n| \"f x > p \\<Longrightarrow> group_part_aux p (x#xs) (ls, eq, gs) = group_part_aux p xs (ls, eq, x#gs)\"\n| \"f x = p \\<Longrightarrow> group_part_aux p (x#xs) (ls, eq, gs) = group_part_aux p xs (ls, merge x eq, gs)\""], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>p ls eqa gs.\n                   x = (p, [], ls, eqa, gs) \\<Longrightarrow> P;\n        \\<And>xa p xs ls eqa gs.\n           \\<lbrakk>f xa < p; x = (p, xa # xs, ls, eqa, gs)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>xa p xs ls eqa gs.\n           \\<lbrakk>p < f xa; x = (p, xa # xs, ls, eqa, gs)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>xa p xs ls eqa gs.\n           \\<lbrakk>f xa = p; x = (p, xa # xs, ls, eqa, gs)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>p ls eqa gs pa lsa eqb gsa.\n       (p, [], ls, eqa, gs) = (pa, [], lsa, eqb, gsa) \\<Longrightarrow>\n       (ls, eqa, gs) = (lsa, eqb, gsa)\n 3. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>f x < pa;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, x # lsa, eqb, gsa)\n 4. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>pa < f x;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, lsa, eqb, x # gsa)\n 5. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>f x = pa;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, lsa, merge x eqb, gsa)\n 6. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; f xa < pa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xsa, xa # lsa, eqb, gsa)\n 7. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; pa < f xa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xsa, lsa, eqb, xa # gsa)\n 8. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; f xa = pa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC\n                          (pa, xsa, lsa, merge xa eqb, gsa)\n 9. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>p < f x; pa < f xa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, ls, eqa, x # gs) =\n                         group_part_aux_sumC (pa, xsa, lsa, eqb, xa # gsa)\n 10. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n        \\<lbrakk>p < f x; f xa = pa;\n         (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n        \\<Longrightarrow> group_part_aux_sumC (p, xs, ls, eqa, x # gs) =\n                          group_part_aux_sumC\n                           (pa, xsa, lsa, merge xa eqb, gsa)\nA total of 11 subgoals...", "proof (clarify, goal_cases)"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>P a aa ab ac b.\n       \\<lbrakk>\\<And>p ls eqa gs.\n                   (a, aa, ab, ac, b) =\n                   (p, [], ls, eqa, gs) \\<Longrightarrow>\n                   P;\n        \\<And>x p xs ls eqa gs.\n           \\<lbrakk>f x < p;\n            (a, aa, ab, ac, b) = (p, x # xs, ls, eqa, gs)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>x p xs ls eqa gs.\n           \\<lbrakk>p < f x;\n            (a, aa, ab, ac, b) = (p, x # xs, ls, eqa, gs)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>x p xs ls eqa gs.\n           \\<lbrakk>f x = p;\n            (a, aa, ab, ac, b) = (p, x # xs, ls, eqa, gs)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>p ls eqa gs pa lsa eqb gsa.\n       (p, [], ls, eqa, gs) = (pa, [], lsa, eqb, gsa) \\<Longrightarrow>\n       (ls, eqa, gs) = (lsa, eqb, gsa)\n 3. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>f x < pa;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, x # lsa, eqb, gsa)\n 4. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>pa < f x;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, lsa, eqb, x # gsa)\n 5. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>f x = pa;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, lsa, merge x eqb, gsa)\n 6. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; f xa < pa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xsa, xa # lsa, eqb, gsa)\n 7. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; pa < f xa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xsa, lsa, eqb, xa # gsa)\n 8. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; f xa = pa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC\n                          (pa, xsa, lsa, merge xa eqb, gsa)\n 9. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>p < f x; pa < f xa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, ls, eqa, x # gs) =\n                         group_part_aux_sumC (pa, xsa, lsa, eqb, xa # gsa)\n 10. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n        \\<lbrakk>p < f x; f xa = pa;\n         (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n        \\<Longrightarrow> group_part_aux_sumC (p, xs, ls, eqa, x # gs) =\n                          group_part_aux_sumC\n                           (pa, xsa, lsa, merge xa eqb, gsa)\nA total of 11 subgoals...", "case prems: (1 P p xs ls eq gs)"], ["proof (state)\nthis:\n  (p, xs, ls, eq, gs) = (?p, [], ?ls, ?eq, ?gs) \\<Longrightarrow> P\n  \\<lbrakk>f ?x < ?p;\n   (p, xs, ls, eq, gs) = (?p, ?x # ?xs, ?ls, ?eq, ?gs)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>?p < f ?x;\n   (p, xs, ls, eq, gs) = (?p, ?x # ?xs, ?ls, ?eq, ?gs)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>f ?x = ?p;\n   (p, xs, ls, eq, gs) = (?p, ?x # ?xs, ?ls, ?eq, ?gs)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (11 subgoals):\n 1. \\<And>P a aa ab ac b.\n       \\<lbrakk>\\<And>p ls eqa gs.\n                   (a, aa, ab, ac, b) =\n                   (p, [], ls, eqa, gs) \\<Longrightarrow>\n                   P;\n        \\<And>x p xs ls eqa gs.\n           \\<lbrakk>f x < p;\n            (a, aa, ab, ac, b) = (p, x # xs, ls, eqa, gs)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>x p xs ls eqa gs.\n           \\<lbrakk>p < f x;\n            (a, aa, ab, ac, b) = (p, x # xs, ls, eqa, gs)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>x p xs ls eqa gs.\n           \\<lbrakk>f x = p;\n            (a, aa, ab, ac, b) = (p, x # xs, ls, eqa, gs)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>p ls eqa gs pa lsa eqb gsa.\n       (p, [], ls, eqa, gs) = (pa, [], lsa, eqb, gsa) \\<Longrightarrow>\n       (ls, eqa, gs) = (lsa, eqb, gsa)\n 3. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>f x < pa;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, x # lsa, eqb, gsa)\n 4. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>pa < f x;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, lsa, eqb, x # gsa)\n 5. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>f x = pa;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, lsa, merge x eqb, gsa)\n 6. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; f xa < pa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xsa, xa # lsa, eqb, gsa)\n 7. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; pa < f xa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xsa, lsa, eqb, xa # gsa)\n 8. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; f xa = pa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC\n                          (pa, xsa, lsa, merge xa eqb, gsa)\n 9. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>p < f x; pa < f xa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, ls, eqa, x # gs) =\n                         group_part_aux_sumC (pa, xsa, lsa, eqb, xa # gsa)\n 10. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n        \\<lbrakk>p < f x; f xa = pa;\n         (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n        \\<Longrightarrow> group_part_aux_sumC (p, xs, ls, eqa, x # gs) =\n                          group_part_aux_sumC\n                           (pa, xsa, lsa, merge xa eqb, gsa)\nA total of 11 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P", "fix x xs'"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P", "assume \"xs = x # xs'\""], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. P", "using prems"], ["proof (prove)\nusing this:\n  xs = x # xs'\n  (p, xs, ls, eq, gs) = (?p, [], ?ls, ?eq, ?gs) \\<Longrightarrow> P\n  \\<lbrakk>f ?x < ?p;\n   (p, xs, ls, eq, gs) = (?p, ?x # ?xs, ?ls, ?eq, ?gs)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>?p < f ?x;\n   (p, xs, ls, eq, gs) = (?p, ?x # ?xs, ?ls, ?eq, ?gs)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>f ?x = ?p;\n   (p, xs, ls, eq, gs) = (?p, ?x # ?xs, ?ls, ?eq, ?gs)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (cases \"f x\" p rule: linorder_cases) auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> P", "qed (auto intro: prems(1))"], ["proof (state)\nthis:\n  P\n\ngoal (10 subgoals):\n 1. \\<And>p ls eqa gs pa lsa eqb gsa.\n       (p, [], ls, eqa, gs) = (pa, [], lsa, eqb, gsa) \\<Longrightarrow>\n       (ls, eqa, gs) = (lsa, eqb, gsa)\n 2. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>f x < pa;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, x # lsa, eqb, gsa)\n 3. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>pa < f x;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, lsa, eqb, x # gsa)\n 4. \\<And>p ls eqa gs x pa xs lsa eqb gsa.\n       \\<lbrakk>f x = pa;\n        (p, [], ls, eqa, gs) = (pa, x # xs, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> (ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xs, lsa, merge x eqb, gsa)\n 5. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; f xa < pa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xsa, xa # lsa, eqb, gsa)\n 6. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; pa < f xa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC (pa, xsa, lsa, eqb, xa # gsa)\n 7. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>f x < p; f xa = pa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, x # ls, eqa, gs) =\n                         group_part_aux_sumC\n                          (pa, xsa, lsa, merge xa eqb, gsa)\n 8. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>p < f x; pa < f xa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, ls, eqa, x # gs) =\n                         group_part_aux_sumC (pa, xsa, lsa, eqb, xa # gsa)\n 9. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n       \\<lbrakk>p < f x; f xa = pa;\n        (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n       \\<Longrightarrow> group_part_aux_sumC (p, xs, ls, eqa, x # gs) =\n                         group_part_aux_sumC\n                          (pa, xsa, lsa, merge xa eqb, gsa)\n 10. \\<And>x p xs ls eqa gs xa pa xsa lsa eqb gsa.\n        \\<lbrakk>f x = p; f xa = pa;\n         (p, x # xs, ls, eqa, gs) = (pa, xa # xsa, lsa, eqb, gsa)\\<rbrakk>\n        \\<Longrightarrow> group_part_aux_sumC (p, xs, ls, merge x eqa, gs) =\n                          group_part_aux_sumC\n                           (pa, xsa, lsa, merge xa eqb, gsa)", "qed simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All group_part_aux_dom", "by (relation \"Wellfounded.measure (size \\<circ> fst \\<circ> snd)\") simp_all"], ["", "private"], ["", "lemmas group_part_aux_induct = \n  group_part_aux.induct[split_format (complete), OF groupsort_locale]"], ["", "definition group_part where \"group_part p xs = group_part_aux (f p) xs ([], p, [])\""], ["", "private"], ["", "lemma group_part: \n  \"group_part p xs = (rev (filter (\\<lambda>x. f x < f p) xs), \n     fold merge (filter (\\<lambda>x. f x = f p) xs) p, rev (filter (\\<lambda>x. f x > f p) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "fix p xs ls eq gs"], ["proof (state)\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "have \"fst (group_part_aux p xs (ls, eq, gs)) = rev (filter (\\<lambda>x. f x < p) xs) @ ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (group_part_aux p xs (ls, eq, gs)) =\n    rev (filter (\\<lambda>x. f x < p) xs) @ ls", "by (induction p xs ls eq gs rule: group_part_aux_induct) simp_all"], ["proof (state)\nthis:\n  fst (group_part_aux p xs (ls, eq, gs)) =\n  rev (filter (\\<lambda>x. f x < p) xs) @ ls\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "}"], ["proof (state)\nthis:\n  fst (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2)) =\n  rev (filter (\\<lambda>x. f x < ?pa2) ?xsa2) @ ?ls2\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "note A = this"], ["proof (state)\nthis:\n  fst (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2)) =\n  rev (filter (\\<lambda>x. f x < ?pa2) ?xsa2) @ ?ls2\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "{"], ["proof (state)\nthis:\n  fst (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2)) =\n  rev (filter (\\<lambda>x. f x < ?pa2) ?xsa2) @ ?ls2\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "fix p xs ls eq gs"], ["proof (state)\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "have \"snd (snd (group_part_aux p xs (ls, eq, gs))) = rev (filter (\\<lambda>x. f x > p) xs) @ gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (group_part_aux p xs (ls, eq, gs))) =\n    rev (filter (\\<lambda>x. p < f x) xs) @ gs", "by (induction p xs ls eq gs rule: group_part_aux_induct) simp_all"], ["proof (state)\nthis:\n  snd (snd (group_part_aux p xs (ls, eq, gs))) =\n  rev (filter (\\<lambda>x. p < f x) xs) @ gs\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "}"], ["proof (state)\nthis:\n  snd (snd (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  rev (filter (\\<lambda>x. ?pa2 < f x) ?xsa2) @ ?gs2\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "note B = this"], ["proof (state)\nthis:\n  snd (snd (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  rev (filter (\\<lambda>x. ?pa2 < f x) ?xsa2) @ ?gs2\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "{"], ["proof (state)\nthis:\n  snd (snd (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  rev (filter (\\<lambda>x. ?pa2 < f x) ?xsa2) @ ?gs2\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "fix p xs ls eq gs"], ["proof (state)\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "have \"fst (snd (group_part_aux p xs (ls, eq, gs))) = \n            fold merge (filter (\\<lambda>x. f x = p) xs) eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (group_part_aux p xs (ls, eq, gs))) =\n    fold merge (filter (\\<lambda>x. f x = p) xs) eq", "by (induction p xs ls eq gs rule: group_part_aux_induct) auto"], ["proof (state)\nthis:\n  fst (snd (group_part_aux p xs (ls, eq, gs))) =\n  fold merge (filter (\\<lambda>x. f x = p) xs) eq\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "}"], ["proof (state)\nthis:\n  fst (snd (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  fold merge (filter (\\<lambda>x. f x = ?pa2) ?xsa2) ?eq2\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "note C = this"], ["proof (state)\nthis:\n  fst (snd (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  fold merge (filter (\\<lambda>x. f x = ?pa2) ?xsa2) ?eq2\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "note ABC = A B C"], ["proof (state)\nthis:\n  fst (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2)) =\n  rev (filter (\\<lambda>x. f x < ?pa2) ?xsa2) @ ?ls2\n  snd (snd (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  rev (filter (\\<lambda>x. ?pa2 < f x) ?xsa2) @ ?gs2\n  fst (snd (group_part_aux ?pa2 ?xsa2 (?ls2, ?eq2, ?gs2))) =\n  fold merge (filter (\\<lambda>x. f x = ?pa2) ?xsa2) ?eq2\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "from ABC[of \"f p\" xs \"[]\" \"p\" \"[]\"]"], ["proof (chain)\npicking this:\n  fst (group_part_aux (f p) xs ([], p, [])) =\n  rev (filter (\\<lambda>x. f x < f p) xs) @ []\n  snd (snd (group_part_aux (f p) xs ([], p, []))) =\n  rev (filter (\\<lambda>x. f p < f x) xs) @ []\n  fst (snd (group_part_aux (f p) xs ([], p, []))) =\n  fold merge (filter (\\<lambda>x. f x = f p) xs) p", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (group_part_aux (f p) xs ([], p, [])) =\n  rev (filter (\\<lambda>x. f x < f p) xs) @ []\n  snd (snd (group_part_aux (f p) xs ([], p, []))) =\n  rev (filter (\\<lambda>x. f p < f x) xs) @ []\n  fst (snd (group_part_aux (f p) xs ([], p, []))) =\n  fold merge (filter (\\<lambda>x. f x = f p) xs) p\n\ngoal (1 subgoal):\n 1. group_part p xs =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "unfolding group_part_def"], ["proof (prove)\nusing this:\n  fst (group_part_aux (f p) xs ([], p, [])) =\n  rev (filter (\\<lambda>x. f x < f p) xs) @ []\n  snd (snd (group_part_aux (f p) xs ([], p, []))) =\n  rev (filter (\\<lambda>x. f p < f x) xs) @ []\n  fst (snd (group_part_aux (f p) xs ([], p, []))) =\n  fold merge (filter (\\<lambda>x. f x = f p) xs) p\n\ngoal (1 subgoal):\n 1. group_part_aux (f p) xs ([], p, []) =\n    (rev (filter (\\<lambda>x. f x < f p) xs),\n     fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n     rev (filter (\\<lambda>x. f p < f x) xs))", "by (intro prod_eqI) simp_all"], ["proof (state)\nthis:\n  group_part p xs =\n  (rev (filter (\\<lambda>x. f x < f p) xs),\n   fold merge (filter (\\<lambda>x. f x = f p) xs) p,\n   rev (filter (\\<lambda>x. f p < f x) xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "function group_sort :: \"'a list \\<Rightarrow> 'a list\" where\n  \"group_sort [] = []\"\n| \"group_sort (x#xs) = (case group_part x xs of (ls, eq, gs) \\<Rightarrow> group_sort ls @ eq # group_sort gs)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>xa xs. x = xa # xs \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> [] = []\n 3. \\<And>x xs.\n       [] = x # xs \\<Longrightarrow>\n       [] =\n       (case group_part x xs of\n        (ls, eq, gs) \\<Rightarrow>\n          group_sort_sumC ls @ eq # group_sort_sumC gs)\n 4. \\<And>x xs xa xsa.\n       x # xs = xa # xsa \\<Longrightarrow>\n       (case group_part x xs of\n        (ls, eq, gs) \\<Rightarrow>\n          group_sort_sumC ls @ eq # group_sort_sumC gs) =\n       (case group_part xa xsa of\n        (ls, eq, gs) \\<Rightarrow>\n          group_sort_sumC ls @ eq # group_sort_sumC gs)", "by pat_completeness simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All group_sort_dom", "by (relation \"Wellfounded.measure length\") (simp_all add: group_part less_Suc_eq_le)"], ["", "private"], ["", "lemma group_append:\n  assumes \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> f x \\<noteq> f y\"\n  shows   \"group (xs @ ys) = group xs @ group ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.group (xs @ ys) = local.group xs @ local.group ys", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<noteq> f ?y\n\ngoal (1 subgoal):\n 1. local.group (xs @ ys) = local.group xs @ local.group ys", "proof (induction xs arbitrary: ys rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (\\<forall>xa.\n                           xa \\<in> set ys \\<longrightarrow>\n                           (\\<forall>xb.\n                               xb \\<in> set x \\<longrightarrow>\n                               f xa \\<noteq> f xb)) \\<longrightarrow>\n                       local.group (ys @ x) =\n                       local.group ys @ local.group x);\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> f x \\<noteq> f y\\<rbrakk>\n       \\<Longrightarrow> local.group (xs @ ys) =\n                         local.group xs @ local.group ys", "case (1 xs')"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs' \\<longrightarrow>\n     (\\<forall>x.\n         (\\<forall>xa.\n             xa \\<in> set ys \\<longrightarrow>\n             (\\<forall>xb.\n                 xb \\<in> set x \\<longrightarrow>\n                 f xa \\<noteq> f xb)) \\<longrightarrow>\n         local.group (ys @ x) = local.group ys @ local.group x)\n  \\<lbrakk>?x \\<in> set xs'; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<noteq> f ?y\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (\\<forall>xa.\n                           xa \\<in> set ys \\<longrightarrow>\n                           (\\<forall>xb.\n                               xb \\<in> set x \\<longrightarrow>\n                               f xa \\<noteq> f xb)) \\<longrightarrow>\n                       local.group (ys @ x) =\n                       local.group ys @ local.group x);\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> f x \\<noteq> f y\\<rbrakk>\n       \\<Longrightarrow> local.group (xs @ ys) =\n                         local.group xs @ local.group ys", "hence IH: \"\\<And>x xs ys. length xs < length xs' \\<Longrightarrow> (\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> f x \\<noteq> f y)\n                \\<Longrightarrow> group (xs @ ys) = group xs @ group ys\""], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs' \\<longrightarrow>\n     (\\<forall>x.\n         (\\<forall>xa.\n             xa \\<in> set ys \\<longrightarrow>\n             (\\<forall>xb.\n                 xb \\<in> set x \\<longrightarrow>\n                 f xa \\<noteq> f xb)) \\<longrightarrow>\n         local.group (ys @ x) = local.group ys @ local.group x)\n  \\<lbrakk>?x \\<in> set xs'; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<noteq> f ?y\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>length xs < length xs';\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> f x \\<noteq> f y\\<rbrakk>\n       \\<Longrightarrow> local.group (xs @ ys) =\n                         local.group xs @ local.group ys", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>length ?xs < length xs';\n   \\<And>x y.\n      \\<lbrakk>x \\<in> set ?xs; y \\<in> set ?ys\\<rbrakk>\n      \\<Longrightarrow> f x \\<noteq> f y\\<rbrakk>\n  \\<Longrightarrow> local.group (?xs @ ?ys) =\n                    local.group ?xs @ local.group ?ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (\\<forall>xa.\n                           xa \\<in> set ys \\<longrightarrow>\n                           (\\<forall>xb.\n                               xb \\<in> set x \\<longrightarrow>\n                               f xa \\<noteq> f xb)) \\<longrightarrow>\n                       local.group (ys @ x) =\n                       local.group ys @ local.group x);\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> f x \\<noteq> f y\\<rbrakk>\n       \\<Longrightarrow> local.group (xs @ ys) =\n                         local.group xs @ local.group ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.group (xs' @ ys) = local.group xs' @ local.group ys", "proof (cases xs')"], ["proof (state)\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs' = x # xs\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "note [simp] = this"], ["proof (state)\nthis:\n  xs' = x # xs\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "have \"group (xs' @ ys) = fold merge [y\\<leftarrow>xs@ys . f y = f x] x #\n            group ([xa\\<leftarrow>xs . f xa \\<noteq> f x] @ [xa\\<leftarrow>ys . f xa \\<noteq> f x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.group (xs' @ ys) =\n    fold merge (filter (\\<lambda>y. f y = f x) (xs @ ys)) x #\n    local.group\n     (filter (\\<lambda>xa. f xa \\<noteq> f x) xs @\n      filter (\\<lambda>xa. f xa \\<noteq> f x) ys)", "by (simp add: o_def)"], ["proof (state)\nthis:\n  local.group (xs' @ ys) =\n  fold merge (filter (\\<lambda>y. f y = f x) (xs @ ys)) x #\n  local.group\n   (filter (\\<lambda>xa. f xa \\<noteq> f x) xs @\n    filter (\\<lambda>xa. f xa \\<noteq> f x) ys)\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "also"], ["proof (state)\nthis:\n  local.group (xs' @ ys) =\n  fold merge (filter (\\<lambda>y. f y = f x) (xs @ ys)) x #\n  local.group\n   (filter (\\<lambda>xa. f xa \\<noteq> f x) xs @\n    filter (\\<lambda>xa. f xa \\<noteq> f x) ys)\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "from 1(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set xs'; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<noteq> f ?y", "have \"[y\\<leftarrow>xs@ys . f y = f x] = [y\\<leftarrow>xs . f y = f x]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs'; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<noteq> f ?y\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. f y = f x) (xs @ ys) =\n    filter (\\<lambda>y. f y = f x) xs", "by (force simp: filter_empty_conv)"], ["proof (state)\nthis:\n  filter (\\<lambda>y. f y = f x) (xs @ ys) =\n  filter (\\<lambda>y. f y = f x) xs\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "also"], ["proof (state)\nthis:\n  filter (\\<lambda>y. f y = f x) (xs @ ys) =\n  filter (\\<lambda>y. f y = f x) xs\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "from 1(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set xs'; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<noteq> f ?y", "have \"[xa\\<leftarrow>ys . f xa \\<noteq> f x] = ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs'; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<noteq> f ?y\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>xa. f xa \\<noteq> f x) ys = ys", "by (force simp: filter_id_conv)"], ["proof (state)\nthis:\n  filter (\\<lambda>xa. f xa \\<noteq> f x) ys = ys\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "also"], ["proof (state)\nthis:\n  filter (\\<lambda>xa. f xa \\<noteq> f x) ys = ys\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "have \"group ([xa\\<leftarrow>xs . f xa \\<noteq> f x] @ ys) =\n               group [xa\\<leftarrow>xs . f xa \\<noteq> f x] @ group ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs @ ys) =\n    local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs) @\n    local.group ys", "using 1(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs'; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<noteq> f ?y\n\ngoal (1 subgoal):\n 1. local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs @ ys) =\n    local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs) @\n    local.group ys", "by (intro IH) (simp_all add: less_Suc_eq_le)"], ["proof (state)\nthis:\n  local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs @ ys) =\n  local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs) @ local.group ys\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       local.group (xs' @ ys) = local.group xs' @ local.group ys", "finally"], ["proof (chain)\npicking this:\n  local.group (xs' @ ys) =\n  fold merge (filter (\\<lambda>y. f y = f x) xs) x #\n  local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs) @ local.group ys", "show ?thesis"], ["proof (prove)\nusing this:\n  local.group (xs' @ ys) =\n  fold merge (filter (\\<lambda>y. f y = f x) xs) x #\n  local.group (filter (\\<lambda>xa. f xa \\<noteq> f x) xs) @ local.group ys\n\ngoal (1 subgoal):\n 1. local.group (xs' @ ys) = local.group xs' @ local.group ys", "by (simp add: o_def)"], ["proof (state)\nthis:\n  local.group (xs' @ ys) = local.group xs' @ local.group ys\n\ngoal (1 subgoal):\n 1. xs' = [] \\<Longrightarrow>\n    local.group (xs' @ ys) = local.group xs' @ local.group ys", "qed simp"], ["proof (state)\nthis:\n  local.group (xs' @ ys) = local.group xs' @ local.group ys\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma group_empty_iff [simp]: \"group xs = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.group xs = []) = (xs = [])", "by (induction xs rule: group.induct) auto"], ["", "lemma group_sort_correct: \"group_sort xs = group (sort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_sort xs = local.group (local.sort xs)", "proof (induction xs rule: group_sort.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "case (2 x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = group_part x xs; (?xb, ?ya) = ?y\\<rbrakk>\n  \\<Longrightarrow> group_sort ?xa = local.group (local.sort ?xa)\n  \\<lbrakk>(?xa, ?y) = group_part x xs; (?xb, ?ya) = ?y\\<rbrakk>\n  \\<Longrightarrow> group_sort ?ya = local.group (local.sort ?ya)\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "have \"group_sort (x#xs) = \n          group_sort (rev [xa\\<leftarrow>xs . f xa < f x]) @ group (x#[xa\\<leftarrow>xs . f xa = f x]) @\n          group_sort (rev [xa\\<leftarrow>xs . f x < f xa])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_sort (x # xs) =\n    group_sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) @\n    local.group (x # filter (\\<lambda>xa. f xa = f x) xs) @\n    group_sort (rev (filter (\\<lambda>xa. f x < f xa) xs))", "by (simp add: group_part)"], ["proof (state)\nthis:\n  group_sort (x # xs) =\n  group_sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) @\n  local.group (x # filter (\\<lambda>xa. f xa = f x) xs) @\n  group_sort (rev (filter (\\<lambda>xa. f x < f xa) xs))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "also"], ["proof (state)\nthis:\n  group_sort (x # xs) =\n  group_sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) @\n  local.group (x # filter (\\<lambda>xa. f xa = f x) xs) @\n  group_sort (rev (filter (\\<lambda>xa. f x < f xa) xs))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "have \"group_sort (rev [xa\\<leftarrow>xs . f xa < f x]) = group (sort (rev [xa\\<leftarrow>xs . f xa < f x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) =\n    local.group (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)))", "by (rule 2) (simp_all add: group_part)"], ["proof (state)\nthis:\n  group_sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) =\n  local.group (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "also"], ["proof (state)\nthis:\n  group_sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) =\n  local.group (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "have \"group_sort (rev [xa\\<leftarrow>xs . f xa > f x]) = group (sort (rev [xa\\<leftarrow>xs . f xa > f x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_sort (rev (filter (\\<lambda>xa. f x < f xa) xs)) =\n    local.group (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))", "by (rule 2) (simp_all add: group_part)"], ["proof (state)\nthis:\n  group_sort (rev (filter (\\<lambda>xa. f x < f xa) xs)) =\n  local.group (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "also"], ["proof (state)\nthis:\n  group_sort (rev (filter (\\<lambda>xa. f x < f xa) xs)) =\n  local.group (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "have \"group (x#[xa\\<leftarrow>xs . f xa = f x]) @ group (sort (rev [xa\\<leftarrow>xs . f xa > f x])) =\n             group ((x#[xa\\<leftarrow>xs . f xa = f x]) @ sort (rev [xa\\<leftarrow>xs . f xa > f x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.group (x # filter (\\<lambda>xa. f xa = f x) xs) @\n    local.group (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs))) =\n    local.group\n     ((x # filter (\\<lambda>xa. f xa = f x) xs) @\n      local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))", "by (intro group_append[symmetric]) (auto simp: set_sort)"], ["proof (state)\nthis:\n  local.group (x # filter (\\<lambda>xa. f xa = f x) xs) @\n  local.group (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs))) =\n  local.group\n   ((x # filter (\\<lambda>xa. f xa = f x) xs) @\n    local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "also"], ["proof (state)\nthis:\n  local.group (x # filter (\\<lambda>xa. f xa = f x) xs) @\n  local.group (local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs))) =\n  local.group\n   ((x # filter (\\<lambda>xa. f xa = f x) xs) @\n    local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "have \"group (sort (rev [xa\\<leftarrow>xs . f xa < f x])) @ ... = \n             group (sort (rev [xa\\<leftarrow>xs . f xa < f x]) @ (x#[xa\\<leftarrow>xs . f xa = f x]) @\n                 sort (rev [xa\\<leftarrow>xs . f xa > f x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.group (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs))) @\n    local.group\n     ((x # filter (\\<lambda>xa. f xa = f x) xs) @\n      local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs))) =\n    local.group\n     (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) @\n      (x # filter (\\<lambda>xa. f xa = f x) xs) @\n      local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))", "by (intro group_append[symmetric]) (auto simp: set_sort)"], ["proof (state)\nthis:\n  local.group (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs))) @\n  local.group\n   ((x # filter (\\<lambda>xa. f xa = f x) xs) @\n    local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs))) =\n  local.group\n   (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) @\n    (x # filter (\\<lambda>xa. f xa = f x) xs) @\n    local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "also"], ["proof (state)\nthis:\n  local.group (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs))) @\n  local.group\n   ((x # filter (\\<lambda>xa. f xa = f x) xs) @\n    local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs))) =\n  local.group\n   (local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) @\n    (x # filter (\\<lambda>xa. f xa = f x) xs) @\n    local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)))\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "have \"sort (rev [xa\\<leftarrow>xs . f xa < f x]) @ (x#[xa\\<leftarrow>xs . f xa = f x]) @\n                 sort (rev [xa\\<leftarrow>xs . f xa > f x]) = sort (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) @\n    (x # filter (\\<lambda>xa. f xa = f x) xs) @\n    local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)) =\n    local.sort (x # xs)", "by (simp add: part)"], ["proof (state)\nthis:\n  local.sort (rev (filter (\\<lambda>xa. f xa < f x) xs)) @\n  (x # filter (\\<lambda>xa. f xa = f x) xs) @\n  local.sort (rev (filter (\\<lambda>xa. f x < f xa) xs)) =\n  local.sort (x # xs)\n\ngoal (2 subgoals):\n 1. group_sort [] = local.group (local.sort [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xa y xb ya.\n                   \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n                   \\<Longrightarrow> group_sort xa =\n                                     local.group (local.sort xa);\n        \\<And>xa y xb ya.\n           \\<lbrakk>(xa, y) = group_part x xs; (xb, ya) = y\\<rbrakk>\n           \\<Longrightarrow> group_sort ya =\n                             local.group (local.sort ya)\\<rbrakk>\n       \\<Longrightarrow> group_sort (x # xs) =\n                         local.group (local.sort (x # xs))", "finally"], ["proof (chain)\npicking this:\n  group_sort (x # xs) = local.group (local.sort (x # xs))", "show ?case"], ["proof (prove)\nusing this:\n  group_sort (x # xs) = local.group (local.sort (x # xs))\n\ngoal (1 subgoal):\n 1. group_sort (x # xs) = local.group (local.sort (x # xs))", "."], ["proof (state)\nthis:\n  group_sort (x # xs) = local.group (local.sort (x # xs))\n\ngoal (1 subgoal):\n 1. group_sort [] = local.group (local.sort [])", "qed simp"], ["", "lemma sorted_group_sort: \"sorted (map f (group_sort xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map f (group_sort xs))", "by (auto simp: group_sort_correct intro!: sorted_group sorted_sort)"], ["", "lemma distinct_group_sort: \"distinct (map f (group_sort xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f (group_sort xs))", "by (simp add: group_sort_correct distinct_group)"], ["", "lemma g_group_sort: \"g (group_sort xs) = g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (group_sort xs) = g xs", "by (simp add: group_sort_correct g_group g_sort)"], ["", "lemmas [simp del] = group_sort.simps group_part_aux.simps"], ["", "end"], ["", "end"], ["", "end"]]}