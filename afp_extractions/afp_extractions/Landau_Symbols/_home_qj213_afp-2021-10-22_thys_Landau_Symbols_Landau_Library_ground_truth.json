{"file_name": "/home/qj213/afp-2021-10-22/thys/Landau_Symbols/Landau_Library.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Landau_Symbols", "problem_names": ["lemma eventually_at_top_compose:\n  assumes \"\\<And>c. eventually (\\<lambda>x. (f x:: 'a :: linorder) \\<ge> c) F\" \"eventually P at_top\"\n  shows   \"eventually (\\<lambda>x. P (f x)) F\"", "lemma eventually_False_at_top_linorder [simp]: \n  \"eventually (\\<lambda>_::_::linorder. False) at_top \\<longleftrightarrow> False\"", "lemma eventually_not_equal: \"eventually (\\<lambda>x::'a::linordered_semidom. x \\<noteq> a) at_top\"", "lemma eventually_subst':\n  \"eventually (\\<lambda>x. f x = g x) F \\<Longrightarrow> eventually (\\<lambda>x. P x (f x)) F = eventually (\\<lambda>x. P x (g x)) F\"", "lemma eventually_nat_real:\n  assumes \"eventually P (at_top :: real filter)\"\n  shows   \"eventually (\\<lambda>x. P (real x)) (at_top :: nat filter)\"", "lemma filterlim_cong':\n  assumes \"filterlim f F G\"\n  assumes \"eventually (\\<lambda>x. f x = g x) G\"\n  shows   \"filterlim g F G\"", "lemma eventually_ln_at_top: \"eventually (\\<lambda>x. P (ln x :: real)) at_top = eventually P at_top\"", "lemma filtermap_ln_at_top: \"filtermap (ln :: real \\<Rightarrow> real) at_top = at_top\"", "lemma eventually_ln_not_equal: \"eventually (\\<lambda>x::real. ln x \\<noteq> a) at_top\"", "lemma ln_mono: \"0 < x \\<Longrightarrow> 0 < y \\<Longrightarrow> x \\<le> y \\<Longrightarrow> ln (x::real) \\<le> ln y\"", "lemma ln_mono_strict: \"0 < x \\<Longrightarrow> 0 < y \\<Longrightarrow> x < y \\<Longrightarrow> ln (x::real) < ln y\"", "lemma prod_list_pos: \"(\\<And>x::_::linordered_semidom. x \\<in> set xs \\<Longrightarrow> x > 0) \\<Longrightarrow> prod_list xs > 0\"", "lemma (in monoid_mult) fold_plus_prod_list_rev:\n  \"fold times xs = times (prod_list (rev xs))\"", "lemma powr_realpow_eventually: \n  assumes \"filterlim f at_top F\"\n  shows   \"eventually (\\<lambda>x. f x powr (real n) = f x ^ n) F\"", "lemma zero_powr [simp]: \"(0::real) powr x = 0\"", "lemma powr_negD: \"(a::real) powr b \\<le> 0 \\<Longrightarrow> a = 0\"", "lemma inverse_powr [simp]:\n  assumes \"(x::real) \\<ge> 0\"\n  shows   \"inverse x powr y = inverse (x powr y)\"", "lemma powr_mono':\n  assumes \"(x::real) > 0\" \"x \\<le> 1\" \"a \\<le> b\"\n  shows   \"x powr b \\<le> x powr a\"", "lemma powr_less_mono':\n  assumes \"(x::real) > 0\" \"x < 1\" \"a < b\"\n  shows   \"x powr b < x powr a\"", "lemma powr_lower_bound: \"\\<lbrakk>(l::real) > 0; l \\<le> x; x \\<le> u\\<rbrakk> \\<Longrightarrow> min (l powr z) (u powr z) \\<le> x powr z\"", "lemma powr_upper_bound: \"\\<lbrakk>(l::real) > 0; l \\<le> x; x \\<le> u\\<rbrakk> \\<Longrightarrow> max (l powr z) (u powr z) \\<ge> x powr z\"", "lemma powr_eventually_exp_ln: \"eventually (\\<lambda>x. (x::real) powr p = exp (p * ln x)) at_top\"", "lemma powr_eventually_exp_ln': \n  assumes \"x > 0\"\n  shows   \"eventually (\\<lambda>x. (x::real) powr p = exp (p * ln x)) (nhds x)\"", "lemma powr_at_top: \n  assumes \"(p::real) > 0\"\n  shows   \"filterlim (\\<lambda>x. x powr p) at_top at_top\"", "lemma powr_at_top_neg: \n  assumes \"(a::real) > 0\" \"a < 1\"\n  shows   \"((\\<lambda>x. a powr x) \\<longlongrightarrow> 0) at_top\"", "lemma powr_at_bot:\n  assumes \"(a::real) > 1\"\n  shows   \"((\\<lambda>x. a powr x) \\<longlongrightarrow> 0) at_bot\"", "lemma powr_at_bot_neg:\n  assumes \"(a::real) > 0\" \"a < 1\"\n  shows   \"filterlim (\\<lambda>x. a powr x) at_top at_bot\"", "lemma DERIV_powr: \n  assumes \"x > 0\"\n  shows   \"((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)\""], "translations": [["", "lemma eventually_at_top_compose:\n  assumes \"\\<And>c. eventually (\\<lambda>x. (f x:: 'a :: linorder) \\<ge> c) F\" \"eventually P at_top\"\n  shows   \"eventually (\\<lambda>x. P (f x)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. P (f x)", "using assms filterlim_at_top filterlim_iff"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. ?c \\<le> f x\n  eventually P at_top\n  filterlim ?f at_top ?F =\n  (\\<forall>Z. \\<forall>\\<^sub>F x in ?F. Z \\<le> ?f x)\n  filterlim ?f ?F2.0 ?F1.0 =\n  (\\<forall>P.\n      eventually P ?F2.0 \\<longrightarrow>\n      (\\<forall>\\<^sub>F x in ?F1.0. P (?f x)))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. P (f x)", "by blast"], ["", "lemma eventually_False_at_top_linorder [simp]: \n  \"eventually (\\<lambda>_::_::linorder. False) at_top \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F _ in at_top. False) = False", "unfolding eventually_at_top_linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>N. \\<forall>n\\<ge>N. False) = False", "by force"], ["", "lemma eventually_not_equal: \"eventually (\\<lambda>x::'a::linordered_semidom. x \\<noteq> a) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x \\<noteq> a", "using eventually_ge_at_top[of \"a+1\"]"], ["proof (prove)\nusing this:\n  eventually ((\\<le>) (a + (1::'a))) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x \\<noteq> a", "by eventually_elim (insert less_add_one[of a], auto)"], ["", "lemma eventually_subst':\n  \"eventually (\\<lambda>x. f x = g x) F \\<Longrightarrow> eventually (\\<lambda>x. P x (f x)) F = eventually (\\<lambda>x. P x (g x)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x = g x \\<Longrightarrow>\n    (\\<forall>\\<^sub>F x in F. P x (f x)) =\n    (\\<forall>\\<^sub>F x in F. P x (g x))", "by (rule eventually_subst, erule eventually_rev_mp) simp"], ["", "lemma eventually_nat_real:\n  assumes \"eventually P (at_top :: real filter)\"\n  shows   \"eventually (\\<lambda>x. P (real x)) (at_top :: nat filter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially. P (real x)", "using assms filterlim_real_sequentially"], ["proof (prove)\nusing this:\n  eventually P at_top\n  filterlim real at_top sequentially\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially. P (real x)", "unfolding filterlim_def le_filter_def eventually_filtermap"], ["proof (prove)\nusing this:\n  eventually P at_top\n  \\<forall>P.\n     eventually P at_top \\<longrightarrow>\n     (\\<forall>\\<^sub>F x in sequentially. P (real x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially. P (real x)", "by auto"], ["", "lemma filterlim_cong':\n  assumes \"filterlim f F G\"\n  assumes \"eventually (\\<lambda>x. f x = g x) G\"\n  shows   \"filterlim g F G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim g F G", "using assms"], ["proof (prove)\nusing this:\n  filterlim f F G\n  \\<forall>\\<^sub>F x in G. f x = g x\n\ngoal (1 subgoal):\n 1. filterlim g F G", "by (subst filterlim_cong[OF refl refl, of _ f]) (auto elim: eventually_mono)"], ["", "lemma eventually_ln_at_top: \"eventually (\\<lambda>x. P (ln x :: real)) at_top = eventually P at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at_top. P (ln x)) = eventually P at_top", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "fix P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "assume \"eventually (\\<lambda>x. P (ln x :: real)) at_top\""], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. P (ln x)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top. P (ln x)", "obtain x0 where x0: \"\\<And>x. x \\<ge> x0 \\<Longrightarrow> P (ln x)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. P (ln x)\n\ngoal (1 subgoal):\n 1. (\\<And>x0.\n        (\\<And>x. x0 \\<le> x \\<Longrightarrow> P (ln x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) eventually_at_top_linorder) auto"], ["proof (state)\nthis:\n  x0 \\<le> ?x \\<Longrightarrow> P (ln ?x)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "{"], ["proof (state)\nthis:\n  x0 \\<le> ?x \\<Longrightarrow> P (ln ?x)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "assume \"x \\<ge> ln (max 1 x0)\""], ["proof (state)\nthis:\n  ln (max 1 x0) \\<le> x\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "hence \"exp x \\<ge> max 1 x0\""], ["proof (prove)\nusing this:\n  ln (max 1 x0) \\<le> x\n\ngoal (1 subgoal):\n 1. max 1 x0 \\<le> exp x", "by (subst (2) exp_ln[symmetric], simp, subst exp_le_cancel_iff)"], ["proof (state)\nthis:\n  max 1 x0 \\<le> exp x\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "hence \"exp x \\<ge> x0\""], ["proof (prove)\nusing this:\n  max 1 x0 \\<le> exp x\n\ngoal (1 subgoal):\n 1. x0 \\<le> exp x", "by simp"], ["proof (state)\nthis:\n  x0 \\<le> exp x\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "from x0[OF this]"], ["proof (chain)\npicking this:\n  P (ln (exp x))", "have \"P x\""], ["proof (prove)\nusing this:\n  P (ln (exp x))\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["proof (state)\nthis:\n  P x\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "}"], ["proof (state)\nthis:\n  ln (max 1 x0) \\<le> ?x2 \\<Longrightarrow> P ?x2\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x) \\<Longrightarrow>\n    eventually P at_top\n 2. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "thus \"eventually P at_top\""], ["proof (prove)\nusing this:\n  ln (max 1 x0) \\<le> ?x2 \\<Longrightarrow> P ?x2\n\ngoal (1 subgoal):\n 1. eventually P at_top", "by (subst eventually_at_top_linorder) blast"], ["proof (state)\nthis:\n  eventually P at_top\n\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "fix P :: \"real \\<Rightarrow> bool\""], ["proof (state)\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "assume  \"eventually P at_top\""], ["proof (state)\nthis:\n  eventually P at_top\n\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "then"], ["proof (chain)\npicking this:\n  eventually P at_top", "obtain x0 where x0: \"\\<And>x. x \\<ge> x0 \\<Longrightarrow> P x\""], ["proof (prove)\nusing this:\n  eventually P at_top\n\ngoal (1 subgoal):\n 1. (\\<And>x0.\n        (\\<And>x. x0 \\<le> x \\<Longrightarrow> P x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) eventually_at_top_linorder) auto"], ["proof (state)\nthis:\n  x0 \\<le> ?x \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "{"], ["proof (state)\nthis:\n  x0 \\<le> ?x \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "assume \"x \\<ge> exp x0\""], ["proof (state)\nthis:\n  exp x0 \\<le> x\n\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "hence \"ln x \\<ge> x0\""], ["proof (prove)\nusing this:\n  exp x0 \\<le> x\n\ngoal (1 subgoal):\n 1. x0 \\<le> ln x", "by (subst ln_exp[symmetric], subst ln_le_cancel_iff)\n                         (simp_all add: less_le_trans[OF exp_gt_zero])"], ["proof (state)\nthis:\n  x0 \\<le> ln x\n\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "from x0[OF this]"], ["proof (chain)\npicking this:\n  P (ln x)", "have \"P (ln x)\""], ["proof (prove)\nusing this:\n  P (ln x)\n\ngoal (1 subgoal):\n 1. P (ln x)", "."], ["proof (state)\nthis:\n  P (ln x)\n\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "}"], ["proof (state)\nthis:\n  exp x0 \\<le> ?x2 \\<Longrightarrow> P (ln ?x2)\n\ngoal (1 subgoal):\n 1. eventually P at_top \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. P (ln x)", "thus \"eventually (\\<lambda>x. P (ln x)) at_top\""], ["proof (prove)\nusing this:\n  exp x0 \\<le> ?x2 \\<Longrightarrow> P (ln ?x2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. P (ln x)", "by (subst eventually_at_top_linorder) blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. P (ln x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filtermap_ln_at_top: \"filtermap (ln :: real \\<Rightarrow> real) at_top = at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap ln at_top = at_top", "by (simp add: filter_eq_iff eventually_filtermap eventually_ln_at_top)"], ["", "lemma eventually_ln_not_equal: \"eventually (\\<lambda>x::real. ln x \\<noteq> a) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln x \\<noteq> a", "by (subst eventually_ln_at_top) (rule eventually_not_equal)"], ["", "subsection \\<open>Miscellaneous\\<close>"], ["", "lemma ln_mono: \"0 < x \\<Longrightarrow> 0 < y \\<Longrightarrow> x \\<le> y \\<Longrightarrow> ln (x::real) \\<le> ln y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; 0 < y; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ln x \\<le> ln y", "by (subst ln_le_cancel_iff) simp_all"], ["", "lemma ln_mono_strict: \"0 < x \\<Longrightarrow> 0 < y \\<Longrightarrow> x < y \\<Longrightarrow> ln (x::real) < ln y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; 0 < y; x < y\\<rbrakk> \\<Longrightarrow> ln x < ln y", "by (subst ln_less_cancel_iff) simp_all"], ["", "lemma prod_list_pos: \"(\\<And>x::_::linordered_semidom. x \\<in> set xs \\<Longrightarrow> x > 0) \\<Longrightarrow> prod_list xs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> (0::'a) < x) \\<Longrightarrow>\n    (0::'a) < prod_list xs", "by (induction xs) auto"], ["", "lemma (in monoid_mult) fold_plus_prod_list_rev:\n  \"fold times xs = times (prod_list (rev xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (*) xs = (*) (prod_list (rev xs))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "have \"fold times xs x = prod_list (rev xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (*) xs x = prod_list (rev xs @ [x])", "by (simp add: foldr_conv_fold prod_list.eq_foldr)"], ["proof (state)\nthis:\n  fold (*) xs x = prod_list (rev xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "also"], ["proof (state)\nthis:\n  fold (*) xs x = prod_list (rev xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "have \"\\<dots> = prod_list (rev xs) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (rev xs @ [x]) = prod_list (rev xs) * x", "by simp"], ["proof (state)\nthis:\n  prod_list (rev xs @ [x]) = prod_list (rev xs) * x\n\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "finally"], ["proof (chain)\npicking this:\n  fold (*) xs x = prod_list (rev xs) * x", "show \"fold times xs x = prod_list (rev xs) * x\""], ["proof (prove)\nusing this:\n  fold (*) xs x = prod_list (rev xs) * x\n\ngoal (1 subgoal):\n 1. fold (*) xs x = prod_list (rev xs) * x", "."], ["proof (state)\nthis:\n  fold (*) xs x = prod_list (rev xs) * x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Real powers\\<close>"], ["", "lemma powr_realpow_eventually: \n  assumes \"filterlim f at_top F\"\n  shows   \"eventually (\\<lambda>x. f x powr (real n) = f x ^ n) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x powr real n = f x ^ n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x powr real n = f x ^ n", "from assms"], ["proof (chain)\npicking this:\n  filterlim f at_top F", "have \"eventually (\\<lambda>x. f x > 0) F\""], ["proof (prove)\nusing this:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < f x", "using filterlim_at_top_dense"], ["proof (prove)\nusing this:\n  filterlim f at_top F\n  filterlim ?f at_top ?F = (\\<forall>Z. \\<forall>\\<^sub>F x in ?F. Z < ?f x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < f x", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 < f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x powr real n = f x ^ n", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x powr real n = f x ^ n", "by eventually_elim (simp add: powr_realpow)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. f x powr real n = f x ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_powr [simp]: \"(0::real) powr x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 powr x = 0", "unfolding powr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 = 0 then 0 else exp (x * ln 0)) = 0", "by simp"], ["", "lemma powr_negD: \"(a::real) powr b \\<le> 0 \\<Longrightarrow> a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a powr b \\<le> 0 \\<Longrightarrow> a = 0", "unfolding powr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = 0 then 0 else exp (b * ln a)) \\<le> 0 \\<Longrightarrow> a = 0", "by (simp split: if_split_asm)"], ["", "lemma inverse_powr [simp]:\n  assumes \"(x::real) \\<ge> 0\"\n  shows   \"inverse x powr y = inverse (x powr y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse x powr y = inverse (x powr y)", "proof (cases \"x > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)\n 2. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "assume x: \"x > 0\""], ["proof (state)\nthis:\n  0 < x\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)\n 2. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "from x"], ["proof (chain)\npicking this:\n  0 < x", "have \"inverse x powr y = exp (y * ln (inverse x))\""], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. inverse x powr y = exp (y * ln (inverse x))", "by (simp add: powr_def)"], ["proof (state)\nthis:\n  inverse x powr y = exp (y * ln (inverse x))\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)\n 2. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "also"], ["proof (state)\nthis:\n  inverse x powr y = exp (y * ln (inverse x))\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)\n 2. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "have \"ln (inverse x) = -ln x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (inverse x) = - ln x", "by (simp add: x ln_inverse)"], ["proof (state)\nthis:\n  ln (inverse x) = - ln x\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)\n 2. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "also"], ["proof (state)\nthis:\n  ln (inverse x) = - ln x\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)\n 2. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "have \"exp (y * -ln x) = inverse (exp (y * ln x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (y * - ln x) = inverse (exp (y * ln x))", "by (simp add: exp_minus)"], ["proof (state)\nthis:\n  exp (y * - ln x) = inverse (exp (y * ln x))\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)\n 2. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "also"], ["proof (state)\nthis:\n  exp (y * - ln x) = inverse (exp (y * ln x))\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)\n 2. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "from x"], ["proof (chain)\npicking this:\n  0 < x", "have \"exp (y * ln x) = x powr y\""], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. exp (y * ln x) = x powr y", "by (simp add: powr_def)"], ["proof (state)\nthis:\n  exp (y * ln x) = x powr y\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)\n 2. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "finally"], ["proof (chain)\npicking this:\n  inverse x powr y = inverse (x powr y)", "show ?thesis"], ["proof (prove)\nusing this:\n  inverse x powr y = inverse (x powr y)\n\ngoal (1 subgoal):\n 1. inverse x powr y = inverse (x powr y)", "."], ["proof (state)\nthis:\n  inverse x powr y = inverse (x powr y)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < x \\<Longrightarrow> inverse x powr y = inverse (x powr y)", "qed (insert assms, simp)"], ["", "lemma powr_mono':\n  assumes \"(x::real) > 0\" \"x \\<le> 1\" \"a \\<le> b\"\n  shows   \"x powr b \\<le> x powr a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x powr b \\<le> x powr a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x powr b \\<le> x powr a", "have \"inverse x powr a \\<le> inverse x powr b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse x powr a \\<le> inverse x powr b", "using assms"], ["proof (prove)\nusing this:\n  0 < x\n  x \\<le> 1\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. inverse x powr a \\<le> inverse x powr b", "by (intro powr_mono) (simp_all add: field_simps)"], ["proof (state)\nthis:\n  inverse x powr a \\<le> inverse x powr b\n\ngoal (1 subgoal):\n 1. x powr b \\<le> x powr a", "hence \"inverse (x powr a) \\<le> inverse (x powr b)\""], ["proof (prove)\nusing this:\n  inverse x powr a \\<le> inverse x powr b\n\ngoal (1 subgoal):\n 1. inverse (x powr a) \\<le> inverse (x powr b)", "using assms"], ["proof (prove)\nusing this:\n  inverse x powr a \\<le> inverse x powr b\n  0 < x\n  x \\<le> 1\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. inverse (x powr a) \\<le> inverse (x powr b)", "by simp"], ["proof (state)\nthis:\n  inverse (x powr a) \\<le> inverse (x powr b)\n\ngoal (1 subgoal):\n 1. x powr b \\<le> x powr a", "with assms"], ["proof (chain)\npicking this:\n  0 < x\n  x \\<le> 1\n  a \\<le> b\n  inverse (x powr a) \\<le> inverse (x powr b)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < x\n  x \\<le> 1\n  a \\<le> b\n  inverse (x powr a) \\<le> inverse (x powr b)\n\ngoal (1 subgoal):\n 1. x powr b \\<le> x powr a", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x powr b \\<le> x powr a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powr_less_mono':\n  assumes \"(x::real) > 0\" \"x < 1\" \"a < b\"\n  shows   \"x powr b < x powr a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x powr b < x powr a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x powr b < x powr a", "have \"inverse x powr a < inverse x powr b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse x powr a < inverse x powr b", "using assms"], ["proof (prove)\nusing this:\n  0 < x\n  x < 1\n  a < b\n\ngoal (1 subgoal):\n 1. inverse x powr a < inverse x powr b", "by (intro powr_less_mono) (simp_all add: field_simps)"], ["proof (state)\nthis:\n  inverse x powr a < inverse x powr b\n\ngoal (1 subgoal):\n 1. x powr b < x powr a", "hence \"inverse (x powr a) < inverse (x powr b)\""], ["proof (prove)\nusing this:\n  inverse x powr a < inverse x powr b\n\ngoal (1 subgoal):\n 1. inverse (x powr a) < inverse (x powr b)", "using assms"], ["proof (prove)\nusing this:\n  inverse x powr a < inverse x powr b\n  0 < x\n  x < 1\n  a < b\n\ngoal (1 subgoal):\n 1. inverse (x powr a) < inverse (x powr b)", "by simp"], ["proof (state)\nthis:\n  inverse (x powr a) < inverse (x powr b)\n\ngoal (1 subgoal):\n 1. x powr b < x powr a", "with assms"], ["proof (chain)\npicking this:\n  0 < x\n  x < 1\n  a < b\n  inverse (x powr a) < inverse (x powr b)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < x\n  x < 1\n  a < b\n  inverse (x powr a) < inverse (x powr b)\n\ngoal (1 subgoal):\n 1. x powr b < x powr a", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x powr b < x powr a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powr_lower_bound: \"\\<lbrakk>(l::real) > 0; l \\<le> x; x \\<le> u\\<rbrakk> \\<Longrightarrow> min (l powr z) (u powr z) \\<le> x powr z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> x; x \\<le> u\\<rbrakk>\n    \\<Longrightarrow> min (l powr z) (u powr z) \\<le> x powr z", "apply (cases \"z \\<ge> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < l; l \\<le> x; x \\<le> u; 0 \\<le> z\\<rbrakk>\n    \\<Longrightarrow> min (l powr z) (u powr z) \\<le> x powr z\n 2. \\<lbrakk>0 < l; l \\<le> x; x \\<le> u; \\<not> 0 \\<le> z\\<rbrakk>\n    \\<Longrightarrow> min (l powr z) (u powr z) \\<le> x powr z", "apply (rule order.trans[OF min.cobounded1 powr_mono2], simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> x; x \\<le> u; \\<not> 0 \\<le> z\\<rbrakk>\n    \\<Longrightarrow> min (l powr z) (u powr z) \\<le> x powr z", "apply (rule order.trans[OF min.cobounded2 powr_mono2'], simp_all) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma powr_upper_bound: \"\\<lbrakk>(l::real) > 0; l \\<le> x; x \\<le> u\\<rbrakk> \\<Longrightarrow> max (l powr z) (u powr z) \\<ge> x powr z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> x; x \\<le> u\\<rbrakk>\n    \\<Longrightarrow> x powr z \\<le> max (l powr z) (u powr z)", "apply (cases \"z \\<ge> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < l; l \\<le> x; x \\<le> u; 0 \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x powr z \\<le> max (l powr z) (u powr z)\n 2. \\<lbrakk>0 < l; l \\<le> x; x \\<le> u; \\<not> 0 \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x powr z \\<le> max (l powr z) (u powr z)", "apply (rule order.trans[OF powr_mono2 max.cobounded2], simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> x; x \\<le> u; \\<not> 0 \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x powr z \\<le> max (l powr z) (u powr z)", "apply (rule order.trans[OF powr_mono2' max.cobounded1], simp_all) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma powr_eventually_exp_ln: \"eventually (\\<lambda>x. (x::real) powr p = exp (p * ln x)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x powr p = exp (p * ln x)", "using eventually_gt_at_top[of \"0::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x powr p = exp (p * ln x)", "unfolding powr_def"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       (if x = 0 then 0 else exp (p * ln x)) = exp (p * ln x)", "by eventually_elim simp_all"], ["", "lemma powr_eventually_exp_ln': \n  assumes \"x > 0\"\n  shows   \"eventually (\\<lambda>x. (x::real) powr p = exp (p * ln x)) (nhds x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in nhds x. x powr p = exp (p * ln x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in nhds x. x powr p = exp (p * ln x)", "let ?A = \"{(0::real)<..}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in nhds x. x powr p = exp (p * ln x)", "from assms"], ["proof (chain)\npicking this:\n  0 < x", "have \"eventually (\\<lambda>x. x > 0) (nhds x)\""], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. eventually ((<) 0) (nhds x)", "unfolding eventually_nhds"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. \\<exists>S. open S \\<and> x \\<in> S \\<and> Ball S ((<) 0)", "by (intro exI[of _ \"{(0::real)<..}\"]) simp_all"], ["proof (state)\nthis:\n  eventually ((<) 0) (nhds x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in nhds x. x powr p = exp (p * ln x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  eventually ((<) 0) (nhds x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in nhds x. x powr p = exp (p * ln x)", "by eventually_elim (simp add: powr_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in nhds x. x powr p = exp (p * ln x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powr_at_top: \n  assumes \"(p::real) > 0\"\n  shows   \"filterlim (\\<lambda>x. x powr p) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. x powr p :> at_top", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_top. x powr p :> at_top", "have \"LIM x at_top. exp (p * ln x) :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. exp (p * ln x) :> at_top", "by (rule filterlim_compose[OF exp_at_top filterlim_tendsto_pos_mult_at_top[OF tendsto_const]])\n       (simp_all add: ln_at_top assms)"], ["proof (state)\nthis:\n  LIM x at_top. exp (p * ln x) :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top. x powr p :> at_top", "thus ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_top. exp (p * ln x) :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top. x powr p :> at_top", "by (subst filterlim_cong[OF refl refl powr_eventually_exp_ln])"], ["proof (state)\nthis:\n  LIM x at_top. x powr p :> at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powr_at_top_neg: \n  assumes \"(a::real) > 0\" \"a < 1\"\n  shows   \"((\\<lambda>x. a powr x) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_top", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_top", "from assms"], ["proof (chain)\npicking this:\n  0 < a\n  a < 1", "have \"LIM x at_top. ln (inverse a) * x :> at_top\""], ["proof (prove)\nusing this:\n  0 < a\n  a < 1\n\ngoal (1 subgoal):\n 1. filterlim ((*) (ln (inverse a))) at_top at_top", "by (intro filterlim_tendsto_pos_mult_at_top[OF tendsto_const])\n       (simp_all add: filterlim_ident field_simps)"], ["proof (state)\nthis:\n  filterlim ((*) (ln (inverse a))) at_top at_top\n\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_top", "with assms"], ["proof (chain)\npicking this:\n  0 < a\n  a < 1\n  filterlim ((*) (ln (inverse a))) at_top at_top", "have \"LIM x at_top. ln a * x :> at_bot\""], ["proof (prove)\nusing this:\n  0 < a\n  a < 1\n  filterlim ((*) (ln (inverse a))) at_top at_top\n\ngoal (1 subgoal):\n 1. filterlim ((*) (ln a)) at_bot at_top", "by (subst filterlim_uminus_at_bot) (simp add: ln_inverse)"], ["proof (state)\nthis:\n  filterlim ((*) (ln a)) at_bot at_top\n\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_top", "hence \"((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\nusing this:\n  filterlim ((*) (ln a)) at_bot at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_top", "by (intro filterlim_compose[OF exp_at_bot]) (simp_all add: mult.commute)"], ["proof (state)\nthis:\n  ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_top", "with assms"], ["proof (chain)\npicking this:\n  0 < a\n  a < 1\n  ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < a\n  a < 1\n  ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_top", "unfolding powr_def"], ["proof (prove)\nusing this:\n  0 < a\n  a < 1\n  ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. if a = 0 then 0 else exp (x * ln a)) \\<longlongrightarrow>\n     0)\n     at_top", "by simp"], ["proof (state)\nthis:\n  ((powr) a \\<longlongrightarrow> 0) at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powr_at_bot:\n  assumes \"(a::real) > 1\"\n  shows   \"((\\<lambda>x. a powr x) \\<longlongrightarrow> 0) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_bot", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_bot", "from assms"], ["proof (chain)\npicking this:\n  1 < a", "have \"filterlim (\\<lambda>x. ln a * x) at_bot at_bot\""], ["proof (prove)\nusing this:\n  1 < a\n\ngoal (1 subgoal):\n 1. filterlim ((*) (ln a)) at_bot at_bot", "by (intro filterlim_tendsto_pos_mult_at_bot[OF tendsto_const _ filterlim_ident]) auto"], ["proof (state)\nthis:\n  filterlim ((*) (ln a)) at_bot at_bot\n\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_bot", "hence \"((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_bot\""], ["proof (prove)\nusing this:\n  filterlim ((*) (ln a)) at_bot at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_bot", "by (intro filterlim_compose[OF exp_at_bot]) (simp add: algebra_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_bot\n\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_bot\n\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_bot", "using assms"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_bot\n  1 < a\n\ngoal (1 subgoal):\n 1. ((powr) a \\<longlongrightarrow> 0) at_bot", "unfolding powr_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. exp (x * ln a)) \\<longlongrightarrow> 0) at_bot\n  1 < a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. if a = 0 then 0 else exp (x * ln a)) \\<longlongrightarrow>\n     0)\n     at_bot", "by simp"], ["proof (state)\nthis:\n  ((powr) a \\<longlongrightarrow> 0) at_bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powr_at_bot_neg:\n  assumes \"(a::real) > 0\" \"a < 1\"\n  shows   \"filterlim (\\<lambda>x. a powr x) at_top at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim ((powr) a) at_top at_bot", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. filterlim ((powr) a) at_top at_bot", "from assms"], ["proof (chain)\npicking this:\n  0 < a\n  a < 1", "have \"LIM x at_bot. ln (inverse a) * -x :> at_top\""], ["proof (prove)\nusing this:\n  0 < a\n  a < 1\n\ngoal (1 subgoal):\n 1. LIM x at_bot. ln (inverse a) * - x :> at_top", "by (intro filterlim_tendsto_pos_mult_at_top[OF tendsto_const] filterlim_uminus_at_top_at_bot)\n       (simp_all add: ln_inverse)"], ["proof (state)\nthis:\n  LIM x at_bot. ln (inverse a) * - x :> at_top\n\ngoal (1 subgoal):\n 1. filterlim ((powr) a) at_top at_bot", "with assms"], ["proof (chain)\npicking this:\n  0 < a\n  a < 1\n  LIM x at_bot. ln (inverse a) * - x :> at_top", "have \"LIM x at_bot. x * ln a :> at_top\""], ["proof (prove)\nusing this:\n  0 < a\n  a < 1\n  LIM x at_bot. ln (inverse a) * - x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. x * ln a :> at_top", "by (subst (asm) ln_inverse) (simp_all add: mult.commute)"], ["proof (state)\nthis:\n  LIM x at_bot. x * ln a :> at_top\n\ngoal (1 subgoal):\n 1. filterlim ((powr) a) at_top at_bot", "hence \"LIM x at_bot. exp (x * ln a) :> at_top\""], ["proof (prove)\nusing this:\n  LIM x at_bot. x * ln a :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. exp (x * ln a) :> at_top", "by (intro filterlim_compose[OF exp_at_top]) simp"], ["proof (state)\nthis:\n  LIM x at_bot. exp (x * ln a) :> at_top\n\ngoal (1 subgoal):\n 1. filterlim ((powr) a) at_top at_bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_bot. exp (x * ln a) :> at_top\n\ngoal (1 subgoal):\n 1. filterlim ((powr) a) at_top at_bot", "using assms"], ["proof (prove)\nusing this:\n  LIM x at_bot. exp (x * ln a) :> at_top\n  0 < a\n  a < 1\n\ngoal (1 subgoal):\n 1. filterlim ((powr) a) at_top at_bot", "unfolding powr_def"], ["proof (prove)\nusing this:\n  LIM x at_bot. exp (x * ln a) :> at_top\n  0 < a\n  a < 1\n\ngoal (1 subgoal):\n 1. LIM x at_bot. if a = 0 then 0 else exp (x * ln a) :> at_top", "by simp"], ["proof (state)\nthis:\n  filterlim ((powr) a) at_top at_bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DERIV_powr: \n  assumes \"x > 0\"\n  shows   \"((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)", "have \"((\\<lambda>x. exp (p * ln x)) has_real_derivative\n         exp (p * ln x) * (p * inverse x)) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. exp (p * ln x)) has_real_derivative\n     exp (p * ln x) * (p * inverse x))\n     (at x)", "unfolding powr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. exp (p * ln x)) has_real_derivative\n     exp (p * ln x) * (p * inverse x))\n     (at x)", "by (intro DERIV_fun_exp DERIV_cmult DERIV_ln) fact"], ["proof (state)\nthis:\n  ((\\<lambda>x. exp (p * ln x)) has_real_derivative\n   exp (p * ln x) * (p * inverse x))\n   (at x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. exp (p * ln x)) has_real_derivative\n   exp (p * ln x) * (p * inverse x))\n   (at x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)", "have \"exp (p * ln x) * (p * inverse x) = p * x powr (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (p * ln x) * (p * inverse x) = p * x powr (p - 1)", "unfolding powr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (p * ln x) * (p * inverse x) =\n    p * (if x = 0 then 0 else exp ((p - 1) * ln x))", "by (simp add: field_simps exp_diff assms)"], ["proof (state)\nthis:\n  exp (p * ln x) * (p * inverse x) = p * x powr (p - 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. exp (p * ln x)) has_real_derivative p * x powr (p - 1))\n   (at x)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. exp (p * ln x)) has_real_derivative p * x powr (p - 1))\n   (at x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)", "using assms"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. exp (p * ln x)) has_real_derivative p * x powr (p - 1))\n   (at x)\n  0 < x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)", "by (subst DERIV_cong_ev[OF refl powr_eventually_exp_ln' refl])"], ["proof (state)\nthis:\n  ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}