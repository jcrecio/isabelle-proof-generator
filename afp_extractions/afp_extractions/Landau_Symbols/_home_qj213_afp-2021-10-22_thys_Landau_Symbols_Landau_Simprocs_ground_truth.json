{"file_name": "/home/qj213/afp-2021-10-22/thys/Landau_Symbols/Landau_Simprocs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Landau_Symbols", "problem_names": ["lemma bigtheta_const [landau_simp]:\n  \"NO_MATCH 1 c \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> (\\<lambda>x. c) \\<in> \\<Theta>(\\<lambda>x. 1)\"", "lemmas [landau_simp] = bigtheta_const_ln bigtheta_const_ln_powr bigtheta_const_ln_pow", "lemma bigtheta_const_ln' [landau_simp]: \n  \"0 < a \\<Longrightarrow> (\\<lambda>x::real. ln (x * a)) \\<in> \\<Theta>(ln)\"", "lemma bigtheta_const_ln_powr' [landau_simp]: \n  \"0 < a \\<Longrightarrow> (\\<lambda>x::real. ln (x * a) powr p) \\<in> \\<Theta>(\\<lambda>x. ln x powr p)\"", "lemma bigtheta_const_ln_pow' [landau_simp]: \n  \"0 < a \\<Longrightarrow> (\\<lambda>x::real. ln (x * a) ^ p) \\<in> \\<Theta>(\\<lambda>x. ln x ^ p)\"", "lemma landau_gt_1_cong: \n  \"landau_symbol L L' Lr \\<Longrightarrow> (\\<And>x::real. x > 1 \\<Longrightarrow> f x = g x) \\<Longrightarrow> L at_top (f) = L at_top (g)\"", "lemma landau_gt_1_in_cong: \n  \"landau_symbol L L' Lr \\<Longrightarrow> (\\<And>x::real. x > 1 \\<Longrightarrow> f x = g x) \\<Longrightarrow> f \\<in> L at_top (h) \\<longleftrightarrow> g \\<in> L at_top (h)\"", "lemma landau_prop_equalsI:\n  \"landau_symbol L L' Lr \\<Longrightarrow> (\\<And>x::real. x > 1 \\<Longrightarrow> f1 x = f2 x) \\<Longrightarrow> (\\<And>x. x > 1 \\<Longrightarrow> g1 x = g2 x) \\<Longrightarrow> \n     f1 \\<in> L at_top (g1) \\<longleftrightarrow> f2 \\<in> L at_top (g2)\"", "lemma ab_diff_conv_add_uminus': \"(a::_::ab_group_add) - b = -b + a\"", "lemma extract_diff_middle: \"(a::_::ab_group_add) - (x + b) = -x + (a - b)\"", "lemma divide_inverse': \"(a::_::{division_ring,ab_semigroup_mult}) / b = inverse b * a\"", "lemma extract_divide_middle:\"(a::_::{field}) / (x * b) = inverse x * (a / b)\"", "lemmas landau_cancel = landau_symbol.mult_cancel_left", "lemmas mult_cancel_left' = landau_symbol.mult_cancel_left[OF _ bigtheta_refl eventually_nonzeroD]", "lemma mult_cancel_left_1:\n  assumes \"landau_symbol L L' Lr\" \"eventually_nonzero F f\"\n  shows   \"f \\<in> L F (\\<lambda>x. f x * g2 x) \\<longleftrightarrow> (\\<lambda>_. 1) \\<in> L F (g2)\"\n          \"(\\<lambda>x. f x * f2 x) \\<in> L F (f) \\<longleftrightarrow> f2 \\<in> L F (\\<lambda>_. 1)\"\n          \"f \\<in> L F (f) \\<longleftrightarrow> (\\<lambda>_. 1) \\<in> L F (\\<lambda>_. 1)\"", "lemmas landau_mult_cancel_simps = mult_cancel_left' mult_cancel_left_1", "lemmas bigtheta_simps = \n  landau_theta.cong_bigtheta[OF bigtheta_const_ln]\n  landau_theta.cong_bigtheta[OF bigtheta_const_ln_powr]", "lemma asymp_equiv_plus_const_left: \"(\\<lambda>n. c + real n) \\<sim>[at_top] (\\<lambda>n. real n)\"", "lemma asymp_equiv_plus_const_right: \"(\\<lambda>n. real n + c) \\<sim>[at_top] (\\<lambda>n. real n)\"", "lemma \"(\\<lambda>x::real. f x * x) \\<in> O(\\<lambda>x. g x / (h x / x)) \\<longleftrightarrow> f \\<in> O(\\<lambda>x. g x / h x)\"", "lemma \"(\\<lambda>x::real. x) \\<in> \\<omega>(\\<lambda>x. g x / (h x / x)) \\<longleftrightarrow> (\\<lambda>x. 1) \\<in> \\<omega>(\\<lambda>x. g x / h x)\"", "lemma \"(\\<lambda>x. x powr 1) \\<in> O(\\<lambda>x. x powr 2 :: real)\"", "lemma \"\\<Theta>(\\<lambda>x::real. 2*x powr 3 - 4*x powr 2) = \\<Theta>(\\<lambda>x::real. x powr 3)\"", "lemma \"p < q \\<Longrightarrow> (\\<lambda>x::real. c * x powr p * ln x powr r) \\<in> o(\\<lambda>x::real. x powr q)\"", "lemma \"c \\<noteq> 0 \\<Longrightarrow> p > q \\<Longrightarrow> (\\<lambda>x::real. c * x powr p * ln x powr r) \\<in> \\<omega>(\\<lambda>x::real. x powr q)\"", "lemma \"b > 0 \\<Longrightarrow> (\\<lambda>x::real. x / ln (2*b*x) * 2) \\<in> o(\\<lambda>x. x * ln (b*x))\"", "lemma \"o(\\<lambda>x::real. x * ln (3*x)) = o(\\<lambda>x. ln x * x)\"", "lemma \"(\\<lambda>x::real. x) \\<in> o(\\<lambda>x. x * ln (3*x))\"", "lemma \"(\\<lambda>x. 3 * ln x * ln x / x * ln (ln (ln (ln x)))) \\<in> \n         \\<omega>(\\<lambda>x::real. 5 * ln (ln x) ^ 2 / (2*x) powr 1.5 * inverse 2)\"", "lemma \"\\<Theta>(\\<lambda>x::real. 2 * x powr 3 + x * x^2/ln x) = \\<Theta>(\\<lambda>x::real. x powr 3)\"", "lemma \"\\<Theta>(\\<lambda>x::real. 2 * x powr 3 + x * x^2/ln x + 42 * x powr 9 + 213 * x powr 5 - 4 * x powr 7) = \n         \\<Theta>(\\<lambda>x::real. x ^ 3 + x / ln x * x powr (3/2) - 2*x powr 9)\"", "lemma \"(\\<lambda>x::real. x + x * ln (3*x)) \\<in> o(\\<lambda>x::real. x^2 + ln (2*x) powr 3)\""], "translations": [["", "lemma bigtheta_const [landau_simp]:\n  \"NO_MATCH 1 c \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> (\\<lambda>x. c) \\<in> \\<Theta>(\\<lambda>x. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NO_MATCH (1::'a) c; c \\<noteq> (0::'b)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. c) \\<in> \\<Theta>(\\<lambda>x. 1::'b)", "by simp"], ["", "lemmas [landau_simp] = bigtheta_const_ln bigtheta_const_ln_powr bigtheta_const_ln_pow"], ["", "lemma bigtheta_const_ln' [landau_simp]: \n  \"0 < a \\<Longrightarrow> (\\<lambda>x::real. ln (x * a)) \\<in> \\<Theta>(ln)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> (\\<lambda>x. ln (x * a)) \\<in> \\<Theta>(ln)", "by (subst mult.commute) (rule bigtheta_const_ln)"], ["", "lemma bigtheta_const_ln_powr' [landau_simp]: \n  \"0 < a \\<Longrightarrow> (\\<lambda>x::real. ln (x * a) powr p) \\<in> \\<Theta>(\\<lambda>x. ln x powr p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (x * a) powr p) \\<in> \\<Theta>(\\<lambda>x. ln x powr p)", "by (subst mult.commute) (rule bigtheta_const_ln_powr)"], ["", "lemma bigtheta_const_ln_pow' [landau_simp]: \n  \"0 < a \\<Longrightarrow> (\\<lambda>x::real. ln (x * a) ^ p) \\<in> \\<Theta>(\\<lambda>x. ln x ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (x * a) ^ p) \\<in> \\<Theta>(\\<lambda>x. ln x ^ p)", "by (subst mult.commute) (rule bigtheta_const_ln_pow)"], ["", "subsection \\<open>Simproc setup\\<close>"], ["", "lemma landau_gt_1_cong: \n  \"landau_symbol L L' Lr \\<Longrightarrow> (\\<And>x::real. x > 1 \\<Longrightarrow> f x = g x) \\<Longrightarrow> L at_top (f) = L at_top (g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>landau_symbol L L' Lr;\n     \\<And>x. 1 < x \\<Longrightarrow> f x = g x\\<rbrakk>\n    \\<Longrightarrow> L at_top f = L at_top g", "by (auto intro: eventually_mono [OF eventually_gt_at_top[of 1]] elim!: landau_symbol.cong)"], ["", "lemma landau_gt_1_in_cong: \n  \"landau_symbol L L' Lr \\<Longrightarrow> (\\<And>x::real. x > 1 \\<Longrightarrow> f x = g x) \\<Longrightarrow> f \\<in> L at_top (h) \\<longleftrightarrow> g \\<in> L at_top (h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>landau_symbol L L' Lr;\n     \\<And>x. 1 < x \\<Longrightarrow> f x = g x\\<rbrakk>\n    \\<Longrightarrow> (f \\<in> L at_top h) = (g \\<in> L at_top h)", "by (auto intro: eventually_mono [OF eventually_gt_at_top[of 1]] elim!: landau_symbol.in_cong)"], ["", "lemma landau_prop_equalsI:\n  \"landau_symbol L L' Lr \\<Longrightarrow> (\\<And>x::real. x > 1 \\<Longrightarrow> f1 x = f2 x) \\<Longrightarrow> (\\<And>x. x > 1 \\<Longrightarrow> g1 x = g2 x) \\<Longrightarrow> \n     f1 \\<in> L at_top (g1) \\<longleftrightarrow> f2 \\<in> L at_top (g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>landau_symbol L L' Lr;\n     \\<And>x. 1 < x \\<Longrightarrow> f1 x = f2 x;\n     \\<And>x. 1 < x \\<Longrightarrow> g1 x = g2 x\\<rbrakk>\n    \\<Longrightarrow> (f1 \\<in> L at_top g1) = (f2 \\<in> L at_top g2)", "apply (subst landau_gt_1_cong, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>landau_symbol L L' Lr;\n     \\<And>x. 1 < x \\<Longrightarrow> f1 x = f2 x;\n     \\<And>x. 1 < x \\<Longrightarrow> g1 x = g2 x\\<rbrakk>\n    \\<Longrightarrow> (f1 \\<in> L at_top g2) = (f2 \\<in> L at_top g2)", "apply (subst landau_gt_1_in_cong, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>landau_symbol L L' Lr;\n     \\<And>x. 1 < x \\<Longrightarrow> f1 x = f2 x;\n     \\<And>x. 1 < x \\<Longrightarrow> g1 x = g2 x\\<rbrakk>\n    \\<Longrightarrow> (f2 \\<in> L at_top g2) = (f2 \\<in> L at_top g2)", "apply (rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ab_diff_conv_add_uminus': \"(a::_::ab_group_add) - b = -b + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - b = - b + a", "by simp"], ["", "lemma extract_diff_middle: \"(a::_::ab_group_add) - (x + b) = -x + (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - (x + b) = - x + (a - b)", "by simp"], ["", "lemma divide_inverse': \"(a::_::{division_ring,ab_semigroup_mult}) / b = inverse b * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a / b = inverse b * a", "by (simp add: divide_inverse mult.commute)"], ["", "lemma extract_divide_middle:\"(a::_::{field}) / (x * b) = inverse x * (a / b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a / (x * b) = inverse x * (a / b)", "by (simp add: divide_inverse algebra_simps)"], ["", "lemmas landau_cancel = landau_symbol.mult_cancel_left"], ["", "lemmas mult_cancel_left' = landau_symbol.mult_cancel_left[OF _ bigtheta_refl eventually_nonzeroD]"], ["", "lemma mult_cancel_left_1:\n  assumes \"landau_symbol L L' Lr\" \"eventually_nonzero F f\"\n  shows   \"f \\<in> L F (\\<lambda>x. f x * g2 x) \\<longleftrightarrow> (\\<lambda>_. 1) \\<in> L F (g2)\"\n          \"(\\<lambda>x. f x * f2 x) \\<in> L F (f) \\<longleftrightarrow> f2 \\<in> L F (\\<lambda>_. 1)\"\n          \"f \\<in> L F (f) \\<longleftrightarrow> (\\<lambda>_. 1) \\<in> L F (\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<in> L F (\\<lambda>x. f x * g2 x)) =\n    ((\\<lambda>_. 1::'b) \\<in> L F g2) &&&\n    ((\\<lambda>x. f x * f2 x) \\<in> L F f) =\n    (f2 \\<in> L F (\\<lambda>_. 1::'b)) &&&\n    (f \\<in> L F f) = ((\\<lambda>_. 1::'b) \\<in> L F (\\<lambda>_. 1::'b))", "using mult_cancel_left'[OF assms, of \"\\<lambda>_. 1\"] mult_cancel_left'[OF assms, of _ \"\\<lambda>_. 1\"]\n        mult_cancel_left'[OF assms, of \"\\<lambda>_. 1\" \"\\<lambda>_. 1\"]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f x * (1::'b)) \\<in> L F (\\<lambda>x. f x * ?g2.0 x)) =\n  ((\\<lambda>_. 1::'b) \\<in> L F ?g2.0)\n  ((\\<lambda>x. f x * ?f2.0 x) \\<in> L F (\\<lambda>x. f x * (1::'b))) =\n  (?f2.0 \\<in> L F (\\<lambda>_. 1::'b))\n  ((\\<lambda>x. f x * (1::'b)) \\<in> L F (\\<lambda>x. f x * (1::'b))) =\n  ((\\<lambda>_. 1::'b) \\<in> L F (\\<lambda>_. 1::'b))\n\ngoal (1 subgoal):\n 1. (f \\<in> L F (\\<lambda>x. f x * g2 x)) =\n    ((\\<lambda>_. 1::'b) \\<in> L F g2) &&&\n    ((\\<lambda>x. f x * f2 x) \\<in> L F f) =\n    (f2 \\<in> L F (\\<lambda>_. 1::'b)) &&&\n    (f \\<in> L F f) = ((\\<lambda>_. 1::'b) \\<in> L F (\\<lambda>_. 1::'b))", "by simp_all"], ["", "lemmas landau_mult_cancel_simps = mult_cancel_left' mult_cancel_left_1"], ["", "ML_file \\<open>landau_simprocs.ML\\<close>"], ["", "lemmas bigtheta_simps = \n  landau_theta.cong_bigtheta[OF bigtheta_const_ln]\n  landau_theta.cong_bigtheta[OF bigtheta_const_ln_powr]"], ["", "text \\<open>\n  The following simproc attempts to cancel common factors in Landau symbols, i.\\,e.\\ in a\n  goal like $f(x) h(x) \\in L(g(x) h(x))$, the common factor $h(x)$ will be cancelled. This only\n  works if the simproc can prove that $h(x)$ is eventually non-zero, for which it uses some\n  heuristics.\n\\<close>"], ["", "simproc_setup landau_cancel_factor (\n    \"f \\<in> o[F](g)\" | \"f \\<in> O[F](g)\" | \"f \\<in> \\<omega>[F](g)\" | \"f \\<in> \\<Omega>[F](g)\" | \"f \\<in> \\<Theta>[F](g)\"\n  ) = \\<open>K Landau.cancel_factor_simproc\\<close>"], ["", "text \\<open>\n  The next simproc attempts to cancel dominated summands from Landau symbols; e.\\,g.\\ $O(x + \\ln x)$\n  is simplified to $O(x)$, since $\\ln x \\in o(x)$. This can be very slow on large terms, so it\n  is not enabled by default.\n\\<close>"], ["", "simproc_setup simplify_landau_sum (\n    \"o[F](\\<lambda>x. f x)\" | \"O[F](\\<lambda>x. f x)\" | \"\\<omega>[F](\\<lambda>x. f x)\" | \"\\<Omega>[F](\\<lambda>x. f x)\" | \"\\<Theta>[F](\\<lambda>x. f x)\" |\n    \"f \\<in> o[F](g)\" | \"f \\<in> O[F](g)\" | \"f \\<in> \\<omega>[F](g)\" | \"f \\<in> \\<Omega>[F](g)\" | \"f \\<in> \\<Theta>[F](g)\"\n  ) = \\<open>K (Landau.lift_landau_simproc Landau.simplify_landau_sum_simproc)\\<close>"], ["", "text \\<open>\n  This simproc attempts to simplify factors of an expression in a Landau symbol statement\n  independently from another, i.\\,e.\\ in something like $O(f(x) g(x)$, a simp rule that rewrites\n  $O(f(x))$ to $O(f'(x))$ will also rewrite $O(f(x) g(x))$ to $O(f'(x) g(x))$ without any further\n  setup.\n\\<close>"], ["", "simproc_setup simplify_landau_product (\n    \"o[F](\\<lambda>x. f x)\" | \"O[F](\\<lambda>x. f x)\" | \"\\<omega>[F](\\<lambda>x. f x)\" | \"\\<Omega>[F](\\<lambda>x. f x)\" | \"\\<Theta>[F](\\<lambda>x. f x)\" |\n    \"f \\<in> o[F](g)\" | \"f \\<in> O[F](g)\" | \"f \\<in> \\<omega>[F](g)\" | \"f \\<in> \\<Omega>[F](g)\" | \"f \\<in> \\<Theta>[F](g)\"\n  ) = \\<open>K (Landau.lift_landau_simproc Landau.simplify_landau_product_simproc)\\<close>"], ["", "text \\<open>\n  Lastly, the next very specialised simproc can solve goals of the form \n  $f(x) \\in L(g(x))$ where $f$ and $g$ are real-valued functions consisting only of multiplications,\n  powers of $x$, and powers of iterated logarithms of $x$. This is done by rewriting both sides\n  into the form $x^a (\\ln x)^b (\\ln \\ln x)^c$ etc.\\ and then comparing the exponents\n  lexicographically.\n\n  Note that for historic reasons, this only works for $x\\to\\infty$.\n\\<close>"], ["", "simproc_setup landau_real_prod (\n    \"(f :: real \\<Rightarrow> real) \\<in> o(g)\" | \"(f :: real \\<Rightarrow> real) \\<in> O(g)\" |\n    \"(f :: real \\<Rightarrow> real) \\<in> \\<omega>(g)\" | \"(f :: real \\<Rightarrow> real) \\<in> \\<Omega>(g)\" |\n    \"(f :: real \\<Rightarrow> real) \\<in> \\<Theta>(g)\"\n  ) = \\<open>K Landau.simplify_landau_real_prod_prop_simproc\\<close>"], ["", "subsection \\<open>Tests\\<close>"], ["", "lemma asymp_equiv_plus_const_left: \"(\\<lambda>n. c + real n) \\<sim>[at_top] (\\<lambda>n. real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. c + real n) \\<sim>[sequentially] real", "by (subst asymp_equiv_add_left) (auto intro!: asymp_equiv_intros eventually_gt_at_top)"], ["", "lemma asymp_equiv_plus_const_right: \"(\\<lambda>n. real n + c) \\<sim>[at_top] (\\<lambda>n. real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. real n + c) \\<sim>[sequentially] real", "using asymp_equiv_plus_const_left[of c]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. c + real n) \\<sim>[sequentially] real\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real n + c) \\<sim>[sequentially] real", "by (simp add: add.commute)"], ["", "subsubsection \\<open>Product simplification tests\\<close>"], ["", "lemma \"(\\<lambda>x::real. f x * x) \\<in> O(\\<lambda>x. g x / (h x / x)) \\<longleftrightarrow> f \\<in> O(\\<lambda>x. g x / h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * x) \\<in> O(\\<lambda>x. g x / (h x / x))) =\n    (f \\<in> O(\\<lambda>x. g x / h x))", "by simp"], ["", "lemma \"(\\<lambda>x::real. x) \\<in> \\<omega>(\\<lambda>x. g x / (h x / x)) \\<longleftrightarrow> (\\<lambda>x. 1) \\<in> \\<omega>(\\<lambda>x. g x / h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x) \\<in> \\<omega>(\\<lambda>x. g x / (h x / x))) =\n    ((\\<lambda>x. 1) \\<in> \\<omega>(\\<lambda>x. g x / h x))", "by simp"], ["", "subsubsection \\<open>Real product decision procure tests\\<close>"], ["", "lemma \"(\\<lambda>x. x powr 1) \\<in> O(\\<lambda>x. x powr 2 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x powr 1) \\<in> O(\\<lambda>x. x powr 2)", "by simp"], ["", "lemma \"\\<Theta>(\\<lambda>x::real. 2*x powr 3 - 4*x powr 2) = \\<Theta>(\\<lambda>x::real. x powr 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. 2 * x powr 3 - 4 * x powr 2) =\n    \\<Theta>(\\<lambda>x. x powr 3)", "by (simp add: landau_theta.absorb)"], ["", "lemma \"p < q \\<Longrightarrow> (\\<lambda>x::real. c * x powr p * ln x powr r) \\<in> o(\\<lambda>x::real. x powr q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p < q \\<Longrightarrow>\n    (\\<lambda>x. c * x powr p * ln x powr r) \\<in> o(\\<lambda>x. x powr q)", "by simp"], ["", "lemma \"c \\<noteq> 0 \\<Longrightarrow> p > q \\<Longrightarrow> (\\<lambda>x::real. c * x powr p * ln x powr r) \\<in> \\<omega>(\\<lambda>x::real. x powr q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> 0; q < p\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. c * x powr p * ln x powr r)\n                      \\<in> \\<omega>(\\<lambda>x. x powr q)", "by simp"], ["", "lemma \"b > 0 \\<Longrightarrow> (\\<lambda>x::real. x / ln (2*b*x) * 2) \\<in> o(\\<lambda>x. x * ln (b*x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    (\\<lambda>x. x / ln (2 * b * x) * 2) \\<in> o(\\<lambda>x. x * ln (b * x))", "by simp"], ["", "lemma \"o(\\<lambda>x::real. x * ln (3*x)) = o(\\<lambda>x. ln x * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. o(\\<lambda>x. x * ln (3 * x)) = o(\\<lambda>x. ln x * x)", "by (simp add: mult.commute)"], ["", "lemma \"(\\<lambda>x::real. x) \\<in> o(\\<lambda>x. x * ln (3*x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x) \\<in> o(\\<lambda>x. x * ln (3 * x))", "by simp"], ["", "ML_val \\<open>\n  Landau.simplify_landau_real_prod_prop_conv @{context} \n  @{cterm \"(\\<lambda>x::real. 5 * ln (ln x) ^ 2 / (2*x) powr 1.5 * inverse 2) \\<in> \n           \\<omega>(\\<lambda>x. 3 * ln x * ln x / x * ln (ln (ln (ln x))))\"}\n\\<close>"], ["", "lemma \"(\\<lambda>x. 3 * ln x * ln x / x * ln (ln (ln (ln x)))) \\<in> \n         \\<omega>(\\<lambda>x::real. 5 * ln (ln x) ^ 2 / (2*x) powr 1.5 * inverse 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 3 * ln x * ln x / x * ln (ln (ln (ln x))))\n    \\<in> \\<omega>(\\<lambda>x.\n                      5 * (ln (ln x))\\<^sup>2 / (2 * x) powr (15 / 10) *\n                      inverse 2)", "by simp"], ["", "subsubsection \\<open>Sum cancelling tests\\<close>"], ["", "lemma \"\\<Theta>(\\<lambda>x::real. 2 * x powr 3 + x * x^2/ln x) = \\<Theta>(\\<lambda>x::real. x powr 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. 2 * x powr 3 + x * x\\<^sup>2 / ln x) =\n    \\<Theta>(\\<lambda>x. x powr 3)", "by simp"], ["", "(* TODO: tweak simproc with size threshold *)"], ["", "lemma \"\\<Theta>(\\<lambda>x::real. 2 * x powr 3 + x * x^2/ln x + 42 * x powr 9 + 213 * x powr 5 - 4 * x powr 7) = \n         \\<Theta>(\\<lambda>x::real. x ^ 3 + x / ln x * x powr (3/2) - 2*x powr 9)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x.\n                2 * x powr 3 + x * x\\<^sup>2 / ln x + 42 * x powr 9 +\n                213 * x powr 5 -\n                4 * x powr 7) =\n    \\<Theta>(\\<lambda>x. x ^ 3 + x / ln x * x powr (3 / 2) - 2 * x powr 9)", "using [[landau_sum_limit = 5]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x.\n                2 * x powr 3 + x * x\\<^sup>2 / ln x + 42 * x powr 9 +\n                213 * x powr 5 -\n                4 * x powr 7) =\n    \\<Theta>(\\<lambda>x. x ^ 3 + x / ln x * x powr (3 / 2) - 2 * x powr 9)", "by simp"], ["", "lemma \"(\\<lambda>x::real. x + x * ln (3*x)) \\<in> o(\\<lambda>x::real. x^2 + ln (2*x) powr 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x + x * ln (3 * x))\n    \\<in> o(\\<lambda>x. x\\<^sup>2 + ln (2 * x) powr 3)", "by simp"], ["", "end"]]}