{"file_name": "/home/qj213/afp-2021-10-22/thys/Landau_Symbols/Landau_Real_Products.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Landau_Symbols", "problem_names": ["lemmas [eventually_nonzero_simps] = \n  eventually_nonzero_def [symmetric] eventually_nonneg_def [symmetric]", "lemma eventually_nonzeroD: \"eventually_nonzero F f \\<Longrightarrow> eventually (\\<lambda>x. f x \\<noteq> 0) F\"", "lemma eventually_nonzero_const [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>_::_::linorder. c) \\<longleftrightarrow> F = bot \\<or> c \\<noteq> 0\"", "lemma eventually_nonzero_inverse [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>x. inverse (f x)) \\<longleftrightarrow> eventually_nonzero F f\"", "lemma eventually_nonzero_mult [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>x. f x * g x) \\<longleftrightarrow> eventually_nonzero F f \\<and> eventually_nonzero F g\"", "lemma eventually_nonzero_pow [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>x::_::linorder. f x ^ n) \\<longleftrightarrow> n = 0 \\<or> eventually_nonzero F f\"", "lemma eventually_nonzero_divide [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>x. f x / g x) \\<longleftrightarrow> eventually_nonzero F f \\<and> eventually_nonzero F g\"", "lemma eventually_nonzero_ident_at_top_linorder [eventually_nonzero_simps]:\n  \"eventually_nonzero at_top (\\<lambda>x::'a::{real_normed_field,linordered_field}. x)\"", "lemma eventually_nonzero_ident_nhds [eventually_nonzero_simps]:\n  \"eventually_nonzero (nhds a) (\\<lambda>x. x) \\<longleftrightarrow> a \\<noteq> 0\"", "lemma eventually_nonzero_ident_at_within [eventually_nonzero_simps]:\n  \"eventually_nonzero (at a within A) (\\<lambda>x. x)\"", "lemma eventually_nonzero_ln_at_top [eventually_nonzero_simps]:\n  \"eventually_nonzero at_top (\\<lambda>x::real. ln x)\"", "lemma eventually_nonzero_ln_const_at_top [eventually_nonzero_simps]:\n  \"b > 0 \\<Longrightarrow> eventually_nonzero at_top (\\<lambda>x. ln (b * x :: real))\"", "lemma eventually_nonzero_ln_const'_at_top [eventually_nonzero_simps]:\n  \"b > 0 \\<Longrightarrow> eventually_nonzero at_top (\\<lambda>x. ln (x * b :: real))\"", "lemma eventually_nonzero_powr_at_top [eventually_nonzero_simps]:\n  \"eventually_nonzero at_top (\\<lambda>x::real. f x powr p) \\<longleftrightarrow> eventually_nonzero at_top f\"", "lemma eventually_nonneg_const [eventually_nonzero_simps]:\n  \"eventually_nonneg F (\\<lambda>_. c) \\<longleftrightarrow> F = bot \\<or> c \\<ge> 0\"", "lemma eventually_nonneg_inverse [eventually_nonzero_simps]:\n  \"eventually_nonneg F (\\<lambda>x. inverse (f x)) \\<longleftrightarrow> eventually_nonneg F f\"", "lemma eventually_nonneg_add [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"eventually_nonneg F g\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x + g x)\"", "lemma eventually_nonneg_mult [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"eventually_nonneg F g\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x * g x)\"", "lemma eventually_nonneg_mult' [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F (\\<lambda>x. -f x)\" \"eventually_nonneg F (\\<lambda>x. - g x)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x * g x)\"", "lemma eventually_nonneg_divide [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"eventually_nonneg F g\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x / g x)\"", "lemma eventually_nonneg_divide' [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F (\\<lambda>x. -f x)\" \"eventually_nonneg F (\\<lambda>x. - g x)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x / g x)\"", "lemma eventually_nonneg_ident_at_top [eventually_nonzero_simps]:\n  \"eventually_nonneg at_top (\\<lambda>x. x)\"", "lemma eventually_nonneg_ident_nhds [eventually_nonzero_simps]:\n  fixes a :: \"'a :: {linorder_topology, linordered_field}\"\n  shows \"a > 0 \\<Longrightarrow> eventually_nonneg (nhds a) (\\<lambda>x. x)\"", "lemma eventually_nonneg_ident_at_within [eventually_nonzero_simps]:\n  fixes a :: \"'a :: {linorder_topology, linordered_field}\"\n  shows \"a > 0 \\<Longrightarrow> eventually_nonneg (at a within A) (\\<lambda>x. x)\"", "lemma eventually_nonneg_pow [eventually_nonzero_simps]:\n  \"eventually_nonneg F f \\<Longrightarrow> eventually_nonneg F (\\<lambda>x. f x ^ n)\"", "lemma eventually_nonneg_powr [eventually_nonzero_simps]:\n  \"eventually_nonneg F (\\<lambda>x. f x powr y :: real)\"", "lemma eventually_nonneg_ln_at_top [eventually_nonzero_simps]:\n  \"eventually_nonneg at_top (\\<lambda>x. ln x :: real)\"", "lemma eventually_nonneg_ln_const [eventually_nonzero_simps]:\n  \"b > 0 \\<Longrightarrow> eventually_nonneg at_top (\\<lambda>x. ln (b*x) :: real)\"", "lemma eventually_nonneg_ln_const' [eventually_nonzero_simps]:\n  \"b > 0 \\<Longrightarrow> eventually_nonneg at_top (\\<lambda>x. ln (x*b) :: real)\"", "lemma eventually_nonzero_bigtheta':\n  \"f \\<in> \\<Theta>[F](g) \\<Longrightarrow> eventually_nonzero F f \\<longleftrightarrow> eventually_nonzero F g\"", "lemma eventually_nonneg_at_top: \n  assumes \"filterlim f at_top F\"\n  shows   \"eventually_nonneg F f\"", "lemma eventually_nonzero_at_top: \n  assumes \"filterlim (f :: 'a \\<Rightarrow> 'b :: {linordered_field, real_normed_field}) at_top F\"\n  shows   \"eventually_nonzero F f\"", "lemma eventually_nonneg_at_top_ASSUMPTION [eventually_nonzero_simps]:\n  \"ASSUMPTION (filterlim f at_top F) \\<Longrightarrow> eventually_nonneg F f\"", "lemma eventually_nonzero_at_top_ASSUMPTION [eventually_nonzero_simps]:\n  \"ASSUMPTION (filterlim f (at_top :: 'a :: {linordered_field, real_normed_field} filter) F) \\<Longrightarrow> \n     eventually_nonzero F f\"", "lemma filterlim_at_top_iff_smallomega:\n  fixes f :: \"_ \\<Rightarrow> real\"\n  shows \"filterlim f at_top F \\<longleftrightarrow> f \\<in> \\<omega>[F](\\<lambda>_. 1) \\<and> eventually_nonneg F f\"", "lemma smallomega_1_iff: \n  \"eventually_nonneg F f \\<Longrightarrow> f \\<in> \\<omega>[F](\\<lambda>_. 1 :: real) \\<longleftrightarrow> filterlim f at_top F\"", "lemma smallo_1_iff: \n  \"eventually_nonneg F f \\<Longrightarrow> (\\<lambda>_. 1 :: real) \\<in> o[F](f) \\<longleftrightarrow> filterlim f at_top F\"", "lemma eventually_nonneg_add1 [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"g \\<in> o[F](f)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x + g x :: real)\"", "lemma eventually_nonneg_add2 [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F g\" \"f \\<in> o[F](g)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x + g x :: real)\"", "lemma eventually_nonneg_diff1 [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"g \\<in> o[F](f)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x - g x :: real)\"", "lemma eventually_nonneg_diff2 [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F (\\<lambda>x. - g x)\" \"f \\<in> o[F](g)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x - g x :: real)\"", "lemma bigtheta_mult_eq: \"\\<Theta>[F](\\<lambda>x. f x * g x) = \\<Theta>[F](f) * \\<Theta>[F](g)\"", "lemma bigtheta_mult_eq_set_mult:\n  shows \"\\<Theta>[F](\\<lambda>x. f x * g x) = set_mult (\\<Theta>[F](f)) (\\<Theta>[F](g))\"", "lemma bigtheta_inverse_eq_set_inverse:\n  shows \"\\<Theta>[F](\\<lambda>x. inverse (f x)) = set_inverse (\\<Theta>[F](f))\"", "lemma set_divide_inverse: \n  \"set_divide (A :: (_ \\<Rightarrow> (_ :: division_ring)) set) B = set_mult A (set_inverse B)\"", "lemma bigtheta_divide_eq_set_divide:\n  shows \"\\<Theta>[F](\\<lambda>x. f x / g x) = set_divide (\\<Theta>[F](f)) (\\<Theta>[F](g))\"", "lemma bigtheta_pow_eq_set_pow: \"\\<Theta>[F](\\<lambda>x. f x ^ n) = bigtheta_pow F (\\<Theta>[F](f)) n\"", "lemma bigtheta_powr_eq_set_powr: \n  assumes \"eventually_nonneg F f\"\n  shows   \"\\<Theta>[F](\\<lambda>x. f x powr (y::real)) = bigtheta_powr F (\\<Theta>[F](f)) y\"", "lemmas bigtheta_factors_eq = \n  bigtheta_mult_eq_set_mult bigtheta_inverse_eq_set_inverse bigtheta_divide_eq_set_divide \n  bigtheta_pow_eq_set_pow bigtheta_powr_eq_set_powr", "lemmas landau_bigtheta_congs = landau_symbols[THEN landau_symbol.cong_bigtheta]", "lemma (in landau_symbol) meta_cong_bigtheta: \"\\<Theta>[F](f) \\<equiv> \\<Theta>[F](g) \\<Longrightarrow> L F (f) \\<equiv> L F (g)\"", "lemmas landau_bigtheta_meta_congs = landau_symbols[THEN landau_symbol.meta_cong_bigtheta]", "lemma real_powr_at_top: \n  assumes \"(p::real) > 0\"\n  shows   \"filterlim (\\<lambda>x. x powr p) at_top at_top\"", "lemma tendsto_ln_over_powr: \n  assumes \"(a::real) > 0\"\n  shows   \"((\\<lambda>x. ln x / x powr a) \\<longlongrightarrow> 0) at_top\"", "lemma tendsto_ln_powr_over_powr: \n  assumes \"(a::real) > 0\" \"b > 0\"\n  shows   \"((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top\"", "lemma tendsto_ln_powr_over_powr': \n  assumes \"b > 0\"\n  shows   \"((\\<lambda>x::real. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top\"", "lemma tendsto_ln_over_ln:\n  assumes \"(a::real) > 0\" \"c > 0\"\n  shows   \"((\\<lambda>x. ln (a*x) / ln (c*x)) \\<longlongrightarrow> 1) at_top\"", "lemma tendsto_ln_powr_over_ln_powr:\n  assumes \"(a::real) > 0\" \"c > 0\"\n  shows   \"((\\<lambda>x. ln (a*x) powr d / ln (c*x) powr d) \\<longlongrightarrow> 1) at_top\"", "lemma tendsto_ln_powr_over_ln_powr': \n  \"c > 0 \\<Longrightarrow> ((\\<lambda>x::real. ln x powr d / ln (c*x) powr d) \\<longlongrightarrow> 1) at_top\"", "lemma tendsto_ln_powr_over_ln_powr'': \n  \"a > 0 \\<Longrightarrow> ((\\<lambda>x::real. ln (a*x) powr d / ln x powr d) \\<longlongrightarrow> 1) at_top\"", "lemma bigtheta_const_ln_powr [simp]: \"a > 0 \\<Longrightarrow> (\\<lambda>x::real. ln (a*x) powr d) \\<in> \\<Theta>(\\<lambda>x. ln x powr d)\"", "lemma bigtheta_const_ln_pow [simp]: \"a > 0 \\<Longrightarrow> (\\<lambda>x::real. ln (a*x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)\"", "lemma bigtheta_const_ln [simp]: \"a > 0 \\<Longrightarrow> (\\<lambda>x::real. ln (a*x)) \\<in> \\<Theta>(\\<lambda>x. ln x)\"", "lemma powr_closureI [simp]: \"(\\<lambda>x. f x powr p) \\<in> powr_closure f\"", "lemma powr_closureE:\n  assumes \"g \\<in> powr_closure f\"\n  obtains p where \"g = (\\<lambda>x. f x powr p)\"", "lemma div: \"h1 \\<in> H \\<Longrightarrow> h2 \\<in> H \\<Longrightarrow> (\\<lambda>x. h1 x / h2 x) \\<in> H\"", "lemma nonzero: \"h \\<in> H \\<Longrightarrow> eventually (\\<lambda>x. h x \\<noteq> 0) F\"", "lemma landau_cases:\n  assumes \"h1 \\<in> H\" \"h2 \\<in> H\"\n  obtains \"h1 \\<in> o[F](h2)\" | \"h2 \\<in> o[F](h1)\" | \"h1 \\<in> \\<Theta>[F](h2)\"", "lemma small_big_antisym:\n  assumes \"h1 \\<in> H\" \"h2 \\<in> H\" \"h1 \\<in> o[F](h2)\" \"h2 \\<in> O[F](h1)\" shows False", "lemma small_antisym:\n  assumes \"h1 \\<in> H\" \"h2 \\<in> H\" \"h1 \\<in> o[F](h2)\" \"h2 \\<in> o[F](h1)\" shows False", "lemma smallo_iff:\n  assumes \"g1 \\<in> G\" \"g2 \\<in> G\" \"h1 \\<in> H\" \"h2 \\<in> H\"\n  shows \"(\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x) \\<longleftrightarrow>\n             g1 \\<in> o[F](g2) \\<or> (g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\" (is \"?P \\<longleftrightarrow> ?Q\")", "lemma bigo_iff:\n  assumes \"g1 \\<in> G\" \"g2 \\<in> G\" \"h1 \\<in> H\" \"h2 \\<in> H\"\n  shows \"(\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x) \\<longleftrightarrow>\n             g1 \\<in> o[F](g2) \\<or> (g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\" (is \"?P \\<longleftrightarrow> ?Q\")", "lemma bigtheta_iff:\n  \"g1 \\<in> G \\<Longrightarrow> g2 \\<in> G \\<Longrightarrow> h1 \\<in> H \\<Longrightarrow> h2 \\<in> H \\<Longrightarrow>\n    (\\<lambda>x. g1 x * h1 x) \\<in> \\<Theta>[F](\\<lambda>x. g2 x * h2 x) \\<longleftrightarrow> g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> \\<Theta>[F](h2)\"", "lemma landau_function_family_powr_closure:\n  assumes \"F \\<noteq> bot\" \"filterlim f at_top F\"\n  shows   \"landau_function_family F (powr_closure f)\"", "lemma landau_function_family_pair_trans:\n  assumes \"landau_function_family_pair Ftr F G f\"\n  assumes \"landau_function_family_pair Ftr G H g\"\n  shows   \"landau_function_family_pair Ftr F (G*H) f\"", "lemma landau_function_family_pair_trans_powr:\n  assumes \"landau_function_family_pair F (powr_closure g) H (\\<lambda>x. g x powr 1)\"\n  assumes \"filterlim f at_top F\"\n  assumes \"\\<And>p. (\\<lambda>x. g x powr p) \\<in> o[F](f)\"\n  shows   \"landau_function_family_pair F (powr_closure f) (powr_closure g * H) (\\<lambda>x. f x powr 1)\"", "lemma dominates_trans:\n  assumes \"eventually (\\<lambda>x. g x > 0) F\"\n  assumes \"dominates F f g\" \"dominates F g h\"\n  shows   \"dominates F f h\"", "lemma dominating_chain_imp_dominating_chain':\n  \"Ftr \\<noteq> bot \\<Longrightarrow> (\\<And>g. g \\<in> set gs \\<Longrightarrow> filterlim g at_top Ftr) \\<Longrightarrow>\n     landau_dominating_chain Ftr gs \\<Longrightarrow> landau_dominating_chain' Ftr gs\"", "lemma dominating_chain': \"landau_dominating_chain' F (map get_fun gs)\"", "lemma gs_powr_0_eq_one:\n  \"eventually (\\<lambda>x. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1) F\"", "lemma listmap_gs_in_listmap:\n  \"(\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g) \\<in> prod_list (map powr_closure (map h fs))\"", "lemma smallo_iff:\n  \"(\\<lambda>_. 1) \\<in> o[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g) \\<longleftrightarrow> pos_list (map get_param gs)\"", "lemma bigo_iff:\n  \"(\\<lambda>_. 1) \\<in> O[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g) \\<longleftrightarrow> nonneg_list (map get_param gs)\"", "lemma bigtheta_iff:\n  \"(\\<lambda>_. 1) \\<in> \\<Theta>[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g) \\<longleftrightarrow> list_all ((=) 0) (map get_param gs)\"", "lemma fun_chain_at_top_at_top:\n  assumes \"filterlim (f :: ('a::order) \\<Rightarrow> 'a) at_top at_top\"\n  shows   \"filterlim (f ^^ n) at_top at_top\"", "lemma const_smallo_ln_chain: \"(\\<lambda>_. 1) \\<in> o((ln::real\\<Rightarrow>real)^^n)\"", "lemma ln_fun_in_smallo_fun:\n  assumes \"filterlim f at_top at_top\"\n  shows   \"(\\<lambda>x. ln (f x) powr p :: real) \\<in> o(f)\"", "lemma ln_chain_dominates: \"m > n \\<Longrightarrow> dominates at_top ((ln::real \\<Rightarrow> real)^^n) (ln^^m)\"", "lemma eval_primfun_altdef: \"eval_primfun f x = eval_primfun' (fst f) x powr snd f\"", "lemma primfun_cases:\n  assumes \"(\\<And>n e. P (LnChain n, e))\"\n  shows   \"P x\"", "lemma eval_primfun'_at_top: \"filterlim (eval_primfun' f) at_top at_top\"", "lemma primfun_dominates:\n  \"f < g \\<Longrightarrow> dominates at_top (eval_primfun' f) (eval_primfun' g)\"", "lemma eval_primfun_pos: \"eventually (\\<lambda>x::real. eval_primfun f x > 0) at_top\"", "lemma eventually_nonneg_primfun: \"eventually_nonneg at_top (eval_primfun f)\"", "lemma eval_primfun_nonzero: \"eventually (\\<lambda>x. eval_primfun f x \\<noteq> 0) at_top\"", "lemma eval_merge_primfun:\n  \"fst f = fst g \\<Longrightarrow>\n     eval_primfun (merge_primfun f g) x = eval_primfun f x * eval_primfun g x\"", "lemma eval_inverse_primfun:\n  \"eval_primfun (inverse_primfun f) x = inverse (eval_primfun f x)\"", "lemma eval_powr_primfun:\n  \"eval_primfun (powr_primfun f e) x = eval_primfun f x powr e\"", "lemma eval_primfuns_pos: \"eventually (\\<lambda>x. eval_primfuns fs x > 0) at_top\"", "lemma eval_primfuns_nonzero: \"eventually (\\<lambda>x. eval_primfuns fs x \\<noteq> 0) at_top\"", "lemma BIGTHETA_CONST'_tag: \"\\<Theta>(\\<lambda>x. c) = BIGTHETA_CONST' c\"", "lemma BIGTHETA_CONST_tag: \"\\<Theta>(f) = BIGTHETA_CONST 1 \\<Theta>(f)\"", "lemma BIGTHETA_FUN_tag: \"\\<Theta>(f) = BIGTHETA_FUN f\"", "lemma set_mult_is_times: \"set_mult A B = A * B\"", "lemma set_powr_mult:\n  assumes \"eventually_nonneg F f\" and \"eventually_nonneg F g\"\n  shows   \"\\<Theta>[F](\\<lambda>x. (f x * g x :: real) powr p) = set_mult (\\<Theta>[F](\\<lambda>x. f x powr p)) (\\<Theta>[F](\\<lambda>x. g x powr p))\"", "lemma eventually_nonneg_bigtheta_pow_realpow:\n  \"\\<Theta>(\\<lambda>x. eval_primfun f x ^ e) = \\<Theta>(\\<lambda>x. eval_primfun f x powr real e)\"", "lemma BIGTHETA_CONST_fold:\n  \"BIGTHETA_CONST (c::real) (BIGTHETA_CONST d A) = BIGTHETA_CONST (c*d) A\"\n  \"bigtheta_pow at_top (BIGTHETA_CONST c \\<Theta>(eval_primfun pf)) k =\n     BIGTHETA_CONST (c ^ k) \\<Theta>(\\<lambda>x. eval_primfun pf x powr k)\"\n  \"set_inverse (BIGTHETA_CONST c \\<Theta>(f)) = BIGTHETA_CONST (inverse c) \\<Theta>(\\<lambda>x. inverse (f x))\"\n  \"set_mult (BIGTHETA_CONST c \\<Theta>(f)) (BIGTHETA_CONST d \\<Theta>(g)) =\n     BIGTHETA_CONST (c*d) \\<Theta>(\\<lambda>x. f x*g x)\"\n  \"BIGTHETA_CONST' (c::real) = BIGTHETA_CONST c \\<Theta>(\\<lambda>_. 1)\"\n  \"BIGTHETA_FUN (f::real\\<Rightarrow>real) = BIGTHETA_CONST 1 \\<Theta>(f)\"", "lemma fold_fun_chain:\n  \"g x = (g ^^ 1) x\" \"(g ^^ m) ((g ^^ n) x) = (g ^^ (m+n)) x\"", "lemma reify_ln_chain1:\n  \"\\<Theta>(\\<lambda>x. (ln ^^ n) x) = \\<Theta>(eval_primfun (LnChain n, 1))\"", "lemma reify_monom1:\n  \"\\<Theta>(\\<lambda>x::real. x) = \\<Theta>(eval_primfun (LnChain 0, 1))\"", "lemma reify_monom_pow:\n  \"\\<Theta>(\\<lambda>x::real. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))\"", "lemma reify_monom_powr:\n  \"\\<Theta>(\\<lambda>x::real. x powr e) = \\<Theta>(eval_primfun (LnChain 0, e))\"", "lemmas reify_monom = reify_monom1 reify_monom_pow reify_monom_powr", "lemma reify_ln_chain_pow:\n  \"\\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) = \\<Theta>(eval_primfun (LnChain n, real e))\"", "lemma reify_ln_chain_powr:\n  \"\\<Theta>(\\<lambda>x. (ln ^^ n) x powr e) = \\<Theta>(eval_primfun (LnChain n, e))\"", "lemmas reify_ln_chain = reify_ln_chain1 reify_ln_chain_pow reify_ln_chain_powr", "lemma numeral_power_Suc: \"numeral n ^ Suc a = numeral n * numeral n ^ a\"", "lemmas landau_product_preprocess =\n  one_add_one one_plus_numeral numeral_plus_one arith_simps numeral_power_Suc power_0\n  fold_fun_chain[where g = ln] reify_ln_chain reify_monom", "lemma LANDAU_PROD'_fold:\n  \"BIGTHETA_CONST e \\<Theta>(\\<lambda>_. d) = BIGTHETA_CONST (e*d) \\<Theta>(eval_primfuns [])\"\n  \"LANDAU_PROD' c (\\<lambda>_. 1) = LANDAU_PROD' c (eval_primfuns [])\"\n  \"eval_primfun f = eval_primfuns [f]\"\n  \"eval_primfuns fs x * eval_primfuns gs x = eval_primfuns (fs @ gs) x\"", "lemma inverse_prod_list_field:\n  \"prod_list (map (\\<lambda>x. inverse (f x)) xs) = inverse (prod_list (map f xs :: _ :: field list))\"", "lemma landau_prod_meta_cong:\n  assumes \"landau_symbol L L' Lr\"\n  assumes \"\\<Theta>(f) \\<equiv> BIGTHETA_CONST c1 (\\<Theta>(eval_primfuns fs))\"\n  assumes \"\\<Theta>(g) \\<equiv> BIGTHETA_CONST c2 (\\<Theta>(eval_primfuns gs))\"\n  shows   \"f \\<in> L at_top (g) \\<equiv> LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)\"", "lemma list_ConsCons_induct:\n  assumes \"P []\" \"\\<And>x. P [x]\" \"\\<And>x y xs. P (y#xs) \\<Longrightarrow> P (x#y#xs)\"\n  shows   \"P xs\"", "lemma landau_function_family_chain_primfuns:\n  assumes \"sorted (map fst fs)\"\n  assumes \"distinct (map fst fs)\"\n  shows   \"landau_function_family_chain at_top fs (eval_primfun' o fst)\"", "lemma (in monoid_mult) fold_plus_prod_list_rev:\n  \"fold times xs = times (prod_list (rev xs))\"", "lemma nonneg_primfun_list_iff: \"nonneg_primfun_list fs = nonneg_list (map snd fs)\"", "lemma pos_primfun_list_iff: \"pos_primfun_list fs = pos_list (map snd fs)\"", "lemma iszero_primfun_list_iff: \"iszero_primfun_list fs = list_all ((=) 0) (map snd fs)\"", "lemma landau_primfuns_iff:\n  \"((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) = nonneg_primfun_list (group_primfuns fs)\" (is \"?A\")\n  \"((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) = pos_primfun_list (group_primfuns fs)\" (is \"?B\")\n  \"((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) = iszero_primfun_list (group_primfuns fs)\" (is \"?C\")", "lemma LANDAU_PROD_bigo_iff:\n  \"LANDAU_PROD (bigo at_top) c1 c2 fs \\<longleftrightarrow> c1 = 0 \\<or> (c2 \\<noteq> 0 \\<and> nonneg_primfun_list (group_primfuns fs))\"", "lemma LANDAU_PROD_smallo_iff:\n  \"LANDAU_PROD (smallo at_top) c1 c2 fs \\<longleftrightarrow> c1 = 0 \\<or> (c2 \\<noteq> 0 \\<and> pos_primfun_list (group_primfuns fs))\"", "lemma LANDAU_PROD_bigtheta_iff:\n  \"LANDAU_PROD (bigtheta at_top) c1 c2 fs \\<longleftrightarrow> (c1 = 0 \\<and> c2 = 0) \\<or> (c1 \\<noteq> 0 \\<and> c2 \\<noteq> 0 \\<and>\n     iszero_primfun_list (group_primfuns fs))\"", "lemmas LANDAU_PROD_iff = LANDAU_PROD_bigo_iff LANDAU_PROD_smallo_iff LANDAU_PROD_bigtheta_iff", "lemmas landau_real_prod_simps [simp] =\n  groupsort_primfun.group_part_def\n  group_primfuns_def groupsort_primfun.group_sort.simps\n  groupsort_primfun.group_part_aux.simps pos_primfun_list.simps\n  nonneg_primfun_list.simps iszero_primfun_list.simps"], "translations": [["", "lemmas [eventually_nonzero_simps] = \n  eventually_nonzero_def [symmetric] eventually_nonneg_def [symmetric]"], ["", "lemma eventually_nonzeroD: \"eventually_nonzero F f \\<Longrightarrow> eventually (\\<lambda>x. f x \\<noteq> 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero F f \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in F. f x \\<noteq> (0::'b)", "by (simp add: eventually_nonzero_def)"], ["", "lemma eventually_nonzero_const [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>_::_::linorder. c) \\<longleftrightarrow> F = bot \\<or> c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero F (\\<lambda>_. c) =\n    (F = bot \\<or> c \\<noteq> (0::'b))", "unfolding eventually_nonzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in F. c \\<noteq> (0::'b)) =\n    (F = bot \\<or> c \\<noteq> (0::'b))", "by (auto simp add: eventually_False)"], ["", "lemma eventually_nonzero_inverse [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>x. inverse (f x)) \\<longleftrightarrow> eventually_nonzero F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero F (\\<lambda>x. inverse (f x)) =\n    eventually_nonzero F f", "unfolding eventually_nonzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in F. inverse (f x) \\<noteq> (0::'b)) =\n    (\\<forall>\\<^sub>F x in F. f x \\<noteq> (0::'b))", "by simp"], ["", "lemma eventually_nonzero_mult [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>x. f x * g x) \\<longleftrightarrow> eventually_nonzero F f \\<and> eventually_nonzero F g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero F (\\<lambda>x. f x * g x) =\n    (eventually_nonzero F f \\<and> eventually_nonzero F g)", "unfolding eventually_nonzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in F. f x * g x \\<noteq> (0::'b)) =\n    ((\\<forall>\\<^sub>F x in F. f x \\<noteq> (0::'b)) \\<and>\n     (\\<forall>\\<^sub>F x in F. g x \\<noteq> (0::'b)))", "by (simp_all add: eventually_conj_iff[symmetric])"], ["", "lemma eventually_nonzero_pow [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>x::_::linorder. f x ^ n) \\<longleftrightarrow> n = 0 \\<or> eventually_nonzero F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero F (\\<lambda>x. f x ^ n) =\n    (n = 0 \\<or> eventually_nonzero F f)", "by (induction n) (auto simp: eventually_nonzero_simps)"], ["", "lemma eventually_nonzero_divide [eventually_nonzero_simps]:\n  \"eventually_nonzero F (\\<lambda>x. f x / g x) \\<longleftrightarrow> eventually_nonzero F f \\<and> eventually_nonzero F g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero F (\\<lambda>x. f x / g x) =\n    (eventually_nonzero F f \\<and> eventually_nonzero F g)", "unfolding eventually_nonzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in F. f x / g x \\<noteq> (0::'b)) =\n    ((\\<forall>\\<^sub>F x in F. f x \\<noteq> (0::'b)) \\<and>\n     (\\<forall>\\<^sub>F x in F. g x \\<noteq> (0::'b)))", "by (simp_all add: eventually_conj_iff[symmetric])"], ["", "lemma eventually_nonzero_ident_at_top_linorder [eventually_nonzero_simps]:\n  \"eventually_nonzero at_top (\\<lambda>x::'a::{real_normed_field,linordered_field}. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero at_top (\\<lambda>x. x)", "unfolding eventually_nonzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x \\<noteq> (0::'a)", "by simp"], ["", "lemma eventually_nonzero_ident_nhds [eventually_nonzero_simps]:\n  \"eventually_nonzero (nhds a) (\\<lambda>x. x) \\<longleftrightarrow> a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero (nhds a) (\\<lambda>x. x) = (a \\<noteq> (0::'a))", "using eventually_nhds_in_open[of \"-{0}\" a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>open (- {0::'a}); a \\<in> - {0::'a}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F y in nhds a. y \\<in> - {0::'a}\n\ngoal (1 subgoal):\n 1. eventually_nonzero (nhds a) (\\<lambda>x. x) = (a \\<noteq> (0::'a))", "by (auto elim!: eventually_mono simp: eventually_nonzero_def open_Compl \n           dest: eventually_nhds_x_imp_x)"], ["", "lemma eventually_nonzero_ident_at_within [eventually_nonzero_simps]:\n  \"eventually_nonzero (at a within A) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero (at a within A) (\\<lambda>x. x)", "using eventually_nonzero_ident_nhds[of a]"], ["proof (prove)\nusing this:\n  eventually_nonzero (nhds a) (\\<lambda>x. x) = (a \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. eventually_nonzero (at a within A) (\\<lambda>x. x)", "by (cases \"a = 0\") (auto simp: eventually_nonzero_def eventually_at_filter elim!: eventually_mono)"], ["", "lemma eventually_nonzero_ln_at_top [eventually_nonzero_simps]:\n  \"eventually_nonzero at_top (\\<lambda>x::real. ln x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero at_top ln", "unfolding eventually_nonzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln x \\<noteq> 0", "by (auto intro!: eventually_mono[OF eventually_gt_at_top[of 1]])"], ["", "lemma eventually_nonzero_ln_const_at_top [eventually_nonzero_simps]:\n  \"b > 0 \\<Longrightarrow> eventually_nonzero at_top (\\<lambda>x. ln (b * x :: real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    eventually_nonzero at_top (\\<lambda>x. ln (b * x))", "unfolding eventually_nonzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. ln (b * x) \\<noteq> 0", "apply (rule eventually_mono [OF eventually_gt_at_top[of \"max 1 (inverse b)\"]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < b; max 1 (inverse b) < x\\<rbrakk>\n       \\<Longrightarrow> ln (b * x) \\<noteq> 0", "by (metis exp_ln exp_minus exp_minus_inverse less_numeral_extra(3) ln_gt_zero max_less_iff_conj mult.commute mult_strict_right_mono)"], ["", "lemma eventually_nonzero_ln_const'_at_top [eventually_nonzero_simps]:\n  \"b > 0 \\<Longrightarrow> eventually_nonzero at_top (\\<lambda>x. ln (x * b :: real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    eventually_nonzero at_top (\\<lambda>x. ln (x * b))", "using eventually_nonzero_ln_const_at_top[of b]"], ["proof (prove)\nusing this:\n  0 < b \\<Longrightarrow> eventually_nonzero at_top (\\<lambda>x. ln (b * x))\n\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    eventually_nonzero at_top (\\<lambda>x. ln (x * b))", "by (simp add: mult.commute)"], ["", "lemma eventually_nonzero_powr_at_top [eventually_nonzero_simps]:\n  \"eventually_nonzero at_top (\\<lambda>x::real. f x powr p) \\<longleftrightarrow> eventually_nonzero at_top f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero at_top (\\<lambda>x. f x powr p) =\n    eventually_nonzero at_top f", "unfolding eventually_nonzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at_top. f x powr p \\<noteq> (0::'a)) =\n    (\\<forall>\\<^sub>F x in at_top. f x \\<noteq> (0::'a))", "by simp"], ["", "lemma eventually_nonneg_const [eventually_nonzero_simps]:\n  \"eventually_nonneg F (\\<lambda>_. c) \\<longleftrightarrow> F = bot \\<or> c \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>_. c) = (F = bot \\<or> (0::'b) \\<le> c)", "unfolding eventually_nonneg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in F. (0::'b) \\<le> c) =\n    (F = bot \\<or> (0::'b) \\<le> c)", "by (auto simp: eventually_False)"], ["", "lemma eventually_nonneg_inverse [eventually_nonzero_simps]:\n  \"eventually_nonneg F (\\<lambda>x. inverse (f x)) \\<longleftrightarrow> eventually_nonneg F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. inverse (f x)) = eventually_nonneg F f", "unfolding eventually_nonneg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in F. (0::'b) \\<le> inverse (f x)) =\n    (\\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x)", "by (intro eventually_subst) (auto)"], ["", "lemma eventually_nonneg_add [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"eventually_nonneg F g\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x + g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x + g x)", "using assms"], ["proof (prove)\nusing this:\n  eventually_nonneg F f\n  eventually_nonneg F g\n\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x + g x)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x + g x", "by eventually_elim simp"], ["", "lemma eventually_nonneg_mult [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"eventually_nonneg F g\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x * g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x * g x)", "using assms"], ["proof (prove)\nusing this:\n  eventually_nonneg F f\n  eventually_nonneg F g\n\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x * g x)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x * g x", "by eventually_elim simp"], ["", "lemma eventually_nonneg_mult' [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F (\\<lambda>x. -f x)\" \"eventually_nonneg F (\\<lambda>x. - g x)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x * g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x * g x)", "using assms"], ["proof (prove)\nusing this:\n  eventually_nonneg F (\\<lambda>x. - f x)\n  eventually_nonneg F (\\<lambda>x. - g x)\n\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x * g x)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> - f x\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> - g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x * g x", "by eventually_elim (auto intro: mult_nonpos_nonpos)"], ["", "lemma eventually_nonneg_divide [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"eventually_nonneg F g\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x / g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x / g x)", "using assms"], ["proof (prove)\nusing this:\n  eventually_nonneg F f\n  eventually_nonneg F g\n\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x / g x)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x / g x", "by eventually_elim simp"], ["", "lemma eventually_nonneg_divide' [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F (\\<lambda>x. -f x)\" \"eventually_nonneg F (\\<lambda>x. - g x)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x / g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x / g x)", "using assms"], ["proof (prove)\nusing this:\n  eventually_nonneg F (\\<lambda>x. - f x)\n  eventually_nonneg F (\\<lambda>x. - g x)\n\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x / g x)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> - f x\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> - g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x / g x", "by eventually_elim (auto intro: divide_nonpos_nonpos)"], ["", "lemma eventually_nonneg_ident_at_top [eventually_nonzero_simps]:\n  \"eventually_nonneg at_top (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg at_top (\\<lambda>x. x)", "unfolding eventually_nonneg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually ((\\<le>) (0::'a)) at_top", "by (rule eventually_ge_at_top)"], ["", "lemma eventually_nonneg_ident_nhds [eventually_nonzero_simps]:\n  fixes a :: \"'a :: {linorder_topology, linordered_field}\"\n  shows \"a > 0 \\<Longrightarrow> eventually_nonneg (nhds a) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < a \\<Longrightarrow> eventually_nonneg (nhds a) (\\<lambda>x. x)", "unfolding eventually_nonneg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < a \\<Longrightarrow> eventually ((\\<le>) (0::'a)) (nhds a)", "using eventually_nhds_in_open[of \"{0<..}\" a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>open {0::'a<..}; a \\<in> {0::'a<..}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F y in nhds a. y \\<in> {0::'a<..}\n\ngoal (1 subgoal):\n 1. (0::'a) < a \\<Longrightarrow> eventually ((\\<le>) (0::'a)) (nhds a)", "by (auto simp: eventually_nonneg_def dest: eventually_nhds_x_imp_x elim!: eventually_mono)"], ["", "lemma eventually_nonneg_ident_at_within [eventually_nonzero_simps]:\n  fixes a :: \"'a :: {linorder_topology, linordered_field}\"\n  shows \"a > 0 \\<Longrightarrow> eventually_nonneg (at a within A) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < a \\<Longrightarrow>\n    eventually_nonneg (at a within A) (\\<lambda>x. x)", "using eventually_nonneg_ident_nhds[of a]"], ["proof (prove)\nusing this:\n  (0::'a) < a \\<Longrightarrow> eventually_nonneg (nhds a) (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. (0::'a) < a \\<Longrightarrow>\n    eventually_nonneg (at a within A) (\\<lambda>x. x)", "by (auto simp: eventually_nonneg_def eventually_at_filter elim: eventually_mono)"], ["", "lemma eventually_nonneg_pow [eventually_nonzero_simps]:\n  \"eventually_nonneg F f \\<Longrightarrow> eventually_nonneg F (\\<lambda>x. f x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F f \\<Longrightarrow>\n    eventually_nonneg F (\\<lambda>x. f x ^ n)", "by (induction n) (auto simp: eventually_nonzero_simps)"], ["", "lemma eventually_nonneg_powr [eventually_nonzero_simps]:\n  \"eventually_nonneg F (\\<lambda>x. f x powr y :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x powr y)", "by (simp add: eventually_nonneg_def)"], ["", "lemma eventually_nonneg_ln_at_top [eventually_nonzero_simps]:\n  \"eventually_nonneg at_top (\\<lambda>x. ln x :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg at_top ln", "by (auto intro!: eventually_mono[OF eventually_gt_at_top[of \"1::real\"]]\n           simp: eventually_nonneg_def)"], ["", "lemma eventually_nonneg_ln_const [eventually_nonzero_simps]:\n  \"b > 0 \\<Longrightarrow> eventually_nonneg at_top (\\<lambda>x. ln (b*x) :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    eventually_nonneg at_top (\\<lambda>x. ln (b * x))", "unfolding eventually_nonneg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. 0 \\<le> ln (b * x)", "using eventually_ge_at_top[of \"inverse b\"]"], ["proof (prove)\nusing this:\n  eventually ((\\<le>) (inverse b)) at_top\n\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. 0 \\<le> ln (b * x)", "by eventually_elim (simp_all add: field_simps)"], ["", "lemma eventually_nonneg_ln_const' [eventually_nonzero_simps]:\n  \"b > 0 \\<Longrightarrow> eventually_nonneg at_top (\\<lambda>x. ln (x*b) :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    eventually_nonneg at_top (\\<lambda>x. ln (x * b))", "using eventually_nonneg_ln_const[of b]"], ["proof (prove)\nusing this:\n  0 < b \\<Longrightarrow> eventually_nonneg at_top (\\<lambda>x. ln (b * x))\n\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow>\n    eventually_nonneg at_top (\\<lambda>x. ln (x * b))", "by (simp add: mult.commute)"], ["", "lemma eventually_nonzero_bigtheta':\n  \"f \\<in> \\<Theta>[F](g) \\<Longrightarrow> eventually_nonzero F f \\<longleftrightarrow> eventually_nonzero F g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>[F](g) \\<Longrightarrow>\n    eventually_nonzero F f = eventually_nonzero F g", "unfolding eventually_nonzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>[F](g) \\<Longrightarrow>\n    (\\<forall>\\<^sub>F x in F. f x \\<noteq> (0::'b)) =\n    (\\<forall>\\<^sub>F x in F. g x \\<noteq> (0::'b))", "by (rule eventually_nonzero_bigtheta)"], ["", "lemma eventually_nonneg_at_top: \n  assumes \"filterlim f at_top F\"\n  shows   \"eventually_nonneg F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eventually_nonneg F f", "from assms"], ["proof (chain)\npicking this:\n  filterlim f at_top F", "have \"eventually (\\<lambda>x. f x \\<ge> 0) F\""], ["proof (prove)\nusing this:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x", "by (simp add: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x\n\ngoal (1 subgoal):\n 1. eventually_nonneg F f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x\n\ngoal (1 subgoal):\n 1. eventually_nonneg F f", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. (0::'b) \\<le> f x", "by eventually_elim simp"], ["proof (state)\nthis:\n  eventually_nonneg F f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eventually_nonzero_at_top: \n  assumes \"filterlim (f :: 'a \\<Rightarrow> 'b :: {linordered_field, real_normed_field}) at_top F\"\n  shows   \"eventually_nonzero F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonzero F f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eventually_nonzero F f", "from assms"], ["proof (chain)\npicking this:\n  filterlim f at_top F", "have \"eventually (\\<lambda>x. f x \\<ge> 1) F\""], ["proof (prove)\nusing this:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. (1::'b) \\<le> f x", "by (simp add: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. (1::'b) \\<le> f x\n\ngoal (1 subgoal):\n 1. eventually_nonzero F f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (1::'b) \\<le> f x\n\ngoal (1 subgoal):\n 1. eventually_nonzero F f", "unfolding eventually_nonzero_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (1::'b) \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x \\<noteq> (0::'b)", "by eventually_elim auto"], ["proof (state)\nthis:\n  eventually_nonzero F f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eventually_nonneg_at_top_ASSUMPTION [eventually_nonzero_simps]:\n  \"ASSUMPTION (filterlim f at_top F) \\<Longrightarrow> eventually_nonneg F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSUMPTION (filterlim f at_top F) \\<Longrightarrow>\n    eventually_nonneg F f", "by (simp add: ASSUMPTION_def eventually_nonneg_at_top)"], ["", "lemma eventually_nonzero_at_top_ASSUMPTION [eventually_nonzero_simps]:\n  \"ASSUMPTION (filterlim f (at_top :: 'a :: {linordered_field, real_normed_field} filter) F) \\<Longrightarrow> \n     eventually_nonzero F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSUMPTION (filterlim f at_top F) \\<Longrightarrow>\n    eventually_nonzero F f", "using eventually_nonzero_at_top[of f F]"], ["proof (prove)\nusing this:\n  filterlim f at_top F \\<Longrightarrow> eventually_nonzero F f\n\ngoal (1 subgoal):\n 1. ASSUMPTION (filterlim f at_top F) \\<Longrightarrow>\n    eventually_nonzero F f", "by (simp add: ASSUMPTION_def)"], ["", "lemma filterlim_at_top_iff_smallomega:\n  fixes f :: \"_ \\<Rightarrow> real\"\n  shows \"filterlim f at_top F \\<longleftrightarrow> f \\<in> \\<omega>[F](\\<lambda>_. 1) \\<and> eventually_nonneg F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_top F =\n    (f \\<in> \\<omega>[F](\\<lambda>_. 1) \\<and> eventually_nonneg F f)", "unfolding eventually_nonneg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_top F =\n    (f \\<in> \\<omega>[F](\\<lambda>_. 1) \\<and>\n     (\\<forall>\\<^sub>F x in F. 0 \\<le> f x))", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. filterlim f at_top F \\<Longrightarrow>\n    f \\<in> \\<omega>[F](\\<lambda>_. 1)\n 2. filterlim f at_top F \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n 3. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "assume A: \"filterlim f at_top F\""], ["proof (state)\nthis:\n  filterlim f at_top F\n\ngoal (3 subgoals):\n 1. filterlim f at_top F \\<Longrightarrow>\n    f \\<in> \\<omega>[F](\\<lambda>_. 1)\n 2. filterlim f at_top F \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n 3. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "thus B: \"eventually (\\<lambda>x. f x \\<ge> 0) F\""], ["proof (prove)\nusing this:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 \\<le> f x", "by (simp add: eventually_nonzero_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (2 subgoals):\n 1. filterlim f at_top F \\<Longrightarrow>\n    f \\<in> \\<omega>[F](\\<lambda>_. 1)\n 2. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "{"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (2 subgoals):\n 1. filterlim f at_top F \\<Longrightarrow>\n    f \\<in> \\<omega>[F](\\<lambda>_. 1)\n 2. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. filterlim f at_top F \\<Longrightarrow>\n    f \\<in> \\<omega>[F](\\<lambda>_. 1)\n 2. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "from A"], ["proof (chain)\npicking this:\n  filterlim f at_top F", "have \"filterlim (\\<lambda>x. norm (f x)) at_top F\""], ["proof (prove)\nusing this:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. LIM x F. norm (f x) :> at_top", "by (intro filterlim_at_infinity_imp_norm_at_top filterlim_at_top_imp_at_infinity)"], ["proof (state)\nthis:\n  LIM x F. norm (f x) :> at_top\n\ngoal (2 subgoals):\n 1. filterlim f at_top F \\<Longrightarrow>\n    f \\<in> \\<omega>[F](\\<lambda>_. 1)\n 2. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "hence \"eventually (\\<lambda>x. norm (f x) \\<ge> c) F\""], ["proof (prove)\nusing this:\n  LIM x F. norm (f x) :> at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. c \\<le> norm (f x)", "by (auto simp: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. c \\<le> norm (f x)\n\ngoal (2 subgoals):\n 1. filterlim f at_top F \\<Longrightarrow>\n    f \\<in> \\<omega>[F](\\<lambda>_. 1)\n 2. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "}"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. ?c2 \\<le> norm (f x)\n\ngoal (2 subgoals):\n 1. filterlim f at_top F \\<Longrightarrow>\n    f \\<in> \\<omega>[F](\\<lambda>_. 1)\n 2. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "thus \"f \\<in> \\<omega>[F](\\<lambda>_. 1)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. ?c2 \\<le> norm (f x)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<omega>[F](\\<lambda>_. 1)", "by (rule landau_omega.smallI)"], ["proof (state)\nthis:\n  f \\<in> \\<omega>[F](\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "assume A: \"f \\<in> \\<omega>[F](\\<lambda>_. 1)\" and B: \"eventually (\\<lambda>x. f x \\<ge> 0) F\""], ["proof (state)\nthis:\n  f \\<in> \\<omega>[F](\\<lambda>_. 1)\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "{"], ["proof (state)\nthis:\n  f \\<in> \\<omega>[F](\\<lambda>_. 1)\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "fix c :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "assume \"c > 0\""], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "from landau_omega.smallD[OF A this] B"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. c * norm 1 \\<le> norm (f x)\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x", "have \"eventually (\\<lambda>x. f x \\<ge> c) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. c * norm 1 \\<le> norm (f x)\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. c \\<le> f x", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. c \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "}"], ["proof (state)\nthis:\n  0 < ?c2 \\<Longrightarrow> \\<forall>\\<^sub>F x in F. ?c2 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> \\<omega>[F](\\<lambda>_. 1);\n     \\<forall>\\<^sub>F x in F. 0 \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> filterlim f at_top F", "thus \"filterlim f at_top F\""], ["proof (prove)\nusing this:\n  0 < ?c2 \\<Longrightarrow> \\<forall>\\<^sub>F x in F. ?c2 \\<le> f x\n\ngoal (1 subgoal):\n 1. filterlim f at_top F", "by (subst filterlim_at_top_gt[of _ _ 0]) simp_all"], ["proof (state)\nthis:\n  filterlim f at_top F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smallomega_1_iff: \n  \"eventually_nonneg F f \\<Longrightarrow> f \\<in> \\<omega>[F](\\<lambda>_. 1 :: real) \\<longleftrightarrow> filterlim f at_top F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F f \\<Longrightarrow>\n    (f \\<in> \\<omega>[F](\\<lambda>_. 1)) = filterlim f at_top F", "by (simp add: filterlim_at_top_iff_smallomega)"], ["", "lemma smallo_1_iff: \n  \"eventually_nonneg F f \\<Longrightarrow> (\\<lambda>_. 1 :: real) \\<in> o[F](f) \\<longleftrightarrow> filterlim f at_top F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F f \\<Longrightarrow>\n    ((\\<lambda>_. 1) \\<in> o[F](f)) = filterlim f at_top F", "by (simp add: filterlim_at_top_iff_smallomega smallomega_iff_smallo)"], ["", "lemma eventually_nonneg_add1 [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"g \\<in> o[F](f)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x + g x :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x + g x)", "using  landau_o.smallD[OF assms(2) zero_less_one] assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (g x) \\<le> 1 * norm (f x)\n  eventually_nonneg F f\n\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x + g x)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (g x) \\<le> 1 * norm (f x)\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 \\<le> f x + g x", "by eventually_elim simp_all"], ["", "lemma eventually_nonneg_add2 [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F g\" \"f \\<in> o[F](g)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x + g x :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x + g x)", "using  landau_o.smallD[OF assms(2) zero_less_one] assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (f x) \\<le> 1 * norm (g x)\n  eventually_nonneg F g\n\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x + g x)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (f x) \\<le> 1 * norm (g x)\n  \\<forall>\\<^sub>F x in F. 0 \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 \\<le> f x + g x", "by eventually_elim simp_all"], ["", "lemma eventually_nonneg_diff1 [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F f\" \"g \\<in> o[F](f)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x - g x :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x - g x)", "using  landau_o.smallD[OF assms(2) zero_less_one] assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (g x) \\<le> 1 * norm (f x)\n  eventually_nonneg F f\n\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x - g x)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (g x) \\<le> 1 * norm (f x)\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 \\<le> f x - g x", "by eventually_elim simp_all"], ["", "lemma eventually_nonneg_diff2 [eventually_nonzero_simps]:\n  assumes \"eventually_nonneg F (\\<lambda>x. - g x)\" \"f \\<in> o[F](g)\"\n  shows   \"eventually_nonneg F (\\<lambda>x. f x - g x :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x - g x)", "using  landau_o.smallD[OF assms(2) zero_less_one] assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (f x) \\<le> 1 * norm (g x)\n  eventually_nonneg F (\\<lambda>x. - g x)\n\ngoal (1 subgoal):\n 1. eventually_nonneg F (\\<lambda>x. f x - g x)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (f x) \\<le> 1 * norm (g x)\n  \\<forall>\\<^sub>F x in F. 0 \\<le> - g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 \\<le> f x - g x", "by eventually_elim simp_all"], ["", "subsection \\<open>Rewriting Landau symbols\\<close>"], ["", "lemma bigtheta_mult_eq: \"\\<Theta>[F](\\<lambda>x. f x * g x) = \\<Theta>[F](f) * \\<Theta>[F](g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. f x * g x) = \\<Theta>[F](f) * \\<Theta>[F](g)", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)\n 2. \\<And>x.\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)", "fix h"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)\n 2. \\<And>x.\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)", "assume \"h \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)\""], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)\n 2. \\<And>x.\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)", "thus \"h \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)\""], ["proof (prove)\nusing this:\n  h \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)\n\ngoal (1 subgoal):\n 1. h \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)", "by (elim set_times_elim, hypsubst, unfold func_times) (erule (1) landau_theta.mult)"], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "assume \"h \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)\""], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "then"], ["proof (chain)\npicking this:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)", "guess c1 c2 :: real"], ["proof (prove)\nusing this:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x * g x)\n\ngoal (1 subgoal):\n 1. thesis", "unfolding bigtheta_def"], ["proof (prove)\nusing this:\n  h \\<in> O[F](\\<lambda>x. f x * g x) \\<inter>\n          \\<Omega>[F](\\<lambda>x. f x * g x)\n\ngoal (1 subgoal):\n 1. thesis", "by (elim landau_o.bigE landau_omega.bigE IntE)"], ["proof (state)\nthis:\n  0 < c1\n  \\<forall>\\<^sub>F x in F. norm (h x) \\<le> c1 * norm (f x * g x)\n  0 < c2\n  \\<forall>\\<^sub>F x in F. c2 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "note c = this"], ["proof (state)\nthis:\n  0 < c1\n  \\<forall>\\<^sub>F x in F. norm (h x) \\<le> c1 * norm (f x * g x)\n  0 < c2\n  \\<forall>\\<^sub>F x in F. c2 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "define h1 h2\n    where \"h1 x = (if g x = 0 then if f x = 0 then if h x = 0 then h x else 1 else f x else h x / g x)\"\n      and \"h2 x = (if g x = 0 then if f x = 0 then h x else h x / f x else g x)\"\n    for x"], ["proof (state)\nthis:\n  h1 ?x =\n  (if g ?x = (0::'b)\n   then if f ?x = (0::'b) then if h ?x = (0::'b) then h ?x else (1::'b)\n        else f ?x\n   else h ?x / g ?x)\n  h2 ?x =\n  (if g ?x = (0::'b) then if f ?x = (0::'b) then h ?x else h ?x / f ?x\n   else g ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "have \"h = h1 * h2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h = h1 * h2", "by (intro ext) (auto simp: h1_def h2_def field_simps)"], ["proof (state)\nthis:\n  h = h1 * h2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "moreover"], ["proof (state)\nthis:\n  h = h1 * h2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "have \"h1 \\<in> \\<Theta>[F](f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h1 \\<in> \\<Theta>[F](f)", "proof (rule bigthetaI')"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < ?c1.0\n 2. 0 < ?c2.0\n 3. \\<forall>\\<^sub>F x in F.\n       ?c1.0 * norm (f x) \\<le> norm (h1 x) \\<and>\n       norm (h1 x) \\<le> ?c2.0 * norm (f x)", "from c(3)"], ["proof (chain)\npicking this:\n  0 < c2", "show \"min c2 1 > 0\""], ["proof (prove)\nusing this:\n  0 < c2\n\ngoal (1 subgoal):\n 1. 0 < min c2 1", "by simp"], ["proof (state)\nthis:\n  0 < min c2 1\n\ngoal (2 subgoals):\n 1. 0 < ?c2.0\n 2. \\<forall>\\<^sub>F x in F.\n       min c2 1 * norm (f x) \\<le> norm (h1 x) \\<and>\n       norm (h1 x) \\<le> ?c2.0 * norm (f x)", "from c(1)"], ["proof (chain)\npicking this:\n  0 < c1", "show \"max c1 1 > 0\""], ["proof (prove)\nusing this:\n  0 < c1\n\ngoal (1 subgoal):\n 1. 0 < max c1 1", "by simp"], ["proof (state)\nthis:\n  0 < max c1 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F.\n       min c2 1 * norm (f x) \\<le> norm (h1 x) \\<and>\n       norm (h1 x) \\<le> max c1 1 * norm (f x)", "from c(2,4)"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. norm (h x) \\<le> c1 * norm (f x * g x)\n  \\<forall>\\<^sub>F x in F. c2 * norm (f x * g x) \\<le> norm (h x)", "show \"eventually (\\<lambda>x. min c2 1 * (norm (f x)) \\<le> norm (h1 x) \\<and> \n                            norm (h1 x) \\<le> max c1 1 * (norm (f x))) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (h x) \\<le> c1 * norm (f x * g x)\n  \\<forall>\\<^sub>F x in F. c2 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F.\n       min c2 1 * norm (f x) \\<le> norm (h1 x) \\<and>\n       norm (h1 x) \\<le> max c1 1 * norm (f x)", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (f x) \\<le> norm (h1 x) \\<and>\n                         norm (h1 x) \\<le> max c1 1 * norm (f x)", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (f x) \\<le> norm (h1 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (f x) \\<le> norm (h1 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "assume A: \"(norm (h x)) \\<le> c1 * norm (f x * g x)\" \n               and B: \"(norm (h x)) \\<ge> c2 * norm (f x * g x)\""], ["proof (state)\nthis:\n  norm (h x) \\<le> c1 * norm (f x * g x)\n  c2 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (f x) \\<le> norm (h1 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "have m: \"min c2 1 * (norm (f x)) \\<le> 1 * (norm (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min c2 1 * norm (f x) \\<le> 1 * norm (f x)", "by (rule mult_right_mono) simp_all"], ["proof (state)\nthis:\n  min c2 1 * norm (f x) \\<le> 1 * norm (f x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (f x) \\<le> norm (h1 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "have \"min c2 1 * norm (f x * g x) \\<le> c2 * norm (f x * g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min c2 1 * norm (f x * g x) \\<le> c2 * norm (f x * g x)", "by (intro mult_right_mono) simp_all"], ["proof (state)\nthis:\n  min c2 1 * norm (f x * g x) \\<le> c2 * norm (f x * g x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (f x) \\<le> norm (h1 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "also"], ["proof (state)\nthis:\n  min c2 1 * norm (f x * g x) \\<le> c2 * norm (f x * g x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (f x) \\<le> norm (h1 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "note B"], ["proof (state)\nthis:\n  c2 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (f x) \\<le> norm (h1 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "finally"], ["proof (chain)\npicking this:\n  min c2 1 * norm (f x * g x) \\<le> norm (h x)", "show \"norm (h1 x) \\<ge> min c2 1 * (norm (f x))\""], ["proof (prove)\nusing this:\n  min c2 1 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (1 subgoal):\n 1. min c2 1 * norm (f x) \\<le> norm (h1 x)", "using m A"], ["proof (prove)\nusing this:\n  min c2 1 * norm (f x * g x) \\<le> norm (h x)\n  min c2 1 * norm (f x) \\<le> 1 * norm (f x)\n  norm (h x) \\<le> c1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. min c2 1 * norm (f x) \\<le> norm (h1 x)", "by (cases \"g x = 0\") (simp_all add: h1_def norm_mult norm_divide field_simps)+"], ["proof (state)\nthis:\n  min c2 1 * norm (f x) \\<le> norm (h1 x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "have m: \"1 * (norm (f x)) \\<le> max c1 1 * (norm (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * norm (f x) \\<le> max c1 1 * norm (f x)", "by (rule mult_right_mono) simp_all"], ["proof (state)\nthis:\n  1 * norm (f x) \\<le> max c1 1 * norm (f x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "note A"], ["proof (state)\nthis:\n  norm (h x) \\<le> c1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "also"], ["proof (state)\nthis:\n  norm (h x) \\<le> c1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "have \"c1 * norm (f x * g x) \\<le> max c1 1 * norm (f x * g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 * norm (f x * g x) \\<le> max c1 1 * norm (f x * g x)", "by (intro mult_right_mono) simp_all"], ["proof (state)\nthis:\n  c1 * norm (f x * g x) \\<le> max c1 1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h1 x) \\<le> max c1 1 * norm (f x)", "finally"], ["proof (chain)\npicking this:\n  norm (h x) \\<le> max c1 1 * norm (f x * g x)", "show \"norm (h1 x) \\<le> max c1 1 * (norm (f x))\""], ["proof (prove)\nusing this:\n  norm (h x) \\<le> max c1 1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. norm (h1 x) \\<le> max c1 1 * norm (f x)", "using m A"], ["proof (prove)\nusing this:\n  norm (h x) \\<le> max c1 1 * norm (f x * g x)\n  1 * norm (f x) \\<le> max c1 1 * norm (f x)\n  norm (h x) \\<le> c1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. norm (h1 x) \\<le> max c1 1 * norm (f x)", "by (cases \"g x = 0\") (simp_all add: h1_def norm_mult norm_divide field_simps)+"], ["proof (state)\nthis:\n  norm (h1 x) \\<le> max c1 1 * norm (f x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F.\n     min c2 1 * norm (f x) \\<le> norm (h1 x) \\<and>\n     norm (h1 x) \\<le> max c1 1 * norm (f x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h1 \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "moreover"], ["proof (state)\nthis:\n  h1 \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "have \"h2 \\<in> \\<Theta>[F](g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h2 \\<in> \\<Theta>[F](g)", "proof (rule bigthetaI')"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < ?c1.0\n 2. 0 < ?c2.0\n 3. \\<forall>\\<^sub>F x in F.\n       ?c1.0 * norm (g x) \\<le> norm (h2 x) \\<and>\n       norm (h2 x) \\<le> ?c2.0 * norm (g x)", "from c(3)"], ["proof (chain)\npicking this:\n  0 < c2", "show \"min c2 1 > 0\""], ["proof (prove)\nusing this:\n  0 < c2\n\ngoal (1 subgoal):\n 1. 0 < min c2 1", "by simp"], ["proof (state)\nthis:\n  0 < min c2 1\n\ngoal (2 subgoals):\n 1. 0 < ?c2.0\n 2. \\<forall>\\<^sub>F x in F.\n       min c2 1 * norm (g x) \\<le> norm (h2 x) \\<and>\n       norm (h2 x) \\<le> ?c2.0 * norm (g x)", "from c(1)"], ["proof (chain)\npicking this:\n  0 < c1", "show \"max c1 1 > 0\""], ["proof (prove)\nusing this:\n  0 < c1\n\ngoal (1 subgoal):\n 1. 0 < max c1 1", "by simp"], ["proof (state)\nthis:\n  0 < max c1 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F.\n       min c2 1 * norm (g x) \\<le> norm (h2 x) \\<and>\n       norm (h2 x) \\<le> max c1 1 * norm (g x)", "from c(2,4)"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. norm (h x) \\<le> c1 * norm (f x * g x)\n  \\<forall>\\<^sub>F x in F. c2 * norm (f x * g x) \\<le> norm (h x)", "show \"eventually (\\<lambda>x. min c2 1 * (norm (g x)) \\<le> norm (h2 x) \\<and>  \n                            norm (h2 x) \\<le> max c1 1 * (norm (g x))) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (h x) \\<le> c1 * norm (f x * g x)\n  \\<forall>\\<^sub>F x in F. c2 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F.\n       min c2 1 * norm (g x) \\<le> norm (h2 x) \\<and>\n       norm (h2 x) \\<le> max c1 1 * norm (g x)", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (g x) \\<le> norm (h2 x) \\<and>\n                         norm (h2 x) \\<le> max c1 1 * norm (g x)", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (g x) \\<le> norm (h2 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (g x) \\<le> norm (h2 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "assume A: \"(norm (h x)) \\<le> c1 * norm (f x * g x)\" \n               and B: \"(norm (h x)) \\<ge> c2 * norm (f x * g x)\""], ["proof (state)\nthis:\n  norm (h x) \\<le> c1 * norm (f x * g x)\n  c2 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (g x) \\<le> norm (h2 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "have m: \"min c2 1 * (norm (f x)) \\<le> 1 * (norm (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min c2 1 * norm (f x) \\<le> 1 * norm (f x)", "by (rule mult_right_mono) simp_all"], ["proof (state)\nthis:\n  min c2 1 * norm (f x) \\<le> 1 * norm (f x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (g x) \\<le> norm (h2 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "have \"min c2 1 * norm (f x * g x) \\<le> c2 * norm (f x * g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min c2 1 * norm (f x * g x) \\<le> c2 * norm (f x * g x)", "by (intro mult_right_mono) simp_all"], ["proof (state)\nthis:\n  min c2 1 * norm (f x * g x) \\<le> c2 * norm (f x * g x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (g x) \\<le> norm (h2 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "also"], ["proof (state)\nthis:\n  min c2 1 * norm (f x * g x) \\<le> c2 * norm (f x * g x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (g x) \\<le> norm (h2 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "note B"], ["proof (state)\nthis:\n  c2 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> min c2 1 * norm (g x) \\<le> norm (h2 x)\n 2. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "finally"], ["proof (chain)\npicking this:\n  min c2 1 * norm (f x * g x) \\<le> norm (h x)", "show \"norm (h2 x) \\<ge> min c2 1 * (norm (g x))\""], ["proof (prove)\nusing this:\n  min c2 1 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (1 subgoal):\n 1. min c2 1 * norm (g x) \\<le> norm (h2 x)", "using m A B"], ["proof (prove)\nusing this:\n  min c2 1 * norm (f x * g x) \\<le> norm (h x)\n  min c2 1 * norm (f x) \\<le> 1 * norm (f x)\n  norm (h x) \\<le> c1 * norm (f x * g x)\n  c2 * norm (f x * g x) \\<le> norm (h x)\n\ngoal (1 subgoal):\n 1. min c2 1 * norm (g x) \\<le> norm (h2 x)", "by (cases \"g x = 0\") (auto simp: h2_def abs_mult field_simps)+"], ["proof (state)\nthis:\n  min c2 1 * norm (g x) \\<le> norm (h2 x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "have m: \"1 * (norm (g x)) \\<le> max c1 1 * (norm (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * norm (g x) \\<le> max c1 1 * norm (g x)", "by (rule mult_right_mono) simp_all"], ["proof (state)\nthis:\n  1 * norm (g x) \\<le> max c1 1 * norm (g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "note A"], ["proof (state)\nthis:\n  norm (h x) \\<le> c1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "also"], ["proof (state)\nthis:\n  norm (h x) \\<le> c1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "have \"c1 * norm (f x * g x) \\<le> max c1 1 * norm (f x * g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 * norm (f x * g x) \\<le> max c1 1 * norm (f x * g x)", "by (intro mult_right_mono) simp_all"], ["proof (state)\nthis:\n  c1 * norm (f x * g x) \\<le> max c1 1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm (h x) \\<le> c1 * norm (f x * g x);\n        c2 * norm (f x * g x) \\<le> norm (h x)\\<rbrakk>\n       \\<Longrightarrow> norm (h2 x) \\<le> max c1 1 * norm (g x)", "finally"], ["proof (chain)\npicking this:\n  norm (h x) \\<le> max c1 1 * norm (f x * g x)", "show \"norm (h2 x) \\<le> max c1 1 * (norm (g x))\""], ["proof (prove)\nusing this:\n  norm (h x) \\<le> max c1 1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. norm (h2 x) \\<le> max c1 1 * norm (g x)", "using m A"], ["proof (prove)\nusing this:\n  norm (h x) \\<le> max c1 1 * norm (f x * g x)\n  1 * norm (g x) \\<le> max c1 1 * norm (g x)\n  norm (h x) \\<le> c1 * norm (f x * g x)\n\ngoal (1 subgoal):\n 1. norm (h2 x) \\<le> max c1 1 * norm (g x)", "by (cases \"g x = 0\") (simp_all add: h2_def abs_mult field_simps)+"], ["proof (state)\nthis:\n  norm (h2 x) \\<le> max c1 1 * norm (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F.\n     min c2 1 * norm (g x) \\<le> norm (h2 x) \\<and>\n     norm (h2 x) \\<le> max c1 1 * norm (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h2 \\<in> \\<Theta>[F](g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x * g x) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "ultimately"], ["proof (chain)\npicking this:\n  h = h1 * h2\n  h1 \\<in> \\<Theta>[F](f)\n  h2 \\<in> \\<Theta>[F](g)", "show \"h \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)\""], ["proof (prove)\nusing this:\n  h = h1 * h2\n  h1 \\<in> \\<Theta>[F](f)\n  h2 \\<in> \\<Theta>[F](g)\n\ngoal (1 subgoal):\n 1. h \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)", "by blast"], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](f) * \\<Theta>[F](g)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Since the simplifier does not currently rewriting with relations other than equality,\n  but we want to rewrite terms like @{term \"\\<Theta>(\\<lambda>x. log 2 x * x)\"} to @{term \"\\<Theta>(\\<lambda>x. ln x * x)\"}, \n  we need to bring the term into something that contains @{term \"\\<Theta>(\\<lambda>x. log 2 x)\"} and \n  @{term \"\\<Theta>(\\<lambda>x. x)\"}, which can then be rewritten individually.\n  For this, we introduce the following constants and rewrite rules. The rules are mainly used \n  by the simprocs, but may be useful for manual reasoning occasionally.\n\\<close>"], ["", "definition \"set_mult A B = {\\<lambda>x. f x * g x |f g. f \\<in> A \\<and> g \\<in> B}\""], ["", "definition \"set_inverse A = {\\<lambda>x. inverse (f x) |f. f \\<in> A}\""], ["", "definition \"set_divide A B = {\\<lambda>x. f x / g x |f g. f \\<in> A \\<and> g \\<in> B}\""], ["", "definition \"set_pow A n = {\\<lambda>x. f x ^ n |f. f \\<in> A}\""], ["", "definition \"set_powr A y = {\\<lambda>x. f x powr y |f. f \\<in> A}\""], ["", "lemma bigtheta_mult_eq_set_mult:\n  shows \"\\<Theta>[F](\\<lambda>x. f x * g x) = set_mult (\\<Theta>[F](f)) (\\<Theta>[F](g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. f x * g x) =\n    set_mult \\<Theta>[F](f) \\<Theta>[F](g)", "unfolding bigtheta_mult_eq set_mult_def set_times_def func_times"], ["proof (prove)\ngoal (1 subgoal):\n 1. {c. \\<exists>a\\<in>\\<Theta>[F](f).\n           \\<exists>b\\<in>\\<Theta>[F](g). c = (\\<lambda>x. a x * b x)} =\n    {\\<lambda>x. fa x * ga x |fa ga.\n     fa \\<in> \\<Theta>[F](f) \\<and> ga \\<in> \\<Theta>[F](g)}", "by blast"], ["", "lemma bigtheta_inverse_eq_set_inverse:\n  shows \"\\<Theta>[F](\\<lambda>x. inverse (f x)) = set_inverse (\\<Theta>[F](f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. inverse (f x)) = set_inverse \\<Theta>[F](f)", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x)) \\<Longrightarrow>\n       x \\<in> set_inverse \\<Theta>[F](f)\n 2. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "fix g :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x)) \\<Longrightarrow>\n       x \\<in> set_inverse \\<Theta>[F](f)\n 2. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "assume \"g \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))\""], ["proof (state)\nthis:\n  g \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x)) \\<Longrightarrow>\n       x \\<in> set_inverse \\<Theta>[F](f)\n 2. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "hence \"(\\<lambda>x. inverse (g x)) \\<in> \\<Theta>[F](\\<lambda>x. inverse (inverse (f x)))\""], ["proof (prove)\nusing this:\n  g \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (g x))\n    \\<in> \\<Theta>[F](\\<lambda>x. inverse (inverse (f x)))", "by (subst bigtheta_inverse)"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (g x))\n  \\<in> \\<Theta>[F](\\<lambda>x. inverse (inverse (f x)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x)) \\<Longrightarrow>\n       x \\<in> set_inverse \\<Theta>[F](f)\n 2. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (g x))\n  \\<in> \\<Theta>[F](\\<lambda>x. inverse (inverse (f x)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x)) \\<Longrightarrow>\n       x \\<in> set_inverse \\<Theta>[F](f)\n 2. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "have \"(\\<lambda>x. inverse (inverse (f x))) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (inverse (f x))) = f", "by (rule ext) simp"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (inverse (f x))) = f\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x)) \\<Longrightarrow>\n       x \\<in> set_inverse \\<Theta>[F](f)\n 2. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. inverse (g x)) \\<in> \\<Theta>[F](f)", "show \"g \\<in> set_inverse (\\<Theta>[F](f))\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. inverse (g x)) \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. g \\<in> set_inverse \\<Theta>[F](f)", "unfolding set_inverse_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. inverse (g x)) \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. g \\<in> {\\<lambda>x. inverse (fa x) |fa. fa \\<in> \\<Theta>[F](f)}", "by force"], ["proof (state)\nthis:\n  g \\<in> set_inverse \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "fix g :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "assume \"g \\<in> set_inverse (\\<Theta>[F](f))\""], ["proof (state)\nthis:\n  g \\<in> set_inverse \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "then"], ["proof (chain)\npicking this:\n  g \\<in> set_inverse \\<Theta>[F](f)", "obtain g' where \"g = (\\<lambda>x. inverse (g' x))\" \"g' \\<in> \\<Theta>[F](f)\""], ["proof (prove)\nusing this:\n  g \\<in> set_inverse \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>g = (\\<lambda>x. inverse (g' x));\n         g' \\<in> \\<Theta>[F](f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_inverse_def"], ["proof (prove)\nusing this:\n  g \\<in> {\\<lambda>x. inverse (fa x) |fa. fa \\<in> \\<Theta>[F](f)}\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>g = (\\<lambda>x. inverse (g' x));\n         g' \\<in> \\<Theta>[F](f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g = (\\<lambda>x. inverse (g' x))\n  g' \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "hence \"(\\<lambda>x. inverse (g' x)) \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))\""], ["proof (prove)\nusing this:\n  g = (\\<lambda>x. inverse (g' x))\n  g' \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (g' x))\n    \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "by (subst bigtheta_inverse)"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (g' x)) \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (g' x)) \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "from \\<open>g = (\\<lambda>x. inverse (g' x))\\<close>"], ["proof (chain)\npicking this:\n  g = (\\<lambda>x. inverse (g' x))", "have \"(\\<lambda>x. inverse (g' x)) = g\""], ["proof (prove)\nusing this:\n  g = (\\<lambda>x. inverse (g' x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (g' x)) = g", "by (intro ext) simp"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (g' x)) = g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_inverse \\<Theta>[F](f) \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "finally"], ["proof (chain)\npicking this:\n  g \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "show \"g \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))\""], ["proof (prove)\nusing this:\n  g \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))\n\ngoal (1 subgoal):\n 1. g \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))", "."], ["proof (state)\nthis:\n  g \\<in> \\<Theta>[F](\\<lambda>x. inverse (f x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_divide_inverse: \n  \"set_divide (A :: (_ \\<Rightarrow> (_ :: division_ring)) set) B = set_mult A (set_inverse B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_divide A B = set_mult A (set_inverse B)", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_divide A B \\<Longrightarrow>\n       x \\<in> set_mult A (set_inverse B)\n 2. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_divide A B \\<Longrightarrow>\n       x \\<in> set_mult A (set_inverse B)\n 2. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "assume \"f \\<in> set_divide A B\""], ["proof (state)\nthis:\n  f \\<in> set_divide A B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_divide A B \\<Longrightarrow>\n       x \\<in> set_mult A (set_inverse B)\n 2. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "then"], ["proof (chain)\npicking this:\n  f \\<in> set_divide A B", "obtain g h where \"f = (\\<lambda>x. g x / h x)\" \"g \\<in> A\" \"h \\<in> B\""], ["proof (prove)\nusing this:\n  f \\<in> set_divide A B\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>f = (\\<lambda>x. g x / h x); g \\<in> A; h \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_divide_def"], ["proof (prove)\nusing this:\n  f \\<in> {\\<lambda>x. f x / g x |f g. f \\<in> A \\<and> g \\<in> B}\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>f = (\\<lambda>x. g x / h x); g \\<in> A; h \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f = (\\<lambda>x. g x / h x)\n  g \\<in> A\n  h \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_divide A B \\<Longrightarrow>\n       x \\<in> set_mult A (set_inverse B)\n 2. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "hence \"f = g * (\\<lambda>x. inverse (h x))\" \"(\\<lambda>x. inverse (h x)) \\<in> set_inverse B\""], ["proof (prove)\nusing this:\n  f = (\\<lambda>x. g x / h x)\n  g \\<in> A\n  h \\<in> B\n\ngoal (1 subgoal):\n 1. f = g * (\\<lambda>x. inverse (h x)) &&&\n    (\\<lambda>x. inverse (h x)) \\<in> set_inverse B", "unfolding set_inverse_def"], ["proof (prove)\nusing this:\n  f = (\\<lambda>x. g x / h x)\n  g \\<in> A\n  h \\<in> B\n\ngoal (1 subgoal):\n 1. f = g * (\\<lambda>x. inverse (h x)) &&&\n    (\\<lambda>x. inverse (h x))\n    \\<in> {\\<lambda>x. inverse (f x) |f. f \\<in> B}", "by (auto simp: divide_inverse)"], ["proof (state)\nthis:\n  f = g * (\\<lambda>x. inverse (h x))\n  (\\<lambda>x. inverse (h x)) \\<in> set_inverse B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_divide A B \\<Longrightarrow>\n       x \\<in> set_mult A (set_inverse B)\n 2. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "with \\<open>g \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> A\n  f = g * (\\<lambda>x. inverse (h x))\n  (\\<lambda>x. inverse (h x)) \\<in> set_inverse B", "show \"f \\<in> set_mult A (set_inverse B)\""], ["proof (prove)\nusing this:\n  g \\<in> A\n  f = g * (\\<lambda>x. inverse (h x))\n  (\\<lambda>x. inverse (h x)) \\<in> set_inverse B\n\ngoal (1 subgoal):\n 1. f \\<in> set_mult A (set_inverse B)", "unfolding set_mult_def"], ["proof (prove)\nusing this:\n  g \\<in> A\n  f = g * (\\<lambda>x. inverse (h x))\n  (\\<lambda>x. inverse (h x)) \\<in> set_inverse B\n\ngoal (1 subgoal):\n 1. f \\<in> {\\<lambda>x. f x * g x |f g.\n             f \\<in> A \\<and> g \\<in> set_inverse B}", "by force"], ["proof (state)\nthis:\n  f \\<in> set_mult A (set_inverse B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "assume \"f \\<in> set_mult A (set_inverse B)\""], ["proof (state)\nthis:\n  f \\<in> set_mult A (set_inverse B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "then"], ["proof (chain)\npicking this:\n  f \\<in> set_mult A (set_inverse B)", "obtain g h where \"f = g * (\\<lambda>x. inverse (h x))\" \"g \\<in> A\" \"h \\<in> B\""], ["proof (prove)\nusing this:\n  f \\<in> set_mult A (set_inverse B)\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>f = g * (\\<lambda>x. inverse (h x)); g \\<in> A;\n         h \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_times_def set_inverse_def set_mult_def"], ["proof (prove)\nusing this:\n  f \\<in> {\\<lambda>x. f x * g x |f g.\n           f \\<in> A \\<and>\n           g \\<in> {\\<lambda>x. inverse (f x) |f. f \\<in> B}}\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>f = g * (\\<lambda>x. inverse (h x)); g \\<in> A;\n         h \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  f = g * (\\<lambda>x. inverse (h x))\n  g \\<in> A\n  h \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "hence \"f = (\\<lambda>x. g x / h x)\""], ["proof (prove)\nusing this:\n  f = g * (\\<lambda>x. inverse (h x))\n  g \\<in> A\n  h \\<in> B\n\ngoal (1 subgoal):\n 1. f = (\\<lambda>x. g x / h x)", "by (intro ext) (simp add: divide_inverse)"], ["proof (state)\nthis:\n  f = (\\<lambda>x. g x / h x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_mult A (set_inverse B) \\<Longrightarrow>\n       x \\<in> set_divide A B", "with \\<open>g \\<in> A\\<close> \\<open>h \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> A\n  h \\<in> B\n  f = (\\<lambda>x. g x / h x)", "show \"f \\<in> set_divide A B\""], ["proof (prove)\nusing this:\n  g \\<in> A\n  h \\<in> B\n  f = (\\<lambda>x. g x / h x)\n\ngoal (1 subgoal):\n 1. f \\<in> set_divide A B", "unfolding set_divide_def"], ["proof (prove)\nusing this:\n  g \\<in> A\n  h \\<in> B\n  f = (\\<lambda>x. g x / h x)\n\ngoal (1 subgoal):\n 1. f \\<in> {\\<lambda>x. f x / g x |f g. f \\<in> A \\<and> g \\<in> B}", "by blast"], ["proof (state)\nthis:\n  f \\<in> set_divide A B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bigtheta_divide_eq_set_divide:\n  shows \"\\<Theta>[F](\\<lambda>x. f x / g x) = set_divide (\\<Theta>[F](f)) (\\<Theta>[F](g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. f x / g x) =\n    set_divide \\<Theta>[F](f) \\<Theta>[F](g)", "by (simp only: set_divide_inverse divide_inverse bigtheta_mult_eq_set_mult \n                 bigtheta_inverse_eq_set_inverse)"], ["", "primrec bigtheta_pow where\n  \"bigtheta_pow F A 0 = \\<Theta>[F](\\<lambda>_. 1)\"\n| \"bigtheta_pow F A (Suc n) = set_mult A (bigtheta_pow F A n)\""], ["", "lemma bigtheta_pow_eq_set_pow: \"\\<Theta>[F](\\<lambda>x. f x ^ n) = bigtheta_pow F (\\<Theta>[F](f)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. f x ^ n) = bigtheta_pow F \\<Theta>[F](f) n", "by (induction n) (simp_all add: bigtheta_mult_eq_set_mult)"], ["", "definition bigtheta_powr where\n  \"bigtheta_powr F A y = (if y = 0 then {f. \\<exists>g\\<in>A. eventually_nonneg F g \\<and> f \\<in> \\<Theta>[F](\\<lambda>x. g x powr y)} \n     else {f. \\<exists>g\\<in>A. eventually_nonneg F g \\<and> (\\<forall>x. (norm (f x)) = g x powr y)})\""], ["", "lemma bigtheta_powr_eq_set_powr: \n  assumes \"eventually_nonneg F f\"\n  shows   \"\\<Theta>[F](\\<lambda>x. f x powr (y::real)) = bigtheta_powr F (\\<Theta>[F](f)) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y", "proof (cases \"y = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y", "assume [simp]: \"y = 0\""], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "fix h"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "assume \"h \\<in> bigtheta_powr F \\<Theta>[F](f) y\""], ["proof (state)\nthis:\n  h \\<in> bigtheta_powr F \\<Theta>[F](f) y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "then"], ["proof (chain)\npicking this:\n  h \\<in> bigtheta_powr F \\<Theta>[F](f) y", "obtain g where g: \"g \\<in> \\<Theta>[F](f)\" \"eventually_nonneg F g\" \"h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\""], ["proof (prove)\nusing this:\n  h \\<in> bigtheta_powr F \\<Theta>[F](f) y\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> \\<Theta>[F](f); eventually_nonneg F g;\n         h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding bigtheta_powr_def"], ["proof (prove)\nusing this:\n  h \\<in> (if y = 0\n           then {fa.\n                 \\<exists>g\\<in>\\<Theta>[F](f).\n                    eventually_nonneg F g \\<and>\n                    fa \\<in> \\<Theta>[F](\\<lambda>x. g x powr y)}\n           else {fa.\n                 \\<exists>g\\<in>\\<Theta>[F](f).\n                    eventually_nonneg F g \\<and>\n                    (\\<forall>x. norm (fa x) = g x powr y)})\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> \\<Theta>[F](f); eventually_nonneg F g;\n         h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  g \\<in> \\<Theta>[F](f)\n  eventually_nonneg F g\n  h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "note this(3)"], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "also"], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "have \"(\\<lambda>x. g x powr 0) \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr 0)\n    \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr 0)", "using assms"], ["proof (prove)\nusing this:\n  eventually_nonneg F f\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr 0)\n    \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr 0)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr 0)\n    \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr 0)", "by (intro bigthetaI_cong) (auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr 0)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr 0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr 0)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr 0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "from g(1)"], ["proof (chain)\npicking this:\n  g \\<in> \\<Theta>[F](f)", "have \"(\\<lambda>x. \\<bar>g x\\<bar> powr 0) \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr 0)\""], ["proof (prove)\nusing this:\n  g \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>g x\\<bar> powr 0)\n    \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr 0)", "by (rule bigtheta_powr)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>g x\\<bar> powr 0)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr 0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>g x\\<bar> powr 0)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr 0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "from g(2)"], ["proof (chain)\npicking this:\n  eventually_nonneg F g", "have \"(\\<lambda>x. f x powr 0) \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr 0)\""], ["proof (prove)\nusing this:\n  eventually_nonneg F g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr 0)\n    \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr 0)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 \\<le> g x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr 0)\n    \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr 0)", "by (intro bigthetaI_cong) (auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  (\\<lambda>x. f x powr 0)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr 0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "finally"], ["proof (chain)\npicking this:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x powr 0)", "show \"h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\""], ["proof (prove)\nusing this:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x powr 0)\n\ngoal (1 subgoal):\n 1. h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "by simp"], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y", "assume \"h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\""], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y", "with assms"], ["proof (chain)\npicking this:\n  eventually_nonneg F f\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "have \"\\<exists>g\\<in>\\<Theta>[F](f). eventually_nonneg F g \\<and> h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\""], ["proof (prove)\nusing this:\n  eventually_nonneg F f\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<Theta>[F](f).\n       eventually_nonneg F g \\<and>\n       h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)", "by (intro bexI[of _ f] conjI) simp_all"], ["proof (state)\nthis:\n  \\<exists>g\\<in>\\<Theta>[F](f).\n     eventually_nonneg F g \\<and>\n     h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y", "thus \"h \\<in> bigtheta_powr F \\<Theta>[F](f) y\""], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>\\<Theta>[F](f).\n     eventually_nonneg F g \\<and>\n     h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\n\ngoal (1 subgoal):\n 1. h \\<in> bigtheta_powr F \\<Theta>[F](f) y", "unfolding bigtheta_powr_def"], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>\\<Theta>[F](f).\n     eventually_nonneg F g \\<and>\n     h \\<in> \\<Theta>[F](\\<lambda>x. g x powr 0)\n\ngoal (1 subgoal):\n 1. h \\<in> (if y = 0\n             then {fa.\n                   \\<exists>g\\<in>\\<Theta>[F](f).\n                      eventually_nonneg F g \\<and>\n                      fa \\<in> \\<Theta>[F](\\<lambda>x. g x powr y)}\n             else {fa.\n                   \\<exists>g\\<in>\\<Theta>[F](f).\n                      eventually_nonneg F g \\<and>\n                      (\\<forall>x. norm (fa x) = g x powr y)})", "by simp"], ["proof (state)\nthis:\n  h \\<in> bigtheta_powr F \\<Theta>[F](f) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y", "assume y: \"y \\<noteq> 0\""], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "fix h"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "assume h: \"h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\""], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "let ?h' = \"\\<lambda>x. \\<bar>h x\\<bar> powr inverse y\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "from bigtheta_powr[OF h, of \"inverse y\"] y"], ["proof (chain)\npicking this:\n  (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x powr y\\<bar> powr inverse y)\n  y \\<noteq> 0", "have \"?h' \\<in> \\<Theta>[F](\\<lambda>x. f x powr 1)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x powr y\\<bar> powr inverse y)\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y)\n    \\<in> \\<Theta>[F](\\<lambda>x. f x powr 1)", "by (simp add: powr_powr)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y)\n  \\<in> \\<Theta>[F](\\<lambda>x. f x powr 1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y)\n  \\<in> \\<Theta>[F](\\<lambda>x. f x powr 1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "have \"(\\<lambda>x. f x powr 1) \\<in> \\<Theta>[F](f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr 1) \\<in> \\<Theta>[F](f)", "using assms"], ["proof (prove)\nusing this:\n  eventually_nonneg F f\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr 1) \\<in> \\<Theta>[F](f)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr 1) \\<in> \\<Theta>[F](f)", "by (intro bigthetaI_cong) (auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  (\\<lambda>x. f x powr 1) \\<in> \\<Theta>[F](f)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y) \\<in> \\<Theta>[F](f)", "have \"?h' \\<in> \\<Theta>[F](f)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y) \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y) \\<in> \\<Theta>[F](f)", "."], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y) \\<in> \\<Theta>[F](f)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "with y"], ["proof (chain)\npicking this:\n  y \\<noteq> 0\n  (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y) \\<in> \\<Theta>[F](f)", "have \"\\<exists>g\\<in>\\<Theta>[F](f). eventually_nonneg F g \\<and> (\\<forall>x. (norm (h x)) = g x powr y)\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  (\\<lambda>x. \\<bar>h x\\<bar> powr inverse y) \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<Theta>[F](f).\n       eventually_nonneg F g \\<and> (\\<forall>x. norm (h x) = g x powr y)", "by (intro bexI[of _ ?h']) (simp_all add: powr_powr eventually_nonneg_def)"], ["proof (state)\nthis:\n  \\<exists>g\\<in>\\<Theta>[F](f).\n     eventually_nonneg F g \\<and> (\\<forall>x. norm (h x) = g x powr y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y) \\<Longrightarrow>\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y\n 2. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "thus \"h \\<in> bigtheta_powr F \\<Theta>[F](f) y\""], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>\\<Theta>[F](f).\n     eventually_nonneg F g \\<and> (\\<forall>x. norm (h x) = g x powr y)\n\ngoal (1 subgoal):\n 1. h \\<in> bigtheta_powr F \\<Theta>[F](f) y", "using y"], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>\\<Theta>[F](f).\n     eventually_nonneg F g \\<and> (\\<forall>x. norm (h x) = g x powr y)\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<in> bigtheta_powr F \\<Theta>[F](f) y", "unfolding bigtheta_powr_def"], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>\\<Theta>[F](f).\n     eventually_nonneg F g \\<and> (\\<forall>x. norm (h x) = g x powr y)\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<in> (if y = 0\n             then {fa.\n                   \\<exists>g\\<in>\\<Theta>[F](f).\n                      eventually_nonneg F g \\<and>\n                      fa \\<in> \\<Theta>[F](\\<lambda>x. g x powr y)}\n             else {fa.\n                   \\<exists>g\\<in>\\<Theta>[F](f).\n                      eventually_nonneg F g \\<and>\n                      (\\<forall>x. norm (fa x) = g x powr y)})", "by simp"], ["proof (state)\nthis:\n  h \\<in> bigtheta_powr F \\<Theta>[F](f) y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "assume \"h \\<in> bigtheta_powr F (\\<Theta>[F](f)) y\""], ["proof (state)\nthis:\n  h \\<in> bigtheta_powr F \\<Theta>[F](f) y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "with y"], ["proof (chain)\npicking this:\n  y \\<noteq> 0\n  h \\<in> bigtheta_powr F \\<Theta>[F](f) y", "obtain g where A: \"g \\<in> \\<Theta>[F](f)\" \"\\<And>x. \\<bar>h x\\<bar> = g x powr y\" \"eventually_nonneg F g\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  h \\<in> bigtheta_powr F \\<Theta>[F](f) y\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> \\<Theta>[F](f);\n         \\<And>x. \\<bar>h x\\<bar> = g x powr y;\n         eventually_nonneg F g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding bigtheta_powr_def"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  h \\<in> (if y = 0\n           then {fa.\n                 \\<exists>g\\<in>\\<Theta>[F](f).\n                    eventually_nonneg F g \\<and>\n                    fa \\<in> \\<Theta>[F](\\<lambda>x. g x powr y)}\n           else {fa.\n                 \\<exists>g\\<in>\\<Theta>[F](f).\n                    eventually_nonneg F g \\<and>\n                    (\\<forall>x. norm (fa x) = g x powr y)})\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> \\<Theta>[F](f);\n         \\<And>x. \\<bar>h x\\<bar> = g x powr y;\n         eventually_nonneg F g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  g \\<in> \\<Theta>[F](f)\n  \\<bar>h ?x\\<bar> = g ?x powr y\n  eventually_nonneg F g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "from this(3)"], ["proof (chain)\npicking this:\n  eventually_nonneg F g", "have \"(\\<lambda>x. g x powr y) \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr y)\""], ["proof (prove)\nusing this:\n  eventually_nonneg F g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr y)\n    \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr y)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 \\<le> g x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr y)\n    \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr y)", "by (intro bigthetaI_cong) (auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr y)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr y)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>g x\\<bar> powr y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "from A(1)"], ["proof (chain)\npicking this:\n  g \\<in> \\<Theta>[F](f)", "have \"(\\<lambda>x. \\<bar>g x\\<bar> powr y) \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr y)\""], ["proof (prove)\nusing this:\n  g \\<in> \\<Theta>[F](f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>g x\\<bar> powr y)\n    \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr y)", "by (rule bigtheta_powr)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>g x\\<bar> powr y)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>g x\\<bar> powr y)\n  \\<in> \\<Theta>[F](\\<lambda>x. \\<bar>f x\\<bar> powr y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "have \"(\\<lambda>x. \\<bar>f x\\<bar> powr y) \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>f x\\<bar> powr y)\n    \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "using assms"], ["proof (prove)\nusing this:\n  eventually_nonneg F f\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>f x\\<bar> powr y)\n    \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "unfolding eventually_nonneg_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>f x\\<bar> powr y)\n    \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "by (intro bigthetaI_cong) (auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>f x\\<bar> powr y)\n  \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. g x powr y) \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "have \"(\\<lambda>x. \\<bar>h x\\<bar>) \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. g x powr y) \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>h x\\<bar>) \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "by (subst A(2))"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>h x\\<bar>) \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bigtheta_powr F \\<Theta>[F](f) y \\<Longrightarrow>\n       x \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "thus \"(\\<lambda>x. h x) \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<bar>h x\\<bar>) \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\n\ngoal (1 subgoal):\n 1. h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)", "by simp"], ["proof (state)\nthis:\n  h \\<in> \\<Theta>[F](\\<lambda>x. f x powr y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Theta>[F](\\<lambda>x. f x powr y) = bigtheta_powr F \\<Theta>[F](f) y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas bigtheta_factors_eq = \n  bigtheta_mult_eq_set_mult bigtheta_inverse_eq_set_inverse bigtheta_divide_eq_set_divide \n  bigtheta_pow_eq_set_pow bigtheta_powr_eq_set_powr"], ["", "lemmas landau_bigtheta_congs = landau_symbols[THEN landau_symbol.cong_bigtheta]"], ["", "lemma (in landau_symbol) meta_cong_bigtheta: \"\\<Theta>[F](f) \\<equiv> \\<Theta>[F](g) \\<Longrightarrow> L F (f) \\<equiv> L F (g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](f) \\<equiv> \\<Theta>[F](g) \\<Longrightarrow>\n    L F f \\<equiv> L F g", "using bigtheta_refl[of f]"], ["proof (prove)\nusing this:\n  f \\<in> \\<Theta>[?F](f)\n\ngoal (1 subgoal):\n 1. \\<Theta>[F](f) \\<equiv> \\<Theta>[F](g) \\<Longrightarrow>\n    L F f \\<equiv> L F g", "by (intro eq_reflection cong_bigtheta) blast"], ["", "lemmas landau_bigtheta_meta_congs = landau_symbols[THEN landau_symbol.meta_cong_bigtheta]"], ["", "subsection \\<open>Preliminary facts\\<close>"], ["", "lemma real_powr_at_top: \n  assumes \"(p::real) > 0\"\n  shows   \"filterlim (\\<lambda>x. x powr p) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. x powr p :> at_top", "proof (subst filterlim_cong[OF refl refl])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. x powr p = ?g x\n 2. filterlim ?g at_top at_top", "show \"LIM x at_top. exp (p * ln x) :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. exp (p * ln x) :> at_top", "by (rule filterlim_compose[OF exp_at_top filterlim_tendsto_pos_mult_at_top[OF tendsto_const]])\n       (simp_all add: ln_at_top assms)"], ["proof (state)\nthis:\n  LIM x at_top. exp (p * ln x) :> at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x powr p = exp (p * ln x)", "show \"eventually (\\<lambda>x. x powr p = exp (p * ln x)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x powr p = exp (p * ln x)", "using eventually_gt_at_top[of 0]"], ["proof (prove)\nusing this:\n  eventually ((<) (0::?'a1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x powr p = exp (p * ln x)", "by eventually_elim (simp add: powr_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. x powr p = exp (p * ln x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_ln_over_powr: \n  assumes \"(a::real) > 0\"\n  shows   \"((\\<lambda>x. ln x / x powr a) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x / x powr a) \\<longlongrightarrow> 0) at_top", "proof (rule lhospital_at_top_at_top)"], ["proof (state)\ngoal (5 subgoals):\n 1. LIM x at_top. x powr a :> at_top\n 2. \\<forall>\\<^sub>F x in at_top. ?g' x \\<noteq> 0\n 3. \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative ?f' x) (at x)\n 4. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. x powr a) has_real_derivative ?g' x) (at x)\n 5. ((\\<lambda>x. ?f' x / ?g' x) \\<longlongrightarrow> 0) at_top", "from assms"], ["proof (chain)\npicking this:\n  0 < a", "show \"LIM x at_top. x powr a :> at_top\""], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. LIM x at_top. x powr a :> at_top", "by (rule real_powr_at_top)"], ["proof (state)\nthis:\n  LIM x at_top. x powr a :> at_top\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. ?g' x \\<noteq> 0\n 2. \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative ?f' x) (at x)\n 3. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. x powr a) has_real_derivative ?g' x) (at x)\n 4. ((\\<lambda>x. ?f' x / ?g' x) \\<longlongrightarrow> 0) at_top", "show \"eventually (\\<lambda>x. a * x powr (a - 1) \\<noteq> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. a * x powr (a - 1) \\<noteq> 0", "using eventually_gt_at_top[of \"0::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. a * x powr (a - 1) \\<noteq> 0", "by eventually_elim (insert assms, simp)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. a * x powr (a - 1) \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative ?f' x) (at x)\n 2. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. x powr a) has_real_derivative a * x powr (a - 1))\n        (at x)\n 3. ((\\<lambda>x. ?f' x / (a * x powr (a - 1))) \\<longlongrightarrow> 0)\n     at_top", "show \"eventually (\\<lambda>x::real. (ln has_real_derivative (inverse x)) (at x)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative inverse x) (at x)", "using eventually_gt_at_top[of \"0::real\"] DERIV_ln"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n  0 < ?x \\<Longrightarrow> (ln has_real_derivative inverse ?x) (at ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative inverse x) (at x)", "by (elim eventually_mono) simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative inverse x) (at x)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. x powr a) has_real_derivative a * x powr (a - 1))\n        (at x)\n 2. ((\\<lambda>x. inverse x / (a * x powr (a - 1))) \\<longlongrightarrow> 0)\n     at_top", "show \"eventually (\\<lambda>x. ((\\<lambda>x. x powr a) has_real_derivative a * x powr (a - 1)) (at x)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. x powr a) has_real_derivative a * x powr (a - 1))\n        (at x)", "using eventually_gt_at_top[of \"0::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. x powr a) has_real_derivative a * x powr (a - 1))\n        (at x)", "by eventually_elim (auto intro!: derivative_eq_intros)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     ((\\<lambda>x. x powr a) has_real_derivative a * x powr (a - 1)) (at x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse x / (a * x powr (a - 1))) \\<longlongrightarrow> 0)\n     at_top", "have \"eventually (\\<lambda>x. inverse a * x powr -a = inverse x / (a*x powr (a-1))) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       inverse a * x powr - a = inverse x / (a * x powr (a - 1))", "using eventually_gt_at_top[of \"0::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       inverse a * x powr - a = inverse x / (a * x powr (a - 1))", "by (elim eventually_mono) (simp add: field_simps powr_diff powr_minus)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     inverse a * x powr - a = inverse x / (a * x powr (a - 1))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse x / (a * x powr (a - 1))) \\<longlongrightarrow> 0)\n     at_top", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     inverse a * x powr - a = inverse x / (a * x powr (a - 1))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse x / (a * x powr (a - 1))) \\<longlongrightarrow> 0)\n     at_top", "from assms"], ["proof (chain)\npicking this:\n  0 < a", "have \"((\\<lambda>x. inverse a * x powr -a) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse a * x powr - a) \\<longlongrightarrow> 0) at_top", "by (intro tendsto_mult_right_zero tendsto_neg_powr filterlim_ident) simp_all"], ["proof (state)\nthis:\n  ((\\<lambda>x. inverse a * x powr - a) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse x / (a * x powr (a - 1))) \\<longlongrightarrow> 0)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top.\n     inverse a * x powr - a = inverse x / (a * x powr (a - 1))\n  ((\\<lambda>x. inverse a * x powr - a) \\<longlongrightarrow> 0) at_top", "show \"((\\<lambda>x. inverse x / (a * x powr (a - 1))) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top.\n     inverse a * x powr - a = inverse x / (a * x powr (a - 1))\n  ((\\<lambda>x. inverse a * x powr - a) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse x / (a * x powr (a - 1))) \\<longlongrightarrow> 0)\n     at_top", "by (subst (asm) tendsto_cong) simp_all"], ["proof (state)\nthis:\n  ((\\<lambda>x. inverse x / (a * x powr (a - 1))) \\<longlongrightarrow> 0)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_ln_powr_over_powr: \n  assumes \"(a::real) > 0\" \"b > 0\"\n  shows   \"((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "have \"eventually (\\<lambda>x. ln x powr a / x powr b = (ln x / x powr (b/a)) powr a) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ln x powr a / x powr b = (ln x / x powr (b / a)) powr a", "using assms eventually_gt_at_top[of \"1::real\"]"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n  eventually ((<) 1) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ln x powr a / x powr b = (ln x / x powr (b / a)) powr a", "by (elim eventually_mono) (simp add: powr_divide powr_powr)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     ln x powr a / x powr b = (ln x / x powr (b / a)) powr a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     ln x powr a / x powr b = (ln x / x powr (b / a)) powr a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "have \"eventually (\\<lambda>x. 0 < ln x / x powr (b / a)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < ln x / x powr (b / a)", "using eventually_gt_at_top[of \"1::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 1) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < ln x / x powr (b / a)", "by (elim eventually_mono) simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. 0 < ln x / x powr (b / a)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "with assms"], ["proof (chain)\npicking this:\n  0 < a\n  0 < b\n  \\<forall>\\<^sub>F x in at_top. 0 < ln x / x powr (b / a)", "have \"((\\<lambda>x. (ln x / x powr (b/a)) powr a) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n  \\<forall>\\<^sub>F x in at_top. 0 < ln x / x powr (b / a)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (ln x / x powr (b / a)) powr a) \\<longlongrightarrow> 0)\n     at_top", "by (intro tendsto_zero_powrI tendsto_ln_over_powr) (simp_all add: eventually_mono)"], ["proof (state)\nthis:\n  ((\\<lambda>x. (ln x / x powr (b / a)) powr a) \\<longlongrightarrow> 0)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top.\n     ln x powr a / x powr b = (ln x / x powr (b / a)) powr a\n  ((\\<lambda>x. (ln x / x powr (b / a)) powr a) \\<longlongrightarrow> 0)\n   at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top.\n     ln x powr a / x powr b = (ln x / x powr (b / a)) powr a\n  ((\\<lambda>x. (ln x / x powr (b / a)) powr a) \\<longlongrightarrow> 0)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "by (subst tendsto_cong) simp_all"], ["proof (state)\nthis:\n  ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_ln_powr_over_powr': \n  assumes \"b > 0\"\n  shows   \"((\\<lambda>x::real. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "proof (cases \"a \\<le> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> 0 \\<Longrightarrow>\n    ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top\n 2. \\<not> a \\<le> 0 \\<Longrightarrow>\n    ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "assume a: \"a \\<le> 0\""], ["proof (state)\nthis:\n  a \\<le> 0\n\ngoal (2 subgoals):\n 1. a \\<le> 0 \\<Longrightarrow>\n    ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top\n 2. \\<not> a \\<le> 0 \\<Longrightarrow>\n    ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "proof (rule tendsto_sandwich[of \"\\<lambda>_::real. 0\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in at_top. 0 \\<le> ln n powr a / n powr b\n 2. \\<forall>\\<^sub>F n in at_top. ln n powr a / n powr b \\<le> ?h n\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) at_top\n 4. (?h \\<longlongrightarrow> 0) at_top", "have \"eventually (\\<lambda>x. ln x powr a \\<le> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln x powr a \\<le> 1", "unfolding eventually_at_top_linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. ln n powr a \\<le> 1", "proof (intro allI exI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. ?N \\<le> n \\<Longrightarrow> ln n powr a \\<le> 1", "fix x :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. ?N \\<le> n \\<Longrightarrow> ln n powr a \\<le> 1", "assume x: \"x \\<ge> exp 1\""], ["proof (state)\nthis:\n  exp 1 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>n. ?N \\<le> n \\<Longrightarrow> ln n powr a \\<le> 1", "have \"0 < exp (1::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < exp 1", "by simp"], ["proof (state)\nthis:\n  0 < exp 1\n\ngoal (1 subgoal):\n 1. \\<And>n. ?N \\<le> n \\<Longrightarrow> ln n powr a \\<le> 1", "also"], ["proof (state)\nthis:\n  0 < exp 1\n\ngoal (1 subgoal):\n 1. \\<And>n. ?N \\<le> n \\<Longrightarrow> ln n powr a \\<le> 1", "have \"\\<dots> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 1 \\<le> x", "by fact"], ["proof (state)\nthis:\n  exp 1 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>n. ?N \\<le> n \\<Longrightarrow> ln n powr a \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  0 < x", "have \"ln x \\<ge> ln (exp 1)\""], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. ln (exp 1) \\<le> ln x", "using x"], ["proof (prove)\nusing this:\n  0 < x\n  exp 1 \\<le> x\n\ngoal (1 subgoal):\n 1. ln (exp 1) \\<le> ln x", "by (subst ln_le_cancel_iff) auto"], ["proof (state)\nthis:\n  ln (exp 1) \\<le> ln x\n\ngoal (1 subgoal):\n 1. \\<And>n. ?N \\<le> n \\<Longrightarrow> ln n powr a \\<le> 1", "hence \"ln x powr a \\<le> ln (exp 1) powr a\""], ["proof (prove)\nusing this:\n  ln (exp 1) \\<le> ln x\n\ngoal (1 subgoal):\n 1. ln x powr a \\<le> ln (exp 1) powr a", "using a"], ["proof (prove)\nusing this:\n  ln (exp 1) \\<le> ln x\n  a \\<le> 0\n\ngoal (1 subgoal):\n 1. ln x powr a \\<le> ln (exp 1) powr a", "by (intro powr_mono2') simp_all"], ["proof (state)\nthis:\n  ln x powr a \\<le> ln (exp 1) powr a\n\ngoal (1 subgoal):\n 1. \\<And>n. ?N \\<le> n \\<Longrightarrow> ln n powr a \\<le> 1", "thus \"ln x powr a \\<le> 1\""], ["proof (prove)\nusing this:\n  ln x powr a \\<le> ln (exp 1) powr a\n\ngoal (1 subgoal):\n 1. ln x powr a \\<le> 1", "by simp"], ["proof (state)\nthis:\n  ln x powr a \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. ln x powr a \\<le> 1\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in at_top. 0 \\<le> ln n powr a / n powr b\n 2. \\<forall>\\<^sub>F n in at_top. ln n powr a / n powr b \\<le> ?h n\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) at_top\n 4. (?h \\<longlongrightarrow> 0) at_top", "thus \"eventually (\\<lambda>x. ln x powr a / x powr b \\<le> x powr -b) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. ln x powr a \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln x powr a / x powr b \\<le> x powr - b", "by eventually_elim (insert a, simp add: field_simps powr_minus divide_right_mono)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. ln x powr a / x powr b \\<le> x powr - b\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in at_top. 0 \\<le> ln n powr a / n powr b\n 2. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) at_top\n 3. ((\\<lambda>x. x powr - b) \\<longlongrightarrow> 0) at_top", "qed (auto intro!: filterlim_ident tendsto_neg_powr assms)"], ["proof (state)\nthis:\n  ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> 0 \\<Longrightarrow>\n    ((\\<lambda>x. ln x powr a / x powr b) \\<longlongrightarrow> 0) at_top", "qed (intro tendsto_ln_powr_over_powr, simp_all add: assms)"], ["", "lemma tendsto_ln_over_ln:\n  assumes \"(a::real) > 0\" \"c > 0\"\n  shows   \"((\\<lambda>x. ln (a*x) / ln (c*x)) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln (a * x) / ln (c * x)) \\<longlongrightarrow> 1) at_top", "proof (rule lhospital_at_top_at_top)"], ["proof (state)\ngoal (5 subgoals):\n 1. LIM x at_top. ln (c * x) :> at_top\n 2. \\<forall>\\<^sub>F x in at_top. ?g' x \\<noteq> 0\n 3. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (a * x)) has_real_derivative ?f' x) (at x)\n 4. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (c * x)) has_real_derivative ?g' x) (at x)\n 5. ((\\<lambda>x. ?f' x / ?g' x) \\<longlongrightarrow> 1) at_top", "show \"LIM x at_top. ln (c*x) :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. ln (c * x) :> at_top", "by (intro filterlim_compose[OF ln_at_top] filterlim_tendsto_pos_mult_at_top[OF tendsto_const] \n              filterlim_ident assms(2))"], ["proof (state)\nthis:\n  LIM x at_top. ln (c * x) :> at_top\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. ?g' x \\<noteq> 0\n 2. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (a * x)) has_real_derivative ?f' x) (at x)\n 3. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (c * x)) has_real_derivative ?g' x) (at x)\n 4. ((\\<lambda>x. ?f' x / ?g' x) \\<longlongrightarrow> 1) at_top", "show \"eventually (\\<lambda>x. ((\\<lambda>x. ln (a*x)) has_real_derivative (inverse x)) (at x)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (a * x)) has_real_derivative inverse x) (at x)", "using eventually_gt_at_top[of \"inverse a\"] assms"], ["proof (prove)\nusing this:\n  eventually ((<) (inverse a)) at_top\n  0 < a\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (a * x)) has_real_derivative inverse x) (at x)", "by (auto elim!: eventually_mono intro!: derivative_eq_intros simp: field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     ((\\<lambda>x. ln (a * x)) has_real_derivative inverse x) (at x)\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. ?g' x \\<noteq> 0\n 2. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (c * x)) has_real_derivative ?g' x) (at x)\n 3. ((\\<lambda>x. inverse x / ?g' x) \\<longlongrightarrow> 1) at_top", "show \"eventually (\\<lambda>x. ((\\<lambda>x. ln (c*x)) has_real_derivative (inverse x)) (at x)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (c * x)) has_real_derivative inverse x) (at x)", "using eventually_gt_at_top[of \"inverse c\"] assms"], ["proof (prove)\nusing this:\n  eventually ((<) (inverse c)) at_top\n  0 < a\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (c * x)) has_real_derivative inverse x) (at x)", "by (auto elim!: eventually_mono intro!: derivative_eq_intros simp: field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     ((\\<lambda>x. ln (c * x)) has_real_derivative inverse x) (at x)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_top. inverse x \\<noteq> 0\n 2. ((\\<lambda>x. inverse x / inverse x) \\<longlongrightarrow> 1) at_top", "show \"((\\<lambda>x::real. inverse x / inverse x) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse x / inverse x) \\<longlongrightarrow> 1) at_top", "by (subst tendsto_cong[of _ \"\\<lambda>_. 1\"]) simp_all"], ["proof (state)\nthis:\n  ((\\<lambda>x. inverse x / inverse x) \\<longlongrightarrow> 1) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. inverse x \\<noteq> 0", "qed simp_all"], ["", "lemma tendsto_ln_powr_over_ln_powr:\n  assumes \"(a::real) > 0\" \"c > 0\"\n  shows   \"((\\<lambda>x. ln (a*x) powr d / ln (c*x) powr d) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         ln (a * x) powr d / ln (c * x) powr d) \\<longlongrightarrow>\n     1)\n     at_top", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         ln (a * x) powr d / ln (c * x) powr d) \\<longlongrightarrow>\n     1)\n     at_top", "have \"eventually (\\<lambda>x. ln (a*x) powr d / ln (c*x) powr d = (ln (a*x) / ln (c*x)) powr d) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ln (a * x) powr d / ln (c * x) powr d =\n       (ln (a * x) / ln (c * x)) powr d", "using assms eventually_gt_at_top[of \"max (inverse a) (inverse c)\"]"], ["proof (prove)\nusing this:\n  0 < a\n  0 < c\n  eventually ((<) (max (inverse a) (inverse c))) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ln (a * x) powr d / ln (c * x) powr d =\n       (ln (a * x) / ln (c * x)) powr d", "by (auto elim!: eventually_mono simp: powr_divide field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     ln (a * x) powr d / ln (c * x) powr d =\n     (ln (a * x) / ln (c * x)) powr d\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         ln (a * x) powr d / ln (c * x) powr d) \\<longlongrightarrow>\n     1)\n     at_top", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     ln (a * x) powr d / ln (c * x) powr d =\n     (ln (a * x) / ln (c * x)) powr d\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         ln (a * x) powr d / ln (c * x) powr d) \\<longlongrightarrow>\n     1)\n     at_top", "have \"((\\<lambda>x. (ln (a*x) / ln (c*x)) powr d) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (ln (a * x) / ln (c * x)) powr d) \\<longlongrightarrow> 1)\n     at_top", "using assms"], ["proof (prove)\nusing this:\n  0 < a\n  0 < c\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (ln (a * x) / ln (c * x)) powr d) \\<longlongrightarrow> 1)\n     at_top", "by (intro tendsto_eq_rhs[OF tendsto_powr[OF tendsto_ln_over_ln tendsto_const]]) simp_all"], ["proof (state)\nthis:\n  ((\\<lambda>x. (ln (a * x) / ln (c * x)) powr d) \\<longlongrightarrow> 1)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         ln (a * x) powr d / ln (c * x) powr d) \\<longlongrightarrow>\n     1)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top.\n     ln (a * x) powr d / ln (c * x) powr d =\n     (ln (a * x) / ln (c * x)) powr d\n  ((\\<lambda>x. (ln (a * x) / ln (c * x)) powr d) \\<longlongrightarrow> 1)\n   at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top.\n     ln (a * x) powr d / ln (c * x) powr d =\n     (ln (a * x) / ln (c * x)) powr d\n  ((\\<lambda>x. (ln (a * x) / ln (c * x)) powr d) \\<longlongrightarrow> 1)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         ln (a * x) powr d / ln (c * x) powr d) \\<longlongrightarrow>\n     1)\n     at_top", "by (subst tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>x. ln (a * x) powr d / ln (c * x) powr d) \\<longlongrightarrow>\n   1)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_ln_powr_over_ln_powr': \n  \"c > 0 \\<Longrightarrow> ((\\<lambda>x::real. ln x powr d / ln (c*x) powr d) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    ((\\<lambda>x. ln x powr d / ln (c * x) powr d) \\<longlongrightarrow> 1)\n     at_top", "using tendsto_ln_powr_over_ln_powr[of 1 c d]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 1; 0 < c\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         ln (1 * x) powr d /\n                         ln (c * x) powr d) \\<longlongrightarrow>\n                     1)\n                     at_top\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    ((\\<lambda>x. ln x powr d / ln (c * x) powr d) \\<longlongrightarrow> 1)\n     at_top", "by simp"], ["", "lemma tendsto_ln_powr_over_ln_powr'': \n  \"a > 0 \\<Longrightarrow> ((\\<lambda>x::real. ln (a*x) powr d / ln x powr d) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    ((\\<lambda>x. ln (a * x) powr d / ln x powr d) \\<longlongrightarrow> 1)\n     at_top", "using tendsto_ln_powr_over_ln_powr[of _ 1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?a; 0 < 1\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         ln (?a * x) powr ?d /\n                         ln (1 * x) powr ?d) \\<longlongrightarrow>\n                     1)\n                     at_top\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    ((\\<lambda>x. ln (a * x) powr d / ln x powr d) \\<longlongrightarrow> 1)\n     at_top", "by simp"], ["", "lemma bigtheta_const_ln_powr [simp]: \"a > 0 \\<Longrightarrow> (\\<lambda>x::real. ln (a*x) powr d) \\<in> \\<Theta>(\\<lambda>x. ln x powr d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) powr d) \\<in> \\<Theta>(\\<lambda>x. ln x powr d)", "by (intro bigthetaI_tendsto[of 1] tendsto_ln_powr_over_ln_powr'') simp"], ["", "lemma bigtheta_const_ln_pow [simp]: \"a > 0 \\<Longrightarrow> (\\<lambda>x::real. ln (a*x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "assume a: \"a > 0\""], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "have \"\\<forall>\\<^sub>F x in at_top. ln (a * x) ^ d = ln (a * x) powr real d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln (a * x) ^ d = ln (a * x) powr real d", "using eventually_gt_at_top[of \"1/a\"]"], ["proof (prove)\nusing this:\n  eventually ((<) (1 / a)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln (a * x) ^ d = ln (a * x) powr real d", "by eventually_elim (insert a, subst powr_realpow, auto simp: field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. ln (a * x) ^ d = ln (a * x) powr real d\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "hence \"(\\<lambda>x::real. ln (a*x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln (a*x) powr real d)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. ln (a * x) ^ d = ln (a * x) powr real d\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ln (a * x) ^ d)\n    \\<in> \\<Theta>(\\<lambda>x. ln (a * x) powr real d)", "by (rule bigthetaI_cong)"], ["proof (state)\nthis:\n  (\\<lambda>x. ln (a * x) ^ d)\n  \\<in> \\<Theta>(\\<lambda>x. ln (a * x) powr real d)\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. ln (a * x) ^ d)\n  \\<in> \\<Theta>(\\<lambda>x. ln (a * x) powr real d)\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "from a"], ["proof (chain)\npicking this:\n  0 < a", "have \"(\\<lambda>x. ln (a*x) powr real d) \\<in> \\<Theta>(\\<lambda>x. ln x powr real d)\""], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ln (a * x) powr real d)\n    \\<in> \\<Theta>(\\<lambda>x. ln x powr real d)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x. ln (a * x) powr real d)\n  \\<in> \\<Theta>(\\<lambda>x. ln x powr real d)\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. ln (a * x) powr real d)\n  \\<in> \\<Theta>(\\<lambda>x. ln x powr real d)\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "have \"\\<forall>\\<^sub>F x in at_top. ln x powr real d = ln x ^ d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln x powr real d = ln x ^ d", "using eventually_gt_at_top[of 1]"], ["proof (prove)\nusing this:\n  eventually ((<) (1::?'a1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln x powr real d = ln x ^ d", "by eventually_elim (subst powr_realpow, auto simp: field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. ln x powr real d = ln x ^ d\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "hence \"(\\<lambda>x. ln x powr real d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. ln x powr real d = ln x ^ d\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ln x powr real d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "by (rule bigthetaI_cong)"], ["proof (state)\nthis:\n  (\\<lambda>x. ln x powr real d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)", "."], ["proof (state)\nthis:\n  (\\<lambda>x. ln (a * x) ^ d) \\<in> \\<Theta>(\\<lambda>x. ln x ^ d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bigtheta_const_ln [simp]: \"a > 0 \\<Longrightarrow> (\\<lambda>x::real. ln (a*x)) \\<in> \\<Theta>(\\<lambda>x. ln x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> (\\<lambda>x. ln (a * x)) \\<in> \\<Theta>(ln)", "using tendsto_ln_over_ln[of a 1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < a; 0 < 1\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         ln (a * x) / ln (1 * x)) \\<longlongrightarrow>\n                     1)\n                     at_top\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> (\\<lambda>x. ln (a * x)) \\<in> \\<Theta>(ln)", "by (intro bigthetaI_tendsto[of 1]) simp_all"], ["", "text \\<open>\n  If there are two functions @{term \"f\"} and @{term \"g\"} where any power of @{term \"g\"} is\n  asymptotically smaller than @{term \"f\"}, propositions like @{term \"(\\<lambda>x. f x ^ p1 * g x ^ q1) \\<in>\n  O(\\<lambda>x. f x ^ p2 * g x ^ q2)\"} can be decided just by looking at the exponents:\n  the proposition is true iff @{term \"p1 < p2\"} or @{term \"p1 = p2 \\<and> q1 \\<le> q2\"}.\n\n  The functions @{term \"\\<lambda>x. x\"}, @{term \"\\<lambda>x. ln x\"}, @{term \"\\<lambda>x. ln (ln x)\"}, $\\ldots$\n  form a chain in which every function dominates all succeeding functions in the above sense,\n  allowing to decide propositions involving Landau symbols and functions that are products of\n  powers of functions from this chain by reducing the proposition to a statement involving only\n  logical connectives and comparisons on the exponents.\n\n  We will now give the mathematical background for this and implement reification to bring\n  functions from this class into a canonical form, allowing the decision procedure to be\n  implemented in a simproc.\n\\<close>"], ["", "subsection \\<open>Decision procedure\\<close>"], ["", "definition \"powr_closure f \\<equiv> {\\<lambda>x. f x powr p :: real |p. True}\""], ["", "lemma powr_closureI [simp]: \"(\\<lambda>x. f x powr p) \\<in> powr_closure f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr p) \\<in> powr_closure f", "unfolding powr_closure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr p) \\<in> {\\<lambda>x. f x powr p |p. True}", "by force"], ["", "lemma powr_closureE:\n  assumes \"g \\<in> powr_closure f\"\n  obtains p where \"g = (\\<lambda>x. f x powr p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        g = (\\<lambda>x. f x powr p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  g \\<in> powr_closure f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        g = (\\<lambda>x. f x powr p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding powr_closure_def"], ["proof (prove)\nusing this:\n  g \\<in> {\\<lambda>x. f x powr p |p. True}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        g = (\\<lambda>x. f x powr p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["", "locale landau_function_family =\n  fixes F :: \"'a filter\" and H :: \"('a \\<Rightarrow> real) set\"\n  assumes F_nontrivial: \"F \\<noteq> bot\"\n  assumes pos: \"h \\<in> H \\<Longrightarrow> eventually (\\<lambda>x. h x > 0) F\"\n  assumes linear: \"h1 \\<in> H \\<Longrightarrow> h2 \\<in> H \\<Longrightarrow> h1 \\<in> o[F](h2) \\<or> h2 \\<in> o[F](h1) \\<or> h1 \\<in> \\<Theta>[F](h2)\"\n  assumes mult: \"h1 \\<in> H \\<Longrightarrow> h2 \\<in> H \\<Longrightarrow> (\\<lambda>x. h1 x * h2 x) \\<in> H\"\n  assumes inverse: \"h \\<in> H \\<Longrightarrow> (\\<lambda>x. inverse (h x)) \\<in> H\"\nbegin"], ["", "lemma div: \"h1 \\<in> H \\<Longrightarrow> h2 \\<in> H \\<Longrightarrow> (\\<lambda>x. h1 x / h2 x) \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h1 \\<in> H; h2 \\<in> H\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. h1 x / h2 x) \\<in> H", "by (subst divide_inverse) (intro mult inverse)"], ["", "lemma nonzero: \"h \\<in> H \\<Longrightarrow> eventually (\\<lambda>x. h x \\<noteq> 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> H \\<Longrightarrow> \\<forall>\\<^sub>F x in F. h x \\<noteq> 0", "by (drule pos) (auto elim: eventually_mono)"], ["", "lemma landau_cases:\n  assumes \"h1 \\<in> H\" \"h2 \\<in> H\"\n  obtains \"h1 \\<in> o[F](h2)\" | \"h2 \\<in> o[F](h1)\" | \"h1 \\<in> \\<Theta>[F](h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h1 \\<in> o[F](h2) \\<Longrightarrow> thesis;\n     h2 \\<in> o[F](h1) \\<Longrightarrow> thesis;\n     h1 \\<in> \\<Theta>[F](h2) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using linear[OF assms]"], ["proof (prove)\nusing this:\n  h1 \\<in> o[F](h2) \\<or> h2 \\<in> o[F](h1) \\<or> h1 \\<in> \\<Theta>[F](h2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h1 \\<in> o[F](h2) \\<Longrightarrow> thesis;\n     h2 \\<in> o[F](h1) \\<Longrightarrow> thesis;\n     h1 \\<in> \\<Theta>[F](h2) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["", "lemma small_big_antisym:\n  assumes \"h1 \\<in> H\" \"h2 \\<in> H\" \"h1 \\<in> o[F](h2)\" \"h2 \\<in> O[F](h1)\" shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from nonzero[OF assms(1)] nonzero[OF assms(2)] landau_o.small_big_asymmetric[OF assms(3,4)]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. h1 x \\<noteq> 0\n  \\<forall>\\<^sub>F x in F. h2 x \\<noteq> 0\n  \\<forall>\\<^sub>F x in F. h1 x = 0", "have \"eventually (\\<lambda>_::'a. False) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. h1 x \\<noteq> 0\n  \\<forall>\\<^sub>F x in F. h2 x \\<noteq> 0\n  \\<forall>\\<^sub>F x in F. h1 x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F _ in F. False", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F _ in F. False\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F _ in F. False\n\ngoal (1 subgoal):\n 1. False", "by (simp add: eventually_False F_nontrivial)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma small_antisym:\n  assumes \"h1 \\<in> H\" \"h2 \\<in> H\" \"h1 \\<in> o[F](h2)\" \"h2 \\<in> o[F](h1)\" shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  h1 \\<in> H\n  h2 \\<in> H\n  h1 \\<in> o[F](h2)\n  h2 \\<in> o[F](h1)\n\ngoal (1 subgoal):\n 1. False", "by (blast intro: small_big_antisym landau_o.small_imp_big)"], ["", "end"], ["", "locale landau_function_family_pair =\n  G: landau_function_family F G + H: landau_function_family F H for F G H +\n  fixes g\n  assumes gs_dominate: \"g1 \\<in> G \\<Longrightarrow> g2 \\<in> G \\<Longrightarrow> h1 \\<in> H \\<Longrightarrow> h2 \\<in> H \\<Longrightarrow> g1 \\<in> o[F](g2) \\<Longrightarrow>\n     (\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)\"\n  assumes g: \"g \\<in> G\"\n  assumes g_dominates: \"h \\<in> H \\<Longrightarrow> h \\<in> o[F](g)\"\nbegin"], ["", "sublocale GH: landau_function_family F \"G * H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family F (G * H)", "proof (unfold_locales; (elim set_times_elim; hypsubst)?)"], ["proof (state)\ngoal (5 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in F. 0 < (a * b) x\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 4. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 5. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "fix g h"], ["proof (state)\ngoal (5 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in F. 0 < (a * b) x\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 4. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 5. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "assume \"g \\<in> G\" \"h \\<in> H\""], ["proof (state)\nthis:\n  g \\<in> G\n  h \\<in> H\n\ngoal (5 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in F. 0 < (a * b) x\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 4. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 5. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "from G.pos[OF this(1)] H.pos[OF this(2)]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. 0 < g x\n  \\<forall>\\<^sub>F x in F. 0 < h x", "show \"eventually (\\<lambda>x. (g*h) x > 0) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < g x\n  \\<forall>\\<^sub>F x in F. 0 < h x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < (g * h) x", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 < (g * h) x\n\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 4. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 4. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "fix g h"], ["proof (state)\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 4. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "assume A: \"g \\<in> G\" \"h \\<in> H\""], ["proof (state)\nthis:\n  g \\<in> G\n  h \\<in> H\n\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 4. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "have \"(\\<lambda>x. inverse ((g * h) x)) = (\\<lambda>x. inverse (g x)) * (\\<lambda>x. inverse (h x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse ((g * h) x)) =\n    (\\<lambda>x. inverse (g x)) * (\\<lambda>x. inverse (h x))", "by (rule ext) simp"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse ((g * h) x)) =\n  (\\<lambda>x. inverse (g x)) * (\\<lambda>x. inverse (h x))\n\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 4. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse ((g * h) x)) =\n  (\\<lambda>x. inverse (g x)) * (\\<lambda>x. inverse (h x))\n\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 4. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "from A"], ["proof (chain)\npicking this:\n  g \\<in> G\n  h \\<in> H", "have \"... \\<in> G * H\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  h \\<in> H\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (g x)) * (\\<lambda>x. inverse (h x)) \\<in> G * H", "by (intro G.inverse H.inverse set_times_intro)"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (g x)) * (\\<lambda>x. inverse (h x)) \\<in> G * H\n\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H\n 4. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse ((a * b) x)) \\<in> G * H", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. inverse ((g * h) x)) \\<in> G * H", "show \"(\\<lambda>x. inverse ((g * h) x)) \\<in> G * H\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. inverse ((g * h) x)) \\<in> G * H\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse ((g * h) x)) \\<in> G * H", "."], ["proof (state)\nthis:\n  (\\<lambda>x. inverse ((g * h) x)) \\<in> G * H\n\ngoal (3 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H", "fix g1 g2 h1 h2"], ["proof (state)\ngoal (3 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H", "assume A: \"g1 \\<in> G\" \"g2 \\<in> G\" \"h1 \\<in> H\" \"h2 \\<in> H\""], ["proof (state)\nthis:\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n\ngoal (3 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a * b \\<in> o[F](aa * ba) \\<or>\n                         aa * ba \\<in> o[F](a * b) \\<or>\n                         a * b \\<in> \\<Theta>[F](aa * ba)\n 3. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H", "from gs_dominate[OF this] gs_dominate[OF this(2,1,4,3)]\n       G.linear[OF this(1,2)] H.linear[OF this(3,4)]"], ["proof (chain)\npicking this:\n  g1 \\<in> o[F](g2) \\<Longrightarrow>\n  (\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)\n  g2 \\<in> o[F](g1) \\<Longrightarrow>\n  (\\<lambda>x. g2 x * h2 x) \\<in> o[F](\\<lambda>x. g1 x * h1 x)\n  g1 \\<in> o[F](g2) \\<or> g2 \\<in> o[F](g1) \\<or> g1 \\<in> \\<Theta>[F](g2)\n  h1 \\<in> o[F](h2) \\<or> h2 \\<in> o[F](h1) \\<or> h1 \\<in> \\<Theta>[F](h2)", "show \"g1 * h1 \\<in> o[F](g2 * h2) \\<or> g2 * h2 \\<in> o[F](g1 * h1) \\<or> g1 * h1 \\<in> \\<Theta>[F](g2 * h2)\""], ["proof (prove)\nusing this:\n  g1 \\<in> o[F](g2) \\<Longrightarrow>\n  (\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)\n  g2 \\<in> o[F](g1) \\<Longrightarrow>\n  (\\<lambda>x. g2 x * h2 x) \\<in> o[F](\\<lambda>x. g1 x * h1 x)\n  g1 \\<in> o[F](g2) \\<or> g2 \\<in> o[F](g1) \\<or> g1 \\<in> \\<Theta>[F](g2)\n  h1 \\<in> o[F](h2) \\<or> h2 \\<in> o[F](h1) \\<or> h1 \\<in> \\<Theta>[F](h2)\n\ngoal (1 subgoal):\n 1. g1 * h1 \\<in> o[F](g2 * h2) \\<or>\n    g2 * h2 \\<in> o[F](g1 * h1) \\<or> g1 * h1 \\<in> \\<Theta>[F](g2 * h2)", "by (elim disjE) (force simp: func_times bigomega_iff_bigo intro: landau_theta.mult\n         landau_o.small.mult landau_o.small_big_mult landau_o.big_small_mult)+"], ["proof (state)\nthis:\n  g1 * h1 \\<in> o[F](g2 * h2) \\<or>\n  g2 * h2 \\<in> o[F](g1 * h1) \\<or> g1 * h1 \\<in> \\<Theta>[F](g2 * h2)\n\ngoal (2 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H", "have B: \"(\\<lambda>x. (g1 * h1) x * (g2 * h2) x) = (g1 * g2) * (h1 * h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (g1 * h1) x * (g2 * h2) x) = g1 * g2 * (h1 * h2)", "by (rule ext) (simp add: func_times mult_ac)"], ["proof (state)\nthis:\n  (\\<lambda>x. (g1 * h1) x * (g2 * h2) x) = g1 * g2 * (h1 * h2)\n\ngoal (2 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 a b aa ba.\n       \\<lbrakk>a \\<in> G; b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a * b) x * (aa * ba) x) \\<in> G * H", "from A"], ["proof (chain)\npicking this:\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H", "show \"(\\<lambda>x. (g1 * h1) x * (g2 * h2) x) \\<in> G * H\""], ["proof (prove)\nusing this:\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (g1 * h1) x * (g2 * h2) x) \\<in> G * H", "by (subst B, intro set_times_intro) (auto intro: G.mult H.mult simp: func_times)"], ["proof (state)\nthis:\n  (\\<lambda>x. (g1 * h1) x * (g2 * h2) x) \\<in> G * H\n\ngoal (1 subgoal):\n 1. F \\<noteq> bot", "qed (fact G.F_nontrivial)"], ["", "lemma smallo_iff:\n  assumes \"g1 \\<in> G\" \"g2 \\<in> G\" \"h1 \\<in> H\" \"h2 \\<in> H\"\n  shows \"(\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x) \\<longleftrightarrow>\n             g1 \\<in> o[F](g2) \\<or> (g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\" (is \"?P \\<longleftrightarrow> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "proof (rule G.landau_cases[OF assms(1,2)])"], ["proof (state)\ngoal (3 subgoals):\n 1. g1 \\<in> o[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 2. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 3. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "assume \"g1 \\<in> o[F](g2)\""], ["proof (state)\nthis:\n  g1 \\<in> o[F](g2)\n\ngoal (3 subgoals):\n 1. g1 \\<in> o[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 2. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 3. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  g1 \\<in> o[F](g2)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "by (auto intro!: gs_dominate assms)"], ["proof (state)\nthis:\n  ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n  (g1 \\<in> o[F](g2) \\<or>\n   g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "assume A: \"g1 \\<in> \\<Theta>[F](g2)\""], ["proof (state)\nthis:\n  g1 \\<in> \\<Theta>[F](g2)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "hence B: \"g2 \\<in> O[F](g1)\""], ["proof (prove)\nusing this:\n  g1 \\<in> \\<Theta>[F](g2)\n\ngoal (1 subgoal):\n 1. g2 \\<in> O[F](g1)", "by (subst (asm) bigtheta_sym) (rule bigthetaD1)"], ["proof (state)\nthis:\n  g2 \\<in> O[F](g1)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "hence \"g1 \\<notin> o[F](g2)\""], ["proof (prove)\nusing this:\n  g2 \\<in> O[F](g1)\n\ngoal (1 subgoal):\n 1. g1 \\<notin> o[F](g2)", "using assms"], ["proof (prove)\nusing this:\n  g2 \\<in> O[F](g1)\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n\ngoal (1 subgoal):\n 1. g1 \\<notin> o[F](g2)", "by (auto dest: G.small_big_antisym)"], ["proof (state)\nthis:\n  g1 \\<notin> o[F](g2)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "moreover"], ["proof (state)\nthis:\n  g1 \\<notin> o[F](g2)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "from A"], ["proof (chain)\npicking this:\n  g1 \\<in> \\<Theta>[F](g2)", "have \"o[F](\\<lambda>x. g2 x * h2 x) = o[F](\\<lambda>x. g1 x * h2 x)\""], ["proof (prove)\nusing this:\n  g1 \\<in> \\<Theta>[F](g2)\n\ngoal (1 subgoal):\n 1. o[F](\\<lambda>x. g2 x * h2 x) = o[F](\\<lambda>x. g1 x * h2 x)", "by (intro landau_o.small.cong_bigtheta landau_theta.mult_right, subst bigtheta_sym)"], ["proof (state)\nthis:\n  o[F](\\<lambda>x. g2 x * h2 x) = o[F](\\<lambda>x. g1 x * h2 x)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "ultimately"], ["proof (chain)\npicking this:\n  g1 \\<notin> o[F](g2)\n  o[F](\\<lambda>x. g2 x * h2 x) = o[F](\\<lambda>x. g1 x * h2 x)", "show ?thesis"], ["proof (prove)\nusing this:\n  g1 \\<notin> o[F](g2)\n  o[F](\\<lambda>x. g2 x * h2 x) = o[F](\\<lambda>x. g1 x * h2 x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "using G.nonzero[OF assms(1)] A"], ["proof (prove)\nusing this:\n  g1 \\<notin> o[F](g2)\n  o[F](\\<lambda>x. g2 x * h2 x) = o[F](\\<lambda>x. g1 x * h2 x)\n  \\<forall>\\<^sub>F x in F. g1 x \\<noteq> 0\n  g1 \\<in> \\<Theta>[F](g2)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "by (auto simp add: landau_o.small.mult_cancel_left)"], ["proof (state)\nthis:\n  ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n  (g1 \\<in> o[F](g2) \\<or>\n   g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n\ngoal (1 subgoal):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "assume A: \"g2 \\<in> o[F](g1)\""], ["proof (state)\nthis:\n  g2 \\<in> o[F](g1)\n\ngoal (1 subgoal):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "from gs_dominate[OF assms(2,1,4,3) this]"], ["proof (chain)\npicking this:\n  (\\<lambda>x. g2 x * h2 x) \\<in> o[F](\\<lambda>x. g1 x * h1 x)", "have B: \"g2 * h2 \\<in> o[F](g1 * h1)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. g2 x * h2 x) \\<in> o[F](\\<lambda>x. g1 x * h1 x)\n\ngoal (1 subgoal):\n 1. g2 * h2 \\<in> o[F](g1 * h1)", "by (simp add: func_times)"], ["proof (state)\nthis:\n  g2 * h2 \\<in> o[F](g1 * h1)\n\ngoal (1 subgoal):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "have \"g1 \\<notin> o[F](g2)\" \"g1 \\<notin> \\<Theta>[F](g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g1 \\<notin> o[F](g2) &&& g1 \\<notin> \\<Theta>[F](g2)", "using assms A"], ["proof (prove)\nusing this:\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  g2 \\<in> o[F](g1)\n\ngoal (1 subgoal):\n 1. g1 \\<notin> o[F](g2) &&& g1 \\<notin> \\<Theta>[F](g2)", "by (auto dest: G.small_antisym G.small_big_antisym simp: bigomega_iff_bigo)"], ["proof (state)\nthis:\n  g1 \\<notin> o[F](g2)\n  g1 \\<notin> \\<Theta>[F](g2)\n\ngoal (1 subgoal):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "moreover"], ["proof (state)\nthis:\n  g1 \\<notin> o[F](g2)\n  g1 \\<notin> \\<Theta>[F](g2)\n\ngoal (1 subgoal):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "have \"\\<not>?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. g1 x * h1 x) \\<notin> o[F](\\<lambda>x. g2 x * h2 x)", "by (intro notI GH.small_antisym[OF _ _ B] set_times_intro) (simp_all add: func_times assms)"], ["proof (state)\nthis:\n  (\\<lambda>x. g1 x * h1 x) \\<notin> o[F](\\<lambda>x. g2 x * h2 x)\n\ngoal (1 subgoal):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "ultimately"], ["proof (chain)\npicking this:\n  g1 \\<notin> o[F](g2)\n  g1 \\<notin> \\<Theta>[F](g2)\n  (\\<lambda>x. g1 x * h1 x) \\<notin> o[F](\\<lambda>x. g2 x * h2 x)", "show ?thesis"], ["proof (prove)\nusing this:\n  g1 \\<notin> o[F](g2)\n  g1 \\<notin> \\<Theta>[F](g2)\n  (\\<lambda>x. g1 x * h1 x) \\<notin> o[F](\\<lambda>x. g2 x * h2 x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>x. g1 x * h1 x) \\<in> o[F](\\<lambda>x. g2 x * h2 x)) =\n  (g1 \\<in> o[F](g2) \\<or>\n   g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> o[F](h2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bigo_iff:\n  assumes \"g1 \\<in> G\" \"g2 \\<in> G\" \"h1 \\<in> H\" \"h2 \\<in> H\"\n  shows \"(\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x) \\<longleftrightarrow>\n             g1 \\<in> o[F](g2) \\<or> (g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\" (is \"?P \\<longleftrightarrow> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "proof (rule G.landau_cases[OF assms(1,2)])"], ["proof (state)\ngoal (3 subgoals):\n 1. g1 \\<in> o[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 2. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 3. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "assume \"g1 \\<in> o[F](g2)\""], ["proof (state)\nthis:\n  g1 \\<in> o[F](g2)\n\ngoal (3 subgoals):\n 1. g1 \\<in> o[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 2. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 3. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  g1 \\<in> o[F](g2)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "by (auto intro!: gs_dominate assms landau_o.small_imp_big)"], ["proof (state)\nthis:\n  ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n  (g1 \\<in> o[F](g2) \\<or>\n   g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "assume A: \"g2 \\<in> o[F](g1)\""], ["proof (state)\nthis:\n  g2 \\<in> o[F](g1)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "hence \"g1 \\<notin> O[F](g2)\""], ["proof (prove)\nusing this:\n  g2 \\<in> o[F](g1)\n\ngoal (1 subgoal):\n 1. g1 \\<notin> O[F](g2)", "using assms"], ["proof (prove)\nusing this:\n  g2 \\<in> o[F](g1)\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n\ngoal (1 subgoal):\n 1. g1 \\<notin> O[F](g2)", "by (auto dest: G.small_big_antisym)"], ["proof (state)\nthis:\n  g1 \\<notin> O[F](g2)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "moreover"], ["proof (state)\nthis:\n  g1 \\<notin> O[F](g2)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "from gs_dominate[OF assms(2,1,4,3) A]"], ["proof (chain)\npicking this:\n  (\\<lambda>x. g2 x * h2 x) \\<in> o[F](\\<lambda>x. g1 x * h1 x)", "have \"g2*h2 \\<in> o[F](g1*h1)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. g2 x * h2 x) \\<in> o[F](\\<lambda>x. g1 x * h1 x)\n\ngoal (1 subgoal):\n 1. g2 * h2 \\<in> o[F](g1 * h1)", "by (simp add: func_times)"], ["proof (state)\nthis:\n  g2 * h2 \\<in> o[F](g1 * h1)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "hence \"g1*h1 \\<notin> O[F](g2*h2)\""], ["proof (prove)\nusing this:\n  g2 * h2 \\<in> o[F](g1 * h1)\n\ngoal (1 subgoal):\n 1. g1 * h1 \\<notin> O[F](g2 * h2)", "by (blast intro: GH.small_big_antisym assms)"], ["proof (state)\nthis:\n  g1 * h1 \\<notin> O[F](g2 * h2)\n\ngoal (2 subgoals):\n 1. g2 \\<in> o[F](g1) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n 2. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "ultimately"], ["proof (chain)\npicking this:\n  g1 \\<notin> O[F](g2)\n  g1 * h1 \\<notin> O[F](g2 * h2)", "show ?thesis"], ["proof (prove)\nusing this:\n  g1 \\<notin> O[F](g2)\n  g1 * h1 \\<notin> O[F](g2 * h2)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "using A assms"], ["proof (prove)\nusing this:\n  g1 \\<notin> O[F](g2)\n  g1 * h1 \\<notin> O[F](g2 * h2)\n  g2 \\<in> o[F](g1)\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "by (auto simp: func_times dest: landau_o.small_imp_big)"], ["proof (state)\nthis:\n  ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n  (g1 \\<in> o[F](g2) \\<or>\n   g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n\ngoal (1 subgoal):\n 1. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "assume A: \"g1 \\<in> \\<Theta>[F](g2)\""], ["proof (state)\nthis:\n  g1 \\<in> \\<Theta>[F](g2)\n\ngoal (1 subgoal):\n 1. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "hence \"g1 \\<notin> o[F](g2)\""], ["proof (prove)\nusing this:\n  g1 \\<in> \\<Theta>[F](g2)\n\ngoal (1 subgoal):\n 1. g1 \\<notin> o[F](g2)", "unfolding bigtheta_def"], ["proof (prove)\nusing this:\n  g1 \\<in> O[F](g2) \\<inter> \\<Omega>[F](g2)\n\ngoal (1 subgoal):\n 1. g1 \\<notin> o[F](g2)", "using assms"], ["proof (prove)\nusing this:\n  g1 \\<in> O[F](g2) \\<inter> \\<Omega>[F](g2)\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n\ngoal (1 subgoal):\n 1. g1 \\<notin> o[F](g2)", "by (auto dest: G.small_big_antisym simp: bigomega_iff_bigo)"], ["proof (state)\nthis:\n  g1 \\<notin> o[F](g2)\n\ngoal (1 subgoal):\n 1. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "moreover"], ["proof (state)\nthis:\n  g1 \\<notin> o[F](g2)\n\ngoal (1 subgoal):\n 1. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "have \"O[F](\\<lambda>x. g2 x * h2 x) = O[F](\\<lambda>x. g1 x * h2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. O[F](\\<lambda>x. g2 x * h2 x) = O[F](\\<lambda>x. g1 x * h2 x)", "by (subst landau_o.big.cong_bigtheta[OF landau_theta.mult_right[OF A]]) (rule refl)"], ["proof (state)\nthis:\n  O[F](\\<lambda>x. g2 x * h2 x) = O[F](\\<lambda>x. g1 x * h2 x)\n\ngoal (1 subgoal):\n 1. g1 \\<in> \\<Theta>[F](g2) \\<Longrightarrow>\n    ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "ultimately"], ["proof (chain)\npicking this:\n  g1 \\<notin> o[F](g2)\n  O[F](\\<lambda>x. g2 x * h2 x) = O[F](\\<lambda>x. g1 x * h2 x)", "show ?thesis"], ["proof (prove)\nusing this:\n  g1 \\<notin> o[F](g2)\n  O[F](\\<lambda>x. g2 x * h2 x) = O[F](\\<lambda>x. g1 x * h2 x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "using A G.nonzero[OF assms(2)]"], ["proof (prove)\nusing this:\n  g1 \\<notin> o[F](g2)\n  O[F](\\<lambda>x. g2 x * h2 x) = O[F](\\<lambda>x. g1 x * h2 x)\n  g1 \\<in> \\<Theta>[F](g2)\n  \\<forall>\\<^sub>F x in F. g2 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n    (g1 \\<in> o[F](g2) \\<or>\n     g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))", "by (auto simp: landau_o.big.mult_cancel_left eventually_nonzero_bigtheta)"], ["proof (state)\nthis:\n  ((\\<lambda>x. g1 x * h1 x) \\<in> O[F](\\<lambda>x. g2 x * h2 x)) =\n  (g1 \\<in> o[F](g2) \\<or>\n   g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> O[F](h2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bigtheta_iff:\n  \"g1 \\<in> G \\<Longrightarrow> g2 \\<in> G \\<Longrightarrow> h1 \\<in> H \\<Longrightarrow> h2 \\<in> H \\<Longrightarrow>\n    (\\<lambda>x. g1 x * h1 x) \\<in> \\<Theta>[F](\\<lambda>x. g2 x * h2 x) \\<longleftrightarrow> g1 \\<in> \\<Theta>[F](g2) \\<and> h1 \\<in> \\<Theta>[F](h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g1 \\<in> G; g2 \\<in> G; h1 \\<in> H; h2 \\<in> H\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. g1 x * h1 x)\n                       \\<in> \\<Theta>[F](\\<lambda>x. g2 x * h2 x)) =\n                      (g1 \\<in> \\<Theta>[F](g2) \\<and>\n                       h1 \\<in> \\<Theta>[F](h2))", "by (auto simp: bigtheta_def bigo_iff bigomega_iff_bigo intro: landau_o.small_imp_big\n           dest: G.small_antisym G.small_big_antisym)"], ["", "end"], ["", "lemma landau_function_family_powr_closure:\n  assumes \"F \\<noteq> bot\" \"filterlim f at_top F\"\n  shows   \"landau_function_family F (powr_closure f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family F (powr_closure f)", "proof (unfold_locales; (elim powr_closureE; hypsubst)?)"], ["proof (state)\ngoal (5 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h p. \\<forall>\\<^sub>F x in F. 0 < f x powr p\n 3. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr pa) \\<or>\n       (\\<lambda>x. f x powr pa) \\<in> o[F](\\<lambda>x. f x powr p) \\<or>\n       (\\<lambda>x. f x powr p) \\<in> \\<Theta>[F](\\<lambda>x. f x powr pa)\n 4. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p * f x powr pa) \\<in> powr_closure f\n 5. \\<And>h p. (\\<lambda>x. inverse (f x powr p)) \\<in> powr_closure f", "from assms"], ["proof (chain)\npicking this:\n  F \\<noteq> bot\n  filterlim f at_top F", "have \"eventually (\\<lambda>x. f x \\<ge> 1) F\""], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 1 \\<le> f x", "using filterlim_at_top"], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  filterlim f at_top F\n  filterlim ?f at_top ?F =\n  (\\<forall>Z. \\<forall>\\<^sub>F x in ?F. Z \\<le> ?f x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 1 \\<le> f x", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (5 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h p. \\<forall>\\<^sub>F x in F. 0 < f x powr p\n 3. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr pa) \\<or>\n       (\\<lambda>x. f x powr pa) \\<in> o[F](\\<lambda>x. f x powr p) \\<or>\n       (\\<lambda>x. f x powr p) \\<in> \\<Theta>[F](\\<lambda>x. f x powr pa)\n 4. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p * f x powr pa) \\<in> powr_closure f\n 5. \\<And>h p. (\\<lambda>x. inverse (f x powr p)) \\<in> powr_closure f", "hence A: \"eventually (\\<lambda>x. f x \\<noteq> 0) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x \\<noteq> 0", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. f x \\<noteq> 0\n\ngoal (5 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h p. \\<forall>\\<^sub>F x in F. 0 < f x powr p\n 3. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr pa) \\<or>\n       (\\<lambda>x. f x powr pa) \\<in> o[F](\\<lambda>x. f x powr p) \\<or>\n       (\\<lambda>x. f x powr p) \\<in> \\<Theta>[F](\\<lambda>x. f x powr pa)\n 4. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p * f x powr pa) \\<in> powr_closure f\n 5. \\<And>h p. (\\<lambda>x. inverse (f x powr p)) \\<in> powr_closure f", "{"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. f x \\<noteq> 0\n\ngoal (5 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h p. \\<forall>\\<^sub>F x in F. 0 < f x powr p\n 3. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr pa) \\<or>\n       (\\<lambda>x. f x powr pa) \\<in> o[F](\\<lambda>x. f x powr p) \\<or>\n       (\\<lambda>x. f x powr p) \\<in> \\<Theta>[F](\\<lambda>x. f x powr pa)\n 4. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p * f x powr pa) \\<in> powr_closure f\n 5. \\<And>h p. (\\<lambda>x. inverse (f x powr p)) \\<in> powr_closure f", "fix p q :: real"], ["proof (state)\ngoal (5 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h p. \\<forall>\\<^sub>F x in F. 0 < f x powr p\n 3. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr pa) \\<or>\n       (\\<lambda>x. f x powr pa) \\<in> o[F](\\<lambda>x. f x powr p) \\<or>\n       (\\<lambda>x. f x powr p) \\<in> \\<Theta>[F](\\<lambda>x. f x powr pa)\n 4. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p * f x powr pa) \\<in> powr_closure f\n 5. \\<And>h p. (\\<lambda>x. inverse (f x powr p)) \\<in> powr_closure f", "show \"(\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr q) \\<or>\n          (\\<lambda>x. f x powr q) \\<in> o[F](\\<lambda>x. f x powr p) \\<or>\n          (\\<lambda>x. f x powr p) \\<in> \\<Theta>[F](\\<lambda>x. f x powr q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr q) \\<or>\n    (\\<lambda>x. f x powr q) \\<in> o[F](\\<lambda>x. f x powr p) \\<or>\n    (\\<lambda>x. f x powr p) \\<in> \\<Theta>[F](\\<lambda>x. f x powr q)", "by (cases p q rule: linorder_cases)\n       (force intro!: smalloI_tendsto tendsto_neg_powr simp: powr_diff [symmetric]  assms A)+"], ["proof (state)\nthis:\n  (\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr q) \\<or>\n  (\\<lambda>x. f x powr q) \\<in> o[F](\\<lambda>x. f x powr p) \\<or>\n  (\\<lambda>x. f x powr p) \\<in> \\<Theta>[F](\\<lambda>x. f x powr q)\n\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h p. \\<forall>\\<^sub>F x in F. 0 < f x powr p\n 3. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p * f x powr pa) \\<in> powr_closure f\n 4. \\<And>h p. (\\<lambda>x. inverse (f x powr p)) \\<in> powr_closure f", "}"], ["proof (state)\nthis:\n  (\\<lambda>x. f x powr ?p2) \\<in> o[F](\\<lambda>x. f x powr ?q2) \\<or>\n  (\\<lambda>x. f x powr ?q2) \\<in> o[F](\\<lambda>x. f x powr ?p2) \\<or>\n  (\\<lambda>x. f x powr ?p2) \\<in> \\<Theta>[F](\\<lambda>x. f x powr ?q2)\n\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h p. \\<forall>\\<^sub>F x in F. 0 < f x powr p\n 3. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p * f x powr pa) \\<in> powr_closure f\n 4. \\<And>h p. (\\<lambda>x. inverse (f x powr p)) \\<in> powr_closure f", "fix p"], ["proof (state)\ngoal (4 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h p. \\<forall>\\<^sub>F x in F. 0 < f x powr p\n 3. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p * f x powr pa) \\<in> powr_closure f\n 4. \\<And>h p. (\\<lambda>x. inverse (f x powr p)) \\<in> powr_closure f", "show \"eventually (\\<lambda>x. f x powr p > 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < f x powr p", "using A"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < f x powr p", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 < f x powr p\n\ngoal (3 subgoals):\n 1. F \\<noteq> bot\n 2. \\<And>h1 h2 p pa.\n       (\\<lambda>x. f x powr p * f x powr pa) \\<in> powr_closure f\n 3. \\<And>h p. (\\<lambda>x. inverse (f x powr p)) \\<in> powr_closure f", "qed (auto simp: powr_add[symmetric] powr_minus[symmetric] \\<open>F \\<noteq> bot\\<close> intro: powr_closureI)"], ["", "lemma landau_function_family_pair_trans:\n  assumes \"landau_function_family_pair Ftr F G f\"\n  assumes \"landau_function_family_pair Ftr G H g\"\n  shows   \"landau_function_family_pair Ftr F (G*H) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family_pair Ftr F (G * H) f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. landau_function_family_pair Ftr F (G * H) f", "interpret FG: landau_function_family_pair Ftr F G f"], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family_pair Ftr F G f", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. landau_function_family_pair Ftr F (G * H) f", "interpret GH: landau_function_family_pair Ftr G H g"], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family_pair Ftr G H g", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. landau_function_family_pair Ftr F (G * H) f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family_pair Ftr F (G * H) f", "proof (unfold_locales; (elim set_times_elim)?; (clarify)?;\n         (unfold func_times mult.assoc[symmetric])?)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "fix f1 f2 g1 g2 h1 h2"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "assume A: \"f1 \\<in> F\" \"f2 \\<in> F\" \"g1 \\<in> G\" \"g2 \\<in> G\" \"h1 \\<in> H\" \"h2 \\<in> H\" \"f1 \\<in> o[Ftr](f2)\""], ["proof (state)\nthis:\n  f1 \\<in> F\n  f2 \\<in> F\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  f1 \\<in> o[Ftr](f2)\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "from A"], ["proof (chain)\npicking this:\n  f1 \\<in> F\n  f2 \\<in> F\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  f1 \\<in> o[Ftr](f2)", "have \"(\\<lambda>x. f1 x * g1 x * h1 x) \\<in> o[Ftr](\\<lambda>x. f1 x * g1 x * g x)\""], ["proof (prove)\nusing this:\n  f1 \\<in> F\n  f2 \\<in> F\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  f1 \\<in> o[Ftr](f2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f1 x * g1 x * h1 x)\n    \\<in> o[Ftr](\\<lambda>x. f1 x * g1 x * g x)", "by (intro landau_o.small.mult_left GH.g_dominates)"], ["proof (state)\nthis:\n  (\\<lambda>x. f1 x * g1 x * h1 x)\n  \\<in> o[Ftr](\\<lambda>x. f1 x * g1 x * g x)\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. f1 x * g1 x * h1 x)\n  \\<in> o[Ftr](\\<lambda>x. f1 x * g1 x * g x)\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "have \"(\\<lambda>x. f1 x * g1 x * g x) = (\\<lambda>x. f1 x * (g1 x * g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f1 x * g1 x * g x) = (\\<lambda>x. f1 x * (g1 x * g x))", "by (simp only: mult.assoc)"], ["proof (state)\nthis:\n  (\\<lambda>x. f1 x * g1 x * g x) = (\\<lambda>x. f1 x * (g1 x * g x))\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. f1 x * g1 x * g x) = (\\<lambda>x. f1 x * (g1 x * g x))\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "from A"], ["proof (chain)\npicking this:\n  f1 \\<in> F\n  f2 \\<in> F\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  f1 \\<in> o[Ftr](f2)", "have \"... \\<in> o[Ftr](\\<lambda>x. f2 x * (g2 x / g x))\""], ["proof (prove)\nusing this:\n  f1 \\<in> F\n  f2 \\<in> F\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  f1 \\<in> o[Ftr](f2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f1 x * (g1 x * g x))\n    \\<in> o[Ftr](\\<lambda>x. f2 x * (g2 x / g x))", "by (intro FG.gs_dominate FG.H.mult FG.H.div GH.g)"], ["proof (state)\nthis:\n  (\\<lambda>x. f1 x * (g1 x * g x))\n  \\<in> o[Ftr](\\<lambda>x. f2 x * (g2 x / g x))\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. f1 x * (g1 x * g x))\n  \\<in> o[Ftr](\\<lambda>x. f2 x * (g2 x / g x))\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "from A"], ["proof (chain)\npicking this:\n  f1 \\<in> F\n  f2 \\<in> F\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  f1 \\<in> o[Ftr](f2)", "have \"(\\<lambda>x. inverse (h2 x)) \\<in> o[Ftr](g)\""], ["proof (prove)\nusing this:\n  f1 \\<in> F\n  f2 \\<in> F\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  f1 \\<in> o[Ftr](f2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (h2 x)) \\<in> o[Ftr](g)", "by (intro GH.g_dominates GH.H.inverse)"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (h2 x)) \\<in> o[Ftr](g)\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "with GH.g A"], ["proof (chain)\npicking this:\n  g \\<in> G\n  f1 \\<in> F\n  f2 \\<in> F\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  f1 \\<in> o[Ftr](f2)\n  (\\<lambda>x. inverse (h2 x)) \\<in> o[Ftr](g)", "have \"(\\<lambda>x. f2 x * (g2 x / g x)) \\<in> o[Ftr](\\<lambda>x. f2 x * (g2 x * h2 x))\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  f1 \\<in> F\n  f2 \\<in> F\n  g1 \\<in> G\n  g2 \\<in> G\n  h1 \\<in> H\n  h2 \\<in> H\n  f1 \\<in> o[Ftr](f2)\n  (\\<lambda>x. inverse (h2 x)) \\<in> o[Ftr](g)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f2 x * (g2 x / g x))\n    \\<in> o[Ftr](\\<lambda>x. f2 x * (g2 x * h2 x))", "by (auto simp: FG.H.nonzero GH.H.nonzero divide_inverse\n               intro!: landau_o.small.mult_left intro: landau_o.small.inverse_flip)"], ["proof (state)\nthis:\n  (\\<lambda>x. f2 x * (g2 x / g x))\n  \\<in> o[Ftr](\\<lambda>x. f2 x * (g2 x * h2 x))\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. f2 x * (g2 x / g x))\n  \\<in> o[Ftr](\\<lambda>x. f2 x * (g2 x * h2 x))\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "have \"... = o[Ftr](\\<lambda>x. f2 x * g2 x * h2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. o[Ftr](\\<lambda>x. f2 x * (g2 x * h2 x)) =\n    o[Ftr](\\<lambda>x. f2 x * g2 x * h2 x)", "by (simp only: mult.assoc)"], ["proof (state)\nthis:\n  o[Ftr](\\<lambda>x. f2 x * (g2 x * h2 x)) =\n  o[Ftr](\\<lambda>x. f2 x * g2 x * h2 x)\n\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 a b aa ba.\n       \\<lbrakk>g1 \\<in> F; g2 \\<in> F; g1 \\<in> o[Ftr](g2); a \\<in> G;\n        b \\<in> H; aa \\<in> G; ba \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. g1 x * a x * b x)\n                         \\<in> o[Ftr](\\<lambda>x. g2 x * aa x * ba x)\n 2. f \\<in> F\n 3. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. f1 x * g1 x * h1 x)\n  \\<in> o[Ftr](\\<lambda>x. f2 x * g2 x * h2 x)", "show \"(\\<lambda>x. f1 x * g1 x * h1 x) \\<in> o[Ftr](\\<lambda>x. f2 x * g2 x * h2 x)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. f1 x * g1 x * h1 x)\n  \\<in> o[Ftr](\\<lambda>x. f2 x * g2 x * h2 x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f1 x * g1 x * h1 x)\n    \\<in> o[Ftr](\\<lambda>x. f2 x * g2 x * h2 x)", "."], ["proof (state)\nthis:\n  (\\<lambda>x. f1 x * g1 x * h1 x)\n  \\<in> o[Ftr](\\<lambda>x. f2 x * g2 x * h2 x)\n\ngoal (2 subgoals):\n 1. f \\<in> F\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> F\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "fix g1 h1"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> F\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "assume A: \"g1 \\<in> G\" \"h1 \\<in> H\""], ["proof (state)\nthis:\n  g1 \\<in> G\n  h1 \\<in> H\n\ngoal (2 subgoals):\n 1. f \\<in> F\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "hence \"(\\<lambda>x. g1 x * h1 x) \\<in> o[Ftr](\\<lambda>x. g1 x * g x)\""], ["proof (prove)\nusing this:\n  g1 \\<in> G\n  h1 \\<in> H\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g1 x * h1 x) \\<in> o[Ftr](\\<lambda>x. g1 x * g x)", "by (intro landau_o.small.mult_left GH.g_dominates)"], ["proof (state)\nthis:\n  (\\<lambda>x. g1 x * h1 x) \\<in> o[Ftr](\\<lambda>x. g1 x * g x)\n\ngoal (2 subgoals):\n 1. f \\<in> F\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. g1 x * h1 x) \\<in> o[Ftr](\\<lambda>x. g1 x * g x)\n\ngoal (2 subgoals):\n 1. f \\<in> F\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "from A"], ["proof (chain)\npicking this:\n  g1 \\<in> G\n  h1 \\<in> H", "have \"(\\<lambda>x. g1 x * g x) \\<in> o[Ftr](f)\""], ["proof (prove)\nusing this:\n  g1 \\<in> G\n  h1 \\<in> H\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g1 x * g x) \\<in> o[Ftr](f)", "by (intro FG.g_dominates FG.H.mult GH.g)"], ["proof (state)\nthis:\n  (\\<lambda>x. g1 x * g x) \\<in> o[Ftr](f)\n\ngoal (2 subgoals):\n 1. f \\<in> F\n 2. \\<And>h a b.\n       \\<lbrakk>a \\<in> G; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) \\<in> o[Ftr](f)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. g1 x * h1 x) \\<in> o[Ftr](f)", "show \"(\\<lambda>x. g1 x * h1 x) \\<in> o[Ftr](f)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. g1 x * h1 x) \\<in> o[Ftr](f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g1 x * h1 x) \\<in> o[Ftr](f)", "."], ["proof (state)\nthis:\n  (\\<lambda>x. g1 x * h1 x) \\<in> o[Ftr](f)\n\ngoal (1 subgoal):\n 1. f \\<in> F", "qed (simp_all add: FG.g)"], ["proof (state)\nthis:\n  landau_function_family_pair Ftr F (G * H) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma landau_function_family_pair_trans_powr:\n  assumes \"landau_function_family_pair F (powr_closure g) H (\\<lambda>x. g x powr 1)\"\n  assumes \"filterlim f at_top F\"\n  assumes \"\\<And>p. (\\<lambda>x. g x powr p) \\<in> o[F](f)\"\n  shows   \"landau_function_family_pair F (powr_closure f) (powr_closure g * H) (\\<lambda>x. f x powr 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure f) (powr_closure g * H)\n     (\\<lambda>x. f x powr 1)", "proof (rule landau_function_family_pair_trans[OF _ assms(1)])"], ["proof (state)\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure f) (powr_closure g)\n     (\\<lambda>x. f x powr 1)", "interpret GH: landau_function_family_pair F \"powr_closure g\" H \"\\<lambda>x. g x powr 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure g) H\n     (\\<lambda>x. g x powr 1)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure f) (powr_closure g)\n     (\\<lambda>x. f x powr 1)", "interpret F: landau_function_family F \"powr_closure f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family F (powr_closure f)", "by (rule landau_function_family_powr_closure) (rule GH.G.F_nontrivial, rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure f) (powr_closure g)\n     (\\<lambda>x. f x powr 1)", "show \"landau_function_family_pair F (powr_closure f) (powr_closure g) (\\<lambda>x. f x powr 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure f) (powr_closure g)\n     (\\<lambda>x. f x powr 1)", "proof (unfold_locales; (elim powr_closureE; hypsubst)?)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)\n 2. (\\<lambda>x. f x powr 1) \\<in> powr_closure f\n 3. \\<And>h p. (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "show \"(\\<lambda>x. f x powr 1) \\<in> powr_closure f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr 1) \\<in> powr_closure f", "by (rule powr_closureI)"], ["proof (state)\nthis:\n  (\\<lambda>x. f x powr 1) \\<in> powr_closure f\n\ngoal (2 subgoals):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)\n 2. \\<And>h p. (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)\n 2. \\<And>h p. (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "fix p ::real"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)\n 2. \\<And>h p. (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "note assms(3)[of p]"], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr p) \\<in> o[F](f)\n\ngoal (2 subgoals):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)\n 2. \\<And>h p. (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr p) \\<in> o[F](f)\n\ngoal (2 subgoals):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)\n 2. \\<And>h p. (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "from assms(2)"], ["proof (chain)\npicking this:\n  filterlim f at_top F", "have \"eventually (\\<lambda>x. f x \\<ge> 1) F\""], ["proof (prove)\nusing this:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 1 \\<le> f x", "by (force simp: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (2 subgoals):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)\n 2. \\<And>h p. (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "hence \"f \\<in> \\<Theta>[F](\\<lambda>x. f x powr 1)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>[F](\\<lambda>x. f x powr 1)", "by (auto intro!: bigthetaI_cong elim!: eventually_mono)"], ["proof (state)\nthis:\n  f \\<in> \\<Theta>[F](\\<lambda>x. f x powr 1)\n\ngoal (2 subgoals):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)\n 2. \\<And>h p. (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "show \"(\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)", "."], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr p) \\<in> o[F](\\<lambda>x. f x powr 1)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "fix p p1 p2 p3 :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "assume A: \"(\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr p1)\""], ["proof (state)\nthis:\n  (\\<lambda>x. f x powr p) \\<in> o[F](\\<lambda>x. f x powr p1)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "have p: \"p < p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p < p1", "proof (cases p p1 rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1\n 3. p1 < p \\<Longrightarrow> p < p1", "assume \"p > p1\""], ["proof (state)\nthis:\n  p1 < p\n\ngoal (3 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1\n 3. p1 < p \\<Longrightarrow> p < p1", "moreover"], ["proof (state)\nthis:\n  p1 < p\n\ngoal (3 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1\n 3. p1 < p \\<Longrightarrow> p < p1", "from assms(2)"], ["proof (chain)\npicking this:\n  filterlim f at_top F", "have \"eventually (\\<lambda>x. f x \\<ge> 1) F\""], ["proof (prove)\nusing this:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 1 \\<le> f x", "by (force simp: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (3 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1\n 3. p1 < p \\<Longrightarrow> p < p1", "hence \"eventually (\\<lambda>x. f x \\<noteq> 0) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x \\<noteq> 0", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. f x \\<noteq> 0\n\ngoal (3 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1\n 3. p1 < p \\<Longrightarrow> p < p1", "ultimately"], ["proof (chain)\npicking this:\n  p1 < p\n  \\<forall>\\<^sub>F x in F. f x \\<noteq> 0", "have \"(\\<lambda>x. f x powr p1) \\<in> o[F](\\<lambda>x. f x powr p)\""], ["proof (prove)\nusing this:\n  p1 < p\n  \\<forall>\\<^sub>F x in F. f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr p1) \\<in> o[F](\\<lambda>x. f x powr p)", "using assms"], ["proof (prove)\nusing this:\n  p1 < p\n  \\<forall>\\<^sub>F x in F. f x \\<noteq> 0\n  landau_function_family_pair F (powr_closure g) H (\\<lambda>x. g x powr 1)\n  filterlim f at_top F\n  (\\<lambda>x. g x powr ?p) \\<in> o[F](f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr p1) \\<in> o[F](\\<lambda>x. f x powr p)", "by (auto intro!: smalloI_tendsto tendsto_neg_powr simp: powr_diff [symmetric] )"], ["proof (state)\nthis:\n  (\\<lambda>x. f x powr p1) \\<in> o[F](\\<lambda>x. f x powr p)\n\ngoal (3 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1\n 3. p1 < p \\<Longrightarrow> p < p1", "from F.small_antisym[OF _ _ this A]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(\\<lambda>x. f x powr p1) \\<in> powr_closure f;\n   (\\<lambda>x. f x powr p) \\<in> powr_closure f\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<lambda>x. f x powr p1) \\<in> powr_closure f;\n   (\\<lambda>x. f x powr p) \\<in> powr_closure f\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. p < p1", "by (auto simp: powr_closureI)"], ["proof (state)\nthis:\n  p < p1\n\ngoal (2 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1", "assume \"p = p1\""], ["proof (state)\nthis:\n  p = p1\n\ngoal (2 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1", "hence \"(\\<lambda>x. f x powr p1) \\<in> O[F](\\<lambda>x. f x powr p)\""], ["proof (prove)\nusing this:\n  p = p1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr p1) \\<in> O[F](\\<lambda>x. f x powr p)", "by (intro bigthetaD1) simp"], ["proof (state)\nthis:\n  (\\<lambda>x. f x powr p1) \\<in> O[F](\\<lambda>x. f x powr p)\n\ngoal (2 subgoals):\n 1. p < p1 \\<Longrightarrow> p < p1\n 2. p = p1 \\<Longrightarrow> p < p1", "with F.small_big_antisym[OF _ _ A this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(\\<lambda>x. f x powr p) \\<in> powr_closure f;\n   (\\<lambda>x. f x powr p1) \\<in> powr_closure f\\<rbrakk>\n  \\<Longrightarrow> False\n  (\\<lambda>x. f x powr p1) \\<in> O[F](\\<lambda>x. f x powr p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<lambda>x. f x powr p) \\<in> powr_closure f;\n   (\\<lambda>x. f x powr p1) \\<in> powr_closure f\\<rbrakk>\n  \\<Longrightarrow> False\n  (\\<lambda>x. f x powr p1) \\<in> O[F](\\<lambda>x. f x powr p)\n\ngoal (1 subgoal):\n 1. p < p1", "by (auto simp: powr_closureI)"], ["proof (state)\nthis:\n  p < p1\n\ngoal (1 subgoal):\n 1. p < p1 \\<Longrightarrow> p < p1", "qed"], ["proof (state)\nthis:\n  p < p1\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "from assms(2)"], ["proof (chain)\npicking this:\n  filterlim f at_top F", "have f_pos: \"eventually (\\<lambda>x. f x \\<ge> 1) F\""], ["proof (prove)\nusing this:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 1 \\<le> f x", "by (force simp: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "from assms"], ["proof (chain)\npicking this:\n  landau_function_family_pair F (powr_closure g) H (\\<lambda>x. g x powr 1)\n  filterlim f at_top F\n  (\\<lambda>x. g x powr ?p) \\<in> o[F](f)", "have \"(\\<lambda>x. g x powr ((p2 - p3)/(p1 - p))) \\<in> o[F](f)\""], ["proof (prove)\nusing this:\n  landau_function_family_pair F (powr_closure g) H (\\<lambda>x. g x powr 1)\n  filterlim f at_top F\n  (\\<lambda>x. g x powr ?p) \\<in> o[F](f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr ((p2 - p3) / (p1 - p))) \\<in> o[F](f)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr ((p2 - p3) / (p1 - p))) \\<in> o[F](f)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "from smallo_powr[OF this, of \"p1 - p\"] p"], ["proof (chain)\npicking this:\n  0 < p1 - p \\<Longrightarrow>\n  (\\<lambda>x. \\<bar>g x powr ((p2 - p3) / (p1 - p))\\<bar> powr (p1 - p))\n  \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr (p1 - p))\n  p < p1", "have \"(\\<lambda>x. g x powr (p2 - p3)) \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr (p1 - p))\""], ["proof (prove)\nusing this:\n  0 < p1 - p \\<Longrightarrow>\n  (\\<lambda>x. \\<bar>g x powr ((p2 - p3) / (p1 - p))\\<bar> powr (p1 - p))\n  \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr (p1 - p))\n  p < p1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr (p2 - p3))\n    \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr (p1 - p))", "by (simp add: powr_powr)"], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr (p2 - p3))\n  \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr (p1 - p))\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "hence \"(\\<lambda>x. \\<bar>f x\\<bar> powr p * g x powr p2) \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr p1 * g x powr p3)\" (is ?P)"], ["proof (prove)\nusing this:\n  (\\<lambda>x. g x powr (p2 - p3))\n  \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr (p1 - p))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>f x\\<bar> powr p * g x powr p2)\n    \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr p1 * g x powr p3)", "using GH.G.nonzero[OF GH.g] F.nonzero[OF powr_closureI]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. g x powr (p2 - p3))\n  \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr (p1 - p))\n  \\<forall>\\<^sub>F x in F. g x powr 1 \\<noteq> 0\n  \\<forall>\\<^sub>F x in F. f x powr ?p1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>f x\\<bar> powr p * g x powr p2)\n    \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr p1 * g x powr p3)", "by (simp add: powr_diff landau_o.small.divide_eq1\n                    landau_o.small.divide_eq2 mult.commute)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>f x\\<bar> powr p * g x powr p2)\n  \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr p1 * g x powr p3)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>f x\\<bar> powr p * g x powr p2)\n  \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr p1 * g x powr p3)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "have \"?P \\<longleftrightarrow> (\\<lambda>x. f x powr p * g x powr p2) \\<in> o[F](\\<lambda>x. f x powr p1 * g x powr p3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>f x\\<bar> powr p * g x powr p2)\n     \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr p1 * g x powr p3)) =\n    ((\\<lambda>x. f x powr p * g x powr p2)\n     \\<in> o[F](\\<lambda>x. f x powr p1 * g x powr p3))", "using f_pos"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>f x\\<bar> powr p * g x powr p2)\n     \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr p1 * g x powr p3)) =\n    ((\\<lambda>x. f x powr p * g x powr p2)\n     \\<in> o[F](\\<lambda>x. f x powr p1 * g x powr p3))", "by (intro landau_o.small.cong_ex) (auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<bar>f x\\<bar> powr p * g x powr p2)\n   \\<in> o[F](\\<lambda>x. \\<bar>f x\\<bar> powr p1 * g x powr p3)) =\n  ((\\<lambda>x. f x powr p * g x powr p2)\n   \\<in> o[F](\\<lambda>x. f x powr p1 * g x powr p3))\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2 h1 h2 p pa pb pc.\n       (\\<lambda>x. f x powr p)\n       \\<in> o[F](\\<lambda>x. f x powr pa) \\<Longrightarrow>\n       (\\<lambda>x. f x powr p * g x powr pb)\n       \\<in> o[F](\\<lambda>x. f x powr pa * g x powr pc)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. f x powr p * g x powr p2)\n  \\<in> o[F](\\<lambda>x. f x powr p1 * g x powr p3)", "show \"(\\<lambda>x. f x powr p * g x powr p2) \\<in> o[F](\\<lambda>x. f x powr p1 * g x powr p3)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. f x powr p * g x powr p2)\n  \\<in> o[F](\\<lambda>x. f x powr p1 * g x powr p3)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x powr p * g x powr p2)\n    \\<in> o[F](\\<lambda>x. f x powr p1 * g x powr p3)", "."], ["proof (state)\nthis:\n  (\\<lambda>x. f x powr p * g x powr p2)\n  \\<in> o[F](\\<lambda>x. f x powr p1 * g x powr p3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  landau_function_family_pair F (powr_closure f) (powr_closure g)\n   (\\<lambda>x. f x powr 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition dominates :: \"'a filter \\<Rightarrow> ('a \\<Rightarrow> real) \\<Rightarrow> ('a \\<Rightarrow> real) \\<Rightarrow> bool\" where\n  \"dominates F f g = (\\<forall>p. (\\<lambda>x. g x powr p) \\<in> o[F](f))\""], ["", "lemma dominates_trans:\n  assumes \"eventually (\\<lambda>x. g x > 0) F\"\n  assumes \"dominates F f g\" \"dominates F g h\"\n  shows   \"dominates F f h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dominates F f h", "unfolding dominates_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. (\\<lambda>x. h x powr p) \\<in> o[F](f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. (\\<lambda>x. h x powr p) \\<in> o[F](f)", "fix p :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. (\\<lambda>x. h x powr p) \\<in> o[F](f)", "from assms(3)"], ["proof (chain)\npicking this:\n  dominates F g h", "have \"(\\<lambda>x. h x powr p) \\<in> o[F](g)\""], ["proof (prove)\nusing this:\n  dominates F g h\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. h x powr p) \\<in> o[F](g)", "unfolding dominates_def"], ["proof (prove)\nusing this:\n  \\<forall>p. (\\<lambda>x. h x powr p) \\<in> o[F](g)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. h x powr p) \\<in> o[F](g)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x. h x powr p) \\<in> o[F](g)\n\ngoal (1 subgoal):\n 1. \\<And>p. (\\<lambda>x. h x powr p) \\<in> o[F](f)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. h x powr p) \\<in> o[F](g)\n\ngoal (1 subgoal):\n 1. \\<And>p. (\\<lambda>x. h x powr p) \\<in> o[F](f)", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. 0 < g x", "have \"g \\<in> \\<Theta>[F](\\<lambda>x. g x powr 1)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < g x\n\ngoal (1 subgoal):\n 1. g \\<in> \\<Theta>[F](\\<lambda>x. g x powr 1)", "by (intro bigthetaI_cong) (auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  g \\<in> \\<Theta>[F](\\<lambda>x. g x powr 1)\n\ngoal (1 subgoal):\n 1. \\<And>p. (\\<lambda>x. h x powr p) \\<in> o[F](f)", "also"], ["proof (state)\nthis:\n  g \\<in> \\<Theta>[F](\\<lambda>x. g x powr 1)\n\ngoal (1 subgoal):\n 1. \\<And>p. (\\<lambda>x. h x powr p) \\<in> o[F](f)", "from assms(2)"], ["proof (chain)\npicking this:\n  dominates F f g", "have \"(\\<lambda>x. g x powr 1) \\<in> o[F](f)\""], ["proof (prove)\nusing this:\n  dominates F f g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr 1) \\<in> o[F](f)", "unfolding dominates_def"], ["proof (prove)\nusing this:\n  \\<forall>p. (\\<lambda>x. g x powr p) \\<in> o[F](f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. g x powr 1) \\<in> o[F](f)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x. g x powr 1) \\<in> o[F](f)\n\ngoal (1 subgoal):\n 1. \\<And>p. (\\<lambda>x. h x powr p) \\<in> o[F](f)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. h x powr p) \\<in> o[F](f)", "show \"(\\<lambda>x. h x powr p) \\<in> o[F](f)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. h x powr p) \\<in> o[F](f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. h x powr p) \\<in> o[F](f)", "."], ["proof (state)\nthis:\n  (\\<lambda>x. h x powr p) \\<in> o[F](f)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun landau_dominating_chain where\n  \"landau_dominating_chain F (f # g # gs) \\<longleftrightarrow>\n    dominates F f g \\<and> landau_dominating_chain F (g # gs)\"\n| \"landau_dominating_chain F [f] \\<longleftrightarrow> (\\<lambda>x. 1) \\<in> o[F](f)\"\n| \"landau_dominating_chain F [] \\<longleftrightarrow> True\""], ["", "primrec landau_dominating_chain' where\n  \"landau_dominating_chain' F [] \\<longleftrightarrow> True\"\n| \"landau_dominating_chain' F (f # gs) \\<longleftrightarrow>\n    landau_function_family_pair F (powr_closure f) (prod_list (map powr_closure gs)) (\\<lambda>x. f x powr 1) \\<and>\n    landau_dominating_chain' F gs\""], ["", "primrec nonneg_list where\n  \"nonneg_list [] \\<longleftrightarrow> True\"\n| \"nonneg_list (x#xs) \\<longleftrightarrow> x > 0 \\<or> (x = 0 \\<and> nonneg_list xs)\""], ["", "primrec pos_list where\n  \"pos_list [] \\<longleftrightarrow> False\"\n| \"pos_list (x#xs) \\<longleftrightarrow> x > 0 \\<or> (x = 0 \\<and> pos_list xs)\""], ["", "lemma dominating_chain_imp_dominating_chain':\n  \"Ftr \\<noteq> bot \\<Longrightarrow> (\\<And>g. g \\<in> set gs \\<Longrightarrow> filterlim g at_top Ftr) \\<Longrightarrow>\n     landau_dominating_chain Ftr gs \\<Longrightarrow> landau_dominating_chain' Ftr gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ftr \\<noteq> bot;\n     \\<And>g. g \\<in> set gs \\<Longrightarrow> filterlim g at_top Ftr;\n     landau_dominating_chain Ftr gs\\<rbrakk>\n    \\<Longrightarrow> landau_dominating_chain' Ftr gs", "proof (induction gs rule: landau_dominating_chain.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>F f g gs.\n       \\<lbrakk>\\<lbrakk>F \\<noteq> bot;\n                 \\<And>ga.\n                    ga \\<in> set (g # gs) \\<Longrightarrow>\n                    filterlim ga at_top F;\n                 landau_dominating_chain F (g # gs)\\<rbrakk>\n                \\<Longrightarrow> landau_dominating_chain' F (g # gs);\n        F \\<noteq> bot;\n        \\<And>ga.\n           ga \\<in> set (f # g # gs) \\<Longrightarrow>\n           filterlim ga at_top F;\n        landau_dominating_chain F (f # g # gs)\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F (f # g # gs)\n 2. \\<And>F f.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [f] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F [f]\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F [f]\n 3. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "case (1 F f g gs)"], ["proof (state)\nthis:\n  \\<lbrakk>F \\<noteq> bot;\n   \\<And>ga. ga \\<in> set (g # gs) \\<Longrightarrow> filterlim ga at_top F;\n   landau_dominating_chain F (g # gs)\\<rbrakk>\n  \\<Longrightarrow> landau_dominating_chain' F (g # gs)\n  F \\<noteq> bot\n  ?g \\<in> set (f # g # gs) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F (f # g # gs)\n\ngoal (3 subgoals):\n 1. \\<And>F f g gs.\n       \\<lbrakk>\\<lbrakk>F \\<noteq> bot;\n                 \\<And>ga.\n                    ga \\<in> set (g # gs) \\<Longrightarrow>\n                    filterlim ga at_top F;\n                 landau_dominating_chain F (g # gs)\\<rbrakk>\n                \\<Longrightarrow> landau_dominating_chain' F (g # gs);\n        F \\<noteq> bot;\n        \\<And>ga.\n           ga \\<in> set (f # g # gs) \\<Longrightarrow>\n           filterlim ga at_top F;\n        landau_dominating_chain F (f # g # gs)\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F (f # g # gs)\n 2. \\<And>F f.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [f] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F [f]\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F [f]\n 3. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "from 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>F \\<noteq> bot;\n   \\<And>ga. ga \\<in> set (g # gs) \\<Longrightarrow> filterlim ga at_top F;\n   landau_dominating_chain F (g # gs)\\<rbrakk>\n  \\<Longrightarrow> landau_dominating_chain' F (g # gs)\n  F \\<noteq> bot\n  ?g \\<in> set (f # g # gs) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F (f # g # gs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>F \\<noteq> bot;\n   \\<And>ga. ga \\<in> set (g # gs) \\<Longrightarrow> filterlim ga at_top F;\n   landau_dominating_chain F (g # gs)\\<rbrakk>\n  \\<Longrightarrow> landau_dominating_chain' F (g # gs)\n  F \\<noteq> bot\n  ?g \\<in> set (f # g # gs) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F (f # g # gs)\n\ngoal (1 subgoal):\n 1. landau_dominating_chain' F (f # g # gs)", "by (auto intro!: landau_function_family_pair_trans_powr simp add: dominates_def)"], ["proof (state)\nthis:\n  landau_dominating_chain' F (f # g # gs)\n\ngoal (2 subgoals):\n 1. \\<And>F f.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [f] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F [f]\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F [f]\n 2. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>F f.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [f] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F [f]\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F [f]\n 2. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "case (2 F f)"], ["proof (state)\nthis:\n  F \\<noteq> bot\n  ?g \\<in> set [f] \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F [f]\n\ngoal (2 subgoals):\n 1. \\<And>F f.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [f] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F [f]\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F [f]\n 2. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "then"], ["proof (chain)\npicking this:\n  F \\<noteq> bot\n  ?g \\<in> set [f] \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F [f]", "interpret F: landau_function_family F \"powr_closure f\""], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  ?g \\<in> set [f] \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F [f]\n\ngoal (1 subgoal):\n 1. landau_function_family F (powr_closure f)", "by (intro landau_function_family_powr_closure) simp_all"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>F f.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [f] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F [f]\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F [f]\n 2. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "from 2"], ["proof (chain)\npicking this:\n  F \\<noteq> bot\n  ?g \\<in> set [f] \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F [f]", "have \"eventually (\\<lambda>x. f x \\<ge> 1) F\""], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  ?g \\<in> set [f] \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F [f]\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 1 \\<le> f x", "by (force simp: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (2 subgoals):\n 1. \\<And>F f.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [f] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F [f]\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F [f]\n 2. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "hence \"o[F](\\<lambda>x. f x powr 1) = o[F](\\<lambda>x. f x)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 1 \\<le> f x\n\ngoal (1 subgoal):\n 1. o[F](\\<lambda>x. f x powr 1) = o[F](f)", "by (intro landau_o.small.cong) (auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  o[F](\\<lambda>x. f x powr 1) = o[F](f)\n\ngoal (2 subgoals):\n 1. \\<And>F f.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [f] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F [f]\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F [f]\n 2. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "with 2"], ["proof (chain)\npicking this:\n  F \\<noteq> bot\n  ?g \\<in> set [f] \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F [f]\n  o[F](\\<lambda>x. f x powr 1) = o[F](f)", "have \"landau_function_family_pair F (powr_closure f) {\\<lambda>_. 1} (\\<lambda>x. f x powr 1)\""], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  ?g \\<in> set [f] \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain F [f]\n  o[F](\\<lambda>x. f x powr 1) = o[F](f)\n\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure f) {\\<lambda>_. 1}\n     (\\<lambda>x. f x powr 1)", "by unfold_locales (auto intro: powr_closureI)"], ["proof (state)\nthis:\n  landau_function_family_pair F (powr_closure f) {\\<lambda>_. 1}\n   (\\<lambda>x. f x powr 1)\n\ngoal (2 subgoals):\n 1. \\<And>F f.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [f] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F [f]\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F [f]\n 2. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "thus ?case"], ["proof (prove)\nusing this:\n  landau_function_family_pair F (powr_closure f) {\\<lambda>_. 1}\n   (\\<lambda>x. f x powr 1)\n\ngoal (1 subgoal):\n 1. landau_dominating_chain' F [f]", "by (simp add: one_fun_def)"], ["proof (state)\nthis:\n  landau_dominating_chain' F [f]\n\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "case 3"], ["proof (state)\nthis:\n  F_ \\<noteq> bot\n  ?g \\<in> set [] \\<Longrightarrow> filterlim ?g at_top F_\n  landau_dominating_chain F_ []\n\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>F \\<noteq> bot;\n        \\<And>g. g \\<in> set [] \\<Longrightarrow> filterlim g at_top F;\n        landau_dominating_chain F []\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain' F []", "then"], ["proof (chain)\npicking this:\n  F_ \\<noteq> bot\n  ?g \\<in> set [] \\<Longrightarrow> filterlim ?g at_top F_\n  landau_dominating_chain F_ []", "show ?case"], ["proof (prove)\nusing this:\n  F_ \\<noteq> bot\n  ?g \\<in> set [] \\<Longrightarrow> filterlim ?g at_top F_\n  landau_dominating_chain F_ []\n\ngoal (1 subgoal):\n 1. landau_dominating_chain' F_ []", "by simp"], ["proof (state)\nthis:\n  landau_dominating_chain' F_ []\n\ngoal:\nNo subgoals!", "qed"], ["", "locale landau_function_family_chain =\n  fixes F :: \"'b filter\"\n  fixes gs :: \"'a list\"\n  fixes get_param :: \"'a \\<Rightarrow> real\"\n  fixes get_fun :: \"'a \\<Rightarrow> ('b \\<Rightarrow> real)\"\n  assumes F_nontrivial: \"F \\<noteq> bot\"\n  assumes gs_pos: \"g \\<in> set (map get_fun gs) \\<Longrightarrow> filterlim g at_top F\"\n  assumes dominating_chain: \"landau_dominating_chain F (map get_fun gs)\"\nbegin"], ["", "lemma dominating_chain': \"landau_dominating_chain' F (map get_fun gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_dominating_chain' F (map get_fun gs)", "by (intro dominating_chain_imp_dominating_chain' gs_pos dominating_chain F_nontrivial)"], ["", "lemma gs_powr_0_eq_one:\n  \"eventually (\\<lambda>x. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1", "using gs_pos"], ["proof (prove)\nusing this:\n  ?g \\<in> set (map get_fun gs) \\<Longrightarrow> filterlim ?g at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1", "proof (induction gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>g.\n        g \\<in> set (map get_fun []) \\<Longrightarrow>\n        filterlim g at_top F) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>[]. get_fun g x powr 0) = 1\n 2. \\<And>a gs.\n       \\<lbrakk>(\\<And>g.\n                    g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                    filterlim g at_top F) \\<Longrightarrow>\n                \\<forall>\\<^sub>F x in F.\n                   (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1;\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in F.\n                            (\\<Prod>g\\<leftarrow>a #\n           gs. get_fun g x powr 0) =\n                            1", "case (Cons g gs)"], ["proof (state)\nthis:\n  (\\<And>g.\n      g \\<in> set (map get_fun gs) \\<Longrightarrow>\n      filterlim g at_top F) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in F. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n\ngoal (2 subgoals):\n 1. (\\<And>g.\n        g \\<in> set (map get_fun []) \\<Longrightarrow>\n        filterlim g at_top F) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>[]. get_fun g x powr 0) = 1\n 2. \\<And>a gs.\n       \\<lbrakk>(\\<And>g.\n                    g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                    filterlim g at_top F) \\<Longrightarrow>\n                \\<forall>\\<^sub>F x in F.\n                   (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1;\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in F.\n                            (\\<Prod>g\\<leftarrow>a #\n           gs. get_fun g x powr 0) =\n                            1", "from Cons"], ["proof (chain)\npicking this:\n  (\\<And>g.\n      g \\<in> set (map get_fun gs) \\<Longrightarrow>\n      filterlim g at_top F) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in F. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F", "have \"eventually (\\<lambda>x. get_fun g x > 0) F\""], ["proof (prove)\nusing this:\n  (\\<And>g.\n      g \\<in> set (map get_fun gs) \\<Longrightarrow>\n      filterlim g at_top F) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in F. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < get_fun g x", "by (auto simp: filterlim_at_top_dense)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 < get_fun g x\n\ngoal (2 subgoals):\n 1. (\\<And>g.\n        g \\<in> set (map get_fun []) \\<Longrightarrow>\n        filterlim g at_top F) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>[]. get_fun g x powr 0) = 1\n 2. \\<And>a gs.\n       \\<lbrakk>(\\<And>g.\n                    g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                    filterlim g at_top F) \\<Longrightarrow>\n                \\<forall>\\<^sub>F x in F.\n                   (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1;\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in F.\n                            (\\<Prod>g\\<leftarrow>a #\n           gs. get_fun g x powr 0) =\n                            1", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 < get_fun g x\n\ngoal (2 subgoals):\n 1. (\\<And>g.\n        g \\<in> set (map get_fun []) \\<Longrightarrow>\n        filterlim g at_top F) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>[]. get_fun g x powr 0) = 1\n 2. \\<And>a gs.\n       \\<lbrakk>(\\<And>g.\n                    g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                    filterlim g at_top F) \\<Longrightarrow>\n                \\<forall>\\<^sub>F x in F.\n                   (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1;\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in F.\n                            (\\<Prod>g\\<leftarrow>a #\n           gs. get_fun g x powr 0) =\n                            1", "from Cons"], ["proof (chain)\npicking this:\n  (\\<And>g.\n      g \\<in> set (map get_fun gs) \\<Longrightarrow>\n      filterlim g at_top F) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in F. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F", "have \"eventually (\\<lambda>x. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1) F\""], ["proof (prove)\nusing this:\n  (\\<And>g.\n      g \\<in> set (map get_fun gs) \\<Longrightarrow>\n      filterlim g at_top F) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in F. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1\n\ngoal (2 subgoals):\n 1. (\\<And>g.\n        g \\<in> set (map get_fun []) \\<Longrightarrow>\n        filterlim g at_top F) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>[]. get_fun g x powr 0) = 1\n 2. \\<And>a gs.\n       \\<lbrakk>(\\<And>g.\n                    g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                    filterlim g at_top F) \\<Longrightarrow>\n                \\<forall>\\<^sub>F x in F.\n                   (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1;\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in F.\n                            (\\<Prod>g\\<leftarrow>a #\n           gs. get_fun g x powr 0) =\n                            1", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. 0 < get_fun g x\n  \\<forall>\\<^sub>F x in F. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < get_fun g x\n  \\<forall>\\<^sub>F x in F. (\\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) = 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0) = 1", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F.\n     (\\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        g \\<in> set (map get_fun []) \\<Longrightarrow>\n        filterlim g at_top F) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in F.\n       (\\<Prod>g\\<leftarrow>[]. get_fun g x powr 0) = 1", "qed simp_all"], ["", "lemma listmap_gs_in_listmap:\n  \"(\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g) \\<in> prod_list (map powr_closure (map h fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g)\n    \\<in> prod_list (map powr_closure (map h fs))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g)\n    \\<in> prod_list (map powr_closure (map h fs))", "have \"(\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g) = (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g) =\n    (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))", "by (rule ext, induction fs) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g) =\n  (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g)\n    \\<in> prod_list (map powr_closure (map h fs))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g) =\n  (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g)\n    \\<in> prod_list (map powr_closure (map h fs))", "have \"... \\<in> prod_list (map powr_closure (map h fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\n    \\<in> prod_list (map powr_closure (map h fs))", "apply (induction fs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Prod>g\\<leftarrow>[]. (\\<lambda>x. h g x powr p g))\n    \\<in> prod_list (map powr_closure (map h []))\n 2. \\<And>a fs.\n       (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\n       \\<in> prod_list (map powr_closure (map h fs)) \\<Longrightarrow>\n       (\\<Prod>g\\<leftarrow>a # fs. (\\<lambda>x. h g x powr p g))\n       \\<in> prod_list (map powr_closure (map h (a # fs)))", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\n       \\<in> prod_list (map powr_closure (map h fs)) \\<Longrightarrow>\n       (\\<Prod>g\\<leftarrow>a # fs. (\\<lambda>x. h g x powr p g))\n       \\<in> prod_list (map powr_closure (map h (a # fs)))", "apply (simp only: list.map prod_list.Cons, rule set_times_intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a fs.\n       (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\n       \\<in> prod_list (map powr_closure (map h fs)) \\<Longrightarrow>\n       (\\<lambda>x. h a x powr p a) \\<in> powr_closure (h a)\n 2. \\<And>a fs.\n       (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\n       \\<in> prod_list (map powr_closure (map h fs)) \\<Longrightarrow>\n       (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\n       \\<in> prod_list (map powr_closure (map h fs))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Prod>g\\<leftarrow>fs. (\\<lambda>x. h g x powr p g))\n  \\<in> prod_list (map powr_closure (map h fs))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g)\n    \\<in> prod_list (map powr_closure (map h fs))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g)\n  \\<in> prod_list (map powr_closure (map h fs))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g)\n  \\<in> prod_list (map powr_closure (map h fs))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g)\n    \\<in> prod_list (map powr_closure (map h fs))", "."], ["proof (state)\nthis:\n  (\\<lambda>x. \\<Prod>g\\<leftarrow>fs. h g x powr p g)\n  \\<in> prod_list (map powr_closure (map h fs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smallo_iff:\n  \"(\\<lambda>_. 1) \\<in> o[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g) \\<longleftrightarrow> pos_list (map get_param gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    pos_list (map get_param gs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    pos_list (map get_param gs)", "have \"((\\<lambda>_. 1) \\<in> o[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) \\<longleftrightarrow>\n          ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) \\<in> o[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g))", "by (rule sym, intro landau_o.small.in_cong gs_powr_0_eq_one)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    pos_list (map get_param gs)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    pos_list (map get_param gs)", "from gs_pos dominating_chain'"], ["proof (chain)\npicking this:\n  ?g \\<in> set (map get_fun gs) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun gs)", "have \"... \\<longleftrightarrow> pos_list (map get_param gs)\""], ["proof (prove)\nusing this:\n  ?g \\<in> set (map get_fun gs) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun gs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    pos_list (map get_param gs)", "proof (induction gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>g.\n                g \\<in> set (map get_fun []) \\<Longrightarrow>\n                filterlim g at_top F;\n     landau_dominating_chain' F (map get_fun [])\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n                       \\<in> o[F](\\<lambda>x.\n                                     \\<Prod>g\\<leftarrow>[]. get_fun g\n                        x powr\n                       get_param g)) =\n                      pos_list (map get_param [])\n 2. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> o[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  pos_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> o[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         pos_list (map get_param (a # gs))", "case Nil"], ["proof (state)\nthis:\n  ?g \\<in> set (map get_fun []) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>g.\n                g \\<in> set (map get_fun []) \\<Longrightarrow>\n                filterlim g at_top F;\n     landau_dominating_chain' F (map get_fun [])\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n                       \\<in> o[F](\\<lambda>x.\n                                     \\<Prod>g\\<leftarrow>[]. get_fun g\n                        x powr\n                       get_param g)) =\n                      pos_list (map get_param [])\n 2. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> o[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  pos_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> o[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         pos_list (map get_param (a # gs))", "have \"(\\<lambda>x::'b. 1::real) \\<notin> o[F](\\<lambda>x. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 1) \\<notin> o[F](\\<lambda>x. 1)", "using F_nontrivial"], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. 1) \\<notin> o[F](\\<lambda>x. 1)", "by (auto dest!: landau_o.small_big_asymmetric)"], ["proof (state)\nthis:\n  (\\<lambda>x. 1) \\<notin> o[F](\\<lambda>x. 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>g.\n                g \\<in> set (map get_fun []) \\<Longrightarrow>\n                filterlim g at_top F;\n     landau_dominating_chain' F (map get_fun [])\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n                       \\<in> o[F](\\<lambda>x.\n                                     \\<Prod>g\\<leftarrow>[]. get_fun g\n                        x powr\n                       get_param g)) =\n                      pos_list (map get_param [])\n 2. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> o[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  pos_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> o[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         pos_list (map get_param (a # gs))", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<lambda>x. 1) \\<notin> o[F](\\<lambda>x. 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>[]. get_fun g x powr get_param g)) =\n    pos_list (map get_param [])", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>[]. get_fun g x powr get_param g)) =\n  pos_list (map get_param [])\n\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> o[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  pos_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> o[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         pos_list (map get_param (a # gs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> o[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  pos_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> o[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         pos_list (map get_param (a # gs))", "case (Cons g gs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> o[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    pos_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> o[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  pos_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> o[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         pos_list (map get_param (a # gs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> o[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    pos_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))", "interpret G: landau_function_family_pair F \"powr_closure (get_fun g)\"\n       \"prod_list (map powr_closure (map get_fun gs))\" \"\\<lambda>x. get_fun g x powr 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> o[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    pos_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure (get_fun g))\n     (prod_list (map powr_closure (map get_fun gs)))\n     (\\<lambda>x. get_fun g x powr 1)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> o[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  pos_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> o[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         pos_list (map get_param (a # gs))", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> o[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    pos_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> o[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    pos_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>g #\n gs. get_fun g x powr get_param g)) =\n    pos_list (map get_param (g # gs))", "using listmap_gs_in_listmap[of get_fun _ gs] F_nontrivial"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> o[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    pos_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n  (\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr ?p g)\n  \\<in> prod_list (map powr_closure (map get_fun gs))\n  F \\<noteq> bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>g #\n gs. get_fun g x powr get_param g)) =\n    pos_list (map get_param (g # gs))", "by (simp_all add: G.smallo_iff listmap_gs_in_listmap powr_smallo_iff powr_bigtheta_iff\n                   del: powr_zero_eq_one)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>g #\n                                     gs. get_fun g x powr get_param g)) =\n  pos_list (map get_param (g # gs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  pos_list (map get_param gs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    pos_list (map get_param gs)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>_. 1)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  pos_list (map get_param gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>_. 1)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  pos_list (map get_param gs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> o[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    pos_list (map get_param gs)", "."], ["proof (state)\nthis:\n  ((\\<lambda>_. 1)\n   \\<in> o[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  pos_list (map get_param gs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bigo_iff:\n  \"(\\<lambda>_. 1) \\<in> O[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g) \\<longleftrightarrow> nonneg_list (map get_param gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param gs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param gs)", "have \"((\\<lambda>_. 1) \\<in> O[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) \\<longleftrightarrow>\n          ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) \\<in> O[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g))", "by (rule sym, intro landau_o.big.in_cong gs_powr_0_eq_one)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param gs)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param gs)", "from gs_pos dominating_chain'"], ["proof (chain)\npicking this:\n  ?g \\<in> set (map get_fun gs) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun gs)", "have \"... \\<longleftrightarrow> nonneg_list (map get_param gs)\""], ["proof (prove)\nusing this:\n  ?g \\<in> set (map get_fun gs) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun gs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param gs)", "proof (induction gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>g.\n                g \\<in> set (map get_fun []) \\<Longrightarrow>\n                filterlim g at_top F;\n     landau_dominating_chain' F (map get_fun [])\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n                       \\<in> O[F](\\<lambda>x.\n                                     \\<Prod>g\\<leftarrow>[]. get_fun g\n                        x powr\n                       get_param g)) =\n                      nonneg_list (map get_param [])\n 2. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> O[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  nonneg_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> O[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         nonneg_list (map get_param (a # gs))", "case Nil"], ["proof (state)\nthis:\n  ?g \\<in> set (map get_fun []) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>g.\n                g \\<in> set (map get_fun []) \\<Longrightarrow>\n                filterlim g at_top F;\n     landau_dominating_chain' F (map get_fun [])\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n                       \\<in> O[F](\\<lambda>x.\n                                     \\<Prod>g\\<leftarrow>[]. get_fun g\n                        x powr\n                       get_param g)) =\n                      nonneg_list (map get_param [])\n 2. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> O[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  nonneg_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> O[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         nonneg_list (map get_param (a # gs))", "then"], ["proof (chain)\npicking this:\n  ?g \\<in> set (map get_fun []) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun [])", "show ?case"], ["proof (prove)\nusing this:\n  ?g \\<in> set (map get_fun []) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun [])\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>[]. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param [])", "by (simp add: func_one)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>[]. get_fun g x powr get_param g)) =\n  nonneg_list (map get_param [])\n\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> O[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  nonneg_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> O[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         nonneg_list (map get_param (a # gs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> O[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  nonneg_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> O[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         nonneg_list (map get_param (a # gs))", "case (Cons g gs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> O[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    nonneg_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> O[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  nonneg_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> O[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         nonneg_list (map get_param (a # gs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> O[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    nonneg_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))", "interpret G: landau_function_family_pair F \"powr_closure (get_fun g)\"\n       \"prod_list (map powr_closure (map get_fun gs))\" \"\\<lambda>x. get_fun g x powr 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> O[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    nonneg_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure (get_fun g))\n     (prod_list (map powr_closure (map get_fun gs)))\n     (\\<lambda>x. get_fun g x powr 1)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> O[F](\\<lambda>x.\n           \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  nonneg_list (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> O[F](\\<lambda>x.\n  \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         nonneg_list (map get_param (a # gs))", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> O[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    nonneg_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> O[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    nonneg_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>g #\n gs. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param (g # gs))", "using listmap_gs_in_listmap[of get_fun _ gs] F_nontrivial"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> O[F](\\<lambda>x.\n                                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n                     get_param g)) =\n                    nonneg_list (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n  (\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr ?p g)\n  \\<in> prod_list (map powr_closure (map get_fun gs))\n  F \\<noteq> bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>g #\n gs. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param (g # gs))", "by (simp_all add: G.bigo_iff listmap_gs_in_listmap powr_smallo_iff powr_bigtheta_iff\n                   del: powr_zero_eq_one)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>g #\n                                     gs. get_fun g x powr get_param g)) =\n  nonneg_list (map get_param (g # gs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  nonneg_list (map get_param gs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param gs)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>_. 1)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  nonneg_list (map get_param gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>_. 1)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  nonneg_list (map get_param gs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> O[F](\\<lambda>x.\n                   \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n    nonneg_list (map get_param gs)", "."], ["proof (state)\nthis:\n  ((\\<lambda>_. 1)\n   \\<in> O[F](\\<lambda>x.\n                 \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n  nonneg_list (map get_param gs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bigtheta_iff:\n  \"(\\<lambda>_. 1) \\<in> \\<Theta>[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g) \\<longleftrightarrow> list_all ((=) 0) (map get_param gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n            get_param g)) =\n    list_all ((=) 0) (map get_param gs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n            get_param g)) =\n    list_all ((=) 0) (map get_param gs)", "have \"((\\<lambda>_. 1) \\<in> \\<Theta>[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) \\<longleftrightarrow>\n          ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0) \\<in> \\<Theta>[F](\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n            get_param g)) =\n    ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n            get_param g))", "by (rule sym, intro landau_theta.in_cong gs_powr_0_eq_one)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n          get_param g)) =\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n          get_param g))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n            get_param g)) =\n    list_all ((=) 0) (map get_param gs)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n          get_param g)) =\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n          get_param g))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n            get_param g)) =\n    list_all ((=) 0) (map get_param gs)", "from gs_pos dominating_chain'"], ["proof (chain)\npicking this:\n  ?g \\<in> set (map get_fun gs) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun gs)", "have \"... \\<longleftrightarrow> list_all ((=) 0) (map get_param gs)\""], ["proof (prove)\nusing this:\n  ?g \\<in> set (map get_fun gs) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun gs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n            get_param g)) =\n    list_all ((=) 0) (map get_param gs)", "proof (induction gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>g.\n                g \\<in> set (map get_fun []) \\<Longrightarrow>\n                filterlim g at_top F;\n     landau_dominating_chain' F (map get_fun [])\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n                       \\<in> \\<Theta>[F](\\<lambda>x.\n      \\<Prod>g\\<leftarrow>[]. get_fun g x powr get_param g)) =\n                      list_all ((=) 0) (map get_param [])\n 2. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> \\<Theta>[F](\\<lambda>x.\n                  \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  list_all ((=) 0) (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> \\<Theta>[F](\\<lambda>x.\n         \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         list_all ((=) 0) (map get_param (a # gs))", "case Nil"], ["proof (state)\nthis:\n  ?g \\<in> set (map get_fun []) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>g.\n                g \\<in> set (map get_fun []) \\<Longrightarrow>\n                filterlim g at_top F;\n     landau_dominating_chain' F (map get_fun [])\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n                       \\<in> \\<Theta>[F](\\<lambda>x.\n      \\<Prod>g\\<leftarrow>[]. get_fun g x powr get_param g)) =\n                      list_all ((=) 0) (map get_param [])\n 2. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> \\<Theta>[F](\\<lambda>x.\n                  \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  list_all ((=) 0) (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> \\<Theta>[F](\\<lambda>x.\n         \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         list_all ((=) 0) (map get_param (a # gs))", "then"], ["proof (chain)\npicking this:\n  ?g \\<in> set (map get_fun []) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun [])", "show ?case"], ["proof (prove)\nusing this:\n  ?g \\<in> set (map get_fun []) \\<Longrightarrow> filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun [])\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>[]. get_fun g x powr\n            get_param g)) =\n    list_all ((=) 0) (map get_param [])", "by (simp add: func_one)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>[]. get_fun g x powr 0)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>[]. get_fun g x powr\n          get_param g)) =\n  list_all ((=) 0) (map get_param [])\n\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> \\<Theta>[F](\\<lambda>x.\n                  \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  list_all ((=) 0) (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> \\<Theta>[F](\\<lambda>x.\n         \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         list_all ((=) 0) (map get_param (a # gs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> \\<Theta>[F](\\<lambda>x.\n                  \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  list_all ((=) 0) (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> \\<Theta>[F](\\<lambda>x.\n         \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         list_all ((=) 0) (map get_param (a # gs))", "case (Cons g gs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> \\<Theta>[F](\\<lambda>x.\n    \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                    list_all ((=) 0) (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> \\<Theta>[F](\\<lambda>x.\n                  \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  list_all ((=) 0) (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> \\<Theta>[F](\\<lambda>x.\n         \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         list_all ((=) 0) (map get_param (a # gs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> \\<Theta>[F](\\<lambda>x.\n    \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                    list_all ((=) 0) (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))", "interpret G: landau_function_family_pair F \"powr_closure (get_fun g)\"\n       \"prod_list (map powr_closure (map get_fun gs))\" \"\\<lambda>x. get_fun g x powr 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> \\<Theta>[F](\\<lambda>x.\n    \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                    list_all ((=) 0) (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n\ngoal (1 subgoal):\n 1. landau_function_family_pair F (powr_closure (get_fun g))\n     (prod_list (map powr_closure (map get_fun gs)))\n     (\\<lambda>x. get_fun g x powr 1)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a gs.\n       \\<lbrakk>\\<lbrakk>\\<And>g.\n                            g \\<in> set (map get_fun gs) \\<Longrightarrow>\n                            filterlim g at_top F;\n                 landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x.\n \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                                   \\<in> \\<Theta>[F](\\<lambda>x.\n                  \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                                  list_all ((=) 0) (map get_param gs);\n        \\<And>g.\n           g \\<in> set (map get_fun (a # gs)) \\<Longrightarrow>\n           filterlim g at_top F;\n        landau_dominating_chain' F (map get_fun (a # gs))\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              \\<Prod>g\\<leftarrow>a #\n            gs. get_fun g x powr 0)\n                          \\<in> \\<Theta>[F](\\<lambda>x.\n         \\<Prod>g\\<leftarrow>a # gs. get_fun g x powr get_param g)) =\n                         list_all ((=) 0) (map get_param (a # gs))", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> \\<Theta>[F](\\<lambda>x.\n    \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                    list_all ((=) 0) (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> \\<Theta>[F](\\<lambda>x.\n    \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                    list_all ((=) 0) (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>g #\n        gs. get_fun g x powr get_param g)) =\n    list_all ((=) 0) (map get_param (g # gs))", "using listmap_gs_in_listmap[of get_fun _ gs] F_nontrivial"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>g.\n              g \\<in> set (map get_fun gs) \\<Longrightarrow>\n              filterlim g at_top F;\n   landau_dominating_chain' F (map get_fun gs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n                     \\<in> \\<Theta>[F](\\<lambda>x.\n    \\<Prod>g\\<leftarrow>gs. get_fun g x powr get_param g)) =\n                    list_all ((=) 0) (map get_param gs)\n  ?g \\<in> set (map get_fun (g # gs)) \\<Longrightarrow>\n  filterlim ?g at_top F\n  landau_dominating_chain' F (map get_fun (g # gs))\n  (\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr ?p g)\n  \\<in> prod_list (map powr_closure (map get_fun gs))\n  F \\<noteq> bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>g #\n        gs. get_fun g x powr get_param g)) =\n    list_all ((=) 0) (map get_param (g # gs))", "by (simp_all add: G.bigtheta_iff listmap_gs_in_listmap powr_smallo_iff powr_bigtheta_iff\n                   del: powr_zero_eq_one)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>g # gs. get_fun g x powr 0)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>g #\n      gs. get_fun g x powr get_param g)) =\n  list_all ((=) 0) (map get_param (g # gs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<Prod>g\\<leftarrow>gs. get_fun g x powr 0)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n          get_param g)) =\n  list_all ((=) 0) (map get_param gs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n            get_param g)) =\n    list_all ((=) 0) (map get_param gs)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>_. 1)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n          get_param g)) =\n  list_all ((=) 0) (map get_param gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>_. 1)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n          get_param g)) =\n  list_all ((=) 0) (map get_param gs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1)\n     \\<in> \\<Theta>[F](\\<lambda>x.\n                          \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n            get_param g)) =\n    list_all ((=) 0) (map get_param gs)", "."], ["proof (state)\nthis:\n  ((\\<lambda>_. 1)\n   \\<in> \\<Theta>[F](\\<lambda>x.\n                        \\<Prod>g\\<leftarrow>gs. get_fun g x powr\n          get_param g)) =\n  list_all ((=) 0) (map get_param gs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma fun_chain_at_top_at_top:\n  assumes \"filterlim (f :: ('a::order) \\<Rightarrow> 'a) at_top at_top\"\n  shows   \"filterlim (f ^^ n) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim (f ^^ n) at_top at_top", "by (induction n) (auto intro: filterlim_ident filterlim_compose[OF assms])"], ["", "lemma const_smallo_ln_chain: \"(\\<lambda>_. 1) \\<in> o((ln::real\\<Rightarrow>real)^^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. 1) \\<in> o(ln ^^ n)", "proof (intro smalloI_tendsto)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. 1 / (ln ^^ n) x) \\<longlongrightarrow> 0) at_top\n 2. \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x \\<noteq> 0", "show \"((\\<lambda>x::real. 1 / (ln^^n) x) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. 1 / (ln ^^ n) x) \\<longlongrightarrow> 0) at_top", "by (rule tendsto_divide_0 tendsto_const filterlim_at_top_imp_at_infinity\n             fun_chain_at_top_at_top ln_at_top)+"], ["proof (state)\nthis:\n  ((\\<lambda>x. 1 / (ln ^^ n) x) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x \\<noteq> 0", "from fun_chain_at_top_at_top[OF ln_at_top, of n]"], ["proof (chain)\npicking this:\n  filterlim (ln ^^ n) at_top at_top", "have \"eventually (\\<lambda>x::real. (ln^^n) x > 0) at_top\""], ["proof (prove)\nusing this:\n  filterlim (ln ^^ n) at_top at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x", "by (simp add: filterlim_at_top_dense)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x \\<noteq> 0", "thus \"eventually (\\<lambda>x::real. (ln^^n) x \\<noteq> 0) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x \\<noteq> 0", "by eventually_elim simp_all"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ln_fun_in_smallo_fun:\n  assumes \"filterlim f at_top at_top\"\n  shows   \"(\\<lambda>x. ln (f x) powr p :: real) \\<in> o(f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ln (f x) powr p) \\<in> o(f)", "proof (rule smalloI_tendsto)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. ln (f x) powr p / f x) \\<longlongrightarrow> 0) at_top\n 2. \\<forall>\\<^sub>F x in at_top. f x \\<noteq> 0", "have \"((\\<lambda>x. ln x powr p / x powr 1) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr p / x powr 1) \\<longlongrightarrow> 0) at_top", "by (rule tendsto_ln_powr_over_powr') simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. ln x powr p / x powr 1) \\<longlongrightarrow> 0) at_top\n\ngoal (2 subgoals):\n 1. ((\\<lambda>x. ln (f x) powr p / f x) \\<longlongrightarrow> 0) at_top\n 2. \\<forall>\\<^sub>F x in at_top. f x \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>x. ln x powr p / x powr 1) \\<longlongrightarrow> 0) at_top\n\ngoal (2 subgoals):\n 1. ((\\<lambda>x. ln (f x) powr p / f x) \\<longlongrightarrow> 0) at_top\n 2. \\<forall>\\<^sub>F x in at_top. f x \\<noteq> 0", "have \"eventually (\\<lambda>x. ln x powr p / x powr 1 = ln x powr p / x) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln x powr p / x powr 1 = ln x powr p / x", "using eventually_gt_at_top[of \"0::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln x powr p / x powr 1 = ln x powr p / x", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. ln x powr p / x powr 1 = ln x powr p / x\n\ngoal (2 subgoals):\n 1. ((\\<lambda>x. ln (f x) powr p / f x) \\<longlongrightarrow> 0) at_top\n 2. \\<forall>\\<^sub>F x in at_top. f x \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. ln x powr p / x powr 1) \\<longlongrightarrow> 0) at_top\n  \\<forall>\\<^sub>F x in at_top. ln x powr p / x powr 1 = ln x powr p / x", "have \"((\\<lambda>x. ln x powr p / x) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. ln x powr p / x powr 1) \\<longlongrightarrow> 0) at_top\n  \\<forall>\\<^sub>F x in at_top. ln x powr p / x powr 1 = ln x powr p / x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln x powr p / x) \\<longlongrightarrow> 0) at_top", "by (subst (asm) tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>x. ln x powr p / x) \\<longlongrightarrow> 0) at_top\n\ngoal (2 subgoals):\n 1. ((\\<lambda>x. ln (f x) powr p / f x) \\<longlongrightarrow> 0) at_top\n 2. \\<forall>\\<^sub>F x in at_top. f x \\<noteq> 0", "from this assms"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. ln x powr p / x) \\<longlongrightarrow> 0) at_top\n  filterlim f at_top at_top", "show \"((\\<lambda>x. ln (f x) powr p / f x) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. ln x powr p / x) \\<longlongrightarrow> 0) at_top\n  filterlim f at_top at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln (f x) powr p / f x) \\<longlongrightarrow> 0) at_top", "by (rule filterlim_compose)"], ["proof (state)\nthis:\n  ((\\<lambda>x. ln (f x) powr p / f x) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. f x \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  filterlim f at_top at_top", "have \"eventually (\\<lambda>x. f x \\<ge> 1) at_top\""], ["proof (prove)\nusing this:\n  filterlim f at_top at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 1 \\<le> f x", "by (simp add: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. 1 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. f x \\<noteq> 0", "thus \"eventually (\\<lambda>x. f x \\<noteq> 0) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 1 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. f x \\<noteq> 0", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. f x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ln_chain_dominates: \"m > n \\<Longrightarrow> dominates at_top ((ln::real \\<Rightarrow> real)^^n) (ln^^m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m \\<Longrightarrow> dominates at_top (ln ^^ n) (ln ^^ m)", "proof (erule less_Suc_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. dominates at_top (ln ^^ i) (ln ^^ Suc i)\n 2. \\<And>i j k.\n       \\<lbrakk>i < j; j < k; dominates at_top (ln ^^ i) (ln ^^ j);\n        dominates at_top (ln ^^ j) (ln ^^ k)\\<rbrakk>\n       \\<Longrightarrow> dominates at_top (ln ^^ i) (ln ^^ k)", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. dominates at_top (ln ^^ i) (ln ^^ Suc i)\n 2. \\<And>i j k.\n       \\<lbrakk>i < j; j < k; dominates at_top (ln ^^ i) (ln ^^ j);\n        dominates at_top (ln ^^ j) (ln ^^ k)\\<rbrakk>\n       \\<Longrightarrow> dominates at_top (ln ^^ i) (ln ^^ k)", "show \"dominates at_top ((ln::real\\<Rightarrow>real)^^n) (ln^^(Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dominates at_top (ln ^^ n) (ln ^^ Suc n)", "unfolding dominates_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. (\\<lambda>x. (ln ^^ Suc n) x powr p) \\<in> o(ln ^^ n)", "by (force intro: ln_fun_in_smallo_fun fun_chain_at_top_at_top ln_at_top)"], ["proof (state)\nthis:\n  dominates at_top (ln ^^ n) (ln ^^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < j; j < k; dominates at_top (ln ^^ i) (ln ^^ j);\n        dominates at_top (ln ^^ j) (ln ^^ k)\\<rbrakk>\n       \\<Longrightarrow> dominates at_top (ln ^^ i) (ln ^^ k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < j; j < k; dominates at_top (ln ^^ i) (ln ^^ j);\n        dominates at_top (ln ^^ j) (ln ^^ k)\\<rbrakk>\n       \\<Longrightarrow> dominates at_top (ln ^^ i) (ln ^^ k)", "fix k m n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < j; j < k; dominates at_top (ln ^^ i) (ln ^^ j);\n        dominates at_top (ln ^^ j) (ln ^^ k)\\<rbrakk>\n       \\<Longrightarrow> dominates at_top (ln ^^ i) (ln ^^ k)", "assume A: \"dominates at_top ((ln::real \\<Rightarrow> real)^^k) (ln^^m)\"\n            \"dominates at_top ((ln::real \\<Rightarrow> real)^^m) (ln^^n)\""], ["proof (state)\nthis:\n  dominates at_top (ln ^^ k) (ln ^^ m)\n  dominates at_top (ln ^^ m) (ln ^^ n)\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < j; j < k; dominates at_top (ln ^^ i) (ln ^^ j);\n        dominates at_top (ln ^^ j) (ln ^^ k)\\<rbrakk>\n       \\<Longrightarrow> dominates at_top (ln ^^ i) (ln ^^ k)", "from fun_chain_at_top_at_top[OF ln_at_top, of m]"], ["proof (chain)\npicking this:\n  filterlim (ln ^^ m) at_top at_top", "have \"eventually (\\<lambda>x::real. (ln^^m) x > 0) at_top\""], ["proof (prove)\nusing this:\n  filterlim (ln ^^ m) at_top at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ m) x", "by (simp add: filterlim_at_top_dense)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ m) x\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < j; j < k; dominates at_top (ln ^^ i) (ln ^^ j);\n        dominates at_top (ln ^^ j) (ln ^^ k)\\<rbrakk>\n       \\<Longrightarrow> dominates at_top (ln ^^ i) (ln ^^ k)", "from this A"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ m) x\n  dominates at_top (ln ^^ k) (ln ^^ m)\n  dominates at_top (ln ^^ m) (ln ^^ n)", "show \"dominates at_top ((ln::real \\<Rightarrow> real)^^k) ((ln::real \\<Rightarrow> real)^^n)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ m) x\n  dominates at_top (ln ^^ k) (ln ^^ m)\n  dominates at_top (ln ^^ m) (ln ^^ n)\n\ngoal (1 subgoal):\n 1. dominates at_top (ln ^^ k) (ln ^^ n)", "by (rule dominates_trans)"], ["proof (state)\nthis:\n  dominates at_top (ln ^^ k) (ln ^^ n)\n\ngoal:\nNo subgoals!", "qed"], ["", "datatype primfun = LnChain nat"], ["", "instantiation primfun :: linorder\nbegin"], ["", "fun less_eq_primfun :: \"primfun \\<Rightarrow> primfun \\<Rightarrow> bool\" where\n  \"LnChain x \\<le> LnChain y \\<longleftrightarrow> x \\<le> y\""], ["", "fun less_primfun :: \"primfun \\<Rightarrow> primfun \\<Rightarrow> bool\" where\n  \"LnChain x < LnChain y \\<longleftrightarrow> x < y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(primfun, linorder_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (1 x y)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (induction x y rule: less_eq_primfun.induct) auto"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (2 x)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by (cases x) auto"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (3 x y z)"], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> z\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by (induction x y rule: less_eq_primfun.induct, cases z) auto"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (4 x y)"], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "by (induction x y rule: less_eq_primfun.induct) auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (5 x y)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<or> y \\<le> x", "by (induction x y rule: less_eq_primfun.induct) auto"], ["proof (state)\nthis:\n  x \\<le> y \\<or> y \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun eval_primfun' :: \"_ \\<Rightarrow> _ \\<Rightarrow> real\" where\n  \"eval_primfun' (LnChain n) = (\\<lambda>x. (ln^^n) x)\""], ["", "fun eval_primfun :: \"_ \\<Rightarrow> _ \\<Rightarrow> real\" where\n  \"eval_primfun (f, e) = (\\<lambda>x. eval_primfun' f x powr e)\""], ["", "lemma eval_primfun_altdef: \"eval_primfun f x = eval_primfun' (fst f) x powr snd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_primfun f x = eval_primfun' (fst f) x powr snd f", "by (cases f) simp"], ["", "fun merge_primfun where\n  \"merge_primfun (x::primfun, a) (y, b) = (x, a + b)\""], ["", "fun inverse_primfun where\n  \"inverse_primfun (x::primfun, a) = (x, -a)\""], ["", "fun powr_primfun where\n  \"powr_primfun (x::primfun, a) e = (x, e*a)\""], ["", "lemma primfun_cases:\n  assumes \"(\\<And>n e. P (LnChain n, e))\"\n  shows   \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "proof (cases x, hypsubst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. x = (a, b) \\<Longrightarrow> P (a, b)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. x = (a, b) \\<Longrightarrow> P (a, b)", "show \"P (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (a, b)", "by (cases a; hypsubst, rule assms)"], ["proof (state)\nthis:\n  P (a, b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_primfun'_at_top: \"filterlim (eval_primfun' f) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim (eval_primfun' f) at_top at_top", "by (cases f) (auto intro!: fun_chain_at_top_at_top ln_at_top)"], ["", "lemma primfun_dominates:\n  \"f < g \\<Longrightarrow> dominates at_top (eval_primfun' f) (eval_primfun' g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f < g \\<Longrightarrow>\n    dominates at_top (eval_primfun' f) (eval_primfun' g)", "by (elim less_primfun.elims; hypsubst) (simp_all add: ln_chain_dominates)"], ["", "lemma eval_primfun_pos: \"eventually (\\<lambda>x::real. eval_primfun f x > 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun f x", "proof (cases f, hypsubst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       f = (a, b) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun (a, b) x", "fix f e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       f = (a, b) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun (a, b) x", "from eval_primfun'_at_top"], ["proof (chain)\npicking this:\n  filterlim (eval_primfun' ?f) at_top at_top", "have \"eventually (\\<lambda>x. eval_primfun' f x > 0) at_top\""], ["proof (prove)\nusing this:\n  filterlim (eval_primfun' ?f) at_top at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun' f x", "by (auto simp: filterlim_at_top_dense)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun' f x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       f = (a, b) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun (a, b) x", "thus \"eventually (\\<lambda>x::real. eval_primfun (f,e) x > 0) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun' f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun (f, e) x", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun (f, e) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eventually_nonneg_primfun: \"eventually_nonneg at_top (eval_primfun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually_nonneg at_top (eval_primfun f)", "unfolding eventually_nonneg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 \\<le> eval_primfun f x", "using eval_primfun_pos[of f]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 \\<le> eval_primfun f x", "by eventually_elim simp"], ["", "lemma eval_primfun_nonzero: \"eventually (\\<lambda>x. eval_primfun f x \\<noteq> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. eval_primfun f x \\<noteq> 0", "using eval_primfun_pos[of f]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. eval_primfun f x \\<noteq> 0", "by eventually_elim simp"], ["", "lemma eval_merge_primfun:\n  \"fst f = fst g \\<Longrightarrow>\n     eval_primfun (merge_primfun f g) x = eval_primfun f x * eval_primfun g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst f = fst g \\<Longrightarrow>\n    eval_primfun (merge_primfun f g) x = eval_primfun f x * eval_primfun g x", "by (induction f g rule: merge_primfun.induct) (simp_all add: powr_add)"], ["", "lemma eval_inverse_primfun:\n  \"eval_primfun (inverse_primfun f) x = inverse (eval_primfun f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_primfun (inverse_primfun f) x = inverse (eval_primfun f x)", "by (induction f rule: inverse_primfun.induct) (simp_all add: powr_minus)"], ["", "lemma eval_powr_primfun:\n  \"eval_primfun (powr_primfun f e) x = eval_primfun f x powr e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_primfun (powr_primfun f e) x = eval_primfun f x powr e", "by (induction f e rule: powr_primfun.induct) (simp_all add: powr_powr mult.commute)"], ["", "definition eval_primfuns where\n  \"eval_primfuns fs x = (\\<Prod>f\\<leftarrow>fs. eval_primfun f x)\""], ["", "lemma eval_primfuns_pos: \"eventually (\\<lambda>x. eval_primfuns fs x > 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < eval_primfuns fs x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < eval_primfuns fs x", "have prod_list_pos: \"(\\<And>x::_::linordered_semidom. x \\<in> set xs \\<Longrightarrow> x > 0) \\<Longrightarrow> prod_list xs > 0\"\n    for xs :: \"real list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set xs \\<Longrightarrow> 0 < x) \\<Longrightarrow>\n    0 < prod_list xs", "by (induction xs) auto"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> set ?xs \\<Longrightarrow> 0 < x) \\<Longrightarrow>\n  0 < prod_list ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < eval_primfuns fs x", "have \"eventually (\\<lambda>x. \\<forall>f\\<in>set fs. eval_primfun f x > 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       \\<forall>f\\<in>set fs. 0 < eval_primfun f x", "by (intro eventually_ball_finite ballI eval_primfun_pos finite_set)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. \\<forall>f\\<in>set fs. 0 < eval_primfun f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < eval_primfuns fs x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. \\<forall>f\\<in>set fs. 0 < eval_primfun f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < eval_primfuns fs x", "unfolding eval_primfuns_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. \\<forall>f\\<in>set fs. 0 < eval_primfun f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       0 < (\\<Prod>f\\<leftarrow>fs. eval_primfun f x)", "by eventually_elim (rule prod_list_pos, auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. 0 < eval_primfuns fs x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_primfuns_nonzero: \"eventually (\\<lambda>x. eval_primfuns fs x \\<noteq> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. eval_primfuns fs x \\<noteq> 0", "using eval_primfuns_pos[of fs]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 0 < eval_primfuns fs x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. eval_primfuns fs x \\<noteq> 0", "by eventually_elim simp"], ["", "subsection \\<open>Reification\\<close>"], ["", "definition LANDAU_PROD' where\n  \"LANDAU_PROD' L c f = L(\\<lambda>x. c * f x)\""], ["", "definition LANDAU_PROD where\n  \"LANDAU_PROD L c1 c2 fs \\<longleftrightarrow> (\\<lambda>_. c1) \\<in> L(\\<lambda>x. c2 * eval_primfuns fs x)\""], ["", "definition BIGTHETA_CONST' where \"BIGTHETA_CONST' c = \\<Theta>(\\<lambda>x. c)\""], ["", "definition BIGTHETA_CONST where \"BIGTHETA_CONST c A = set_mult \\<Theta>(\\<lambda>_. c) A\""], ["", "definition BIGTHETA_FUN where \"BIGTHETA_FUN f = \\<Theta>(f)\""], ["", "lemma BIGTHETA_CONST'_tag: \"\\<Theta>(\\<lambda>x. c) = BIGTHETA_CONST' c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. c) = BIGTHETA_CONST' c", "using BIGTHETA_CONST'_def"], ["proof (prove)\nusing this:\n  BIGTHETA_CONST' ?c = \\<Theta>(\\<lambda>x. ?c)\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. c) = BIGTHETA_CONST' c", ".."], ["", "lemma BIGTHETA_CONST_tag: \"\\<Theta>(f) = BIGTHETA_CONST 1 \\<Theta>(f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(f) = BIGTHETA_CONST (1::'b) \\<Theta>(f)", "by (simp add: BIGTHETA_CONST_def bigtheta_mult_eq_set_mult[symmetric])"], ["", "lemma BIGTHETA_FUN_tag: \"\\<Theta>(f) = BIGTHETA_FUN f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(f) = BIGTHETA_FUN f", "by (simp add: BIGTHETA_FUN_def)"], ["", "lemma set_mult_is_times: \"set_mult A B = A * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mult A B = A * B", "unfolding set_mult_def set_times_def func_times"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>x. f x * g x |f g. f \\<in> A \\<and> g \\<in> B} =\n    {c. \\<exists>a\\<in>A. \\<exists>b\\<in>B. c = (\\<lambda>x. a x * b x)}", "by blast"], ["", "lemma set_powr_mult:\n  assumes \"eventually_nonneg F f\" and \"eventually_nonneg F g\"\n  shows   \"\\<Theta>[F](\\<lambda>x. (f x * g x :: real) powr p) = set_mult (\\<Theta>[F](\\<lambda>x. f x powr p)) (\\<Theta>[F](\\<lambda>x. g x powr p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n    set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n     \\<Theta>[F](\\<lambda>x. g x powr p)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n    set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n     \\<Theta>[F](\\<lambda>x. g x powr p)", "from assms"], ["proof (chain)\npicking this:\n  eventually_nonneg F f\n  eventually_nonneg F g", "have \"eventually (\\<lambda>x. f x \\<ge> 0) F\" \"eventually (\\<lambda>x. g x \\<ge> 0) F\""], ["proof (prove)\nusing this:\n  eventually_nonneg F f\n  eventually_nonneg F g\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 \\<le> f x &&&\n    \\<forall>\\<^sub>F x in F. 0 \\<le> g x", "by (simp_all add: eventually_nonneg_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n  \\<forall>\\<^sub>F x in F. 0 \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n    set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n     \\<Theta>[F](\\<lambda>x. g x powr p)", "hence \"eventually (\\<lambda>x. (f x * g x :: real) powr p = f x powr p * g x powr p) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n  \\<forall>\\<^sub>F x in F. 0 \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. (f x * g x) powr p = f x powr p * g x powr p", "by eventually_elim (simp add: powr_mult)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. (f x * g x) powr p = f x powr p * g x powr p\n\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n    set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n     \\<Theta>[F](\\<lambda>x. g x powr p)", "hence \"\\<Theta>[F](\\<lambda>x. (f x * g x :: real) powr p) = \\<Theta>[F](\\<lambda>x. f x powr p * g x powr p)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. (f x * g x) powr p = f x powr p * g x powr p\n\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n    \\<Theta>[F](\\<lambda>x. f x powr p * g x powr p)", "by (rule landau_theta.cong)"], ["proof (state)\nthis:\n  \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n  \\<Theta>[F](\\<lambda>x. f x powr p * g x powr p)\n\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n    set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n     \\<Theta>[F](\\<lambda>x. g x powr p)", "also"], ["proof (state)\nthis:\n  \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n  \\<Theta>[F](\\<lambda>x. f x powr p * g x powr p)\n\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n    set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n     \\<Theta>[F](\\<lambda>x. g x powr p)", "have \"... = set_mult (\\<Theta>[F](\\<lambda>x. f x powr p)) (\\<Theta>[F](\\<lambda>x. g x powr p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. f x powr p * g x powr p) =\n    set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n     \\<Theta>[F](\\<lambda>x. g x powr p)", "by (simp add: bigtheta_mult_eq_set_mult)"], ["proof (state)\nthis:\n  \\<Theta>[F](\\<lambda>x. f x powr p * g x powr p) =\n  set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n   \\<Theta>[F](\\<lambda>x. g x powr p)\n\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n    set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n     \\<Theta>[F](\\<lambda>x. g x powr p)", "finally"], ["proof (chain)\npicking this:\n  \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n  set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n   \\<Theta>[F](\\<lambda>x. g x powr p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n  set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n   \\<Theta>[F](\\<lambda>x. g x powr p)\n\ngoal (1 subgoal):\n 1. \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n    set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n     \\<Theta>[F](\\<lambda>x. g x powr p)", "."], ["proof (state)\nthis:\n  \\<Theta>[F](\\<lambda>x. (f x * g x) powr p) =\n  set_mult \\<Theta>[F](\\<lambda>x. f x powr p)\n   \\<Theta>[F](\\<lambda>x. g x powr p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eventually_nonneg_bigtheta_pow_realpow:\n  \"\\<Theta>(\\<lambda>x. eval_primfun f x ^ e) = \\<Theta>(\\<lambda>x. eval_primfun f x powr real e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. eval_primfun f x ^ e) =\n    \\<Theta>(\\<lambda>x. eval_primfun f x powr real e)", "using eval_primfun_pos[of f]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 0 < eval_primfun f x\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. eval_primfun f x ^ e) =\n    \\<Theta>(\\<lambda>x. eval_primfun f x powr real e)", "by (auto intro!: landau_theta.cong elim!: eventually_mono simp: powr_realpow)"], ["", "lemma BIGTHETA_CONST_fold:\n  \"BIGTHETA_CONST (c::real) (BIGTHETA_CONST d A) = BIGTHETA_CONST (c*d) A\"\n  \"bigtheta_pow at_top (BIGTHETA_CONST c \\<Theta>(eval_primfun pf)) k =\n     BIGTHETA_CONST (c ^ k) \\<Theta>(\\<lambda>x. eval_primfun pf x powr k)\"\n  \"set_inverse (BIGTHETA_CONST c \\<Theta>(f)) = BIGTHETA_CONST (inverse c) \\<Theta>(\\<lambda>x. inverse (f x))\"\n  \"set_mult (BIGTHETA_CONST c \\<Theta>(f)) (BIGTHETA_CONST d \\<Theta>(g)) =\n     BIGTHETA_CONST (c*d) \\<Theta>(\\<lambda>x. f x*g x)\"\n  \"BIGTHETA_CONST' (c::real) = BIGTHETA_CONST c \\<Theta>(\\<lambda>_. 1)\"\n  \"BIGTHETA_FUN (f::real\\<Rightarrow>real) = BIGTHETA_CONST 1 \\<Theta>(f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BIGTHETA_CONST c (BIGTHETA_CONST d A) = BIGTHETA_CONST (c * d) A &&&\n     bigtheta_pow at_top (BIGTHETA_CONST c \\<Theta>(eval_primfun pf)) k =\n     BIGTHETA_CONST (c ^ k)\n      \\<Theta>(\\<lambda>x. eval_primfun pf x powr real k) &&&\n     set_inverse (BIGTHETA_CONST c \\<Theta>(f)) =\n     BIGTHETA_CONST (inverse c) \\<Theta>(\\<lambda>x. inverse (f x))) &&&\n    set_mult (BIGTHETA_CONST c \\<Theta>(f)) (BIGTHETA_CONST d \\<Theta>(g)) =\n    BIGTHETA_CONST (c * d) \\<Theta>(\\<lambda>x. f x * g x) &&&\n    BIGTHETA_CONST' c = BIGTHETA_CONST c \\<Theta>(\\<lambda>_. 1) &&&\n    BIGTHETA_FUN f = BIGTHETA_CONST 1 \\<Theta>(f)", "apply (simp add: BIGTHETA_CONST_def set_mult_is_times bigtheta_mult_eq_set_mult mult_ac)"], ["proof (prove)\ngoal (5 subgoals):\n 1. bigtheta_pow at_top (BIGTHETA_CONST c \\<Theta>(eval_primfun pf)) k =\n    BIGTHETA_CONST (c ^ k)\n     \\<Theta>(\\<lambda>x. eval_primfun pf x powr real k)\n 2. set_inverse (BIGTHETA_CONST c \\<Theta>(f)) =\n    BIGTHETA_CONST (inverse c) \\<Theta>(\\<lambda>x. inverse (f x))\n 3. set_mult (BIGTHETA_CONST c \\<Theta>(f)) (BIGTHETA_CONST d \\<Theta>(g)) =\n    BIGTHETA_CONST (c * d) \\<Theta>(\\<lambda>x. f x * g x)\n 4. BIGTHETA_CONST' c = BIGTHETA_CONST c \\<Theta>(\\<lambda>_. 1)\n 5. BIGTHETA_FUN f = BIGTHETA_CONST 1 \\<Theta>(f)", "apply (simp only: BIGTHETA_CONST_def bigtheta_mult_eq_set_mult[symmetric]\n           bigtheta_pow_eq_set_pow[symmetric] power_mult_distrib mult_ac)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<Theta>(\\<lambda>x. c ^ k * eval_primfun pf x ^ k) =\n    \\<Theta>(\\<lambda>x. c ^ k * eval_primfun pf x powr real k)\n 2. set_inverse (BIGTHETA_CONST c \\<Theta>(f)) =\n    BIGTHETA_CONST (inverse c) \\<Theta>(\\<lambda>x. inverse (f x))\n 3. set_mult (BIGTHETA_CONST c \\<Theta>(f)) (BIGTHETA_CONST d \\<Theta>(g)) =\n    BIGTHETA_CONST (c * d) \\<Theta>(\\<lambda>x. f x * g x)\n 4. BIGTHETA_CONST' c = BIGTHETA_CONST c \\<Theta>(\\<lambda>_. 1)\n 5. BIGTHETA_FUN f = BIGTHETA_CONST 1 \\<Theta>(f)", "apply (simp add: bigtheta_mult_eq_set_mult eventually_nonneg_bigtheta_pow_realpow)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set_inverse (BIGTHETA_CONST c \\<Theta>(f)) =\n    BIGTHETA_CONST (inverse c) \\<Theta>(\\<lambda>x. inverse (f x))\n 2. set_mult (BIGTHETA_CONST c \\<Theta>(f)) (BIGTHETA_CONST d \\<Theta>(g)) =\n    BIGTHETA_CONST (c * d) \\<Theta>(\\<lambda>x. f x * g x)\n 3. BIGTHETA_CONST' c = BIGTHETA_CONST c \\<Theta>(\\<lambda>_. 1)\n 4. BIGTHETA_FUN f = BIGTHETA_CONST 1 \\<Theta>(f)", "by (simp_all add: BIGTHETA_CONST_def BIGTHETA_CONST'_def BIGTHETA_FUN_def\n        bigtheta_mult_eq_set_mult[symmetric] set_mult_is_times[symmetric]\n        bigtheta_pow_eq_set_pow[symmetric] bigtheta_inverse_eq_set_inverse[symmetric]\n        mult_ac power_mult_distrib)"], ["", "lemma fold_fun_chain:\n  \"g x = (g ^^ 1) x\" \"(g ^^ m) ((g ^^ n) x) = (g ^^ (m+n)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x = (g ^^ 1) x &&& (g ^^ m) ((g ^^ n) x) = (g ^^ (m + n)) x", "by (simp_all add: funpow_add)"], ["", "lemma reify_ln_chain1:\n  \"\\<Theta>(\\<lambda>x. (ln ^^ n) x) = \\<Theta>(eval_primfun (LnChain n, 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(ln ^^ n) = \\<Theta>(eval_primfun (LnChain n, 1))", "proof (intro landau_theta.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       (ln ^^ n) x = eval_primfun (LnChain n, 1) x", "have \"filterlim ((ln :: real \\<Rightarrow> real) ^^ n) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim (ln ^^ n) at_top at_top", "by (intro fun_chain_at_top_at_top ln_at_top)"], ["proof (state)\nthis:\n  filterlim (ln ^^ n) at_top at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       (ln ^^ n) x = eval_primfun (LnChain n, 1) x", "hence \"eventually (\\<lambda>x::real. (ln ^^ n) x > 0) at_top\""], ["proof (prove)\nusing this:\n  filterlim (ln ^^ n) at_top at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x", "using filterlim_at_top_dense"], ["proof (prove)\nusing this:\n  filterlim (ln ^^ n) at_top at_top\n  filterlim ?f at_top ?F = (\\<forall>Z. \\<forall>\\<^sub>F x in ?F. Z < ?f x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       (ln ^^ n) x = eval_primfun (LnChain n, 1) x", "thus \"eventually (\\<lambda>x. (ln ^^ n) x = eval_primfun (LnChain n, 1) x) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       (ln ^^ n) x = eval_primfun (LnChain n, 1) x", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x = eval_primfun (LnChain n, 1) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reify_monom1:\n  \"\\<Theta>(\\<lambda>x::real. x) = \\<Theta>(eval_primfun (LnChain 0, 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x) = \\<Theta>(eval_primfun (LnChain 0, 1))", "proof (intro landau_theta.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x = eval_primfun (LnChain 0, 1) x", "from eventually_gt_at_top[of \"0::real\"]"], ["proof (chain)\npicking this:\n  eventually ((<) 0) at_top", "show \"eventually (\\<lambda>x. x = eval_primfun (LnChain 0, 1) x) at_top\""], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x = eval_primfun (LnChain 0, 1) x", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. x = eval_primfun (LnChain 0, 1) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reify_monom_pow:\n  \"\\<Theta>(\\<lambda>x::real. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))", "have \"\\<Theta>(eval_primfun (LnChain 0, real e)) = \\<Theta>(\\<lambda>x. x powr (real e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(eval_primfun (LnChain 0, real e)) =\n    \\<Theta>(\\<lambda>x. x powr real e)", "by simp"], ["proof (state)\nthis:\n  \\<Theta>(eval_primfun (LnChain 0, real e)) =\n  \\<Theta>(\\<lambda>x. x powr real e)\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))", "also"], ["proof (state)\nthis:\n  \\<Theta>(eval_primfun (LnChain 0, real e)) =\n  \\<Theta>(\\<lambda>x. x powr real e)\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))", "have \"eventually (\\<lambda>x. x powr (real e) = x ^ e) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x powr real e = x ^ e", "using eventually_gt_at_top[of 0]"], ["proof (prove)\nusing this:\n  eventually ((<) (0::?'a1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. x powr real e = x ^ e", "by eventually_elim (simp add: powr_realpow)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. x powr real e = x ^ e\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))", "hence \"\\<Theta>(\\<lambda>x. x powr (real e)) = \\<Theta>(\\<lambda>x. x ^ e)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. x powr real e = x ^ e\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x powr real e) = \\<Theta>(\\<lambda>x. x ^ e)", "by (rule landau_theta.cong)"], ["proof (state)\nthis:\n  \\<Theta>(\\<lambda>x. x powr real e) = \\<Theta>(\\<lambda>x. x ^ e)\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))", "finally"], ["proof (chain)\npicking this:\n  \\<Theta>(eval_primfun (LnChain 0, real e)) = \\<Theta>(\\<lambda>x. x ^ e)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>(eval_primfun (LnChain 0, real e)) = \\<Theta>(\\<lambda>x. x ^ e)\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))", ".."], ["proof (state)\nthis:\n  \\<Theta>(\\<lambda>x. x ^ e) = \\<Theta>(eval_primfun (LnChain 0, real e))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reify_monom_powr:\n  \"\\<Theta>(\\<lambda>x::real. x powr e) = \\<Theta>(eval_primfun (LnChain 0, e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. x powr e) = \\<Theta>(eval_primfun (LnChain 0, e))", "by (rule landau_theta.cong) simp"], ["", "lemmas reify_monom = reify_monom1 reify_monom_pow reify_monom_powr"], ["", "lemma reify_ln_chain_pow:\n  \"\\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) = \\<Theta>(eval_primfun (LnChain n, real e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) =\n    \\<Theta>(eval_primfun (LnChain n, real e))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) =\n    \\<Theta>(eval_primfun (LnChain n, real e))", "have \"\\<Theta>(eval_primfun (LnChain n, real e)) = \\<Theta>(\\<lambda>x. (ln ^^ n) x powr (real e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(eval_primfun (LnChain n, real e)) =\n    \\<Theta>(\\<lambda>x. (ln ^^ n) x powr real e)", "by simp"], ["proof (state)\nthis:\n  \\<Theta>(eval_primfun (LnChain n, real e)) =\n  \\<Theta>(\\<lambda>x. (ln ^^ n) x powr real e)\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) =\n    \\<Theta>(eval_primfun (LnChain n, real e))", "also"], ["proof (state)\nthis:\n  \\<Theta>(eval_primfun (LnChain n, real e)) =\n  \\<Theta>(\\<lambda>x. (ln ^^ n) x powr real e)\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) =\n    \\<Theta>(eval_primfun (LnChain n, real e))", "have \"eventually (\\<lambda>x::real. (ln ^^ n) x > 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x", "using fun_chain_at_top_at_top[OF ln_at_top]"], ["proof (prove)\nusing this:\n  filterlim (ln ^^ ?n) at_top at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x", "unfolding filterlim_at_top_dense"], ["proof (prove)\nusing this:\n  \\<forall>Z. \\<forall>\\<^sub>F x in at_top. Z < (ln ^^ ?n) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) =\n    \\<Theta>(eval_primfun (LnChain n, real e))", "hence \"eventually (\\<lambda>x. (ln ^^ n) x powr (real e) = (ln ^^ n) x ^ e) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. 0 < (ln ^^ n) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x powr real e = (ln ^^ n) x ^ e", "by eventually_elim (subst powr_realpow, auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x powr real e = (ln ^^ n) x ^ e\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) =\n    \\<Theta>(eval_primfun (LnChain n, real e))", "hence \"\\<Theta>(\\<lambda>x. (ln ^^ n) x powr (real e)) = \\<Theta>(\\<lambda>x. (ln ^^ n) x^e)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. (ln ^^ n) x powr real e = (ln ^^ n) x ^ e\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x powr real e) =\n    \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e)", "by (rule landau_theta.cong)"], ["proof (state)\nthis:\n  \\<Theta>(\\<lambda>x. (ln ^^ n) x powr real e) =\n  \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e)\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) =\n    \\<Theta>(eval_primfun (LnChain n, real e))", "finally"], ["proof (chain)\npicking this:\n  \\<Theta>(eval_primfun (LnChain n, real e)) =\n  \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>(eval_primfun (LnChain n, real e)) =\n  \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e)\n\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) =\n    \\<Theta>(eval_primfun (LnChain n, real e))", ".."], ["proof (state)\nthis:\n  \\<Theta>(\\<lambda>x. (ln ^^ n) x ^ e) =\n  \\<Theta>(eval_primfun (LnChain n, real e))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reify_ln_chain_powr:\n  \"\\<Theta>(\\<lambda>x. (ln ^^ n) x powr e) = \\<Theta>(eval_primfun (LnChain n, e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(\\<lambda>x. (ln ^^ n) x powr e) =\n    \\<Theta>(eval_primfun (LnChain n, e))", "by (intro landau_theta.cong) simp"], ["", "lemmas reify_ln_chain = reify_ln_chain1 reify_ln_chain_pow reify_ln_chain_powr"], ["", "lemma numeral_power_Suc: \"numeral n ^ Suc a = numeral n * numeral n ^ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n ^ Suc a = numeral n * numeral n ^ a", "by (rule power.simps)"], ["", "lemmas landau_product_preprocess =\n  one_add_one one_plus_numeral numeral_plus_one arith_simps numeral_power_Suc power_0\n  fold_fun_chain[where g = ln] reify_ln_chain reify_monom"], ["", "lemma LANDAU_PROD'_fold:\n  \"BIGTHETA_CONST e \\<Theta>(\\<lambda>_. d) = BIGTHETA_CONST (e*d) \\<Theta>(eval_primfuns [])\"\n  \"LANDAU_PROD' c (\\<lambda>_. 1) = LANDAU_PROD' c (eval_primfuns [])\"\n  \"eval_primfun f = eval_primfuns [f]\"\n  \"eval_primfuns fs x * eval_primfuns gs x = eval_primfuns (fs @ gs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BIGTHETA_CONST e \\<Theta>(\\<lambda>_. d) =\n     BIGTHETA_CONST (e * d) \\<Theta>(eval_primfuns []) &&&\n     LANDAU_PROD' c (\\<lambda>_. 1) = LANDAU_PROD' c (eval_primfuns [])) &&&\n    eval_primfun f = eval_primfuns [f] &&&\n    eval_primfuns fs x * eval_primfuns gs x = eval_primfuns (fs @ gs) x", "apply (simp only: BIGTHETA_CONST_def set_mult_is_times eval_primfuns_def[abs_def] bigtheta_mult_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<Theta>(\\<lambda>_. e) * \\<Theta>(\\<lambda>_. d) =\n    \\<Theta>(\\<lambda>_. e) * \\<Theta>(\\<lambda>_. d) *\n    \\<Theta>(\\<lambda>x. \\<Prod>f\\<leftarrow>[]. eval_primfun f x)\n 2. LANDAU_PROD' c (\\<lambda>_. 1) = LANDAU_PROD' c (eval_primfuns [])\n 3. eval_primfun f = eval_primfuns [f]\n 4. eval_primfuns fs x * eval_primfuns gs x = eval_primfuns (fs @ gs) x", "apply (simp add: bigtheta_mult_eq[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. LANDAU_PROD' c (\\<lambda>_. 1) = LANDAU_PROD' c (eval_primfuns [])\n 2. eval_primfun f = eval_primfuns [f]\n 3. eval_primfuns fs x * eval_primfuns gs x = eval_primfuns (fs @ gs) x", "by (simp_all add: eval_primfuns_def[abs_def] BIGTHETA_CONST_def)"], ["", "lemma inverse_prod_list_field:\n  \"prod_list (map (\\<lambda>x. inverse (f x)) xs) = inverse (prod_list (map f xs :: _ :: field list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>xs. inverse (f x)) = inverse (prod_list (map f xs))", "by (induction xs) simp_all"], ["", "lemma landau_prod_meta_cong:\n  assumes \"landau_symbol L L' Lr\"\n  assumes \"\\<Theta>(f) \\<equiv> BIGTHETA_CONST c1 (\\<Theta>(eval_primfuns fs))\"\n  assumes \"\\<Theta>(g) \\<equiv> BIGTHETA_CONST c2 (\\<Theta>(eval_primfuns gs))\"\n  shows   \"f \\<in> L at_top (g) \\<equiv> LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> L at_top g \\<equiv>\n    LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> L at_top g \\<equiv>\n    LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)", "interpret landau_symbol L L' Lr"], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_symbol L L' Lr", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> L at_top g \\<equiv>\n    LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)", "have \"f \\<in> L at_top (g) \\<longleftrightarrow> (\\<lambda>x. c1 * eval_primfuns fs x) \\<in> L at_top (\\<lambda>x. c2 * eval_primfuns gs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<in> L at_top g) =\n    ((\\<lambda>x. c1 * eval_primfuns fs x)\n     \\<in> L at_top (\\<lambda>x. c2 * eval_primfuns gs x))", "using assms(2,3)[symmetric]"], ["proof (prove)\nusing this:\n  BIGTHETA_CONST c1 \\<Theta>(eval_primfuns fs) \\<equiv> \\<Theta>(f)\n  BIGTHETA_CONST c2 \\<Theta>(eval_primfuns gs) \\<equiv> \\<Theta>(g)\n\ngoal (1 subgoal):\n 1. (f \\<in> L at_top g) =\n    ((\\<lambda>x. c1 * eval_primfuns fs x)\n     \\<in> L at_top (\\<lambda>x. c2 * eval_primfuns gs x))", "unfolding BIGTHETA_CONST_def"], ["proof (prove)\nusing this:\n  set_mult \\<Theta>(\\<lambda>_. c1) \\<Theta>(eval_primfuns fs) \\<equiv>\n  \\<Theta>(f)\n  set_mult \\<Theta>(\\<lambda>_. c2) \\<Theta>(eval_primfuns gs) \\<equiv>\n  \\<Theta>(g)\n\ngoal (1 subgoal):\n 1. (f \\<in> L at_top g) =\n    ((\\<lambda>x. c1 * eval_primfuns fs x)\n     \\<in> L at_top (\\<lambda>x. c2 * eval_primfuns gs x))", "by (intro cong_ex_bigtheta) (simp_all add: bigtheta_mult_eq_set_mult[symmetric])"], ["proof (state)\nthis:\n  (f \\<in> L at_top g) =\n  ((\\<lambda>x. c1 * eval_primfuns fs x)\n   \\<in> L at_top (\\<lambda>x. c2 * eval_primfuns gs x))\n\ngoal (1 subgoal):\n 1. f \\<in> L at_top g \\<equiv>\n    LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)", "also"], ["proof (state)\nthis:\n  (f \\<in> L at_top g) =\n  ((\\<lambda>x. c1 * eval_primfuns fs x)\n   \\<in> L at_top (\\<lambda>x. c2 * eval_primfuns gs x))\n\ngoal (1 subgoal):\n 1. f \\<in> L at_top g \\<equiv>\n    LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)", "have \"... \\<longleftrightarrow> (\\<lambda>x. c1) \\<in> L at_top (\\<lambda>x. c2 * eval_primfuns gs x / eval_primfuns fs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c1 * eval_primfuns fs x)\n     \\<in> L at_top (\\<lambda>x. c2 * eval_primfuns gs x)) =\n    ((\\<lambda>x. c1)\n     \\<in> L at_top\n            (\\<lambda>x. c2 * eval_primfuns gs x / eval_primfuns fs x))", "by (simp_all add: eval_primfuns_nonzero divide_eq1)"], ["proof (state)\nthis:\n  ((\\<lambda>x. c1 * eval_primfuns fs x)\n   \\<in> L at_top (\\<lambda>x. c2 * eval_primfuns gs x)) =\n  ((\\<lambda>x. c1)\n   \\<in> L at_top\n          (\\<lambda>x. c2 * eval_primfuns gs x / eval_primfuns fs x))\n\ngoal (1 subgoal):\n 1. f \\<in> L at_top g \\<equiv>\n    LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)", "finally"], ["proof (chain)\npicking this:\n  (f \\<in> L at_top g) =\n  ((\\<lambda>x. c1)\n   \\<in> L at_top\n          (\\<lambda>x. c2 * eval_primfuns gs x / eval_primfuns fs x))", "show \"f \\<in> L at_top (g) \\<equiv> LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)\""], ["proof (prove)\nusing this:\n  (f \\<in> L at_top g) =\n  ((\\<lambda>x. c1)\n   \\<in> L at_top\n          (\\<lambda>x. c2 * eval_primfuns gs x / eval_primfuns fs x))\n\ngoal (1 subgoal):\n 1. f \\<in> L at_top g \\<equiv>\n    LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)", "by (simp add: LANDAU_PROD_def eval_primfuns_def eval_inverse_primfun\n                  divide_inverse o_def inverse_prod_list_field mult_ac)"], ["proof (state)\nthis:\n  f \\<in> L at_top g \\<equiv>\n  LANDAU_PROD (L at_top) c1 c2 (map inverse_primfun fs @ gs)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun pos_primfun_list where\n  \"pos_primfun_list [] \\<longleftrightarrow> False\"\n| \"pos_primfun_list ((_,x)#xs) \\<longleftrightarrow> x > 0 \\<or> (x = 0 \\<and> pos_primfun_list xs)\""], ["", "fun nonneg_primfun_list where\n  \"nonneg_primfun_list [] \\<longleftrightarrow> True\"\n| \"nonneg_primfun_list ((_,x)#xs) \\<longleftrightarrow> x > 0 \\<or> (x = 0 \\<and> nonneg_primfun_list xs)\""], ["", "fun iszero_primfun_list where\n  \"iszero_primfun_list [] \\<longleftrightarrow> True\"\n| \"iszero_primfun_list ((_,x)#xs) \\<longleftrightarrow> x = 0 \\<and> iszero_primfun_list xs\""], ["", "definition \"group_primfuns \\<equiv> groupsort.group_sort fst merge_primfun\""], ["", "lemma list_ConsCons_induct:\n  assumes \"P []\" \"\\<And>x. P [x]\" \"\\<And>x y xs. P (y#xs) \\<Longrightarrow> P (x#y#xs)\"\n  shows   \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof (induction xs rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow> P ys \\<Longrightarrow>\n       P xs", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow> P ys \\<Longrightarrow>\n       P xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P xs", "case (Cons x xs')"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P xs", "note A = this"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P xs", "from assms 1"], ["proof (chain)\npicking this:\n  P []\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P ys", "show ?thesis"], ["proof (prove)\nusing this:\n  P []\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\n\ngoal (1 subgoal):\n 1. P xs", "proof (cases xs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P []; \\<And>x. P [x];\n     \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs);\n     \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n     xs' = []\\<rbrakk>\n    \\<Longrightarrow> P xs\n 2. \\<And>a list.\n       \\<lbrakk>P []; \\<And>x. P [x];\n        \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "case (Cons y xs'')"], ["proof (state)\nthis:\n  xs' = y # xs''\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P []; \\<And>x. P [x];\n     \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs);\n     \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n     xs' = []\\<rbrakk>\n    \\<Longrightarrow> P xs\n 2. \\<And>a list.\n       \\<lbrakk>P []; \\<And>x. P [x];\n        \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "with 1 A"], ["proof (chain)\npicking this:\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\n  xs = x # xs'\n  xs' = y # xs''", "have \"P (y#xs'')\""], ["proof (prove)\nusing this:\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\n  xs = x # xs'\n  xs' = y # xs''\n\ngoal (1 subgoal):\n 1. P (y # xs'')", "by simp"], ["proof (state)\nthis:\n  P (y # xs'')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P []; \\<And>x. P [x];\n     \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs);\n     \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n     xs' = []\\<rbrakk>\n    \\<Longrightarrow> P xs\n 2. \\<And>a list.\n       \\<lbrakk>P []; \\<And>x. P [x];\n        \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "with Cons A assms"], ["proof (chain)\npicking this:\n  xs' = y # xs''\n  xs = x # xs'\n  P []\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n  P (y # xs'')", "show ?thesis"], ["proof (prove)\nusing this:\n  xs' = y # xs''\n  xs = x # xs'\n  P []\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n  P (y # xs'')\n\ngoal (1 subgoal):\n 1. P xs", "by simp"], ["proof (state)\nthis:\n  P xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P []; \\<And>x. P [x];\n     \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs);\n     \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n     xs' = []\\<rbrakk>\n    \\<Longrightarrow> P xs", "qed (simp add: assms A)"], ["proof (state)\nthis:\n  P xs\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> P xs", "qed (simp add: assms)"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma landau_function_family_chain_primfuns:\n  assumes \"sorted (map fst fs)\"\n  assumes \"distinct (map fst fs)\"\n  shows   \"landau_function_family_chain at_top fs (eval_primfun' o fst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family_chain at_top fs (eval_primfun' \\<circ> fst)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. at_top \\<noteq> bot\n 2. \\<And>g.\n       g \\<in> set (map (eval_primfun' \\<circ> fst) fs) \\<Longrightarrow>\n       filterlim g at_top at_top\n 3. landau_dominating_chain at_top (map (eval_primfun' \\<circ> fst) fs)", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. at_top \\<noteq> bot\n 2. \\<And>g.\n       g \\<in> set (map (eval_primfun' \\<circ> fst) fs) \\<Longrightarrow>\n       filterlim g at_top at_top\n 3. landau_dominating_chain at_top (map (eval_primfun' \\<circ> fst) fs)", "from assms"], ["proof (chain)\npicking this:\n  sorted (map fst fs)\n  distinct (map fst fs)", "show ?case"], ["proof (prove)\nusing this:\n  sorted (map fst fs)\n  distinct (map fst fs)\n\ngoal (1 subgoal):\n 1. landau_dominating_chain at_top (map (eval_primfun' \\<circ> fst) fs)", "proof (induction fs rule: list_ConsCons_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>sorted (map fst []); distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> landau_dominating_chain at_top\n                       (map (eval_primfun' \\<circ> fst) [])\n 2. \\<And>x.\n       \\<lbrakk>sorted (map fst [x]); distinct (map fst [x])\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain at_top\n                          (map (eval_primfun' \\<circ> fst) [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (y # xs));\n                 distinct (map fst (y # xs))\\<rbrakk>\n                \\<Longrightarrow> landau_dominating_chain at_top\n                                   (map (eval_primfun' \\<circ> fst)\n                                     (y # xs));\n        sorted (map fst (x # y # xs));\n        distinct (map fst (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain at_top\n                          (map (eval_primfun' \\<circ> fst) (x # y # xs))", "case (2 g)"], ["proof (state)\nthis:\n  sorted (map fst [g])\n  distinct (map fst [g])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>sorted (map fst []); distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> landau_dominating_chain at_top\n                       (map (eval_primfun' \\<circ> fst) [])\n 2. \\<And>x.\n       \\<lbrakk>sorted (map fst [x]); distinct (map fst [x])\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain at_top\n                          (map (eval_primfun' \\<circ> fst) [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (y # xs));\n                 distinct (map fst (y # xs))\\<rbrakk>\n                \\<Longrightarrow> landau_dominating_chain at_top\n                                   (map (eval_primfun' \\<circ> fst)\n                                     (y # xs));\n        sorted (map fst (x # y # xs));\n        distinct (map fst (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain at_top\n                          (map (eval_primfun' \\<circ> fst) (x # y # xs))", "from eval_primfun'_at_top[of \"fst g\"]"], ["proof (chain)\npicking this:\n  filterlim (eval_primfun' (fst g)) at_top at_top", "have \"eval_primfun' (fst g) \\<in> \\<omega>(\\<lambda>_. 1)\""], ["proof (prove)\nusing this:\n  filterlim (eval_primfun' (fst g)) at_top at_top\n\ngoal (1 subgoal):\n 1. eval_primfun' (fst g) \\<in> \\<omega>(\\<lambda>_. 1)", "by (intro smallomegaI_filterlim_at_infinity filterlim_at_top_imp_at_infinity) simp"], ["proof (state)\nthis:\n  eval_primfun' (fst g) \\<in> \\<omega>(\\<lambda>_. 1)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>sorted (map fst []); distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> landau_dominating_chain at_top\n                       (map (eval_primfun' \\<circ> fst) [])\n 2. \\<And>x.\n       \\<lbrakk>sorted (map fst [x]); distinct (map fst [x])\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain at_top\n                          (map (eval_primfun' \\<circ> fst) [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (y # xs));\n                 distinct (map fst (y # xs))\\<rbrakk>\n                \\<Longrightarrow> landau_dominating_chain at_top\n                                   (map (eval_primfun' \\<circ> fst)\n                                     (y # xs));\n        sorted (map fst (x # y # xs));\n        distinct (map fst (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain at_top\n                          (map (eval_primfun' \\<circ> fst) (x # y # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  eval_primfun' (fst g) \\<in> \\<omega>(\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. landau_dominating_chain at_top (map (eval_primfun' \\<circ> fst) [g])", "by (simp add: smallomega_iff_smallo)"], ["proof (state)\nthis:\n  landau_dominating_chain at_top (map (eval_primfun' \\<circ> fst) [g])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (map fst []); distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> landau_dominating_chain at_top\n                       (map (eval_primfun' \\<circ> fst) [])\n 2. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (y # xs));\n                 distinct (map fst (y # xs))\\<rbrakk>\n                \\<Longrightarrow> landau_dominating_chain at_top\n                                   (map (eval_primfun' \\<circ> fst)\n                                     (y # xs));\n        sorted (map fst (x # y # xs));\n        distinct (map fst (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain at_top\n                          (map (eval_primfun' \\<circ> fst) (x # y # xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (map fst []); distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> landau_dominating_chain at_top\n                       (map (eval_primfun' \\<circ> fst) [])\n 2. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (y # xs));\n                 distinct (map fst (y # xs))\\<rbrakk>\n                \\<Longrightarrow> landau_dominating_chain at_top\n                                   (map (eval_primfun' \\<circ> fst)\n                                     (y # xs));\n        sorted (map fst (x # y # xs));\n        distinct (map fst (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain at_top\n                          (map (eval_primfun' \\<circ> fst) (x # y # xs))", "case (3 f g gs)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted (map fst (g # gs)); distinct (map fst (g # gs))\\<rbrakk>\n  \\<Longrightarrow> landau_dominating_chain at_top\n                     (map (eval_primfun' \\<circ> fst) (g # gs))\n  sorted (map fst (f # g # gs))\n  distinct (map fst (f # g # gs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (map fst []); distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> landau_dominating_chain at_top\n                       (map (eval_primfun' \\<circ> fst) [])\n 2. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (y # xs));\n                 distinct (map fst (y # xs))\\<rbrakk>\n                \\<Longrightarrow> landau_dominating_chain at_top\n                                   (map (eval_primfun' \\<circ> fst)\n                                     (y # xs));\n        sorted (map fst (x # y # xs));\n        distinct (map fst (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> landau_dominating_chain at_top\n                          (map (eval_primfun' \\<circ> fst) (x # y # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (map fst (g # gs)); distinct (map fst (g # gs))\\<rbrakk>\n  \\<Longrightarrow> landau_dominating_chain at_top\n                     (map (eval_primfun' \\<circ> fst) (g # gs))\n  sorted (map fst (f # g # gs))\n  distinct (map fst (f # g # gs))\n\ngoal (1 subgoal):\n 1. landau_dominating_chain at_top\n     (map (eval_primfun' \\<circ> fst) (f # g # gs))", "by (auto simp: primfun_dominates)"], ["proof (state)\nthis:\n  landau_dominating_chain at_top\n   (map (eval_primfun' \\<circ> fst) (f # g # gs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted (map fst []); distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> landau_dominating_chain at_top\n                       (map (eval_primfun' \\<circ> fst) [])", "qed simp"], ["proof (state)\nthis:\n  landau_dominating_chain at_top (map (eval_primfun' \\<circ> fst) fs)\n\ngoal (2 subgoals):\n 1. at_top \\<noteq> bot\n 2. \\<And>g.\n       g \\<in> set (map (eval_primfun' \\<circ> fst) fs) \\<Longrightarrow>\n       filterlim g at_top at_top", "qed (auto simp: eval_primfun'_at_top)"], ["", "lemma (in monoid_mult) fold_plus_prod_list_rev:\n  \"fold times xs = times (prod_list (rev xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (*) xs = (*) (prod_list (rev xs))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "have \"fold times xs x = prod_list (rev xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (*) xs x = prod_list (rev xs @ [x])", "by (simp add: foldr_conv_fold prod_list.eq_foldr)"], ["proof (state)\nthis:\n  fold (*) xs x = prod_list (rev xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "also"], ["proof (state)\nthis:\n  fold (*) xs x = prod_list (rev xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "have \"\\<dots> = prod_list (rev xs) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (rev xs @ [x]) = prod_list (rev xs) * x", "by simp"], ["proof (state)\nthis:\n  prod_list (rev xs @ [x]) = prod_list (rev xs) * x\n\ngoal (1 subgoal):\n 1. \\<And>x. fold (*) xs x = prod_list (rev xs) * x", "finally"], ["proof (chain)\npicking this:\n  fold (*) xs x = prod_list (rev xs) * x", "show \"fold times xs x = prod_list (rev xs) * x\""], ["proof (prove)\nusing this:\n  fold (*) xs x = prod_list (rev xs) * x\n\ngoal (1 subgoal):\n 1. fold (*) xs x = prod_list (rev xs) * x", "."], ["proof (state)\nthis:\n  fold (*) xs x = prod_list (rev xs) * x\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation groupsort_primfun: groupsort fst merge_primfun eval_primfuns"], ["proof (prove)\ngoal (1 subgoal):\n 1. groupsort fst merge_primfun eval_primfuns", "proof (standard, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       fst x = fst y \\<Longrightarrow> fst (merge_primfun x y) = fst x\n 2. \\<And>xs ys.\n       mset xs = mset ys \\<Longrightarrow>\n       eval_primfuns xs = eval_primfuns ys\n 3. \\<And>x y.\n       fst x = fst y \\<Longrightarrow>\n       eval_primfuns [x, y] = eval_primfuns [merge_primfun x y]\n 4. \\<And>xs1 xs2 ys1 ys2.\n       \\<lbrakk>eval_primfuns xs1 = eval_primfuns xs2;\n        eval_primfuns ys1 = eval_primfuns ys2\\<rbrakk>\n       \\<Longrightarrow> eval_primfuns (xs1 @ ys1) =\n                         eval_primfuns (xs2 @ ys2)", "case (1 x y)"], ["proof (state)\nthis:\n  fst x = fst y\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       fst x = fst y \\<Longrightarrow> fst (merge_primfun x y) = fst x\n 2. \\<And>xs ys.\n       mset xs = mset ys \\<Longrightarrow>\n       eval_primfuns xs = eval_primfuns ys\n 3. \\<And>x y.\n       fst x = fst y \\<Longrightarrow>\n       eval_primfuns [x, y] = eval_primfuns [merge_primfun x y]\n 4. \\<And>xs1 xs2 ys1 ys2.\n       \\<lbrakk>eval_primfuns xs1 = eval_primfuns xs2;\n        eval_primfuns ys1 = eval_primfuns ys2\\<rbrakk>\n       \\<Longrightarrow> eval_primfuns (xs1 @ ys1) =\n                         eval_primfuns (xs2 @ ys2)", "thus ?case"], ["proof (prove)\nusing this:\n  fst x = fst y\n\ngoal (1 subgoal):\n 1. fst (merge_primfun x y) = fst x", "by (induction x y rule: merge_primfun.induct) simp_all"], ["proof (state)\nthis:\n  fst (merge_primfun x y) = fst x\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       mset xs = mset ys \\<Longrightarrow>\n       eval_primfuns xs = eval_primfuns ys\n 2. \\<And>x y.\n       fst x = fst y \\<Longrightarrow>\n       eval_primfuns [x, y] = eval_primfuns [merge_primfun x y]\n 3. \\<And>xs1 xs2 ys1 ys2.\n       \\<lbrakk>eval_primfuns xs1 = eval_primfuns xs2;\n        eval_primfuns ys1 = eval_primfuns ys2\\<rbrakk>\n       \\<Longrightarrow> eval_primfuns (xs1 @ ys1) =\n                         eval_primfuns (xs2 @ ys2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       mset xs = mset ys \\<Longrightarrow>\n       eval_primfuns xs = eval_primfuns ys\n 2. \\<And>x y.\n       fst x = fst y \\<Longrightarrow>\n       eval_primfuns [x, y] = eval_primfuns [merge_primfun x y]\n 3. \\<And>xs1 xs2 ys1 ys2.\n       \\<lbrakk>eval_primfuns xs1 = eval_primfuns xs2;\n        eval_primfuns ys1 = eval_primfuns ys2\\<rbrakk>\n       \\<Longrightarrow> eval_primfuns (xs1 @ ys1) =\n                         eval_primfuns (xs2 @ ys2)", "case (2 fs gs)"], ["proof (state)\nthis:\n  mset fs = mset gs\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       mset xs = mset ys \\<Longrightarrow>\n       eval_primfuns xs = eval_primfuns ys\n 2. \\<And>x y.\n       fst x = fst y \\<Longrightarrow>\n       eval_primfuns [x, y] = eval_primfuns [merge_primfun x y]\n 3. \\<And>xs1 xs2 ys1 ys2.\n       \\<lbrakk>eval_primfuns xs1 = eval_primfuns xs2;\n        eval_primfuns ys1 = eval_primfuns ys2\\<rbrakk>\n       \\<Longrightarrow> eval_primfuns (xs1 @ ys1) =\n                         eval_primfuns (xs2 @ ys2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_primfuns fs = eval_primfuns gs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. eval_primfuns fs x = eval_primfuns gs x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. eval_primfuns fs x = eval_primfuns gs x", "have \"eval_primfuns fs x = fold (*) (map (\\<lambda>f. eval_primfun f x) fs) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_primfuns fs x = fold (*) (map (\\<lambda>f. eval_primfun f x) fs) 1", "unfolding eval_primfuns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>f\\<leftarrow>fs. eval_primfun f x) =\n    fold (*) (map (\\<lambda>f. eval_primfun f x) fs) 1", "by (simp add: fold_plus_prod_list_rev)"], ["proof (state)\nthis:\n  eval_primfuns fs x = fold (*) (map (\\<lambda>f. eval_primfun f x) fs) 1\n\ngoal (1 subgoal):\n 1. \\<And>x. eval_primfuns fs x = eval_primfuns gs x", "also"], ["proof (state)\nthis:\n  eval_primfuns fs x = fold (*) (map (\\<lambda>f. eval_primfun f x) fs) 1\n\ngoal (1 subgoal):\n 1. \\<And>x. eval_primfuns fs x = eval_primfuns gs x", "have \"fold (*) (map (\\<lambda>f. eval_primfun f x) fs) = fold (*) (map (\\<lambda>f. eval_primfun f x) gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (*) (map (\\<lambda>f. eval_primfun f x) fs) =\n    fold (*) (map (\\<lambda>f. eval_primfun f x) gs)", "using 2"], ["proof (prove)\nusing this:\n  mset fs = mset gs\n\ngoal (1 subgoal):\n 1. fold (*) (map (\\<lambda>f. eval_primfun f x) fs) =\n    fold (*) (map (\\<lambda>f. eval_primfun f x) gs)", "by (intro fold_multiset_equiv ext) auto"], ["proof (state)\nthis:\n  fold (*) (map (\\<lambda>f. eval_primfun f x) fs) =\n  fold (*) (map (\\<lambda>f. eval_primfun f x) gs)\n\ngoal (1 subgoal):\n 1. \\<And>x. eval_primfuns fs x = eval_primfuns gs x", "also"], ["proof (state)\nthis:\n  fold (*) (map (\\<lambda>f. eval_primfun f x) fs) =\n  fold (*) (map (\\<lambda>f. eval_primfun f x) gs)\n\ngoal (1 subgoal):\n 1. \\<And>x. eval_primfuns fs x = eval_primfuns gs x", "have \"... 1 = eval_primfuns gs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (*) (map (\\<lambda>f. eval_primfun f x) gs) 1 = eval_primfuns gs x", "unfolding eval_primfuns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (*) (map (\\<lambda>f. eval_primfun f x) gs) 1 =\n    (\\<Prod>f\\<leftarrow>gs. eval_primfun f x)", "by (simp add: fold_plus_prod_list_rev)"], ["proof (state)\nthis:\n  fold (*) (map (\\<lambda>f. eval_primfun f x) gs) 1 = eval_primfuns gs x\n\ngoal (1 subgoal):\n 1. \\<And>x. eval_primfuns fs x = eval_primfuns gs x", "finally"], ["proof (chain)\npicking this:\n  eval_primfuns fs x = eval_primfuns gs x", "show \"eval_primfuns fs x = eval_primfuns gs x\""], ["proof (prove)\nusing this:\n  eval_primfuns fs x = eval_primfuns gs x\n\ngoal (1 subgoal):\n 1. eval_primfuns fs x = eval_primfuns gs x", "."], ["proof (state)\nthis:\n  eval_primfuns fs x = eval_primfuns gs x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_primfuns fs = eval_primfuns gs\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       fst x = fst y \\<Longrightarrow>\n       eval_primfuns [x, y] = eval_primfuns [merge_primfun x y]\n 2. \\<And>xs1 xs2 ys1 ys2.\n       \\<lbrakk>eval_primfuns xs1 = eval_primfuns xs2;\n        eval_primfuns ys1 = eval_primfuns ys2\\<rbrakk>\n       \\<Longrightarrow> eval_primfuns (xs1 @ ys1) =\n                         eval_primfuns (xs2 @ ys2)", "qed (auto simp: fun_eq_iff eval_merge_primfun eval_primfuns_def)"], ["", "lemma nonneg_primfun_list_iff: \"nonneg_primfun_list fs = nonneg_list (map snd fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_primfun_list fs = nonneg_list (map snd fs)", "by (induction fs rule: nonneg_primfun_list.induct) simp_all"], ["", "lemma pos_primfun_list_iff: \"pos_primfun_list fs = pos_list (map snd fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_primfun_list fs = pos_list (map snd fs)", "by (induction fs rule: pos_primfun_list.induct) simp_all"], ["", "lemma iszero_primfun_list_iff: \"iszero_primfun_list fs = list_all ((=) 0) (map snd fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iszero_primfun_list fs = list_all ((=) (0::'b)) (map snd fs)", "by (induction fs rule: iszero_primfun_list.induct) simp_all"], ["", "lemma landau_primfuns_iff:\n  \"((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) = nonneg_primfun_list (group_primfuns fs)\" (is \"?A\")\n  \"((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) = pos_primfun_list (group_primfuns fs)\" (is \"?B\")\n  \"((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) = iszero_primfun_list (group_primfuns fs)\" (is \"?C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n    nonneg_primfun_list (group_primfuns fs) &&&\n    ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs) &&&\n    ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n    nonneg_primfun_list (group_primfuns fs)\n 2. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)\n 3. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "interpret landau_function_family_chain at_top \"group_primfuns fs\" snd \"eval_primfun' o fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_function_family_chain at_top (group_primfuns fs)\n     (eval_primfun' \\<circ> fst)", "by (rule landau_function_family_chain_primfuns)\n       (simp_all add: group_primfuns_def groupsort_primfun.sorted_group_sort\n                      groupsort_primfun.distinct_group_sort)"], ["proof (state)\ngoal (3 subgoals):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n    nonneg_primfun_list (group_primfuns fs)\n 2. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)\n 3. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "have \"(\\<lambda>_. 1) \\<in> O(eval_primfuns fs) \\<longleftrightarrow> (\\<lambda>_. 1) \\<in> O(eval_primfuns (group_primfuns fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n    ((\\<lambda>_. 1) \\<in> O(eval_primfuns (group_primfuns fs)))", "by (simp_all add: groupsort_primfun.g_group_sort group_primfuns_def)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n  ((\\<lambda>_. 1) \\<in> O(eval_primfuns (group_primfuns fs)))\n\ngoal (3 subgoals):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n    nonneg_primfun_list (group_primfuns fs)\n 2. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)\n 3. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n  ((\\<lambda>_. 1) \\<in> O(eval_primfuns (group_primfuns fs)))\n\ngoal (3 subgoals):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n    nonneg_primfun_list (group_primfuns fs)\n 2. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)\n 3. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "have \"... \\<longleftrightarrow> nonneg_list (map snd (group_primfuns fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns (group_primfuns fs))) =\n    nonneg_list (map snd (group_primfuns fs))", "using bigo_iff"], ["proof (prove)\nusing this:\n  ((\\<lambda>_. 1)\n   \\<in> O(\\<lambda>x.\n              \\<Prod>g\\<leftarrow>group_primfuns\n                                   fs. (eval_primfun' \\<circ> fst) g x powr\n snd g)) =\n  nonneg_list (map snd (group_primfuns fs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns (group_primfuns fs))) =\n    nonneg_list (map snd (group_primfuns fs))", "by (simp add: eval_primfuns_def[abs_def] eval_primfun_altdef)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> O(eval_primfuns (group_primfuns fs))) =\n  nonneg_list (map snd (group_primfuns fs))\n\ngoal (3 subgoals):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n    nonneg_primfun_list (group_primfuns fs)\n 2. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)\n 3. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n  nonneg_list (map snd (group_primfuns fs))", "show ?A"], ["proof (prove)\nusing this:\n  ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n  nonneg_list (map snd (group_primfuns fs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n    nonneg_primfun_list (group_primfuns fs)", "by (simp add: nonneg_primfun_list_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> O(eval_primfuns fs)) =\n  nonneg_primfun_list (group_primfuns fs)\n\ngoal (2 subgoals):\n 1. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)\n 2. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "have \"(\\<lambda>_. 1) \\<in> o(eval_primfuns fs) \\<longleftrightarrow> (\\<lambda>_. 1) \\<in> o(eval_primfuns (group_primfuns fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    ((\\<lambda>_. 1) \\<in> o(eval_primfuns (group_primfuns fs)))", "by (simp_all add: groupsort_primfun.g_group_sort group_primfuns_def)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n  ((\\<lambda>_. 1) \\<in> o(eval_primfuns (group_primfuns fs)))\n\ngoal (2 subgoals):\n 1. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)\n 2. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n  ((\\<lambda>_. 1) \\<in> o(eval_primfuns (group_primfuns fs)))\n\ngoal (2 subgoals):\n 1. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)\n 2. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "have \"... \\<longleftrightarrow> pos_list (map snd (group_primfuns fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> o(eval_primfuns (group_primfuns fs))) =\n    pos_list (map snd (group_primfuns fs))", "using smallo_iff"], ["proof (prove)\nusing this:\n  ((\\<lambda>_. 1)\n   \\<in> o(\\<lambda>x.\n              \\<Prod>g\\<leftarrow>group_primfuns\n                                   fs. (eval_primfun' \\<circ> fst) g x powr\n snd g)) =\n  pos_list (map snd (group_primfuns fs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> o(eval_primfuns (group_primfuns fs))) =\n    pos_list (map snd (group_primfuns fs))", "by (simp add: eval_primfuns_def[abs_def] eval_primfun_altdef)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> o(eval_primfuns (group_primfuns fs))) =\n  pos_list (map snd (group_primfuns fs))\n\ngoal (2 subgoals):\n 1. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)\n 2. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n  pos_list (map snd (group_primfuns fs))", "show ?B"], ["proof (prove)\nusing this:\n  ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n  pos_list (map snd (group_primfuns fs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n    pos_primfun_list (group_primfuns fs)", "by (simp add: pos_primfun_list_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> o(eval_primfuns fs)) =\n  pos_primfun_list (group_primfuns fs)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "have \"(\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs) \\<longleftrightarrow> (\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns (group_primfuns fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns (group_primfuns fs)))", "by (simp_all add: groupsort_primfun.g_group_sort group_primfuns_def)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n  ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns (group_primfuns fs)))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n  ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns (group_primfuns fs)))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "have \"... \\<longleftrightarrow> list_all ((=) 0) (map snd (group_primfuns fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns (group_primfuns fs))) =\n    list_all ((=) 0) (map snd (group_primfuns fs))", "using bigtheta_iff"], ["proof (prove)\nusing this:\n  ((\\<lambda>_. 1)\n   \\<in> \\<Theta>(\\<lambda>x.\n                     \\<Prod>g\\<leftarrow>group_primfuns\n    fs. (eval_primfun' \\<circ> fst) g x powr snd g)) =\n  list_all ((=) 0) (map snd (group_primfuns fs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns (group_primfuns fs))) =\n    list_all ((=) 0) (map snd (group_primfuns fs))", "by (simp add: eval_primfuns_def[abs_def] eval_primfun_altdef)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns (group_primfuns fs))) =\n  list_all ((=) 0) (map snd (group_primfuns fs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n  list_all ((=) 0) (map snd (group_primfuns fs))", "show ?C"], ["proof (prove)\nusing this:\n  ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n  list_all ((=) 0) (map snd (group_primfuns fs))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n    iszero_primfun_list (group_primfuns fs)", "by (simp add: iszero_primfun_list_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>_. 1) \\<in> \\<Theta>(eval_primfuns fs)) =\n  iszero_primfun_list (group_primfuns fs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LANDAU_PROD_bigo_iff:\n  \"LANDAU_PROD (bigo at_top) c1 c2 fs \\<longleftrightarrow> c1 = 0 \\<or> (c2 \\<noteq> 0 \\<and> nonneg_primfun_list (group_primfuns fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LANDAU_PROD bigo_at_top c1 c2 fs =\n    (c1 = 0 \\<or>\n     c2 \\<noteq> 0 \\<and> nonneg_primfun_list (group_primfuns fs))", "unfolding LANDAU_PROD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. c1) \\<in> O(\\<lambda>x. c2 * eval_primfuns fs x)) =\n    (c1 = 0 \\<or>\n     c2 \\<noteq> 0 \\<and> nonneg_primfun_list (group_primfuns fs))", "by (cases \"c1 = 0\", simp, cases \"c2 = 0\", simp) (simp_all add: landau_primfuns_iff)"], ["", "lemma LANDAU_PROD_smallo_iff:\n  \"LANDAU_PROD (smallo at_top) c1 c2 fs \\<longleftrightarrow> c1 = 0 \\<or> (c2 \\<noteq> 0 \\<and> pos_primfun_list (group_primfuns fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LANDAU_PROD smallo_at_top c1 c2 fs =\n    (c1 = 0 \\<or> c2 \\<noteq> 0 \\<and> pos_primfun_list (group_primfuns fs))", "unfolding LANDAU_PROD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. c1) \\<in> o(\\<lambda>x. c2 * eval_primfuns fs x)) =\n    (c1 = 0 \\<or> c2 \\<noteq> 0 \\<and> pos_primfun_list (group_primfuns fs))", "by (cases \"c1 = 0\", simp, cases \"c2 = 0\", simp) (simp_all add: landau_primfuns_iff)"], ["", "lemma LANDAU_PROD_bigtheta_iff:\n  \"LANDAU_PROD (bigtheta at_top) c1 c2 fs \\<longleftrightarrow> (c1 = 0 \\<and> c2 = 0) \\<or> (c1 \\<noteq> 0 \\<and> c2 \\<noteq> 0 \\<and>\n     iszero_primfun_list (group_primfuns fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "have A: \"\\<And>P x. (x = 0 \\<Longrightarrow> P) \\<Longrightarrow> (x \\<noteq> 0 \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<lbrakk>x = (0::'a) \\<Longrightarrow> P;\n        x \\<noteq> (0::'a) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x = (0::?'a1) \\<Longrightarrow> ?P;\n   ?x \\<noteq> (0::?'a1) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x = (0::?'a1) \\<Longrightarrow> ?P;\n   ?x \\<noteq> (0::?'a1) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "assume \"eventually (\\<lambda>x. eval_primfuns fs x = 0) at_top\""], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. eval_primfuns fs x = 0\n\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "with eval_primfuns_nonzero[of fs]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top. eval_primfuns fs x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_top. eval_primfuns fs x = 0", "have \"eventually (\\<lambda>x::real. False) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. eval_primfuns fs x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_top. eval_primfuns fs x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. False", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. False\n\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "hence False"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "}"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. eval_primfuns fs x = 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "note B = this"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. eval_primfuns fs x = 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LANDAU_PROD bigtheta_at_top c1 c2 fs =\n    (c1 = 0 \\<and> c2 = 0 \\<or>\n     c1 \\<noteq> 0 \\<and>\n     c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))", "by (rule A[of c1, case_product A[of c2]])\n                  (insert B, auto simp: LANDAU_PROD_def landau_primfuns_iff)"], ["proof (state)\nthis:\n  LANDAU_PROD bigtheta_at_top c1 c2 fs =\n  (c1 = 0 \\<and> c2 = 0 \\<or>\n   c1 \\<noteq> 0 \\<and>\n   c2 \\<noteq> 0 \\<and> iszero_primfun_list (group_primfuns fs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas LANDAU_PROD_iff = LANDAU_PROD_bigo_iff LANDAU_PROD_smallo_iff LANDAU_PROD_bigtheta_iff"], ["", "lemmas landau_real_prod_simps [simp] =\n  groupsort_primfun.group_part_def\n  group_primfuns_def groupsort_primfun.group_sort.simps\n  groupsort_primfun.group_part_aux.simps pos_primfun_list.simps\n  nonneg_primfun_list.simps iszero_primfun_list.simps"], ["", "end"]]}