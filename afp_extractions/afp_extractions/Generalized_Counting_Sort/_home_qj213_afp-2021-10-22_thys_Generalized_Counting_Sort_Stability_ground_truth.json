{"file_name": "/home/qj213/afp-2021-10-22/thys/Generalized_Counting_Sort/Stability.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Generalized_Counting_Sort", "problem_names": ["lemma gcsort_stab_input:\n \"stab_inv (\\<lambda>k. [x\\<leftarrow>xs. key x = k]) key (0, [length xs], xs)\"", "lemma gcsort_stab_intro:\n \"stab_inv f key t \\<Longrightarrow> [x\\<leftarrow>gcsort_out t. key x = k] = f k\"", "lemma fill_stable [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_same index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n      map the [w\\<leftarrow>fill xs ns index key ub mi ma. \\<exists>x. w = Some x \\<and> key x = k] =\n        [x\\<leftarrow>xs. k = key x]\"", "lemma fill_offs_enum_stable [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_same index key\"\n  shows\n   \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n    0 < n \\<Longrightarrow>\n      [x\\<leftarrow>map the (fill xs (offs (enum xs index key n mi ma) 0)\n        index key (length xs) mi ma). key x = k] = [x\\<leftarrow>xs. k = key x]\"\n  (is \"_ \\<Longrightarrow> _ \\<Longrightarrow> [_\\<leftarrow>map the ?ys. _] = _\"\n   is \"_ \\<Longrightarrow> _ \\<Longrightarrow> [_\\<leftarrow>map the (fill _ ?ns _ _ _ _ _). _] = _\")", "lemma mini_first [rule_format]:\n \"xs \\<noteq> [] \\<longrightarrow> i < mini xs key \\<longrightarrow>\n    key (xs ! mini xs key) < key (xs ! i)\"", "lemma maxi_last [rule_format]:\n \"xs \\<noteq> [] \\<longrightarrow> maxi xs key < i \\<longrightarrow> i < length xs \\<longrightarrow>\n    key (xs ! i) < key (xs ! maxi xs key)\"", "lemma nths_range:\n \"nths xs A = nths xs (A \\<inter> {..<length xs})\"", "lemma filter_nths_diff:\n  assumes\n    A: \"i < length xs\" and\n    B: \"\\<not> P (xs ! i)\"\n  shows \"[x\\<leftarrow>nths xs (A - {i}). P x] = [x\\<leftarrow>nths xs A. P x]\"", "lemma mini_stable:\n  assumes\n    A: \"xs \\<noteq> []\" and\n    B: \"mini xs key \\<in> A\"\n      (is \"?nmi \\<in> _\")\n  shows \"[x\\<leftarrow>[xs ! ?nmi] @ nths xs (A - {?nmi}). key x = k] =\n    [x\\<leftarrow>nths xs A. key x = k]\"\n    (is \"[x\\<leftarrow>[?xmi] @ _. _] = _\")", "lemma maxi_stable:\n  assumes\n    A: \"xs \\<noteq> []\" and\n    B: \"maxi xs key \\<in> A\"\n      (is \"?nma \\<in> _\")\n  shows \"[x\\<leftarrow>nths xs (A - {?nma}) @ [xs ! ?nma]. key x = k] =\n    [x\\<leftarrow>nths xs A. key x = k]\"\n    (is \"[x\\<leftarrow>_ @ [?xma]. _] = _\")", "lemma round_stab_inv [rule_format]:\n \"index_less index key \\<longrightarrow> index_same index key \\<longrightarrow> bn_inv p q t \\<longrightarrow>\n    add_inv n t \\<longrightarrow> stab_inv f key t \\<longrightarrow> stab_inv f key (round index key p q r t)\"", "lemma gcsort_stab_inv:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_same index key\" and\n    C: \"add_inv n t\" and\n    D: \"n \\<le> p\"\n  shows \"\\<lbrakk>t' \\<in> gcsort_set index key p t; stab_inv f key t\\<rbrakk> \\<Longrightarrow>\n    stab_inv f key t'\"", "theorem gcsort_stable:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_same index key\" and\n    C: \"length xs \\<le> p\"\n  shows \"[x\\<leftarrow>gcsort index key p xs. key x = k] = [x\\<leftarrow>xs. key x = k]\""], "translations": [["", "lemma gcsort_stab_input:\n \"stab_inv (\\<lambda>k. [x\\<leftarrow>xs. key x = k]) key (0, [length xs], xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stab_inv (\\<lambda>k. filter (\\<lambda>x. key x = k) xs) key\n     (0, [length xs], xs)", "by simp"], ["", "lemma gcsort_stab_intro:\n \"stab_inv f key t \\<Longrightarrow> [x\\<leftarrow>gcsort_out t. key x = k] = f k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stab_inv f key t \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (gcsort_out t) = f k", "by (cases t, simp add: gcsort_out_def)"], ["", "text \\<open>\n\\null\n\nIn what follows, step 9 of the proof method is accomplished.\n\nFirst, lemma @{text fill_offs_enum_stable} proves that function @{const fill}, if its input offsets'\nlist is computed via the composition of functions @{const offs} and @{const enum}, does not modify\nthe sublist of its input objects' list formed by the objects having a given key. Moreover, lemmas\n@{text mini_stable} and @{text maxi_stable} prove that the extraction of the leftmost minimum and\nthe rightmost maximum from an objects' list through functions @{const mini} and @{const maxi} is\nendowed with the same property.\n\nThese lemmas are then used to prove lemma @{text gcsort_stab_inv}, which states that the sublist of\nthe objects having a given key within the objects' list is still the same after any recursive round.\n\n\\null\n\\<close>"], ["", "lemma fill_stable [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_same index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n      map the [w\\<leftarrow>fill xs ns index key ub mi ma. \\<exists>x. w = Some x \\<and> key x = k] =\n        [x\\<leftarrow>xs. k = key x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    map the\n     (filter (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n       (fill xs ns index key ub mi ma)) =\n    filter (\\<lambda>x. k = key x) xs", "proof (induction xs arbitrary: ns, simp_all add: Let_def, rule conjI,\n (rule_tac [!] impI)+, (erule_tac [!] conjE)+, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "fix x xs and ns :: \"nat list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "let ?i = \"index key x (length ns) mi ma\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "let ?ns' = \"ns[?i := Suc (ns ! ?i)]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "let ?ws = \"[w\\<leftarrow>fill xs ?ns' index key ub mi ma.\n    \\<exists>y. w = Some y \\<and> key y = key x]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "let ?ws' = \"[w\\<leftarrow>(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x].\n    \\<exists>y. w = Some y \\<and> key y = key x]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "assume\n    C: \"\\<forall>x \\<in> set xs. mi \\<le> key x \\<and> key x \\<le> ma\" and\n    D: \"mi \\<le> key x\" and\n    E: \"key x \\<le> ma\" and\n    F: \"ns \\<noteq> []\" and\n    G: \"offs_pred ns ub (x # xs) index key mi ma\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  mi \\<le> key x\n  key x \\<le> ma\n  ns \\<noteq> []\n  offs_pred ns ub (x # xs) index key mi ma\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have H: \"?i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "using A and D and E and F"], ["proof (prove)\nusing this:\n  index_less index key\n  mi \\<le> key x\n  key x \\<le> ma\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key x (length ns) mi ma < length ns\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "assume \"\\<And>ns. ns \\<noteq> [] \\<longrightarrow> offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    map the [w\\<leftarrow>fill xs ns index key ub mi ma.\n      \\<exists>y. w = Some y \\<and> key y = key x] =\n    [y\\<leftarrow>xs. key x = key y]\""], ["proof (state)\nthis:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. key x = key y) xs\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "moreover"], ["proof (state)\nthis:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. key x = key y) xs\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have I: \"offs_pred ?ns' ub xs index key mi ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma", "using G and H"], ["proof (prove)\nusing this:\n  offs_pred ns ub (x # xs) index key mi ma\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma", "by (rule_tac offs_pred_cons, simp_all)"], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "ultimately"], ["proof (chain)\npicking this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. key x = key y) xs\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma", "have J: \"map the ?ws = [y\\<leftarrow>xs. key x = key y]\""], ["proof (prove)\nusing this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. key x = key y) xs\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. map the\n     (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)) =\n    filter (\\<lambda>y. key x = key y) xs", "using F"], ["proof (prove)\nusing this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. key x = key y) xs\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. map the\n     (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)) =\n    filter (\\<lambda>y. key x = key y) xs", "by simp"], ["proof (state)\nthis:\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)) =\n  filter (\\<lambda>y. key x = key y) xs\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"ns ! ?i + offs_num (length ns) (x # xs) index key mi ma ?i \\<le> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma +\n    offs_num (length ns) (x # xs) index key mi ma\n     (index key x (length ns) mi ma)\n    \\<le> ub", "using G and H"], ["proof (prove)\nusing this:\n  offs_pred ns ub (x # xs) index key mi ma\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma +\n    offs_num (length ns) (x # xs) index key mi ma\n     (index key x (length ns) mi ma)\n    \\<le> ub", "by (rule offs_pred_ub, simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (x # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ub\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "hence K: \"ns ! ?i < ub\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (x # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ub\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma < ub", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma < ub\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "moreover"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma < ub\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "from this"], ["proof (chain)\npicking this:\n  ns ! index key x (length ns) mi ma < ub", "have\n    L: \"(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] ! (ns ! ?i) = Some x\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] !\n    (ns ! index key x (length ns) mi ma) =\n    Some x", "by (subst nth_list_update_eq, simp_all add: fill_length)"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma) =\n  Some x\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "ultimately"], ["proof (chain)\npicking this:\n  ns ! index key x (length ns) mi ma < ub\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma) =\n  Some x", "have \"0 < length ?ws'\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < ub\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma) =\n  Some x\n\ngoal (1 subgoal):\n 1. 0 < length\n         (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n           ((fill xs\n              (ns[index key x (length ns) mi ma :=\n                    Suc (ns ! index key x (length ns) mi ma)])\n              index key ub mi ma)\n            [ns ! index key x (length ns) mi ma := Some x]))", "by (simp add: length_filter_conv_card card_gt_0_iff,\n     rule_tac exI [where x = \"ns ! ?i\"], simp add: fill_length)"], ["proof (state)\nthis:\n  0 < length\n       (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n         ((fill xs\n            (ns[index key x (length ns) mi ma :=\n                  Suc (ns ! index key x (length ns) mi ma)])\n            index key ub mi ma)\n          [ns ! index key x (length ns) mi ma := Some x]))\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "hence \"\\<exists>w ws. ?ws' = w # ws\""], ["proof (prove)\nusing this:\n  0 < length\n       (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n         ((fill xs\n            (ns[index key x (length ns) mi ma :=\n                  Suc (ns ! index key x (length ns) mi ma)])\n            index key ub mi ma)\n          [ns ! index key x (length ns) mi ma := Some x]))\n\ngoal (1 subgoal):\n 1. \\<exists>w ws.\n       filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n        ((fill xs\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           index key ub mi ma)\n         [ns ! index key x (length ns) mi ma := Some x]) =\n       w # ws", "by (rule_tac list.exhaust [of ?ws'], simp_all)"], ["proof (state)\nthis:\n  \\<exists>w ws.\n     filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n      ((fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)\n       [ns ! index key x (length ns) mi ma := Some x]) =\n     w # ws\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>w ws.\n     filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n      ((fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)\n       [ns ! index key x (length ns) mi ma := Some x]) =\n     w # ws", "obtain w and ws where \"?ws' = w # ws\""], ["proof (prove)\nusing this:\n  \\<exists>w ws.\n     filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n      ((fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)\n       [ns ! index key x (length ns) mi ma := Some x]) =\n     w # ws\n\ngoal (1 subgoal):\n 1. (\\<And>w ws.\n        filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n         ((fill xs\n            (ns[index key x (length ns) mi ma :=\n                  Suc (ns ! index key x (length ns) mi ma)])\n            index key ub mi ma)\n          [ns ! index key x (length ns) mi ma := Some x]) =\n        w # ws \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  w # ws\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "hence \"\\<exists>us vs y.\n    (fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] = us @ w # vs \\<and>\n    (\\<forall>u \\<in> set us. \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n    w = Some y \\<and> key y = key x \\<and>\n    ws = [w\\<leftarrow>vs. \\<exists>y. w = Some y \\<and> key y = key x]\"\n    (is \"\\<exists>us vs y. ?P us vs y\")"], ["proof (prove)\nusing this:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  w # ws\n\ngoal (1 subgoal):\n 1. \\<exists>us vs y.\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)\n       [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n       (\\<forall>u\\<in>set us.\n           \\<forall>y.\n              u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n       w = Some y \\<and>\n       key y = key x \\<and>\n       ws =\n       filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs", "by (simp add: filter_eq_Cons_iff, blast)"], ["proof (state)\nthis:\n  \\<exists>us vs y.\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)\n     [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n     (\\<forall>u\\<in>set us.\n         \\<forall>y.\n            u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n     w = Some y \\<and>\n     key y = key x \\<and>\n     ws =\n     filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>us vs y.\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)\n     [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n     (\\<forall>u\\<in>set us.\n         \\<forall>y.\n            u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n     w = Some y \\<and>\n     key y = key x \\<and>\n     ws =\n     filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs", "obtain us and vs and y where M: \"?P us vs y\""], ["proof (prove)\nusing this:\n  \\<exists>us vs y.\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)\n     [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n     (\\<forall>u\\<in>set us.\n         \\<forall>y.\n            u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n     w = Some y \\<and>\n     key y = key x \\<and>\n     ws =\n     filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs y.\n        (fill xs\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n        (\\<forall>u\\<in>set us.\n            \\<forall>y.\n               u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n        w = Some y \\<and>\n        key y = key x \\<and>\n        ws =\n        filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n         vs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "let ?A = \"{i. i < length ns \\<and> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n    ns ! i \\<le> length us}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"length us = ns ! ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us = ns ! index key x (length ns) mi ma", "proof (rule ccontr, erule neqE, cases \"?A = {}\",\n   cases \"0 < offs_num (length ns) xs index key mi ma 0\", simp_all only: not_gr0)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "assume\n      N: \"length us < ns ! ?i\" and\n      O: \"?A = {}\" and\n      P: \"0 < offs_num (length ns) xs index key mi ma 0\""], ["proof (state)\nthis:\n  length us < ns ! index key x (length ns) mi ma\n  {i. i < length ns \\<and>\n      0 < offs_num (length ns) xs index key mi ma i \\<and>\n      ns ! i \\<le> length us} =\n  {}\n  0 < offs_num (length ns) xs index key mi ma 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "have \"length us < ns ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us < ns ! 0", "proof (rule ccontr, simp add: not_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. ns ! 0 \\<le> length us \\<Longrightarrow> False", "assume \"ns ! 0 \\<le> length us\""], ["proof (state)\nthis:\n  ns ! 0 \\<le> length us\n\ngoal (1 subgoal):\n 1. ns ! 0 \\<le> length us \\<Longrightarrow> False", "with F and P"], ["proof (chain)\npicking this:\n  ns \\<noteq> []\n  0 < offs_num (length ns) xs index key mi ma 0\n  ns ! 0 \\<le> length us", "have \"0 \\<in> ?A\""], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  0 < offs_num (length ns) xs index key mi ma 0\n  ns ! 0 \\<le> length us\n\ngoal (1 subgoal):\n 1. 0 \\<in> {i. i < length ns \\<and>\n                0 < offs_num (length ns) xs index key mi ma i \\<and>\n                ns ! i \\<le> length us}", "by simp"], ["proof (state)\nthis:\n  0 \\<in> {i. i < length ns \\<and>\n              0 < offs_num (length ns) xs index key mi ma i \\<and>\n              ns ! i \\<le> length us}\n\ngoal (1 subgoal):\n 1. ns ! 0 \\<le> length us \\<Longrightarrow> False", "with O"], ["proof (chain)\npicking this:\n  {i. i < length ns \\<and>\n      0 < offs_num (length ns) xs index key mi ma i \\<and>\n      ns ! i \\<le> length us} =\n  {}\n  0 \\<in> {i. i < length ns \\<and>\n              0 < offs_num (length ns) xs index key mi ma i \\<and>\n              ns ! i \\<le> length us}", "show False"], ["proof (prove)\nusing this:\n  {i. i < length ns \\<and>\n      0 < offs_num (length ns) xs index key mi ma i \\<and>\n      ns ! i \\<le> length us} =\n  {}\n  0 \\<in> {i. i < length ns \\<and>\n              0 < offs_num (length ns) xs index key mi ma i \\<and>\n              ns ! i \\<le> length us}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length us < ns ! 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"length us < ?ns' ! 0\""], ["proof (prove)\nusing this:\n  length us < ns ! 0\n\ngoal (1 subgoal):\n 1. length us\n    < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0", "using F"], ["proof (prove)\nusing this:\n  length us < ns ! 0\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. length us\n    < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0", "by (cases ?i, simp_all)"], ["proof (state)\nthis:\n  length us\n  < ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"offs_none ?ns' ub xs index key mi ma (length us)\""], ["proof (prove)\nusing this:\n  length us\n  < ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    0\n\ngoal (1 subgoal):\n 1. offs_none\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (length us)", "using P"], ["proof (prove)\nusing this:\n  length us\n  < ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    0\n  0 < offs_num (length ns) xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_none\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (length us)", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (length us)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"fill xs ?ns' index key ub mi ma ! (length us) = None\""], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (length us)\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    length us =\n    None", "using C and F and I"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (length us)\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  ns \\<noteq> []\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    length us =\n    None", "by (rule_tac fill_none [OF A], simp_all)"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  None\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] ! (length us) = None\""], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  None\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! length us =\n    None", "using N"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  None\n  length us < ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! length us =\n    None", "by simp"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! length us =\n  None\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! length us =\n  None\n\ngoal (1 subgoal):\n 1. False", "using M"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! length us =\n  None\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "assume\n      N: \"length us < ns ! ?i\" and\n      O: \"?A = {}\" and\n      P: \"offs_num (length ns) xs index key mi ma 0 = 0\""], ["proof (state)\nthis:\n  length us < ns ! index key x (length ns) mi ma\n  {i. i < length ns \\<and>\n      0 < offs_num (length ns) xs index key mi ma i \\<and>\n      ns ! i \\<le> length us} =\n  {}\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "from K and N"], ["proof (chain)\npicking this:\n  ns ! index key x (length ns) mi ma < ub\n  length us < ns ! index key x (length ns) mi ma", "have \"length us < offs_next ?ns' ub xs index key mi ma 0\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < ub\n  length us < ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. length us\n    < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0", "proof (rule_tac ccontr, simp only: not_less offs_next_def split: if_split_asm)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma < ub;\n     length us < ns ! index key x (length ns) mi ma; True; True;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma 0 \\<noteq>\n     {};\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma 0)\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"offs_set_next ?ns' xs index key mi ma 0 \\<noteq> {}\"\n        (is \"?B \\<noteq> _\")"], ["proof (state)\nthis:\n  offs_set_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma 0 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma < ub;\n     length us < ns ! index key x (length ns) mi ma; True; True;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma 0 \\<noteq>\n     {};\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma 0)\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"Min ?B \\<in> ?B\""], ["proof (prove)\nusing this:\n  offs_set_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma 0 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          xs index key mi ma 0)\n    \\<in> offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma 0", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<in> offs_set_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma < ub;\n     length us < ns ! index key x (length ns) mi ma; True; True;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma 0 \\<noteq>\n     {};\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma 0)\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<in> offs_set_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma < ub;\n     length us < ns ! index key x (length ns) mi ma; True; True;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma 0 \\<noteq>\n     {};\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma 0)\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"?ns' ! Min ?B \\<le> length us\""], ["proof (state)\nthis:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<le> length us\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma < ub;\n     length us < ns ! index key x (length ns) mi ma; True; True;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma 0 \\<noteq>\n     {};\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma 0)\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"ns ! Min ?B \\<le> length us\""], ["proof (prove)\nusing this:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<le> length us\n\ngoal (1 subgoal):\n 1. ns !\n    Min (offs_set_next\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          xs index key mi ma 0)\n    \\<le> length us", "using H"], ["proof (prove)\nusing this:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<le> length us\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. ns !\n    Min (offs_set_next\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          xs index key mi ma 0)\n    \\<le> length us", "by (cases \"Min ?B = ?i\", simp_all)"], ["proof (state)\nthis:\n  ns !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<le> length us\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma < ub;\n     length us < ns ! index key x (length ns) mi ma; True; True;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma 0 \\<noteq>\n     {};\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma 0)\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<in> offs_set_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         xs index key mi ma 0\n  ns !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<le> length us", "have \"Min ?B \\<in> ?A\""], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<in> offs_set_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         xs index key mi ma 0\n  ns !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<le> length us\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          xs index key mi ma 0)\n    \\<in> {i. i < length ns \\<and>\n              0 < offs_num (length ns) xs index key mi ma i \\<and>\n              ns ! i \\<le> length us}", "by simp"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma < ub;\n     length us < ns ! index key x (length ns) mi ma; True; True;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma 0 \\<noteq>\n     {};\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma 0)\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False", "with O"], ["proof (chain)\npicking this:\n  {i. i < length ns \\<and>\n      0 < offs_num (length ns) xs index key mi ma i \\<and>\n      ns ! i \\<le> length us} =\n  {}\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}", "show False"], ["proof (prove)\nusing this:\n  {i. i < length ns \\<and>\n      0 < offs_num (length ns) xs index key mi ma i \\<and>\n      ns ! i \\<le> length us} =\n  {}\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma 0)\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length us\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"offs_none ?ns' ub xs index key mi ma (length us)\""], ["proof (prove)\nusing this:\n  length us\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_none\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (length us)", "using P"], ["proof (prove)\nusing this:\n  length us\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. offs_none\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (length us)", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (length us)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"fill xs ?ns' index key ub mi ma ! (length us) = None\""], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (length us)\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    length us =\n    None", "using C and F and I"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (length us)\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  ns \\<noteq> []\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    length us =\n    None", "by (rule_tac fill_none [OF A], simp_all)"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  None\n\ngoal (3 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] ! (length us) = None\""], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  None\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! length us =\n    None", "using N"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  None\n  length us < ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! length us =\n    None", "by simp"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! length us =\n  None\n\ngoal (3 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} =\n     {};\n     offs_num (length ns) xs index key mi ma 0 = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! length us =\n  None\n\ngoal (1 subgoal):\n 1. False", "using M"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! length us =\n  None\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "assume N: \"length us < ns ! ?i\""], ["proof (state)\nthis:\n  length us < ns ! index key x (length ns) mi ma\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "assume \"?A \\<noteq> {}\""], ["proof (state)\nthis:\n  {i. i < length ns \\<and>\n      0 < offs_num (length ns) xs index key mi ma i \\<and>\n      ns ! i \\<le> length us} \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"Max ?A \\<in> ?A\""], ["proof (prove)\nusing this:\n  {i. i < length ns \\<and>\n      0 < offs_num (length ns) xs index key mi ma i \\<and>\n      ns ! i \\<le> length us} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Max {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n    \\<in> {i. i < length ns \\<and>\n              0 < offs_num (length ns) xs index key mi ma i \\<and>\n              ns ! i \\<le> length us}", "by (rule_tac Max_in, simp)"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}", "have O: \"Max ?A \\<noteq> ?i\""], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n\ngoal (1 subgoal):\n 1. Max {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us} \\<noteq>\n    index key x (length ns) mi ma", "using N"], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n  length us < ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. Max {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us} \\<noteq>\n    index key x (length ns) mi ma", "by (rule_tac notI, simp)"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us} \\<noteq>\n  index key x (length ns) mi ma\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us} \\<noteq>\n  index key x (length ns) mi ma", "have \"index key y (length ?ns') mi ma = Max ?A\""], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us} \\<noteq>\n  index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. index key y\n     (length\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)]))\n     mi ma =\n    Max {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}", "using C"], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us} \\<noteq>\n  index key x (length ns) mi ma\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n\ngoal (1 subgoal):\n 1. index key y\n     (length\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)]))\n     mi ma =\n    Max {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}", "proof (rule_tac fill_index [OF A _ I, where j = \"length us\"], simp_all,\n     rule_tac ccontr, simp only: not_less not_le offs_next_def split: if_split_asm)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) =\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ub \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "assume \"ub \\<le> length us\""], ["proof (state)\nthis:\n  ub \\<le> length us\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) =\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ub \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "with N"], ["proof (chain)\npicking this:\n  length us < ns ! index key x (length ns) mi ma\n  ub \\<le> length us", "have \"ub < ns ! ?i\""], ["proof (prove)\nusing this:\n  length us < ns ! index key x (length ns) mi ma\n  ub \\<le> length us\n\ngoal (1 subgoal):\n 1. ub < ns ! index key x (length ns) mi ma", "by simp"], ["proof (state)\nthis:\n  ub < ns ! index key x (length ns) mi ma\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) =\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ub \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "with K"], ["proof (chain)\npicking this:\n  ns ! index key x (length ns) mi ma < ub\n  ub < ns ! index key x (length ns) mi ma", "show False"], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < ub\n  ub < ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "let ?B = \"offs_set_next ?ns' xs index key mi ma (Max ?A)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "assume \"?ns' ! Min ?B \\<le> length us\""], ["proof (state)\nthis:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> length us\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "hence \"ns ! Min ?B \\<le> length us\""], ["proof (prove)\nusing this:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> length us\n\ngoal (1 subgoal):\n 1. ns !\n    Min (offs_set_next\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us}))\n    \\<le> length us", "using H"], ["proof (prove)\nusing this:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> length us\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. ns !\n    Min (offs_set_next\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us}))\n    \\<le> length us", "by (cases \"Min ?B = ?i\", simp_all)"], ["proof (state)\nthis:\n  ns !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> length us\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "moreover"], ["proof (state)\nthis:\n  ns !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> length us\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "assume \"?B \\<noteq> {}\""], ["proof (state)\nthis:\n  offs_set_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma\n   (Max {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}) \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "hence P: \"Min ?B \\<in> ?B\""], ["proof (prove)\nusing this:\n  offs_set_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma\n   (Max {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us}))\n    \\<in> offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us})", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<in> offs_set_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         xs index key mi ma\n         (Max {i. i < length ns \\<and>\n                  0 < offs_num (length ns) xs index key mi ma i \\<and>\n                  ns ! i \\<le> length us})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "ultimately"], ["proof (chain)\npicking this:\n  ns !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> length us\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<in> offs_set_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         xs index key mi ma\n         (Max {i. i < length ns \\<and>\n                  0 < offs_num (length ns) xs index key mi ma i \\<and>\n                  ns ! i \\<le> length us})", "have \"Min ?B \\<in> ?A\""], ["proof (prove)\nusing this:\n  ns !\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> length us\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<in> offs_set_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         xs index key mi ma\n         (Max {i. i < length ns \\<and>\n                  0 < offs_num (length ns) xs index key mi ma i \\<and>\n                  ns ! i \\<le> length us})\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us}))\n    \\<in> {i. i < length ns \\<and>\n              0 < offs_num (length ns) xs index key mi ma i \\<and>\n              ns ! i \\<le> length us}", "by simp"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "hence \"Min ?B \\<le> Max ?A\""], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<in> {i. i < length ns \\<and>\n            0 < offs_num (length ns) xs index key mi ma i \\<and>\n            ns ! i \\<le> length us}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us}))\n    \\<le> Max {i. i < length ns \\<and>\n                  0 < offs_num (length ns) xs index key mi ma i \\<and>\n                  ns ! i \\<le> length us}", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> Max {i. i < length ns \\<and>\n                0 < offs_num (length ns) xs index key mi ma i \\<and>\n                ns ! i \\<le> length us}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<in> {i. i < length ns \\<and>\n                       0 < offs_num (length ns) xs index key mi ma i \\<and>\n                       ns ! i \\<le> length us};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; True;\n     \\<not> False;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     offs_set_next\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      xs index key mi ma\n      (Max {i. i < length ns \\<and>\n               0 < offs_num (length ns) xs index key mi ma i \\<and>\n               ns ! i \\<le> length us}) \\<noteq>\n     {};\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     < length ns;\n     0 < offs_num (length ns) xs index key mi ma\n          (Max {i. i < length ns \\<and>\n                   0 < offs_num (length ns) xs index key mi ma i \\<and>\n                   ns ! i \\<le> length us});\n     ns !\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us}\n     \\<le> length us;\n     ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)] !\n     Min (offs_set_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           xs index key mi ma\n           (Max {i. i < length ns \\<and>\n                    0 < offs_num (length ns) xs index key mi ma i \\<and>\n                    ns ! i \\<le> length us}))\n     \\<le> length us\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "thus False"], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> Max {i. i < length ns \\<and>\n                0 < offs_num (length ns) xs index key mi ma i \\<and>\n                ns ! i \\<le> length us}\n\ngoal (1 subgoal):\n 1. False", "using P"], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<le> Max {i. i < length ns \\<and>\n                0 < offs_num (length ns) xs index key mi ma i \\<and>\n                ns ! i \\<le> length us}\n  Min (offs_set_next\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        xs index key mi ma\n        (Max {i. i < length ns \\<and>\n                 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                 ns ! i \\<le> length us}))\n  \\<in> offs_set_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         xs index key mi ma\n         (Max {i. i < length ns \\<and>\n                  0 < offs_num (length ns) xs index key mi ma i \\<and>\n                  ns ! i \\<le> length us})\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "have \"fill xs ?ns' index key ub mi ma ! length us =\n        (fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] ! length us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    length us =\n    (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! length us", "using N"], ["proof (prove)\nusing this:\n  length us < ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    length us =\n    (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! length us", "by simp"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! length us\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma\n                  (Max {i. i < length ns \\<and>\n                           0 < offs_num (length ns) xs index key mi ma\n                                i \\<and>\n                           ns ! i \\<le> length us}) \\<and>\n             ns !\n             Max {i. i < length ns \\<and>\n                     0 < offs_num (length ns) xs index key mi ma i \\<and>\n                     ns ! i \\<le> length us}\n             \\<le> length us;\n     Max {i. i < length ns \\<and>\n             0 < offs_num (length ns) xs index key mi ma i \\<and>\n             ns ! i \\<le> length us} \\<noteq>\n     index key x (length ns) mi ma;\n     \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n    \\<Longrightarrow> fill xs\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       index key ub mi ma !\n                      length us =\n                      Some y", "thus \"fill xs ?ns' index key ub mi ma ! length us = Some y\""], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! length us\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    length us =\n    Some y", "using M"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! length us\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    length us =\n    Some y", "by simp"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  length us =\n  Some y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index key y\n   (length\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)]))\n   mi ma =\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  index key y\n   (length\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)]))\n   mi ma =\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "have \"index key y (length ?ns') mi ma = ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index key y\n     (length\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)]))\n     mi ma =\n    index key x (length ns) mi ma", "using B and D and E and M"], ["proof (prove)\nusing this:\n  index_same index key\n  mi \\<le> key x\n  key x \\<le> ma\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. index key y\n     (length\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)]))\n     mi ma =\n    index key x (length ns) mi ma", "by (cases \"y = x\", simp_all add:\n       index_same_def)"], ["proof (state)\nthis:\n  index key y\n   (length\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)]))\n   mi ma =\n  index key x (length ns) mi ma\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length us < ns ! index key x (length ns) mi ma;\n     {i. i < length ns \\<and>\n         0 < offs_num (length ns) xs index key mi ma i \\<and>\n         ns ! i \\<le> length us} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  index key y\n   (length\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)]))\n   mi ma =\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  index key y\n   (length\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)]))\n   mi ma =\n  index key x (length ns) mi ma", "show False"], ["proof (prove)\nusing this:\n  index key y\n   (length\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)]))\n   mi ma =\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  index key y\n   (length\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)]))\n   mi ma =\n  index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. False", "using O"], ["proof (prove)\nusing this:\n  index key y\n   (length\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)]))\n   mi ma =\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us}\n  index key y\n   (length\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)]))\n   mi ma =\n  index key x (length ns) mi ma\n  Max {i. i < length ns \\<and>\n          0 < offs_num (length ns) xs index key mi ma i \\<and>\n          ns ! i \\<le> length us} \\<noteq>\n  index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "assume N: \"ns ! ?i < length us\""], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma < length us\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] ! (ns ! ?i) =\n      us ! (ns ! ?i)\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < length us\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] !\n    (ns ! index key x (length ns) mi ma) =\n    us ! (ns ! index key x (length ns) mi ma)", "using M"], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < length us\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] !\n    (ns ! index key x (length ns) mi ma) =\n    us ! (ns ! index key x (length ns) mi ma)", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma) =\n  us ! (ns ! index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "hence \"(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] ! (ns ! ?i) \\<in> set us\""], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma) =\n  us ! (ns ! index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] !\n    (ns ! index key x (length ns) mi ma)\n    \\<in> set us", "using N"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma) =\n  us ! (ns ! index key x (length ns) mi ma)\n  ns ! index key x (length ns) mi ma < length us\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] !\n    (ns ! index key x (length ns) mi ma)\n    \\<in> set us", "by simp"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma)\n  \\<in> set us\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma < length us \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma)\n  \\<in> set us\n\ngoal (1 subgoal):\n 1. False", "using L and M"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma)\n  \\<in> set us\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] !\n  (ns ! index key x (length ns) mi ma) =\n  Some x\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length us = ns ! index key x (length ns) mi ma\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "hence \"take (ns ! ?i) ((fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x]) = us\""], ["proof (prove)\nusing this:\n  length us = ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. take (ns ! index key x (length ns) mi ma)\n     ((fill xs\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        index key ub mi ma)\n      [ns ! index key x (length ns) mi ma := Some x]) =\n    us", "using M"], ["proof (prove)\nusing this:\n  length us = ns ! index key x (length ns) mi ma\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. take (ns ! index key x (length ns) mi ma)\n     ((fill xs\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        index key ub mi ma)\n      [ns ! index key x (length ns) mi ma := Some x]) =\n    us", "by simp"], ["proof (state)\nthis:\n  take (ns ! index key x (length ns) mi ma)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  us\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "hence N: \"take (ns ! ?i) (fill xs ?ns' index key ub mi ma) = us\""], ["proof (prove)\nusing this:\n  take (ns ! index key x (length ns) mi ma)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  us\n\ngoal (1 subgoal):\n 1. take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) =\n    us", "by simp"], ["proof (state)\nthis:\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) =\n  us\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"fill xs ?ns' index key ub mi ma =\n    take (ns ! ?i) (fill xs ?ns' index key ub mi ma) @\n    fill xs ?ns' index key ub mi ma ! (ns ! ?i) #\n    drop (Suc (ns ! ?i)) (fill xs ?ns' index key ub mi ma)\"\n    (is \"_ = ?ts @ _ # ?ds\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma =\n    take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) @\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "using K"], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma =\n    take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) @\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "by (rule_tac id_take_nth_drop, simp add: fill_length)"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "moreover"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"fill xs ?ns' index key ub mi ma ! (ns ! ?i) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) =\n    None", "using C and D and E and F and G"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  mi \\<le> key x\n  key x \\<le> ma\n  ns \\<noteq> []\n  offs_pred ns ub (x # xs) index key mi ma\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) =\n    None", "by (rule_tac fill_index_none [OF A],\n     simp_all)"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) =\n  None\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "ultimately"], ["proof (chain)\npicking this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) =\n  None", "have O: \"fill xs ?ns' index key ub mi ma = us @ None # ?ds\""], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) =\n  None\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma =\n    us @\n    None #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "using N"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) =\n  None\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) =\n  us\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma =\n    us @\n    None #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "by simp"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  us @\n  None #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] =\n    ?ts @ Some x # ?ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] =\n    take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) @\n    Some x #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "using K"], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] =\n    take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) @\n    Some x #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "by (rule_tac upd_conv_take_nth_drop, simp add: fill_length)"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "hence \"(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] =\n    us @ Some x # ?ds\""], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] =\n    us @\n    Some x #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "using N"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) =\n  us\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] =\n    us @\n    Some x #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "by simp"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  us @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "hence \"?ws' = Some x # [w\\<leftarrow>?ds. \\<exists>y. w = Some y \\<and> key y = key x]\""], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  us @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     ((fill xs\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        index key ub mi ma)\n      [ns ! index key x (length ns) mi ma := Some x]) =\n    Some x #\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (drop (Suc (ns ! index key x (length ns) mi ma))\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma))", "using M"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  us @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     ((fill xs\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        index key ub mi ma)\n      [ns ! index key x (length ns) mi ma := Some x]) =\n    Some x #\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (drop (Suc (ns ! index key x (length ns) mi ma))\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma))", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  Some x #\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   (drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma))\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "also"], ["proof (state)\nthis:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  Some x #\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   (drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma))\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"\\<dots> = Some x # ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some x #\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (drop (Suc (ns ! index key x (length ns) mi ma))\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)) =\n    Some x #\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "using M"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] = us @ w # vs \\<and>\n  (\\<forall>u\\<in>set us.\n      \\<forall>y. u = Some y \\<longrightarrow> key y \\<noteq> key x) \\<and>\n  w = Some y \\<and>\n  key y = key x \\<and>\n  ws = filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x) vs\n\ngoal (1 subgoal):\n 1. Some x #\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (drop (Suc (ns ! index key x (length ns) mi ma))\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)) =\n    Some x #\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "by (subst (2) O, simp)"], ["proof (state)\nthis:\n  Some x #\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   (drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)) =\n  Some x #\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (2 subgoals):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w.\n                          \\<exists>x. w = Some x \\<and> key x = key a)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. key a = key x) xs;\n        k = key a; ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = key a)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         a # filter (\\<lambda>x. key a = key x) xs\n 2. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "finally"], ["proof (chain)\npicking this:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  Some x #\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)", "show \"map the ?ws' = x # [y\\<leftarrow>xs. key x = key y]\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  Some x #\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. map the\n     (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n       ((fill xs\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key x (length ns) mi ma := Some x])) =\n    x # filter (\\<lambda>y. key x = key y) xs", "using J"], ["proof (prove)\nusing this:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  Some x #\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)) =\n  filter (\\<lambda>y. key x = key y) xs\n\ngoal (1 subgoal):\n 1. map the\n     (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n       ((fill xs\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key x (length ns) mi ma := Some x])) =\n    x # filter (\\<lambda>y. key x = key y) xs", "by simp"], ["proof (state)\nthis:\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = key x)\n     ((fill xs\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        index key ub mi ma)\n      [ns ! index key x (length ns) mi ma := Some x])) =\n  x # filter (\\<lambda>y. key x = key y) xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "fix x xs and ns :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "let ?i = \"index key x (length ns) mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "let ?ns' = \"ns[?i := Suc (ns ! ?i)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "let ?ws = \"[w\\<leftarrow>fill xs ?ns' index key ub mi ma. \\<exists>y. w = Some y \\<and> key y = k]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "let ?ws' = \"[w\\<leftarrow>(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x].\n    \\<exists>y. w = Some y \\<and> key y = k]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "assume\n    C: \"\\<forall>x \\<in> set xs. mi \\<le> key x \\<and> key x \\<le> ma\" and\n    D: \"mi \\<le> key x\" and\n    E: \"key x \\<le> ma\" and\n    F: \"ns \\<noteq> []\" and\n    G: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    H: \"k \\<noteq> key x\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  mi \\<le> key x\n  key x \\<le> ma\n  ns \\<noteq> []\n  offs_pred ns ub (x # xs) index key mi ma\n  k \\<noteq> key x\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have I: \"?i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "using A and D and E and F"], ["proof (prove)\nusing this:\n  index_less index key\n  mi \\<le> key x\n  key x \\<le> ma\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "assume \"\\<And>ns. ns \\<noteq> [] \\<longrightarrow> offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    map the [w\\<leftarrow>fill xs ns index key ub mi ma.\n      \\<exists>y. w = Some y \\<and> key y = k] =\n    [y\\<leftarrow>xs. k = key y]\""], ["proof (state)\nthis:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. k = key y) xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "moreover"], ["proof (state)\nthis:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. k = key y) xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"offs_pred ?ns' ub xs index key mi ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma", "using G and I"], ["proof (prove)\nusing this:\n  offs_pred ns ub (x # xs) index key mi ma\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma", "by (rule_tac offs_pred_cons, simp_all)"], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "ultimately"], ["proof (chain)\npicking this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. k = key y) xs\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma", "have J: \"map the ?ws = [y\\<leftarrow>xs. k = key y]\""], ["proof (prove)\nusing this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. k = key y) xs\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. map the\n     (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)) =\n    filter (\\<lambda>y. k = key y) xs", "using F"], ["proof (prove)\nusing this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs ?ns index key ub mi ma)) =\n  filter (\\<lambda>y. k = key y) xs\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. map the\n     (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)) =\n    filter (\\<lambda>y. k = key y) xs", "by simp"], ["proof (state)\nthis:\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)) =\n  filter (\\<lambda>y. k = key y) xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"ns ! ?i + offs_num (length ns) (x # xs) index key mi ma ?i \\<le> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma +\n    offs_num (length ns) (x # xs) index key mi ma\n     (index key x (length ns) mi ma)\n    \\<le> ub", "using G and I"], ["proof (prove)\nusing this:\n  offs_pred ns ub (x # xs) index key mi ma\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma +\n    offs_num (length ns) (x # xs) index key mi ma\n     (index key x (length ns) mi ma)\n    \\<le> ub", "by (rule offs_pred_ub, simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (x # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ub\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "hence K: \"ns ! ?i < ub\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (x # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ub\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma < ub", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"fill xs ?ns' index key ub mi ma =\n    take (ns ! ?i) (fill xs ?ns' index key ub mi ma) @\n    fill xs ?ns' index key ub mi ma ! (ns ! ?i) #\n    drop (Suc (ns ! ?i)) (fill xs ?ns' index key ub mi ma)\"\n    (is \"_ = ?ts @ _ # ?ds\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma =\n    take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) @\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "using K"], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma =\n    take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) @\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "by (rule_tac id_take_nth_drop, simp add: fill_length)"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "moreover"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"fill xs ?ns' index key ub mi ma ! (ns ! ?i) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) =\n    None", "using C and D and E and F and G"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  mi \\<le> key x\n  key x \\<le> ma\n  ns \\<noteq> []\n  offs_pred ns ub (x # xs) index key mi ma\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) =\n    None", "by (rule_tac fill_index_none [OF A],\n     simp_all)"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "ultimately"], ["proof (chain)\npicking this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) =\n  None", "have L: \"fill xs ?ns' index key ub mi ma = ?ts @ None # ?ds\""], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key x (length ns) mi ma) =\n  None\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma =\n    take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) @\n    None #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "by simp"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  None #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"(fill xs ?ns' index key ub mi ma)[ns ! ?i := Some x] =\n    ?ts @ Some x # ?ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] =\n    take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) @\n    Some x #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "using K"], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] =\n    take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) @\n    Some x #\n    drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "by (rule_tac upd_conv_take_nth_drop, simp add: fill_length)"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "moreover"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "have \"?ws = [w\\<leftarrow>?ts. \\<exists>y. w = Some y \\<and> key y = k] @\n    [w\\<leftarrow>?ds. \\<exists>y. w = Some y \\<and> key y = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma) =\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (take (ns ! index key x (length ns) mi ma)\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma)) @\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (drop (Suc (ns ! index key x (length ns) mi ma))\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma))", "by (subst L, simp)"], ["proof (state)\nthis:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) =\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)) @\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "ultimately"], ["proof (chain)\npicking this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) =\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)) @\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma))", "have \"?ws' = ?ws\""], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) =\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)) @\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     ((fill xs\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        index key ub mi ma)\n      [ns ! index key x (length ns) mi ma := Some x]) =\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "using H"], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] =\n  take (ns ! index key x (length ns) mi ma)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) @\n  Some x #\n  drop (Suc (ns ! index key x (length ns) mi ma))\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma) =\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (take (ns ! index key x (length ns) mi ma)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)) @\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (drop (Suc (ns ! index key x (length ns) mi ma))\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma))\n  k \\<noteq> key x\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     ((fill xs\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        index key ub mi ma)\n      [ns ! index key x (length ns) mi ma := Some x]) =\n    filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   map the\n                    (filter\n                      (\\<lambda>w. \\<exists>x. w = Some x \\<and> key x = k)\n                      (fill xs ns index key ub mi ma)) =\n                   filter (\\<lambda>x. k = key x) xs;\n        k \\<noteq> key a; ns \\<noteq> [];\n        offs_pred ns ub (a # xs) index key mi ma; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> map the\n                          (filter\n                            (\\<lambda>w.\n                                \\<exists>x. w = Some x \\<and> key x = k)\n                            ((fill xs\n                               (ns[index key a (length ns) mi ma :=\n                                     Suc\n(ns ! index key a (length ns) mi ma)])\n                               index key ub mi ma)\n                             [ns ! index key a (length ns) mi ma :=\n                                Some a])) =\n                         filter (\\<lambda>x. k = key x) xs", "thus \"map the ?ws' = [y\\<leftarrow>xs. k = key y]\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n\ngoal (1 subgoal):\n 1. map the\n     (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n       ((fill xs\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key x (length ns) mi ma := Some x])) =\n    filter (\\<lambda>y. k = key y) xs", "using J"], ["proof (prove)\nusing this:\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   ((fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x]) =\n  filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n   (fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma)\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma)) =\n  filter (\\<lambda>y. k = key y) xs\n\ngoal (1 subgoal):\n 1. map the\n     (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n       ((fill xs\n          (ns[index key x (length ns) mi ma :=\n                Suc (ns ! index key x (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key x (length ns) mi ma := Some x])) =\n    filter (\\<lambda>y. k = key y) xs", "by simp"], ["proof (state)\nthis:\n  map the\n   (filter (\\<lambda>w. \\<exists>y. w = Some y \\<and> key y = k)\n     ((fill xs\n        (ns[index key x (length ns) mi ma :=\n              Suc (ns ! index key x (length ns) mi ma)])\n        index key ub mi ma)\n      [ns ! index key x (length ns) mi ma := Some x])) =\n  filter (\\<lambda>y. k = key y) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fill_offs_enum_stable [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_same index key\"\n  shows\n   \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n    0 < n \\<Longrightarrow>\n      [x\\<leftarrow>map the (fill xs (offs (enum xs index key n mi ma) 0)\n        index key (length xs) mi ma). key x = k] = [x\\<leftarrow>xs. k = key x]\"\n  (is \"_ \\<Longrightarrow> _ \\<Longrightarrow> [_\\<leftarrow>map the ?ys. _] = _\"\n   is \"_ \\<Longrightarrow> _ \\<Longrightarrow> [_\\<leftarrow>map the (fill _ ?ns _ _ _ _ _). _] = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. key x \\<in> {mi..ma}; 0 < n\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (map the\n                         (fill xs (offs (enum xs index key n mi ma) 0) index\n                           key (length xs) mi ma)) =\n                      filter (\\<lambda>x. k = key x) xs", "proof (subst fill_stable [symmetric, OF A B, of xs mi ma ?ns], simp,\n simp only: length_greater_0_conv [symmetric] offs_length enum_length,\n rule offs_enum_pred [OF A], simp, subst filter_map,\n simp add: filter_eq_nths fill_length)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < n\\<rbrakk>\n    \\<Longrightarrow> map the\n                       (nths\n                         (fill xs (offs (enum xs index key n mi ma) 0) index\n                           key (length xs) mi ma)\n                         {i. i < length xs \\<and>\n                             key (the (fill xs\n  (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n i)) =\n                             k}) =\n                      map the\n                       (nths\n                         (fill xs (offs (enum xs index key n mi ma) 0) index\n                           key (length xs) mi ma)\n                         {i. i < length xs \\<and>\n                             (\\<exists>x.\n                                 fill xs\n                                  (offs (enum xs index key n mi ma) 0) index\n                                  key (length xs) mi ma !\n                                 i =\n                                 Some x \\<and>\n                                 key x = k)})", "assume\n    C: \"\\<forall>x \\<in> set xs. mi \\<le> key x \\<and> key x \\<le> ma\" and\n    D: \"0 < n\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < n\\<rbrakk>\n    \\<Longrightarrow> map the\n                       (nths\n                         (fill xs (offs (enum xs index key n mi ma) 0) index\n                           key (length xs) mi ma)\n                         {i. i < length xs \\<and>\n                             key (the (fill xs\n  (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n i)) =\n                             k}) =\n                      map the\n                       (nths\n                         (fill xs (offs (enum xs index key n mi ma) 0) index\n                           key (length xs) mi ma)\n                         {i. i < length xs \\<and>\n                             (\\<exists>x.\n                                 fill xs\n                                  (offs (enum xs index key n mi ma) 0) index\n                                  key (length xs) mi ma !\n                                 i =\n                                 Some x \\<and>\n                                 key x = k)})", "have \"{i. i < length xs \\<and> key (the (?ys ! i)) = k} =\n    {i. i < length xs \\<and> (\\<exists>x. ?ys ! i = Some x \\<and> key x = k)}\"\n    (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and>\n        key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                   (length xs) mi ma !\n                  i)) =\n        k} =\n    {i. i < length xs \\<and>\n        (\\<exists>x.\n            fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma !\n            i =\n            Some x \\<and>\n            key x = k)}", "proof (rule set_eqI, rule iffI, simp_all, erule_tac [!] conjE, erule_tac [2] exE,\n   erule_tac [2] conjE, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length xs;\n        key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                   (length xs) mi ma !\n                  x)) =\n        k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            fill xs (offs (enum xs index key n mi ma) 0)\n                             index key (length xs) mi ma !\n                            x =\n                            Some xa \\<and>\n                            key xa = k", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length xs;\n        key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                   (length xs) mi ma !\n                  x)) =\n        k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            fill xs (offs (enum xs index key n mi ma) 0)\n                             index key (length xs) mi ma !\n                            x =\n                            Some xa \\<and>\n                            key xa = k", "assume E: \"i < length xs\" and F: \"key (the (?ys ! i)) = k\""], ["proof (state)\nthis:\n  i < length xs\n  key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma !\n            i)) =\n  k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length xs;\n        key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                   (length xs) mi ma !\n                  x)) =\n        k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            fill xs (offs (enum xs index key n mi ma) 0)\n                             index key (length xs) mi ma !\n                            x =\n                            Some xa \\<and>\n                            key xa = k", "have \"\\<exists>x. ?ys ! i = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n        ma !\n       i =\n       Some x", "proof (cases \"?ys ! i\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    i =\n    None \\<Longrightarrow>\n    False", "assume \"?ys ! i = None\""], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    i =\n    None \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    i =\n    None \\<Longrightarrow>\n    False", "have \"?ys ! i \\<in> set ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    i\n    \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma)", "using E"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    i\n    \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma)", "by (rule_tac nth_mem, simp add: fill_length)"], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    i =\n    None \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  None\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)", "have \"None \\<in> set ?ys\""], ["proof (prove)\nusing this:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  None\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n\ngoal (1 subgoal):\n 1. None\n    \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma)", "by simp"], ["proof (state)\nthis:\n  None\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    i =\n    None \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  None\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    i =\n    None \\<Longrightarrow>\n    False", "have \"count (mset ?ys) None = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count\n     (mset\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma))\n     None =\n    0", "using C and D"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  0 < n\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma))\n     None =\n    0", "by (rule_tac fill_offs_enum_count_none [OF A], simp)"], ["proof (state)\nthis:\n  count\n   (mset\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma))\n   None =\n  0\n\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    i =\n    None \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  None\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n  count\n   (mset\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma))\n   None =\n  0", "show False"], ["proof (prove)\nusing this:\n  None\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n  count\n   (mset\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma))\n   None =\n  0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     i =\n     Some x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length xs;\n        key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                   (length xs) mi ma !\n                  x)) =\n        k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            fill xs (offs (enum xs index key n mi ma) 0)\n                             index key (length xs) mi ma !\n                            x =\n                            Some xa \\<and>\n                            key xa = k", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     i =\n     Some x", "obtain x where \"?ys ! i = Some x\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     i =\n     Some x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        Some x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  Some x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length xs;\n        key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                   (length xs) mi ma !\n                  x)) =\n        k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            fill xs (offs (enum xs index key n mi ma) 0)\n                             index key (length xs) mi ma !\n                            x =\n                            Some xa \\<and>\n                            key xa = k", "moreover"], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  Some x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length xs;\n        key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                   (length xs) mi ma !\n                  x)) =\n        k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            fill xs (offs (enum xs index key n mi ma) 0)\n                             index key (length xs) mi ma !\n                            x =\n                            Some xa \\<and>\n                            key xa = k", "from this"], ["proof (chain)\npicking this:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  Some x", "have \"key x = k\""], ["proof (prove)\nusing this:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  Some x\n\ngoal (1 subgoal):\n 1. key x = k", "using F"], ["proof (prove)\nusing this:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  Some x\n  key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma !\n            i)) =\n  k\n\ngoal (1 subgoal):\n 1. key x = k", "by simp"], ["proof (state)\nthis:\n  key x = k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length xs;\n        key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                   (length xs) mi ma !\n                  x)) =\n        k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            fill xs (offs (enum xs index key n mi ma) 0)\n                             index key (length xs) mi ma !\n                            x =\n                            Some xa \\<and>\n                            key xa = k", "ultimately"], ["proof (chain)\npicking this:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  Some x\n  key x = k", "show \"\\<exists>x. ?ys ! i = Some x \\<and> key x = k\""], ["proof (prove)\nusing this:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  i =\n  Some x\n  key x = k\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n        ma !\n       i =\n       Some x \\<and>\n       key x = k", "by simp"], ["proof (state)\nthis:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     i =\n     Some x \\<and>\n     key x = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {i. i < length xs \\<and>\n      key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                 (length xs) mi ma !\n                i)) =\n      k} =\n  {i. i < length xs \\<and>\n      (\\<exists>x.\n          fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma !\n          i =\n          Some x \\<and>\n          key x = k)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < n\\<rbrakk>\n    \\<Longrightarrow> map the\n                       (nths\n                         (fill xs (offs (enum xs index key n mi ma) 0) index\n                           key (length xs) mi ma)\n                         {i. i < length xs \\<and>\n                             key (the (fill xs\n  (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n i)) =\n                             k}) =\n                      map the\n                       (nths\n                         (fill xs (offs (enum xs index key n mi ma) 0) index\n                           key (length xs) mi ma)\n                         {i. i < length xs \\<and>\n                             (\\<exists>x.\n                                 fill xs\n                                  (offs (enum xs index key n mi ma) 0) index\n                                  key (length xs) mi ma !\n                                 i =\n                                 Some x \\<and>\n                                 key x = k)})", "thus \"map the (nths ?ys ?A) = map the (nths ?ys ?B)\""], ["proof (prove)\nusing this:\n  {i. i < length xs \\<and>\n      key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                 (length xs) mi ma !\n                i)) =\n      k} =\n  {i. i < length xs \\<and>\n      (\\<exists>x.\n          fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma !\n          i =\n          Some x \\<and>\n          key x = k)}\n\ngoal (1 subgoal):\n 1. map the\n     (nths\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)\n       {i. i < length xs \\<and>\n           key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                      (length xs) mi ma !\n                     i)) =\n           k}) =\n    map the\n     (nths\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)\n       {i. i < length xs \\<and>\n           (\\<exists>x.\n               fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma !\n               i =\n               Some x \\<and>\n               key x = k)})", "by simp"], ["proof (state)\nthis:\n  map the\n   (nths\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma)\n     {i. i < length xs \\<and>\n         key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                    (length xs) mi ma !\n                   i)) =\n         k}) =\n  map the\n   (nths\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma)\n     {i. i < length xs \\<and>\n         (\\<exists>x.\n             fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma !\n             i =\n             Some x \\<and>\n             key x = k)})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mini_first [rule_format]:\n \"xs \\<noteq> [] \\<longrightarrow> i < mini xs key \\<longrightarrow>\n    key (xs ! mini xs key) < key (xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    i < mini xs key \\<longrightarrow> key (xs ! mini xs key) < key (xs ! i)", "by (induction xs arbitrary: i, simp_all add: Let_def, (rule impI)+,\n erule conjE, simp add: not_le nth_Cons split: nat.split)"], ["", "lemma maxi_last [rule_format]:\n \"xs \\<noteq> [] \\<longrightarrow> maxi xs key < i \\<longrightarrow> i < length xs \\<longrightarrow>\n    key (xs ! i) < key (xs ! maxi xs key)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    maxi xs key < i \\<longrightarrow>\n    i < length xs \\<longrightarrow> key (xs ! i) < key (xs ! maxi xs key)", "by (induction xs arbitrary: i, simp_all add: Let_def, (rule impI)+,\n rule le_less_trans, rule maxi_ub, rule nth_mem, simp)"], ["", "lemma nths_range:\n \"nths xs A = nths xs (A \\<inter> {..<length xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths xs A = nths xs (A \\<inter> {..<length xs})", "proof (induction xs arbitrary: A, simp_all add: nths_Cons)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs A.\n       (\\<And>A.\n           nths xs A =\n           nths xs (A \\<inter> {..<length xs})) \\<Longrightarrow>\n       nths xs {j. Suc j \\<in> A} =\n       nths xs {j. Suc j \\<in> A \\<and> j < length xs}", "fix xs :: \"'a list\" and A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs A.\n       (\\<And>A.\n           nths xs A =\n           nths xs (A \\<inter> {..<length xs})) \\<Longrightarrow>\n       nths xs {j. Suc j \\<in> A} =\n       nths xs {j. Suc j \\<in> A \\<and> j < length xs}", "assume \"\\<And>A. nths xs A = nths xs (A \\<inter> {..<length xs})\""], ["proof (state)\nthis:\n  nths xs ?A = nths xs (?A \\<inter> {..<length xs})\n\ngoal (1 subgoal):\n 1. \\<And>xs A.\n       (\\<And>A.\n           nths xs A =\n           nths xs (A \\<inter> {..<length xs})) \\<Longrightarrow>\n       nths xs {j. Suc j \\<in> A} =\n       nths xs {j. Suc j \\<in> A \\<and> j < length xs}", "hence \"nths xs {i. Suc i \\<in> A} = nths xs ({i. Suc i \\<in> A} \\<inter> {..<length xs})\""], ["proof (prove)\nusing this:\n  nths xs ?A = nths xs (?A \\<inter> {..<length xs})\n\ngoal (1 subgoal):\n 1. nths xs {i. Suc i \\<in> A} =\n    nths xs ({i. Suc i \\<in> A} \\<inter> {..<length xs})", "."], ["proof (state)\nthis:\n  nths xs {i. Suc i \\<in> A} =\n  nths xs ({i. Suc i \\<in> A} \\<inter> {..<length xs})\n\ngoal (1 subgoal):\n 1. \\<And>xs A.\n       (\\<And>A.\n           nths xs A =\n           nths xs (A \\<inter> {..<length xs})) \\<Longrightarrow>\n       nths xs {j. Suc j \\<in> A} =\n       nths xs {j. Suc j \\<in> A \\<and> j < length xs}", "moreover"], ["proof (state)\nthis:\n  nths xs {i. Suc i \\<in> A} =\n  nths xs ({i. Suc i \\<in> A} \\<inter> {..<length xs})\n\ngoal (1 subgoal):\n 1. \\<And>xs A.\n       (\\<And>A.\n           nths xs A =\n           nths xs (A \\<inter> {..<length xs})) \\<Longrightarrow>\n       nths xs {j. Suc j \\<in> A} =\n       nths xs {j. Suc j \\<in> A \\<and> j < length xs}", "have\n   \"{i. Suc i \\<in> A} \\<inter> {..<length xs} = {i. Suc i \\<in> A \\<and> i < length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. Suc i \\<in> A} \\<inter> {..<length xs} =\n    {i. Suc i \\<in> A \\<and> i < length xs}", "by blast"], ["proof (state)\nthis:\n  {i. Suc i \\<in> A} \\<inter> {..<length xs} =\n  {i. Suc i \\<in> A \\<and> i < length xs}\n\ngoal (1 subgoal):\n 1. \\<And>xs A.\n       (\\<And>A.\n           nths xs A =\n           nths xs (A \\<inter> {..<length xs})) \\<Longrightarrow>\n       nths xs {j. Suc j \\<in> A} =\n       nths xs {j. Suc j \\<in> A \\<and> j < length xs}", "ultimately"], ["proof (chain)\npicking this:\n  nths xs {i. Suc i \\<in> A} =\n  nths xs ({i. Suc i \\<in> A} \\<inter> {..<length xs})\n  {i. Suc i \\<in> A} \\<inter> {..<length xs} =\n  {i. Suc i \\<in> A \\<and> i < length xs}", "show\n   \"nths xs {i. Suc i \\<in> A} = nths xs {i. Suc i \\<in> A \\<and> i < length xs}\""], ["proof (prove)\nusing this:\n  nths xs {i. Suc i \\<in> A} =\n  nths xs ({i. Suc i \\<in> A} \\<inter> {..<length xs})\n  {i. Suc i \\<in> A} \\<inter> {..<length xs} =\n  {i. Suc i \\<in> A \\<and> i < length xs}\n\ngoal (1 subgoal):\n 1. nths xs {i. Suc i \\<in> A} =\n    nths xs {i. Suc i \\<in> A \\<and> i < length xs}", "by simp"], ["proof (state)\nthis:\n  nths xs {i. Suc i \\<in> A} =\n  nths xs {i. Suc i \\<in> A \\<and> i < length xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_nths_diff:\n  assumes\n    A: \"i < length xs\" and\n    B: \"\\<not> P (xs ! i)\"\n  shows \"[x\\<leftarrow>nths xs (A - {i}). P x] = [x\\<leftarrow>nths xs A. P x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (nths xs (A - {i})) = filter P (nths xs A)", "proof (cases \"i \\<in> A\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "case True"], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "have C: \"xs = take i xs @ xs ! i # drop (Suc i) xs\"\n    (is \"_ = ?ts @ _ # ?ds\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = take i xs @ xs ! i # drop (Suc i) xs", "using A"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. xs = take i xs @ xs ! i # drop (Suc i) xs", "by (rule id_take_nth_drop)"], ["proof (state)\nthis:\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "have \"nths xs A = nths ?ts A @ nths (xs ! i # ?ds) {j. j + length ?ts \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths xs A =\n    nths (take i xs) A @\n    nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A}", "by (subst C, simp add: nths_append)"], ["proof (state)\nthis:\n  nths xs A =\n  nths (take i xs) A @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "moreover"], ["proof (state)\nthis:\n  nths xs A =\n  nths (take i xs) A @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "have D: \"length ?ts = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take i xs) = i", "using A"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (take i xs) = i", "by simp"], ["proof (state)\nthis:\n  length (take i xs) = i\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "ultimately"], ["proof (chain)\npicking this:\n  nths xs A =\n  nths (take i xs) A @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A}\n  length (take i xs) = i", "have E: \"nths xs A = nths ?ts (A \\<inter> {..<i}) @ xs ! i #\n    nths ?ds {j. Suc j + i \\<in> A}\"\n    (is \"_ = ?vs @ _ # ?ws\")"], ["proof (prove)\nusing this:\n  nths xs A =\n  nths (take i xs) A @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A}\n  length (take i xs) = i\n\ngoal (1 subgoal):\n 1. nths xs A =\n    nths (take i xs) (A \\<inter> {..<i}) @\n    xs ! i # nths (drop (Suc i) xs) {j. Suc j + i \\<in> A}", "using True"], ["proof (prove)\nusing this:\n  nths xs A =\n  nths (take i xs) A @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A}\n  length (take i xs) = i\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. nths xs A =\n    nths (take i xs) (A \\<inter> {..<i}) @\n    xs ! i # nths (drop (Suc i) xs) {j. Suc j + i \\<in> A}", "by (simp add: nths_Cons, subst nths_range, simp)"], ["proof (state)\nthis:\n  nths xs A =\n  nths (take i xs) (A \\<inter> {..<i}) @\n  xs ! i # nths (drop (Suc i) xs) {j. Suc j + i \\<in> A}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "have \"nths xs (A - {i}) = nths ?ts (A - {i}) @\n    nths (xs ! i # ?ds) {j. j + length ?ts \\<in> A - {i}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths xs (A - {i}) =\n    nths (take i xs) (A - {i}) @\n    nths (xs ! i # drop (Suc i) xs)\n     {j. j + length (take i xs) \\<in> A - {i}}", "by (subst C, simp add: nths_append)"], ["proof (state)\nthis:\n  nths xs (A - {i}) =\n  nths (take i xs) (A - {i}) @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A - {i}}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "moreover"], ["proof (state)\nthis:\n  nths xs (A - {i}) =\n  nths (take i xs) (A - {i}) @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A - {i}}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "have \"(A - {i}) \\<inter> {..<i} = A \\<inter> {..<i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - {i}) \\<inter> {..<i} = A \\<inter> {..<i}", "by (rule set_eqI, rule iffI, simp_all)"], ["proof (state)\nthis:\n  (A - {i}) \\<inter> {..<i} = A \\<inter> {..<i}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "ultimately"], ["proof (chain)\npicking this:\n  nths xs (A - {i}) =\n  nths (take i xs) (A - {i}) @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A - {i}}\n  (A - {i}) \\<inter> {..<i} = A \\<inter> {..<i}", "have \"nths xs (A - {i}) = ?vs @ ?ws\""], ["proof (prove)\nusing this:\n  nths xs (A - {i}) =\n  nths (take i xs) (A - {i}) @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A - {i}}\n  (A - {i}) \\<inter> {..<i} = A \\<inter> {..<i}\n\ngoal (1 subgoal):\n 1. nths xs (A - {i}) =\n    nths (take i xs) (A \\<inter> {..<i}) @\n    nths (drop (Suc i) xs) {j. Suc j + i \\<in> A}", "using D"], ["proof (prove)\nusing this:\n  nths xs (A - {i}) =\n  nths (take i xs) (A - {i}) @\n  nths (xs ! i # drop (Suc i) xs) {j. j + length (take i xs) \\<in> A - {i}}\n  (A - {i}) \\<inter> {..<i} = A \\<inter> {..<i}\n  length (take i xs) = i\n\ngoal (1 subgoal):\n 1. nths xs (A - {i}) =\n    nths (take i xs) (A \\<inter> {..<i}) @\n    nths (drop (Suc i) xs) {j. Suc j + i \\<in> A}", "by (simp add: nths_Cons, subst nths_range, simp)"], ["proof (state)\nthis:\n  nths xs (A - {i}) =\n  nths (take i xs) (A \\<inter> {..<i}) @\n  nths (drop (Suc i) xs) {j. Suc j + i \\<in> A}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    filter P (nths xs (A - {i})) = filter P (nths xs A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  nths xs (A - {i}) =\n  nths (take i xs) (A \\<inter> {..<i}) @\n  nths (drop (Suc i) xs) {j. Suc j + i \\<in> A}\n\ngoal (1 subgoal):\n 1. filter P (nths xs (A - {i})) = filter P (nths xs A)", "using B and E"], ["proof (prove)\nusing this:\n  nths xs (A - {i}) =\n  nths (take i xs) (A \\<inter> {..<i}) @\n  nths (drop (Suc i) xs) {j. Suc j + i \\<in> A}\n  \\<not> P (xs ! i)\n  nths xs A =\n  nths (take i xs) (A \\<inter> {..<i}) @\n  xs ! i # nths (drop (Suc i) xs) {j. Suc j + i \\<in> A}\n\ngoal (1 subgoal):\n 1. filter P (nths xs (A - {i})) = filter P (nths xs A)", "by simp"], ["proof (state)\nthis:\n  filter P (nths xs (A - {i})) = filter P (nths xs A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mini_stable:\n  assumes\n    A: \"xs \\<noteq> []\" and\n    B: \"mini xs key \\<in> A\"\n      (is \"?nmi \\<in> _\")\n  shows \"[x\\<leftarrow>[xs ! ?nmi] @ nths xs (A - {?nmi}). key x = k] =\n    [x\\<leftarrow>nths xs A. key x = k]\"\n    (is \"[x\\<leftarrow>[?xmi] @ _. _] = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     ([xs ! mini xs key] @ nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "proof (simp, rule conjI, rule_tac [!] impI, rule_tac [2] filter_nths_diff,\n rule_tac [2] mini_less, simp_all add: A)"], ["proof (state)\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "assume C: \"key ?xmi = k\""], ["proof (state)\nthis:\n  key (xs ! mini xs key) = k\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "moreover"], ["proof (state)\nthis:\n  key (xs ! mini xs key) = k\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"?nmi < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mini xs key < length xs", "using A"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. mini xs key < length xs", "by (rule_tac mini_less, simp)"], ["proof (state)\nthis:\n  mini xs key < length xs\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "ultimately"], ["proof (chain)\npicking this:\n  key (xs ! mini xs key) = k\n  mini xs key < length xs", "have \"0 < length [x\\<leftarrow>xs. key x = k]\""], ["proof (prove)\nusing this:\n  key (xs ! mini xs key) = k\n  mini xs key < length xs\n\ngoal (1 subgoal):\n 1. 0 < length (filter (\\<lambda>x. key x = k) xs)", "by (simp add: length_filter_conv_card card_gt_0_iff, rule_tac exI, rule_tac conjI)"], ["proof (state)\nthis:\n  0 < length (filter (\\<lambda>x. key x = k) xs)\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "hence \"\\<exists>y ys. [x\\<leftarrow>xs. key x = k] = y # ys\""], ["proof (prove)\nusing this:\n  0 < length (filter (\\<lambda>x. key x = k) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>y ys. filter (\\<lambda>x. key x = k) xs = y # ys", "by (rule_tac list.exhaust [of \"[x\\<leftarrow>xs. key x = k]\"], simp_all)"], ["proof (state)\nthis:\n  \\<exists>y ys. filter (\\<lambda>x. key x = k) xs = y # ys\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "then"], ["proof (chain)\npicking this:\n  \\<exists>y ys. filter (\\<lambda>x. key x = k) xs = y # ys", "obtain y and ys where \"[x\\<leftarrow>xs. key x = k] = y # ys\""], ["proof (prove)\nusing this:\n  \\<exists>y ys. filter (\\<lambda>x. key x = k) xs = y # ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        filter (\\<lambda>x. key x = k) xs = y # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) xs = y # ys\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "hence \"\\<exists>us vs. xs = us @ y # vs \\<and>\n    (\\<forall>u \\<in> set us. key u \\<noteq> k) \\<and> key y = k \\<and> ys = [x\\<leftarrow>vs. key x = k]\"\n    (is \"\\<exists>us vs. ?P us vs\")"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. key x = k) xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ y # vs \\<and>\n       (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n       key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs", "by (simp add: filter_eq_Cons_iff)"], ["proof (state)\nthis:\n  \\<exists>us vs.\n     xs = us @ y # vs \\<and>\n     (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n     key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "then"], ["proof (chain)\npicking this:\n  \\<exists>us vs.\n     xs = us @ y # vs \\<and>\n     (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n     key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs", "obtain us and vs where D: \"?P us vs\""], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     xs = us @ y # vs \\<and>\n     (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n     key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        xs = us @ y # vs \\<and>\n        (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n        key y = k \\<and>\n        ys = filter (\\<lambda>x. key x = k) vs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have E: \"length us = ?nmi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us = mini xs key", "proof (rule ccontr, erule neqE)"], ["proof (state)\ngoal (2 subgoals):\n 1. length us < mini xs key \\<Longrightarrow> False\n 2. mini xs key < length us \\<Longrightarrow> False", "assume \"length us < ?nmi\""], ["proof (state)\nthis:\n  length us < mini xs key\n\ngoal (2 subgoals):\n 1. length us < mini xs key \\<Longrightarrow> False\n 2. mini xs key < length us \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  length us < mini xs key", "have \"key ?xmi < key (xs ! length us)\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  length us < mini xs key\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) < key (xs ! length us)", "by (rule mini_first)"], ["proof (state)\nthis:\n  key (xs ! mini xs key) < key (xs ! length us)\n\ngoal (2 subgoals):\n 1. length us < mini xs key \\<Longrightarrow> False\n 2. mini xs key < length us \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  key (xs ! mini xs key) < key (xs ! length us)\n\ngoal (2 subgoals):\n 1. length us < mini xs key \\<Longrightarrow> False\n 2. mini xs key < length us \\<Longrightarrow> False", "have \"\\<dots> = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key (xs ! length us) = k", "using D"], ["proof (prove)\nusing this:\n  xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. key (xs ! length us) = k", "by simp"], ["proof (state)\nthis:\n  key (xs ! length us) = k\n\ngoal (2 subgoals):\n 1. length us < mini xs key \\<Longrightarrow> False\n 2. mini xs key < length us \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  key (xs ! mini xs key) < k", "show False"], ["proof (prove)\nusing this:\n  key (xs ! mini xs key) < k\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  key (xs ! mini xs key) < k\n  key (xs ! mini xs key) = k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. mini xs key < length us \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mini xs key < length us \\<Longrightarrow> False", "assume F: \"?nmi < length us\""], ["proof (state)\nthis:\n  mini xs key < length us\n\ngoal (1 subgoal):\n 1. mini xs key < length us \\<Longrightarrow> False", "hence \"?xmi = us ! ?nmi\""], ["proof (prove)\nusing this:\n  mini xs key < length us\n\ngoal (1 subgoal):\n 1. xs ! mini xs key = us ! mini xs key", "using D"], ["proof (prove)\nusing this:\n  mini xs key < length us\n  xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. xs ! mini xs key = us ! mini xs key", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  xs ! mini xs key = us ! mini xs key\n\ngoal (1 subgoal):\n 1. mini xs key < length us \\<Longrightarrow> False", "hence \"?xmi \\<in> set us\""], ["proof (prove)\nusing this:\n  xs ! mini xs key = us ! mini xs key\n\ngoal (1 subgoal):\n 1. xs ! mini xs key \\<in> set us", "using F"], ["proof (prove)\nusing this:\n  xs ! mini xs key = us ! mini xs key\n  mini xs key < length us\n\ngoal (1 subgoal):\n 1. xs ! mini xs key \\<in> set us", "by simp"], ["proof (state)\nthis:\n  xs ! mini xs key \\<in> set us\n\ngoal (1 subgoal):\n 1. mini xs key < length us \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  xs ! mini xs key \\<in> set us\n\ngoal (1 subgoal):\n 1. False", "using C and D"], ["proof (prove)\nusing this:\n  xs ! mini xs key \\<in> set us\n  key (xs ! mini xs key) = k\n  xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length us = mini xs key\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "moreover"], ["proof (state)\nthis:\n  length us = mini xs key\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"xs ! length us = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! length us = y", "using D"], ["proof (prove)\nusing this:\n  xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. xs ! length us = y", "by simp"], ["proof (state)\nthis:\n  xs ! length us = y\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "ultimately"], ["proof (chain)\npicking this:\n  length us = mini xs key\n  xs ! length us = y", "have F: \"?xmi = y\""], ["proof (prove)\nusing this:\n  length us = mini xs key\n  xs ! length us = y\n\ngoal (1 subgoal):\n 1. xs ! mini xs key = y", "by simp"], ["proof (state)\nthis:\n  xs ! mini xs key = y\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"nths xs A = nths us A @ nths (y # vs) {i. i + ?nmi \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths xs A = nths us A @ nths (y # vs) {i. i + mini xs key \\<in> A}", "using D and E"], ["proof (prove)\nusing this:\n  xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n  length us = mini xs key\n\ngoal (1 subgoal):\n 1. nths xs A = nths us A @ nths (y # vs) {i. i + mini xs key \\<in> A}", "by (simp add: nths_append)"], ["proof (state)\nthis:\n  nths xs A = nths us A @ nths (y # vs) {i. i + mini xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "also"], ["proof (state)\nthis:\n  nths xs A = nths us A @ nths (y # vs) {i. i + mini xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"\\<dots> = nths us A @ y # nths vs {i. Suc i + ?nmi \\<in> A}\"\n    (is \"_ = _ @ _ # ?ws\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths us A @ nths (y # vs) {i. i + mini xs key \\<in> A} =\n    nths us A @ y # nths vs {i. Suc i + mini xs key \\<in> A}", "using B"], ["proof (prove)\nusing this:\n  mini xs key \\<in> A\n\ngoal (1 subgoal):\n 1. nths us A @ nths (y # vs) {i. i + mini xs key \\<in> A} =\n    nths us A @ y # nths vs {i. Suc i + mini xs key \\<in> A}", "by (simp add: nths_Cons)"], ["proof (state)\nthis:\n  nths us A @ nths (y # vs) {i. i + mini xs key \\<in> A} =\n  nths us A @ y # nths vs {i. Suc i + mini xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "finally"], ["proof (chain)\npicking this:\n  nths xs A = nths us A @ y # nths vs {i. Suc i + mini xs key \\<in> A}", "have G: \"[x\\<leftarrow>nths xs A. key x = k] = y # [x\\<leftarrow>?ws. key x = k]\""], ["proof (prove)\nusing this:\n  nths xs A = nths us A @ y # nths vs {i. Suc i + mini xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs A) =\n    y #\n    filter (\\<lambda>x. key x = k)\n     (nths vs {i. Suc i + mini xs key \\<in> A})", "using D"], ["proof (prove)\nusing this:\n  nths xs A = nths us A @ y # nths vs {i. Suc i + mini xs key \\<in> A}\n  xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs A) =\n    y #\n    filter (\\<lambda>x. key x = k)\n     (nths vs {i. Suc i + mini xs key \\<in> A})", "by (simp add: filter_empty_conv, rule_tac ballI,\n     drule_tac in_set_nthsD, simp)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) (nths xs A) =\n  y #\n  filter (\\<lambda>x. key x = k) (nths vs {i. Suc i + mini xs key \\<in> A})\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"nths xs (A - {?nmi}) = nths us (A - {?nmi}) @\n    nths (y # vs) {i. i + ?nmi \\<in> A - {?nmi}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths xs (A - {mini xs key}) =\n    nths us (A - {mini xs key}) @\n    nths (y # vs) {i. i + mini xs key \\<in> A - {mini xs key}}", "using D and E"], ["proof (prove)\nusing this:\n  xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n  length us = mini xs key\n\ngoal (1 subgoal):\n 1. nths xs (A - {mini xs key}) =\n    nths us (A - {mini xs key}) @\n    nths (y # vs) {i. i + mini xs key \\<in> A - {mini xs key}}", "by (simp add: nths_append)"], ["proof (state)\nthis:\n  nths xs (A - {mini xs key}) =\n  nths us (A - {mini xs key}) @\n  nths (y # vs) {i. i + mini xs key \\<in> A - {mini xs key}}\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "also"], ["proof (state)\nthis:\n  nths xs (A - {mini xs key}) =\n  nths us (A - {mini xs key}) @\n  nths (y # vs) {i. i + mini xs key \\<in> A - {mini xs key}}\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"\\<dots> = nths us (A - {?nmi}) @ ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths us (A - {mini xs key}) @\n    nths (y # vs) {i. i + mini xs key \\<in> A - {mini xs key}} =\n    nths us (A - {mini xs key}) @ nths vs {i. Suc i + mini xs key \\<in> A}", "by (simp add: nths_Cons)"], ["proof (state)\nthis:\n  nths us (A - {mini xs key}) @\n  nths (y # vs) {i. i + mini xs key \\<in> A - {mini xs key}} =\n  nths us (A - {mini xs key}) @ nths vs {i. Suc i + mini xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "finally"], ["proof (chain)\npicking this:\n  nths xs (A - {mini xs key}) =\n  nths us (A - {mini xs key}) @ nths vs {i. Suc i + mini xs key \\<in> A}", "have H: \"[x\\<leftarrow>nths xs (A - {?nmi}). key x = k] = [x\\<leftarrow>?ws. key x = k]\""], ["proof (prove)\nusing this:\n  nths xs (A - {mini xs key}) =\n  nths us (A - {mini xs key}) @ nths vs {i. Suc i + mini xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k)\n     (nths vs {i. Suc i + mini xs key \\<in> A})", "using D"], ["proof (prove)\nusing this:\n  nths xs (A - {mini xs key}) =\n  nths us (A - {mini xs key}) @ nths vs {i. Suc i + mini xs key \\<in> A}\n  xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k)\n     (nths vs {i. Suc i + mini xs key \\<in> A})", "by (simp add: filter_empty_conv, rule_tac ballI,\n     drule_tac in_set_nthsD, simp)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n  filter (\\<lambda>x. key x = k) (nths vs {i. Suc i + mini xs key \\<in> A})\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = k \\<Longrightarrow>\n    xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "show \"?xmi # [x\\<leftarrow>nths xs (A - {?nmi}). key x = k] =\n    [x\\<leftarrow>nths xs A. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "using F and G and H"], ["proof (prove)\nusing this:\n  xs ! mini xs key = y\n  filter (\\<lambda>x. key x = k) (nths xs A) =\n  y #\n  filter (\\<lambda>x. key x = k) (nths vs {i. Suc i + mini xs key \\<in> A})\n  filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n  filter (\\<lambda>x. key x = k) (nths vs {i. Suc i + mini xs key \\<in> A})\n\ngoal (1 subgoal):\n 1. xs ! mini xs key #\n    filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "by simp"], ["proof (state)\nthis:\n  xs ! mini xs key #\n  filter (\\<lambda>x. key x = k) (nths xs (A - {mini xs key})) =\n  filter (\\<lambda>x. key x = k) (nths xs A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maxi_stable:\n  assumes\n    A: \"xs \\<noteq> []\" and\n    B: \"maxi xs key \\<in> A\"\n      (is \"?nma \\<in> _\")\n  shows \"[x\\<leftarrow>nths xs (A - {?nma}) @ [xs ! ?nma]. key x = k] =\n    [x\\<leftarrow>nths xs A. key x = k]\"\n    (is \"[x\\<leftarrow>_ @ [?xma]. _] = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (nths xs (A - {maxi xs key}) @ [xs ! maxi xs key]) =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "proof (simp, rule conjI, rule_tac [!] impI, rule_tac [2] filter_nths_diff,\n rule_tac [2] maxi_less, simp_all add: A)"], ["proof (state)\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "assume C: \"key ?xma = k\""], ["proof (state)\nthis:\n  key (xs ! maxi xs key) = k\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "moreover"], ["proof (state)\nthis:\n  key (xs ! maxi xs key) = k\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have D: \"?nma < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxi xs key < length xs", "using A"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. maxi xs key < length xs", "by (rule_tac maxi_less, simp)"], ["proof (state)\nthis:\n  maxi xs key < length xs\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "ultimately"], ["proof (chain)\npicking this:\n  key (xs ! maxi xs key) = k\n  maxi xs key < length xs", "have \"0 < length [x\\<leftarrow>rev xs. key x = k]\""], ["proof (prove)\nusing this:\n  key (xs ! maxi xs key) = k\n  maxi xs key < length xs\n\ngoal (1 subgoal):\n 1. 0 < length (filter (\\<lambda>x. key x = k) (rev xs))", "by (simp add: length_filter_conv_card card_gt_0_iff,\n     rule_tac exI [where x = \"length xs - Suc ?nma\"], simp add: rev_nth)"], ["proof (state)\nthis:\n  0 < length (filter (\\<lambda>x. key x = k) (rev xs))\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "hence \"\\<exists>y ys. [x\\<leftarrow>rev xs. key x = k] = y # ys\""], ["proof (prove)\nusing this:\n  0 < length (filter (\\<lambda>x. key x = k) (rev xs))\n\ngoal (1 subgoal):\n 1. \\<exists>y ys. filter (\\<lambda>x. key x = k) (rev xs) = y # ys", "by (rule_tac list.exhaust [of \"[x\\<leftarrow>rev xs. key x = k]\"], simp_all)"], ["proof (state)\nthis:\n  \\<exists>y ys. filter (\\<lambda>x. key x = k) (rev xs) = y # ys\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "then"], ["proof (chain)\npicking this:\n  \\<exists>y ys. filter (\\<lambda>x. key x = k) (rev xs) = y # ys", "obtain y and ys where \"[x\\<leftarrow>rev xs. key x = k] = y # ys\""], ["proof (prove)\nusing this:\n  \\<exists>y ys. filter (\\<lambda>x. key x = k) (rev xs) = y # ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        filter (\\<lambda>x. key x = k) (rev xs) = y # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) (rev xs) = y # ys\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "hence \"\\<exists>us vs. rev xs = us @ y # vs \\<and>\n    (\\<forall>u \\<in> set us. key u \\<noteq> k) \\<and> key y = k \\<and> ys = [x\\<leftarrow>vs. key x = k]\"\n    (is \"\\<exists>us vs. ?P us vs\")"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. key x = k) (rev xs) = y # ys\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       rev xs = us @ y # vs \\<and>\n       (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n       key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs", "by (simp add: filter_eq_Cons_iff)"], ["proof (state)\nthis:\n  \\<exists>us vs.\n     rev xs = us @ y # vs \\<and>\n     (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n     key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "then"], ["proof (chain)\npicking this:\n  \\<exists>us vs.\n     rev xs = us @ y # vs \\<and>\n     (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n     key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs", "obtain us and vs where E: \"?P us vs\""], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     rev xs = us @ y # vs \\<and>\n     (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n     key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        rev xs = us @ y # vs \\<and>\n        (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n        key y = k \\<and>\n        ys = filter (\\<lambda>x. key x = k) vs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rev xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "hence F: \"xs = rev vs @ y # rev us\""], ["proof (prove)\nusing this:\n  rev xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. xs = rev vs @ y # rev us", "by (simp add: rev_swap)"], ["proof (state)\nthis:\n  xs = rev vs @ y # rev us\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have G: \"length us = length xs - Suc ?nma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us = length xs - Suc (maxi xs key)", "proof (rule ccontr, erule neqE)"], ["proof (state)\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "assume \"length us < length xs - Suc ?nma\""], ["proof (state)\nthis:\n  length us < length xs - Suc (maxi xs key)\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "hence \"?nma < length xs - Suc (length us)\""], ["proof (prove)\nusing this:\n  length us < length xs - Suc (maxi xs key)\n\ngoal (1 subgoal):\n 1. maxi xs key < length xs - Suc (length us)", "by simp"], ["proof (state)\nthis:\n  maxi xs key < length xs - Suc (length us)\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  maxi xs key < length xs - Suc (length us)\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "have \"length xs - Suc (length us) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs - Suc (length us) < length xs", "using D"], ["proof (prove)\nusing this:\n  maxi xs key < length xs\n\ngoal (1 subgoal):\n 1. length xs - Suc (length us) < length xs", "by simp"], ["proof (state)\nthis:\n  length xs - Suc (length us) < length xs\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  maxi xs key < length xs - Suc (length us)\n  length xs - Suc (length us) < length xs", "have \"key (xs ! (length xs - Suc (length us))) < key ?xma\""], ["proof (prove)\nusing this:\n  maxi xs key < length xs - Suc (length us)\n  length xs - Suc (length us) < length xs\n\ngoal (1 subgoal):\n 1. key (xs ! (length xs - Suc (length us))) < key (xs ! maxi xs key)", "by (rule maxi_last [OF A])"], ["proof (state)\nthis:\n  key (xs ! (length xs - Suc (length us))) < key (xs ! maxi xs key)\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  key (xs ! (length xs - Suc (length us))) < key (xs ! maxi xs key)\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "have \"length us < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us < length xs", "using F"], ["proof (prove)\nusing this:\n  xs = rev vs @ y # rev us\n\ngoal (1 subgoal):\n 1. length us < length xs", "by simp"], ["proof (state)\nthis:\n  length us < length xs\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  key (xs ! (length xs - Suc (length us))) < key (xs ! maxi xs key)\n  length us < length xs", "have \"key (rev xs ! length us) < key ?xma\""], ["proof (prove)\nusing this:\n  key (xs ! (length xs - Suc (length us))) < key (xs ! maxi xs key)\n  length us < length xs\n\ngoal (1 subgoal):\n 1. key (rev xs ! length us) < key (xs ! maxi xs key)", "by (simp add: rev_nth)"], ["proof (state)\nthis:\n  key (rev xs ! length us) < key (xs ! maxi xs key)\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  key (rev xs ! length us) < key (xs ! maxi xs key)\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "have \"key (rev xs ! length us) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key (rev xs ! length us) = k", "using E"], ["proof (prove)\nusing this:\n  rev xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. key (rev xs ! length us) = k", "by simp"], ["proof (state)\nthis:\n  key (rev xs ! length us) = k\n\ngoal (2 subgoals):\n 1. length us < length xs - Suc (maxi xs key) \\<Longrightarrow> False\n 2. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  key (rev xs ! length us) < key (xs ! maxi xs key)\n  key (rev xs ! length us) = k", "show False"], ["proof (prove)\nusing this:\n  key (rev xs ! length us) < key (xs ! maxi xs key)\n  key (rev xs ! length us) = k\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  key (rev xs ! length us) < key (xs ! maxi xs key)\n  key (rev xs ! length us) = k\n  key (xs ! maxi xs key) = k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "assume H: \"length xs - Suc ?nma < length us\""], ["proof (state)\nthis:\n  length xs - Suc (maxi xs key) < length us\n\ngoal (1 subgoal):\n 1. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "hence \"rev xs ! (length xs - Suc ?nma) = us ! (length xs - Suc ?nma)\""], ["proof (prove)\nusing this:\n  length xs - Suc (maxi xs key) < length us\n\ngoal (1 subgoal):\n 1. rev xs ! (length xs - Suc (maxi xs key)) =\n    us ! (length xs - Suc (maxi xs key))", "using E"], ["proof (prove)\nusing this:\n  length xs - Suc (maxi xs key) < length us\n  rev xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. rev xs ! (length xs - Suc (maxi xs key)) =\n    us ! (length xs - Suc (maxi xs key))", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  rev xs ! (length xs - Suc (maxi xs key)) =\n  us ! (length xs - Suc (maxi xs key))\n\ngoal (1 subgoal):\n 1. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "hence \"rev xs ! (length xs - Suc ?nma) \\<in> set us\""], ["proof (prove)\nusing this:\n  rev xs ! (length xs - Suc (maxi xs key)) =\n  us ! (length xs - Suc (maxi xs key))\n\ngoal (1 subgoal):\n 1. rev xs ! (length xs - Suc (maxi xs key)) \\<in> set us", "using H"], ["proof (prove)\nusing this:\n  rev xs ! (length xs - Suc (maxi xs key)) =\n  us ! (length xs - Suc (maxi xs key))\n  length xs - Suc (maxi xs key) < length us\n\ngoal (1 subgoal):\n 1. rev xs ! (length xs - Suc (maxi xs key)) \\<in> set us", "by simp"], ["proof (state)\nthis:\n  rev xs ! (length xs - Suc (maxi xs key)) \\<in> set us\n\ngoal (1 subgoal):\n 1. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "hence \"?xma \\<in> set us\""], ["proof (prove)\nusing this:\n  rev xs ! (length xs - Suc (maxi xs key)) \\<in> set us\n\ngoal (1 subgoal):\n 1. xs ! maxi xs key \\<in> set us", "using D"], ["proof (prove)\nusing this:\n  rev xs ! (length xs - Suc (maxi xs key)) \\<in> set us\n  maxi xs key < length xs\n\ngoal (1 subgoal):\n 1. xs ! maxi xs key \\<in> set us", "by (simp add: rev_nth)"], ["proof (state)\nthis:\n  xs ! maxi xs key \\<in> set us\n\ngoal (1 subgoal):\n 1. length xs - Suc (maxi xs key) < length us \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  xs ! maxi xs key \\<in> set us\n\ngoal (1 subgoal):\n 1. False", "using C and E"], ["proof (prove)\nusing this:\n  xs ! maxi xs key \\<in> set us\n  key (xs ! maxi xs key) = k\n  rev xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length us = length xs - Suc (maxi xs key)\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "moreover"], ["proof (state)\nthis:\n  length us = length xs - Suc (maxi xs key)\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"rev xs ! length us = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs ! length us = y", "using E"], ["proof (prove)\nusing this:\n  rev xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. rev xs ! length us = y", "by simp"], ["proof (state)\nthis:\n  rev xs ! length us = y\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "ultimately"], ["proof (chain)\npicking this:\n  length us = length xs - Suc (maxi xs key)\n  rev xs ! length us = y", "have H: \"?xma = y\""], ["proof (prove)\nusing this:\n  length us = length xs - Suc (maxi xs key)\n  rev xs ! length us = y\n\ngoal (1 subgoal):\n 1. xs ! maxi xs key = y", "using D"], ["proof (prove)\nusing this:\n  length us = length xs - Suc (maxi xs key)\n  rev xs ! length us = y\n  maxi xs key < length xs\n\ngoal (1 subgoal):\n 1. xs ! maxi xs key = y", "by (simp add: rev_nth)"], ["proof (state)\nthis:\n  xs ! maxi xs key = y\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"length xs = length us + Suc ?nma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length us + Suc (maxi xs key)", "using D and G"], ["proof (prove)\nusing this:\n  maxi xs key < length xs\n  length us = length xs - Suc (maxi xs key)\n\ngoal (1 subgoal):\n 1. length xs = length us + Suc (maxi xs key)", "by simp"], ["proof (state)\nthis:\n  length xs = length us + Suc (maxi xs key)\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "hence I: \"length vs = ?nma\""], ["proof (prove)\nusing this:\n  length xs = length us + Suc (maxi xs key)\n\ngoal (1 subgoal):\n 1. length vs = maxi xs key", "using F"], ["proof (prove)\nusing this:\n  length xs = length us + Suc (maxi xs key)\n  xs = rev vs @ y # rev us\n\ngoal (1 subgoal):\n 1. length vs = maxi xs key", "by simp"], ["proof (state)\nthis:\n  length vs = maxi xs key\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "hence \"nths xs A = nths (rev vs) A @ nths (y # rev us) {i. i + ?nma \\<in> A}\""], ["proof (prove)\nusing this:\n  length vs = maxi xs key\n\ngoal (1 subgoal):\n 1. nths xs A =\n    nths (rev vs) A @ nths (y # rev us) {i. i + maxi xs key \\<in> A}", "using F"], ["proof (prove)\nusing this:\n  length vs = maxi xs key\n  xs = rev vs @ y # rev us\n\ngoal (1 subgoal):\n 1. nths xs A =\n    nths (rev vs) A @ nths (y # rev us) {i. i + maxi xs key \\<in> A}", "by (simp add: nths_append)"], ["proof (state)\nthis:\n  nths xs A =\n  nths (rev vs) A @ nths (y # rev us) {i. i + maxi xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "also"], ["proof (state)\nthis:\n  nths xs A =\n  nths (rev vs) A @ nths (y # rev us) {i. i + maxi xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"\\<dots> = nths (rev vs) (A \\<inter> {..<?nma}) @ y #\n    nths (rev us) {i. Suc i + ?nma \\<in> A}\"\n    (is \"_ = ?ws @ _ # _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (rev vs) A @ nths (y # rev us) {i. i + maxi xs key \\<in> A} =\n    nths (rev vs) (A \\<inter> {..<maxi xs key}) @\n    y # nths (rev us) {i. Suc i + maxi xs key \\<in> A}", "using B and I"], ["proof (prove)\nusing this:\n  maxi xs key \\<in> A\n  length vs = maxi xs key\n\ngoal (1 subgoal):\n 1. nths (rev vs) A @ nths (y # rev us) {i. i + maxi xs key \\<in> A} =\n    nths (rev vs) (A \\<inter> {..<maxi xs key}) @\n    y # nths (rev us) {i. Suc i + maxi xs key \\<in> A}", "by (simp add: nths_Cons, subst nths_range, simp)"], ["proof (state)\nthis:\n  nths (rev vs) A @ nths (y # rev us) {i. i + maxi xs key \\<in> A} =\n  nths (rev vs) (A \\<inter> {..<maxi xs key}) @\n  y # nths (rev us) {i. Suc i + maxi xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "finally"], ["proof (chain)\npicking this:\n  nths xs A =\n  nths (rev vs) (A \\<inter> {..<maxi xs key}) @\n  y # nths (rev us) {i. Suc i + maxi xs key \\<in> A}", "have J: \"[x\\<leftarrow>nths xs A. key x = k] = [x\\<leftarrow>?ws. key x = k] @ [y]\""], ["proof (prove)\nusing this:\n  nths xs A =\n  nths (rev vs) (A \\<inter> {..<maxi xs key}) @\n  y # nths (rev us) {i. Suc i + maxi xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs A) =\n    filter (\\<lambda>x. key x = k)\n     (nths (rev vs) (A \\<inter> {..<maxi xs key})) @\n    [y]", "using E"], ["proof (prove)\nusing this:\n  nths xs A =\n  nths (rev vs) (A \\<inter> {..<maxi xs key}) @\n  y # nths (rev us) {i. Suc i + maxi xs key \\<in> A}\n  rev xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs A) =\n    filter (\\<lambda>x. key x = k)\n     (nths (rev vs) (A \\<inter> {..<maxi xs key})) @\n    [y]", "by (simp add: filter_empty_conv, rule_tac ballI,\n     drule_tac in_set_nthsD, simp)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) (nths xs A) =\n  filter (\\<lambda>x. key x = k)\n   (nths (rev vs) (A \\<inter> {..<maxi xs key})) @\n  [y]\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"nths xs (A - {?nma}) = nths (rev vs) (A - {?nma}) @\n    nths (y # rev us) {i. i + ?nma \\<in> A - {?nma}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths xs (A - {maxi xs key}) =\n    nths (rev vs) (A - {maxi xs key}) @\n    nths (y # rev us) {i. i + maxi xs key \\<in> A - {maxi xs key}}", "using F and I"], ["proof (prove)\nusing this:\n  xs = rev vs @ y # rev us\n  length vs = maxi xs key\n\ngoal (1 subgoal):\n 1. nths xs (A - {maxi xs key}) =\n    nths (rev vs) (A - {maxi xs key}) @\n    nths (y # rev us) {i. i + maxi xs key \\<in> A - {maxi xs key}}", "by (simp add: nths_append)"], ["proof (state)\nthis:\n  nths xs (A - {maxi xs key}) =\n  nths (rev vs) (A - {maxi xs key}) @\n  nths (y # rev us) {i. i + maxi xs key \\<in> A - {maxi xs key}}\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "hence \"nths xs (A - {?nma}) = nths (rev vs) ((A - {?nma}) \\<inter> {..<?nma}) @\n    nths (rev us) {i. Suc i + ?nma \\<in> A}\""], ["proof (prove)\nusing this:\n  nths xs (A - {maxi xs key}) =\n  nths (rev vs) (A - {maxi xs key}) @\n  nths (y # rev us) {i. i + maxi xs key \\<in> A - {maxi xs key}}\n\ngoal (1 subgoal):\n 1. nths xs (A - {maxi xs key}) =\n    nths (rev vs) ((A - {maxi xs key}) \\<inter> {..<maxi xs key}) @\n    nths (rev us) {i. Suc i + maxi xs key \\<in> A}", "using I"], ["proof (prove)\nusing this:\n  nths xs (A - {maxi xs key}) =\n  nths (rev vs) (A - {maxi xs key}) @\n  nths (y # rev us) {i. i + maxi xs key \\<in> A - {maxi xs key}}\n  length vs = maxi xs key\n\ngoal (1 subgoal):\n 1. nths xs (A - {maxi xs key}) =\n    nths (rev vs) ((A - {maxi xs key}) \\<inter> {..<maxi xs key}) @\n    nths (rev us) {i. Suc i + maxi xs key \\<in> A}", "by (simp add: nths_Cons, subst nths_range, simp)"], ["proof (state)\nthis:\n  nths xs (A - {maxi xs key}) =\n  nths (rev vs) ((A - {maxi xs key}) \\<inter> {..<maxi xs key}) @\n  nths (rev us) {i. Suc i + maxi xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "moreover"], ["proof (state)\nthis:\n  nths xs (A - {maxi xs key}) =\n  nths (rev vs) ((A - {maxi xs key}) \\<inter> {..<maxi xs key}) @\n  nths (rev us) {i. Suc i + maxi xs key \\<in> A}\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "have \"(A - {?nma}) \\<inter> {..<?nma} = A \\<inter> {..<?nma}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - {maxi xs key}) \\<inter> {..<maxi xs key} =\n    A \\<inter> {..<maxi xs key}", "by (rule set_eqI, rule iffI, simp_all)"], ["proof (state)\nthis:\n  (A - {maxi xs key}) \\<inter> {..<maxi xs key} =\n  A \\<inter> {..<maxi xs key}\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "ultimately"], ["proof (chain)\npicking this:\n  nths xs (A - {maxi xs key}) =\n  nths (rev vs) ((A - {maxi xs key}) \\<inter> {..<maxi xs key}) @\n  nths (rev us) {i. Suc i + maxi xs key \\<in> A}\n  (A - {maxi xs key}) \\<inter> {..<maxi xs key} =\n  A \\<inter> {..<maxi xs key}", "have K: \"[x\\<leftarrow>nths xs (A - {?nma}). key x = k] =\n    [x\\<leftarrow>?ws. key x = k]\""], ["proof (prove)\nusing this:\n  nths xs (A - {maxi xs key}) =\n  nths (rev vs) ((A - {maxi xs key}) \\<inter> {..<maxi xs key}) @\n  nths (rev us) {i. Suc i + maxi xs key \\<in> A}\n  (A - {maxi xs key}) \\<inter> {..<maxi xs key} =\n  A \\<inter> {..<maxi xs key}\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) =\n    filter (\\<lambda>x. key x = k)\n     (nths (rev vs) (A \\<inter> {..<maxi xs key}))", "using E"], ["proof (prove)\nusing this:\n  nths xs (A - {maxi xs key}) =\n  nths (rev vs) ((A - {maxi xs key}) \\<inter> {..<maxi xs key}) @\n  nths (rev us) {i. Suc i + maxi xs key \\<in> A}\n  (A - {maxi xs key}) \\<inter> {..<maxi xs key} =\n  A \\<inter> {..<maxi xs key}\n  rev xs = us @ y # vs \\<and>\n  (\\<forall>u\\<in>set us. key u \\<noteq> k) \\<and>\n  key y = k \\<and> ys = filter (\\<lambda>x. key x = k) vs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) =\n    filter (\\<lambda>x. key x = k)\n     (nths (rev vs) (A \\<inter> {..<maxi xs key}))", "by (simp add: filter_empty_conv, rule_tac ballI,\n     drule_tac in_set_nthsD, simp)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) =\n  filter (\\<lambda>x. key x = k)\n   (nths (rev vs) (A \\<inter> {..<maxi xs key}))\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) = k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "show \"[x\\<leftarrow>nths xs (A - {?nma}). key x = k] @ [?xma] =\n    [x\\<leftarrow>nths xs A. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "using H and J and K"], ["proof (prove)\nusing this:\n  xs ! maxi xs key = y\n  filter (\\<lambda>x. key x = k) (nths xs A) =\n  filter (\\<lambda>x. key x = k)\n   (nths (rev vs) (A \\<inter> {..<maxi xs key})) @\n  [y]\n  filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) =\n  filter (\\<lambda>x. key x = k)\n   (nths (rev vs) (A \\<inter> {..<maxi xs key}))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n    [xs ! maxi xs key] =\n    filter (\\<lambda>x. key x = k) (nths xs A)", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) (nths xs (A - {maxi xs key})) @\n  [xs ! maxi xs key] =\n  filter (\\<lambda>x. key x = k) (nths xs A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_stab_inv [rule_format]:\n \"index_less index key \\<longrightarrow> index_same index key \\<longrightarrow> bn_inv p q t \\<longrightarrow>\n    add_inv n t \\<longrightarrow> stab_inv f key t \\<longrightarrow> stab_inv f key (round index key p q r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_less index key \\<longrightarrow>\n    index_same index key \\<longrightarrow>\n    bn_inv p q t \\<longrightarrow>\n    add_inv n t \\<longrightarrow>\n    stab_inv f key t \\<longrightarrow>\n    stab_inv f key (round index key p q r t)", "proof (induction index key p q r t arbitrary: n f rule: round.induct,\n (rule_tac [!] impI)+, simp, simp, simp_all only: simp_thms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n f.\n       \\<lbrakk>\\<And>n f.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   stab_inv f key (u, ns, tl xs) \\<longrightarrow>\n                   stab_inv f key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        stab_inv f key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "fix index p q r u ns xs n f and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n f.\n       \\<lbrakk>\\<And>n f.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   stab_inv f key (u, ns, tl xs) \\<longrightarrow>\n                   stab_inv f key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        stab_inv f key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?t = \"round index key p q r (u, ns, tl xs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n f.\n       \\<lbrakk>\\<And>n f.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   stab_inv f key (u, ns, tl xs) \\<longrightarrow>\n                   stab_inv f key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        stab_inv f key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n   \"\\<And>n f. bn_inv p q (u, ns, tl xs) \\<longrightarrow> add_inv n (u, ns, tl xs) \\<longrightarrow>\n      stab_inv f key (u, ns, tl xs) \\<longrightarrow> stab_inv f key ?t\" and\n   \"bn_inv p q (u, Suc 0 # ns, xs)\" and\n   \"add_inv n (u, Suc 0 # ns, xs)\" and\n   \"stab_inv f key (u, Suc 0 # ns, xs)\""], ["proof (state)\nthis:\n  bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n  add_inv ?n (u, ns, tl xs) \\<longrightarrow>\n  stab_inv ?f key (u, ns, tl xs) \\<longrightarrow>\n  stab_inv ?f key (round index key p q r (u, ns, tl xs))\n  bn_inv p q (u, Suc 0 # ns, xs)\n  add_inv n (u, Suc 0 # ns, xs)\n  stab_inv f key (u, Suc 0 # ns, xs)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n f.\n       \\<lbrakk>\\<And>n f.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   stab_inv f key (u, ns, tl xs) \\<longrightarrow>\n                   stab_inv f key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        stab_inv f key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "thus \"stab_inv f key (round index key p q r (u, Suc 0 # ns, xs))\""], ["proof (prove)\nusing this:\n  bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n  add_inv ?n (u, ns, tl xs) \\<longrightarrow>\n  stab_inv ?f key (u, ns, tl xs) \\<longrightarrow>\n  stab_inv ?f key (round index key p q r (u, ns, tl xs))\n  bn_inv p q (u, Suc 0 # ns, xs)\n  add_inv n (u, Suc 0 # ns, xs)\n  stab_inv f key (u, Suc 0 # ns, xs)\n\ngoal (1 subgoal):\n 1. stab_inv f key (round index key p q r (u, Suc 0 # ns, xs))", "proof (cases ?t, cases xs, simp_all add: add_suc, arith, erule_tac conjE,\n   rule_tac allI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "fix k y ys xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "let ?f' = \"f(key y := tl (f (key y)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "assume \"\\<And>n' f'. foldl (+) 0 ns = n' \\<and> length ys = n' \\<longrightarrow>\n      (\\<forall>k'. [x\\<leftarrow>ys. key x = k'] = f' k') \\<longrightarrow> (\\<forall>k'. [x\\<leftarrow>xs'. key x = k'] = f' k')\""], ["proof (state)\nthis:\n  foldl (+) 0 ns = ?n' \\<and> length ys = ?n' \\<longrightarrow>\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') ys = ?f' k') \\<longrightarrow>\n  (\\<forall>k'. filter (\\<lambda>x. key x = k') xs' = ?f' k')\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "moreover"], ["proof (state)\nthis:\n  foldl (+) 0 ns = ?n' \\<and> length ys = ?n' \\<longrightarrow>\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') ys = ?f' k') \\<longrightarrow>\n  (\\<forall>k'. filter (\\<lambda>x. key x = k') xs' = ?f' k')\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "assume \"Suc (foldl (+) 0 ns) = n\" and \"Suc (length ys) = n\""], ["proof (state)\nthis:\n  Suc (foldl (+) 0 ns) = n\n  Suc (length ys) = n\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "ultimately"], ["proof (chain)\npicking this:\n  foldl (+) 0 ns = ?n' \\<and> length ys = ?n' \\<longrightarrow>\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') ys = ?f' k') \\<longrightarrow>\n  (\\<forall>k'. filter (\\<lambda>x. key x = k') xs' = ?f' k')\n  Suc (foldl (+) 0 ns) = n\n  Suc (length ys) = n", "have \"(\\<forall>k'. [x\\<leftarrow>ys. key x = k'] = ?f' k') \\<longrightarrow>\n      (\\<forall>k'. [x\\<leftarrow>xs'. key x = k'] = ?f' k')\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = ?n' \\<and> length ys = ?n' \\<longrightarrow>\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') ys = ?f' k') \\<longrightarrow>\n  (\\<forall>k'. filter (\\<lambda>x. key x = k') xs' = ?f' k')\n  Suc (foldl (+) 0 ns) = n\n  Suc (length ys) = n\n\ngoal (1 subgoal):\n 1. (\\<forall>k'.\n        filter (\\<lambda>x. key x = k') ys =\n        (f(key y := tl (f (key y)))) k') \\<longrightarrow>\n    (\\<forall>k'.\n        filter (\\<lambda>x. key x = k') xs' =\n        (f(key y := tl (f (key y)))) k')", "by blast"], ["proof (state)\nthis:\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') ys =\n      (f(key y := tl (f (key y)))) k') \\<longrightarrow>\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') xs' = (f(key y := tl (f (key y)))) k')\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "moreover"], ["proof (state)\nthis:\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') ys =\n      (f(key y := tl (f (key y)))) k') \\<longrightarrow>\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') xs' = (f(key y := tl (f (key y)))) k')\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "assume A: \"\\<forall>k'. (if key y = k'\n      then y # [x\\<leftarrow>ys. key x = k'] else [x\\<leftarrow>ys. key x = k']) = f k'\""], ["proof (state)\nthis:\n  \\<forall>k'.\n     (if key y = k' then y # filter (\\<lambda>x. key x = k') ys\n      else filter (\\<lambda>x. key x = k') ys) =\n     f k'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "hence B: \"f (key y) = y # [x\\<leftarrow>ys. key x = key y]\""], ["proof (prove)\nusing this:\n  \\<forall>k'.\n     (if key y = k' then y # filter (\\<lambda>x. key x = k') ys\n      else filter (\\<lambda>x. key x = k') ys) =\n     f k'\n\ngoal (1 subgoal):\n 1. f (key y) = y # filter (\\<lambda>x. key x = key y) ys", "by (drule_tac spec [where x = \"key y\"], simp)"], ["proof (state)\nthis:\n  f (key y) = y # filter (\\<lambda>x. key x = key y) ys\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "hence \"\\<forall>k'. [x\\<leftarrow>ys. key x = k'] = ?f' k'\""], ["proof (prove)\nusing this:\n  f (key y) = y # filter (\\<lambda>x. key x = key y) ys\n\ngoal (1 subgoal):\n 1. \\<forall>k'.\n       filter (\\<lambda>x. key x = k') ys = (f(key y := tl (f (key y)))) k'", "proof (rule_tac allI, simp, rule_tac impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>f (key y) = y # filter (\\<lambda>x. key x = key y) ys;\n        f (key y) = y # filter (\\<lambda>x. key x = key y) ys;\n        k' \\<noteq> key y\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k') ys = f k'", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>f (key y) = y # filter (\\<lambda>x. key x = key y) ys;\n        f (key y) = y # filter (\\<lambda>x. key x = key y) ys;\n        k' \\<noteq> key y\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k') ys = f k'", "assume \"k' \\<noteq> key y\""], ["proof (state)\nthis:\n  k' \\<noteq> key y\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>f (key y) = y # filter (\\<lambda>x. key x = key y) ys;\n        f (key y) = y # filter (\\<lambda>x. key x = key y) ys;\n        k' \\<noteq> key y\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k') ys = f k'", "thus \"[x\\<leftarrow>ys. key x = k'] = f k'\""], ["proof (prove)\nusing this:\n  k' \\<noteq> key y\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k') ys = f k'", "using A"], ["proof (prove)\nusing this:\n  k' \\<noteq> key y\n  \\<forall>k'.\n     (if key y = k' then y # filter (\\<lambda>x. key x = k') ys\n      else filter (\\<lambda>x. key x = k') ys) =\n     f k'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k') ys = f k'", "by (drule_tac spec [where x = k'], simp)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k') ys = f k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k'.\n     filter (\\<lambda>x. key x = k') ys = (f(key y := tl (f (key y)))) k'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') ys =\n      (f(key y := tl (f (key y)))) k') \\<longrightarrow>\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') xs' = (f(key y := tl (f (key y)))) k')\n  \\<forall>k'.\n     filter (\\<lambda>x. key x = k') ys = (f(key y := tl (f (key y)))) k'", "have C: \"\\<forall>k'. [x\\<leftarrow>xs'. key x = k'] = ?f' k'\""], ["proof (prove)\nusing this:\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') ys =\n      (f(key y := tl (f (key y)))) k') \\<longrightarrow>\n  (\\<forall>k'.\n      filter (\\<lambda>x. key x = k') xs' = (f(key y := tl (f (key y)))) k')\n  \\<forall>k'.\n     filter (\\<lambda>x. key x = k') ys = (f(key y := tl (f (key y)))) k'\n\ngoal (1 subgoal):\n 1. \\<forall>k'.\n       filter (\\<lambda>x. key x = k') xs' = (f(key y := tl (f (key y)))) k'", ".."], ["proof (state)\nthis:\n  \\<forall>k'.\n     filter (\\<lambda>x. key x = k') xs' = (f(key y := tl (f (key y)))) k'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>k.\n           (if key aa = k then aa # filter (\\<lambda>x. key x = k) list\n            else filter (\\<lambda>x. key x = k) list) =\n           f k;\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>k.\n               filter (\\<lambda>x. key x = k) list = f k) \\<longrightarrow>\n           (\\<forall>k. filter (\\<lambda>x. key x = k) c = f k);\n        xs = aa # list; foldl (+) (Suc 0) ns = n; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (key aa = k \\<longrightarrow>\n                          aa # filter (\\<lambda>x. key x = k) c =\n                          f k) \\<and>\n                         (key aa \\<noteq> k \\<longrightarrow>\n                          filter (\\<lambda>x. key x = k) c = f k)", "show \"(key y = k \\<longrightarrow> y # [x\\<leftarrow>xs'. key x = k] = f k) \\<and>\n      (key y \\<noteq> k \\<longrightarrow> [x\\<leftarrow>xs'. key x = k] = f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (key y = k \\<longrightarrow>\n     y # filter (\\<lambda>x. key x = k) xs' = f k) \\<and>\n    (key y \\<noteq> k \\<longrightarrow>\n     filter (\\<lambda>x. key x = k) xs' = f k)", "proof (rule conjI, rule_tac [!] impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. key y = k \\<Longrightarrow> y # filter (\\<lambda>x. key x = k) xs' = f k\n 2. key y \\<noteq> k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) xs' = f k", "assume \"key y = k\""], ["proof (state)\nthis:\n  key y = k\n\ngoal (2 subgoals):\n 1. key y = k \\<Longrightarrow> y # filter (\\<lambda>x. key x = k) xs' = f k\n 2. key y \\<noteq> k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) xs' = f k", "moreover"], ["proof (state)\nthis:\n  key y = k\n\ngoal (2 subgoals):\n 1. key y = k \\<Longrightarrow> y # filter (\\<lambda>x. key x = k) xs' = f k\n 2. key y \\<noteq> k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) xs' = f k", "have \"tl (f (key y)) = [x\\<leftarrow>xs'. key x = key y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (f (key y)) = filter (\\<lambda>x. key x = key y) xs'", "using C"], ["proof (prove)\nusing this:\n  \\<forall>k'.\n     filter (\\<lambda>x. key x = k') xs' = (f(key y := tl (f (key y)))) k'\n\ngoal (1 subgoal):\n 1. tl (f (key y)) = filter (\\<lambda>x. key x = key y) xs'", "by simp"], ["proof (state)\nthis:\n  tl (f (key y)) = filter (\\<lambda>x. key x = key y) xs'\n\ngoal (2 subgoals):\n 1. key y = k \\<Longrightarrow> y # filter (\\<lambda>x. key x = k) xs' = f k\n 2. key y \\<noteq> k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) xs' = f k", "hence \"f (key y) = y # [x\\<leftarrow>xs'. key x = key y]\""], ["proof (prove)\nusing this:\n  tl (f (key y)) = filter (\\<lambda>x. key x = key y) xs'\n\ngoal (1 subgoal):\n 1. f (key y) = y # filter (\\<lambda>x. key x = key y) xs'", "using B"], ["proof (prove)\nusing this:\n  tl (f (key y)) = filter (\\<lambda>x. key x = key y) xs'\n  f (key y) = y # filter (\\<lambda>x. key x = key y) ys\n\ngoal (1 subgoal):\n 1. f (key y) = y # filter (\\<lambda>x. key x = key y) xs'", "by (subst hd_Cons_tl [symmetric], simp_all)"], ["proof (state)\nthis:\n  f (key y) = y # filter (\\<lambda>x. key x = key y) xs'\n\ngoal (2 subgoals):\n 1. key y = k \\<Longrightarrow> y # filter (\\<lambda>x. key x = k) xs' = f k\n 2. key y \\<noteq> k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) xs' = f k", "ultimately"], ["proof (chain)\npicking this:\n  key y = k\n  f (key y) = y # filter (\\<lambda>x. key x = key y) xs'", "show \"y # [x\\<leftarrow>xs'. key x = k] = f k\""], ["proof (prove)\nusing this:\n  key y = k\n  f (key y) = y # filter (\\<lambda>x. key x = key y) xs'\n\ngoal (1 subgoal):\n 1. y # filter (\\<lambda>x. key x = k) xs' = f k", "by simp"], ["proof (state)\nthis:\n  y # filter (\\<lambda>x. key x = k) xs' = f k\n\ngoal (1 subgoal):\n 1. key y \\<noteq> k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) xs' = f k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. key y \\<noteq> k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) xs' = f k", "assume \"key y \\<noteq> k\""], ["proof (state)\nthis:\n  key y \\<noteq> k\n\ngoal (1 subgoal):\n 1. key y \\<noteq> k \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k) xs' = f k", "thus \"[x\\<leftarrow>xs'. key x = k] = f k\""], ["proof (prove)\nusing this:\n  key y \\<noteq> k\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) xs' = f k", "using C"], ["proof (prove)\nusing this:\n  key y \\<noteq> k\n  \\<forall>k'.\n     filter (\\<lambda>x. key x = k') xs' = (f(key y := tl (f (key y)))) k'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) xs' = f k", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) xs' = f k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (key y = k \\<longrightarrow>\n   y # filter (\\<lambda>x. key x = k) xs' = f k) \\<and>\n  (key y \\<noteq> k \\<longrightarrow>\n   filter (\\<lambda>x. key x = k) xs' = f k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  stab_inv f key (round index key p q r (u, Suc 0 # ns, xs))\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "fix index p q r u m ns n f and key :: \"'a \\<Rightarrow> 'b\" and xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?ws = \"take (Suc (Suc m)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?ys = \"drop (Suc (Suc m)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?r = \"\\<lambda>m'. round_suc_suc index key ?ws m m' u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?t = \"\\<lambda>r' v. round index key p q r' (v, ns, ?ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n    A: \"index_less index key\" and\n    B: \"index_same index key\""], ["proof (state)\nthis:\n  index_less index key\n  index_same index key\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n   \"\\<And>ws a b c d e g h i n f.\n      ws = ?ws \\<Longrightarrow> a = bn_comp m p q r \\<Longrightarrow> (b, c) = bn_comp m p q r \\<Longrightarrow>\n      d = ?r b \\<Longrightarrow> (e, g) = ?r b \\<Longrightarrow> (h, i) = g \\<Longrightarrow>\n        bn_inv p q (e, ns, ?ys) \\<longrightarrow> add_inv n (e, ns, ?ys) \\<longrightarrow>\n          stab_inv f key (e, ns, ?ys) \\<longrightarrow> stab_inv f key (?t c e)\" and\n   \"bn_inv p q (u, Suc (Suc m) # ns, xs)\" and\n   \"add_inv n (u, Suc (Suc m) # ns, xs)\" and\n   \"stab_inv f key (u, Suc (Suc m) # ns, xs)\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?g) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?h, ?i) = ?g\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    stab_inv ?f key\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    stab_inv ?f key\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  stab_inv f key (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     stab_inv f key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_same index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        stab_inv f key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> stab_inv f key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "thus \"stab_inv f key (round index key p q r (u, Suc (Suc m) # ns, xs))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?g) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?h, ?i) = ?g\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    stab_inv ?f key\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    stab_inv ?f key\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  stab_inv f key (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. stab_inv f key (round index key p q r (u, Suc (Suc m) # ns, xs))", "using [[simproc del: defined_all]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?g) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?h, ?i) = ?g\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    stab_inv ?f key\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    stab_inv ?f key\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  stab_inv f key (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. stab_inv f key (round index key p q r (u, Suc (Suc m) # ns, xs))", "proof (simp split: prod.split, ((rule_tac allI)+, ((rule_tac impI)+)?)+,\n   (erule_tac conjE)+, subst (asm) (2) add_base_zero, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "fix m' r' v ms' ws' xs' k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "let ?f = \"\\<lambda>k. [x\\<leftarrow>?ys. key x = k]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "let ?P = \"\\<lambda>f. \\<forall>k. [x\\<leftarrow>?ys. key x = k] = f k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "let ?Q = \"\\<lambda>f. \\<forall>k. [x\\<leftarrow>xs'. key x = k] = f k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "assume\n      C: \"?r m' = (v, ms', ws')\" and\n      D: \"bn_comp m p q r = (m', r')\" and\n      E: \"bn_valid m p q\" and\n      F: \"Suc (Suc (foldl (+) 0 ns + m)) = n\" and\n      G: \"length xs = n\""], ["proof (state)\nthis:\n  round_suc_suc index key (take (Suc (Suc m)) xs) m m' u = (v, ms', ws')\n  bn_comp m p q r = (m', r')\n  bn_valid m p q\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "assume \"\\<And>ws a b c d e g h i n' f.\n      ws = ?ws \\<Longrightarrow> a = (m', r') \\<Longrightarrow> b = m' \\<and> c = r' \\<Longrightarrow>\n      d = (v, ms', ws') \\<Longrightarrow> e = v \\<and> g = (ms', ws') \\<Longrightarrow> h = ms' \\<and> i = ws' \\<Longrightarrow>\n        foldl (+) 0 ns = n' \\<and> n - Suc (Suc m) = n' \\<longrightarrow> ?P f \\<longrightarrow> ?Q f\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?g = (ms', ws'); ?h = ms' \\<and> ?i = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    (\\<forall>k.\n                        filter (\\<lambda>x. key x = k)\n                         (drop (Suc (Suc m)) xs) =\n                        ?f k) \\<longrightarrow>\n                    (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = ?f k)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "hence \"\\<And>f. foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow> ?P f \\<longrightarrow> ?Q f\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?g = (ms', ws'); ?h = ms' \\<and> ?i = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    (\\<forall>k.\n                        filter (\\<lambda>x. key x = k)\n                         (drop (Suc (Suc m)) xs) =\n                        ?f k) \\<longrightarrow>\n                    (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = ?f k)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow>\n       (\\<forall>k.\n           filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n           f k) \\<longrightarrow>\n       (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = f k)", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow>\n  (\\<forall>k.\n      filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n      ?f k) \\<longrightarrow>\n  (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = ?f k)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "hence \"\\<And>f. ?P f \\<longrightarrow> ?Q f\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow>\n  (\\<forall>k.\n      filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n      ?f k) \\<longrightarrow>\n  (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = ?f k)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       (\\<forall>k.\n           filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n           f k) \\<longrightarrow>\n       (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = f k)", "using F"], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow>\n  (\\<forall>k.\n      filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n      ?f k) \\<longrightarrow>\n  (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = ?f k)\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       (\\<forall>k.\n           filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n           f k) \\<longrightarrow>\n       (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = f k)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>k.\n      filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n      ?f k) \\<longrightarrow>\n  (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = ?f k)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "hence \"?P ?f \\<longrightarrow> ?Q ?f\""], ["proof (prove)\nusing this:\n  (\\<forall>k.\n      filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n      ?f k) \\<longrightarrow>\n  (\\<forall>k. filter (\\<lambda>x. key x = k) xs' = ?f k)\n\ngoal (1 subgoal):\n 1. (\\<forall>k.\n        filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n        filter (\\<lambda>x. key x = k)\n         (drop (Suc (Suc m)) xs)) \\<longrightarrow>\n    (\\<forall>k.\n        filter (\\<lambda>x. key x = k) xs' =\n        filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs))", "."], ["proof (state)\nthis:\n  (\\<forall>k.\n      filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n      filter (\\<lambda>x. key x = k)\n       (drop (Suc (Suc m)) xs)) \\<longrightarrow>\n  (\\<forall>k.\n      filter (\\<lambda>x. key x = k) xs' =\n      filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "hence \"[x\\<leftarrow>xs'. key x = k] = [x\\<leftarrow>?ys. key x = k]\""], ["proof (prove)\nusing this:\n  (\\<forall>k.\n      filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n      filter (\\<lambda>x. key x = k)\n       (drop (Suc (Suc m)) xs)) \\<longrightarrow>\n  (\\<forall>k.\n      filter (\\<lambda>x. key x = k) xs' =\n      filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) xs' =\n    filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) xs' =\n  filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "moreover"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) xs' =\n  filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "assume \"\\<forall>k. [x\\<leftarrow>xs. key x = k] = f k\""], ["proof (state)\nthis:\n  \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "hence \"f k = [x\\<leftarrow>?ws @ ?ys. key x = k]\""], ["proof (prove)\nusing this:\n  \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k\n\ngoal (1 subgoal):\n 1. f k =\n    filter (\\<lambda>x. key x = k)\n     (take (Suc (Suc m)) xs @ drop (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  f k =\n  filter (\\<lambda>x. key x = k)\n   (take (Suc (Suc m)) xs @ drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "ultimately"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. key x = k) xs' =\n  filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs)\n  f k =\n  filter (\\<lambda>x. key x = k)\n   (take (Suc (Suc m)) xs @ drop (Suc (Suc m)) xs)", "have \"f k = [x\\<leftarrow>?ws. key x = k] @ [x\\<leftarrow>xs'. key x = k]\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. key x = k) xs' =\n  filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs)\n  f k =\n  filter (\\<lambda>x. key x = k)\n   (take (Suc (Suc m)) xs @ drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. f k =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n    filter (\\<lambda>x. key x = k) xs'", "by (subst (asm) filter_append, simp)"], ["proof (state)\nthis:\n  f k =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n  filter (\\<lambda>x. key x = k) xs'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba k.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) (drop (Suc (Suc m)) xs) =\n   f k) \\<longrightarrow>\n                                     (\\<forall>k.\n   filter (\\<lambda>x. key x = k) ba = f k);\n        \\<forall>k. filter (\\<lambda>x. key x = k) xs = f k;\n        foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. key x = k) b @\n                         filter (\\<lambda>x. key x = k) ba =\n                         f k", "with C [symmetric]"], ["proof (chain)\npicking this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\n  f k =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n  filter (\\<lambda>x. key x = k) xs'", "show \"[x\\<leftarrow>ws'. key x = k] @ [x\\<leftarrow>xs'. key x = k] = f k\""], ["proof (prove)\nusing this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\n  f k =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n  filter (\\<lambda>x. key x = k) xs'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) ws' @\n    filter (\\<lambda>x. key x = k) xs' =\n    f k", "proof (simp add: round_suc_suc_def Let_def del: filter.simps\n     split: if_split_asm)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "let ?nmi = \"mini ?ws key\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "let ?nma = \"maxi ?ws key\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "let ?xmi = \"?ws ! ?nmi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "let ?xma = \"?ws ! ?nma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "let ?mi = \"key ?xmi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "let ?ma = \"key ?xma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "let ?k = \"case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m | Suc (Suc i) \\<Rightarrow> u + m'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "let ?zs = \"nths ?ws (- {?nmi, ?nma})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "let ?ms = \"enum ?zs index key ?k ?mi ?ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "have H: \"length ?ws = Suc (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc (Suc m)) xs) = Suc (Suc m)", "using F and G"], ["proof (prove)\nusing this:\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. length (take (Suc (Suc m)) xs) = Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "hence I: \"?nmi \\<noteq> ?nma\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. mini (take (Suc (Suc m)) xs) key \\<noteq>\n    maxi (take (Suc (Suc m)) xs) key", "by (rule_tac mini_maxi_neq, simp)"], ["proof (state)\nthis:\n  mini (take (Suc (Suc m)) xs) key \\<noteq> maxi (take (Suc (Suc m)) xs) key\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "have \"[x\\<leftarrow>(([?xmi] @ map the (fill ?zs (offs ?ms 0) index key m ?mi ?ma))\n        @ [?xma]). key x = k] = [x\\<leftarrow>?ws. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "proof (cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "case True"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "have \"?nmi < length ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)", "using H"], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)", "by (rule_tac mini_less, simp)"], ["proof (state)\nthis:\n  mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "hence J: \"?nmi < Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. mini (take (Suc (Suc m)) xs) key < Suc (Suc 0)", "using True"], ["proof (prove)\nusing this:\n  mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n  m = 0\n\ngoal (1 subgoal):\n 1. mini (take (Suc (Suc m)) xs) key < Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  mini (take (Suc (Suc m)) xs) key < Suc (Suc 0)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "moreover"], ["proof (state)\nthis:\n  mini (take (Suc (Suc m)) xs) key < Suc (Suc 0)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "have \"?nma < length ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)", "using H"], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)", "by (rule_tac maxi_less, simp)"], ["proof (state)\nthis:\n  maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "hence K: \"?nma < Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. maxi (take (Suc (Suc m)) xs) key < Suc (Suc 0)", "using True"], ["proof (prove)\nusing this:\n  maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n  m = 0\n\ngoal (1 subgoal):\n 1. maxi (take (Suc (Suc m)) xs) key < Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  maxi (take (Suc (Suc m)) xs) key < Suc (Suc 0)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "ultimately"], ["proof (chain)\npicking this:\n  mini (take (Suc (Suc m)) xs) key < Suc (Suc 0)\n  maxi (take (Suc (Suc m)) xs) key < Suc (Suc 0)", "have \"card ({..<Suc (Suc 0)} - {?nma} - {?nmi}) = 0\""], ["proof (prove)\nusing this:\n  mini (take (Suc (Suc m)) xs) key < Suc (Suc 0)\n  maxi (take (Suc (Suc m)) xs) key < Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. card\n     ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n      {mini (take (Suc (Suc m)) xs) key}) =\n    0", "using I"], ["proof (prove)\nusing this:\n  mini (take (Suc (Suc m)) xs) key < Suc (Suc 0)\n  maxi (take (Suc (Suc m)) xs) key < Suc (Suc 0)\n  mini (take (Suc (Suc m)) xs) key \\<noteq> maxi (take (Suc (Suc m)) xs) key\n\ngoal (1 subgoal):\n 1. card\n     ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n      {mini (take (Suc (Suc m)) xs) key}) =\n    0", "by ((subst card_Diff_singleton, simp, simp)+,\n           subst card_lessThan, simp)"], ["proof (state)\nthis:\n  card\n   ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n    {mini (take (Suc (Suc m)) xs) key}) =\n  0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "hence L: \"{..<Suc (Suc 0)} - {?nma} - {?nmi} = {}\""], ["proof (prove)\nusing this:\n  card\n   ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n    {mini (take (Suc (Suc m)) xs) key}) =\n  0\n\ngoal (1 subgoal):\n 1. {..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n    {mini (take (Suc (Suc m)) xs) key} =\n    {}", "by simp"], ["proof (state)\nthis:\n  {..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n  {mini (take (Suc (Suc m)) xs) key} =\n  {}\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "have \"length (fill ?zs (offs ?ms 0) index key m ?mi ?ma) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key m\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    0", "using True"], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. length\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key m\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    0", "by (simp add: fill_length)"], ["proof (state)\nthis:\n  length\n   (fill\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     (offs\n       (enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n       0)\n     index key m\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "hence M: \"map the (fill ?zs (offs ?ms 0) index key m ?mi ?ma) =\n          nths ?ws ({..<Suc (Suc 0)} - {?nma} - {?nmi})\""], ["proof (prove)\nusing this:\n  length\n   (fill\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     (offs\n       (enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n       0)\n     index key m\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  0\n\ngoal (1 subgoal):\n 1. map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key m\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    nths (take (Suc (Suc m)) xs)\n     ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n      {mini (take (Suc (Suc m)) xs) key})", "by (subst L, simp)"], ["proof (state)\nthis:\n  map the\n   (fill\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     (offs\n       (enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n       0)\n     index key m\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  nths (take (Suc (Suc m)) xs)\n   ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n    {mini (take (Suc (Suc m)) xs) key})\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "proof (subst M, subst filter_append)"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     ([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n      nths (take (Suc (Suc m)) xs)\n       ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n        {mini (take (Suc (Suc m)) xs) key})) @\n    filter (\\<lambda>x. key x = k)\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "show \"[x\\<leftarrow>[?xmi] @ nths ?ws ({..<Suc (Suc 0)} - {?nma} - {?nmi}).\n            key x = k] @ [x\\<leftarrow>[?xma]. key x = k] = [x\\<leftarrow>?ws. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     ([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n      nths (take (Suc (Suc m)) xs)\n       ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n        {mini (take (Suc (Suc m)) xs) key})) @\n    filter (\\<lambda>x. key x = k)\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "proof (subst mini_stable, simp only: length_greater_0_conv\n           [symmetric] H, simp add: I J, subst filter_append [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (nths (take (Suc (Suc m)) xs)\n       ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key}) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "show \"[x\\<leftarrow>nths ?ws ({..<Suc (Suc 0)} - {?nma}) @ [?xma].\n              key x = k] = [x\\<leftarrow>?ws. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (nths (take (Suc (Suc m)) xs)\n       ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key}) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "by (subst maxi_stable, simp only: length_greater_0_conv\n               [symmetric] H, simp add: K, simp add: True)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (nths (take (Suc (Suc m)) xs)\n     ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key}) @\n    [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   ([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n    nths (take (Suc (Suc m)) xs)\n     ({..<Suc (Suc 0)} - {maxi (take (Suc (Suc m)) xs) key} -\n      {mini (take (Suc (Suc m)) xs) key})) @\n  filter (\\<lambda>x. key x = k)\n   [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) @\n    [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "case False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "hence \"0 < ?k\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')", "by (simp, drule_tac bn_comp_fst_nonzero [OF E], subst (asm) D,\n           simp split: nat.split)"], ["proof (state)\nthis:\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "hence \"[x\\<leftarrow>map the (fill ?zs (offs ?ms 0) index key (length ?zs) ?mi ?ma).\n          key x = k] = [x\\<leftarrow>?zs. k = key x]\""], ["proof (prove)\nusing this:\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key\n         (length\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key})))\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs !\n               maxi (take (Suc (Suc m)) xs) key)))) =\n    filter (\\<lambda>x. k = key x)\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))", "by (rule_tac fill_offs_enum_stable [OF A B], simp, rule_tac conjI,\n           ((rule_tac mini_lb | rule_tac maxi_ub), erule_tac in_set_nthsD)+)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key\n       (length\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key})))\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) =\n  filter (\\<lambda>x. k = key x)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "moreover"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key\n       (length\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key})))\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) =\n  filter (\\<lambda>x. k = key x)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "have \"[x\\<leftarrow>?zs. k = key x] = [x\\<leftarrow>?zs. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. k = key x)\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})) =\n    filter (\\<lambda>x. key x = k)\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))", "by (rule filter_cong, simp, blast)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. k = key x)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  filter (\\<lambda>x. key x = k)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "ultimately"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. key x = k)\n   (map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key\n       (length\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key})))\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) =\n  filter (\\<lambda>x. k = key x)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n  filter (\\<lambda>x. k = key x)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  filter (\\<lambda>x. key x = k)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))", "have\n          J: \"[x\\<leftarrow>map the (fill ?zs (offs ?ms 0) index key m ?mi ?ma).\n            key x = k] = [x\\<leftarrow>?zs. key x = k]\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. key x = k)\n   (map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key\n       (length\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key})))\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) =\n  filter (\\<lambda>x. k = key x)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n  filter (\\<lambda>x. k = key x)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  filter (\\<lambda>x. key x = k)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs !\n               maxi (take (Suc (Suc m)) xs) key)))) =\n    filter (\\<lambda>x. key x = k)\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))", "using H"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. key x = k)\n   (map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key\n       (length\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key})))\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) =\n  filter (\\<lambda>x. k = key x)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n  filter (\\<lambda>x. k = key x)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  filter (\\<lambda>x. key x = k)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs !\n               maxi (take (Suc (Suc m)) xs) key)))) =\n    filter (\\<lambda>x. key x = k)\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))", "by (simp add: mini_maxi_nths)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key m\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) =\n  filter (\\<lambda>x. key x = k)\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n       map the\n        (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs !\n                maxi (take (Suc (Suc m)) xs) key)))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "proof (simp only: filter_append J, subst Compl_eq_Diff_UNIV,\n         subst Diff_insert, subst filter_append [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     ([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n      nths (take (Suc (Suc m)) xs)\n       (UNIV - {maxi (take (Suc (Suc m)) xs) key} -\n        {mini (take (Suc (Suc m)) xs) key})) @\n    filter (\\<lambda>x. key x = k)\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "show \"[x\\<leftarrow>[?xmi] @ nths ?ws (UNIV - {?nma} - {?nmi}). key x = k]\n            @ [x\\<leftarrow>[?xma]. key x = k] = [x\\<leftarrow>?ws. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     ([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n      nths (take (Suc (Suc m)) xs)\n       (UNIV - {maxi (take (Suc (Suc m)) xs) key} -\n        {mini (take (Suc (Suc m)) xs) key})) @\n    filter (\\<lambda>x. key x = k)\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "proof (subst mini_stable, simp only: length_greater_0_conv\n           [symmetric] H, simp add: I, subst filter_append [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (nths (take (Suc (Suc m)) xs)\n       (UNIV - {maxi (take (Suc (Suc m)) xs) key}) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "show \"[x\\<leftarrow>nths ?ws (UNIV - {?nma}) @ [?xma]. key x = k] =\n              [x\\<leftarrow>?ws. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (nths (take (Suc (Suc m)) xs)\n       (UNIV - {maxi (take (Suc (Suc m)) xs) key}) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "by (subst maxi_stable, simp only: length_greater_0_conv\n               [symmetric] H, simp, subst nths_range, subst H, simp)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (nths (take (Suc (Suc m)) xs)\n     (UNIV - {maxi (take (Suc (Suc m)) xs) key}) @\n    [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   ([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n    nths (take (Suc (Suc m)) xs)\n     (UNIV - {maxi (take (Suc (Suc m)) xs) key} -\n      {mini (take (Suc (Suc m)) xs) key})) @\n  filter (\\<lambda>x. key x = k)\n   [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) @\n    [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) @\n    [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f k =\n             filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs) @\n             filter (\\<lambda>x. key x = k) xs';\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>x. key x = k)\n                       (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key #\n                        map the\n                         (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key))) @\n                        [take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key]) =\n                      filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "thus \"[x\\<leftarrow>?xmi # map the (fill ?zs (offs ?ms 0) index key m ?mi ?ma) @\n        [?xma]. key x = k] = [x\\<leftarrow>?ws. key x = k]\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. key x = k)\n   (([take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key] @\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))) @\n    [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n    filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n    map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key m\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n    [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n  filter (\\<lambda>x. key x = k) (take (Suc (Suc m)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) ws' @ filter (\\<lambda>x. key x = k) xs' =\n  f k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  stab_inv f key (round index key p q r (u, Suc (Suc m) # ns, xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcsort_stab_inv:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_same index key\" and\n    C: \"add_inv n t\" and\n    D: \"n \\<le> p\"\n  shows \"\\<lbrakk>t' \\<in> gcsort_set index key p t; stab_inv f key t\\<rbrakk> \\<Longrightarrow>\n    stab_inv f key t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in> gcsort_set index key p t; stab_inv f key t\\<rbrakk>\n    \\<Longrightarrow> stab_inv f key t'", "by (erule gcsort_set.induct, simp, drule gcsort_add_inv [OF A _ C D],\n rule round_stab_inv [OF A B], simp_all del: bn_inv.simps, erule conjE,\n frule sym, erule subst, rule bn_inv_intro, insert D, simp)"], ["", "text \\<open>\n\\null\n\nThe only remaining task is to address step 10 of the proof method, which is done by proving theorem\n@{text gcsort_stable}. It holds under the conditions that the objects' number is not larger than the\ncounters' upper bound and function @{text index} satisfies both predicates @{const index_less} and\n@{const index_same}, and states that function @{const gcsort} leaves unchanged the sublist of the\nobjects having a given key within the input objects' list.\n\n\\null\n\\<close>"], ["", "theorem gcsort_stable:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_same index key\" and\n    C: \"length xs \\<le> p\"\n  shows \"[x\\<leftarrow>gcsort index key p xs. key x = k] = [x\\<leftarrow>xs. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (gcsort index key p xs) =\n    filter (\\<lambda>x. key x = k) xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (gcsort index key p xs) =\n    filter (\\<lambda>x. key x = k) xs", "let ?t = \"(0, [length xs], xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (gcsort index key p xs) =\n    filter (\\<lambda>x. key x = k) xs", "have \"stab_inv (\\<lambda>k. [x\\<leftarrow>xs. key x = k]) key (gcsort_aux index key p ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stab_inv (\\<lambda>k. filter (\\<lambda>x. key x = k) xs) key\n     (gcsort_aux index key p (0, [length xs], xs))", "by (rule gcsort_stab_inv [OF A B _ C], rule gcsort_add_input,\n     rule gcsort_aux_set, rule gcsort_stab_input)"], ["proof (state)\nthis:\n  stab_inv (\\<lambda>k. filter (\\<lambda>x. key x = k) xs) key\n   (gcsort_aux index key p (0, [length xs], xs))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (gcsort index key p xs) =\n    filter (\\<lambda>x. key x = k) xs", "hence \"[x\\<leftarrow>gcsort_out (gcsort_aux index key p ?t). key x = k] =\n    [x\\<leftarrow>xs. key x = k]\""], ["proof (prove)\nusing this:\n  stab_inv (\\<lambda>k. filter (\\<lambda>x. key x = k) xs) key\n   (gcsort_aux index key p (0, [length xs], xs))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k)\n     (gcsort_out (gcsort_aux index key p (0, [length xs], xs))) =\n    filter (\\<lambda>x. key x = k) xs", "by (rule gcsort_stab_intro)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (gcsort_out (gcsort_aux index key p (0, [length xs], xs))) =\n  filter (\\<lambda>x. key x = k) xs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (gcsort index key p xs) =\n    filter (\\<lambda>x. key x = k) xs", "moreover"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k)\n   (gcsort_out (gcsort_aux index key p (0, [length xs], xs))) =\n  filter (\\<lambda>x. key x = k) xs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (gcsort index key p xs) =\n    filter (\\<lambda>x. key x = k) xs", "have \"?t = gcsort_in xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0, [length xs], xs) = gcsort_in xs", "by (simp add: gcsort_in_def)"], ["proof (state)\nthis:\n  (0, [length xs], xs) = gcsort_in xs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (gcsort index key p xs) =\n    filter (\\<lambda>x. key x = k) xs", "ultimately"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. key x = k)\n   (gcsort_out (gcsort_aux index key p (0, [length xs], xs))) =\n  filter (\\<lambda>x. key x = k) xs\n  (0, [length xs], xs) = gcsort_in xs", "show ?thesis"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. key x = k)\n   (gcsort_out (gcsort_aux index key p (0, [length xs], xs))) =\n  filter (\\<lambda>x. key x = k) xs\n  (0, [length xs], xs) = gcsort_in xs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (gcsort index key p xs) =\n    filter (\\<lambda>x. key x = k) xs", "by (simp add: gcsort_def)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. key x = k) (gcsort index key p xs) =\n  filter (\\<lambda>x. key x = k) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}