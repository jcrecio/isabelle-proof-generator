{"file_name": "/home/qj213/afp-2021-10-22/thys/Generalized_Counting_Sort/Sorting.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Generalized_Counting_Sort", "problem_names": ["lemma gcsort_sort_input:\n \"sort_inv key (0, [length xs], xs)\"", "lemma offs_nth:\n  assumes\n    A: \"find (\\<lambda>n. Suc 0 < n) ns = None\" and\n    B: \"foldl (+) 0 ns = n\" and\n    C: \"k < n\"\n  shows \"\\<exists>i < length ns. offs ns 0 ! i = k\"", "lemma gcsort_sort_intro:\n \"\\<lbrakk>sort_inv key t; add_inv n t; find (\\<lambda>n. Suc 0 < n) (fst (snd t)) = None\\<rbrakk> \\<Longrightarrow>\n    sorted (map key (gcsort_out t))\"", "lemma gcsort_sort_form:\n \"find (\\<lambda>n. Suc 0 < n) (fst (snd (gcsort_aux index key p t))) = None\"", "lemma mini_maxi_keys_le:\n \"x \\<in> set xs \\<Longrightarrow> key (xs ! mini xs key) \\<le> key (xs ! maxi xs key)\"", "lemma mini_maxi_keys_eq [rule_format]:\n \"key (xs ! mini xs key) = key (xs ! maxi xs key) \\<longrightarrow> x \\<in> set xs \\<longrightarrow>\n    key x = key (xs ! maxi xs key)\"", "lemma offs_suc:\n \"i < length ns \\<Longrightarrow> offs ns (Suc k) ! i = Suc (offs ns k ! i)\"", "lemma offs_base_zero:\n \"i < length ns \\<Longrightarrow> offs ns k ! i = offs ns 0 ! i + k\"", "lemma offs_append:\n \"offs (ms @ ns) k = offs ms k @ offs ns (foldl (+) k ms)\"", "lemma offs_enum_next_le [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"i < j\" and\n    C: \"j < n\" and\n    D: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n    xs index key mi ma i \\<le> offs (enum xs index key n mi ma) k ! j\"\n  (is \"_ \\<le> offs ?ns _ ! _\")", "lemma offs_pred_ub_less:\n \"\\<lbrakk>offs_pred ns ub xs index key mi ma; i < length ns;\n   0 < offs_num (length ns) xs index key mi ma i\\<rbrakk> \\<Longrightarrow>\n     ns ! i < ub\"", "lemma fill_count_none [rule_format]:\n  assumes A: \"index_less index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    length xs \\<le> ub \\<longrightarrow>\n      count (mset (fill xs ns index key ub mi ma)) None = ub - length xs\"", "lemma fill_offs_enum_count_none [rule_format]:\n \"\\<lbrakk>index_less index key; \\<forall>x \\<in> set xs. key x \\<in> {mi..ma}; 0 < n\\<rbrakk> \\<Longrightarrow>\n    count (mset (fill xs (offs (enum xs index key n mi ma) 0)\n      index key (length xs) mi ma)) None = 0\"", "lemma fill_index [rule_format]:\n  assumes A: \"index_less index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    i < length ns \\<longrightarrow>\n    0 < offs_num (length ns) xs index key mi ma i \\<longrightarrow>\n    j \\<in> {ns ! i..<offs_next ns ub xs index key mi ma i} \\<longrightarrow>\n    fill xs ns index key ub mi ma ! j = Some x \\<longrightarrow>\n      index key x (length ns) mi ma = i\"", "lemma fill_offs_enum_index [rule_format]:\n \"index_less index key \\<Longrightarrow>\n  \\<forall>x \\<in> set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n  i < n \\<Longrightarrow>\n  0 < offs_num n xs index key mi ma i \\<Longrightarrow>\n  j \\<in> {offs (enum xs index key n mi ma) 0 ! i..<\n    offs_next (offs (enum xs index key n mi ma) 0) (length xs)\n      xs index key mi ma i} \\<Longrightarrow>\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n    mi ma ! j = Some x \\<Longrightarrow>\n    index key x n mi ma = i\"", "lemma fill_sort_inv [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_mono index key\" and\n    C: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"sort_inv key (u, enum xs index key n mi ma,\n    map the (fill xs (offs (enum xs index key n mi ma) 0)\n      index key (length xs) mi ma))\"\n  (is \"sort_inv _ (_, ?ns, _)\")", "lemma round_sort_inv [rule_format]:\n \"index_less index key \\<longrightarrow> index_mono index key \\<longrightarrow> bn_inv p q t \\<longrightarrow>\n    add_inv n t \\<longrightarrow> sort_inv key t \\<longrightarrow> sort_inv key (round index key p q r t)\"", "lemma gcsort_sort_inv:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_mono index key\" and\n    C: \"add_inv n t\" and\n    D: \"n \\<le> p\"\n  shows \"\\<lbrakk>t' \\<in> gcsort_set index key p t; sort_inv key t\\<rbrakk> \\<Longrightarrow>\n    sort_inv key t'\"", "theorem gcsort_sorted:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_mono index key\" and\n    C: \"length xs \\<le> p\"\n  shows \"sorted (map key (gcsort index key p xs))\""], "translations": [["", "lemma gcsort_sort_input:\n \"sort_inv key (0, [length xs], xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_inv key (0, [length xs], xs)", "by simp"], ["", "lemma offs_nth:\n  assumes\n    A: \"find (\\<lambda>n. Suc 0 < n) ns = None\" and\n    B: \"foldl (+) 0 ns = n\" and\n    C: \"k < n\"\n  shows \"\\<exists>i < length ns. offs ns 0 ! i = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length ns. offs ns 0 ! i = k", "proof (cases ns, insert B C, simp, cases \"k = 0\", rule exI [of _ 0], simp,\n rule ccontr, simp (no_asm_use))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "fix m ms"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "assume\n    D: \"ns = m # ms\" and\n    E: \"0 < k\" and\n    F: \"\\<forall>i < length ns. offs ns 0 ! i \\<noteq> k\""], ["proof (state)\nthis:\n  ns = m # ms\n  0 < k\n  \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have G: \"\\<forall>n \\<in> set ns. n \\<le> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set ns. n \\<le> Suc 0", "using A"], ["proof (prove)\nusing this:\n  find ((<) (Suc 0)) ns = None\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set ns. n \\<le> Suc 0", "by (auto simp add: find_None_iff)"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set ns. n \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "let ?A = \"{i. i < length ns \\<and> offs ns 0 ! i < k}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have H: \"Max ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n    \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}", "using D and E"], ["proof (prove)\nusing this:\n  ns = m # ms\n  0 < k\n\ngoal (1 subgoal):\n 1. Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n    \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}", "by (rule_tac Max_in, simp_all, rule_tac exI [of _ 0], simp)"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence I: \"Max ?A < length ns\""], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns", "by simp"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence J: \"offs ns 0 ! Max ?A = foldl (+) 0 (take (Max ?A) ns)\""], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n    foldl (+) 0 (take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns)", "by (rule offs_add)"], ["proof (state)\nthis:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  foldl (+) 0 (take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"Max ?A < length ns - Suc 0 \\<or> Max ?A = length ns - Suc 0\"\n    (is \"?P \\<or> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n    < length ns - Suc 0 \\<or>\n    Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0", "using H"], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n    < length ns - Suc 0 \\<or>\n    Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0", "by (simp, arith)"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns - Suc 0 \\<or>\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns - Suc 0 \\<or>\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns - Suc 0 \\<or>\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "assume ?P"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence K: \"Suc (Max ?A) < length ns\""], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns - Suc 0\n\ngoal (1 subgoal):\n 1. Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) < length ns", "by simp"], ["proof (state)\nthis:\n  Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"offs ns 0 ! Suc (Max ?A) = foldl (+) 0 (take (Suc (Max ?A)) ns)\""], ["proof (prove)\nusing this:\n  Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) < length ns\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n    foldl (+) 0\n     (take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns)", "by (rule offs_add)"], ["proof (state)\nthis:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n  foldl (+) 0\n   (take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n  foldl (+) 0\n   (take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"take (Suc (Max ?A)) ns = take (Max ?A) ns @ [ns ! Max ?A]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns =\n    take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns @\n    [ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}]", "using I"], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns\n\ngoal (1 subgoal):\n 1. take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns =\n    take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns @\n    [ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}]", "by (rule take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns =\n  take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns @\n  [ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n  foldl (+) 0\n   (take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns)\n  take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns =\n  take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns @\n  [ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}]", "have \"offs ns 0 ! Suc (Max ?A) =\n      offs ns 0 ! Max ?A + ns ! Max ?A\""], ["proof (prove)\nusing this:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n  foldl (+) 0\n   (take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns)\n  take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns =\n  take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns @\n  [ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}]\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n    offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n    ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}", "using J"], ["proof (prove)\nusing this:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n  foldl (+) 0\n   (take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns)\n  take (Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})) ns =\n  take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns @\n  [ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}]\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  foldl (+) 0 (take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns)\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n    offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n    ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}", "by simp"], ["proof (state)\nthis:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"offs ns 0 ! Max ?A < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k", "using H"], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k", "by simp"], ["proof (state)\nthis:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"ns ! Max ?A \\<in> set ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} \\<in> set ns", "using I"], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns\n\ngoal (1 subgoal):\n 1. ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} \\<in> set ns", "by (rule nth_mem)"], ["proof (state)\nthis:\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "with G"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set ns. n \\<le> Suc 0\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} \\<in> set ns", "have \"ns ! Max ?A \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set ns. n \\<le> Suc 0\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} \\<in> set ns\n\ngoal (1 subgoal):\n 1. ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} \\<le> Suc 0", ".."], ["proof (state)\nthis:\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} \\<le> Suc 0", "have \"offs ns 0 ! Suc (Max ?A) \\<le> k\""], ["proof (prove)\nusing this:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) =\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k\n  ns ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})\n    \\<le> k", "by simp"], ["proof (state)\nthis:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"offs ns 0 ! Suc (Max ?A) \\<noteq> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs ns 0 !\n    Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) \\<noteq>\n    k", "using F and K"], ["proof (prove)\nusing this:\n  \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\n  Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) < length ns\n\ngoal (1 subgoal):\n 1. offs ns 0 !\n    Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) \\<noteq>\n    k", "by simp"], ["proof (state)\nthis:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) \\<noteq>\n  k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) \\<le> k\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) \\<noteq>\n  k", "have \"offs ns 0 ! Suc (Max ?A) < k\""], ["proof (prove)\nusing this:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) \\<le> k\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) \\<noteq>\n  k\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) < k", "by simp"], ["proof (state)\nthis:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) < k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"Suc (Max ?A) \\<in> ?A\""], ["proof (prove)\nusing this:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) < k\n\ngoal (1 subgoal):\n 1. Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})\n    \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}", "using K"], ["proof (prove)\nusing this:\n  offs ns 0 ! Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) < k\n  Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) < length ns\n\ngoal (1 subgoal):\n 1. Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})\n    \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}", "by simp"], ["proof (state)\nthis:\n  Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})\n  \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"Suc (Max ?A) \\<le> Max ?A\""], ["proof (prove)\nusing this:\n  Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})\n  \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})\n    \\<le> Max {i. i < length ns \\<and> offs ns 0 ! i < k}", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})\n  \\<le> Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence False"], ["proof (prove)\nusing this:\n  Suc (Max {i. i < length ns \\<and> offs ns 0 ! i < k})\n  \\<le> Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  < length ns - Suc 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  < length ns - Suc 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  < length ns - Suc 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "assume ?Q"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"offs ns 0 ! Max ?A = foldl (+) 0 (take (length ns - Suc 0) ns)\""], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n    foldl (+) 0 (take (length ns - Suc 0) ns)", "using J"], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  foldl (+) 0 (take (Max {i. i < length ns \\<and> offs ns 0 ! i < k}) ns)\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n    foldl (+) 0 (take (length ns - Suc 0) ns)", "by simp"], ["proof (state)\nthis:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  foldl (+) 0 (take (length ns - Suc 0) ns)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  foldl (+) 0 (take (length ns - Suc 0) ns)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have K: \"length ns - Suc 0 < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ns - Suc 0 < length ns", "using D"], ["proof (prove)\nusing this:\n  ns = m # ms\n\ngoal (1 subgoal):\n 1. length ns - Suc 0 < length ns", "by simp"], ["proof (state)\nthis:\n  length ns - Suc 0 < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"take (Suc (length ns - Suc 0)) ns =\n      take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)]\""], ["proof (prove)\nusing this:\n  length ns - Suc 0 < length ns\n\ngoal (1 subgoal):\n 1. take (Suc (length ns - Suc 0)) ns =\n    take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)]", "by (rule take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take (Suc (length ns - Suc 0)) ns =\n  take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"foldl (+) 0 ns =\n      foldl (+) 0 (take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)])\""], ["proof (prove)\nusing this:\n  take (Suc (length ns - Suc 0)) ns =\n  take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)]\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns =\n    foldl (+) 0 (take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)])", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0 ns =\n  foldl (+) 0 (take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)])\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  foldl (+) 0 (take (length ns - Suc 0) ns)\n  foldl (+) 0 ns =\n  foldl (+) 0 (take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)])", "have \"n = offs ns 0 ! Max ?A + ns ! (length ns - Suc 0)\""], ["proof (prove)\nusing this:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  foldl (+) 0 (take (length ns - Suc 0) ns)\n  foldl (+) 0 ns =\n  foldl (+) 0 (take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)])\n\ngoal (1 subgoal):\n 1. n =\n    offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n    ns ! (length ns - Suc 0)", "using B"], ["proof (prove)\nusing this:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  foldl (+) 0 (take (length ns - Suc 0) ns)\n  foldl (+) 0 ns =\n  foldl (+) 0 (take (length ns - Suc 0) ns @ [ns ! (length ns - Suc 0)])\n  foldl (+) 0 ns = n\n\ngoal (1 subgoal):\n 1. n =\n    offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n    ns ! (length ns - Suc 0)", "by simp"], ["proof (state)\nthis:\n  n =\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n  ns ! (length ns - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n =\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n  ns ! (length ns - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"offs ns 0 ! Max ?A < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k", "using H"], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  \\<in> {i. i < length ns \\<and> offs ns 0 ! i < k}\n\ngoal (1 subgoal):\n 1. offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k", "by simp"], ["proof (state)\nthis:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"ns ! (length ns - Suc 0) \\<in> set ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! (length ns - Suc 0) \\<in> set ns", "using K"], ["proof (prove)\nusing this:\n  length ns - Suc 0 < length ns\n\ngoal (1 subgoal):\n 1. ns ! (length ns - Suc 0) \\<in> set ns", "by (rule nth_mem)"], ["proof (state)\nthis:\n  ns ! (length ns - Suc 0) \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "with G"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set ns. n \\<le> Suc 0\n  ns ! (length ns - Suc 0) \\<in> set ns", "have \"ns ! (length ns - Suc 0) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set ns. n \\<le> Suc 0\n  ns ! (length ns - Suc 0) \\<in> set ns\n\ngoal (1 subgoal):\n 1. ns ! (length ns - Suc 0) \\<le> Suc 0", ".."], ["proof (state)\nthis:\n  ns ! (length ns - Suc 0) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  n =\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n  ns ! (length ns - Suc 0)\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k\n  ns ! (length ns - Suc 0) \\<le> Suc 0", "have \"n \\<le> k\""], ["proof (prove)\nusing this:\n  n =\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} +\n  ns ! (length ns - Suc 0)\n  offs ns 0 ! Max {i. i < length ns \\<and> offs ns 0 ! i < k} < k\n  ns ! (length ns - Suc 0) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. n \\<le> k", "by simp"], ["proof (state)\nthis:\n  n \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "with C"], ["proof (chain)\npicking this:\n  k < n\n  n \\<le> k", "have False"], ["proof (prove)\nusing this:\n  k < n\n  n \\<le> k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  length ns - Suc 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ns = a # list; foldl (+) 0 ns = n; k < n; 0 < k;\n        \\<forall>i<length ns. offs ns 0 ! i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns - Suc 0 \\<or>\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  < length ns - Suc 0 \\<Longrightarrow>\n  False\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  length ns - Suc 0 \\<Longrightarrow>\n  False", "show False"], ["proof (prove)\nusing this:\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} < length ns - Suc 0 \\<or>\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} = length ns - Suc 0\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k}\n  < length ns - Suc 0 \\<Longrightarrow>\n  False\n  Max {i. i < length ns \\<and> offs ns 0 ! i < k} =\n  length ns - Suc 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcsort_sort_intro:\n \"\\<lbrakk>sort_inv key t; add_inv n t; find (\\<lambda>n. Suc 0 < n) (fst (snd t)) = None\\<rbrakk> \\<Longrightarrow>\n    sorted (map key (gcsort_out t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sort_inv key t; add_inv n t;\n     find ((<) (Suc 0)) (fst (snd t)) = None\\<rbrakk>\n    \\<Longrightarrow> sorted (map key (gcsort_out t))", "proof (cases t, simp add: sorted_iff_nth_mono_less gcsort_out_def,\n erule conjE, (rule allI)+, (rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "fix ns xs j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "assume \"find (\\<lambda>n. Suc 0 < n) ns = None\" and \"foldl (+) 0 ns = n\""], ["proof (state)\nthis:\n  find ((<) (Suc 0)) ns = None\n  foldl (+) 0 ns = n\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "moreover"], ["proof (state)\nthis:\n  find ((<) (Suc 0)) ns = None\n  foldl (+) 0 ns = n\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "assume A: \"k < n\""], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "ultimately"], ["proof (chain)\npicking this:\n  find ((<) (Suc 0)) ns = None\n  foldl (+) 0 ns = n\n  k < n", "have \"\\<exists>i < length ns. offs ns 0 ! i = k\""], ["proof (prove)\nusing this:\n  find ((<) (Suc 0)) ns = None\n  foldl (+) 0 ns = n\n  k < n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length ns. offs ns 0 ! i = k", "by (rule offs_nth)"], ["proof (state)\nthis:\n  \\<exists>i<length ns. offs ns 0 ! i = k\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<length ns. offs ns 0 ! i = k", "obtain i where \"i < length ns \\<and> offs ns 0 ! i = k\""], ["proof (prove)\nusing this:\n  \\<exists>i<length ns. offs ns 0 ! i = k\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length ns \\<and> offs ns 0 ! i = k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  i < length ns \\<and> offs ns 0 ! i = k\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "moreover"], ["proof (state)\nthis:\n  i < length ns \\<and> offs ns 0 ! i = k\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "assume \"\\<forall>i < length ns. \\<forall>j < offs ns 0 ! i. \\<forall>k \\<in> {offs ns 0 ! i..<n}.\n    key (xs ! j) \\<le> key (xs ! k)\""], ["proof (state)\nthis:\n  \\<forall>i<length ns.\n     \\<forall>j<offs ns 0 ! i.\n        \\<forall>k\\<in>{offs ns 0 ! i..<n}. key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "hence \"i < length ns \\<longrightarrow> j < offs ns 0 ! i \\<longrightarrow> k \\<in> {offs ns 0 ! i..<n} \\<longrightarrow>\n    key (xs ! j) \\<le> key (xs ! k)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ns.\n     \\<forall>j<offs ns 0 ! i.\n        \\<forall>k\\<in>{offs ns 0 ! i..<n}. key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. i < length ns \\<longrightarrow>\n    j < offs ns 0 ! i \\<longrightarrow>\n    k \\<in> {offs ns 0 ! i..<n} \\<longrightarrow>\n    key (xs ! j) \\<le> key (xs ! k)", "by simp"], ["proof (state)\nthis:\n  i < length ns \\<longrightarrow>\n  j < offs ns 0 ! i \\<longrightarrow>\n  k \\<in> {offs ns 0 ! i..<n} \\<longrightarrow>\n  key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "ultimately"], ["proof (chain)\npicking this:\n  i < length ns \\<and> offs ns 0 ! i = k\n  i < length ns \\<longrightarrow>\n  j < offs ns 0 ! i \\<longrightarrow>\n  k \\<in> {offs ns 0 ! i..<n} \\<longrightarrow>\n  key (xs ! j) \\<le> key (xs ! k)", "have \"j < k \\<longrightarrow> k < n \\<longrightarrow> key (xs ! j) \\<le> key (xs ! k)\""], ["proof (prove)\nusing this:\n  i < length ns \\<and> offs ns 0 ! i = k\n  i < length ns \\<longrightarrow>\n  j < offs ns 0 ! i \\<longrightarrow>\n  k \\<in> {offs ns 0 ! i..<n} \\<longrightarrow>\n  key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. j < k \\<longrightarrow>\n    k < n \\<longrightarrow> key (xs ! j) \\<le> key (xs ! k)", "by simp"], ["proof (state)\nthis:\n  j < k \\<longrightarrow>\n  k < n \\<longrightarrow> key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "moreover"], ["proof (state)\nthis:\n  j < k \\<longrightarrow>\n  k < n \\<longrightarrow> key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "assume \"j < k\""], ["proof (state)\nthis:\n  j < k\n\ngoal (1 subgoal):\n 1. \\<And>a b c i j.\n       \\<lbrakk>\\<forall>i<length b.\n                   \\<forall>j<offs b 0 ! i.\n                      \\<forall>k\\<in>{offs b 0 ! i..<n}.\n                         key (c ! j) \\<le> key (c ! k);\n        find ((<) (Suc 0)) b = None; t = (a, b, c); foldl (+) 0 b = n;\n        length c = n; i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> key (c ! i) \\<le> key (c ! j)", "ultimately"], ["proof (chain)\npicking this:\n  j < k \\<longrightarrow>\n  k < n \\<longrightarrow> key (xs ! j) \\<le> key (xs ! k)\n  j < k", "show \"key (xs ! j) \\<le> key (xs ! k)\""], ["proof (prove)\nusing this:\n  j < k \\<longrightarrow>\n  k < n \\<longrightarrow> key (xs ! j) \\<le> key (xs ! k)\n  j < k\n\ngoal (1 subgoal):\n 1. key (xs ! j) \\<le> key (xs ! k)", "using A"], ["proof (prove)\nusing this:\n  j < k \\<longrightarrow>\n  k < n \\<longrightarrow> key (xs ! j) \\<le> key (xs ! k)\n  j < k\n  k < n\n\ngoal (1 subgoal):\n 1. key (xs ! j) \\<le> key (xs ! k)", "by simp"], ["proof (state)\nthis:\n  key (xs ! j) \\<le> key (xs ! k)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nAs lemma @{thm [source] gcsort_sort_intro} comprises an additional assumption concerning the form of\nthe fixed points of function @{const gcsort_aux}, step 8 of the proof method is necessary this time\nto prove that such assumption is satisfied.\n\n\\null\n\\<close>"], ["", "lemma gcsort_sort_form:\n \"find (\\<lambda>n. Suc 0 < n) (fst (snd (gcsort_aux index key p t))) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find ((<) (Suc 0)) (fst (snd (gcsort_aux index key p t))) = None", "by (induction index key p t rule: gcsort_aux.induct, simp)"], ["", "text \\<open>\n\\null\n\nHere below, step 9 of the proof method is accomplished.\n\nIn the most significant case of the proof by recursion induction of lemma @{text round_sort_inv},\nnamely that of a bucket $B$ with size larger than two and distinct minimum and maximum keys, the\nfollowing line of reasoning is adopted. Let $x$ be an object contained in a finer-grained bucket\n$B'$ resulting from $B$'s partition, and $y$ an object to the right of $B'$. Then:\n\n\\begin{itemize}\n\n\\item\nIf $y$ is contained in some other finer-grained bucket resulting from $B$'s partition, inequality\n@{term \"key x \\<le> key y\"} holds because predicate @{const sort_inv} is satisfied by a counters' list\ngenerated by function @{const enum} and an objects' list generated by function @{const fill} in case\n@{const fill}'s input offsets' list is computed via the composition of functions @{const offs} and\n@{const enum}, as happens within function @{const round}.\n\\\\This is proven beforehand in lemma @{text fill_sort_inv}.\n\n\\item\nOtherwise, inequality @{term \"key x \\<le> key y\"} holds as well because object $x$ was contained in $B$\nby lemma @{thm [source] fill_offs_enum_count_item}, object $y$ occurred to the right of $B$ by lemma\n@{thm [source] round_count_inv}, and by hypothesis, the key of any object in $B$ was not larger than\nthat of any object to the right of $B$.\n\n\\end{itemize}\n\nUsing lemma @{text round_sort_inv}, the invariance of predicate @{const sort_inv} over inductive set\n@{const gcsort_set} is then proven in lemma @{text gcsort_sort_inv}.\n\n\\null\n\\<close>"], ["", "lemma mini_maxi_keys_le:\n \"x \\<in> set xs \\<Longrightarrow> key (xs ! mini xs key) \\<le> key (xs ! maxi xs key)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow>\n    key (xs ! mini xs key) \\<le> key (xs ! maxi xs key)", "by (frule mini_lb, drule maxi_ub, erule order_trans)"], ["", "lemma mini_maxi_keys_eq [rule_format]:\n \"key (xs ! mini xs key) = key (xs ! maxi xs key) \\<longrightarrow> x \\<in> set xs \\<longrightarrow>\n    key x = key (xs ! maxi xs key)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) = key (xs ! maxi xs key) \\<longrightarrow>\n    x \\<in> set xs \\<longrightarrow> key x = key (xs ! maxi xs key)", "by (induction xs, simp_all add: Let_def, (rule_tac [!] impI, (rule_tac [!] conjI)?)+,\n rule_tac [2-4] impI, frule_tac [1-3] mini_maxi_keys_le [where key = key], simp_all)"], ["", "lemma offs_suc:\n \"i < length ns \\<Longrightarrow> offs ns (Suc k) ! i = Suc (offs ns k ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ns \\<Longrightarrow>\n    offs ns (Suc k) ! i = Suc (offs ns k ! i)", "by (simp add: offs_add add_suc)"], ["", "lemma offs_base_zero:\n \"i < length ns \\<Longrightarrow> offs ns k ! i = offs ns 0 ! i + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ns \\<Longrightarrow> offs ns k ! i = offs ns 0 ! i + k", "by (simp add: offs_add, subst add_base_zero, simp)"], ["", "lemma offs_append:\n \"offs (ms @ ns) k = offs ms k @ offs ns (foldl (+) k ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (ms @ ns) k = offs ms k @ offs ns (foldl (+) k ms)", "by (induction ms arbitrary: k, simp_all)"], ["", "lemma offs_enum_next_le [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"i < j\" and\n    C: \"j < n\" and\n    D: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n    xs index key mi ma i \\<le> offs (enum xs index key n mi ma) k ! j\"\n  (is \"_ \\<le> offs ?ns _ ! _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n    \\<le> offs (enum xs index key n mi ma) k ! j", "proof (rule ccontr, simp add: not_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j\n    < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i \\<Longrightarrow>\n    False", "assume E: \"offs ?ns k ! j <\n    offs_next (offs ?ns k) (length xs + k) xs index key mi ma i\""], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! j\n  < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j\n    < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i \\<Longrightarrow>\n    False", "from B"], ["proof (chain)\npicking this:\n  i < j", "have \"offs_set_next (offs ?ns k) xs index key mi ma i =\n    offs_set_next (offs ?ns k) xs index key mi ma j\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i =\n    offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma j", "proof (rule_tac set_eqI, rule_tac iffI, simp_all, rule_tac ccontr, simp add: not_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length (offs (enum xs index key n mi ma) k) \\<and>\n                i < x \\<and>\n                0 < offs_num (length (offs (enum xs index key n mi ma) k))\n                     xs index key mi ma x;\n        x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> False", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length (offs (enum xs index key n mi ma) k) \\<and>\n                i < x \\<and>\n                0 < offs_num (length (offs (enum xs index key n mi ma) k))\n                     xs index key mi ma x;\n        x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"m < length (offs ?ns k) \\<and> i < m \\<and>\n      0 < offs_num (length (offs ?ns k)) xs index key mi ma m\""], ["proof (state)\nthis:\n  m < length (offs (enum xs index key n mi ma) k) \\<and>\n  i < m \\<and>\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length (offs (enum xs index key n mi ma) k) \\<and>\n                i < x \\<and>\n                0 < offs_num (length (offs (enum xs index key n mi ma) k))\n                     xs index key mi ma x;\n        x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> False", "hence F: \"m \\<in> offs_set_next (offs ?ns k) xs index key mi ma i\"\n      (is \"_ \\<in> ?A\")"], ["proof (prove)\nusing this:\n  m < length (offs (enum xs index key n mi ma) k) \\<and>\n  i < m \\<and>\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma m\n\ngoal (1 subgoal):\n 1. m \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n             mi ma i", "by simp"], ["proof (state)\nthis:\n  m \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length (offs (enum xs index key n mi ma) k) \\<and>\n                i < x \\<and>\n                0 < offs_num (length (offs (enum xs index key n mi ma) k))\n                     xs index key mi ma x;\n        x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"Min ?A \\<le> m\""], ["proof (prove)\nusing this:\n  m \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> m", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length (offs (enum xs index key n mi ma) k) \\<and>\n                i < x \\<and>\n                0 < offs_num (length (offs (enum xs index key n mi ma) k))\n                     xs index key mi ma x;\n        x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length (offs (enum xs index key n mi ma) k) \\<and>\n                i < x \\<and>\n                0 < offs_num (length (offs (enum xs index key n mi ma) k))\n                     xs index key mi ma x;\n        x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"m \\<le> j\""], ["proof (state)\nthis:\n  m \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length (offs (enum xs index key n mi ma) k) \\<and>\n                i < x \\<and>\n                0 < offs_num (length (offs (enum xs index key n mi ma) k))\n                     xs index key mi ma x;\n        x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> m\n  m \\<le> j", "have \"offs ?ns k ! Min ?A \\<le> offs ?ns k ! j\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> m\n  m \\<le> j\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k ! j", "using C"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> m\n  m \\<le> j\n  j < n\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k ! j", "by (rule_tac offs_mono, simp_all add: enum_length)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k ! j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length (offs (enum xs index key n mi ma) k) \\<and>\n                i < x \\<and>\n                0 < offs_num (length (offs (enum xs index key n mi ma) k))\n                     xs index key mi ma x;\n        x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"offs_next (offs ?ns k) (length xs + k) xs index key mi ma i \\<le>\n      offs ?ns k ! j\""], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k ! j\n\ngoal (1 subgoal):\n 1. offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n    \\<le> offs (enum xs index key n mi ma) k ! j", "using F"], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k ! j\n  m \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n    \\<le> offs (enum xs index key n mi ma) k ! j", "by (simp only: offs_next_def split: if_split, rule_tac conjI,\n       blast, simp)"], ["proof (state)\nthis:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma i\n  \\<le> offs (enum xs index key n mi ma) k ! j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length (offs (enum xs index key n mi ma) k) \\<and>\n                i < x \\<and>\n                0 < offs_num (length (offs (enum xs index key n mi ma) k))\n                     xs index key mi ma x;\n        x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma i\n  \\<le> offs (enum xs index key n mi ma) k ! j\n\ngoal (1 subgoal):\n 1. False", "using E"], ["proof (prove)\nusing this:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma i\n  \\<le> offs (enum xs index key n mi ma) k ! j\n  offs (enum xs index key n mi ma) k ! j\n  < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j\n    < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i \\<Longrightarrow>\n    False", "hence \"offs ?ns k ! j <\n    offs_next (offs ?ns k) (length xs + k) xs index key mi ma j\""], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j\n    < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma j", "using E"], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma j\n  offs (enum xs index key n mi ma) k ! j\n  < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j\n    < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma j", "by (simp only: offs_next_def)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! j\n  < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma j\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j\n    < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! j\n  < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma j\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j\n    < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i \\<Longrightarrow>\n    False", "have \"offs_num n xs index key mi ma j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma j = 0", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < offs_num n xs index key mi ma j \\<Longrightarrow> False", "assume \"0 < offs_num n xs index key mi ma j\""], ["proof (state)\nthis:\n  0 < offs_num n xs index key mi ma j\n\ngoal (1 subgoal):\n 1. 0 < offs_num n xs index key mi ma j \\<Longrightarrow> False", "hence \"j \\<in> offs_set_next (offs ?ns k) xs index key mi ma i\"\n      (is \"_ \\<in> ?A\")"], ["proof (prove)\nusing this:\n  0 < offs_num n xs index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n             mi ma i", "using B and C"], ["proof (prove)\nusing this:\n  0 < offs_num n xs index key mi ma j\n  i < j\n  j < n\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n             mi ma i", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num n xs index key mi ma j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num n xs index key mi ma j \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "have \"Min ?A \\<le> j\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> j", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> j\n\ngoal (1 subgoal):\n 1. 0 < offs_num n xs index key mi ma j \\<Longrightarrow> False", "hence \"offs ?ns k ! Min ?A \\<le> offs ?ns k ! j\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> j\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k ! j", "using C"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> j\n  j < n\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k ! j", "by (erule_tac offs_mono, simp add: enum_length)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k ! j\n\ngoal (1 subgoal):\n 1. 0 < offs_num n xs index key mi ma j \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k ! j", "have \"offs_next (offs ?ns k) (length xs + k) xs index key mi ma i \\<le>\n      offs ?ns k ! j\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k ! j\n\ngoal (1 subgoal):\n 1. offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n    \\<le> offs (enum xs index key n mi ma) k ! j", "by (simp only: offs_next_def split: if_split, rule_tac conjI, blast, simp)"], ["proof (state)\nthis:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma i\n  \\<le> offs (enum xs index key n mi ma) k ! j\n\ngoal (1 subgoal):\n 1. 0 < offs_num n xs index key mi ma j \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma i\n  \\<le> offs (enum xs index key n mi ma) k ! j\n\ngoal (1 subgoal):\n 1. False", "using E"], ["proof (prove)\nusing this:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma i\n  \\<le> offs (enum xs index key n mi ma) k ! j\n  offs (enum xs index key n mi ma) k ! j\n  < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_num n xs index key mi ma j = 0\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j\n    < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i \\<Longrightarrow>\n    False", "hence \"offs ?ns k ! j =\n    offs_next (offs ?ns k) (length xs + k) xs index key mi ma j\""], ["proof (prove)\nusing this:\n  offs_num n xs index key mi ma j = 0\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j =\n    offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma j", "using A and C and D"], ["proof (prove)\nusing this:\n  offs_num n xs index key mi ma j = 0\n  index_less index key\n  j < n\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j =\n    offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma j", "by (rule_tac offs_enum_zero, simp_all)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! j =\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma j\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! j\n    < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) k ! j\n  < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma j\n  offs (enum xs index key n mi ma) k ! j =\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma j", "show False"], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k ! j\n  < offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma j\n  offs (enum xs index key n mi ma) k ! j =\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_pred_ub_less:\n \"\\<lbrakk>offs_pred ns ub xs index key mi ma; i < length ns;\n   0 < offs_num (length ns) xs index key mi ma i\\<rbrakk> \\<Longrightarrow>\n     ns ! i < ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_pred ns ub xs index key mi ma; i < length ns;\n     0 < offs_num (length ns) xs index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> ns ! i < ub", "by (drule offs_pred_ub, assumption+, simp)"], ["", "lemma fill_count_none [rule_format]:\n  assumes A: \"index_less index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    length xs \\<le> ub \\<longrightarrow>\n      count (mset (fill xs ns index key ub mi ma)) None = ub - length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    length xs \\<le> ub \\<longrightarrow>\n    count (mset (fill xs ns index key ub mi ma)) None = ub - length xs", "using A"], ["proof (prove)\nusing this:\n  index_less index key\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    length xs \\<le> ub \\<longrightarrow>\n    count (mset (fill xs ns index key ub mi ma)) None = ub - length xs", "proof (induction xs arbitrary: ns, simp_all add: replicate_count Let_def,\n (rule_tac impI)+, (erule_tac conjE)+, subst mset_update, simp add: fill_length,\n erule_tac offs_pred_ub_less, simp_all add: index_less_def offs_num_cons del:\n not_None_eq, subst conj_commute, rule_tac conjI, rule_tac [!] impI, rotate_tac,\n rotate_tac, erule_tac contrapos_np, rule_tac fill_index_none, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "fix x xs and ns :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "let ?i = \"index key x (length ns) mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "let ?ns' = \"ns[?i := Suc (ns ! ?i)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "assume \"\\<And>ns. ns \\<noteq> [] \\<longrightarrow> offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    count (mset (fill xs ns index key ub mi ma)) None = ub - length xs\""], ["proof (state)\nthis:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  count (mset (fill xs ?ns index key ub mi ma)) None = ub - length xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "moreover"], ["proof (state)\nthis:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  count (mset (fill xs ?ns index key ub mi ma)) None = ub - length xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "assume B: \"ns \\<noteq> []\""], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "moreover"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "assume\n   \"offs_pred ns ub (x # xs) index key mi ma\" and\n   \"mi \\<le> key x\" and\n   \"key x \\<le> ma\""], ["proof (state)\nthis:\n  offs_pred ns ub (x # xs) index key mi ma\n  mi \\<le> key x\n  key x \\<le> ma\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "hence \"offs_pred ?ns' ub xs index key mi ma\""], ["proof (prove)\nusing this:\n  offs_pred ns ub (x # xs) index key mi ma\n  mi \\<le> key x\n  key x \\<le> ma\n\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma", "using A and B"], ["proof (prove)\nusing this:\n  offs_pred ns ub (x # xs) index key mi ma\n  mi \\<le> key x\n  key x \\<le> ma\n  index_less index key\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma", "by (rule_tac offs_pred_cons, simp_all add: index_less_def)"], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (fill xs ns index key ub mi ma)) None =\n                   ub - length xs;\n        \\<forall>x n mi ma.\n           mi \\<le> key x \\<and> key x \\<le> ma \\<longrightarrow>\n           0 < n \\<longrightarrow> index key x n mi ma < n;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n        fill xs\n         (ns[index key a (length ns) mi ma :=\n               Suc (ns ! index key a (length ns) mi ma)])\n         index key ub mi ma !\n        (ns ! index key a (length ns) mi ma) =\n        None;\n        index_less index key\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            (fill xs\n                              (ns[index key a (length ns) mi ma :=\n                                    Suc (ns !\n   index key a (length ns) mi ma)])\n                              index key ub mi ma))\n                          None -\n                         Suc 0 =\n                         ub - Suc (length xs)", "ultimately"], ["proof (chain)\npicking this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  count (mset (fill xs ?ns index key ub mi ma)) None = ub - length xs\n  ns \\<noteq> []\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma", "show \"count (mset (fill xs ?ns' index key ub mi ma)) None -\n    Suc 0 = ub - Suc (length xs)\""], ["proof (prove)\nusing this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  count (mset (fill xs ?ns index key ub mi ma)) None = ub - length xs\n  ns \\<noteq> []\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (fill xs\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         index key ub mi ma))\n     None -\n    Suc 0 =\n    ub - Suc (length xs)", "by simp"], ["proof (state)\nthis:\n  count\n   (mset\n     (fill xs\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       index key ub mi ma))\n   None -\n  Suc 0 =\n  ub - Suc (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fill_offs_enum_count_none [rule_format]:\n \"\\<lbrakk>index_less index key; \\<forall>x \\<in> set xs. key x \\<in> {mi..ma}; 0 < n\\<rbrakk> \\<Longrightarrow>\n    count (mset (fill xs (offs (enum xs index key n mi ma) 0)\n      index key (length xs) mi ma)) None = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}; 0 < n\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (fill xs (offs (enum xs index key n mi ma) 0) index\n                           key (length xs) mi ma))\n                       None =\n                      0", "by (subst fill_count_none, simp_all, simp only: length_greater_0_conv [symmetric]\n offs_length enum_length, insert offs_enum_pred [of index key xs mi ma n 0], simp)"], ["", "lemma fill_index [rule_format]:\n  assumes A: \"index_less index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    i < length ns \\<longrightarrow>\n    0 < offs_num (length ns) xs index key mi ma i \\<longrightarrow>\n    j \\<in> {ns ! i..<offs_next ns ub xs index key mi ma i} \\<longrightarrow>\n    fill xs ns index key ub mi ma ! j = Some x \\<longrightarrow>\n      index key x (length ns) mi ma = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    i < length ns \\<longrightarrow>\n    0 < offs_num (length ns) xs index key mi ma i \\<longrightarrow>\n    j \\<in> {ns !\n             i..<offs_next ns ub xs index key mi ma i} \\<longrightarrow>\n    fill xs ns index key ub mi ma ! j = Some x \\<longrightarrow>\n    index key x (length ns) mi ma = i", "proof (induction xs arbitrary: ns, simp add: offs_num_def, simp add: Let_def,\n (rule impI)+, (erule conjE)+, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "fix y xs and ns :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "let ?i = \"index key x (length ns) mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "let ?i' = \"index key y (length ns) mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "let ?ns' = \"ns[?i' := Suc (ns ! ?i')]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "let ?P = \"\\<lambda>ns.\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    i < length ns \\<longrightarrow>\n    0 < offs_num (length ns) xs index key mi ma i \\<longrightarrow>\n    ns ! i \\<le> j \\<and> j < offs_next ns ub xs index key mi ma i \\<longrightarrow>\n    fill xs ns index key ub mi ma ! j = Some x \\<longrightarrow>\n      index key x (length ns) mi ma = i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "assume\n    B: \"\\<forall>x \\<in> set xs. mi \\<le> key x \\<and> key x \\<le> ma\" and\n    C: \"mi \\<le> key y\" and\n    D: \"key y \\<le> ma\" and\n    E: \"offs_pred ns ub (y # xs) index key mi ma\" and\n    F: \"i < length ns\" and\n    G: \"0 < offs_num (length ns) (y # xs) index key mi ma i\" and\n    H: \"ns ! i \\<le> j\" and\n    I: \"j < offs_next ns ub (y # xs) index key mi ma i\" and\n    J: \"\\<And>ns. ?P ns\" and\n    K: \"(fill xs ?ns' index key ub mi ma)[ns ! ?i' := Some y] ! j = Some x\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  mi \\<le> key y\n  key y \\<le> ma\n  offs_pred ns ub (y # xs) index key mi ma\n  i < length ns\n  0 < offs_num (length ns) (y # xs) index key mi ma i\n  ns ! i \\<le> j\n  j < offs_next ns ub (y # xs) index key mi ma i\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  i < length ?ns \\<longrightarrow>\n  0 < offs_num (length ?ns) xs index key mi ma i \\<longrightarrow>\n  ?ns ! i \\<le> j \\<and>\n  j < offs_next ?ns ub xs index key mi ma i \\<longrightarrow>\n  fill xs ?ns index key ub mi ma ! j = Some x \\<longrightarrow>\n  index key x (length ?ns) mi ma = i\n  (fill xs\n    (ns[index key y (length ns) mi ma :=\n          Suc (ns ! index key y (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key y (length ns) mi ma := Some y] ! j =\n  Some x\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "have \"0 < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length ns", "using F"], ["proof (prove)\nusing this:\n  i < length ns\n\ngoal (1 subgoal):\n 1. 0 < length ns", "by arith"], ["proof (state)\nthis:\n  0 < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "hence L: \"?i' < length ns\""], ["proof (prove)\nusing this:\n  0 < length ns\n\ngoal (1 subgoal):\n 1. index key y (length ns) mi ma < length ns", "using A and C and D"], ["proof (prove)\nusing this:\n  0 < length ns\n  index_less index key\n  mi \\<le> key y\n  key y \\<le> ma\n\ngoal (1 subgoal):\n 1. index key y (length ns) mi ma < length ns", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key y (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "hence \"ns ! ?i' + offs_num (length ns) (y # xs) index key mi ma ?i' \\<le> ub\""], ["proof (prove)\nusing this:\n  index key y (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. ns ! index key y (length ns) mi ma +\n    offs_num (length ns) (y # xs) index key mi ma\n     (index key y (length ns) mi ma)\n    \\<le> ub", "by (rule_tac offs_pred_ub [OF E], simp_all add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key y (length ns) mi ma +\n  offs_num (length ns) (y # xs) index key mi ma\n   (index key y (length ns) mi ma)\n  \\<le> ub\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "hence \"ns ! ?i' < ub\""], ["proof (prove)\nusing this:\n  ns ! index key y (length ns) mi ma +\n  offs_num (length ns) (y # xs) index key mi ma\n   (index key y (length ns) mi ma)\n  \\<le> ub\n\ngoal (1 subgoal):\n 1. ns ! index key y (length ns) mi ma < ub", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key y (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   i < length ns \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        i \\<longrightarrow>\n                   ns ! i \\<le> j \\<and>\n                   j < offs_next ns ub xs index key mi ma\n                        i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! j =\n                   Some x \\<longrightarrow>\n                   index key x (length ns) mi ma = i;\n        offs_pred ns ub (a # xs) index key mi ma; i < length ns;\n        0 < offs_num (length ns) (a # xs) index key mi ma i;\n        (fill xs\n          (ns[index key a (length ns) mi ma :=\n                Suc (ns ! index key a (length ns) mi ma)])\n          index key ub mi ma)\n        [ns ! index key a (length ns) mi ma := Some a] ! j =\n        Some x;\n        mi \\<le> key a; ns ! i \\<le> j;\n        j < offs_next ns ub (a # xs) index key mi ma i; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> index key x (length ns) mi ma = i", "with K"], ["proof (chain)\npicking this:\n  (fill xs\n    (ns[index key y (length ns) mi ma :=\n          Suc (ns ! index key y (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key y (length ns) mi ma := Some y] ! j =\n  Some x\n  ns ! index key y (length ns) mi ma < ub", "show \"?i = i\""], ["proof (prove)\nusing this:\n  (fill xs\n    (ns[index key y (length ns) mi ma :=\n          Suc (ns ! index key y (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key y (length ns) mi ma := Some y] ! j =\n  Some x\n  ns ! index key y (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma = i", "proof (cases \"j = ns ! ?i'\", simp, subst (asm) nth_list_update_eq, simp_all\n   add: fill_length)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = x; j = ns ! index key x (length ns) mi ma;\n     ns ! index key x (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i\n 2. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "assume\n      M: \"j = ns ! ?i\" and\n      N: \"y = x\""], ["proof (state)\nthis:\n  j = ns ! index key x (length ns) mi ma\n  y = x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = x; j = ns ! index key x (length ns) mi ma;\n     ns ! index key x (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i\n 2. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma = i", "proof (rule ccontr, erule neqE)"], ["proof (state)\ngoal (2 subgoals):\n 1. index key x (length ns) mi ma < i \\<Longrightarrow> False\n 2. i < index key x (length ns) mi ma \\<Longrightarrow> False", "assume \"?i < i\""], ["proof (state)\nthis:\n  index key x (length ns) mi ma < i\n\ngoal (2 subgoals):\n 1. index key x (length ns) mi ma < i \\<Longrightarrow> False\n 2. i < index key x (length ns) mi ma \\<Longrightarrow> False", "hence \"ns ! ?i + offs_num (length ns) (y # xs) index key mi ma ?i \\<le> ns ! i\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < i\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma +\n    offs_num (length ns) (y # xs) index key mi ma\n     (index key x (length ns) mi ma)\n    \\<le> ns ! i", "using F and G and N"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < i\n  i < length ns\n  0 < offs_num (length ns) (y # xs) index key mi ma i\n  y = x\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma +\n    offs_num (length ns) (y # xs) index key mi ma\n     (index key x (length ns) mi ma)\n    \\<le> ns ! i", "by (rule_tac offs_pred_asc [OF E], simp_all\n         add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (y # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ns ! i\n\ngoal (2 subgoals):\n 1. index key x (length ns) mi ma < i \\<Longrightarrow> False\n 2. i < index key x (length ns) mi ma \\<Longrightarrow> False", "hence \"j < ns ! i\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (y # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ns ! i\n\ngoal (1 subgoal):\n 1. j < ns ! i", "using M and N"], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (y # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ns ! i\n  j = ns ! index key x (length ns) mi ma\n  y = x\n\ngoal (1 subgoal):\n 1. j < ns ! i", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  j < ns ! i\n\ngoal (2 subgoals):\n 1. index key x (length ns) mi ma < i \\<Longrightarrow> False\n 2. i < index key x (length ns) mi ma \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  j < ns ! i\n\ngoal (1 subgoal):\n 1. False", "using H"], ["proof (prove)\nusing this:\n  j < ns ! i\n  ns ! i \\<le> j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "let ?A = \"offs_set_next ns (y # xs) index key mi ma i\""], ["proof (state)\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "assume \"i < ?i\""], ["proof (state)\nthis:\n  i < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "hence O: \"?i \\<in> ?A\""], ["proof (prove)\nusing this:\n  i < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma\n    \\<in> offs_set_next ns (y # xs) index key mi ma i", "using N and L"], ["proof (prove)\nusing this:\n  i < index key x (length ns) mi ma\n  y = x\n  index key y (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma\n    \\<in> offs_set_next ns (y # xs) index key mi ma i", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (y # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "hence P: \"Min ?A \\<in> ?A\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (y # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (y # xs) index key mi ma i)\n    \\<in> offs_set_next ns (y # xs) index key mi ma i", "by (rule_tac Min_in, simp, blast)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  \\<in> offs_set_next ns (y # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "have \"Min ?A \\<le> ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (y # xs) index key mi ma i)\n    \\<le> index key x (length ns) mi ma", "using O"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (y # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (y # xs) index key mi ma i)\n    \\<le> index key x (length ns) mi ma", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  \\<le> index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  \\<le> index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "have \"?A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_set_next ns (y # xs) index key mi ma i \\<noteq> {}", "using O"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (y # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_set_next ns (y # xs) index key mi ma i \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  offs_set_next ns (y # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  \\<le> index key x (length ns) mi ma\n  offs_set_next ns (y # xs) index key mi ma i \\<noteq> {}", "have \"offs_next ns ub (y # xs) index key mi ma i \\<le> j\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  \\<le> index key x (length ns) mi ma\n  offs_set_next ns (y # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. offs_next ns ub (y # xs) index key mi ma i \\<le> j", "using M"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  \\<le> index key x (length ns) mi ma\n  offs_set_next ns (y # xs) index key mi ma i \\<noteq> {}\n  j = ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. offs_next ns ub (y # xs) index key mi ma i \\<le> j", "proof (simp only: offs_next_def, simp, subst (asm) le_less,\n       erule_tac disjE, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x>i.\n                x < length ns \\<and>\n                0 < offs_num (length ns) (y # xs) index key mi ma x;\n     Min (offs_set_next ns (y # xs) index key mi ma i)\n     < index key x (length ns) mi ma;\n     j = ns ! index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> ns ! Min (offs_set_next ns (y # xs) index key mi ma i)\n                      \\<le> ns ! index key x (length ns) mi ma", "assume \"Min ?A < ?i\""], ["proof (state)\nthis:\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x>i.\n                x < length ns \\<and>\n                0 < offs_num (length ns) (y # xs) index key mi ma x;\n     Min (offs_set_next ns (y # xs) index key mi ma i)\n     < index key x (length ns) mi ma;\n     j = ns ! index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> ns ! Min (offs_set_next ns (y # xs) index key mi ma i)\n                      \\<le> ns ! index key x (length ns) mi ma", "hence \"ns ! Min ?A + offs_num (length ns) (y # xs) index key mi ma\n          (Min ?A) \\<le> ns ! ?i\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (y # xs) index key mi ma i) +\n    offs_num (length ns) (y # xs) index key mi ma\n     (Min (offs_set_next ns (y # xs) index key mi ma i))\n    \\<le> ns ! index key x (length ns) mi ma", "using O and P"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  < index key x (length ns) mi ma\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (y # xs) index key mi ma i\n  Min (offs_set_next ns (y # xs) index key mi ma i)\n  \\<in> offs_set_next ns (y # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (y # xs) index key mi ma i) +\n    offs_num (length ns) (y # xs) index key mi ma\n     (Min (offs_set_next ns (y # xs) index key mi ma i))\n    \\<le> ns ! index key x (length ns) mi ma", "by (rule_tac offs_pred_asc [OF E], simp_all)"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns (y # xs) index key mi ma i) +\n  offs_num (length ns) (y # xs) index key mi ma\n   (Min (offs_set_next ns (y # xs) index key mi ma i))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x>i.\n                x < length ns \\<and>\n                0 < offs_num (length ns) (y # xs) index key mi ma x;\n     Min (offs_set_next ns (y # xs) index key mi ma i)\n     < index key x (length ns) mi ma;\n     j = ns ! index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> ns ! Min (offs_set_next ns (y # xs) index key mi ma i)\n                      \\<le> ns ! index key x (length ns) mi ma", "thus \"ns ! Min ?A \\<le> ns ! ?i\""], ["proof (prove)\nusing this:\n  ns ! Min (offs_set_next ns (y # xs) index key mi ma i) +\n  offs_num (length ns) (y # xs) index key mi ma\n   (Min (offs_set_next ns (y # xs) index key mi ma i))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (y # xs) index key mi ma i)\n    \\<le> ns ! index key x (length ns) mi ma", "by simp"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns (y # xs) index key mi ma i)\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_next ns ub (y # xs) index key mi ma i \\<le> j\n\ngoal (1 subgoal):\n 1. i < index key x (length ns) mi ma \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  offs_next ns ub (y # xs) index key mi ma i \\<le> j\n\ngoal (1 subgoal):\n 1. False", "using I"], ["proof (prove)\nusing this:\n  offs_next ns ub (y # xs) index key mi ma i \\<le> j\n  j < offs_next ns ub (y # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "assume\n      M: \"j \\<noteq> ns ! ?i'\" and\n      N: \"fill xs ?ns' index key ub mi ma ! j = Some x\""], ["proof (state)\nthis:\n  j \\<noteq> ns ! index key y (length ns) mi ma\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  j =\n  Some x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "have \"?P ?ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     ub xs index key mi ma \\<longrightarrow>\n    i < length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]) \\<longrightarrow>\n    0 < offs_num\n         (length\n           (ns[index key y (length ns) mi ma :=\n                 Suc (ns ! index key y (length ns) mi ma)]))\n         xs index key mi ma i \\<longrightarrow>\n    ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)] !\n    i\n    \\<le> j \\<and>\n    j < offs_next\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         ub xs index key mi ma i \\<longrightarrow>\n    fill xs\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     index key ub mi ma !\n    j =\n    Some x \\<longrightarrow>\n    index key x\n     (length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)]))\n     mi ma =\n    i", "using J"], ["proof (prove)\nusing this:\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  i < length ?ns \\<longrightarrow>\n  0 < offs_num (length ?ns) xs index key mi ma i \\<longrightarrow>\n  ?ns ! i \\<le> j \\<and>\n  j < offs_next ?ns ub xs index key mi ma i \\<longrightarrow>\n  fill xs ?ns index key ub mi ma ! j = Some x \\<longrightarrow>\n  index key x (length ?ns) mi ma = i\n\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     ub xs index key mi ma \\<longrightarrow>\n    i < length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]) \\<longrightarrow>\n    0 < offs_num\n         (length\n           (ns[index key y (length ns) mi ma :=\n                 Suc (ns ! index key y (length ns) mi ma)]))\n         xs index key mi ma i \\<longrightarrow>\n    ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)] !\n    i\n    \\<le> j \\<and>\n    j < offs_next\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         ub xs index key mi ma i \\<longrightarrow>\n    fill xs\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     index key ub mi ma !\n    j =\n    Some x \\<longrightarrow>\n    index key x\n     (length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)]))\n     mi ma =\n    i", "."], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma \\<longrightarrow>\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)]) \\<longrightarrow>\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i \\<longrightarrow>\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j \\<and>\n  j < offs_next\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n       ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  j =\n  Some x \\<longrightarrow>\n  index key x\n   (length\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)]))\n   mi ma =\n  i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "moreover"], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma \\<longrightarrow>\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)]) \\<longrightarrow>\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i \\<longrightarrow>\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j \\<and>\n  j < offs_next\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n       ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  j =\n  Some x \\<longrightarrow>\n  index key x\n   (length\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)]))\n   mi ma =\n  i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "from D and F"], ["proof (chain)\npicking this:\n  key y \\<le> ma\n  i < length ns", "have \"offs_pred ?ns' ub xs index key mi ma\""], ["proof (prove)\nusing this:\n  key y \\<le> ma\n  i < length ns\n\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     ub xs index key mi ma", "using L"], ["proof (prove)\nusing this:\n  key y \\<le> ma\n  i < length ns\n  index key y (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     ub xs index key mi ma", "by (rule_tac offs_pred_cons [OF E], simp)"], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "moreover"], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "have \"i < length ?ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])", "using F"], ["proof (prove)\nusing this:\n  i < length ns\n\ngoal (1 subgoal):\n 1. i < length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])", "by simp"], ["proof (state)\nthis:\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "moreover"], ["proof (state)\nthis:\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "have \"0 < offs_num (length ?ns') xs index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num\n         (length\n           (ns[index key y (length ns) mi ma :=\n                 Suc (ns ! index key y (length ns) mi ma)]))\n         xs index key mi ma i", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow> False", "assume O: \"offs_num (length ns) xs index key mi ma i = 0\""], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow> False", "hence P: \"offs_num (length ns) (y # xs) index key mi ma i = Suc 0\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) (y # xs) index key mi ma i = Suc 0", "using G"], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma i = 0\n  0 < offs_num (length ns) (y # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_num (length ns) (y # xs) index key mi ma i = Suc 0", "by (simp add: offs_num_cons split: if_split_asm)"], ["proof (state)\nthis:\n  offs_num (length ns) (y # xs) index key mi ma i = Suc 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow> False", "hence \"i = ?i'\""], ["proof (prove)\nusing this:\n  offs_num (length ns) (y # xs) index key mi ma i = Suc 0\n\ngoal (1 subgoal):\n 1. i = index key y (length ns) mi ma", "using O"], ["proof (prove)\nusing this:\n  offs_num (length ns) (y # xs) index key mi ma i = Suc 0\n  offs_num (length ns) xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. i = index key y (length ns) mi ma", "by (simp add: offs_num_cons split: if_split_asm)"], ["proof (state)\nthis:\n  i = index key y (length ns) mi ma\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow> False", "hence \"ns ! i < j\""], ["proof (prove)\nusing this:\n  i = index key y (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! i < j", "using H and M"], ["proof (prove)\nusing this:\n  i = index key y (length ns) mi ma\n  ns ! i \\<le> j\n  j \\<noteq> ns ! index key y (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! i < j", "by simp"], ["proof (state)\nthis:\n  ns ! i < j\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow> False", "hence \"ns ! i + offs_num (length ns) (y # xs) index key mi ma i \\<le> j\""], ["proof (prove)\nusing this:\n  ns ! i < j\n\ngoal (1 subgoal):\n 1. ns ! i + offs_num (length ns) (y # xs) index key mi ma i \\<le> j", "using P"], ["proof (prove)\nusing this:\n  ns ! i < j\n  offs_num (length ns) (y # xs) index key mi ma i = Suc 0\n\ngoal (1 subgoal):\n 1. ns ! i + offs_num (length ns) (y # xs) index key mi ma i \\<le> j", "by simp"], ["proof (state)\nthis:\n  ns ! i + offs_num (length ns) (y # xs) index key mi ma i \\<le> j\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow> False", "with F and G and I"], ["proof (chain)\npicking this:\n  i < length ns\n  0 < offs_num (length ns) (y # xs) index key mi ma i\n  j < offs_next ns ub (y # xs) index key mi ma i\n  ns ! i + offs_num (length ns) (y # xs) index key mi ma i \\<le> j", "have \"offs_none ns ub (y # xs) index key mi ma j\""], ["proof (prove)\nusing this:\n  i < length ns\n  0 < offs_num (length ns) (y # xs) index key mi ma i\n  j < offs_next ns ub (y # xs) index key mi ma i\n  ns ! i + offs_num (length ns) (y # xs) index key mi ma i \\<le> j\n\ngoal (1 subgoal):\n 1. offs_none ns ub (y # xs) index key mi ma j", "by (simp add: offs_none_def, rule_tac disjI1, rule_tac exI\n         [where x = i], simp)"], ["proof (state)\nthis:\n  offs_none ns ub (y # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow> False", "with B and C and D and E and F"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  mi \\<le> key y\n  key y \\<le> ma\n  offs_pred ns ub (y # xs) index key mi ma\n  i < length ns\n  offs_none ns ub (y # xs) index key mi ma j", "have\n       \"fill (y # xs) ns index key ub mi ma ! j = None\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  mi \\<le> key y\n  key y \\<le> ma\n  offs_pred ns ub (y # xs) index key mi ma\n  i < length ns\n  offs_none ns ub (y # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. fill (y # xs) ns index key ub mi ma ! j = None", "by (rule_tac fill_none [OF A], simp_all, erule_tac disjE, simp_all, auto)"], ["proof (state)\nthis:\n  fill (y # xs) ns index key ub mi ma ! j = None\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  fill (y # xs) ns index key ub mi ma ! j = None\n\ngoal (1 subgoal):\n 1. False", "using K"], ["proof (prove)\nusing this:\n  fill (y # xs) ns index key ub mi ma ! j = None\n  (fill xs\n    (ns[index key y (length ns) mi ma :=\n          Suc (ns ! index key y (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key y (length ns) mi ma := Some y] ! j =\n  Some x\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "moreover"], ["proof (state)\nthis:\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "have \"?ns' ! i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)] !\n    i\n    \\<le> j", "using F and H and M"], ["proof (prove)\nusing this:\n  i < length ns\n  ns ! i \\<le> j\n  j \\<noteq> ns ! index key y (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)] !\n    i\n    \\<le> j", "by (cases \"?i' = i\", simp_all)"], ["proof (state)\nthis:\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "moreover"], ["proof (state)\nthis:\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "have \"offs_next ns ub (y # xs) index key mi ma i \\<le>\n      offs_next ?ns' ub xs index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub (y # xs) index key mi ma i\n    \\<le> offs_next\n           (ns[index key y (length ns) mi ma :=\n                 Suc (ns ! index key y (length ns) mi ma)])\n           ub xs index key mi ma i", "using G and L"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (y # xs) index key mi ma i\n  index key y (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_next ns ub (y # xs) index key mi ma i\n    \\<le> offs_next\n           (ns[index key y (length ns) mi ma :=\n                 Suc (ns ! index key y (length ns) mi ma)])\n           ub xs index key mi ma i", "by (rule_tac offs_pred_next_cons [OF E], simp)"], ["proof (state)\nthis:\n  offs_next ns ub (y # xs) index key mi ma i\n  \\<le> offs_next\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         ub xs index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "hence \"j < offs_next ?ns' ub xs index key mi ma i\""], ["proof (prove)\nusing this:\n  offs_next ns ub (y # xs) index key mi ma i\n  \\<le> offs_next\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         ub xs index key mi ma i\n\ngoal (1 subgoal):\n 1. j < offs_next\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         ub xs index key mi ma i", "using I"], ["proof (prove)\nusing this:\n  offs_next ns ub (y # xs) index key mi ma i\n  \\<le> offs_next\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         ub xs index key mi ma i\n  j < offs_next ns ub (y # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. j < offs_next\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         ub xs index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j < offs_next\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n       ub xs index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> ns ! index key y (length ns) mi ma;\n     fill xs\n      (ns[index key y (length ns) mi ma :=\n            Suc (ns ! index key y (length ns) mi ma)])\n      index key ub mi ma !\n     j =\n     Some x;\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> index key x (length ns) mi ma = i", "ultimately"], ["proof (chain)\npicking this:\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma \\<longrightarrow>\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)]) \\<longrightarrow>\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i \\<longrightarrow>\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j \\<and>\n  j < offs_next\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n       ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  j =\n  Some x \\<longrightarrow>\n  index key x\n   (length\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)]))\n   mi ma =\n  i\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j\n  j < offs_next\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n       ub xs index key mi ma i", "show ?thesis"], ["proof (prove)\nusing this:\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma \\<longrightarrow>\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)]) \\<longrightarrow>\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i \\<longrightarrow>\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j \\<and>\n  j < offs_next\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n       ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  j =\n  Some x \\<longrightarrow>\n  index key x\n   (length\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)]))\n   mi ma =\n  i\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j\n  j < offs_next\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n       ub xs index key mi ma i\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma = i", "using N"], ["proof (prove)\nusing this:\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma \\<longrightarrow>\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)]) \\<longrightarrow>\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i \\<longrightarrow>\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j \\<and>\n  j < offs_next\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n       ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  j =\n  Some x \\<longrightarrow>\n  index key x\n   (length\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)]))\n   mi ma =\n  i\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma\n  i < length\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n  0 < offs_num\n       (length\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)]))\n       xs index key mi ma i\n  ns[index key y (length ns) mi ma :=\n       Suc (ns ! index key y (length ns) mi ma)] !\n  i\n  \\<le> j\n  j < offs_next\n       (ns[index key y (length ns) mi ma :=\n             Suc (ns ! index key y (length ns) mi ma)])\n       ub xs index key mi ma i\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  j =\n  Some x\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma = i", "by simp"], ["proof (state)\nthis:\n  index key x (length ns) mi ma = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index key x (length ns) mi ma = i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fill_offs_enum_index [rule_format]:\n \"index_less index key \\<Longrightarrow>\n  \\<forall>x \\<in> set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n  i < n \\<Longrightarrow>\n  0 < offs_num n xs index key mi ma i \\<Longrightarrow>\n  j \\<in> {offs (enum xs index key n mi ma) 0 ! i..<\n    offs_next (offs (enum xs index key n mi ma) 0) (length xs)\n      xs index key mi ma i} \\<Longrightarrow>\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n    mi ma ! j = Some x \\<Longrightarrow>\n    index key x n mi ma = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}; i < n;\n     0 < offs_num n xs index key mi ma i;\n     j \\<in> {offs (enum xs index key n mi ma) 0 !\n              i..<offs_next (offs (enum xs index key n mi ma) 0) (length xs)\n                   xs index key mi ma i};\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     j =\n     Some x\\<rbrakk>\n    \\<Longrightarrow> index key x n mi ma = i", "by (insert fill_index [of index key xs mi ma \"offs (enum xs index key n mi ma) 0\"\n \"length xs\" i j x], insert offs_enum_pred [of index key xs mi ma n 0],\n simp add: offs_length enum_length)"], ["", "lemma fill_sort_inv [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_mono index key\" and\n    C: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"sort_inv key (u, enum xs index key n mi ma,\n    map the (fill xs (offs (enum xs index key n mi ma) 0)\n      index key (length xs) mi ma))\"\n  (is \"sort_inv _ (_, ?ns, _)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_inv key\n     (u, enum xs index key n mi ma,\n      map the\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma))", "proof (simp, (rule allI, rule impI)+, rule ballI, simp add: enum_length fill_length,\n erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "let ?A = \"{i. i < n \\<and> 0 < ?ns ! i}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "let ?B = \"{i. i < n \\<and> offs ?ns 0 ! i \\<le> j \\<and> 0 < offs_num n xs index key mi ma i}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "let ?C = \"{i. i < n \\<and> offs ?ns 0 ! i \\<le> k \\<and> 0 < offs_num n xs index key mi ma i}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "assume\n    D: \"i < n\" and\n    E: \"j < offs ?ns 0 ! i\" and\n    F: \"offs ?ns 0 ! i \\<le> k\" and\n    G: \"k < length xs\""], ["proof (state)\nthis:\n  i < n\n  j < offs (enum xs index key n mi ma) 0 ! i\n  offs (enum xs index key n mi ma) 0 ! i \\<le> k\n  k < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have H: \"\\<forall>i < length xs.\n    \\<exists>x. fill xs (offs ?ns 0) index key (length xs) mi ma ! i = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length xs.\n       \\<exists>x.\n          fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma !\n          i =\n          Some x", "proof (rule allI, rule impI, rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs;\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        None\\<rbrakk>\n       \\<Longrightarrow> False", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs;\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        None\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"fill xs (offs ?ns 0) index key (length xs) mi ma ! m = None\""], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  m =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs;\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        None\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  m =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs;\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        None\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"m < length xs\""], ["proof (state)\nthis:\n  m < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs;\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        None\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"fill xs (offs ?ns 0) index key (length xs) mi ma ! m\n      \\<in> set (fill xs (offs ?ns 0) index key (length xs) mi ma)\""], ["proof (prove)\nusing this:\n  m < length xs\n\ngoal (1 subgoal):\n 1. fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma !\n    m\n    \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma)", "by (rule_tac nth_mem, simp add: fill_length)"], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  m\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs;\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        None\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  m =\n  None\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  m\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)", "have \"None \\<in> set (fill xs (offs ?ns 0) index key (length xs) mi ma)\""], ["proof (prove)\nusing this:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  m =\n  None\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  m\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n\ngoal (1 subgoal):\n 1. None\n    \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma)", "by simp"], ["proof (state)\nthis:\n  None\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs;\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        None\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  None\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs;\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        None\\<rbrakk>\n       \\<Longrightarrow> False", "have\n     \"count (mset (fill xs (offs ?ns 0) index key (length xs) mi ma)) None = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count\n     (mset\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma))\n     None =\n    0", "using C and D"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  i < n\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma))\n     None =\n    0", "by (rule_tac fill_offs_enum_count_none [OF A], simp_all)"], ["proof (state)\nthis:\n  count\n   (mset\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma))\n   None =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs;\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        None\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  None\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n  count\n   (mset\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma))\n   None =\n  0", "show False"], ["proof (prove)\nusing this:\n  None\n  \\<in> set (fill xs (offs (enum xs index key n mi ma) 0) index key\n              (length xs) mi ma)\n  count\n   (mset\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma))\n   None =\n  0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length xs.\n     \\<exists>x.\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        Some x\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have \"\\<exists>y ys. xs = y # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y ys. xs = y # ys", "using G"], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>y ys. xs = y # ys", "by (rule_tac list.exhaust [of xs], simp_all)"], ["proof (state)\nthis:\n  \\<exists>y ys. xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "then"], ["proof (chain)\npicking this:\n  \\<exists>y ys. xs = y # ys", "obtain z and zs where I: \"xs = z # zs\""], ["proof (prove)\nusing this:\n  \\<exists>y ys. xs = y # ys\n\ngoal (1 subgoal):\n 1. (\\<And>z zs. xs = z # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = z # zs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"index key z n mi ma < n\""], ["proof (prove)\nusing this:\n  xs = z # zs\n\ngoal (1 subgoal):\n 1. index key z n mi ma < n", "using A and C and D"], ["proof (prove)\nusing this:\n  xs = z # zs\n  index_less index key\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  i < n\n\ngoal (1 subgoal):\n 1. index key z n mi ma < n", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key z n mi ma < n\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "moreover"], ["proof (state)\nthis:\n  index key z n mi ma < n\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "from this"], ["proof (chain)\npicking this:\n  index key z n mi ma < n", "have \"0 < ?ns ! index key z n mi ma\""], ["proof (prove)\nusing this:\n  index key z n mi ma < n\n\ngoal (1 subgoal):\n 1. 0 < enum xs index key n mi ma ! index key z n mi ma", "using I"], ["proof (prove)\nusing this:\n  index key z n mi ma < n\n  xs = z # zs\n\ngoal (1 subgoal):\n 1. 0 < enum xs index key n mi ma ! index key z n mi ma", "by (simp add: Let_def, subst nth_list_update_eq, simp_all add:\n     enum_length)"], ["proof (state)\nthis:\n  0 < enum xs index key n mi ma ! index key z n mi ma\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "ultimately"], ["proof (chain)\npicking this:\n  index key z n mi ma < n\n  0 < enum xs index key n mi ma ! index key z n mi ma", "have \"index key z n mi ma \\<in> ?A\""], ["proof (prove)\nusing this:\n  index key z n mi ma < n\n  0 < enum xs index key n mi ma ! index key z n mi ma\n\ngoal (1 subgoal):\n 1. index key z n mi ma\n    \\<in> {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}", "by simp"], ["proof (state)\nthis:\n  index key z n mi ma\n  \\<in> {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence J: \"Min ?A \\<in> ?A\""], ["proof (prove)\nusing this:\n  index key z n mi ma\n  \\<in> {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n\ngoal (1 subgoal):\n 1. Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n    \\<in> {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}", "by (rule_tac Min_in, simp, blast)"], ["proof (state)\nthis:\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  \\<in> {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"offs ?ns 0 ! 0 = offs ?ns 0 ! Min ?A\""], ["proof (prove)\nusing this:\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  \\<in> {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) 0 ! 0 =\n    offs (enum xs index key n mi ma) 0 !\n    Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}", "proof (cases \"Min ?A = 0\", simp_all, erule_tac offs_equal, simp_all add:\n   enum_length, rule_tac ccontr, erule_tac conjE, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i};\n        0 < enum xs index key n mi ma ! k;\n        Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n;\n        0 < enum xs index key n mi ma !\n            Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\\<rbrakk>\n       \\<Longrightarrow> False", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i};\n        0 < enum xs index key n mi ma ! k;\n        Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n;\n        0 < enum xs index key n mi ma !\n            Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"m < Min ?A\" and \"Min ?A < n\" and \"0 < ?ns ! m\""], ["proof (state)\nthis:\n  m < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n\n  0 < enum xs index key n mi ma ! m\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i};\n        0 < enum xs index key n mi ma ! k;\n        Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n;\n        0 < enum xs index key n mi ma !\n            Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  m < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n\n  0 < enum xs index key n mi ma ! m\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i};\n        0 < enum xs index key n mi ma ! k;\n        Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n;\n        0 < enum xs index key n mi ma !\n            Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\\<rbrakk>\n       \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  m < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n\n  0 < enum xs index key n mi ma ! m", "have \"Min ?A \\<le> m\""], ["proof (prove)\nusing this:\n  m < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n\n  0 < enum xs index key n mi ma ! m\n\ngoal (1 subgoal):\n 1. Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} \\<le> m", "by (rule_tac Min_le, simp_all)"], ["proof (state)\nthis:\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i};\n        0 < enum xs index key n mi ma ! k;\n        Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n;\n        0 < enum xs index key n mi ma !\n            Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  m < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n\n  0 < enum xs index key n mi ma ! m\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} \\<le> m", "show False"], ["proof (prove)\nusing this:\n  m < Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} < n\n  0 < enum xs index key n mi ma ! m\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} \\<le> m\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) 0 ! 0 =\n  offs (enum xs index key n mi ma) 0 !\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "moreover"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) 0 ! 0 =\n  offs (enum xs index key n mi ma) 0 !\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have \"\\<exists>m ms. ?ns = m # ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m ms. enum xs index key n mi ma = m # ms", "using D"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<exists>m ms. enum xs index key n mi ma = m # ms", "by (rule_tac list.exhaust [of ?ns], simp_all,\n     simp only: length_0_conv [symmetric] enum_length)"], ["proof (state)\nthis:\n  \\<exists>m ms. enum xs index key n mi ma = m # ms\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "then"], ["proof (chain)\npicking this:\n  \\<exists>m ms. enum xs index key n mi ma = m # ms", "obtain m and ms where \"?ns = m # ms\""], ["proof (prove)\nusing this:\n  \\<exists>m ms. enum xs index key n mi ma = m # ms\n\ngoal (1 subgoal):\n 1. (\\<And>m ms.\n        enum xs index key n mi ma = m # ms \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  enum xs index key n mi ma = m # ms\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "ultimately"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) 0 ! 0 =\n  offs (enum xs index key n mi ma) 0 !\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  enum xs index key n mi ma = m # ms", "have \"offs ?ns 0 ! Min ?A = 0\""], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) 0 ! 0 =\n  offs (enum xs index key n mi ma) 0 !\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  enum xs index key n mi ma = m # ms\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) 0 !\n    Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} =\n    0", "by simp"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) 0 !\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"Min ?A \\<in> ?B\""], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) 0 !\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} =\n  0\n\ngoal (1 subgoal):\n 1. Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n    \\<in> {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i}", "using J"], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) 0 !\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i} =\n  0\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  \\<in> {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n\ngoal (1 subgoal):\n 1. Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n    \\<in> {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i}", "by (simp, subst enum_offs_num [symmetric], simp_all)"], ["proof (state)\nthis:\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence K: \"Max ?B \\<in> ?B\""], ["proof (prove)\nusing this:\n  Min {i. i < n \\<and> 0 < enum xs index key n mi ma ! i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n    \\<in> {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i}", "by (rule_tac Max_in, simp, blast)"], ["proof (state)\nthis:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "moreover"], ["proof (state)\nthis:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have \"j < offs_next (offs ?ns 0) (length xs)\n    xs index key mi ma (Max ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n         key mi ma\n         (Max {i. i < n \\<and>\n                  offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                  0 < offs_num n xs index key mi ma i})", "proof (simp only: offs_next_def split: if_split, rule conjI, rule_tac [!] impI,\n   rule_tac [2] ccontr, simp_all only: not_less)"], ["proof (state)\ngoal (2 subgoals):\n 1. offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n     (Max {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i}) =\n    {} \\<Longrightarrow>\n    j < length xs\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> j\\<rbrakk>\n    \\<Longrightarrow> False", "show \"j < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length xs", "using E and F and G"], ["proof (prove)\nusing this:\n  j < offs (enum xs index key n mi ma) 0 ! i\n  offs (enum xs index key n mi ma) 0 ! i \\<le> k\n  k < length xs\n\ngoal (1 subgoal):\n 1. j < length xs", "by simp"], ["proof (state)\nthis:\n  j < length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> j\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> j\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"offs_set_next (offs ?ns 0) xs index key mi ma (Max ?B) \\<noteq> {}\"\n      (is \"?Z \\<noteq> _\")"], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n   (Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> j\\<rbrakk>\n    \\<Longrightarrow> False", "hence L: \"Min ?Z \\<in> ?Z\""], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n   (Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n          ma (Max {i. i < n \\<and>\n                      offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                      0 < offs_num n xs index key mi ma i}))\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i})", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                     0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> j\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                     0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> j\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"offs ?ns 0 ! Min ?Z \\<le> j\""], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) 0 !\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> j\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                     0 < offs_num n xs index key mi ma i})\n  offs (enum xs index key n mi ma) 0 !\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> j", "have \"Min ?Z \\<in> ?B\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                     0 < offs_num n xs index key mi ma i})\n  offs (enum xs index key n mi ma) 0 !\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n          ma (Max {i. i < n \\<and>\n                      offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                      0 < offs_num n xs index key mi ma i}))\n    \\<in> {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i}", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> j\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"Min ?Z \\<le> Max ?B\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n          ma (Max {i. i < n \\<and>\n                      offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                      0 < offs_num n xs index key mi ma i}))\n    \\<le> Max {i. i < n \\<and>\n                  offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                  0 < offs_num n xs index key mi ma i}", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> j\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. False", "using L"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i}\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                     0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "moreover"], ["proof (state)\nthis:\n  j < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have\n   \"\\<exists>x. fill xs (offs ?ns 0) index key (length xs) mi ma ! j = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n        ma !\n       j =\n       Some x", "using E and F and G and H"], ["proof (prove)\nusing this:\n  j < offs (enum xs index key n mi ma) 0 ! i\n  offs (enum xs index key n mi ma) 0 ! i \\<le> k\n  k < length xs\n  \\<forall>i<length xs.\n     \\<exists>x.\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        Some x\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n        ma !\n       j =\n       Some x", "by simp"], ["proof (state)\nthis:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     j =\n     Some x\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     j =\n     Some x", "obtain x where\n    L: \"fill xs (offs ?ns 0) index key (length xs) mi ma ! j = Some x\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     j =\n     Some x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        j =\n        Some x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  j =\n  Some x\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "ultimately"], ["proof (chain)\npicking this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n  j < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i})\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  j =\n  Some x", "have M: \"index key x n mi ma = Max ?B\""], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n  j < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i})\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  j =\n  Some x\n\ngoal (1 subgoal):\n 1. index key x n mi ma =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}", "using C"], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n  j < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i})\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  j =\n  Some x\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n\ngoal (1 subgoal):\n 1. index key x n mi ma =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}", "by (rule_tac fill_offs_enum_index [OF A], simp_all)"], ["proof (state)\nthis:\n  index key x n mi ma =\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have N: \"Max ?B \\<in> ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n    \\<in> {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n              0 < offs_num n xs index key mi ma i}", "using E and F and K"], ["proof (prove)\nusing this:\n  j < offs (enum xs index key n mi ma) 0 ! i\n  offs (enum xs index key n mi ma) 0 ! i \\<le> k\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n    \\<in> {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n              0 < offs_num n xs index key mi ma i}", "by simp"], ["proof (state)\nthis:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"Max ?C \\<in> ?C\""], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n    \\<in> {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n              0 < offs_num n xs index key mi ma i}", "by (rule_tac Max_in, simp, blast)"], ["proof (state)\nthis:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "moreover"], ["proof (state)\nthis:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have O: \"k < offs_next (offs ?ns 0) (length xs)\n    xs index key mi ma (Max ?C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n         key mi ma\n         (Max {i. i < n \\<and>\n                  offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                  0 < offs_num n xs index key mi ma i})", "proof (simp only: offs_next_def split: if_split, rule conjI, rule_tac [!] impI,\n   rule_tac [2] ccontr, simp_all only: not_less)"], ["proof (state)\ngoal (2 subgoals):\n 1. offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n     (Max {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n              0 < offs_num n xs index key mi ma i}) =\n    {} \\<Longrightarrow>\n    k < length xs\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> k\\<rbrakk>\n    \\<Longrightarrow> False", "show \"k < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length xs", "using G"], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. k < length xs", "."], ["proof (state)\nthis:\n  k < length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> k\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> k\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"offs_set_next (offs ?ns 0) xs index key mi ma (Max ?C) \\<noteq> {}\"\n      (is \"?Z \\<noteq> _\")"], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n   (Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> k\\<rbrakk>\n    \\<Longrightarrow> False", "hence P: \"Min ?Z \\<in> ?Z\""], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n   (Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n          ma (Max {i. i < n \\<and>\n                      offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                      0 < offs_num n xs index key mi ma i}))\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i})", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                     0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> k\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                     0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> k\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"offs ?ns 0 ! Min ?Z \\<le> k\""], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) 0 !\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> k\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                     0 < offs_num n xs index key mi ma i})\n  offs (enum xs index key n mi ma) 0 !\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> k", "have \"Min ?Z \\<in> ?C\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                     0 < offs_num n xs index key mi ma i})\n  offs (enum xs index key n mi ma) 0 !\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> k\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n          ma (Max {i. i < n \\<and>\n                      offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                      0 < offs_num n xs index key mi ma i}))\n    \\<in> {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n              0 < offs_num n xs index key mi ma i}", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> k\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"Min ?Z \\<le> Max ?C\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n          ma (Max {i. i < n \\<and>\n                      offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                      0 < offs_num n xs index key mi ma i}))\n    \\<le> Max {i. i < n \\<and>\n                  offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                  0 < offs_num n xs index key mi ma i}", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) 0) xs index key\n              mi ma\n              (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}) \\<noteq>\n             {};\n     offs (enum xs index key n mi ma) 0 !\n     Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n           ma (Max {i. i < n \\<and>\n                       offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                       0 < offs_num n xs index key mi ma i}))\n     \\<le> k\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. False", "using P"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<le> Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i}\n  Min (offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi ma\n        (Max {i. i < n \\<and>\n                 offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                 0 < offs_num n xs index key mi ma i}))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) 0) xs index key mi\n         ma (Max {i. i < n \\<and>\n                     offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                     0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "moreover"], ["proof (state)\nthis:\n  k < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have\n   \"\\<exists>x. fill xs (offs ?ns 0) index key (length xs) mi ma ! k = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n        ma !\n       k =\n       Some x", "using G and H"], ["proof (prove)\nusing this:\n  k < length xs\n  \\<forall>i<length xs.\n     \\<exists>x.\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        i =\n        Some x\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n        ma !\n       k =\n       Some x", "by simp"], ["proof (state)\nthis:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     k =\n     Some x\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     k =\n     Some x", "obtain y where\n    P: \"fill xs (offs ?ns 0) index key (length xs) mi ma ! k = Some y\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n      ma !\n     k =\n     Some x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma !\n        k =\n        Some y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  k =\n  Some y\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "ultimately"], ["proof (chain)\npicking this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n  k < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i})\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  k =\n  Some y", "have Q: \"index key y n mi ma = Max ?C\""], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n  k < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i})\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  k =\n  Some y\n\ngoal (1 subgoal):\n 1. index key y n mi ma =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}", "using C"], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n  k < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i})\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  k =\n  Some y\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n\ngoal (1 subgoal):\n 1. index key y n mi ma =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}", "by (rule_tac fill_offs_enum_index [OF A], simp_all)"], ["proof (state)\nthis:\n  index key y n mi ma =\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have \"Max ?B \\<le> Max ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n    \\<le> Max {i. i < n \\<and>\n                  offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                  0 < offs_num n xs index key mi ma i}", "using N"], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n    \\<le> Max {i. i < n \\<and>\n                  offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                  0 < offs_num n xs index key mi ma i}", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<le> Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"Max ?B < Max ?C\""], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<le> Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n    < Max {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n              0 < offs_num n xs index key mi ma i}", "proof (rule_tac ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i} =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i} \\<Longrightarrow>\n    False", "assume \"Max ?B = Max ?C\""], ["proof (state)\nthis:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i} =\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i} =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i} \\<Longrightarrow>\n    False", "hence \"offs ?ns 0 ! i < offs_next (offs ?ns 0) (length xs)\n      xs index key mi ma (Max ?B)\""], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i} =\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) 0 ! i\n    < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i})", "using F and O"], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i} =\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n  offs (enum xs index key n mi ma) 0 ! i \\<le> k\n  k < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n                0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) 0 ! i\n    < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index\n       key mi ma\n       (Max {i. i < n \\<and>\n                offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n                0 < offs_num n xs index key mi ma i})", "by simp"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) 0 ! i\n  < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index key\n     mi ma\n     (Max {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i} =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) 0 ! i\n  < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index key\n     mi ma\n     (Max {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i})\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i} =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i} \\<Longrightarrow>\n    False", "have \"offs ?ns 0 ! Max ?B < offs ?ns 0 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) 0 !\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n    < offs (enum xs index key n mi ma) 0 ! i", "using E and K"], ["proof (prove)\nusing this:\n  j < offs (enum xs index key n mi ma) 0 ! i\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) 0 !\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n    < offs (enum xs index key n mi ma) 0 ! i", "by simp"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) 0 !\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  < offs (enum xs index key n mi ma) 0 ! i\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i} =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i} \\<Longrightarrow>\n    False", "with K"], ["proof (chain)\npicking this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n  offs (enum xs index key n mi ma) 0 !\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  < offs (enum xs index key n mi ma) 0 ! i", "have \"Max ?B < i\""], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  \\<in> {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n  offs (enum xs index key n mi ma) 0 !\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  < offs (enum xs index key n mi ma) 0 ! i\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i}\n    < i", "by (erule_tac contrapos_pp, subst not_less, subst (asm) not_less,\n       erule_tac offs_mono, simp add: enum_length)"], ["proof (state)\nthis:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  < i\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i} =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i} \\<Longrightarrow>\n    False", "hence \"offs_next (offs ?ns 0) (length xs + 0) xs index key mi ma (Max ?B) \\<le>\n      offs ?ns 0 ! i\""], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  < i\n\ngoal (1 subgoal):\n 1. offs_next (offs (enum xs index key n mi ma) 0) (length xs + 0) xs index\n     key mi ma\n     (Max {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i})\n    \\<le> offs (enum xs index key n mi ma) 0 ! i", "using C and D"], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  < i\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  i < n\n\ngoal (1 subgoal):\n 1. offs_next (offs (enum xs index key n mi ma) 0) (length xs + 0) xs index\n     key mi ma\n     (Max {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i})\n    \\<le> offs (enum xs index key n mi ma) 0 ! i", "by (rule_tac offs_enum_next_le [OF A], simp_all)"], ["proof (state)\nthis:\n  offs_next (offs (enum xs index key n mi ma) 0) (length xs + 0) xs index\n   key mi ma\n   (Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i})\n  \\<le> offs (enum xs index key n mi ma) 0 ! i\n\ngoal (1 subgoal):\n 1. Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i} =\n    Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) 0 ! i\n  < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index key\n     mi ma\n     (Max {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i})\n  offs_next (offs (enum xs index key n mi ma) 0) (length xs + 0) xs index\n   key mi ma\n   (Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i})\n  \\<le> offs (enum xs index key n mi ma) 0 ! i", "show False"], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) 0 ! i\n  < offs_next (offs (enum xs index key n mi ma) 0) (length xs) xs index key\n     mi ma\n     (Max {i. i < n \\<and>\n              offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n              0 < offs_num n xs index key mi ma i})\n  offs_next (offs (enum xs index key n mi ma) 0) (length xs + 0) xs index\n   key mi ma\n   (Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n            0 < offs_num n xs index key mi ma i})\n  \\<le> offs (enum xs index key n mi ma) 0 ! i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  < Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence R: \"index key x n mi ma < index key y n mi ma\""], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  < Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. index key x n mi ma < index key y n mi ma", "using M and Q"], ["proof (prove)\nusing this:\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  < Max {i. i < n \\<and>\n            offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n            0 < offs_num n xs index key mi ma i}\n  index key x n mi ma =\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> j \\<and>\n          0 < offs_num n xs index key mi ma i}\n  index key y n mi ma =\n  Max {i. i < n \\<and>\n          offs (enum xs index key n mi ma) 0 ! i \\<le> k \\<and>\n          0 < offs_num n xs index key mi ma i}\n\ngoal (1 subgoal):\n 1. index key x n mi ma < index key y n mi ma", "by simp"], ["proof (state)\nthis:\n  index key x n mi ma < index key y n mi ma\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have \"count (mset (map the (fill xs (offs ?ns 0) index key\n    (length xs) mi ma))) x = count (mset xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma)))\n     x =\n    count (mset xs) x", "using C and D"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  i < n\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma)))\n     x =\n    count (mset xs) x", "by (rule_tac fill_offs_enum_count_item [OF A], simp_all)"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)))\n   x =\n  count (mset xs) x\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "moreover"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)))\n   x =\n  count (mset xs) x\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have S: \"j < length (map the (fill xs (offs ?ns 0) index key\n    (length xs) mi ma))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma))", "using E and F and G"], ["proof (prove)\nusing this:\n  j < offs (enum xs index key n mi ma) 0 ! i\n  offs (enum xs index key n mi ma) 0 ! i \\<le> k\n  k < length xs\n\ngoal (1 subgoal):\n 1. j < length\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma))", "by (simp add: fill_length)"], ["proof (state)\nthis:\n  j < length\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"map the (fill xs (offs ?ns 0) index key (length xs) mi ma) ! j\n    \\<in> set (map the (fill xs (offs ?ns 0) index key (length xs) mi ma))\""], ["proof (prove)\nusing this:\n  j < length\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma))\n\ngoal (1 subgoal):\n 1. map the\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma) !\n    j\n    \\<in> set (map the\n                (fill xs (offs (enum xs index key n mi ma) 0) index key\n                  (length xs) mi ma))", "by (rule nth_mem)"], ["proof (state)\nthis:\n  map the\n   (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma) !\n  j\n  \\<in> set (map the\n              (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"0 < count (mset (map the (fill xs (offs ?ns 0) index key\n    (length xs) mi ma))) x\""], ["proof (prove)\nusing this:\n  map the\n   (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma) !\n  j\n  \\<in> set (map the\n              (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma))\n\ngoal (1 subgoal):\n 1. 0 < count\n         (mset\n           (map the\n             (fill xs (offs (enum xs index key n mi ma) 0) index key\n               (length xs) mi ma)))\n         x", "using L and S"], ["proof (prove)\nusing this:\n  map the\n   (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma) !\n  j\n  \\<in> set (map the\n              (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma))\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  j =\n  Some x\n  j < length\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma))\n\ngoal (1 subgoal):\n 1. 0 < count\n         (mset\n           (map the\n             (fill xs (offs (enum xs index key n mi ma) 0) index key\n               (length xs) mi ma)))\n         x", "by simp"], ["proof (state)\nthis:\n  0 < count\n       (mset\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma)))\n       x\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "ultimately"], ["proof (chain)\npicking this:\n  count\n   (mset\n     (map the\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)))\n   x =\n  count (mset xs) x\n  0 < count\n       (mset\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma)))\n       x", "have T: \"x \\<in> set xs\""], ["proof (prove)\nusing this:\n  count\n   (mset\n     (map the\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)))\n   x =\n  count (mset xs) x\n  0 < count\n       (mset\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma)))\n       x\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have \"count (mset (map the (fill xs (offs ?ns 0) index key\n    (length xs) mi ma))) y = count (mset xs) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma)))\n     y =\n    count (mset xs) y", "using C and D"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  i < n\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma)))\n     y =\n    count (mset xs) y", "by (rule_tac fill_offs_enum_count_item [OF A], simp_all)"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)))\n   y =\n  count (mset xs) y\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "moreover"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)))\n   y =\n  count (mset xs) y\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have U: \"k < length (map the (fill xs (offs ?ns 0) index key\n    (length xs) mi ma))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma))", "using G"], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. k < length\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma))", "by (simp add: fill_length)"], ["proof (state)\nthis:\n  k < length\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"map the (fill xs (offs ?ns 0) index key (length xs) mi ma) ! k\n    \\<in> set (map the (fill xs (offs ?ns 0) index key (length xs) mi ma))\""], ["proof (prove)\nusing this:\n  k < length\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma))\n\ngoal (1 subgoal):\n 1. map the\n     (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n       ma) !\n    k\n    \\<in> set (map the\n                (fill xs (offs (enum xs index key n mi ma) 0) index key\n                  (length xs) mi ma))", "by (rule nth_mem)"], ["proof (state)\nthis:\n  map the\n   (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma) !\n  k\n  \\<in> set (map the\n              (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"0 < count (mset (map the (fill xs (offs ?ns 0) index key\n    (length xs) mi ma))) y\""], ["proof (prove)\nusing this:\n  map the\n   (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma) !\n  k\n  \\<in> set (map the\n              (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma))\n\ngoal (1 subgoal):\n 1. 0 < count\n         (mset\n           (map the\n             (fill xs (offs (enum xs index key n mi ma) 0) index key\n               (length xs) mi ma)))\n         y", "using P and U"], ["proof (prove)\nusing this:\n  map the\n   (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi\n     ma) !\n  k\n  \\<in> set (map the\n              (fill xs (offs (enum xs index key n mi ma) 0) index key\n                (length xs) mi ma))\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  k =\n  Some y\n  k < length\n       (map the\n         (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n           mi ma))\n\ngoal (1 subgoal):\n 1. 0 < count\n         (mset\n           (map the\n             (fill xs (offs (enum xs index key n mi ma) 0) index key\n               (length xs) mi ma)))\n         y", "by simp"], ["proof (state)\nthis:\n  0 < count\n       (mset\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma)))\n       y\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "ultimately"], ["proof (chain)\npicking this:\n  count\n   (mset\n     (map the\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)))\n   y =\n  count (mset xs) y\n  0 < count\n       (mset\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma)))\n       y", "have V: \"y \\<in> set xs\""], ["proof (prove)\nusing this:\n  count\n   (mset\n     (map the\n       (fill xs (offs (enum xs index key n mi ma) 0) index key (length xs)\n         mi ma)))\n   y =\n  count (mset xs) y\n  0 < count\n       (mset\n         (map the\n           (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma)))\n       y\n\ngoal (1 subgoal):\n 1. y \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "have \"key y \\<le> key x \\<longrightarrow> index key y n mi ma \\<le> index key x n mi ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key y \\<le> key x \\<longrightarrow>\n    index key y n mi ma \\<le> index key x n mi ma", "using B and C and T and V"], ["proof (prove)\nusing this:\n  index_mono index key\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  x \\<in> set xs\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. key y \\<le> key x \\<longrightarrow>\n    index key y n mi ma \\<le> index key x n mi ma", "by (simp add: index_mono_def)"], ["proof (state)\nthis:\n  key y \\<le> key x \\<longrightarrow>\n  index key y n mi ma \\<le> index key x n mi ma\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "hence \"key x < key y\""], ["proof (prove)\nusing this:\n  key y \\<le> key x \\<longrightarrow>\n  index key y n mi ma \\<le> index key x n mi ma\n\ngoal (1 subgoal):\n 1. key x < key y", "by (rule_tac contrapos_pp [OF R], simp add: not_less)"], ["proof (state)\nthis:\n  key x < key y\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < offs (enum xs index key n mi ma) 0 ! i;\n        offs (enum xs index key n mi ma) 0 ! i \\<le> k;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> key (the (fill xs\n                                    (offs (enum xs index key n mi ma) 0)\n                                    index key (length xs) mi ma !\n                                   j))\n                         \\<le> key (the (fill xs\n    (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n   k))", "thus \"key (the (fill xs (offs ?ns 0) index key (length xs) mi ma ! j)) \\<le>\n    key (the (fill xs (offs ?ns 0) index key (length xs) mi ma ! k))\""], ["proof (prove)\nusing this:\n  key x < key y\n\ngoal (1 subgoal):\n 1. key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n               (length xs) mi ma !\n              j))\n    \\<le> key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                     (length xs) mi ma !\n                    k))", "using L and P"], ["proof (prove)\nusing this:\n  key x < key y\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  j =\n  Some x\n  fill xs (offs (enum xs index key n mi ma) 0) index key (length xs) mi ma !\n  k =\n  Some y\n\ngoal (1 subgoal):\n 1. key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n               (length xs) mi ma !\n              j))\n    \\<le> key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                     (length xs) mi ma !\n                    k))", "by simp"], ["proof (state)\nthis:\n  key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n             (length xs) mi ma !\n            j))\n  \\<le> key (the (fill xs (offs (enum xs index key n mi ma) 0) index key\n                   (length xs) mi ma !\n                  k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_sort_inv [rule_format]:\n \"index_less index key \\<longrightarrow> index_mono index key \\<longrightarrow> bn_inv p q t \\<longrightarrow>\n    add_inv n t \\<longrightarrow> sort_inv key t \\<longrightarrow> sort_inv key (round index key p q r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_less index key \\<longrightarrow>\n    index_mono index key \\<longrightarrow>\n    bn_inv p q t \\<longrightarrow>\n    add_inv n t \\<longrightarrow>\n    sort_inv key t \\<longrightarrow> sort_inv key (round index key p q r t)", "proof (induction index key p q r t arbitrary: n rule: round.induct,\n (rule_tac [!] impI)+, simp, simp_all only: simp_thms)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, xs) \\<longrightarrow>\n                   add_inv n (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, 0 # ns, xs); add_inv n (u, 0 # ns, xs);\n        sort_inv key (u, 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, 0 # ns, xs))\n 2. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 3. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "fix index p q r u ns xs n and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, xs) \\<longrightarrow>\n                   add_inv n (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, 0 # ns, xs); add_inv n (u, 0 # ns, xs);\n        sort_inv key (u, 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, 0 # ns, xs))\n 2. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 3. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?t = \"round index key p q r (u, ns, xs)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, xs) \\<longrightarrow>\n                   add_inv n (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, 0 # ns, xs); add_inv n (u, 0 # ns, xs);\n        sort_inv key (u, 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, 0 # ns, xs))\n 2. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 3. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume \"\\<And>n. bn_inv p q (u, ns, xs) \\<longrightarrow> add_inv n (u, ns, xs) \\<longrightarrow>\n    sort_inv key (u, ns, xs) \\<longrightarrow> sort_inv key ?t\""], ["proof (state)\nthis:\n  bn_inv p q (u, ns, xs) \\<longrightarrow>\n  add_inv ?n (u, ns, xs) \\<longrightarrow>\n  sort_inv key (u, ns, xs) \\<longrightarrow>\n  sort_inv key (round index key p q r (u, ns, xs))\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, xs) \\<longrightarrow>\n                   add_inv n (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, 0 # ns, xs); add_inv n (u, 0 # ns, xs);\n        sort_inv key (u, 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, 0 # ns, xs))\n 2. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 3. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "hence \"bn_inv p q (u, ns, xs) \\<longrightarrow> add_inv n (u, ns, xs) \\<longrightarrow>\n    sort_inv key (u, ns, xs) \\<longrightarrow> sort_inv key ?t\""], ["proof (prove)\nusing this:\n  bn_inv p q (u, ns, xs) \\<longrightarrow>\n  add_inv ?n (u, ns, xs) \\<longrightarrow>\n  sort_inv key (u, ns, xs) \\<longrightarrow>\n  sort_inv key (round index key p q r (u, ns, xs))\n\ngoal (1 subgoal):\n 1. bn_inv p q (u, ns, xs) \\<longrightarrow>\n    add_inv n (u, ns, xs) \\<longrightarrow>\n    sort_inv key (u, ns, xs) \\<longrightarrow>\n    sort_inv key (round index key p q r (u, ns, xs))", "."], ["proof (state)\nthis:\n  bn_inv p q (u, ns, xs) \\<longrightarrow>\n  add_inv n (u, ns, xs) \\<longrightarrow>\n  sort_inv key (u, ns, xs) \\<longrightarrow>\n  sort_inv key (round index key p q r (u, ns, xs))\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, xs) \\<longrightarrow>\n                   add_inv n (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, 0 # ns, xs); add_inv n (u, 0 # ns, xs);\n        sort_inv key (u, 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, 0 # ns, xs))\n 2. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 3. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "moreover"], ["proof (state)\nthis:\n  bn_inv p q (u, ns, xs) \\<longrightarrow>\n  add_inv n (u, ns, xs) \\<longrightarrow>\n  sort_inv key (u, ns, xs) \\<longrightarrow>\n  sort_inv key (round index key p q r (u, ns, xs))\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, xs) \\<longrightarrow>\n                   add_inv n (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, 0 # ns, xs); add_inv n (u, 0 # ns, xs);\n        sort_inv key (u, 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, 0 # ns, xs))\n 2. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 3. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n   \"bn_inv p q (u, 0 # ns, xs)\"\n   \"add_inv n (u, 0 # ns, xs)\" and\n   \"sort_inv key (u, 0 # ns, xs)\""], ["proof (state)\nthis:\n  bn_inv p q (u, 0 # ns, xs)\n  add_inv n (u, 0 # ns, xs)\n  sort_inv key (u, 0 # ns, xs)\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, xs) \\<longrightarrow>\n                   add_inv n (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (u, ns, xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, 0 # ns, xs); add_inv n (u, 0 # ns, xs);\n        sort_inv key (u, 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, 0 # ns, xs))\n 2. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 3. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "ultimately"], ["proof (chain)\npicking this:\n  bn_inv p q (u, ns, xs) \\<longrightarrow>\n  add_inv n (u, ns, xs) \\<longrightarrow>\n  sort_inv key (u, ns, xs) \\<longrightarrow>\n  sort_inv key (round index key p q r (u, ns, xs))\n  bn_inv p q (u, 0 # ns, xs)\n  add_inv n (u, 0 # ns, xs)\n  sort_inv key (u, 0 # ns, xs)", "show \"sort_inv key (round index key p q r (u, 0 # ns, xs))\""], ["proof (prove)\nusing this:\n  bn_inv p q (u, ns, xs) \\<longrightarrow>\n  add_inv n (u, ns, xs) \\<longrightarrow>\n  sort_inv key (u, ns, xs) \\<longrightarrow>\n  sort_inv key (round index key p q r (u, ns, xs))\n  bn_inv p q (u, 0 # ns, xs)\n  add_inv n (u, 0 # ns, xs)\n  sort_inv key (u, 0 # ns, xs)\n\ngoal (1 subgoal):\n 1. sort_inv key (round index key p q r (u, 0 # ns, xs))", "by auto"], ["proof (state)\nthis:\n  sort_inv key (round index key p q r (u, 0 # ns, xs))\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "fix index p q r u ns xs n and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?t = \"round index key p q r (u, ns, tl xs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n    A: \"index_less index key\" and\n    B: \"bn_inv p q (u, Suc 0 # ns, xs)\""], ["proof (state)\nthis:\n  index_less index key\n  bn_inv p q (u, Suc 0 # ns, xs)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "moreover"], ["proof (state)\nthis:\n  index_less index key\n  bn_inv p q (u, Suc 0 # ns, xs)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n   \"\\<And>n. bn_inv p q (u, ns, tl xs) \\<longrightarrow> add_inv n (u, ns, tl xs) \\<longrightarrow>\n      sort_inv key (u, ns, tl xs) \\<longrightarrow> sort_inv key ?t\" and\n   \"add_inv n (u, Suc 0 # ns, xs)\" and\n   \"sort_inv key (u, Suc 0 # ns, xs)\""], ["proof (state)\nthis:\n  bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n  add_inv ?n (u, ns, tl xs) \\<longrightarrow>\n  sort_inv key (u, ns, tl xs) \\<longrightarrow>\n  sort_inv key (round index key p q r (u, ns, tl xs))\n  add_inv n (u, Suc 0 # ns, xs)\n  sort_inv key (u, Suc 0 # ns, xs)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n.\n       \\<lbrakk>\\<And>n.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (u, ns, tl xs) \\<longrightarrow>\n                   sort_inv key (round index key p q r (u, ns, tl xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc 0 # ns, xs); add_inv n (u, Suc 0 # ns, xs);\n        sort_inv key (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "ultimately"], ["proof (chain)\npicking this:\n  index_less index key\n  bn_inv p q (u, Suc 0 # ns, xs)\n  bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n  add_inv ?n (u, ns, tl xs) \\<longrightarrow>\n  sort_inv key (u, ns, tl xs) \\<longrightarrow>\n  sort_inv key (round index key p q r (u, ns, tl xs))\n  add_inv n (u, Suc 0 # ns, xs)\n  sort_inv key (u, Suc 0 # ns, xs)", "show \"sort_inv key (round index key p q r (u, Suc 0 # ns, xs))\""], ["proof (prove)\nusing this:\n  index_less index key\n  bn_inv p q (u, Suc 0 # ns, xs)\n  bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n  add_inv ?n (u, ns, tl xs) \\<longrightarrow>\n  sort_inv key (u, ns, tl xs) \\<longrightarrow>\n  sort_inv key (round index key p q r (u, ns, tl xs))\n  add_inv n (u, Suc 0 # ns, xs)\n  sort_inv key (u, Suc 0 # ns, xs)\n\ngoal (1 subgoal):\n 1. sort_inv key (round index key p q r (u, Suc 0 # ns, xs))", "proof (cases ?t, cases xs, simp_all add: add_suc, (rule_tac allI, rule_tac impI)+,\n   rule_tac ballI, simp, (erule_tac conjE)+, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "fix i j k y ys u' ns' xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "assume\n      C: \"round index key p q r (u, ns, ys) = (u', ns', xs')\" and\n      D: \"Suc (foldl (+) 0 ns) = n\" and\n      E: \"Suc (length ys) = n\" and\n      F: \"\\<forall>i < Suc (length ns).\n        \\<forall>j < (0 # offs ns (Suc 0)) ! i. \\<forall>k \\<in> {(0 # offs ns (Suc 0)) ! i..<n}.\n          key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0))\""], ["proof (state)\nthis:\n  round index key p q r (u, ns, ys) = (u', ns', xs')\n  Suc (foldl (+) 0 ns) = n\n  Suc (length ys) = n\n  \\<forall>i<Suc (length ns).\n     \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n           key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "assume A': \"j < (0 # offs ns' (Suc 0)) ! i\""], ["proof (state)\nthis:\n  j < (0 # offs ns' (Suc 0)) ! i\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "hence \"\\<exists>i'. i = Suc i'\""], ["proof (prove)\nusing this:\n  j < (0 # offs ns' (Suc 0)) ! i\n\ngoal (1 subgoal):\n 1. \\<exists>i'. i = Suc i'", "by (rule_tac nat.exhaust [of i], simp_all)"], ["proof (state)\nthis:\n  \\<exists>i'. i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "then"], ["proof (chain)\npicking this:\n  \\<exists>i'. i = Suc i'", "obtain i' where B': \"i = Suc i'\""], ["proof (prove)\nusing this:\n  \\<exists>i'. i = Suc i'\n\ngoal (1 subgoal):\n 1. (\\<And>i'. i = Suc i' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "assume \"i < Suc (length ns')\""], ["proof (state)\nthis:\n  i < Suc (length ns')\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "hence G: \"i' < length ns'\""], ["proof (prove)\nusing this:\n  i < Suc (length ns')\n\ngoal (1 subgoal):\n 1. i' < length ns'", "using B'"], ["proof (prove)\nusing this:\n  i < Suc (length ns')\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. i' < length ns'", "by simp"], ["proof (state)\nthis:\n  i' < length ns'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "hence H: \"j < Suc (offs ns' 0 ! i')\""], ["proof (prove)\nusing this:\n  i' < length ns'\n\ngoal (1 subgoal):\n 1. j < Suc (offs ns' 0 ! i')", "using A' and B'"], ["proof (prove)\nusing this:\n  i' < length ns'\n  j < (0 # offs ns' (Suc 0)) ! i\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. j < Suc (offs ns' 0 ! i')", "by (simp add: offs_suc)"], ["proof (state)\nthis:\n  j < Suc (offs ns' 0 ! i')\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "assume \"(0 # offs ns' (Suc 0)) ! i \\<le> k\""], ["proof (state)\nthis:\n  (0 # offs ns' (Suc 0)) ! i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "hence \"Suc (offs ns' 0 ! i') \\<le> k\""], ["proof (prove)\nusing this:\n  (0 # offs ns' (Suc 0)) ! i \\<le> k\n\ngoal (1 subgoal):\n 1. Suc (offs ns' 0 ! i') \\<le> k", "using B' and G"], ["proof (prove)\nusing this:\n  (0 # offs ns' (Suc 0)) ! i \\<le> k\n  i = Suc i'\n  i' < length ns'\n\ngoal (1 subgoal):\n 1. Suc (offs ns' 0 ! i') \\<le> k", "by (simp add: offs_suc)"], ["proof (state)\nthis:\n  Suc (offs ns' 0 ! i') \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "moreover"], ["proof (state)\nthis:\n  Suc (offs ns' 0 ! i') \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "from this"], ["proof (chain)\npicking this:\n  Suc (offs ns' 0 ! i') \\<le> k", "have \"\\<exists>k'. k = Suc k'\""], ["proof (prove)\nusing this:\n  Suc (offs ns' 0 ! i') \\<le> k\n\ngoal (1 subgoal):\n 1. \\<exists>k'. k = Suc k'", "by (rule_tac nat.exhaust [of k], simp_all)"], ["proof (state)\nthis:\n  \\<exists>k'. k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "then"], ["proof (chain)\npicking this:\n  \\<exists>k'. k = Suc k'", "obtain k' where I: \"k = Suc k'\""], ["proof (prove)\nusing this:\n  \\<exists>k'. k = Suc k'\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "ultimately"], ["proof (chain)\npicking this:\n  Suc (offs ns' 0 ! i') \\<le> k\n  k = Suc k'", "have J: \"offs ns' 0 ! i' \\<le> k'\""], ["proof (prove)\nusing this:\n  Suc (offs ns' 0 ! i') \\<le> k\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. offs ns' 0 ! i' \\<le> k'", "by simp"], ["proof (state)\nthis:\n  offs ns' 0 ! i' \\<le> k'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "assume \"k < Suc (length xs')\""], ["proof (state)\nthis:\n  k < Suc (length xs')\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "hence K: \"k' < length xs'\""], ["proof (prove)\nusing this:\n  k < Suc (length xs')\n\ngoal (1 subgoal):\n 1. k' < length xs'", "using I"], ["proof (prove)\nusing this:\n  k < Suc (length xs')\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. k' < length xs'", "by simp"], ["proof (state)\nthis:\n  k' < length xs'\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "let ?P = \"\\<lambda>n. foldl (+) 0 ns = n \\<and> length ys = n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "let ?Q = \"\\<lambda>n. \\<forall>i < length ns.\n      \\<forall>j < offs ns 0 ! i. \\<forall>k \\<in> {offs ns 0 ! i..<n}.\n        key (ys ! j) \\<le> key (ys ! k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "let ?R = \"\\<forall>i < length ns'.\n      \\<forall>j < offs ns' 0 ! i. \\<forall>k \\<in> {offs ns' 0 ! i..<length xs'}.\n        key (xs' ! j) \\<le> key (xs' ! k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "assume \"\\<And>n. ?P n \\<longrightarrow> ?Q n \\<longrightarrow> ?R\""], ["proof (state)\nthis:\n  foldl (+) 0 ns = ?n \\<and> length ys = ?n \\<longrightarrow>\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<?n}.\n            key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "hence \"?P (n - Suc 0) \\<longrightarrow> ?Q (n - Suc 0) \\<longrightarrow> ?R\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = ?n \\<and> length ys = ?n \\<longrightarrow>\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<?n}.\n            key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns = n - Suc 0 \\<and>\n    length ys = n - Suc 0 \\<longrightarrow>\n    (\\<forall>i<length ns.\n        \\<forall>j<offs ns 0 ! i.\n           \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n              key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n    (\\<forall>i<length ns'.\n        \\<forall>j<offs ns' 0 ! i.\n           \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n              key (xs' ! j) \\<le> key (xs' ! k))", "."], ["proof (state)\nthis:\n  foldl (+) 0 ns = n - Suc 0 \\<and> length ys = n - Suc 0 \\<longrightarrow>\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n            key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "hence \"?Q (n - Suc 0) \\<longrightarrow> ?R\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = n - Suc 0 \\<and> length ys = n - Suc 0 \\<longrightarrow>\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n            key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. (\\<forall>i<length ns.\n        \\<forall>j<offs ns 0 ! i.\n           \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n              key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n    (\\<forall>i<length ns'.\n        \\<forall>j<offs ns' 0 ! i.\n           \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n              key (xs' ! j) \\<le> key (xs' ! k))", "using D and E"], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = n - Suc 0 \\<and> length ys = n - Suc 0 \\<longrightarrow>\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n            key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n  Suc (foldl (+) 0 ns) = n\n  Suc (length ys) = n\n\ngoal (1 subgoal):\n 1. (\\<forall>i<length ns.\n        \\<forall>j<offs ns 0 ! i.\n           \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n              key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n    (\\<forall>i<length ns'.\n        \\<forall>j<offs ns' 0 ! i.\n           \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n              key (xs' ! j) \\<le> key (xs' ! k))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n            key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "moreover"], ["proof (state)\nthis:\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n            key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "have \"?Q (n - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length ns.\n       \\<forall>j<offs ns 0 ! i.\n          \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n             key (ys ! j) \\<le> key (ys ! k)", "proof ((rule allI, rule impI)+, rule ballI, simp, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "have \"Suc i < Suc (length ns) \\<longrightarrow> (\\<forall>j < (0 # offs ns (Suc 0)) ! Suc i.\n        \\<forall>k \\<in> {(0 # offs ns (Suc 0)) ! Suc i..<n}.\n          key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < Suc (length ns) \\<longrightarrow>\n    (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc i..<n}.\n           key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))", "using F"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc (length ns).\n     \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n           key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0))\n\ngoal (1 subgoal):\n 1. Suc i < Suc (length ns) \\<longrightarrow>\n    (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc i..<n}.\n           key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))", ".."], ["proof (state)\nthis:\n  Suc i < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc i.\n      \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc i..<n}.\n         key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "moreover"], ["proof (state)\nthis:\n  Suc i < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc i.\n      \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc i..<n}.\n         key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "assume \"i < length ns\""], ["proof (state)\nthis:\n  i < length ns\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "ultimately"], ["proof (chain)\npicking this:\n  Suc i < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc i.\n      \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc i..<n}.\n         key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\n  i < length ns", "have \"Suc j < Suc (offs ns 0 ! i) \\<longrightarrow>\n        (\\<forall>k \\<in> {Suc (offs ns 0 ! i)..<n}.\n          key ((y # ys) ! Suc j) \\<le> key (ys ! (k - Suc 0)))\""], ["proof (prove)\nusing this:\n  Suc i < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc i.\n      \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc i..<n}.\n         key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\n  i < length ns\n\ngoal (1 subgoal):\n 1. Suc j < Suc (offs ns 0 ! i) \\<longrightarrow>\n    (\\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n        key ((y # ys) ! Suc j) \\<le> key (ys ! (k - Suc 0)))", "by (auto simp add: offs_suc)"], ["proof (state)\nthis:\n  Suc j < Suc (offs ns 0 ! i) \\<longrightarrow>\n  (\\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n      key ((y # ys) ! Suc j) \\<le> key (ys ! (k - Suc 0)))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "moreover"], ["proof (state)\nthis:\n  Suc j < Suc (offs ns 0 ! i) \\<longrightarrow>\n  (\\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n      key ((y # ys) ! Suc j) \\<le> key (ys ! (k - Suc 0)))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "assume \"j < offs ns 0 ! i\""], ["proof (state)\nthis:\n  j < offs ns 0 ! i\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "ultimately"], ["proof (chain)\npicking this:\n  Suc j < Suc (offs ns 0 ! i) \\<longrightarrow>\n  (\\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n      key ((y # ys) ! Suc j) \\<le> key (ys ! (k - Suc 0)))\n  j < offs ns 0 ! i", "have \"\\<forall>k \\<in> {Suc (offs ns 0 ! i)..<n}.\n        key (ys ! j) \\<le> key (ys ! (k - Suc 0))\""], ["proof (prove)\nusing this:\n  Suc j < Suc (offs ns 0 ! i) \\<longrightarrow>\n  (\\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n      key ((y # ys) ! Suc j) \\<le> key (ys ! (k - Suc 0)))\n  j < offs ns 0 ! i\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n       key (ys ! j) \\<le> key (ys ! (k - Suc 0))", "by simp"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n     key (ys ! j) \\<le> key (ys ! (k - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "moreover"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n     key (ys ! j) \\<le> key (ys ! (k - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "assume \"offs ns 0 ! i \\<le> k\" and \"k < n - Suc 0\""], ["proof (state)\nthis:\n  offs ns 0 ! i \\<le> k\n  k < n - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "hence \"Suc k \\<in> {Suc (offs ns 0 ! i)..<n}\""], ["proof (prove)\nusing this:\n  offs ns 0 ! i \\<le> k\n  k < n - Suc 0\n\ngoal (1 subgoal):\n 1. Suc k \\<in> {Suc (offs ns 0 ! i)..<n}", "by simp"], ["proof (state)\nthis:\n  Suc k \\<in> {Suc (offs ns 0 ! i)..<n}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n     key (ys ! j) \\<le> key (ys ! (k - Suc 0))\n  Suc k \\<in> {Suc (offs ns 0 ! i)..<n}", "have \"key (ys ! j) \\<le> key (ys ! (Suc k - Suc 0))\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{Suc (offs ns 0 ! i)..<n}.\n     key (ys ! j) \\<le> key (ys ! (k - Suc 0))\n  Suc k \\<in> {Suc (offs ns 0 ! i)..<n}\n\ngoal (1 subgoal):\n 1. key (ys ! j) \\<le> key (ys ! (Suc k - Suc 0))", ".."], ["proof (state)\nthis:\n  key (ys ! j) \\<le> key (ys ! (Suc k - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc 0\\<rbrakk>\n       \\<Longrightarrow> key (ys ! j) \\<le> key (ys ! k)", "thus \"key (ys ! j) \\<le> key (ys ! k)\""], ["proof (prove)\nusing this:\n  key (ys ! j) \\<le> key (ys ! (Suc k - Suc 0))\n\ngoal (1 subgoal):\n 1. key (ys ! j) \\<le> key (ys ! k)", "by simp"], ["proof (state)\nthis:\n  key (ys ! j) \\<le> key (ys ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length ns.\n     \\<forall>j<offs ns 0 ! i.\n        \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n           key (ys ! j) \\<le> key (ys ! k)\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n            key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n  \\<forall>i<length ns.\n     \\<forall>j<offs ns 0 ! i.\n        \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n           key (ys ! j) \\<le> key (ys ! k)", "have ?R"], ["proof (prove)\nusing this:\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n            key (ys ! j) \\<le> key (ys ! k)) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n  \\<forall>i<length ns.\n     \\<forall>j<offs ns 0 ! i.\n        \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc 0}.\n           key (ys ! j) \\<le> key (ys ! k)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ns'.\n       \\<forall>j<offs ns' 0 ! i.\n          \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n             key (xs' ! j) \\<le> key (xs' ! k)", ".."], ["proof (state)\nthis:\n  \\<forall>i<length ns'.\n     \\<forall>j<offs ns' 0 ! i.\n        \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n           key (xs' ! j) \\<le> key (xs' ! k)\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa list i j k.\n       \\<lbrakk>\\<forall>x\\<in>set ns.\n                   case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n                   | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n                 key ((aa # list) ! j) \\<le> key (list ! (k - Suc 0));\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>i<length ns.\n               \\<forall>j<offs ns 0 ! i.\n                  \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n                     key (list ! j) \\<le> key (list ! k)) \\<longrightarrow>\n           (\\<forall>i<length b.\n               \\<forall>j<offs b 0 ! i.\n                  \\<forall>k\\<in>{offs b 0 ! i..<length c}.\n                     key (c ! j) \\<le> key (c ! k));\n        xs = aa # list; foldl (+) (Suc 0) ns = n; i < Suc (length b);\n        j < (0 # offs b (Suc 0)) ! i; Suc (foldl (+) 0 ns) = n;\n        Suc (length list) = n; (0 # offs b (Suc 0)) ! i \\<le> k;\n        k < Suc (length c); index_less index key\\<rbrakk>\n       \\<Longrightarrow> key ((aa # c) ! j) \\<le> key (c ! (k - Suc 0))", "from I"], ["proof (chain)\npicking this:\n  k = Suc k'", "show \"key ((y # xs') ! j) \\<le> key (xs' ! (k - Suc 0))\""], ["proof (prove)\nusing this:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. key ((y # xs') ! j) \\<le> key (xs' ! (k - Suc 0))", "proof (cases j, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "have \"bn_inv p q (u, ns, ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_inv p q (u, ns, ys)", "using B"], ["proof (prove)\nusing this:\n  bn_inv p q (u, Suc 0 # ns, xs)\n\ngoal (1 subgoal):\n 1. bn_inv p q (u, ns, ys)", "by simp"], ["proof (state)\nthis:\n  bn_inv p q (u, ns, ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "moreover"], ["proof (state)\nthis:\n  bn_inv p q (u, ns, ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "have \"add_inv (n - Suc 0) (u, ns, ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_inv (n - Suc 0) (u, ns, ys)", "using D and E"], ["proof (prove)\nusing this:\n  Suc (foldl (+) 0 ns) = n\n  Suc (length ys) = n\n\ngoal (1 subgoal):\n 1. add_inv (n - Suc 0) (u, ns, ys)", "by auto"], ["proof (state)\nthis:\n  add_inv (n - Suc 0) (u, ns, ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "moreover"], ["proof (state)\nthis:\n  add_inv (n - Suc 0) (u, ns, ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "have \"count_inv (\\<lambda>x. count (mset ys) x) (u, ns, ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_inv (count (mset ys)) (u, ns, ys)", "by simp"], ["proof (state)\nthis:\n  count_inv (count (mset ys)) (u, ns, ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "ultimately"], ["proof (chain)\npicking this:\n  bn_inv p q (u, ns, ys)\n  add_inv (n - Suc 0) (u, ns, ys)\n  count_inv (count (mset ys)) (u, ns, ys)", "have \"count_inv (\\<lambda>x. count (mset ys) x)\n        (round index key p q r (u, ns, ys))\""], ["proof (prove)\nusing this:\n  bn_inv p q (u, ns, ys)\n  add_inv (n - Suc 0) (u, ns, ys)\n  count_inv (count (mset ys)) (u, ns, ys)\n\ngoal (1 subgoal):\n 1. count_inv (count (mset ys)) (round index key p q r (u, ns, ys))", "by (rule round_count_inv [OF A])"], ["proof (state)\nthis:\n  count_inv (count (mset ys)) (round index key p q r (u, ns, ys))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "hence \"count (mset xs') (xs' ! k') = count (mset ys) (xs' ! k')\""], ["proof (prove)\nusing this:\n  count_inv (count (mset ys)) (round index key p q r (u, ns, ys))\n\ngoal (1 subgoal):\n 1. count (mset xs') (xs' ! k') = count (mset ys) (xs' ! k')", "using C"], ["proof (prove)\nusing this:\n  count_inv (count (mset ys)) (round index key p q r (u, ns, ys))\n  round index key p q r (u, ns, ys) = (u', ns', xs')\n\ngoal (1 subgoal):\n 1. count (mset xs') (xs' ! k') = count (mset ys) (xs' ! k')", "by simp"], ["proof (state)\nthis:\n  count (mset xs') (xs' ! k') = count (mset ys) (xs' ! k')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "moreover"], ["proof (state)\nthis:\n  count (mset xs') (xs' ! k') = count (mset ys) (xs' ! k')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "have \"0 < count (mset xs') (xs' ! k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < count (mset xs') (xs' ! k')", "using K"], ["proof (prove)\nusing this:\n  k' < length xs'\n\ngoal (1 subgoal):\n 1. 0 < count (mset xs') (xs' ! k')", "by simp"], ["proof (state)\nthis:\n  0 < count (mset xs') (xs' ! k')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "ultimately"], ["proof (chain)\npicking this:\n  count (mset xs') (xs' ! k') = count (mset ys) (xs' ! k')\n  0 < count (mset xs') (xs' ! k')", "have \"xs' ! k' \\<in> set ys\""], ["proof (prove)\nusing this:\n  count (mset xs') (xs' ! k') = count (mset ys) (xs' ! k')\n  0 < count (mset xs') (xs' ! k')\n\ngoal (1 subgoal):\n 1. xs' ! k' \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  xs' ! k' \\<in> set ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "hence \"\\<exists>m < length ys. ys ! m = xs' ! k'\""], ["proof (prove)\nusing this:\n  xs' ! k' \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>m<length ys. ys ! m = xs' ! k'", "by (simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>m<length ys. ys ! m = xs' ! k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "then"], ["proof (chain)\npicking this:\n  \\<exists>m<length ys. ys ! m = xs' ! k'", "obtain m where L: \"m < length ys \\<and> ys ! m = xs' ! k'\""], ["proof (prove)\nusing this:\n  \\<exists>m<length ys. ys ! m = xs' ! k'\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m < length ys \\<and> ys ! m = xs' ! k' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  m < length ys \\<and> ys ! m = xs' ! k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "have \"Suc 0 < Suc (length ns) \\<longrightarrow> (\\<forall>j < (0 # offs ns (Suc 0)) ! Suc 0.\n        \\<forall>k \\<in> {(0 # offs ns (Suc 0)) ! Suc 0..<n}.\n          key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < Suc (length ns) \\<longrightarrow>\n    (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc 0.\n        \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc 0..<n}.\n           key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))", "using F"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc (length ns).\n     \\<forall>j<(0 # offs ns (Suc 0)) ! i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! i..<n}.\n           key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0))\n\ngoal (1 subgoal):\n 1. Suc 0 < Suc (length ns) \\<longrightarrow>\n    (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc 0.\n        \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc 0..<n}.\n           key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))", ".."], ["proof (state)\nthis:\n  Suc 0 < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc 0.\n      \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc 0..<n}.\n         key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "moreover"], ["proof (state)\nthis:\n  Suc 0 < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc 0.\n      \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc 0..<n}.\n         key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "have M: \"0 < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length ns", "using D [symmetric] and E and L"], ["proof (prove)\nusing this:\n  n = Suc (foldl (+) 0 ns)\n  Suc (length ys) = n\n  m < length ys \\<and> ys ! m = xs' ! k'\n\ngoal (1 subgoal):\n 1. 0 < length ns", "by (rule_tac ccontr, simp)"], ["proof (state)\nthis:\n  0 < length ns\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "ultimately"], ["proof (chain)\npicking this:\n  Suc 0 < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc 0.\n      \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc 0..<n}.\n         key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\n  0 < length ns", "have \"\\<forall>k \\<in> {Suc (offs ns 0 ! 0)..<n}.\n        key y \\<le> key (ys ! (k - Suc 0))\""], ["proof (prove)\nusing this:\n  Suc 0 < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc 0)) ! Suc 0.\n      \\<forall>k\\<in>{(0 # offs ns (Suc 0)) ! Suc 0..<n}.\n         key ((y # ys) ! j) \\<le> key (ys ! (k - Suc 0)))\n  0 < length ns\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{Suc (offs ns 0 ! 0)..<n}.\n       key y \\<le> key (ys ! (k - Suc 0))", "by (auto simp add: offs_suc)"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{Suc (offs ns 0 ! 0)..<n}.\n     key y \\<le> key (ys ! (k - Suc 0))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "hence \"\\<forall>k \\<in> {Suc 0..<n}. key y \\<le> key (ys ! (k - Suc 0))\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{Suc (offs ns 0 ! 0)..<n}.\n     key y \\<le> key (ys ! (k - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{Suc 0..<n}. key y \\<le> key (ys ! (k - Suc 0))", "using M"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{Suc (offs ns 0 ! 0)..<n}.\n     key y \\<le> key (ys ! (k - Suc 0))\n  0 < length ns\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{Suc 0..<n}. key y \\<le> key (ys ! (k - Suc 0))", "by (cases ns, simp_all)"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{Suc 0..<n}. key y \\<le> key (ys ! (k - Suc 0))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "moreover"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{Suc 0..<n}. key y \\<le> key (ys ! (k - Suc 0))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "have \"Suc m \\<in> {Suc 0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m \\<in> {Suc 0..<n}", "using E and L"], ["proof (prove)\nusing this:\n  Suc (length ys) = n\n  m < length ys \\<and> ys ! m = xs' ! k'\n\ngoal (1 subgoal):\n 1. Suc m \\<in> {Suc 0..<n}", "by simp"], ["proof (state)\nthis:\n  Suc m \\<in> {Suc 0..<n}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>{Suc 0..<n}. key y \\<le> key (ys ! (k - Suc 0))\n  Suc m \\<in> {Suc 0..<n}", "have \"key y \\<le> key (ys ! (Suc m - Suc 0))\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{Suc 0..<n}. key y \\<le> key (ys ! (k - Suc 0))\n  Suc m \\<in> {Suc 0..<n}\n\ngoal (1 subgoal):\n 1. key y \\<le> key (ys ! (Suc m - Suc 0))", ".."], ["proof (state)\nthis:\n  key y \\<le> key (ys ! (Suc m - Suc 0))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = 0; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key y \\<le> key (xs' ! k')\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "thus \"key y \\<le> key (xs' ! k')\""], ["proof (prove)\nusing this:\n  key y \\<le> key (ys ! (Suc m - Suc 0))\n\ngoal (1 subgoal):\n 1. key y \\<le> key (xs' ! k')", "using L"], ["proof (prove)\nusing this:\n  key y \\<le> key (ys ! (Suc m - Suc 0))\n  m < length ys \\<and> ys ! m = xs' ! k'\n\ngoal (1 subgoal):\n 1. key y \\<le> key (xs' ! k')", "by simp"], ["proof (state)\nthis:\n  key y \\<le> key (xs' ! k')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "case (Suc j')"], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "moreover"], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "have \"i' < length ns' \\<longrightarrow> (\\<forall>j < offs ns' 0 ! i'.\n        \\<forall>k \\<in> {offs ns' 0 ! i'..<length xs'}. key (xs' ! j) \\<le> key (xs' ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' < length ns' \\<longrightarrow>\n    (\\<forall>j<offs ns' 0 ! i'.\n        \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n           key (xs' ! j) \\<le> key (xs' ! k))", "using \\<open>?R\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i<length ns'.\n     \\<forall>j<offs ns' 0 ! i.\n        \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n           key (xs' ! j) \\<le> key (xs' ! k)\n\ngoal (1 subgoal):\n 1. i' < length ns' \\<longrightarrow>\n    (\\<forall>j<offs ns' 0 ! i'.\n        \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n           key (xs' ! j) \\<le> key (xs' ! k))", ".."], ["proof (state)\nthis:\n  i' < length ns' \\<longrightarrow>\n  (\\<forall>j<offs ns' 0 ! i'.\n      \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n         key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "hence \"j' < offs ns' 0 ! i' \\<longrightarrow>\n        (\\<forall>k \\<in> {offs ns' 0 ! i'..<length xs'}. key (xs' ! j') \\<le> key (xs' ! k))\""], ["proof (prove)\nusing this:\n  i' < length ns' \\<longrightarrow>\n  (\\<forall>j<offs ns' 0 ! i'.\n      \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n         key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. j' < offs ns' 0 ! i' \\<longrightarrow>\n    (\\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n        key (xs' ! j') \\<le> key (xs' ! k))", "using G"], ["proof (prove)\nusing this:\n  i' < length ns' \\<longrightarrow>\n  (\\<forall>j<offs ns' 0 ! i'.\n      \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n         key (xs' ! j) \\<le> key (xs' ! k))\n  i' < length ns'\n\ngoal (1 subgoal):\n 1. j' < offs ns' 0 ! i' \\<longrightarrow>\n    (\\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n        key (xs' ! j') \\<le> key (xs' ! k))", "by simp"], ["proof (state)\nthis:\n  j' < offs ns' 0 ! i' \\<longrightarrow>\n  (\\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n      key (xs' ! j') \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "ultimately"], ["proof (chain)\npicking this:\n  j = Suc j'\n  j' < offs ns' 0 ! i' \\<longrightarrow>\n  (\\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n      key (xs' ! j') \\<le> key (xs' ! k))", "have \"\\<forall>k \\<in> {offs ns' 0 ! i'..<length xs'}.\n        key (xs' ! j') \\<le> key (xs' ! k)\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  j' < offs ns' 0 ! i' \\<longrightarrow>\n  (\\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n      key (xs' ! j') \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n       key (xs' ! j') \\<le> key (xs' ! k)", "using H"], ["proof (prove)\nusing this:\n  j = Suc j'\n  j' < offs ns' 0 ! i' \\<longrightarrow>\n  (\\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n      key (xs' ! j') \\<le> key (xs' ! k))\n  j < Suc (offs ns' 0 ! i')\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n       key (xs' ! j') \\<le> key (xs' ! k)", "by simp"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n     key (xs' ! j') \\<le> key (xs' ! k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "moreover"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n     key (xs' ! j') \\<le> key (xs' ! k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "have \"k' \\<in> {offs ns' 0 ! i'..<length xs'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<in> {offs ns' 0 ! i'..<length xs'}", "using J and K"], ["proof (prove)\nusing this:\n  offs ns' 0 ! i' \\<le> k'\n  k' < length xs'\n\ngoal (1 subgoal):\n 1. k' \\<in> {offs ns' 0 ! i'..<length xs'}", "by simp"], ["proof (state)\nthis:\n  k' \\<in> {offs ns' 0 ! i'..<length xs'}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (xs' ! nat) \\<le> key (xs' ! k')", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n     key (xs' ! j') \\<le> key (xs' ! k)\n  k' \\<in> {offs ns' 0 ! i'..<length xs'}", "show \"key (xs' ! j') \\<le> key (xs' ! k')\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{offs ns' 0 ! i'..<length xs'}.\n     key (xs' ! j') \\<le> key (xs' ! k)\n  k' \\<in> {offs ns' 0 ! i'..<length xs'}\n\ngoal (1 subgoal):\n 1. key (xs' ! j') \\<le> key (xs' ! k')", ".."], ["proof (state)\nthis:\n  key (xs' ! j') \\<le> key (xs' ! k')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  key ((y # xs') ! j) \\<le> key (xs' ! (k - Suc 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sort_inv key (round index key p q r (u, Suc 0 # ns, xs))\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "fix index p q r u m ns n and key :: \"'a \\<Rightarrow> 'b\" and xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?ws = \"take (Suc (Suc m)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?ys = \"drop (Suc (Suc m)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?r = \"\\<lambda>m'. round_suc_suc index key ?ws m m' u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?t = \"\\<lambda>r' v. round index key p q r' (v, ns, ?ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n    A: \"index_less index key\" and\n    B: \"index_mono index key\" and\n    C: \"bn_inv p q (u, Suc (Suc m) # ns, xs)\""], ["proof (state)\nthis:\n  index_less index key\n  index_mono index key\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n   \"\\<And>ws a b c d e f g h n.\n      ws = ?ws \\<Longrightarrow> a = bn_comp m p q r \\<Longrightarrow> (b, c) = bn_comp m p q r \\<Longrightarrow>\n      d = ?r b \\<Longrightarrow> (e, f) = ?r b \\<Longrightarrow> (g, h) = f \\<Longrightarrow>\n        bn_inv p q (e, ns, ?ys) \\<longrightarrow> add_inv n (e, ns, ?ys) \\<longrightarrow>\n          sort_inv key (e, ns, ?ys) \\<longrightarrow> sort_inv key (?t c e)\" and\n   \"add_inv n (u, Suc (Suc m) # ns, xs)\" and\n   \"sort_inv key (u, Suc (Suc m) # ns, xs)\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?f) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?g, ?h) = ?f\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    sort_inv key\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    sort_inv key\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  sort_inv key (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     sort_inv key\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; index_mono index key;\n        bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        sort_inv key (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> sort_inv key\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "with C"], ["proof (chain)\npicking this:\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?f) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?g, ?h) = ?f\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    sort_inv key\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    sort_inv key\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  sort_inv key (u, Suc (Suc m) # ns, xs)", "show \"sort_inv key (round index key p q r (u, Suc (Suc m) # ns, xs))\""], ["proof (prove)\nusing this:\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?f) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?g, ?h) = ?f\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    sort_inv key\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    sort_inv key\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  sort_inv key (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. sort_inv key (round index key p q r (u, Suc (Suc m) # ns, xs))", "using [[simproc del: defined_all]]"], ["proof (prove)\nusing this:\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?f) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?g, ?h) = ?f\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    sort_inv key\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    sort_inv key\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  sort_inv key (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. sort_inv key (round index key p q r (u, Suc (Suc m) # ns, xs))", "proof (simp split: prod.split, ((rule_tac allI)+, (rule_tac impI)+)+,\n   rule_tac ballI, simp, (erule_tac conjE)+, subst (asm) (2) add_base_zero, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "fix m' r' v ms' ws' u' ns' xs' i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?nmi = \"mini ?ws key\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?nma = \"maxi ?ws key\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?xmi = \"?ws ! ?nmi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?xma = \"?ws ! ?nma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?mi = \"key ?xmi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?ma = \"key ?xma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?k = \"case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m | Suc (Suc i) \\<Rightarrow> u + m'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?zs = \"nths ?ws (- {?nmi, ?nma})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?ms = \"enum ?zs index key ?k ?mi ?ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?P = \"\\<lambda>n'. foldl (+) 0 ns = n' \\<and> n - Suc (Suc m) = n'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?Q = \"\\<lambda>n'. \\<forall>i < length ns.\n      \\<forall>j < offs ns 0 ! i. \\<forall>k \\<in> {offs ns 0 ! i..<n'}.\n        key (xs ! Suc (Suc (m + j))) \\<le> key (xs ! Suc (Suc (m + k)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "let ?R = \"\\<forall>i < length ns'.\n      \\<forall>j < offs ns' 0 ! i. \\<forall>k \\<in> {offs ns' 0 ! i..<length xs'}.\n        key (xs' ! j) \\<le> key (xs' ! k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "assume\n      D: \"?r m' = (v, ms', ws')\" and\n      E: \"?t r' v = (u', ns', xs')\" and\n      F: \"bn_comp m p q r = (m', r')\" and\n      G: \"bn_valid m p q\" and\n      H: \"Suc (Suc (foldl (+) 0 ns + m)) = n\" and\n      I: \"length xs = n\" and\n      J: \"\\<forall>i < Suc (length ns). \\<forall>j < (0 # offs ns (Suc (Suc m))) ! i.\n        \\<forall>k \\<in> {(0 # offs ns (Suc (Suc m))) ! i..<n}.\n          key (xs ! j) \\<le> key (xs ! k)\" and\n      K: \"i < length ms' + length ns'\" and\n      L: \"j < offs (ms' @ ns') 0 ! i\" and\n      M: \"offs (ms' @ ns') 0 ! i \\<le> k\" and\n      N: \"k < length ws' + length xs'\""], ["proof (state)\nthis:\n  round_suc_suc index key (take (Suc (Suc m)) xs) m m' u = (v, ms', ws')\n  round index key p q r' (v, ns, drop (Suc (Suc m)) xs) = (u', ns', xs')\n  bn_comp m p q r = (m', r')\n  bn_valid m p q\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n  length xs = n\n  \\<forall>i<Suc (length ns).\n     \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n           key (xs ! j) \\<le> key (xs ! k)\n  i < length ms' + length ns'\n  j < offs (ms' @ ns') 0 ! i\n  offs (ms' @ ns') 0 ! i \\<le> k\n  k < length ws' + length xs'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "have O: \"length ?ws = Suc (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc (Suc m)) xs) = Suc (Suc m)", "using H and I"], ["proof (prove)\nusing this:\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. length (take (Suc (Suc m)) xs) = Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "with D [symmetric]"], ["proof (chain)\npicking this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)", "have P: \"length ws' = Suc (Suc m)\""], ["proof (prove)\nusing this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. length ws' = Suc (Suc m)", "by (simp add: round_suc_suc_def Let_def fill_length split: if_split_asm)"], ["proof (state)\nthis:\n  length ws' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "have Q: \"\\<And>i. i < m \\<Longrightarrow>\n      the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! i) \\<in> set ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "let ?x = \"the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "assume R: \"i < m\""], ["proof (state)\nthis:\n  i < m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "hence \"0 < m\""], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. 0 < m", "by simp"], ["proof (state)\nthis:\n  0 < m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "hence \"0 < ?k\""], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (1 subgoal):\n 1. 0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')", "by (drule_tac bn_comp_fst_nonzero [OF G], subst (asm) F,\n         simp split: nat.split)"], ["proof (state)\nthis:\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "hence \"count (mset (map the (fill ?zs (offs ?ms 0)\n        index key (length ?zs) ?mi ?ma))) ?x = count (mset ?zs) ?x\""], ["proof (prove)\nusing this:\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key\n           (length\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key})))\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     (the (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) !\n           i)) =\n    count\n     (mset\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key})))\n     (the (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) !\n           i))", "by (rule_tac fill_offs_enum_count_item [OF A], simp, rule_tac conjI,\n         ((rule_tac mini_lb | rule_tac maxi_ub), erule_tac in_set_nthsD)+)"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key\n         (length\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key})))\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i)) =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "hence \"count (mset (map the (fill ?zs (offs ?ms 0)\n        index key m ?mi ?ma))) ?x = count (mset ?zs) ?x\""], ["proof (prove)\nusing this:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key\n         (length\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key})))\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i)) =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i))\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     (the (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) !\n           i)) =\n    count\n     (mset\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key})))\n     (the (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) !\n           i))", "using O"], ["proof (prove)\nusing this:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key\n         (length\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key})))\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i)) =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i))\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     (the (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) !\n           i)) =\n    count\n     (mset\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key})))\n     (the (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) !\n           i))", "by (simp add: mini_maxi_nths)"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i)) =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "moreover"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i)) =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "have \"0 < count (mset (map the (fill ?zs (offs ?ms 0)\n        index key m ?mi ?ma))) ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < count\n         (mset\n           (map the\n             (fill\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               (offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0)\n               index key m\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))))\n         (the (fill\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                (offs\n                  (enum\n                    (nths (take (Suc (Suc m)) xs)\n                      (- {mini (take (Suc (Suc m)) xs) key,\n                          maxi (take (Suc (Suc m)) xs) key}))\n                    index key\n                    (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                     | Suc (Suc i) \\<Rightarrow> u + m')\n                    (key (take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key))\n                    (key (take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key)))\n                  0)\n                index key m\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)) !\n               i))", "using R"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. 0 < count\n         (mset\n           (map the\n             (fill\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               (offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0)\n               index key m\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))))\n         (the (fill\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                (offs\n                  (enum\n                    (nths (take (Suc (Suc m)) xs)\n                      (- {mini (take (Suc (Suc m)) xs) key,\n                          maxi (take (Suc (Suc m)) xs) key}))\n                    index key\n                    (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                     | Suc (Suc i) \\<Rightarrow> u + m')\n                    (key (take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key))\n                    (key (take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key)))\n                  0)\n                index key m\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)) !\n               i))", "by (simp add: fill_length)"], ["proof (state)\nthis:\n  0 < count\n       (mset\n         (map the\n           (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))))\n       (the (fill\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              (offs\n                (enum\n                  (nths (take (Suc (Suc m)) xs)\n                    (- {mini (take (Suc (Suc m)) xs) key,\n                        maxi (take (Suc (Suc m)) xs) key}))\n                  index key\n                  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                   | Suc (Suc i) \\<Rightarrow> u + m')\n                  (key (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key))\n                  (key (take (Suc (Suc m)) xs !\n                        maxi (take (Suc (Suc m)) xs) key)))\n                0)\n              index key m\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) !\n             i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "ultimately"], ["proof (chain)\npicking this:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i)) =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i))\n  0 < count\n       (mset\n         (map the\n           (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))))\n       (the (fill\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              (offs\n                (enum\n                  (nths (take (Suc (Suc m)) xs)\n                    (- {mini (take (Suc (Suc m)) xs) key,\n                        maxi (take (Suc (Suc m)) xs) key}))\n                  index key\n                  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                   | Suc (Suc i) \\<Rightarrow> u + m')\n                  (key (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key))\n                  (key (take (Suc (Suc m)) xs !\n                        maxi (take (Suc (Suc m)) xs) key)))\n                0)\n              index key m\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) !\n             i))", "have \"?x \\<in> set ?zs\""], ["proof (prove)\nusing this:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i)) =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   (the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i))\n  0 < count\n       (mset\n         (map the\n           (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))))\n       (the (fill\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              (offs\n                (enum\n                  (nths (take (Suc (Suc m)) xs)\n                    (- {mini (take (Suc (Suc m)) xs) key,\n                        maxi (take (Suc (Suc m)) xs) key}))\n                  index key\n                  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                   | Suc (Suc i) \\<Rightarrow> u + m')\n                  (key (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key))\n                  (key (take (Suc (Suc m)) xs !\n                        maxi (take (Suc (Suc m)) xs) key)))\n                0)\n              index key m\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) !\n             i))\n\ngoal (1 subgoal):\n 1. the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i)\n    \\<in> set (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))", "by simp"], ["proof (state)\nthis:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       i)\n  \\<in> set (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            i)\n       \\<in> set (take (Suc (Suc m)) xs)", "thus \"?x \\<in> set ?ws\""], ["proof (prove)\nusing this:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       i)\n  \\<in> set (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         i)\n    \\<in> set (take (Suc (Suc m)) xs)", "by (rule in_set_nthsD)"], ["proof (state)\nthis:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       i)\n  \\<in> set (take (Suc (Suc m)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < m \\<Longrightarrow>\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       ?i)\n  \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "have R: \"\\<And>i. i < Suc (Suc m) \\<Longrightarrow> Suc (Suc m) \\<le> k \\<Longrightarrow>\n      key (?ws ! i) \\<le> key (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"bn_inv p q (v, ns, ?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_inv p q (v, ns, drop (Suc (Suc m)) xs)", "using C"], ["proof (prove)\nusing this:\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. bn_inv p q (v, ns, drop (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  bn_inv p q (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  bn_inv p q (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"add_inv (n - Suc (Suc m)) (v, ns, ?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)", "using H and I"], ["proof (prove)\nusing this:\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"count_inv (\\<lambda>x. count (mset ?ys) x) (v, ns, ?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_inv (count (mset (drop (Suc (Suc m)) xs)))\n     (v, ns, drop (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  count_inv (count (mset (drop (Suc (Suc m)) xs)))\n   (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "ultimately"], ["proof (chain)\npicking this:\n  bn_inv p q (v, ns, drop (Suc (Suc m)) xs)\n  add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)\n  count_inv (count (mset (drop (Suc (Suc m)) xs)))\n   (v, ns, drop (Suc (Suc m)) xs)", "have \"count_inv (\\<lambda>x. count (mset ?ys) x) (?t r' v)\""], ["proof (prove)\nusing this:\n  bn_inv p q (v, ns, drop (Suc (Suc m)) xs)\n  add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)\n  count_inv (count (mset (drop (Suc (Suc m)) xs)))\n   (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. count_inv (count (mset (drop (Suc (Suc m)) xs)))\n     (round index key p q r' (v, ns, drop (Suc (Suc m)) xs))", "by (rule round_count_inv [OF A])"], ["proof (state)\nthis:\n  count_inv (count (mset (drop (Suc (Suc m)) xs)))\n   (round index key p q r' (v, ns, drop (Suc (Suc m)) xs))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "hence S: \"count (mset xs') (xs' ! (k - Suc (Suc m))) =\n        count (mset ?ys) (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  count_inv (count (mset (drop (Suc (Suc m)) xs)))\n   (round index key p q r' (v, ns, drop (Suc (Suc m)) xs))\n\ngoal (1 subgoal):\n 1. count (mset xs') (xs' ! (k - Suc (Suc m))) =\n    count (mset (drop (Suc (Suc m)) xs)) (xs' ! (k - Suc (Suc m)))", "using E"], ["proof (prove)\nusing this:\n  count_inv (count (mset (drop (Suc (Suc m)) xs)))\n   (round index key p q r' (v, ns, drop (Suc (Suc m)) xs))\n  round index key p q r' (v, ns, drop (Suc (Suc m)) xs) = (u', ns', xs')\n\ngoal (1 subgoal):\n 1. count (mset xs') (xs' ! (k - Suc (Suc m))) =\n    count (mset (drop (Suc (Suc m)) xs)) (xs' ! (k - Suc (Suc m)))", "by simp"], ["proof (state)\nthis:\n  count (mset xs') (xs' ! (k - Suc (Suc m))) =\n  count (mset (drop (Suc (Suc m)) xs)) (xs' ! (k - Suc (Suc m)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"k < Suc (Suc (m + length xs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < Suc (Suc (m + length xs'))", "using N and P"], ["proof (prove)\nusing this:\n  k < length ws' + length xs'\n  length ws' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. k < Suc (Suc (m + length xs'))", "by simp"], ["proof (state)\nthis:\n  k < Suc (Suc (m + length xs'))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  k < Suc (Suc (m + length xs'))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "assume \"Suc (Suc m) \\<le> k\""], ["proof (state)\nthis:\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "ultimately"], ["proof (chain)\npicking this:\n  k < Suc (Suc (m + length xs'))\n  Suc (Suc m) \\<le> k", "have \"0 < count (mset xs') (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  k < Suc (Suc (m + length xs'))\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. 0 < count (mset xs') (xs' ! (k - Suc (Suc m)))", "by simp"], ["proof (state)\nthis:\n  0 < count (mset xs') (xs' ! (k - Suc (Suc m)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "hence \"xs' ! (k - Suc (Suc m)) \\<in> set ?ys\""], ["proof (prove)\nusing this:\n  0 < count (mset xs') (xs' ! (k - Suc (Suc m)))\n\ngoal (1 subgoal):\n 1. xs' ! (k - Suc (Suc m)) \\<in> set (drop (Suc (Suc m)) xs)", "using S"], ["proof (prove)\nusing this:\n  0 < count (mset xs') (xs' ! (k - Suc (Suc m)))\n  count (mset xs') (xs' ! (k - Suc (Suc m))) =\n  count (mset (drop (Suc (Suc m)) xs)) (xs' ! (k - Suc (Suc m)))\n\ngoal (1 subgoal):\n 1. xs' ! (k - Suc (Suc m)) \\<in> set (drop (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  xs' ! (k - Suc (Suc m)) \\<in> set (drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "hence \"\\<exists>p < length ?ys. ?ys ! p = xs' ! (k - Suc (Suc m))\""], ["proof (prove)\nusing this:\n  xs' ! (k - Suc (Suc m)) \\<in> set (drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>p<length (drop (Suc (Suc m)) xs).\n       drop (Suc (Suc m)) xs ! p = xs' ! (k - Suc (Suc m))", "by (simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>p<length (drop (Suc (Suc m)) xs).\n     drop (Suc (Suc m)) xs ! p = xs' ! (k - Suc (Suc m))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>p<length (drop (Suc (Suc m)) xs).\n     drop (Suc (Suc m)) xs ! p = xs' ! (k - Suc (Suc m))", "obtain p where\n        T: \"p < length ?ys \\<and> ?ys ! p = xs' ! (k - Suc (Suc m))\""], ["proof (prove)\nusing this:\n  \\<exists>p<length (drop (Suc (Suc m)) xs).\n     drop (Suc (Suc m)) xs ! p = xs' ! (k - Suc (Suc m))\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p < length (drop (Suc (Suc m)) xs) \\<and>\n        drop (Suc (Suc m)) xs ! p =\n        xs' ! (k - Suc (Suc m)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p < length (drop (Suc (Suc m)) xs) \\<and>\n  drop (Suc (Suc m)) xs ! p = xs' ! (k - Suc (Suc m))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"Suc 0 < Suc (length ns) \\<longrightarrow>\n        (\\<forall>j < (0 # offs ns (Suc (Suc m))) ! Suc 0.\n         \\<forall>k \\<in> {(0 # offs ns (Suc (Suc m))) ! Suc 0..<n}.\n           key (xs ! j) \\<le> key (xs ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < Suc (length ns) \\<longrightarrow>\n    (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc 0.\n        \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc 0..<n}.\n           key (xs ! j) \\<le> key (xs ! k))", "using J"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc (length ns).\n     \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n           key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. Suc 0 < Suc (length ns) \\<longrightarrow>\n    (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc 0.\n        \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc 0..<n}.\n           key (xs ! j) \\<le> key (xs ! k))", ".."], ["proof (state)\nthis:\n  Suc 0 < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc 0.\n      \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc 0..<n}.\n         key (xs ! j) \\<le> key (xs ! k))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  Suc 0 < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc 0.\n      \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc 0..<n}.\n         key (xs ! j) \\<le> key (xs ! k))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have U: \"0 < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length ns", "using H [symmetric] and I and T"], ["proof (prove)\nusing this:\n  n = Suc (Suc (foldl (+) 0 ns + m))\n  length xs = n\n  p < length (drop (Suc (Suc m)) xs) \\<and>\n  drop (Suc (Suc m)) xs ! p = xs' ! (k - Suc (Suc m))\n\ngoal (1 subgoal):\n 1. 0 < length ns", "by (rule_tac ccontr, simp)"], ["proof (state)\nthis:\n  0 < length ns\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "ultimately"], ["proof (chain)\npicking this:\n  Suc 0 < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc 0.\n      \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc 0..<n}.\n         key (xs ! j) \\<le> key (xs ! k))\n  0 < length ns", "have \"\\<forall>j < offs ns (Suc (Suc m)) ! 0.\n        \\<forall>k \\<in> {offs ns (Suc (Suc m)) ! 0..<n}. key (xs ! j) \\<le> key (xs ! k)\""], ["proof (prove)\nusing this:\n  Suc 0 < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc 0.\n      \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc 0..<n}.\n         key (xs ! j) \\<le> key (xs ! k))\n  0 < length ns\n\ngoal (1 subgoal):\n 1. \\<forall>j<offs ns (Suc (Suc m)) ! 0.\n       \\<forall>k\\<in>{offs ns (Suc (Suc m)) ! 0..<n}.\n          key (xs ! j) \\<le> key (xs ! k)", "by simp"], ["proof (state)\nthis:\n  \\<forall>j<offs ns (Suc (Suc m)) ! 0.\n     \\<forall>k\\<in>{offs ns (Suc (Suc m)) ! 0..<n}.\n        key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  \\<forall>j<offs ns (Suc (Suc m)) ! 0.\n     \\<forall>k\\<in>{offs ns (Suc (Suc m)) ! 0..<n}.\n        key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "assume \"i < Suc (Suc m)\""], ["proof (state)\nthis:\n  i < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  i < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"offs ns (Suc (Suc m)) ! 0 = Suc (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs ns (Suc (Suc m)) ! 0 = Suc (Suc m)", "using U"], ["proof (prove)\nusing this:\n  0 < length ns\n\ngoal (1 subgoal):\n 1. offs ns (Suc (Suc m)) ! 0 = Suc (Suc m)", "by (subst offs_base_zero, simp, cases ns, simp_all)"], ["proof (state)\nthis:\n  offs ns (Suc (Suc m)) ! 0 = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>j<offs ns (Suc (Suc m)) ! 0.\n     \\<forall>k\\<in>{offs ns (Suc (Suc m)) ! 0..<n}.\n        key (xs ! j) \\<le> key (xs ! k)\n  i < Suc (Suc m)\n  offs ns (Suc (Suc m)) ! 0 = Suc (Suc m)", "have \"\\<forall>k \\<in> {Suc (Suc m)..<n}. key (?ws ! i) \\<le> key (xs ! k)\""], ["proof (prove)\nusing this:\n  \\<forall>j<offs ns (Suc (Suc m)) ! 0.\n     \\<forall>k\\<in>{offs ns (Suc (Suc m)) ! 0..<n}.\n        key (xs ! j) \\<le> key (xs ! k)\n  i < Suc (Suc m)\n  offs ns (Suc (Suc m)) ! 0 = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{Suc (Suc m)..<n}.\n       key (take (Suc (Suc m)) xs ! i) \\<le> key (xs ! k)", "by simp"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{Suc (Suc m)..<n}.\n     key (take (Suc (Suc m)) xs ! i) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{Suc (Suc m)..<n}.\n     key (take (Suc (Suc m)) xs ! i) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"Suc (Suc m) + p \\<in> {Suc (Suc m)..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc m) + p \\<in> {Suc (Suc m)..<n}", "using I and T"], ["proof (prove)\nusing this:\n  length xs = n\n  p < length (drop (Suc (Suc m)) xs) \\<and>\n  drop (Suc (Suc m)) xs ! p = xs' ! (k - Suc (Suc m))\n\ngoal (1 subgoal):\n 1. Suc (Suc m) + p \\<in> {Suc (Suc m)..<n}", "by (simp, arith)"], ["proof (state)\nthis:\n  Suc (Suc m) + p \\<in> {Suc (Suc m)..<n}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>{Suc (Suc m)..<n}.\n     key (take (Suc (Suc m)) xs ! i) \\<le> key (xs ! k)\n  Suc (Suc m) + p \\<in> {Suc (Suc m)..<n}", "have \"key (?ws ! i) \\<le> key (xs ! (Suc (Suc m) + p))\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{Suc (Suc m)..<n}.\n     key (take (Suc (Suc m)) xs ! i) \\<le> key (xs ! k)\n  Suc (Suc m) + p \\<in> {Suc (Suc m)..<n}\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! i) \\<le> key (xs ! (Suc (Suc m) + p))", ".."], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! i) \\<le> key (xs ! (Suc (Suc m) + p))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n       \\<Longrightarrow> key (take (Suc (Suc m)) xs ! i)\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "thus \"key (?ws ! i) \\<le> key (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  key (take (Suc (Suc m)) xs ! i) \\<le> key (xs ! (Suc (Suc m) + p))\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! i) \\<le> key (xs' ! (k - Suc (Suc m)))", "using O and T"], ["proof (prove)\nusing this:\n  key (take (Suc (Suc m)) xs ! i) \\<le> key (xs ! (Suc (Suc m) + p))\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  p < length (drop (Suc (Suc m)) xs) \\<and>\n  drop (Suc (Suc m)) xs ! p = xs' ! (k - Suc (Suc m))\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! i) \\<le> key (xs' ! (k - Suc (Suc m)))", "by simp"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! i) \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n  \\<Longrightarrow> key (take (Suc (Suc m)) xs ! ?i)\n                    \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "assume \"\\<And>ws a b c d e f g h n'.\n      ws = ?ws \\<Longrightarrow> a = (m', r') \\<Longrightarrow> b = m' \\<and> c = r' \\<Longrightarrow>\n      d = (v, ms', ws') \\<Longrightarrow> e = v \\<and> f = (ms', ws') \\<Longrightarrow> g = ms' \\<and> h = ws' \\<Longrightarrow>\n        ?P n' \\<longrightarrow> ?Q n' \\<longrightarrow> ?R\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    (\\<forall>i<length ns.\n                        \\<forall>j<offs ns 0 ! i.\n                           \\<forall>k\\<in>{offs ns 0 ! i..<?n'}.\n                              key (xs ! Suc (Suc (m + j)))\n                              \\<le> key (xs !\n   Suc (Suc (m + k)))) \\<longrightarrow>\n                    (\\<forall>i<length ns'.\n                        \\<forall>j<offs ns' 0 ! i.\n                           \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n                              key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "hence \"?P (n - Suc (Suc m)) \\<longrightarrow> ?Q (n - Suc (Suc m)) \\<longrightarrow> ?R\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    (\\<forall>i<length ns.\n                        \\<forall>j<offs ns 0 ! i.\n                           \\<forall>k\\<in>{offs ns 0 ! i..<?n'}.\n                              key (xs ! Suc (Suc (m + j)))\n                              \\<le> key (xs !\n   Suc (Suc (m + k)))) \\<longrightarrow>\n                    (\\<forall>i<length ns'.\n                        \\<forall>j<offs ns' 0 ! i.\n                           \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n                              key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns = n - Suc (Suc m) \\<and>\n    n - Suc (Suc m) = n - Suc (Suc m) \\<longrightarrow>\n    (\\<forall>i<length ns.\n        \\<forall>j<offs ns 0 ! i.\n           \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n              key (xs ! Suc (Suc (m + j)))\n              \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n    (\\<forall>i<length ns'.\n        \\<forall>j<offs ns' 0 ! i.\n           \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n              key (xs' ! j) \\<le> key (xs' ! k))", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0 ns = n - Suc (Suc m) \\<and>\n  n - Suc (Suc m) = n - Suc (Suc m) \\<longrightarrow>\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n            key (xs ! Suc (Suc (m + j)))\n            \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "hence \"?Q (n - Suc (Suc m)) \\<longrightarrow> ?R\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = n - Suc (Suc m) \\<and>\n  n - Suc (Suc m) = n - Suc (Suc m) \\<longrightarrow>\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n            key (xs ! Suc (Suc (m + j)))\n            \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. (\\<forall>i<length ns.\n        \\<forall>j<offs ns 0 ! i.\n           \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n              key (xs ! Suc (Suc (m + j)))\n              \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n    (\\<forall>i<length ns'.\n        \\<forall>j<offs ns' 0 ! i.\n           \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n              key (xs' ! j) \\<le> key (xs' ! k))", "using H"], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = n - Suc (Suc m) \\<and>\n  n - Suc (Suc m) = n - Suc (Suc m) \\<longrightarrow>\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n            key (xs ! Suc (Suc (m + j)))\n            \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n\ngoal (1 subgoal):\n 1. (\\<forall>i<length ns.\n        \\<forall>j<offs ns 0 ! i.\n           \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n              key (xs ! Suc (Suc (m + j)))\n              \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n    (\\<forall>i<length ns'.\n        \\<forall>j<offs ns' 0 ! i.\n           \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n              key (xs' ! j) \\<le> key (xs' ! k))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n            key (xs ! Suc (Suc (m + j)))\n            \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "moreover"], ["proof (state)\nthis:\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n            key (xs ! Suc (Suc (m + j)))\n            \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "have \"?Q (n - Suc (Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length ns.\n       \\<forall>j<offs ns 0 ! i.\n          \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n             key (xs ! Suc (Suc (m + j))) \\<le> key (xs ! Suc (Suc (m + k)))", "proof ((rule allI, rule impI)+, rule ballI, simp, erule conjE,\n     subst (1 2) append_take_drop_id [of \"Suc (Suc m)\", symmetric],\n     simp only: nth_append O, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "have \"Suc i < Suc (length ns) \\<longrightarrow>\n        (\\<forall>j < (0 # offs ns (Suc (Suc m))) ! Suc i.\n         \\<forall>k \\<in> {(0 # offs ns (Suc (Suc m))) ! Suc i..<n}.\n           key ((xs) ! j) \\<le> key (xs ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < Suc (length ns) \\<longrightarrow>\n    (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc i..<n}.\n           key (xs ! j) \\<le> key (xs ! k))", "using J"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc (length ns).\n     \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n           key (xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. Suc i < Suc (length ns) \\<longrightarrow>\n    (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc i.\n        \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc i..<n}.\n           key (xs ! j) \\<le> key (xs ! k))", ".."], ["proof (state)\nthis:\n  Suc i < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc i.\n      \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc i..<n}.\n         key (xs ! j) \\<le> key (xs ! k))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "moreover"], ["proof (state)\nthis:\n  Suc i < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc i.\n      \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc i..<n}.\n         key (xs ! j) \\<le> key (xs ! k))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "assume \"i < length ns\""], ["proof (state)\nthis:\n  i < length ns\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "ultimately"], ["proof (chain)\npicking this:\n  Suc i < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc i.\n      \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc i..<n}.\n         key (xs ! j) \\<le> key (xs ! k))\n  i < length ns", "have \"j < offs ns 0 ! i \\<longrightarrow>\n        (\\<forall>k \\<in> {offs ns 0 ! i + Suc (Suc m)..<n}.\n          key (xs ! (Suc (Suc m) + j)) \\<le> key (xs ! k))\""], ["proof (prove)\nusing this:\n  Suc i < Suc (length ns) \\<longrightarrow>\n  (\\<forall>j<(0 # offs ns (Suc (Suc m))) ! Suc i.\n      \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! Suc i..<n}.\n         key (xs ! j) \\<le> key (xs ! k))\n  i < length ns\n\ngoal (1 subgoal):\n 1. j < offs ns 0 ! i \\<longrightarrow>\n    (\\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n        key (xs ! (Suc (Suc m) + j)) \\<le> key (xs ! k))", "by (simp, subst (asm) offs_base_zero, simp,\n         subst (asm) (2) offs_base_zero, simp_all)"], ["proof (state)\nthis:\n  j < offs ns 0 ! i \\<longrightarrow>\n  (\\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n      key (xs ! (Suc (Suc m) + j)) \\<le> key (xs ! k))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "moreover"], ["proof (state)\nthis:\n  j < offs ns 0 ! i \\<longrightarrow>\n  (\\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n      key (xs ! (Suc (Suc m) + j)) \\<le> key (xs ! k))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "assume \"j < offs ns 0 ! i\""], ["proof (state)\nthis:\n  j < offs ns 0 ! i\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "ultimately"], ["proof (chain)\npicking this:\n  j < offs ns 0 ! i \\<longrightarrow>\n  (\\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n      key (xs ! (Suc (Suc m) + j)) \\<le> key (xs ! k))\n  j < offs ns 0 ! i", "have \"\\<forall>k \\<in> {offs ns 0 ! i + Suc (Suc m)..<n}.\n        key (?ys ! j) \\<le> key (xs ! k)\""], ["proof (prove)\nusing this:\n  j < offs ns 0 ! i \\<longrightarrow>\n  (\\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n      key (xs ! (Suc (Suc m) + j)) \\<le> key (xs ! k))\n  j < offs ns 0 ! i\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n       key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! k)", "using O"], ["proof (prove)\nusing this:\n  j < offs ns 0 ! i \\<longrightarrow>\n  (\\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n      key (xs ! (Suc (Suc m) + j)) \\<le> key (xs ! k))\n  j < offs ns 0 ! i\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n       key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! k)", "by simp"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n     key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "moreover"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n     key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "assume \"offs ns 0 ! i \\<le> k\" and \"k < n - Suc (Suc m)\""], ["proof (state)\nthis:\n  offs ns 0 ! i \\<le> k\n  k < n - Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "hence \"Suc (Suc m) + k \\<in> {offs ns 0 ! i + Suc (Suc m)..<n}\""], ["proof (prove)\nusing this:\n  offs ns 0 ! i \\<le> k\n  k < n - Suc (Suc m)\n\ngoal (1 subgoal):\n 1. Suc (Suc m) + k \\<in> {offs ns 0 ! i + Suc (Suc m)..<n}", "by simp"], ["proof (state)\nthis:\n  Suc (Suc m) + k \\<in> {offs ns 0 ! i + Suc (Suc m)..<n}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n     key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! k)\n  Suc (Suc m) + k \\<in> {offs ns 0 ! i + Suc (Suc m)..<n}", "have \"key (?ys ! j) \\<le> key (xs ! (Suc (Suc m) + k))\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{offs ns 0 ! i + Suc (Suc m)..<n}.\n     key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! k)\n  Suc (Suc m) + k \\<in> {offs ns 0 ! i + Suc (Suc m)..<n}\n\ngoal (1 subgoal):\n 1. key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! (Suc (Suc m) + k))", ".."], ["proof (state)\nthis:\n  key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! (Suc (Suc m) + k))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length ns; j < offs ns 0 ! i; offs ns 0 ! i \\<le> k;\n        k < n - Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> key (drop (Suc (Suc m)) xs ! j)\n                         \\<le> key (drop (Suc (Suc m)) xs ! k)", "thus \"key (?ys ! j) \\<le> key (?ys ! k)\""], ["proof (prove)\nusing this:\n  key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! (Suc (Suc m) + k))\n\ngoal (1 subgoal):\n 1. key (drop (Suc (Suc m)) xs ! j) \\<le> key (drop (Suc (Suc m)) xs ! k)", "using O"], ["proof (prove)\nusing this:\n  key (drop (Suc (Suc m)) xs ! j) \\<le> key (xs ! (Suc (Suc m) + k))\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. key (drop (Suc (Suc m)) xs ! j) \\<le> key (drop (Suc (Suc m)) xs ! k)", "by simp"], ["proof (state)\nthis:\n  key (drop (Suc (Suc m)) xs ! j) \\<le> key (drop (Suc (Suc m)) xs ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length ns.\n     \\<forall>j<offs ns 0 ! i.\n        \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n           key (xs ! Suc (Suc (m + j))) \\<le> key (xs ! Suc (Suc (m + k)))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n            key (xs ! Suc (Suc (m + j)))\n            \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n  \\<forall>i<length ns.\n     \\<forall>j<offs ns 0 ! i.\n        \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n           key (xs ! Suc (Suc (m + j))) \\<le> key (xs ! Suc (Suc (m + k)))", "have ?R"], ["proof (prove)\nusing this:\n  (\\<forall>i<length ns.\n      \\<forall>j<offs ns 0 ! i.\n         \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n            key (xs ! Suc (Suc (m + j)))\n            \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n  (\\<forall>i<length ns'.\n      \\<forall>j<offs ns' 0 ! i.\n         \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n            key (xs' ! j) \\<le> key (xs' ! k))\n  \\<forall>i<length ns.\n     \\<forall>j<offs ns 0 ! i.\n        \\<forall>k\\<in>{offs ns 0 ! i..<n - Suc (Suc m)}.\n           key (xs ! Suc (Suc (m + j))) \\<le> key (xs ! Suc (Suc (m + k)))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ns'.\n       \\<forall>j<offs ns' 0 ! i.\n          \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n             key (xs' ! j) \\<le> key (xs' ! k)", ".."], ["proof (state)\nthis:\n  \\<forall>i<length ns'.\n     \\<forall>j<offs ns' 0 ! i.\n        \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n           key (xs' ! j) \\<le> key (xs' ! k)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba i j k.\n       \\<lbrakk>\\<And>ws aaa baa c d e f g h n.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aaa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> f = (a, b); g = a \\<and> h = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>i<length ns.\n   \\<forall>j<offs ns 0 ! i.\n      \\<forall>k\\<in>{offs ns 0 ! i..<n}.\n         key (xs ! Suc (Suc (m + j)))\n         \\<le> key (xs ! Suc (Suc (m + k)))) \\<longrightarrow>\n                                     (\\<forall>i<length aa.\n   \\<forall>j<offs aa 0 ! i.\n      \\<forall>k\\<in>{offs aa 0 ! i..<length ba}.\n         key (ba ! j) \\<le> key (ba ! k));\n        \\<forall>i<Suc (length ns).\n           \\<forall>j<(0 # offs ns (Suc (Suc m))) ! i.\n              \\<forall>k\\<in>{(0 # offs ns (Suc (Suc m))) ! i..<n}.\n                 key (xs ! j) \\<le> key (xs ! k);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); i < length a + length aa;\n        j < offs (a @ aa) 0 ! i; foldl (+) (Suc (Suc m)) ns = n;\n        bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n;\n        offs (a @ aa) 0 ! i \\<le> k; k < length b + length ba\\<rbrakk>\n       \\<Longrightarrow> key ((b @ ba) ! j) \\<le> key ((b @ ba) ! k)", "show \"key ((ws' @ xs') ! j) \\<le> key ((ws' @ xs') ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key ((ws' @ xs') ! j) \\<le> key ((ws' @ xs') ! k)", "proof (simp add: nth_append not_less P, (rule_tac [!] conjI,\n     rule_tac [!] impI)+, rule_tac [3] FalseE)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>j < Suc (Suc m); k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> key (ws' ! j) \\<le> key (ws' ! k)\n 2. \\<lbrakk>j < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (ws' ! j) \\<le> key (xs' ! (k - Suc (Suc m)))\n 3. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "assume\n        S: \"j < Suc (Suc m)\" and\n        T: \"k < Suc (Suc m)\""], ["proof (state)\nthis:\n  j < Suc (Suc m)\n  k < Suc (Suc m)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>j < Suc (Suc m); k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> key (ws' ! j) \\<le> key (ws' ! k)\n 2. \\<lbrakk>j < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (ws' ! j) \\<le> key (xs' ! (k - Suc (Suc m)))\n 3. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "from D [symmetric]"], ["proof (chain)\npicking this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u", "show \"key (ws' ! j) \\<le> key (ws' ! k)\""], ["proof (prove)\nusing this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\n\ngoal (1 subgoal):\n 1. key (ws' ! j) \\<le> key (ws' ! k)", "proof (simp add: round_suc_suc_def Let_def split: if_split_asm,\n       (erule_tac [2] conjE)+, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) =\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v = u + m' - m \\<and>\n     ms' = Suc 0 # Suc 0 # replicate m (Suc 0) \\<and>\n     ws' = take (Suc (Suc m)) xs;\n     (u + m' - m, Suc 0 # Suc 0 # replicate m (Suc 0),\n      take (Suc (Suc m)) xs) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs ! j)\n                      \\<le> key (take (Suc (Suc m)) xs ! k)\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "assume U: \"?mi = ?ma\""], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) =\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v = u + m' - m \\<and>\n     ms' = Suc 0 # Suc 0 # replicate m (Suc 0) \\<and>\n     ws' = take (Suc (Suc m)) xs;\n     (u + m' - m, Suc 0 # Suc 0 # replicate m (Suc 0),\n      take (Suc (Suc m)) xs) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs ! j)\n                      \\<le> key (take (Suc (Suc m)) xs ! k)\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "have \"j < length ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length (take (Suc (Suc m)) xs)", "using S and O"], ["proof (prove)\nusing this:\n  j < Suc (Suc m)\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. j < length (take (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  j < length (take (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) =\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v = u + m' - m \\<and>\n     ms' = Suc 0 # Suc 0 # replicate m (Suc 0) \\<and>\n     ws' = take (Suc (Suc m)) xs;\n     (u + m' - m, Suc 0 # Suc 0 # replicate m (Suc 0),\n      take (Suc (Suc m)) xs) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs ! j)\n                      \\<le> key (take (Suc (Suc m)) xs ! k)\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "hence \"?ws ! j \\<in> set ?ws\""], ["proof (prove)\nusing this:\n  j < length (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. take (Suc (Suc m)) xs ! j \\<in> set (take (Suc (Suc m)) xs)", "by (rule nth_mem)"], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! j \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) =\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v = u + m' - m \\<and>\n     ms' = Suc 0 # Suc 0 # replicate m (Suc 0) \\<and>\n     ws' = take (Suc (Suc m)) xs;\n     (u + m' - m, Suc 0 # Suc 0 # replicate m (Suc 0),\n      take (Suc (Suc m)) xs) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs ! j)\n                      \\<le> key (take (Suc (Suc m)) xs ! k)\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "with U"], ["proof (chain)\npicking this:\n  key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n  take (Suc (Suc m)) xs ! j \\<in> set (take (Suc (Suc m)) xs)", "have \"key (?ws ! j) = ?ma\""], ["proof (prove)\nusing this:\n  key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n  take (Suc (Suc m)) xs ! j \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! j) =\n    key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)", "by (rule mini_maxi_keys_eq)"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! j) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) =\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v = u + m' - m \\<and>\n     ms' = Suc 0 # Suc 0 # replicate m (Suc 0) \\<and>\n     ws' = take (Suc (Suc m)) xs;\n     (u + m' - m, Suc 0 # Suc 0 # replicate m (Suc 0),\n      take (Suc (Suc m)) xs) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs ! j)\n                      \\<le> key (take (Suc (Suc m)) xs ! k)\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "moreover"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! j) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) =\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v = u + m' - m \\<and>\n     ms' = Suc 0 # Suc 0 # replicate m (Suc 0) \\<and>\n     ws' = take (Suc (Suc m)) xs;\n     (u + m' - m, Suc 0 # Suc 0 # replicate m (Suc 0),\n      take (Suc (Suc m)) xs) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs ! j)\n                      \\<le> key (take (Suc (Suc m)) xs ! k)\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "have \"k < length ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length (take (Suc (Suc m)) xs)", "using T and O"], ["proof (prove)\nusing this:\n  k < Suc (Suc m)\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. k < length (take (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  k < length (take (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) =\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v = u + m' - m \\<and>\n     ms' = Suc 0 # Suc 0 # replicate m (Suc 0) \\<and>\n     ws' = take (Suc (Suc m)) xs;\n     (u + m' - m, Suc 0 # Suc 0 # replicate m (Suc 0),\n      take (Suc (Suc m)) xs) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs ! j)\n                      \\<le> key (take (Suc (Suc m)) xs ! k)\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "hence \"?ws ! k \\<in> set ?ws\""], ["proof (prove)\nusing this:\n  k < length (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. take (Suc (Suc m)) xs ! k \\<in> set (take (Suc (Suc m)) xs)", "by (rule nth_mem)"], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! k \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) =\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v = u + m' - m \\<and>\n     ms' = Suc 0 # Suc 0 # replicate m (Suc 0) \\<and>\n     ws' = take (Suc (Suc m)) xs;\n     (u + m' - m, Suc 0 # Suc 0 # replicate m (Suc 0),\n      take (Suc (Suc m)) xs) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs ! j)\n                      \\<le> key (take (Suc (Suc m)) xs ! k)\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "with U"], ["proof (chain)\npicking this:\n  key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n  take (Suc (Suc m)) xs ! k \\<in> set (take (Suc (Suc m)) xs)", "have \"key (?ws ! k) = ?ma\""], ["proof (prove)\nusing this:\n  key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n  take (Suc (Suc m)) xs ! k \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! k) =\n    key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)", "by (rule mini_maxi_keys_eq)"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! k) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) =\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v = u + m' - m \\<and>\n     ms' = Suc 0 # Suc 0 # replicate m (Suc 0) \\<and>\n     ws' = take (Suc (Suc m)) xs;\n     (u + m' - m, Suc 0 # Suc 0 # replicate m (Suc 0),\n      take (Suc (Suc m)) xs) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs ! j)\n                      \\<le> key (take (Suc (Suc m)) xs ! k)\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "ultimately"], ["proof (chain)\npicking this:\n  key (take (Suc (Suc m)) xs ! j) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n  key (take (Suc (Suc m)) xs ! k) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)", "show \"key (?ws ! j) \\<le> key (?ws ! k)\""], ["proof (prove)\nusing this:\n  key (take (Suc (Suc m)) xs ! j) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n  key (take (Suc (Suc m)) xs ! k) =\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! j) \\<le> key (take (Suc (Suc m)) xs ! k)", "by simp"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! j) \\<le> key (take (Suc (Suc m)) xs ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "assume U: \"ms' = Suc 0 # ?ms @ [Suc 0]\""], ["proof (state)\nthis:\n  ms' =\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "hence V: \"j < (0 # offs (?ms @ Suc 0 # ns') (Suc 0)) ! i\""], ["proof (prove)\nusing this:\n  ms' =\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0]\n\ngoal (1 subgoal):\n 1. j < (0 #\n         offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) @\n           Suc 0 # ns')\n          (Suc 0)) !\n        i", "using L"], ["proof (prove)\nusing this:\n  ms' =\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0]\n  j < offs (ms' @ ns') 0 ! i\n\ngoal (1 subgoal):\n 1. j < (0 #\n         offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) @\n           Suc 0 # ns')\n          (Suc 0)) !\n        i", "by simp"], ["proof (state)\nthis:\n  j < (0 #\n       offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         Suc 0 # ns')\n        (Suc 0)) !\n      i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "hence \"\\<exists>i'. i = Suc i'\""], ["proof (prove)\nusing this:\n  j < (0 #\n       offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         Suc 0 # ns')\n        (Suc 0)) !\n      i\n\ngoal (1 subgoal):\n 1. \\<exists>i'. i = Suc i'", "by (rule_tac nat.exhaust [of i], simp_all)"], ["proof (state)\nthis:\n  \\<exists>i'. i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i'. i = Suc i'", "obtain i' where W: \"i = Suc i'\""], ["proof (prove)\nusing this:\n  \\<exists>i'. i = Suc i'\n\ngoal (1 subgoal):\n 1. (\\<And>i'. i = Suc i' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "have \"i < Suc (Suc (?k + length ns'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Suc (Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                   | Suc (Suc i) \\<Rightarrow> u + m') +\n                  length ns'))", "using K and U"], ["proof (prove)\nusing this:\n  i < length ms' + length ns'\n  ms' =\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0]\n\ngoal (1 subgoal):\n 1. i < Suc (Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                   | Suc (Suc i) \\<Rightarrow> u + m') +\n                  length ns'))", "by (simp add: enum_length)"], ["proof (state)\nthis:\n  i < Suc (Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m') +\n                length ns'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "hence X: \"i' < Suc (?k + length ns')\""], ["proof (prove)\nusing this:\n  i < Suc (Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m') +\n                length ns'))\n\ngoal (1 subgoal):\n 1. i' < Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m') +\n              length ns')", "using W"], ["proof (prove)\nusing this:\n  i < Suc (Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m') +\n                length ns'))\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. i' < Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m') +\n              length ns')", "by simp"], ["proof (state)\nthis:\n  i' < Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m') +\n            length ns')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "hence Y: \"j < Suc (offs (?ms @ Suc 0 # ns') 0 ! i')\""], ["proof (prove)\nusing this:\n  i' < Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m') +\n            length ns')\n\ngoal (1 subgoal):\n 1. j < Suc (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)) @\n               Suc 0 # ns')\n              0 !\n             i')", "using V and W"], ["proof (prove)\nusing this:\n  i' < Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m') +\n            length ns')\n  j < (0 #\n       offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         Suc 0 # ns')\n        (Suc 0)) !\n      i\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. j < Suc (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)) @\n               Suc 0 # ns')\n              0 !\n             i')", "by (simp add: enum_length offs_suc)"], ["proof (state)\nthis:\n  j < Suc (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) @\n             Suc 0 # ns')\n            0 !\n           i')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "have \"(0 # offs (?ms @ Suc 0 # ns') (Suc 0)) ! i \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 #\n     offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n       Suc 0 # ns')\n      (Suc 0)) !\n    i\n    \\<le> k", "using M and U"], ["proof (prove)\nusing this:\n  offs (ms' @ ns') 0 ! i \\<le> k\n  ms' =\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0]\n\ngoal (1 subgoal):\n 1. (0 #\n     offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n       Suc 0 # ns')\n      (Suc 0)) !\n    i\n    \\<le> k", "by simp"], ["proof (state)\nthis:\n  (0 #\n   offs\n    (enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     Suc 0 # ns')\n    (Suc 0)) !\n  i\n  \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "hence \"Suc (offs (?ms @ Suc 0 # ns') 0 ! i') \\<le> k\""], ["proof (prove)\nusing this:\n  (0 #\n   offs\n    (enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     Suc 0 # ns')\n    (Suc 0)) !\n  i\n  \\<le> k\n\ngoal (1 subgoal):\n 1. Suc (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) @\n           Suc 0 # ns')\n          0 !\n         i')\n    \\<le> k", "using W and X"], ["proof (prove)\nusing this:\n  (0 #\n   offs\n    (enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     Suc 0 # ns')\n    (Suc 0)) !\n  i\n  \\<le> k\n  i = Suc i'\n  i' < Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m') +\n            length ns')\n\ngoal (1 subgoal):\n 1. Suc (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)) @\n           Suc 0 # ns')\n          0 !\n         i')\n    \\<le> k", "by (simp add: enum_length offs_suc)"], ["proof (state)\nthis:\n  Suc (offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         Suc 0 # ns')\n        0 !\n       i')\n  \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "moreover"], ["proof (state)\nthis:\n  Suc (offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         Suc 0 # ns')\n        0 !\n       i')\n  \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "from this"], ["proof (chain)\npicking this:\n  Suc (offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         Suc 0 # ns')\n        0 !\n       i')\n  \\<le> k", "have \"\\<exists>k'. k = Suc k'\""], ["proof (prove)\nusing this:\n  Suc (offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         Suc 0 # ns')\n        0 !\n       i')\n  \\<le> k\n\ngoal (1 subgoal):\n 1. \\<exists>k'. k = Suc k'", "by (rule_tac nat.exhaust [of k], simp_all)"], ["proof (state)\nthis:\n  \\<exists>k'. k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k'. k = Suc k'", "obtain k' where Z: \"k = Suc k'\""], ["proof (prove)\nusing this:\n  \\<exists>k'. k = Suc k'\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "ultimately"], ["proof (chain)\npicking this:\n  Suc (offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         Suc 0 # ns')\n        0 !\n       i')\n  \\<le> k\n  k = Suc k'", "have AA: \"offs (?ms @ Suc 0 # ns') 0 ! i' \\<le> k'\""], ["proof (prove)\nusing this:\n  Suc (offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         Suc 0 # ns')\n        0 !\n       i')\n  \\<le> k\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. offs\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      Suc 0 # ns')\n     0 !\n    i'\n    \\<le> k'", "by simp"], ["proof (state)\nthis:\n  offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n    Suc 0 # ns')\n   0 !\n  i'\n  \\<le> k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "have AB: \"j \\<le> k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> k'", "using Y and AA"], ["proof (prove)\nusing this:\n  j < Suc (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) @\n             Suc 0 # ns')\n            0 !\n           i')\n  offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n    Suc 0 # ns')\n   0 !\n  i'\n  \\<le> k'\n\ngoal (1 subgoal):\n 1. j \\<le> k'", "by simp"], ["proof (state)\nthis:\n  j \\<le> k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m');\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\\<rbrakk>\n    \\<Longrightarrow> key ((take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key #\n                            map the\n                             (fill\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               (offs\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key)))\n                                 0)\n                               index key m\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key))) @\n                            [take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key]) !\n                           j)\n                      \\<le> key ((take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key #\n                                  map the\n                                   (fill\n                                     (nths (take (Suc (Suc m)) xs)\n (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                     (offs\n (enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n 0)\n                                     index key m\n                                     (key\n (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                     (key\n (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n                                  [take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key]) !\n                                 k)", "with Z"], ["proof (chain)\npicking this:\n  k = Suc k'\n  j \\<le> k'", "show\n         \"key ((?xmi # map the (fill ?zs (offs ?ms 0) index key m ?mi ?ma) @\n            [?xma]) ! j) \\<le>\n          key ((?xmi # map the (fill ?zs (offs ?ms 0) index key m ?mi ?ma) @\n            [?xma]) ! k)\""], ["proof (prove)\nusing this:\n  k = Suc k'\n  j \\<le> k'\n\ngoal (1 subgoal):\n 1. key ((take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n          map the\n           (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key))) @\n          [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) !\n         j)\n    \\<le> key ((take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n                map the\n                 (fill\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   (offs\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))\n                     0)\n                   index key m\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key))) @\n                [take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key]) !\n               k)", "proof (cases j, case_tac [2] \"j < Suc m\", simp_all add: nth_append\n         not_less fill_length, rule_tac [1-2] conjI, rule_tac [1-4] impI,\n         rule_tac [5] FalseE, simp_all)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>j = 0; k' < m; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key (the (fill\n (nths (take (Suc (Suc m)) xs)\n   (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n (offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n   0)\n index key m\n (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\nk'))\n 2. \\<lbrakk>j = 0; m \\<le> k'; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key ([take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key] !\n                                 (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 4. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 5. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"k' < m\""], ["proof (state)\nthis:\n  k' < m\n\ngoal (5 subgoals):\n 1. \\<lbrakk>j = 0; k' < m; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key (the (fill\n (nths (take (Suc (Suc m)) xs)\n   (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n (offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n   0)\n index key m\n (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\nk'))\n 2. \\<lbrakk>j = 0; m \\<le> k'; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key ([take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key] !\n                                 (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 4. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 5. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! k') \\<in> set ?ws\""], ["proof (prove)\nusing this:\n  k' < m\n\ngoal (1 subgoal):\n 1. the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         k')\n    \\<in> set (take (Suc (Suc m)) xs)", "by (rule Q)"], ["proof (state)\nthis:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       k')\n  \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>j = 0; k' < m; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key (the (fill\n (nths (take (Suc (Suc m)) xs)\n   (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n (offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n   0)\n index key m\n (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\nk'))\n 2. \\<lbrakk>j = 0; m \\<le> k'; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key ([take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key] !\n                                 (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 4. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 5. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"?mi \\<le> key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! k'))\""], ["proof (prove)\nusing this:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       k')\n  \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key)\n    \\<le> key (the (fill\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     (offs\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key)))\n                       0)\n                     index key m\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)) !\n                    k'))", "by (rule mini_lb)"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key)\n  \\<le> key (the (fill\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   (offs\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))\n                     0)\n                   index key m\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)) !\n                  k'))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>j = 0; m \\<le> k'; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key ([take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key] !\n                                 (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 4. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>j = 0; m \\<le> k'; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key ([take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key] !\n                                 (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 4. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"m \\<le> k'\""], ["proof (state)\nthis:\n  m \\<le> k'\n\ngoal (4 subgoals):\n 1. \\<lbrakk>j = 0; m \\<le> k'; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key ([take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key] !\n                                 (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 4. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"k' = m\""], ["proof (prove)\nusing this:\n  m \\<le> k'\n\ngoal (1 subgoal):\n 1. k' = m", "using T and Z"], ["proof (prove)\nusing this:\n  m \\<le> k'\n  k < Suc (Suc m)\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. k' = m", "by simp"], ["proof (state)\nthis:\n  k' = m\n\ngoal (4 subgoals):\n 1. \\<lbrakk>j = 0; m \\<le> k'; k = Suc k'\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key ([take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key] !\n                                 (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 4. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"?mi \\<le> key ([?xma] ! (k' - m))\""], ["proof (prove)\nusing this:\n  k' = m\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key)\n    \\<le> key ([take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] !\n               (k' - m))", "by (simp, rule_tac mini_maxi_keys_le, rule_tac nth_mem [of 0],\n             subst O, simp)"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key)\n  \\<le> key ([take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] !\n             (k' - m))\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "fix j'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "have \"sort_inv key (0, ?ms, map the (fill ?zs (offs ?ms 0) index key\n            (length ?zs) ?mi ?ma))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_inv key\n     (0, enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)),\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key\n         (length\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key})))\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))", "by (rule fill_sort_inv [OF A B], simp, rule conjI,\n             ((rule mini_lb | rule maxi_ub), erule in_set_nthsD)+)"], ["proof (state)\nthis:\n  sort_inv key\n   (0, enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)),\n    map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key\n       (length\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key})))\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"sort_inv key (0, ?ms, map the (fill ?zs (offs ?ms 0) index key\n            m ?mi ?ma))\""], ["proof (prove)\nusing this:\n  sort_inv key\n   (0, enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)),\n    map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key\n       (length\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key})))\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))\n\ngoal (1 subgoal):\n 1. sort_inv key\n     (0, enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)),\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))", "using O"], ["proof (prove)\nusing this:\n  sort_inv key\n   (0, enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)),\n    map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key\n       (length\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key})))\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. sort_inv key\n     (0, enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)),\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))", "by (simp add: mini_maxi_nths)"], ["proof (state)\nthis:\n  sort_inv key\n   (0, enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)),\n    map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key m\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<forall>i < ?k. \\<forall>j < offs ?ms 0 ! i. \\<forall>k \\<in> {offs ?ms 0 ! i..<m}.\n            key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! j)) \\<le>\n            key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! k))\""], ["proof (prove)\nusing this:\n  sort_inv key\n   (0, enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)),\n    map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key m\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))\n\ngoal (1 subgoal):\n 1. \\<forall>i<case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m'.\n       \\<forall>j<offs\n                   (enum\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     index key\n                     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                      | Suc (Suc i) \\<Rightarrow> u + m')\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)))\n                   0 !\n                  i.\n          \\<forall>k\\<in>{offs\n                           (enum\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             index key\n                             (case m of 0 \\<Rightarrow> m\n                              | Suc 0 \\<Rightarrow> m\n                              | Suc (Suc i) \\<Rightarrow> u + m')\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))\n                           0 !\n                          i..<m}.\n             key (the (fill\n                        (nths (take (Suc (Suc m)) xs)\n                          (- {mini (take (Suc (Suc m)) xs) key,\n                              maxi (take (Suc (Suc m)) xs) key}))\n                        (offs\n                          (enum\n                            (nths (take (Suc (Suc m)) xs)\n                              (- {mini (take (Suc (Suc m)) xs) key,\n                                  maxi (take (Suc (Suc m)) xs) key}))\n                            index key\n                            (case m of 0 \\<Rightarrow> m\n                             | Suc 0 \\<Rightarrow> m\n                             | Suc (Suc i) \\<Rightarrow> u + m')\n                            (key (take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key))\n                            (key (take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key)))\n                          0)\n                        index key m\n                        (key (take (Suc (Suc m)) xs !\n                              mini (take (Suc (Suc m)) xs) key))\n                        (key (take (Suc (Suc m)) xs !\n                              maxi (take (Suc (Suc m)) xs) key)) !\n                       j))\n             \\<le> key (the (fill\n                              (nths (take (Suc (Suc m)) xs)\n                                (- {mini (take (Suc (Suc m)) xs) key,\n                                    maxi (take (Suc (Suc m)) xs) key}))\n                              (offs\n                                (enum\n                                  (nths (take (Suc (Suc m)) xs)\n                                    (- {mini (take (Suc (Suc m)) xs) key,\n  maxi (take (Suc (Suc m)) xs) key}))\n                                  index key\n                                  (case m of 0 \\<Rightarrow> m\n                                   | Suc 0 \\<Rightarrow> m\n                                   | Suc (Suc i) \\<Rightarrow> u + m')\n                                  (key (take (Suc (Suc m)) xs !\n  mini (take (Suc (Suc m)) xs) key))\n                                  (key (take (Suc (Suc m)) xs !\n  maxi (take (Suc (Suc m)) xs) key)))\n                                0)\n                              index key m\n                              (key (take (Suc (Suc m)) xs !\n                                    mini (take (Suc (Suc m)) xs) key))\n                              (key (take (Suc (Suc m)) xs !\n                                    maxi (take (Suc (Suc m)) xs) key)) !\n                             k))", "by (simp add: enum_length fill_length)"], ["proof (state)\nthis:\n  \\<forall>i<case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m'.\n     \\<forall>j<offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0 !\n                i.\n        \\<forall>k\\<in>{offs\n                         (enum\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           index key\n                           (case m of 0 \\<Rightarrow> m\n                            | Suc 0 \\<Rightarrow> m\n                            | Suc (Suc i) \\<Rightarrow> u + m')\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key)))\n                         0 !\n                        i..<m}.\n           key (the (fill\n                      (nths (take (Suc (Suc m)) xs)\n                        (- {mini (take (Suc (Suc m)) xs) key,\n                            maxi (take (Suc (Suc m)) xs) key}))\n                      (offs\n                        (enum\n                          (nths (take (Suc (Suc m)) xs)\n                            (- {mini (take (Suc (Suc m)) xs) key,\n                                maxi (take (Suc (Suc m)) xs) key}))\n                          index key\n                          (case m of 0 \\<Rightarrow> m\n                           | Suc 0 \\<Rightarrow> m\n                           | Suc (Suc i) \\<Rightarrow> u + m')\n                          (key (take (Suc (Suc m)) xs !\n                                mini (take (Suc (Suc m)) xs) key))\n                          (key (take (Suc (Suc m)) xs !\n                                maxi (take (Suc (Suc m)) xs) key)))\n                        0)\n                      index key m\n                      (key (take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key))\n                      (key (take (Suc (Suc m)) xs !\n                            maxi (take (Suc (Suc m)) xs) key)) !\n                     j))\n           \\<le> key (the (fill\n                            (nths (take (Suc (Suc m)) xs)\n                              (- {mini (take (Suc (Suc m)) xs) key,\n                                  maxi (take (Suc (Suc m)) xs) key}))\n                            (offs\n                              (enum\n                                (nths (take (Suc (Suc m)) xs)\n                                  (- {mini (take (Suc (Suc m)) xs) key,\nmaxi (take (Suc (Suc m)) xs) key}))\n                                index key\n                                (case m of 0 \\<Rightarrow> m\n                                 | Suc 0 \\<Rightarrow> m\n                                 | Suc (Suc i) \\<Rightarrow> u + m')\n                                (key (take (Suc (Suc m)) xs !\nmini (take (Suc (Suc m)) xs) key))\n                                (key (take (Suc (Suc m)) xs !\nmaxi (take (Suc (Suc m)) xs) key)))\n                              0)\n                            index key m\n                            (key (take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key))\n                            (key (take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key)) !\n                           k))\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m'.\n     \\<forall>j<offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0 !\n                i.\n        \\<forall>k\\<in>{offs\n                         (enum\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           index key\n                           (case m of 0 \\<Rightarrow> m\n                            | Suc 0 \\<Rightarrow> m\n                            | Suc (Suc i) \\<Rightarrow> u + m')\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key)))\n                         0 !\n                        i..<m}.\n           key (the (fill\n                      (nths (take (Suc (Suc m)) xs)\n                        (- {mini (take (Suc (Suc m)) xs) key,\n                            maxi (take (Suc (Suc m)) xs) key}))\n                      (offs\n                        (enum\n                          (nths (take (Suc (Suc m)) xs)\n                            (- {mini (take (Suc (Suc m)) xs) key,\n                                maxi (take (Suc (Suc m)) xs) key}))\n                          index key\n                          (case m of 0 \\<Rightarrow> m\n                           | Suc 0 \\<Rightarrow> m\n                           | Suc (Suc i) \\<Rightarrow> u + m')\n                          (key (take (Suc (Suc m)) xs !\n                                mini (take (Suc (Suc m)) xs) key))\n                          (key (take (Suc (Suc m)) xs !\n                                maxi (take (Suc (Suc m)) xs) key)))\n                        0)\n                      index key m\n                      (key (take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key))\n                      (key (take (Suc (Suc m)) xs !\n                            maxi (take (Suc (Suc m)) xs) key)) !\n                     j))\n           \\<le> key (the (fill\n                            (nths (take (Suc (Suc m)) xs)\n                              (- {mini (take (Suc (Suc m)) xs) key,\n                                  maxi (take (Suc (Suc m)) xs) key}))\n                            (offs\n                              (enum\n                                (nths (take (Suc (Suc m)) xs)\n                                  (- {mini (take (Suc (Suc m)) xs) key,\nmaxi (take (Suc (Suc m)) xs) key}))\n                                index key\n                                (case m of 0 \\<Rightarrow> m\n                                 | Suc 0 \\<Rightarrow> m\n                                 | Suc (Suc i) \\<Rightarrow> u + m')\n                                (key (take (Suc (Suc m)) xs !\nmini (take (Suc (Suc m)) xs) key))\n                                (key (take (Suc (Suc m)) xs !\nmaxi (take (Suc (Suc m)) xs) key)))\n                              0)\n                            index key m\n                            (key (take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key))\n                            (key (take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key)) !\n                           k))\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "assume AC: \"k' < m\""], ["proof (state)\nthis:\n  k' < m\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence AD: \"offs (?ms @ Suc 0 # ns') 0 ! i' < m\""], ["proof (prove)\nusing this:\n  k' < m\n\ngoal (1 subgoal):\n 1. offs\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      Suc 0 # ns')\n     0 !\n    i'\n    < m", "using AA"], ["proof (prove)\nusing this:\n  k' < m\n  offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n    Suc 0 # ns')\n   0 !\n  i'\n  \\<le> k'\n\ngoal (1 subgoal):\n 1. offs\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      Suc 0 # ns')\n     0 !\n    i'\n    < m", "by simp"], ["proof (state)\nthis:\n  offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n    Suc 0 # ns')\n   0 !\n  i'\n  < m\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "have AE: \"i' < ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')", "proof (rule contrapos_pp [OF AD], simp add: not_less offs_append\n           nth_append offs_length enum_length)"], ["proof (state)\ngoal (1 subgoal):\n 1. (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n     | Suc (Suc i) \\<Rightarrow> u + m')\n    \\<le> i' \\<Longrightarrow>\n    m \\<le> (foldl (+) 0\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key))) #\n             offs ns'\n              (Suc (foldl (+) 0\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))))) !\n            (i' -\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m'))", "have \"0 < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m", "using AC"], ["proof (prove)\nusing this:\n  k' < m\n\ngoal (1 subgoal):\n 1. 0 < m", "by simp"], ["proof (state)\nthis:\n  0 < m\n\ngoal (1 subgoal):\n 1. (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n     | Suc (Suc i) \\<Rightarrow> u + m')\n    \\<le> i' \\<Longrightarrow>\n    m \\<le> (foldl (+) 0\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key))) #\n             offs ns'\n              (Suc (foldl (+) 0\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))))) !\n            (i' -\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m'))", "hence \"0 < ?k\""], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (1 subgoal):\n 1. 0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')", "by (drule_tac bn_comp_fst_nonzero [OF G], subst (asm) F,\n               simp split: nat.split)"], ["proof (state)\nthis:\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n     | Suc (Suc i) \\<Rightarrow> u + m')\n    \\<le> i' \\<Longrightarrow>\n    m \\<le> (foldl (+) 0\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key))) #\n             offs ns'\n              (Suc (foldl (+) 0\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))))) !\n            (i' -\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m'))", "with A"], ["proof (chain)\npicking this:\n  index_less index key\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')", "have \"foldl (+) 0 ?ms = length ?zs\""], ["proof (prove)\nusing this:\n  index_less index key\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    length\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))", "by (rule enum_add, simp, rule_tac conjI,\n               ((rule_tac mini_lb | rule_tac maxi_ub), erule_tac in_set_nthsD)+)"], ["proof (state)\nthis:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n     | Suc (Suc i) \\<Rightarrow> u + m')\n    \\<le> i' \\<Longrightarrow>\n    m \\<le> (foldl (+) 0\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key))) #\n             offs ns'\n              (Suc (foldl (+) 0\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))))) !\n            (i' -\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m'))", "hence \"foldl (+) 0 ?ms = m\""], ["proof (prove)\nusing this:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    m", "using O"], ["proof (prove)\nusing this:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    m", "by (simp add: mini_maxi_nths)"], ["proof (state)\nthis:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  m\n\ngoal (1 subgoal):\n 1. (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n     | Suc (Suc i) \\<Rightarrow> u + m')\n    \\<le> i' \\<Longrightarrow>\n    m \\<le> (foldl (+) 0\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key))) #\n             offs ns'\n              (Suc (foldl (+) 0\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))))) !\n            (i' -\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m'))", "with X"], ["proof (chain)\npicking this:\n  i' < Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m') +\n            length ns')\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  m", "show \"m \\<le> (foldl (+) 0 ?ms #\n              offs ns' (Suc (foldl (+) 0 ?ms))) ! (i' - ?k)\""], ["proof (prove)\nusing this:\n  i' < Suc ((case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m') +\n            length ns')\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  m\n\ngoal (1 subgoal):\n 1. m \\<le> (foldl (+) 0\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key))) #\n             offs ns'\n              (Suc (foldl (+) 0\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))))) !\n            (i' -\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m'))", "by (cases \"i' - ?k\", simp_all, subst offs_base_zero, simp_all)"], ["proof (state)\nthis:\n  m \\<le> (foldl (+) 0\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key))) #\n           offs ns'\n            (Suc (foldl (+) 0\n                   (enum\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     index key\n                     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                      | Suc (Suc i) \\<Rightarrow> u + m')\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)))))) !\n          (i' -\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i' < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m'.\n     \\<forall>j<offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0 !\n                i.\n        \\<forall>k\\<in>{offs\n                         (enum\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           index key\n                           (case m of 0 \\<Rightarrow> m\n                            | Suc 0 \\<Rightarrow> m\n                            | Suc (Suc i) \\<Rightarrow> u + m')\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key)))\n                         0 !\n                        i..<m}.\n           key (the (fill\n                      (nths (take (Suc (Suc m)) xs)\n                        (- {mini (take (Suc (Suc m)) xs) key,\n                            maxi (take (Suc (Suc m)) xs) key}))\n                      (offs\n                        (enum\n                          (nths (take (Suc (Suc m)) xs)\n                            (- {mini (take (Suc (Suc m)) xs) key,\n                                maxi (take (Suc (Suc m)) xs) key}))\n                          index key\n                          (case m of 0 \\<Rightarrow> m\n                           | Suc 0 \\<Rightarrow> m\n                           | Suc (Suc i) \\<Rightarrow> u + m')\n                          (key (take (Suc (Suc m)) xs !\n                                mini (take (Suc (Suc m)) xs) key))\n                          (key (take (Suc (Suc m)) xs !\n                                maxi (take (Suc (Suc m)) xs) key)))\n                        0)\n                      index key m\n                      (key (take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key))\n                      (key (take (Suc (Suc m)) xs !\n                            maxi (take (Suc (Suc m)) xs) key)) !\n                     j))\n           \\<le> key (the (fill\n                            (nths (take (Suc (Suc m)) xs)\n                              (- {mini (take (Suc (Suc m)) xs) key,\n                                  maxi (take (Suc (Suc m)) xs) key}))\n                            (offs\n                              (enum\n                                (nths (take (Suc (Suc m)) xs)\n                                  (- {mini (take (Suc (Suc m)) xs) key,\nmaxi (take (Suc (Suc m)) xs) key}))\n                                index key\n                                (case m of 0 \\<Rightarrow> m\n                                 | Suc 0 \\<Rightarrow> m\n                                 | Suc (Suc i) \\<Rightarrow> u + m')\n                                (key (take (Suc (Suc m)) xs !\nmini (take (Suc (Suc m)) xs) key))\n                                (key (take (Suc (Suc m)) xs !\nmaxi (take (Suc (Suc m)) xs) key)))\n                              0)\n                            index key m\n                            (key (take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key))\n                            (key (take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key)) !\n                           k))\n  i' < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')", "have \"\\<forall>j < offs ?ms 0 ! i'. \\<forall>k \\<in> {offs ?ms 0 ! i'..<m}.\n            key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! j)) \\<le>\n            key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! k))\""], ["proof (prove)\nusing this:\n  \\<forall>i<case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m'.\n     \\<forall>j<offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0 !\n                i.\n        \\<forall>k\\<in>{offs\n                         (enum\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           index key\n                           (case m of 0 \\<Rightarrow> m\n                            | Suc 0 \\<Rightarrow> m\n                            | Suc (Suc i) \\<Rightarrow> u + m')\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key)))\n                         0 !\n                        i..<m}.\n           key (the (fill\n                      (nths (take (Suc (Suc m)) xs)\n                        (- {mini (take (Suc (Suc m)) xs) key,\n                            maxi (take (Suc (Suc m)) xs) key}))\n                      (offs\n                        (enum\n                          (nths (take (Suc (Suc m)) xs)\n                            (- {mini (take (Suc (Suc m)) xs) key,\n                                maxi (take (Suc (Suc m)) xs) key}))\n                          index key\n                          (case m of 0 \\<Rightarrow> m\n                           | Suc 0 \\<Rightarrow> m\n                           | Suc (Suc i) \\<Rightarrow> u + m')\n                          (key (take (Suc (Suc m)) xs !\n                                mini (take (Suc (Suc m)) xs) key))\n                          (key (take (Suc (Suc m)) xs !\n                                maxi (take (Suc (Suc m)) xs) key)))\n                        0)\n                      index key m\n                      (key (take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key))\n                      (key (take (Suc (Suc m)) xs !\n                            maxi (take (Suc (Suc m)) xs) key)) !\n                     j))\n           \\<le> key (the (fill\n                            (nths (take (Suc (Suc m)) xs)\n                              (- {mini (take (Suc (Suc m)) xs) key,\n                                  maxi (take (Suc (Suc m)) xs) key}))\n                            (offs\n                              (enum\n                                (nths (take (Suc (Suc m)) xs)\n                                  (- {mini (take (Suc (Suc m)) xs) key,\nmaxi (take (Suc (Suc m)) xs) key}))\n                                index key\n                                (case m of 0 \\<Rightarrow> m\n                                 | Suc 0 \\<Rightarrow> m\n                                 | Suc (Suc i) \\<Rightarrow> u + m')\n                                (key (take (Suc (Suc m)) xs !\nmini (take (Suc (Suc m)) xs) key))\n                                (key (take (Suc (Suc m)) xs !\nmaxi (take (Suc (Suc m)) xs) key)))\n                              0)\n                            index key m\n                            (key (take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key))\n                            (key (take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key)) !\n                           k))\n  i' < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. \\<forall>j<offs\n                (enum\n                  (nths (take (Suc (Suc m)) xs)\n                    (- {mini (take (Suc (Suc m)) xs) key,\n                        maxi (take (Suc (Suc m)) xs) key}))\n                  index key\n                  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                   | Suc (Suc i) \\<Rightarrow> u + m')\n                  (key (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key))\n                  (key (take (Suc (Suc m)) xs !\n                        maxi (take (Suc (Suc m)) xs) key)))\n                0 !\n               i'.\n       \\<forall>k\\<in>{offs\n                        (enum\n                          (nths (take (Suc (Suc m)) xs)\n                            (- {mini (take (Suc (Suc m)) xs) key,\n                                maxi (take (Suc (Suc m)) xs) key}))\n                          index key\n                          (case m of 0 \\<Rightarrow> m\n                           | Suc 0 \\<Rightarrow> m\n                           | Suc (Suc i) \\<Rightarrow> u + m')\n                          (key (take (Suc (Suc m)) xs !\n                                mini (take (Suc (Suc m)) xs) key))\n                          (key (take (Suc (Suc m)) xs !\n                                maxi (take (Suc (Suc m)) xs) key)))\n                        0 !\n                       i'..<m}.\n          key (the (fill\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     (offs\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key)))\n                       0)\n                     index key m\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)) !\n                    j))\n          \\<le> key (the (fill\n                           (nths (take (Suc (Suc m)) xs)\n                             (- {mini (take (Suc (Suc m)) xs) key,\n                                 maxi (take (Suc (Suc m)) xs) key}))\n                           (offs\n                             (enum\n                               (nths (take (Suc (Suc m)) xs)\n                                 (- {mini (take (Suc (Suc m)) xs) key,\n                                     maxi (take (Suc (Suc m)) xs) key}))\n                               index key\n                               (case m of 0 \\<Rightarrow> m\n                                | Suc 0 \\<Rightarrow> m\n                                | Suc (Suc i) \\<Rightarrow> u + m')\n                               (key (take (Suc (Suc m)) xs !\n                                     mini (take (Suc (Suc m)) xs) key))\n                               (key (take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key)))\n                             0)\n                           index key m\n                           (key (take (Suc (Suc m)) xs !\n                                 mini (take (Suc (Suc m)) xs) key))\n                           (key (take (Suc (Suc m)) xs !\n                                 maxi (take (Suc (Suc m)) xs) key)) !\n                          k))", "by simp"], ["proof (state)\nthis:\n  \\<forall>j<offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0 !\n             i'.\n     \\<forall>k\\<in>{offs\n                      (enum\n                        (nths (take (Suc (Suc m)) xs)\n                          (- {mini (take (Suc (Suc m)) xs) key,\n                              maxi (take (Suc (Suc m)) xs) key}))\n                        index key\n                        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                         | Suc (Suc i) \\<Rightarrow> u + m')\n                        (key (take (Suc (Suc m)) xs !\n                              mini (take (Suc (Suc m)) xs) key))\n                        (key (take (Suc (Suc m)) xs !\n                              maxi (take (Suc (Suc m)) xs) key)))\n                      0 !\n                     i'..<m}.\n        key (the (fill\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   (offs\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))\n                     0)\n                   index key m\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)) !\n                  j))\n        \\<le> key (the (fill\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         (offs\n                           (enum\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             index key\n                             (case m of 0 \\<Rightarrow> m\n                              | Suc 0 \\<Rightarrow> m\n                              | Suc (Suc i) \\<Rightarrow> u + m')\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))\n                           0)\n                         index key m\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key)) !\n                        k))\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>j<offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0 !\n             i'.\n     \\<forall>k\\<in>{offs\n                      (enum\n                        (nths (take (Suc (Suc m)) xs)\n                          (- {mini (take (Suc (Suc m)) xs) key,\n                              maxi (take (Suc (Suc m)) xs) key}))\n                        index key\n                        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                         | Suc (Suc i) \\<Rightarrow> u + m')\n                        (key (take (Suc (Suc m)) xs !\n                              mini (take (Suc (Suc m)) xs) key))\n                        (key (take (Suc (Suc m)) xs !\n                              maxi (take (Suc (Suc m)) xs) key)))\n                      0 !\n                     i'..<m}.\n        key (the (fill\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   (offs\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))\n                     0)\n                   index key m\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)) !\n                  j))\n        \\<le> key (the (fill\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         (offs\n                           (enum\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             index key\n                             (case m of 0 \\<Rightarrow> m\n                              | Suc 0 \\<Rightarrow> m\n                              | Suc (Suc i) \\<Rightarrow> u + m')\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))\n                           0)\n                         index key m\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key)) !\n                        k))\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j = Suc j'\""], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "with Y and AE"], ["proof (chain)\npicking this:\n  j < Suc (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) @\n             Suc 0 # ns')\n            0 !\n           i')\n  i' < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n  j = Suc j'", "have \"j' < offs ?ms 0 ! i'\""], ["proof (prove)\nusing this:\n  j < Suc (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) @\n             Suc 0 # ns')\n            0 !\n           i')\n  i' < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. j' < offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0 !\n         i'", "by (simp add: offs_append nth_append offs_length enum_length)"], ["proof (state)\nthis:\n  j' < offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n        0 !\n       i'\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>j<offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0 !\n             i'.\n     \\<forall>k\\<in>{offs\n                      (enum\n                        (nths (take (Suc (Suc m)) xs)\n                          (- {mini (take (Suc (Suc m)) xs) key,\n                              maxi (take (Suc (Suc m)) xs) key}))\n                        index key\n                        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                         | Suc (Suc i) \\<Rightarrow> u + m')\n                        (key (take (Suc (Suc m)) xs !\n                              mini (take (Suc (Suc m)) xs) key))\n                        (key (take (Suc (Suc m)) xs !\n                              maxi (take (Suc (Suc m)) xs) key)))\n                      0 !\n                     i'..<m}.\n        key (the (fill\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   (offs\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))\n                     0)\n                   index key m\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)) !\n                  j))\n        \\<le> key (the (fill\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         (offs\n                           (enum\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             index key\n                             (case m of 0 \\<Rightarrow> m\n                              | Suc 0 \\<Rightarrow> m\n                              | Suc (Suc i) \\<Rightarrow> u + m')\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))\n                           0)\n                         index key m\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key)) !\n                        k))\n  j' < offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n        0 !\n       i'", "have \"\\<forall>k \\<in> {offs ?ms 0 ! i'..<m}.\n            key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! j')) \\<le>\n            key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! k))\""], ["proof (prove)\nusing this:\n  \\<forall>j<offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0 !\n             i'.\n     \\<forall>k\\<in>{offs\n                      (enum\n                        (nths (take (Suc (Suc m)) xs)\n                          (- {mini (take (Suc (Suc m)) xs) key,\n                              maxi (take (Suc (Suc m)) xs) key}))\n                        index key\n                        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                         | Suc (Suc i) \\<Rightarrow> u + m')\n                        (key (take (Suc (Suc m)) xs !\n                              mini (take (Suc (Suc m)) xs) key))\n                        (key (take (Suc (Suc m)) xs !\n                              maxi (take (Suc (Suc m)) xs) key)))\n                      0 !\n                     i'..<m}.\n        key (the (fill\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   (offs\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))\n                     0)\n                   index key m\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)) !\n                  j))\n        \\<le> key (the (fill\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         (offs\n                           (enum\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             index key\n                             (case m of 0 \\<Rightarrow> m\n                              | Suc 0 \\<Rightarrow> m\n                              | Suc (Suc i) \\<Rightarrow> u + m')\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))\n                           0)\n                         index key m\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key)) !\n                        k))\n  j' < offs\n        (enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n        0 !\n       i'\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{offs\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))\n                     0 !\n                    i'..<m}.\n       key (the (fill\n                  (nths (take (Suc (Suc m)) xs)\n                    (- {mini (take (Suc (Suc m)) xs) key,\n                        maxi (take (Suc (Suc m)) xs) key}))\n                  (offs\n                    (enum\n                      (nths (take (Suc (Suc m)) xs)\n                        (- {mini (take (Suc (Suc m)) xs) key,\n                            maxi (take (Suc (Suc m)) xs) key}))\n                      index key\n                      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                       | Suc (Suc i) \\<Rightarrow> u + m')\n                      (key (take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key))\n                      (key (take (Suc (Suc m)) xs !\n                            maxi (take (Suc (Suc m)) xs) key)))\n                    0)\n                  index key m\n                  (key (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key))\n                  (key (take (Suc (Suc m)) xs !\n                        maxi (take (Suc (Suc m)) xs) key)) !\n                 j'))\n       \\<le> key (the (fill\n                        (nths (take (Suc (Suc m)) xs)\n                          (- {mini (take (Suc (Suc m)) xs) key,\n                              maxi (take (Suc (Suc m)) xs) key}))\n                        (offs\n                          (enum\n                            (nths (take (Suc (Suc m)) xs)\n                              (- {mini (take (Suc (Suc m)) xs) key,\n                                  maxi (take (Suc (Suc m)) xs) key}))\n                            index key\n                            (case m of 0 \\<Rightarrow> m\n                             | Suc 0 \\<Rightarrow> m\n                             | Suc (Suc i) \\<Rightarrow> u + m')\n                            (key (take (Suc (Suc m)) xs !\n                                  mini (take (Suc (Suc m)) xs) key))\n                            (key (take (Suc (Suc m)) xs !\n                                  maxi (take (Suc (Suc m)) xs) key)))\n                          0)\n                        index key m\n                        (key (take (Suc (Suc m)) xs !\n                              mini (take (Suc (Suc m)) xs) key))\n                        (key (take (Suc (Suc m)) xs !\n                              maxi (take (Suc (Suc m)) xs) key)) !\n                       k))", "by simp"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{offs\n                   (enum\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     index key\n                     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                      | Suc (Suc i) \\<Rightarrow> u + m')\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)))\n                   0 !\n                  i'..<m}.\n     key (the (fill\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                (offs\n                  (enum\n                    (nths (take (Suc (Suc m)) xs)\n                      (- {mini (take (Suc (Suc m)) xs) key,\n                          maxi (take (Suc (Suc m)) xs) key}))\n                    index key\n                    (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                     | Suc (Suc i) \\<Rightarrow> u + m')\n                    (key (take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key))\n                    (key (take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key)))\n                  0)\n                index key m\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)) !\n               j'))\n     \\<le> key (the (fill\n                      (nths (take (Suc (Suc m)) xs)\n                        (- {mini (take (Suc (Suc m)) xs) key,\n                            maxi (take (Suc (Suc m)) xs) key}))\n                      (offs\n                        (enum\n                          (nths (take (Suc (Suc m)) xs)\n                            (- {mini (take (Suc (Suc m)) xs) key,\n                                maxi (take (Suc (Suc m)) xs) key}))\n                          index key\n                          (case m of 0 \\<Rightarrow> m\n                           | Suc 0 \\<Rightarrow> m\n                           | Suc (Suc i) \\<Rightarrow> u + m')\n                          (key (take (Suc (Suc m)) xs !\n                                mini (take (Suc (Suc m)) xs) key))\n                          (key (take (Suc (Suc m)) xs !\n                                maxi (take (Suc (Suc m)) xs) key)))\n                        0)\n                      index key m\n                      (key (take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key))\n                      (key (take (Suc (Suc m)) xs !\n                            maxi (take (Suc (Suc m)) xs) key)) !\n                     k))\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{offs\n                   (enum\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     index key\n                     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                      | Suc (Suc i) \\<Rightarrow> u + m')\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)))\n                   0 !\n                  i'..<m}.\n     key (the (fill\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                (offs\n                  (enum\n                    (nths (take (Suc (Suc m)) xs)\n                      (- {mini (take (Suc (Suc m)) xs) key,\n                          maxi (take (Suc (Suc m)) xs) key}))\n                    index key\n                    (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                     | Suc (Suc i) \\<Rightarrow> u + m')\n                    (key (take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key))\n                    (key (take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key)))\n                  0)\n                index key m\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)) !\n               j'))\n     \\<le> key (the (fill\n                      (nths (take (Suc (Suc m)) xs)\n                        (- {mini (take (Suc (Suc m)) xs) key,\n                            maxi (take (Suc (Suc m)) xs) key}))\n                      (offs\n                        (enum\n                          (nths (take (Suc (Suc m)) xs)\n                            (- {mini (take (Suc (Suc m)) xs) key,\n                                maxi (take (Suc (Suc m)) xs) key}))\n                          index key\n                          (case m of 0 \\<Rightarrow> m\n                           | Suc 0 \\<Rightarrow> m\n                           | Suc (Suc i) \\<Rightarrow> u + m')\n                          (key (take (Suc (Suc m)) xs !\n                                mini (take (Suc (Suc m)) xs) key))\n                          (key (take (Suc (Suc m)) xs !\n                                maxi (take (Suc (Suc m)) xs) key)))\n                        0)\n                      index key m\n                      (key (take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key))\n                      (key (take (Suc (Suc m)) xs !\n                            maxi (take (Suc (Suc m)) xs) key)) !\n                     k))\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "from AA and AE"], ["proof (chain)\npicking this:\n  offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n    Suc 0 # ns')\n   0 !\n  i'\n  \\<le> k'\n  i' < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')", "have \"offs ?ms 0 ! i' \\<le> k'\""], ["proof (prove)\nusing this:\n  offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n    Suc 0 # ns')\n   0 !\n  i'\n  \\<le> k'\n  i' < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. offs\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n     0 !\n    i'\n    \\<le> k'", "by (simp add: offs_append nth_append offs_length enum_length)"], ["proof (state)\nthis:\n  offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n   0 !\n  i'\n  \\<le> k'\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"k' \\<in> {offs ?ms 0 ! i'..<m}\""], ["proof (prove)\nusing this:\n  offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n   0 !\n  i'\n  \\<le> k'\n\ngoal (1 subgoal):\n 1. k' \\<in> {offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0 !\n              i'..<m}", "using AC"], ["proof (prove)\nusing this:\n  offs\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n   0 !\n  i'\n  \\<le> k'\n  k' < m\n\ngoal (1 subgoal):\n 1. k' \\<in> {offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0 !\n              i'..<m}", "by simp"], ["proof (state)\nthis:\n  k' \\<in> {offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0 !\n            i'..<m}\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; k' < m; k = Suc k'; Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (the (fill\n    (nths (take (Suc (Suc m)) xs)\n      (- {mini (take (Suc (Suc m)) xs) key,\n          maxi (take (Suc (Suc m)) xs) key}))\n    (offs\n      (enum\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        index key\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n      0)\n    index key m\n    (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n    (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n   k'))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 3. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>{offs\n                   (enum\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     index key\n                     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                      | Suc (Suc i) \\<Rightarrow> u + m')\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)))\n                   0 !\n                  i'..<m}.\n     key (the (fill\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                (offs\n                  (enum\n                    (nths (take (Suc (Suc m)) xs)\n                      (- {mini (take (Suc (Suc m)) xs) key,\n                          maxi (take (Suc (Suc m)) xs) key}))\n                    index key\n                    (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                     | Suc (Suc i) \\<Rightarrow> u + m')\n                    (key (take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key))\n                    (key (take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key)))\n                  0)\n                index key m\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)) !\n               j'))\n     \\<le> key (the (fill\n                      (nths (take (Suc (Suc m)) xs)\n                        (- {mini (take (Suc (Suc m)) xs) key,\n                            maxi (take (Suc (Suc m)) xs) key}))\n                      (offs\n                        (enum\n                          (nths (take (Suc (Suc m)) xs)\n                            (- {mini (take (Suc (Suc m)) xs) key,\n                                maxi (take (Suc (Suc m)) xs) key}))\n                          index key\n                          (case m of 0 \\<Rightarrow> m\n                           | Suc 0 \\<Rightarrow> m\n                           | Suc (Suc i) \\<Rightarrow> u + m')\n                          (key (take (Suc (Suc m)) xs !\n                                mini (take (Suc (Suc m)) xs) key))\n                          (key (take (Suc (Suc m)) xs !\n                                maxi (take (Suc (Suc m)) xs) key)))\n                        0)\n                      index key m\n                      (key (take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key))\n                      (key (take (Suc (Suc m)) xs !\n                            maxi (take (Suc (Suc m)) xs) key)) !\n                     k))\n  k' \\<in> {offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0 !\n            i'..<m}", "show\n           \"key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! j')) \\<le>\n            key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! k'))\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{offs\n                   (enum\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     index key\n                     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                      | Suc (Suc i) \\<Rightarrow> u + m')\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)))\n                   0 !\n                  i'..<m}.\n     key (the (fill\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                (offs\n                  (enum\n                    (nths (take (Suc (Suc m)) xs)\n                      (- {mini (take (Suc (Suc m)) xs) key,\n                          maxi (take (Suc (Suc m)) xs) key}))\n                    index key\n                    (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                     | Suc (Suc i) \\<Rightarrow> u + m')\n                    (key (take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key))\n                    (key (take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key)))\n                  0)\n                index key m\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)) !\n               j'))\n     \\<le> key (the (fill\n                      (nths (take (Suc (Suc m)) xs)\n                        (- {mini (take (Suc (Suc m)) xs) key,\n                            maxi (take (Suc (Suc m)) xs) key}))\n                      (offs\n                        (enum\n                          (nths (take (Suc (Suc m)) xs)\n                            (- {mini (take (Suc (Suc m)) xs) key,\n                                maxi (take (Suc (Suc m)) xs) key}))\n                          index key\n                          (case m of 0 \\<Rightarrow> m\n                           | Suc 0 \\<Rightarrow> m\n                           | Suc (Suc i) \\<Rightarrow> u + m')\n                          (key (take (Suc (Suc m)) xs !\n                                mini (take (Suc (Suc m)) xs) key))\n                          (key (take (Suc (Suc m)) xs !\n                                maxi (take (Suc (Suc m)) xs) key)))\n                        0)\n                      index key m\n                      (key (take (Suc (Suc m)) xs !\n                            mini (take (Suc (Suc m)) xs) key))\n                      (key (take (Suc (Suc m)) xs !\n                            maxi (take (Suc (Suc m)) xs) key)) !\n                     k))\n  k' \\<in> {offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0 !\n            i'..<m}\n\ngoal (1 subgoal):\n 1. key (the (fill\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               (offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0)\n               index key m\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)) !\n              j'))\n    \\<le> key (the (fill\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     (offs\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key)))\n                       0)\n                     index key m\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)) !\n                    k'))", ".."], ["proof (state)\nthis:\n  key (the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            j'))\n  \\<le> key (the (fill\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   (offs\n                     (enum\n                       (nths (take (Suc (Suc m)) xs)\n                         (- {mini (take (Suc (Suc m)) xs) key,\n                             maxi (take (Suc (Suc m)) xs) key}))\n                       index key\n                       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                        | Suc (Suc i) \\<Rightarrow> u + m')\n                       (key (take (Suc (Suc m)) xs !\n                             mini (take (Suc (Suc m)) xs) key))\n                       (key (take (Suc (Suc m)) xs !\n                             maxi (take (Suc (Suc m)) xs) key)))\n                     0)\n                   index key m\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)) !\n                  k'))\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "fix j'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j' < m\""], ["proof (state)\nthis:\n  j' < m\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! j') \\<in> set ?ws\"\n            (is \"?x \\<in> _\")"], ["proof (prove)\nusing this:\n  j' < m\n\ngoal (1 subgoal):\n 1. the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         j')\n    \\<in> set (take (Suc (Suc m)) xs)", "by (rule Q)"], ["proof (state)\nthis:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n  \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n  \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"m \\<le> k'\""], ["proof (state)\nthis:\n  m \\<le> k'\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"k' = m\""], ["proof (prove)\nusing this:\n  m \\<le> k'\n\ngoal (1 subgoal):\n 1. k' = m", "using T and Z"], ["proof (prove)\nusing this:\n  m \\<le> k'\n  k < Suc (Suc m)\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. k' = m", "by simp"], ["proof (state)\nthis:\n  k' = m\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; nat < m; m \\<le> k'; k = Suc k'\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key ([take (Suc (Suc m)) xs !\n                                     maxi (take (Suc (Suc m)) xs) key] !\n                                    (k' - m))\n 2. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n  \\<in> set (take (Suc (Suc m)) xs)\n  k' = m", "show \"key ?x \\<le> key ([?xma] ! (k' - m))\""], ["proof (prove)\nusing this:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n  \\<in> set (take (Suc (Suc m)) xs)\n  k' = m\n\ngoal (1 subgoal):\n 1. key (the (fill\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               (offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0)\n               index key m\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)) !\n              j'))\n    \\<le> key ([take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] !\n               (k' - m))", "by (simp, rule_tac maxi_ub)"], ["proof (state)\nthis:\n  key (the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            j'))\n  \\<le> key ([take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] !\n             (k' - m))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "fix j'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j = Suc j'\" and \"m \\<le> j'\""], ["proof (state)\nthis:\n  j = Suc j'\n  m \\<le> j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"Suc m \\<le> j\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  m \\<le> j'\n\ngoal (1 subgoal):\n 1. Suc m \\<le> j", "by simp"], ["proof (state)\nthis:\n  Suc m \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"Suc (Suc m) \\<le> k\""], ["proof (prove)\nusing this:\n  Suc m \\<le> j\n\ngoal (1 subgoal):\n 1. Suc (Suc m) \\<le> k", "using Z and AB"], ["proof (prove)\nusing this:\n  Suc m \\<le> j\n  k = Suc k'\n  j \\<le> k'\n\ngoal (1 subgoal):\n 1. Suc (Suc m) \\<le> k", "by simp"], ["proof (state)\nthis:\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>j = Suc nat; m \\<le> nat; k = Suc k';\n        Suc nat \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. False", "using T"], ["proof (prove)\nusing this:\n  Suc (Suc m) \\<le> k\n  k < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  key ((take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) !\n       j)\n  \\<le> key ((take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n              map the\n               (fill\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 (offs\n                   (enum\n                     (nths (take (Suc (Suc m)) xs)\n                       (- {mini (take (Suc (Suc m)) xs) key,\n                           maxi (take (Suc (Suc m)) xs) key}))\n                     index key\n                     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                      | Suc (Suc i) \\<Rightarrow> u + m')\n                     (key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key))\n                     (key (take (Suc (Suc m)) xs !\n                           maxi (take (Suc (Suc m)) xs) key)))\n                   0)\n                 index key m\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key))) @\n              [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) !\n             k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  key (ws' ! j) \\<le> key (ws' ! k)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>j < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (ws' ! j) \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>j < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (ws' ! j) \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "assume\n        S: \"j < Suc (Suc m)\" and\n        T: \"Suc (Suc m) \\<le> k\""], ["proof (state)\nthis:\n  j < Suc (Suc m)\n  Suc (Suc m) \\<le> k\n\ngoal (3 subgoals):\n 1. \\<lbrakk>j < Suc (Suc m); Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (ws' ! j) \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "from D [symmetric]"], ["proof (chain)\npicking this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u", "show \"key (ws' ! j) \\<le> key (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\n\ngoal (1 subgoal):\n 1. key (ws' ! j) \\<le> key (xs' ! (k - Suc (Suc m)))", "proof (simp add: round_suc_suc_def Let_def split: if_split_asm,\n       rule_tac R [OF S T], cases j, case_tac [2] \"j < Suc m\",\n       simp_all add: nth_append not_less fill_length)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     j = 0\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 3. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"?nmi < length ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)", "using O"], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)", "by (rule_tac mini_less, simp)"], ["proof (state)\nthis:\n  mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     j = 0\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 3. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "hence \"?nmi < Suc (Suc m)\""], ["proof (prove)\nusing this:\n  mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. mini (take (Suc (Suc m)) xs) key < Suc (Suc m)", "using O"], ["proof (prove)\nusing this:\n  mini (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. mini (take (Suc (Suc m)) xs) key < Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  mini (take (Suc (Suc m)) xs) key < Suc (Suc m)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     j = 0\\<rbrakk>\n    \\<Longrightarrow> key (take (Suc (Suc m)) xs !\n                           mini (take (Suc (Suc m)) xs) key)\n                      \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 3. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "thus \"?mi \\<le> key (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  mini (take (Suc (Suc m)) xs) key < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key)\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "using T"], ["proof (prove)\nusing this:\n  mini (take (Suc (Suc m)) xs) key < Suc (Suc m)\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key)\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "by (rule R)"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key)\n  \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "fix j'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "assume \"j' < m\""], ["proof (state)\nthis:\n  j' < m\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "hence U: \"the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! j') \\<in> set ?ws\""], ["proof (prove)\nusing this:\n  j' < m\n\ngoal (1 subgoal):\n 1. the (fill\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          (offs\n            (enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)))\n            0)\n          index key m\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n         j')\n    \\<in> set (take (Suc (Suc m)) xs)", "by (rule Q)"], ["proof (state)\nthis:\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n  \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"\\<exists>p < Suc (Suc m). ?ws ! p =\n          the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p<Suc (Suc m).\n       take (Suc (Suc m)) xs ! p =\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            j')", "using O and U"], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n  \\<in> set (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>p<Suc (Suc m).\n       take (Suc (Suc m)) xs ! p =\n       the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            j')", "by (simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>p<Suc (Suc m).\n     take (Suc (Suc m)) xs ! p =\n     the (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)) !\n          j')\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>p<Suc (Suc m).\n     take (Suc (Suc m)) xs ! p =\n     the (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)) !\n          j')", "obtain p where V: \"p < Suc (Suc m) \\<and> ?ws ! p =\n          the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! j')\""], ["proof (prove)\nusing this:\n  \\<exists>p<Suc (Suc m).\n     take (Suc (Suc m)) xs ! p =\n     the (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)) !\n          j')\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p < Suc (Suc m) \\<and>\n        take (Suc (Suc m)) xs ! p =\n        the (fill\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              (offs\n                (enum\n                  (nths (take (Suc (Suc m)) xs)\n                    (- {mini (take (Suc (Suc m)) xs) key,\n                        maxi (take (Suc (Suc m)) xs) key}))\n                  index key\n                  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                   | Suc (Suc i) \\<Rightarrow> u + m')\n                  (key (take (Suc (Suc m)) xs !\n                        mini (take (Suc (Suc m)) xs) key))\n                  (key (take (Suc (Suc m)) xs !\n                        maxi (take (Suc (Suc m)) xs) key)))\n                0)\n              index key m\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) !\n             j') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p < Suc (Suc m) \\<and>\n  take (Suc (Suc m)) xs ! p =\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "hence \"key (?ws ! p) \\<le> key (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  p < Suc (Suc m) \\<and>\n  take (Suc (Suc m)) xs ! p =\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! p) \\<le> key (xs' ! (k - Suc (Suc m)))", "using T"], ["proof (prove)\nusing this:\n  p < Suc (Suc m) \\<and>\n  take (Suc (Suc m)) xs ! p =\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! p) \\<le> key (xs' ! (k - Suc (Suc m)))", "by (rule_tac R, simp)"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! p) \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; nat < m\\<rbrakk>\n       \\<Longrightarrow> key (the (fill\n                                    (nths (take (Suc (Suc m)) xs)\n(- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\n                                    (offs\n(enum\n  (nths (take (Suc (Suc m)) xs)\n    (- {mini (take (Suc (Suc m)) xs) key,\n        maxi (take (Suc (Suc m)) xs) key}))\n  index key\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m')\n  (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n  (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n0)\n                                    index key m\n                                    (key\n(take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n                                    (key\n(take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n                                   nat))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))\n 2. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "thus \"key (the (fill ?zs (offs ?ms 0) index key m ?mi ?ma ! j')) \\<le>\n          key (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  key (take (Suc (Suc m)) xs ! p) \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal (1 subgoal):\n 1. key (the (fill\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               (offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0)\n               index key m\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)) !\n              j'))\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "using V"], ["proof (prove)\nusing this:\n  key (take (Suc (Suc m)) xs ! p) \\<le> key (xs' ! (k - Suc (Suc m)))\n  p < Suc (Suc m) \\<and>\n  take (Suc (Suc m)) xs ! p =\n  the (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) !\n       j')\n\ngoal (1 subgoal):\n 1. key (the (fill\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               (offs\n                 (enum\n                   (nths (take (Suc (Suc m)) xs)\n                     (- {mini (take (Suc (Suc m)) xs) key,\n                         maxi (take (Suc (Suc m)) xs) key}))\n                   index key\n                   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                    | Suc (Suc i) \\<Rightarrow> u + m')\n                   (key (take (Suc (Suc m)) xs !\n                         mini (take (Suc (Suc m)) xs) key))\n                   (key (take (Suc (Suc m)) xs !\n                         maxi (take (Suc (Suc m)) xs) key)))\n                 0)\n               index key m\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)) !\n              j'))\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "by simp"], ["proof (state)\nthis:\n  key (the (fill\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             (offs\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)))\n               0)\n             index key m\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)) !\n            j'))\n  \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "fix j'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "assume \"j = Suc j'\" and \"m \\<le> j'\""], ["proof (state)\nthis:\n  j = Suc j'\n  m \\<le> j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  j = Suc j'\n  m \\<le> j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "from this"], ["proof (chain)\npicking this:\n  j = Suc j'\n  m \\<le> j'", "have \"Suc m \\<le> j\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  m \\<le> j'\n\ngoal (1 subgoal):\n 1. Suc m \\<le> j", "by simp"], ["proof (state)\nthis:\n  Suc m \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "hence \"j = Suc m\""], ["proof (prove)\nusing this:\n  Suc m \\<le> j\n\ngoal (1 subgoal):\n 1. j = Suc m", "using S"], ["proof (prove)\nusing this:\n  Suc m \\<le> j\n  j < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. j = Suc m", "by simp"], ["proof (state)\nthis:\n  j = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "ultimately"], ["proof (chain)\npicking this:\n  j = Suc j'\n  m \\<le> j'\n  j = Suc m", "have \"j' = m\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  m \\<le> j'\n  j = Suc m\n\ngoal (1 subgoal):\n 1. j' = m", "by simp"], ["proof (state)\nthis:\n  j' = m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key) \\<noteq>\n                key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key);\n        v =\n        u + m' -\n        (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        (u + m' -\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc m)) xs)\n            (- {mini (take (Suc (Suc m)) xs) key,\n                maxi (take (Suc (Suc m)) xs) key}))\n          index key\n          (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n           | Suc (Suc i) \\<Rightarrow> u + m')\n          (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n          (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key))) @\n         [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n        round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n        j = Suc nat; m \\<le> nat\\<rbrakk>\n       \\<Longrightarrow> key ([take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key] !\n                              (nat - m))\n                         \\<le> key (xs' ! (k - Suc (Suc m)))", "thus \"key ([?xma] ! (j' - m)) \\<le> key (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  j' = m\n\ngoal (1 subgoal):\n 1. key ([take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] !\n         (j' - m))\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. j' = m \\<Longrightarrow>\n    key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"?nma < length ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)", "using O"], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)", "by (rule_tac maxi_less, simp)"], ["proof (state)\nthis:\n  maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. j' = m \\<Longrightarrow>\n    key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "hence \"?nma < Suc (Suc m)\""], ["proof (prove)\nusing this:\n  maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. maxi (take (Suc (Suc m)) xs) key < Suc (Suc m)", "using O"], ["proof (prove)\nusing this:\n  maxi (take (Suc (Suc m)) xs) key < length (take (Suc (Suc m)) xs)\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. maxi (take (Suc (Suc m)) xs) key < Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  maxi (take (Suc (Suc m)) xs) key < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. j' = m \\<Longrightarrow>\n    key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "thus \"?ma \\<le> key (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  maxi (take (Suc (Suc m)) xs) key < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "using T"], ["proof (prove)\nusing this:\n  maxi (take (Suc (Suc m)) xs) key < Suc (Suc m)\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n    \\<le> key (xs' ! (k - Suc (Suc m)))", "by (rule R)"], ["proof (state)\nthis:\n  key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)\n  \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  key ([take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] !\n       (j' - m))\n  \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  key (ws' ! j) \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "assume \"k < Suc (Suc m)\" and \"Suc (Suc m) \\<le> j\""], ["proof (state)\nthis:\n  k < Suc (Suc m)\n  Suc (Suc m) \\<le> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "hence \"k < j\""], ["proof (prove)\nusing this:\n  k < Suc (Suc m)\n  Suc (Suc m) \\<le> j\n\ngoal (1 subgoal):\n 1. k < j", "by simp"], ["proof (state)\nthis:\n  k < j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  k < j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"j < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < k", "using L and M"], ["proof (prove)\nusing this:\n  j < offs (ms' @ ns') 0 ! i\n  offs (ms' @ ns') 0 ! i \\<le> k\n\ngoal (1 subgoal):\n 1. j < k", "by simp"], ["proof (state)\nthis:\n  j < k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; k < Suc (Suc m)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "ultimately"], ["proof (chain)\npicking this:\n  k < j\n  j < k", "show False"], ["proof (prove)\nusing this:\n  k < j\n  j < k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "assume\n        S: \"Suc (Suc m) \\<le> j\" and\n        T: \"Suc (Suc m) \\<le> k\""], ["proof (state)\nthis:\n  Suc (Suc m) \\<le> j\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "have U: \"0 < length ns' \\<and> 0 < length xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length ns' \\<and> 0 < length xs'", "proof (rule ccontr, simp, erule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "have \"bn_inv p q (v, ns, ?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_inv p q (v, ns, drop (Suc (Suc m)) xs)", "using C"], ["proof (prove)\nusing this:\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. bn_inv p q (v, ns, drop (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  bn_inv p q (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  bn_inv p q (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "have \"add_inv (n - Suc (Suc m)) (v, ns, ?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)", "using H and I"], ["proof (prove)\nusing this:\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)", "by simp"], ["proof (state)\nthis:\n  add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  bn_inv p q (v, ns, drop (Suc (Suc m)) xs)\n  add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)", "have \"add_inv (n - Suc (Suc m)) (?t r' v)\""], ["proof (prove)\nusing this:\n  bn_inv p q (v, ns, drop (Suc (Suc m)) xs)\n  add_inv (n - Suc (Suc m)) (v, ns, drop (Suc (Suc m)) xs)\n\ngoal (1 subgoal):\n 1. add_inv (n - Suc (Suc m))\n     (round index key p q r' (v, ns, drop (Suc (Suc m)) xs))", "by (rule round_add_inv [OF A])"], ["proof (state)\nthis:\n  add_inv (n - Suc (Suc m))\n   (round index key p q r' (v, ns, drop (Suc (Suc m)) xs))\n\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "hence \"length xs' = foldl (+) 0 ns'\""], ["proof (prove)\nusing this:\n  add_inv (n - Suc (Suc m))\n   (round index key p q r' (v, ns, drop (Suc (Suc m)) xs))\n\ngoal (1 subgoal):\n 1. length xs' = foldl (+) 0 ns'", "using E"], ["proof (prove)\nusing this:\n  add_inv (n - Suc (Suc m))\n   (round index key p q r' (v, ns, drop (Suc (Suc m)) xs))\n  round index key p q r' (v, ns, drop (Suc (Suc m)) xs) = (u', ns', xs')\n\ngoal (1 subgoal):\n 1. length xs' = foldl (+) 0 ns'", "by simp"], ["proof (state)\nthis:\n  length xs' = foldl (+) 0 ns'\n\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length xs' = foldl (+) 0 ns'\n\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "assume \"ns' = []\""], ["proof (state)\nthis:\n  ns' = []\n\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  length xs' = foldl (+) 0 ns'\n  ns' = []", "have \"length xs' = 0\""], ["proof (prove)\nusing this:\n  length xs' = foldl (+) 0 ns'\n  ns' = []\n\ngoal (1 subgoal):\n 1. length xs' = 0", "by simp"], ["proof (state)\nthis:\n  length xs' = 0\n\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "hence \"k < Suc (Suc m)\""], ["proof (prove)\nusing this:\n  length xs' = 0\n\ngoal (1 subgoal):\n 1. k < Suc (Suc m)", "using N and P"], ["proof (prove)\nusing this:\n  length xs' = 0\n  k < length ws' + length xs'\n  length ws' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. k < Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  k < Suc (Suc m)\n\ngoal (2 subgoals):\n 1. ns' = [] \\<Longrightarrow> False\n 2. xs' = [] \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  k < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. False", "using T"], ["proof (prove)\nusing this:\n  k < Suc (Suc m)\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. xs' = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs' = [] \\<Longrightarrow> False", "assume \"xs' = []\""], ["proof (state)\nthis:\n  xs' = []\n\ngoal (1 subgoal):\n 1. xs' = [] \\<Longrightarrow> False", "hence \"k < Suc (Suc m)\""], ["proof (prove)\nusing this:\n  xs' = []\n\ngoal (1 subgoal):\n 1. k < Suc (Suc m)", "using N and P"], ["proof (prove)\nusing this:\n  xs' = []\n  k < length ws' + length xs'\n  length ws' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. k < Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  k < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. xs' = [] \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  k < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. False", "using T"], ["proof (prove)\nusing this:\n  k < Suc (Suc m)\n  Suc (Suc m) \\<le> k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < length ns' \\<and> 0 < length xs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "hence V: \"i - length ms' < length ns'\""], ["proof (prove)\nusing this:\n  0 < length ns' \\<and> 0 < length xs'\n\ngoal (1 subgoal):\n 1. i - length ms' < length ns'", "using K"], ["proof (prove)\nusing this:\n  0 < length ns' \\<and> 0 < length xs'\n  i < length ms' + length ns'\n\ngoal (1 subgoal):\n 1. i - length ms' < length ns'", "by arith"], ["proof (state)\nthis:\n  i - length ms' < length ns'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "hence W: \"\\<forall>j < offs ns' 0 ! (i - length ms').\n        \\<forall>k \\<in> {offs ns' 0 ! (i - length ms')..<length xs'}.\n          key (xs' ! j) \\<le> key (xs' ! k)\""], ["proof (prove)\nusing this:\n  i - length ms' < length ns'\n\ngoal (1 subgoal):\n 1. \\<forall>j<offs ns' 0 ! (i - length ms').\n       \\<forall>k\\<in>{offs ns' 0 ! (i - length ms')..<length xs'}.\n          key (xs' ! j) \\<le> key (xs' ! k)", "using \\<open>?R\\<close>"], ["proof (prove)\nusing this:\n  i - length ms' < length ns'\n  \\<forall>i<length ns'.\n     \\<forall>j<offs ns' 0 ! i.\n        \\<forall>k\\<in>{offs ns' 0 ! i..<length xs'}.\n           key (xs' ! j) \\<le> key (xs' ! k)\n\ngoal (1 subgoal):\n 1. \\<forall>j<offs ns' 0 ! (i - length ms').\n       \\<forall>k\\<in>{offs ns' 0 ! (i - length ms')..<length xs'}.\n          key (xs' ! j) \\<le> key (xs' ! k)", "by simp"], ["proof (state)\nthis:\n  \\<forall>j<offs ns' 0 ! (i - length ms').\n     \\<forall>k\\<in>{offs ns' 0 ! (i - length ms')..<length xs'}.\n        key (xs' ! j) \\<le> key (xs' ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "from D [symmetric]"], ["proof (chain)\npicking this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u", "have X: \"foldl (+) 0 ms' = Suc (Suc m)\""], ["proof (prove)\nusing this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ms' = Suc (Suc m)", "proof (simp add: round_suc_suc_def Let_def add_replicate add_suc\n       split: if_split_asm, cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m = 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m", "case True"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m = 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m", "hence \"?k = 0\""], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n     | Suc (Suc i) \\<Rightarrow> u + m') =\n    0", "by simp"], ["proof (state)\nthis:\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m') =\n  0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m = 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m", "hence \"length ?ms = 0\""], ["proof (prove)\nusing this:\n  (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n   | Suc (Suc i) \\<Rightarrow> u + m') =\n  0\n\ngoal (1 subgoal):\n 1. length\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    0", "by (simp add: enum_length)"], ["proof (state)\nthis:\n  length\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m = 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m", "thus \"foldl (+) 0 ?ms = m\""], ["proof (prove)\nusing this:\n  length\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  0\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    m", "using True"], ["proof (prove)\nusing this:\n  length\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  0\n  m = 0\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    m", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m", "case False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m", "hence \"0 < ?k\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')", "by (simp, drule_tac bn_comp_fst_nonzero [OF G], subst (asm) F,\n           simp split: nat.split)"], ["proof (state)\nthis:\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m", "with A"], ["proof (chain)\npicking this:\n  index_less index key\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')", "have \"foldl (+) 0 ?ms = length ?zs\""], ["proof (prove)\nusing this:\n  index_less index key\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    length\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))", "by (rule enum_add, simp, rule_tac conjI,\n           ((rule_tac mini_lb | rule_tac maxi_ub), erule_tac in_set_nthsD)+)"], ["proof (state)\nthis:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0\n                       (enum\n                         (nths (take (Suc (Suc m)) xs)\n                           (- {mini (take (Suc (Suc m)) xs) key,\n                               maxi (take (Suc (Suc m)) xs) key}))\n                         index key\n                         (case m of 0 \\<Rightarrow> m\n                          | Suc 0 \\<Rightarrow> m\n                          | Suc (Suc i) \\<Rightarrow> u + m')\n                         (key (take (Suc (Suc m)) xs !\n                               mini (take (Suc (Suc m)) xs) key))\n                         (key (take (Suc (Suc m)) xs !\n                               maxi (take (Suc (Suc m)) xs) key))) =\n                      m", "thus \"foldl (+) 0 ?ms = m\""], ["proof (prove)\nusing this:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    m", "using O"], ["proof (prove)\nusing this:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    m", "by (simp add: mini_maxi_nths)"], ["proof (state)\nthis:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl (+) 0 ms' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"length ms' < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ms' < i", "proof (rule ccontr, simp add: not_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> length ms' \\<Longrightarrow> False", "assume \"i \\<le> length ms'\""], ["proof (state)\nthis:\n  i \\<le> length ms'\n\ngoal (1 subgoal):\n 1. i \\<le> length ms' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i \\<le> length ms'\n\ngoal (1 subgoal):\n 1. i \\<le> length ms' \\<Longrightarrow> False", "have \"length ms' < length (ms' @ ns')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ms' < length (ms' @ ns')", "using U"], ["proof (prove)\nusing this:\n  0 < length ns' \\<and> 0 < length xs'\n\ngoal (1 subgoal):\n 1. length ms' < length (ms' @ ns')", "by simp"], ["proof (state)\nthis:\n  length ms' < length (ms' @ ns')\n\ngoal (1 subgoal):\n 1. i \\<le> length ms' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  i \\<le> length ms'\n  length ms' < length (ms' @ ns')", "have \"offs (ms' @ ns') 0 ! i \\<le>\n          offs (ms' @ ns') 0 ! (length ms')\""], ["proof (prove)\nusing this:\n  i \\<le> length ms'\n  length ms' < length (ms' @ ns')\n\ngoal (1 subgoal):\n 1. offs (ms' @ ns') 0 ! i \\<le> offs (ms' @ ns') 0 ! length ms'", "by (rule offs_mono)"], ["proof (state)\nthis:\n  offs (ms' @ ns') 0 ! i \\<le> offs (ms' @ ns') 0 ! length ms'\n\ngoal (1 subgoal):\n 1. i \\<le> length ms' \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  offs (ms' @ ns') 0 ! i \\<le> offs (ms' @ ns') 0 ! length ms'\n\ngoal (1 subgoal):\n 1. i \\<le> length ms' \\<Longrightarrow> False", "have \"\\<dots> = Suc (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (ms' @ ns') 0 ! length ms' = Suc (Suc m)", "using U and X"], ["proof (prove)\nusing this:\n  0 < length ns' \\<and> 0 < length xs'\n  foldl (+) 0 ms' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. offs (ms' @ ns') 0 ! length ms' = Suc (Suc m)", "by (simp add: offs_append nth_append offs_length,\n           cases ns', simp_all)"], ["proof (state)\nthis:\n  offs (ms' @ ns') 0 ! length ms' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. i \\<le> length ms' \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  offs (ms' @ ns') 0 ! i \\<le> Suc (Suc m)", "have \"offs (ms' @ ns') 0 ! i \\<le> Suc (Suc m)\""], ["proof (prove)\nusing this:\n  offs (ms' @ ns') 0 ! i \\<le> Suc (Suc m)\n\ngoal (1 subgoal):\n 1. offs (ms' @ ns') 0 ! i \\<le> Suc (Suc m)", "."], ["proof (state)\nthis:\n  offs (ms' @ ns') 0 ! i \\<le> Suc (Suc m)\n\ngoal (1 subgoal):\n 1. i \\<le> length ms' \\<Longrightarrow> False", "hence \"j < Suc (Suc m)\""], ["proof (prove)\nusing this:\n  offs (ms' @ ns') 0 ! i \\<le> Suc (Suc m)\n\ngoal (1 subgoal):\n 1. j < Suc (Suc m)", "using L"], ["proof (prove)\nusing this:\n  offs (ms' @ ns') 0 ! i \\<le> Suc (Suc m)\n  j < offs (ms' @ ns') 0 ! i\n\ngoal (1 subgoal):\n 1. j < Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  j < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. i \\<le> length ms' \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  j < Suc (Suc m)\n\ngoal (1 subgoal):\n 1. False", "using S"], ["proof (prove)\nusing this:\n  j < Suc (Suc m)\n  Suc (Suc m) \\<le> j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length ms' < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "hence Y: \"offs (ms' @ ns') 0 ! i =\n        Suc (Suc m) + offs ns' 0 ! (i - length ms')\""], ["proof (prove)\nusing this:\n  length ms' < i\n\ngoal (1 subgoal):\n 1. offs (ms' @ ns') 0 ! i = Suc (Suc m) + offs ns' 0 ! (i - length ms')", "using X"], ["proof (prove)\nusing this:\n  length ms' < i\n  foldl (+) 0 ms' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. offs (ms' @ ns') 0 ! i = Suc (Suc m) + offs ns' 0 ! (i - length ms')", "by (simp add: offs_append nth_append offs_length,\n         subst offs_base_zero [OF V], simp)"], ["proof (state)\nthis:\n  offs (ms' @ ns') 0 ! i = Suc (Suc m) + offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "hence \"j < Suc (Suc m) + offs ns' 0 ! (i - length ms')\""], ["proof (prove)\nusing this:\n  offs (ms' @ ns') 0 ! i = Suc (Suc m) + offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. j < Suc (Suc m) + offs ns' 0 ! (i - length ms')", "using L"], ["proof (prove)\nusing this:\n  offs (ms' @ ns') 0 ! i = Suc (Suc m) + offs ns' 0 ! (i - length ms')\n  j < offs (ms' @ ns') 0 ! i\n\ngoal (1 subgoal):\n 1. j < Suc (Suc m) + offs ns' 0 ! (i - length ms')", "by simp"], ["proof (state)\nthis:\n  j < Suc (Suc m) + offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  j < Suc (Suc m) + offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "from this"], ["proof (chain)\npicking this:\n  j < Suc (Suc m) + offs ns' 0 ! (i - length ms')", "have \"0 < offs ns' 0 ! (i - length ms')\""], ["proof (prove)\nusing this:\n  j < Suc (Suc m) + offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. 0 < offs ns' 0 ! (i - length ms')", "using S"], ["proof (prove)\nusing this:\n  j < Suc (Suc m) + offs ns' 0 ! (i - length ms')\n  Suc (Suc m) \\<le> j\n\ngoal (1 subgoal):\n 1. 0 < offs ns' 0 ! (i - length ms')", "by (rule_tac ccontr, simp)"], ["proof (state)\nthis:\n  0 < offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "ultimately"], ["proof (chain)\npicking this:\n  j < Suc (Suc m) + offs ns' 0 ! (i - length ms')\n  0 < offs ns' 0 ! (i - length ms')", "have \"j - Suc (Suc m) < offs ns' 0 ! (i - length ms')\""], ["proof (prove)\nusing this:\n  j < Suc (Suc m) + offs ns' 0 ! (i - length ms')\n  0 < offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. j - Suc (Suc m) < offs ns' 0 ! (i - length ms')", "by simp"], ["proof (state)\nthis:\n  j - Suc (Suc m) < offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "hence Z: \"\\<forall>k \\<in> {offs ns' 0 ! (i - length ms')..<length xs'}.\n        key (xs' ! (j - Suc (Suc m))) \\<le> key (xs' ! k)\""], ["proof (prove)\nusing this:\n  j - Suc (Suc m) < offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{offs ns' 0 ! (i - length ms')..<length xs'}.\n       key (xs' ! (j - Suc (Suc m))) \\<le> key (xs' ! k)", "using W"], ["proof (prove)\nusing this:\n  j - Suc (Suc m) < offs ns' 0 ! (i - length ms')\n  \\<forall>j<offs ns' 0 ! (i - length ms').\n     \\<forall>k\\<in>{offs ns' 0 ! (i - length ms')..<length xs'}.\n        key (xs' ! j) \\<le> key (xs' ! k)\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{offs ns' 0 ! (i - length ms')..<length xs'}.\n       key (xs' ! (j - Suc (Suc m))) \\<le> key (xs' ! k)", "by simp"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{offs ns' 0 ! (i - length ms')..<length xs'}.\n     key (xs' ! (j - Suc (Suc m))) \\<le> key (xs' ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"offs ns' 0 ! (i - length ms') \\<le> k - Suc (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs ns' 0 ! (i - length ms') \\<le> k - Suc (Suc m)", "using M and Y"], ["proof (prove)\nusing this:\n  offs (ms' @ ns') 0 ! i \\<le> k\n  offs (ms' @ ns') 0 ! i = Suc (Suc m) + offs ns' 0 ! (i - length ms')\n\ngoal (1 subgoal):\n 1. offs ns' 0 ! (i - length ms') \\<le> k - Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  offs ns' 0 ! (i - length ms') \\<le> k - Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "moreover"], ["proof (state)\nthis:\n  offs ns' 0 ! (i - length ms') \\<le> k - Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "have \"k - Suc (Suc m) < length xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k - Suc (Suc m) < length xs'", "using N and P and U"], ["proof (prove)\nusing this:\n  k < length ws' + length xs'\n  length ws' = Suc (Suc m)\n  0 < length ns' \\<and> 0 < length xs'\n\ngoal (1 subgoal):\n 1. k - Suc (Suc m) < length xs'", "by arith"], ["proof (state)\nthis:\n  k - Suc (Suc m) < length xs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "ultimately"], ["proof (chain)\npicking this:\n  offs ns' 0 ! (i - length ms') \\<le> k - Suc (Suc m)\n  k - Suc (Suc m) < length xs'", "have \"k - Suc (Suc m) \\<in>\n        {offs ns' 0 ! (i - length ms')..<length xs'}\""], ["proof (prove)\nusing this:\n  offs ns' 0 ! (i - length ms') \\<le> k - Suc (Suc m)\n  k - Suc (Suc m) < length xs'\n\ngoal (1 subgoal):\n 1. k - Suc (Suc m) \\<in> {offs ns' 0 ! (i - length ms')..<length xs'}", "by simp"], ["proof (state)\nthis:\n  k - Suc (Suc m) \\<in> {offs ns' 0 ! (i - length ms')..<length xs'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc m) \\<le> j; Suc (Suc m) \\<le> k\\<rbrakk>\n    \\<Longrightarrow> key (xs' ! (j - Suc (Suc m)))\n                      \\<le> key (xs' ! (k - Suc (Suc m)))", "with Z"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>{offs ns' 0 ! (i - length ms')..<length xs'}.\n     key (xs' ! (j - Suc (Suc m))) \\<le> key (xs' ! k)\n  k - Suc (Suc m) \\<in> {offs ns' 0 ! (i - length ms')..<length xs'}", "show \"key (xs' ! (j - Suc (Suc m))) \\<le>\n        key (xs' ! (k - Suc (Suc m)))\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{offs ns' 0 ! (i - length ms')..<length xs'}.\n     key (xs' ! (j - Suc (Suc m))) \\<le> key (xs' ! k)\n  k - Suc (Suc m) \\<in> {offs ns' 0 ! (i - length ms')..<length xs'}\n\ngoal (1 subgoal):\n 1. key (xs' ! (j - Suc (Suc m))) \\<le> key (xs' ! (k - Suc (Suc m)))", ".."], ["proof (state)\nthis:\n  key (xs' ! (j - Suc (Suc m))) \\<le> key (xs' ! (k - Suc (Suc m)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  key ((ws' @ xs') ! j) \\<le> key ((ws' @ xs') ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sort_inv key (round index key p q r (u, Suc (Suc m) # ns, xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcsort_sort_inv:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_mono index key\" and\n    C: \"add_inv n t\" and\n    D: \"n \\<le> p\"\n  shows \"\\<lbrakk>t' \\<in> gcsort_set index key p t; sort_inv key t\\<rbrakk> \\<Longrightarrow>\n    sort_inv key t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in> gcsort_set index key p t; sort_inv key t\\<rbrakk>\n    \\<Longrightarrow> sort_inv key t'", "by (erule gcsort_set.induct, simp, drule gcsort_add_inv [OF A _ C D],\n rule round_sort_inv [OF A B], simp_all del: bn_inv.simps, erule conjE,\n frule sym, erule subst, rule bn_inv_intro, insert D, simp)"], ["", "text \\<open>\n\\null\n\nThe only remaining task is to address step 10 of the proof method, which is done by proving theorem\n@{text gcsort_sorted}. It holds under the conditions that the objects' number is not larger than the\ncounters' upper bound and function @{text index} satisfies both predicates @{const index_less} and\n@{const index_mono}, and states that function @{const gcsort} is successful in sorting the input\nobjects' list.\n\n\\null\n\\<close>"], ["", "theorem gcsort_sorted:\n  assumes\n    A: \"index_less index key\" and\n    B: \"index_mono index key\" and\n    C: \"length xs \\<le> p\"\n  shows \"sorted (map key (gcsort index key p xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "let ?t = \"(0, [length xs], xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "have \"sort_inv key (gcsort_aux index key p ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_inv key (gcsort_aux index key p (0, [length xs], xs))", "by (rule gcsort_sort_inv [OF A B _ C], rule gcsort_add_input,\n     rule gcsort_aux_set, rule gcsort_sort_input)"], ["proof (state)\nthis:\n  sort_inv key (gcsort_aux index key p (0, [length xs], xs))\n\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "moreover"], ["proof (state)\nthis:\n  sort_inv key (gcsort_aux index key p (0, [length xs], xs))\n\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "have \"add_inv (length xs) (gcsort_aux index key p ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_inv (length xs) (gcsort_aux index key p (0, [length xs], xs))", "by (rule gcsort_add_inv [OF A _ _ C],\n     rule gcsort_aux_set, rule gcsort_add_input)"], ["proof (state)\nthis:\n  add_inv (length xs) (gcsort_aux index key p (0, [length xs], xs))\n\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "ultimately"], ["proof (chain)\npicking this:\n  sort_inv key (gcsort_aux index key p (0, [length xs], xs))\n  add_inv (length xs) (gcsort_aux index key p (0, [length xs], xs))", "have \"sorted (map key (gcsort_out (gcsort_aux index key p ?t)))\""], ["proof (prove)\nusing this:\n  sort_inv key (gcsort_aux index key p (0, [length xs], xs))\n  add_inv (length xs) (gcsort_aux index key p (0, [length xs], xs))\n\ngoal (1 subgoal):\n 1. sorted\n     (map key (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))", "by (rule gcsort_sort_intro, simp add: gcsort_sort_form)"], ["proof (state)\nthis:\n  sorted\n   (map key (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))\n\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "moreover"], ["proof (state)\nthis:\n  sorted\n   (map key (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))\n\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "have \"?t = gcsort_in xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0, [length xs], xs) = gcsort_in xs", "by (simp add: gcsort_in_def)"], ["proof (state)\nthis:\n  (0, [length xs], xs) = gcsort_in xs\n\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "ultimately"], ["proof (chain)\npicking this:\n  sorted\n   (map key (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))\n  (0, [length xs], xs) = gcsort_in xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted\n   (map key (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))\n  (0, [length xs], xs) = gcsort_in xs\n\ngoal (1 subgoal):\n 1. sorted (map key (gcsort index key p xs))", "by (simp add: gcsort_def)"], ["proof (state)\nthis:\n  sorted (map key (gcsort index key p xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}