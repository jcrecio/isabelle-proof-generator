{"file_name": "/home/qj213/afp-2021-10-22/thys/Generalized_Counting_Sort/Conservation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Generalized_Counting_Sort", "problem_names": ["lemma gcsort_count_input:\n \"count_inv (count (mset xs)) (0, [length xs], xs)\"", "lemma gcsort_count_intro:\n \"count_inv f t \\<Longrightarrow> count (mset (gcsort_out t)) x = f x\"", "lemma offs_num_cons:\n \"offs_num n (x # xs) index key mi ma i =\n   (if index key x n mi ma = i then Suc else id) (offs_num n xs index key mi ma i)\"", "lemma offs_next_prev:\n \"(0 < offs_num (length ns) xs index key mi ma i \\<and>\n    offs_set_next ns xs index key mi ma i \\<noteq> {} \\<and>\n    Min (offs_set_next ns xs index key mi ma i) = j) =\n  (0 < offs_num (length ns) xs index key mi ma j \\<and>\n    offs_set_prev ns xs index key mi ma j \\<noteq> {} \\<and>\n    Max (offs_set_prev ns xs index key mi ma j) = i)\"\n  (is \"?P = ?Q\")", "lemma offs_next_cons_eq:\n  assumes\n    A: \"index key x (length ns) mi ma = i\" and\n    B: \"i < length ns\" and\n    C: \"0 < offs_num (length ns) (x # xs) index key mi ma j\"\n  shows\n   \"offs_set_prev ns (x # xs) index key mi ma i = {} \\<or>\n      Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n      offs_next ns ub (x # xs) index key mi ma j\"\n  (is \"?P \\<or> ?Q \\<Longrightarrow> _\")", "lemma offs_next_cons_neq:\n  assumes\n    A: \"index key x (length ns) mi ma = i\" and\n    B: \"offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\" and\n    C: \"Max (offs_set_prev ns (x # xs) index key mi ma i) = j\"\n  shows \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    (if 0 < offs_num (length ns) xs index key mi ma i\n     then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)\"", "lemma offs_pred_ub_aux [rule_format]:\n  assumes A: \"offs_pred ns ub xs index key mi ma\"\n  shows \"i < length ns \\<Longrightarrow>\n    \\<forall>j < length ns. i \\<le> j \\<longrightarrow> 0 < offs_num (length ns) xs index key mi ma j \\<longrightarrow>\n      ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ub\"", "lemma offs_pred_ub:\n \"\\<lbrakk>offs_pred ns ub xs index key mi ma; i < length ns;\n   0 < offs_num (length ns) xs index key mi ma i\\<rbrakk> \\<Longrightarrow>\n     ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ub\"", "lemma offs_pred_asc_aux [rule_format]:\n  assumes A: \"offs_pred ns ub xs index key mi ma\"\n  shows \"i < length ns \\<Longrightarrow>\n    \\<forall>j k. k < length ns \\<longrightarrow> i \\<le> j \\<longrightarrow> j < k \\<longrightarrow>\n      0 < offs_num (length ns) xs index key mi ma j \\<longrightarrow>\n      0 < offs_num (length ns) xs index key mi ma k \\<longrightarrow>\n      ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ns ! k\"", "lemma offs_pred_asc:\n \"\\<lbrakk>offs_pred ns ub xs index key mi ma; i < j; j < length ns;\n   0 < offs_num (length ns) xs index key mi ma i;\n   0 < offs_num (length ns) xs index key mi ma j\\<rbrakk> \\<Longrightarrow>\n     ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ns ! j\"", "lemma offs_pred_next:\n  assumes\n    A: \"offs_pred ns ub xs index key mi ma\" and\n    B: \"i < length ns\" and\n    C: \"0 < offs_num (length ns) xs index key mi ma i\"\n  shows \"ns ! i < offs_next ns ub xs index key mi ma i\"", "lemma offs_pred_next_cons_less:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\" and\n    D: \"Max (offs_set_prev ns (x # xs) index key mi ma i) = j\"\n  shows \"offs_next ns ub (x # xs) index key mi ma j <\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\"\n  (is \"?M < ?N\")", "lemma offs_pred_next_cons:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"i < length ns\" and\n    D: \"0 < offs_num (length ns) (x # xs) index key mi ma j\"\n  shows \"offs_next ns ub (x # xs) index key mi ma j \\<le>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\"\n  (is \"?M \\<le> ?N\")", "lemma offs_pred_cons:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"i < length ns\"\n  shows \"offs_pred (ns[i := Suc (ns ! i)]) ub xs index key mi ma\"", "lemma offs_next_zero:\n  assumes\n    A: \"i < length ns\" and\n    B: \"offs_num (length ns) xs index key mi ma i = 0\" and\n    C: \"offs_set_prev ns xs index key mi ma i = {}\"\n  shows \"offs_next ns ub xs index key mi ma 0 =\n    offs_next ns ub xs index key mi ma i\"", "lemma offs_next_zero_cons_eq:\n  assumes\n    A: \"index key x (length ns) mi ma = i\" and\n    B: \"offs_num (length ns) (x # xs) index key mi ma 0 = 0\" and\n    C: \"offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\"\n      (is \"?A \\<noteq> _\")\n  shows \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0\"", "lemma offs_next_zero_cons_neq:\n  assumes\n    A: \"index key x (length ns) mi ma = i\" and\n    B: \"i < length ns\" and\n    C: \"0 < i\" and\n    D: \"offs_set_prev ns (x # xs) index key mi ma i = {}\"\n  shows \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    (if 0 < offs_num (length ns) xs index key mi ma i\n     then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)\"", "lemma offs_pred_zero_cons_less:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"i < length ns\" and\n    D: \"0 < i\" and\n    E: \"offs_set_prev ns (x # xs) index key mi ma i = {}\"\n  shows \"offs_next ns ub (x # xs) index key mi ma 0 <\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\"\n  (is \"?M < ?N\")", "lemma offs_pred_zero_cons:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"i < length ns\" and\n    D: \"offs_num (length ns) (x # xs) index key mi ma 0 = 0\"\n  shows \"offs_next ns ub (x # xs) index key mi ma 0 \\<le>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\"\n  (is \"?M \\<le> ?N\")", "lemma replicate_count:\n \"count (mset (replicate n x)) x = n\"", "lemma fill_none [rule_format]:\n  assumes A: \"index_less index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    offs_none ns ub xs index key mi ma i \\<longrightarrow>\n      fill xs ns index key ub mi ma ! i = None\"", "lemma fill_index_none [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"key x \\<in> {mi..ma}\" and\n    C: \"ns \\<noteq> []\" and\n    D: \"offs_pred ns ub (x # xs) index key mi ma\"\n  shows \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n    fill xs (ns[(index key x (length ns) mi ma) :=\n      Suc (ns ! index key x (length ns) mi ma)]) index key ub mi ma !\n        (ns ! index key x (length ns) mi ma) = None\"\n  (is \"_ \\<Longrightarrow> fill _ ?ns' _ _ _ _ _ ! (_ ! ?i) = _\")", "lemma fill_count_item [rule_format]:\n  assumes A: \"index_less index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    length xs \\<le> ub \\<longrightarrow>\n      count (mset (map the (fill xs ns index key ub mi ma))) x =\n      count (mset xs) x + (if the None = x then ub - length xs else 0)\"", "lemma enum_offs_num:\n \"i < n \\<Longrightarrow> enum xs index key n mi ma ! i = offs_num n xs index key mi ma i\"", "lemma offs_length:\n \"length (offs ns i) = length ns\"", "lemma offs_add [rule_format]:\n \"i < length ns \\<longrightarrow> offs ns k ! i = foldl (+) k (take i ns)\"", "lemma offs_mono_aux:\n \"i \\<le> j \\<Longrightarrow> j < length ns \\<Longrightarrow> offs ns k ! i \\<le> offs ns k ! (i + (j - i))\"", "lemma offs_mono:\n \"i \\<le> j \\<Longrightarrow> j < length ns \\<Longrightarrow> offs ns k ! i \\<le> offs ns k ! j\"", "lemma offs_update:\n \"j < length ns \\<Longrightarrow>\n    offs (ns[i := Suc (ns ! i)]) k ! j = (if j \\<le> i then id else Suc) (offs ns k ! j)\"", "lemma offs_equal_suc:\n  assumes\n    A: \"Suc i < length ns\" and\n    B: \"ns ! i = 0\"\n  shows \"offs ns m ! i = offs ns m ! Suc i\"", "lemma offs_equal [rule_format]:\n \"i < j \\<Longrightarrow> j < length ns \\<Longrightarrow>\n    (\\<forall>k \\<in> {i..<j}. ns ! k = 0) \\<longrightarrow> offs ns m ! i = offs ns m ! j\"", "lemma offs_enum_last [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"0 < n\" and\n    C: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) = length xs + k\"", "lemma offs_enum_ub [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"i < n\" and\n    C: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"offs (enum xs index key n mi ma) k ! i \\<le> length xs + k\"", "lemma offs_enum_next_ge [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"i < n\"\n  shows \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i \\<le>\n      offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n        xs index key mi ma i\"\n  (is \"_ \\<Longrightarrow> offs ?ns _ ! _ \\<le> _\")", "lemma offs_enum_zero_aux [rule_format]:\n \"\\<lbrakk>index_less index key; 0 < n; \\<forall>x \\<in> set xs. key x \\<in> {mi..ma};\n   offs_num n xs index key mi ma (n - Suc 0) = 0\\<rbrakk> \\<Longrightarrow>\n     offs (enum xs index key n mi ma) k ! (n - Suc 0) = length xs + k\"", "lemma offs_enum_zero [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"i < n\" and\n    C: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\" and\n    D: \"offs_num n xs index key mi ma i = 0\"\n  shows \"offs (enum xs index key n mi ma) k ! i =\n    offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n      xs index key mi ma i\"", "lemma offs_enum_next_cons [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"(if i < index key x n mi ma then (\\<le>) else (<))\n    (offs_next (offs (enum xs index key n mi ma) k)\n      (length xs + k) xs index key mi ma i)\n    (offs_next (offs ((enum xs index key n mi ma) [index key x n mi ma :=\n      Suc (enum xs index key n mi ma ! index key x n mi ma)]) k)\n      (Suc (length xs + k)) (x # xs) index key mi ma i)\"\n  (is \"(if i < ?i' then _ else _)\n    (offs_next (offs ?ns _) _ _ _ _ _ _ _)\n    (offs_next (offs ?ns' _) _ _ _ _ _ _ _)\")", "lemma offs_enum_pred [rule_format]:\n  assumes A: \"index_less index key\"\n  shows \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    offs_pred (offs (enum xs index key n mi ma) k) (length xs + k)\n      xs index key mi ma\"", "lemma fill_offs_enum_count_item [rule_format]:\n \"\\<lbrakk>index_less index key; \\<forall>x \\<in> set xs. key x \\<in> {mi..ma}; 0 < n\\<rbrakk> \\<Longrightarrow>\n    count (mset (map the (fill xs (offs (enum xs index key n mi ma) 0)\n      index key (length xs) mi ma))) x =\n    count (mset xs) x\"", "lemma nths_count:\n \"count (mset (nths xs A)) x =\n    count (mset xs) x - card {i. i < length xs \\<and> i \\<notin> A \\<and> xs ! i = x}\"", "lemma round_count_inv [rule_format]:\n \"index_less index key \\<longrightarrow> bn_inv p q t \\<longrightarrow> add_inv n t \\<longrightarrow> count_inv f t \\<longrightarrow>\n    count_inv f (round index key p q r t)\"", "lemma gcsort_count_inv:\n  assumes\n    A: \"index_less index key\" and\n    B: \"add_inv n t\" and\n    C: \"n \\<le> p\"\n  shows \"\\<lbrakk>t' \\<in> gcsort_set index key p t; count_inv f t\\<rbrakk> \\<Longrightarrow>\n    count_inv f t'\"", "theorem gcsort_count:\n  assumes\n    A: \"index_less index key\" and\n    B: \"length xs \\<le> p\"\n  shows \"count (mset (gcsort index key p xs)) x = count (mset xs) x\""], "translations": [["", "lemma gcsort_count_input:\n \"count_inv (count (mset xs)) (0, [length xs], xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_inv (count (mset xs)) (0, [length xs], xs)", "by simp"], ["", "lemma gcsort_count_intro:\n \"count_inv f t \\<Longrightarrow> count (mset (gcsort_out t)) x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_inv f t \\<Longrightarrow> count (mset (gcsort_out t)) x = f x", "by (cases t, simp add: gcsort_out_def)"], ["", "text \\<open>\n\\null\n\nThe main task to be accomplished to prove that GCsort conserves objects is to prove that so does\nfunction @{const fill} in case its input offsets' list is computed via the composition of functions\n@{const offs} and @{const enum}, as happens within function @{const round}.\n\nTo achieve this result, a multi-step strategy will be adopted. The first step, addressed here below,\nopens with the definition of predicate @{text offs_pred}, satisfied by an offsets' list $ns$ and an\nobjects' list $xs$ just in case each bucket delimited by $ns$ is sufficiently large to accommodate\nthe corresponding objects in $xs$. Then, lemma @{text offs_pred_cons} shows that this predicate, if\nsatisfied initially, keeps being true if each object in $xs$ is consumed as happens within function\n@{const fill}, viz. increasing the corresponding offset in $ns$ by one.\n\n\\null\n\\<close>"], ["", "definition offs_num :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b) index_sign \\<Rightarrow>\n  ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> nat \\<Rightarrow> nat\" where\n\"offs_num n xs index key mi ma i \\<equiv>\n  length [x\\<leftarrow>xs. index key x n mi ma = i]\""], ["", "abbreviation offs_set_next :: \"nat list \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b) index_sign \\<Rightarrow>\n  ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> nat \\<Rightarrow> nat set\" where\n\"offs_set_next ns xs index key mi ma i \\<equiv>\n  {k. k < length ns \\<and> i < k \\<and> 0 < offs_num (length ns) xs index key mi ma k}\""], ["", "abbreviation offs_set_prev :: \"nat list \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b) index_sign \\<Rightarrow>\n  ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> nat \\<Rightarrow> nat set\" where\n\"offs_set_prev ns xs index key mi ma i \\<equiv>\n  {k. i < length ns \\<and> k < i \\<and> 0 < offs_num (length ns) xs index key mi ma k}\""], ["", "definition offs_next :: \"nat list \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b) index_sign \\<Rightarrow>\n  ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> nat \\<Rightarrow> nat\" where\n\"offs_next ns ub xs index key mi ma i \\<equiv>\n  if offs_set_next ns xs index key mi ma i = {}\n  then ub else ns ! Min (offs_set_next ns xs index key mi ma i)\""], ["", "definition offs_none :: \"nat list \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b) index_sign \\<Rightarrow>\n  ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"offs_none ns ub xs index key mi ma i \\<equiv>\n  (\\<exists>j < length ns. 0 < offs_num (length ns) xs index key mi ma j \\<and>\n    i \\<in> {ns ! j + offs_num (length ns) xs index key mi ma j..<\n      offs_next ns ub xs index key mi ma j}) \\<or>\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n    i < offs_next ns ub xs index key mi ma 0 \\<or>\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n    i < ns ! 0\""], ["", "definition offs_pred :: \"nat list \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b) index_sign \\<Rightarrow>\n  ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> bool\" where\n\"offs_pred ns ub xs index key mi ma \\<equiv>\n  \\<forall>i < length ns. offs_num (length ns) xs index key mi ma i \\<le>\n    offs_next ns ub xs index key mi ma i - ns ! i\""], ["", "lemma offs_num_cons:\n \"offs_num n (x # xs) index key mi ma i =\n   (if index key x n mi ma = i then Suc else id) (offs_num n xs index key mi ma i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_num n (x # xs) index key mi ma i =\n    (if index key x n mi ma = i then Suc else id)\n     (offs_num n xs index key mi ma i)", "by (simp add: offs_num_def)"], ["", "lemma offs_next_prev:\n \"(0 < offs_num (length ns) xs index key mi ma i \\<and>\n    offs_set_next ns xs index key mi ma i \\<noteq> {} \\<and>\n    Min (offs_set_next ns xs index key mi ma i) = j) =\n  (0 < offs_num (length ns) xs index key mi ma j \\<and>\n    offs_set_prev ns xs index key mi ma j \\<noteq> {} \\<and>\n    Max (offs_set_prev ns xs index key mi ma j) = i)\"\n  (is \"?P = ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < offs_num (length ns) xs index key mi ma i \\<and>\n     offs_set_next ns xs index key mi ma i \\<noteq> {} \\<and>\n     Min (offs_set_next ns xs index key mi ma i) = j) =\n    (0 < offs_num (length ns) xs index key mi ma j \\<and>\n     offs_set_prev ns xs index key mi ma j \\<noteq> {} \\<and>\n     Max (offs_set_prev ns xs index key mi ma j) = i)", "proof (rule iffI, (erule_tac [!] conjE)+)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_set_next ns xs index key mi ma i \\<noteq> {};\n     Min (offs_set_next ns xs index key mi ma i) = j\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma j \\<and>\n                      offs_set_prev ns xs index key mi ma j \\<noteq>\n                      {} \\<and>\n                      Max (offs_set_prev ns xs index key mi ma j) = i\n 2. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "let ?A = \"offs_set_next ns xs index key mi ma i\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_set_next ns xs index key mi ma i \\<noteq> {};\n     Min (offs_set_next ns xs index key mi ma i) = j\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma j \\<and>\n                      offs_set_prev ns xs index key mi ma j \\<noteq>\n                      {} \\<and>\n                      Max (offs_set_prev ns xs index key mi ma j) = i\n 2. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "let ?B = \"offs_set_prev ns xs index key mi ma j\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_set_next ns xs index key mi ma i \\<noteq> {};\n     Min (offs_set_next ns xs index key mi ma i) = j\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma j \\<and>\n                      offs_set_prev ns xs index key mi ma j \\<noteq>\n                      {} \\<and>\n                      Max (offs_set_prev ns xs index key mi ma j) = i\n 2. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "assume\n    A: \"0 < offs_num (length ns) xs index key mi ma i\" and\n    B: \"?A \\<noteq> {}\" and\n    C: \"Min ?A = j\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma i\n  offs_set_next ns xs index key mi ma i \\<noteq> {}\n  Min (offs_set_next ns xs index key mi ma i) = j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_set_next ns xs index key mi ma i \\<noteq> {};\n     Min (offs_set_next ns xs index key mi ma i) = j\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma j \\<and>\n                      offs_set_prev ns xs index key mi ma j \\<noteq>\n                      {} \\<and>\n                      Max (offs_set_prev ns xs index key mi ma j) = i\n 2. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "have \"Min ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma i)\n    \\<in> offs_set_next ns xs index key mi ma i", "using B"], ["proof (prove)\nusing this:\n  offs_set_next ns xs index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma i)\n    \\<in> offs_set_next ns xs index key mi ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma i)\n  \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_set_next ns xs index key mi ma i \\<noteq> {};\n     Min (offs_set_next ns xs index key mi ma i) = j\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma j \\<and>\n                      offs_set_prev ns xs index key mi ma j \\<noteq>\n                      {} \\<and>\n                      Max (offs_set_prev ns xs index key mi ma j) = i\n 2. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "hence D: \"j \\<in> ?A\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma i)\n  \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next ns xs index key mi ma i", "using C"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma i)\n  \\<in> offs_set_next ns xs index key mi ma i\n  Min (offs_set_next ns xs index key mi ma i) = j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next ns xs index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_set_next ns xs index key mi ma i \\<noteq> {};\n     Min (offs_set_next ns xs index key mi ma i) = j\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma j \\<and>\n                      offs_set_prev ns xs index key mi ma j \\<noteq>\n                      {} \\<and>\n                      Max (offs_set_prev ns xs index key mi ma j) = i\n 2. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "hence E: \"i \\<in> ?B\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. i \\<in> offs_set_prev ns xs index key mi ma j", "using A"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next ns xs index key mi ma i\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (1 subgoal):\n 1. i \\<in> offs_set_prev ns xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  i \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_set_next ns xs index key mi ma i \\<noteq> {};\n     Min (offs_set_next ns xs index key mi ma i) = j\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma j \\<and>\n                      offs_set_prev ns xs index key mi ma j \\<noteq>\n                      {} \\<and>\n                      Max (offs_set_prev ns xs index key mi ma j) = i\n 2. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "show ?Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<and>\n    offs_set_prev ns xs index key mi ma j \\<noteq> {} \\<and>\n    Max (offs_set_prev ns xs index key mi ma j) = i", "proof (rule conjI, rule_tac [2] conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j\n 2. offs_set_prev ns xs index key mi ma j \\<noteq> {}\n 3. Max (offs_set_prev ns xs index key mi ma j) = i", "show \"0 < offs_num (length ns) xs index key mi ma j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma j", "using D"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (2 subgoals):\n 1. offs_set_prev ns xs index key mi ma j \\<noteq> {}\n 2. Max (offs_set_prev ns xs index key mi ma j) = i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. offs_set_prev ns xs index key mi ma j \\<noteq> {}\n 2. Max (offs_set_prev ns xs index key mi ma j) = i", "show \"?B \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_set_prev ns xs index key mi ma j \\<noteq> {}", "using E"], ["proof (prove)\nusing this:\n  i \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_set_prev ns xs index key mi ma j \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  offs_set_prev ns xs index key mi ma j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns xs index key mi ma j) = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns xs index key mi ma j) = i", "from E"], ["proof (chain)\npicking this:\n  i \\<in> offs_set_prev ns xs index key mi ma j", "show \"Max ?B = i\""], ["proof (prove)\nusing this:\n  i \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns xs index key mi ma j) = i", "proof (subst Max_eq_iff, simp, blast, simp, rule_tac allI, rule_tac impI,\n     (erule_tac conjE)+, rule_tac ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>j < length ns; a < j;\n        0 < offs_num (length ns) xs index key mi ma a;\n        0 < offs_num (length ns) xs index key mi ma i;\n        \\<not> a \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>j < length ns; a < j;\n        0 < offs_num (length ns) xs index key mi ma a;\n        0 < offs_num (length ns) xs index key mi ma i;\n        \\<not> a \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "assume F: \"k < j\" and \"j < length ns\""], ["proof (state)\nthis:\n  k < j\n  j < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>j < length ns; a < j;\n        0 < offs_num (length ns) xs index key mi ma a;\n        0 < offs_num (length ns) xs index key mi ma i;\n        \\<not> a \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"k < length ns\""], ["proof (prove)\nusing this:\n  k < j\n  j < length ns\n\ngoal (1 subgoal):\n 1. k < length ns", "by simp"], ["proof (state)\nthis:\n  k < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>j < length ns; a < j;\n        0 < offs_num (length ns) xs index key mi ma a;\n        0 < offs_num (length ns) xs index key mi ma i;\n        \\<not> a \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  k < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>j < length ns; a < j;\n        0 < offs_num (length ns) xs index key mi ma a;\n        0 < offs_num (length ns) xs index key mi ma i;\n        \\<not> a \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "assume\n       \"\\<not> k \\<le> i\" and\n       \"0 < offs_num (length ns) xs index key mi ma k\""], ["proof (state)\nthis:\n  \\<not> k \\<le> i\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>j < length ns; a < j;\n        0 < offs_num (length ns) xs index key mi ma a;\n        0 < offs_num (length ns) xs index key mi ma i;\n        \\<not> a \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  k < length ns\n  \\<not> k \\<le> i\n  0 < offs_num (length ns) xs index key mi ma k", "have \"k \\<in> ?A\""], ["proof (prove)\nusing this:\n  k < length ns\n  \\<not> k \\<le> i\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (1 subgoal):\n 1. k \\<in> offs_set_next ns xs index key mi ma i", "by simp"], ["proof (state)\nthis:\n  k \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>j < length ns; a < j;\n        0 < offs_num (length ns) xs index key mi ma a;\n        0 < offs_num (length ns) xs index key mi ma i;\n        \\<not> a \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"Min ?A \\<le> k\""], ["proof (prove)\nusing this:\n  k \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma i) \\<le> k", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma i) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>j < length ns; a < j;\n        0 < offs_num (length ns) xs index key mi ma a;\n        0 < offs_num (length ns) xs index key mi ma i;\n        \\<not> a \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma i) \\<le> k\n\ngoal (1 subgoal):\n 1. False", "using C and F"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma i) \\<le> k\n  Min (offs_set_next ns xs index key mi ma i) = j\n  k < j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (offs_set_prev ns xs index key mi ma j) = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  offs_set_prev ns xs index key mi ma j \\<noteq> {} \\<and>\n  Max (offs_set_prev ns xs index key mi ma j) = i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "let ?A = \"offs_set_prev ns xs index key mi ma j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "let ?B = \"offs_set_next ns xs index key mi ma i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "assume\n    A: \"0 < offs_num (length ns) xs index key mi ma j\" and\n    B: \"?A \\<noteq> {}\" and\n    C: \"Max ?A = i\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j\n  offs_set_prev ns xs index key mi ma j \\<noteq> {}\n  Max (offs_set_prev ns xs index key mi ma j) = i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "have \"Max ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns xs index key mi ma j)\n    \\<in> offs_set_prev ns xs index key mi ma j", "using B"], ["proof (prove)\nusing this:\n  offs_set_prev ns xs index key mi ma j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns xs index key mi ma j)\n    \\<in> offs_set_prev ns xs index key mi ma j", "by (rule_tac Max_in, simp)"], ["proof (state)\nthis:\n  Max (offs_set_prev ns xs index key mi ma j)\n  \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "hence D: \"i \\<in> ?A\""], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns xs index key mi ma j)\n  \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. i \\<in> offs_set_prev ns xs index key mi ma j", "using C"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns xs index key mi ma j)\n  \\<in> offs_set_prev ns xs index key mi ma j\n  Max (offs_set_prev ns xs index key mi ma j) = i\n\ngoal (1 subgoal):\n 1. i \\<in> offs_set_prev ns xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  i \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "hence E: \"j \\<in> ?B\""], ["proof (prove)\nusing this:\n  i \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next ns xs index key mi ma i", "using A"], ["proof (prove)\nusing this:\n  i \\<in> offs_set_prev ns xs index key mi ma j\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next ns xs index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma j;\n     offs_set_prev ns xs index key mi ma j \\<noteq> {};\n     Max (offs_set_prev ns xs index key mi ma j) = i\\<rbrakk>\n    \\<Longrightarrow> 0 < offs_num (length ns) xs index key mi ma i \\<and>\n                      offs_set_next ns xs index key mi ma i \\<noteq>\n                      {} \\<and>\n                      Min (offs_set_next ns xs index key mi ma i) = j", "show ?P"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<and>\n    offs_set_next ns xs index key mi ma i \\<noteq> {} \\<and>\n    Min (offs_set_next ns xs index key mi ma i) = j", "proof (rule conjI, rule_tac [2] conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i\n 2. offs_set_next ns xs index key mi ma i \\<noteq> {}\n 3. Min (offs_set_next ns xs index key mi ma i) = j", "show \"0 < offs_num (length ns) xs index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma i", "using D"], ["proof (prove)\nusing this:\n  i \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma i", "by simp"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (2 subgoals):\n 1. offs_set_next ns xs index key mi ma i \\<noteq> {}\n 2. Min (offs_set_next ns xs index key mi ma i) = j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. offs_set_next ns xs index key mi ma i \\<noteq> {}\n 2. Min (offs_set_next ns xs index key mi ma i) = j", "show \"?B \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma i \\<noteq> {}", "using E"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma i \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  offs_set_next ns xs index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma i) = j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma i) = j", "from E"], ["proof (chain)\npicking this:\n  j \\<in> offs_set_next ns xs index key mi ma i", "show \"Min ?B = j\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma i) = j", "proof (subst Min_eq_iff, simp, blast, simp, rule_tac allI, rule_tac impI,\n     (erule_tac conjE)+, rule_tac ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>j < length ns;\n        0 < offs_num (length ns) xs index key mi ma j; i < x;\n        0 < offs_num (length ns) xs index key mi ma x;\n        \\<not> j \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>j < length ns;\n        0 < offs_num (length ns) xs index key mi ma j; i < x;\n        0 < offs_num (length ns) xs index key mi ma x;\n        \\<not> j \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "assume\n       \"j < length ns\" and\n       \"\\<not> j \\<le> k\" and\n       \"0 < offs_num (length ns) xs index key mi ma k\""], ["proof (state)\nthis:\n  j < length ns\n  \\<not> j \\<le> k\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>j < length ns;\n        0 < offs_num (length ns) xs index key mi ma j; i < x;\n        0 < offs_num (length ns) xs index key mi ma x;\n        \\<not> j \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"k \\<in> ?A\""], ["proof (prove)\nusing this:\n  j < length ns\n  \\<not> j \\<le> k\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (1 subgoal):\n 1. k \\<in> offs_set_prev ns xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  k \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>j < length ns;\n        0 < offs_num (length ns) xs index key mi ma j; i < x;\n        0 < offs_num (length ns) xs index key mi ma x;\n        \\<not> j \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"k \\<le> Max ?A\""], ["proof (prove)\nusing this:\n  k \\<in> offs_set_prev ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. k \\<le> Max (offs_set_prev ns xs index key mi ma j)", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  k \\<le> Max (offs_set_prev ns xs index key mi ma j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>j < length ns;\n        0 < offs_num (length ns) xs index key mi ma j; i < x;\n        0 < offs_num (length ns) xs index key mi ma x;\n        \\<not> j \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  k \\<le> Max (offs_set_prev ns xs index key mi ma j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>j < length ns;\n        0 < offs_num (length ns) xs index key mi ma j; i < x;\n        0 < offs_num (length ns) xs index key mi ma x;\n        \\<not> j \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"i < k\""], ["proof (state)\nthis:\n  i < k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>j < length ns;\n        0 < offs_num (length ns) xs index key mi ma j; i < x;\n        0 < offs_num (length ns) xs index key mi ma x;\n        \\<not> j \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  k \\<le> Max (offs_set_prev ns xs index key mi ma j)\n  i < k", "show False"], ["proof (prove)\nusing this:\n  k \\<le> Max (offs_set_prev ns xs index key mi ma j)\n  i < k\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  k \\<le> Max (offs_set_prev ns xs index key mi ma j)\n  i < k\n  Max (offs_set_prev ns xs index key mi ma j) = i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma i) = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma i \\<and>\n  offs_set_next ns xs index key mi ma i \\<noteq> {} \\<and>\n  Min (offs_set_next ns xs index key mi ma i) = j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_next_cons_eq:\n  assumes\n    A: \"index key x (length ns) mi ma = i\" and\n    B: \"i < length ns\" and\n    C: \"0 < offs_num (length ns) (x # xs) index key mi ma j\"\n  shows\n   \"offs_set_prev ns (x # xs) index key mi ma i = {} \\<or>\n      Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n      offs_next ns ub (x # xs) index key mi ma j\"\n  (is \"?P \\<or> ?Q \\<Longrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_set_prev ns (x # xs) index key mi ma i = {} \\<or>\n    Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq>\n    j \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma j", "proof (simp only: disj_imp, cases \"j < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "let ?A = \"offs_set_prev ns (x # xs) index key mi ma i\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "let ?B = \"offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "let ?C = \"offs_set_next ns (x # xs) index key mi ma j\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "case True"], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence D: \"j \\<in> ?A\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns (x # xs) index key mi ma i", "using B and C"], ["proof (prove)\nusing this:\n  j < i\n  i < length ns\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence \"j \\<le> Max ?A\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. j \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  j \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "moreover"], ["proof (state)\nthis:\n  j \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "assume \"\\<not> ?P \\<longrightarrow> ?Q\""], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<longrightarrow>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence ?Q"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<longrightarrow>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j", "using D"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<longrightarrow>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j", "by blast"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "ultimately"], ["proof (chain)\npicking this:\n  j \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n  Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j", "have E: \"j < Max ?A\""], ["proof (prove)\nusing this:\n  j \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n  Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j\n\ngoal (1 subgoal):\n 1. j < Max (offs_set_prev ns (x # xs) index key mi ma i)", "by simp"], ["proof (state)\nthis:\n  j < Max (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "have F: \"Max ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_prev ns (x # xs) index key mi ma i", "using D"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_prev ns (x # xs) index key mi ma i", "by (rule_tac Max_in, simp, blast)"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "have G: \"Max ?A \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j", "proof (simp, rule conjI, rule_tac [2] conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i) < length ns\n 2. j < Max (offs_set_prev ns (x # xs) index key mi ma i)\n 3. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "show \"Max ?A < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i) < length ns", "using F"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i) < length ns", "by auto"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma i) < length ns\n\ngoal (2 subgoals):\n 1. j < Max (offs_set_prev ns (x # xs) index key mi ma i)\n 2. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. j < Max (offs_set_prev ns (x # xs) index key mi ma i)\n 2. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "show \"j < Max ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < Max (offs_set_prev ns (x # xs) index key mi ma i)", "using E"], ["proof (prove)\nusing this:\n  j < Max (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. j < Max (offs_set_prev ns (x # xs) index key mi ma i)", "."], ["proof (state)\nthis:\n  j < Max (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "have \"0 < offs_num (length ns) (x # xs) index key mi ma (Max ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "using F"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "by blast"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma i))\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "moreover"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma i))\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "have \"Max ?A < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i) < i", "using F"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i) < i", "by blast"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "ultimately"], ["proof (chain)\npicking this:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma i))\n  Max (offs_set_prev ns (x # xs) index key mi ma i) < i", "show \"0 < offs_num (length ns) xs index key mi ma (Max ?A)\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma i))\n  Max (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "using A"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma i))\n  Max (offs_set_prev ns (x # xs) index key mi ma i) < i\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma i))", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence H: \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    ns[i := Suc (ns ! i)] ! Min ?B\""], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    ns[i := Suc (ns ! i)] !\n    Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)", "by (simp only: offs_next_def split: if_split, blast)"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  ns[i := Suc (ns ! i)] !\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "have \"Min ?B \\<le> Max ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n    \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)", "using G"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n    \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "have \"Max ?A < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i) < i", "using F"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i) < i", "by blast"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n  Max (offs_set_prev ns (x # xs) index key mi ma i) < i", "have I: \"Min ?B < i\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n  Max (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) < i", "by simp"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence J: \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    ns ! Min ?B\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) < i\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    ns ! Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)", "using H"], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) < i\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  ns[i := Suc (ns ! i)] !\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    ns ! Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)", "by simp"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  ns ! Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "have \"Min ?B \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n    \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j", "using G"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n    \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j", "by (rule_tac Min_in, simp, blast)"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence K: \"Min ?B \\<in> ?C\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n    \\<in> offs_set_next ns (x # xs) index key mi ma j", "using A and I"], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n  index key x (length ns) mi ma = i\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) < i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n    \\<in> offs_set_next ns (x # xs) index key mi ma j", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence L: \"Min ?C \\<le> Min ?B\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<le> Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "have \"Min ?C \\<in> ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<in> offs_set_next ns (x # xs) index key mi ma j", "using K"], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<in> offs_set_next ns (x # xs) index key mi ma j", "by (rule_tac Min_in, simp, blast)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "have \"Min ?C < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j) < i", "using L and I"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<le> Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) < i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j) < i", "by simp"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j) < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n  Min (offs_set_next ns (x # xs) index key mi ma j) < i", "have \"Min ?C \\<in> ?B\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n  Min (offs_set_next ns (x # xs) index key mi ma j) < i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j", "using A"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n  Min (offs_set_next ns (x # xs) index key mi ma j) < i\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence \"Min ?B \\<le> Min ?C\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n    \\<le> Min (offs_set_next ns (x # xs) index key mi ma j)", "using G"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n    \\<le> Min (offs_set_next ns (x # xs) index key mi ma j)", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<le> Min (offs_set_next ns (x # xs) index key mi ma j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence \"Min ?B = Min ?C\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<le> Min (offs_set_next ns (x # xs) index key mi ma j)\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) =\n    Min (offs_set_next ns (x # xs) index key mi ma j)", "using L"], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<le> Min (offs_set_next ns (x # xs) index key mi ma j)\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<le> Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) =\n    Min (offs_set_next ns (x # xs) index key mi ma j)", "by simp"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) =\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) =\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "have \"offs_next ns ub (x # xs) index key mi ma j = ns ! Min ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j =\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma j)", "using K"], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j =\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma j)", "by (simp only: offs_next_def split: if_split, blast)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j =\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j\n 2. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) =\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  offs_next ns ub (x # xs) index key mi ma j =\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j)", "show ?thesis"], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) =\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  offs_next ns ub (x # xs) index key mi ma j =\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma j", "using J"], ["proof (prove)\nusing this:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j) =\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  offs_next ns ub (x # xs) index key mi ma j =\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  ns ! Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j)\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma j", "by simp"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "let ?A = \"offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "let ?B = \"offs_set_next ns (x # xs) index key mi ma j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "case False"], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "hence \"?A = ?B\""], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n    offs_set_next ns (x # xs) index key mi ma j", "using A"], ["proof (prove)\nusing this:\n  \\<not> j < i\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n    offs_set_next ns (x # xs) index key mi ma j", "by (rule_tac set_eqI, simp add: offs_num_cons)"], ["proof (state)\nthis:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n             {} \\<longrightarrow>\n             Max (offs_set_prev ns (x # xs) index key mi ma i) \\<noteq> j;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                       ma j =\n                      offs_next ns ub (x # xs) index key mi ma j", "thus ?thesis"], ["proof (prove)\nusing this:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma j", "proof (simp only: offs_next_def split: if_split,\n   (rule_tac conjI, blast, rule_tac impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n             offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next ns (x # xs) index key mi ma j \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> ns[i := Suc (ns ! i)] !\n                      Min (offs_set_next ns (x # xs) index key mi ma j) =\n                      ns ! Min (offs_set_next ns (x # xs) index key mi ma j)", "assume \"?B \\<noteq> {}\""], ["proof (state)\nthis:\n  offs_set_next ns (x # xs) index key mi ma j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n             offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next ns (x # xs) index key mi ma j \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> ns[i := Suc (ns ! i)] !\n                      Min (offs_set_next ns (x # xs) index key mi ma j) =\n                      ns ! Min (offs_set_next ns (x # xs) index key mi ma j)", "hence \"Min ?B \\<in> ?B\""], ["proof (prove)\nusing this:\n  offs_set_next ns (x # xs) index key mi ma j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<in> offs_set_next ns (x # xs) index key mi ma j", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n             offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next ns (x # xs) index key mi ma j \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> ns[i := Suc (ns ! i)] !\n                      Min (offs_set_next ns (x # xs) index key mi ma j) =\n                      ns ! Min (offs_set_next ns (x # xs) index key mi ma j)", "hence \"i < Min ?B\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. i < Min (offs_set_next ns (x # xs) index key mi ma j)", "using False"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. i < Min (offs_set_next ns (x # xs) index key mi ma j)", "by simp"], ["proof (state)\nthis:\n  i < Min (offs_set_next ns (x # xs) index key mi ma j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n             offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next ns (x # xs) index key mi ma j \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma j;\n     offs_set_next ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> ns[i := Suc (ns ! i)] !\n                      Min (offs_set_next ns (x # xs) index key mi ma j) =\n                      ns ! Min (offs_set_next ns (x # xs) index key mi ma j)", "thus \"ns[i := Suc (ns ! i)] ! Min ?B = ns ! Min ?B\""], ["proof (prove)\nusing this:\n  i < Min (offs_set_next ns (x # xs) index key mi ma j)\n\ngoal (1 subgoal):\n 1. ns[i := Suc (ns ! i)] !\n    Min (offs_set_next ns (x # xs) index key mi ma j) =\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma j)", "by simp"], ["proof (state)\nthis:\n  ns[i := Suc (ns ! i)] !\n  Min (offs_set_next ns (x # xs) index key mi ma j) =\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_next_cons_neq:\n  assumes\n    A: \"index key x (length ns) mi ma = i\" and\n    B: \"offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\" and\n    C: \"Max (offs_set_prev ns (x # xs) index key mi ma i) = j\"\n  shows \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    (if 0 < offs_num (length ns) xs index key mi ma i\n     then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)", "proof (simp, rule conjI, rule_tac [!] impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "let ?A = \"offs_set_next ns (x # xs) index key mi ma j\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "assume \"0 < offs_num (length ns) xs index key mi ma i\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "with A"], ["proof (chain)\npicking this:\n  index key x (length ns) mi ma = i\n  0 < offs_num (length ns) xs index key mi ma i", "have \"offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j = ?A\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n    offs_set_next ns (x # xs) index key mi ma j", "by (rule_tac set_eqI, rule_tac iffI, simp_all add: offs_num_cons split:\n     if_split_asm)"], ["proof (state)\nthis:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma j\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "moreover"], ["proof (state)\nthis:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma j\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "have \"0 < offs_num (length ns) (x # xs) index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma i", "using A"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma i", "by (simp add: offs_num_def)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma i\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "hence \"0 < offs_num (length ns) (x # xs) index key mi ma j \\<and> ?A \\<noteq> {} \\<and>\n    Min ?A = i\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n    offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n    Min (offs_set_next ns (x # xs) index key mi ma j) = i", "using B and C"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma i\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n    offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n    Min (offs_set_next ns (x # xs) index key mi ma j) = i", "by (subst offs_next_prev, simp)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n  offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n  Min (offs_set_next ns (x # xs) index key mi ma j) = i\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "ultimately"], ["proof (chain)\npicking this:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma j\n  0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n  offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n  Min (offs_set_next ns (x # xs) index key mi ma j) = i", "show \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    Suc (ns ! i)\""], ["proof (prove)\nusing this:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma j\n  0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n  offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n  Min (offs_set_next ns (x # xs) index key mi ma j) = i\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)", "using B"], ["proof (prove)\nusing this:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma j\n  0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n  offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n  Min (offs_set_next ns (x # xs) index key mi ma j) = i\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)", "by (simp only: offs_next_def, simp, subst nth_list_update_eq, blast,\n     simp)"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "let ?A = \"offs_set_prev ns (x # xs) index key mi ma i\""], ["proof (state)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "assume \"offs_num (length ns) xs index key mi ma i = 0\""], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "with A"], ["proof (chain)\npicking this:\n  index key x (length ns) mi ma = i\n  offs_num (length ns) xs index key mi ma i = 0", "have \"offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n    offs_set_next ns (x # xs) index key mi ma i\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  offs_num (length ns) xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n    offs_set_next ns (x # xs) index key mi ma i", "proof (rule_tac set_eqI, rule_tac iffI, simp_all add: offs_num_cons split:\n   if_split_asm, rule_tac conjI, rule_tac notI, simp, rule_tac impI,\n   (erule_tac [!] conjE)+, rule_tac ccontr, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "have \"i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ns", "using B"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. i < length ns", "by blast"], ["proof (state)\nthis:\n  i < length ns\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "moreover"], ["proof (state)\nthis:\n  i < length ns\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "assume \"i \\<noteq> k\" and \"\\<not> i < k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n  \\<not> i < k\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "hence \"k < i\""], ["proof (prove)\nusing this:\n  i \\<noteq> k\n  \\<not> i < k\n\ngoal (1 subgoal):\n 1. k < i", "by simp"], ["proof (state)\nthis:\n  k < i\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "moreover"], ["proof (state)\nthis:\n  k < i\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "assume \"0 < offs_num (length ns) xs index key mi ma k\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "ultimately"], ["proof (chain)\npicking this:\n  i < length ns\n  k < i\n  0 < offs_num (length ns) xs index key mi ma k", "have \"k \\<in> ?A\""], ["proof (prove)\nusing this:\n  i < length ns\n  k < i\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (1 subgoal):\n 1. k \\<in> offs_set_prev ns (x # xs) index key mi ma i", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  k \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "hence \"k \\<le> Max ?A\""], ["proof (prove)\nusing this:\n  k \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. k \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  k \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "moreover"], ["proof (state)\nthis:\n  k \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "assume \"j < k\""], ["proof (state)\nthis:\n  j < k\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>i \\<noteq> xa; xa < length ns; j < xa;\n        0 < offs_num (length ns) xs index key mi ma xa; \\<not> i < xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "ultimately"], ["proof (chain)\npicking this:\n  k \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n  j < k", "show False"], ["proof (prove)\nusing this:\n  k \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n  j < k\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  k \\<le> Max (offs_set_prev ns (x # xs) index key mi ma i)\n  j < k\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "have \"Max ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_prev ns (x # xs) index key mi ma i", "using B"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_prev ns (x # xs) index key mi ma i", "by (rule_tac Max_in, simp_all)"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "hence \"j < i\""], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. j < i", "using C"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j\n\ngoal (1 subgoal):\n 1. j < i", "by simp"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "moreover"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "assume \"i < k\""], ["proof (state)\nthis:\n  i < k\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa < length ns; i < xa;\n        0 < offs_num (length ns) xs index key mi ma xa;\n        index key x (length ns) mi ma = i;\n        offs_num (length ns) xs index key mi ma i = 0\\<rbrakk>\n       \\<Longrightarrow> j < xa", "ultimately"], ["proof (chain)\npicking this:\n  j < i\n  i < k", "show \"j < k\""], ["proof (prove)\nusing this:\n  j < i\n  i < k\n\ngoal (1 subgoal):\n 1. j < k", "by simp"], ["proof (state)\nthis:\n  j < k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "with B"], ["proof (chain)\npicking this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma i", "show \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i\""], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n  offs_set_next ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma i", "proof (simp only: offs_next_def split: if_split, (rule_tac conjI, rule_tac [!] impI,\n   simp)+, subst nth_list_update, blast, simp (no_asm_simp))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_next ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_next ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> i \\<noteq>\n                      Min (offs_set_next ns (x # xs) index key mi ma i)", "assume \"offs_set_next ns (x # xs) index key mi ma i \\<noteq> {}\""], ["proof (state)\nthis:\n  offs_set_next ns (x # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_next ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_next ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> i \\<noteq>\n                      Min (offs_set_next ns (x # xs) index key mi ma i)", "hence \"Min (offs_set_next ns (x # xs) index key mi ma i)\n      \\<in> offs_set_next ns (x # xs) index key mi ma i\""], ["proof (prove)\nusing this:\n  offs_set_next ns (x # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma i)\n    \\<in> offs_set_next ns (x # xs) index key mi ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_next ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_next ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i;\n     offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {};\n     offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma j =\n     offs_set_next ns (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> i \\<noteq>\n                      Min (offs_set_next ns (x # xs) index key mi ma i)", "thus \"i \\<noteq> Min (offs_set_next ns (x # xs) index key mi ma i)\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. i \\<noteq> Min (offs_set_next ns (x # xs) index key mi ma i)", "by simp"], ["proof (state)\nthis:\n  i \\<noteq> Min (offs_set_next ns (x # xs) index key mi ma i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_pred_ub_aux [rule_format]:\n  assumes A: \"offs_pred ns ub xs index key mi ma\"\n  shows \"i < length ns \\<Longrightarrow>\n    \\<forall>j < length ns. i \\<le> j \\<longrightarrow> 0 < offs_num (length ns) xs index key mi ma j \\<longrightarrow>\n      ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ns \\<Longrightarrow>\n    \\<forall>j<length ns.\n       i \\<le> j \\<longrightarrow>\n       0 < offs_num (length ns) xs index key mi ma j \\<longrightarrow>\n       ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ub", "proof (erule strict_inc_induct, rule_tac [!] allI, (rule_tac [!] impI)+,\n drule le_less_Suc_eq, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>length ns = Suc i; j = i;\n        0 < offs_num (Suc i) xs index key mi ma i\\<rbrakk>\n       \\<Longrightarrow> ns ! i + offs_num (Suc i) xs index key mi ma i\n                         \\<le> ub\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>length ns = Suc i; j = i;\n        0 < offs_num (Suc i) xs index key mi ma i\\<rbrakk>\n       \\<Longrightarrow> ns ! i + offs_num (Suc i) xs index key mi ma i\n                         \\<le> ub\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "assume B: \"length ns = Suc i\""], ["proof (state)\nthis:\n  length ns = Suc i\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>length ns = Suc i; j = i;\n        0 < offs_num (Suc i) xs index key mi ma i\\<rbrakk>\n       \\<Longrightarrow> ns ! i + offs_num (Suc i) xs index key mi ma i\n                         \\<le> ub\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "hence \"offs_num (Suc i) xs index key mi ma i \\<le>\n    offs_next ns ub xs index key mi ma i - ns ! i\""], ["proof (prove)\nusing this:\n  length ns = Suc i\n\ngoal (1 subgoal):\n 1. offs_num (Suc i) xs index key mi ma i\n    \\<le> offs_next ns ub xs index key mi ma i - ns ! i", "using A"], ["proof (prove)\nusing this:\n  length ns = Suc i\n  offs_pred ns ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. offs_num (Suc i) xs index key mi ma i\n    \\<le> offs_next ns ub xs index key mi ma i - ns ! i", "by (simp add: offs_pred_def)"], ["proof (state)\nthis:\n  offs_num (Suc i) xs index key mi ma i\n  \\<le> offs_next ns ub xs index key mi ma i - ns ! i\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>length ns = Suc i; j = i;\n        0 < offs_num (Suc i) xs index key mi ma i\\<rbrakk>\n       \\<Longrightarrow> ns ! i + offs_num (Suc i) xs index key mi ma i\n                         \\<le> ub\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "moreover"], ["proof (state)\nthis:\n  offs_num (Suc i) xs index key mi ma i\n  \\<le> offs_next ns ub xs index key mi ma i - ns ! i\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>length ns = Suc i; j = i;\n        0 < offs_num (Suc i) xs index key mi ma i\\<rbrakk>\n       \\<Longrightarrow> ns ! i + offs_num (Suc i) xs index key mi ma i\n                         \\<le> ub\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "have \"offs_next ns ub xs index key mi ma i = ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub xs index key mi ma i = ub", "using B"], ["proof (prove)\nusing this:\n  length ns = Suc i\n\ngoal (1 subgoal):\n 1. offs_next ns ub xs index key mi ma i = ub", "by (simp add: offs_next_def)"], ["proof (state)\nthis:\n  offs_next ns ub xs index key mi ma i = ub\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>length ns = Suc i; j = i;\n        0 < offs_num (Suc i) xs index key mi ma i\\<rbrakk>\n       \\<Longrightarrow> ns ! i + offs_num (Suc i) xs index key mi ma i\n                         \\<le> ub\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (Suc i) xs index key mi ma i\n  \\<le> offs_next ns ub xs index key mi ma i - ns ! i\n  offs_next ns ub xs index key mi ma i = ub", "have \"offs_num (Suc i) xs index key mi ma i \\<le> ub - ns ! i\""], ["proof (prove)\nusing this:\n  offs_num (Suc i) xs index key mi ma i\n  \\<le> offs_next ns ub xs index key mi ma i - ns ! i\n  offs_next ns ub xs index key mi ma i = ub\n\ngoal (1 subgoal):\n 1. offs_num (Suc i) xs index key mi ma i \\<le> ub - ns ! i", "by simp"], ["proof (state)\nthis:\n  offs_num (Suc i) xs index key mi ma i \\<le> ub - ns ! i\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>length ns = Suc i; j = i;\n        0 < offs_num (Suc i) xs index key mi ma i\\<rbrakk>\n       \\<Longrightarrow> ns ! i + offs_num (Suc i) xs index key mi ma i\n                         \\<le> ub\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "moreover"], ["proof (state)\nthis:\n  offs_num (Suc i) xs index key mi ma i \\<le> ub - ns ! i\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>length ns = Suc i; j = i;\n        0 < offs_num (Suc i) xs index key mi ma i\\<rbrakk>\n       \\<Longrightarrow> ns ! i + offs_num (Suc i) xs index key mi ma i\n                         \\<le> ub\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "assume \"0 < offs_num (Suc i) xs index key mi ma i\""], ["proof (state)\nthis:\n  0 < offs_num (Suc i) xs index key mi ma i\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>length ns = Suc i; j = i;\n        0 < offs_num (Suc i) xs index key mi ma i\\<rbrakk>\n       \\<Longrightarrow> ns ! i + offs_num (Suc i) xs index key mi ma i\n                         \\<le> ub\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (Suc i) xs index key mi ma i \\<le> ub - ns ! i\n  0 < offs_num (Suc i) xs index key mi ma i", "show \"ns ! i + offs_num (Suc i) xs index key mi ma i \\<le> ub\""], ["proof (prove)\nusing this:\n  offs_num (Suc i) xs index key mi ma i \\<le> ub - ns ! i\n  0 < offs_num (Suc i) xs index key mi ma i\n\ngoal (1 subgoal):\n 1. ns ! i + offs_num (Suc i) xs index key mi ma i \\<le> ub", "by simp"], ["proof (state)\nthis:\n  ns ! i + offs_num (Suc i) xs index key mi ma i \\<le> ub\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "assume \"j < length ns\""], ["proof (state)\nthis:\n  j < length ns\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "hence \"offs_num (length ns) xs index key mi ma j \\<le>\n    offs_next ns ub xs index key mi ma j - ns ! j\""], ["proof (prove)\nusing this:\n  j < length ns\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j\n    \\<le> offs_next ns ub xs index key mi ma j - ns ! j", "using A"], ["proof (prove)\nusing this:\n  j < length ns\n  offs_pred ns ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j\n    \\<le> offs_next ns ub xs index key mi ma j - ns ! j", "by (simp add: offs_pred_def)"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub xs index key mi ma j - ns ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub xs index key mi ma j - ns ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "assume\n    B: \"\\<forall>k < length ns. Suc i \\<le> k \\<longrightarrow>\n      0 < offs_num (length ns) xs index key mi ma k \\<longrightarrow>\n      ns ! k + offs_num (length ns) xs index key mi ma k \\<le> ub\" and\n    C: \"i \\<le> j\""], ["proof (state)\nthis:\n  \\<forall>k<length ns.\n     Suc i \\<le> k \\<longrightarrow>\n     0 < offs_num (length ns) xs index key mi ma k \\<longrightarrow>\n     ns ! k + offs_num (length ns) xs index key mi ma k \\<le> ub\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "have \"offs_next ns ub xs index key mi ma j \\<le> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub xs index key mi ma j \\<le> ub", "proof (simp only: offs_next_def split: if_split, rule conjI, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ub", "let ?A = \"offs_set_next ns xs index key mi ma j\""], ["proof (state)\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ub", "assume \"?A \\<noteq> {}\""], ["proof (state)\nthis:\n  offs_set_next ns xs index key mi ma j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ub", "hence \"Min ?A \\<in> ?A\""], ["proof (prove)\nusing this:\n  offs_set_next ns xs index key mi ma j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma j)\n    \\<in> offs_set_next ns xs index key mi ma j", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j)\n  \\<in> offs_set_next ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ub", "hence \"ns ! Min ?A + offs_num (length ns) xs index key mi ma (Min ?A) \\<le> ub\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma j)\n  \\<in> offs_set_next ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns xs index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Min (offs_set_next ns xs index key mi ma j))\n    \\<le> ub", "using B and C"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma j)\n  \\<in> offs_set_next ns xs index key mi ma j\n  \\<forall>k<length ns.\n     Suc i \\<le> k \\<longrightarrow>\n     0 < offs_num (length ns) xs index key mi ma k \\<longrightarrow>\n     ns ! k + offs_num (length ns) xs index key mi ma k \\<le> ub\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns xs index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Min (offs_set_next ns xs index key mi ma j))\n    \\<le> ub", "by simp"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns xs index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Min (offs_set_next ns xs index key mi ma j))\n  \\<le> ub\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ub", "thus \"ns ! Min ?A \\<le> ub\""], ["proof (prove)\nusing this:\n  ns ! Min (offs_set_next ns xs index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Min (offs_set_next ns xs index key mi ma j))\n  \\<le> ub\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ub", "by simp"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ub\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_next ns ub xs index key mi ma j \\<le> ub\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub xs index key mi ma j - ns ! j\n  offs_next ns ub xs index key mi ma j \\<le> ub", "have \"offs_num (length ns) xs index key mi ma j \\<le> ub - ns ! j\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub xs index key mi ma j - ns ! j\n  offs_next ns ub xs index key mi ma j \\<le> ub\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j \\<le> ub - ns ! j", "by simp"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j \\<le> ub - ns ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j \\<le> ub - ns ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "assume \"0 < offs_num (length ns) xs index key mi ma j\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>j<length ns.\n                   Suc i \\<le> j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ub;\n        j < length ns; i \\<le> j;\n        0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ub", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma j \\<le> ub - ns ! j\n  0 < offs_num (length ns) xs index key mi ma j", "show \"ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ub\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma j \\<le> ub - ns ! j\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ub", "by simp"], ["proof (state)\nthis:\n  ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ub\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_pred_ub:\n \"\\<lbrakk>offs_pred ns ub xs index key mi ma; i < length ns;\n   0 < offs_num (length ns) xs index key mi ma i\\<rbrakk> \\<Longrightarrow>\n     ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_pred ns ub xs index key mi ma; i < length ns;\n     0 < offs_num (length ns) xs index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> ns ! i + offs_num (length ns) xs index key mi ma i\n                      \\<le> ub", "by (drule offs_pred_ub_aux, assumption+, simp)"], ["", "lemma offs_pred_asc_aux [rule_format]:\n  assumes A: \"offs_pred ns ub xs index key mi ma\"\n  shows \"i < length ns \\<Longrightarrow>\n    \\<forall>j k. k < length ns \\<longrightarrow> i \\<le> j \\<longrightarrow> j < k \\<longrightarrow>\n      0 < offs_num (length ns) xs index key mi ma j \\<longrightarrow>\n      0 < offs_num (length ns) xs index key mi ma k \\<longrightarrow>\n      ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ns ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ns \\<Longrightarrow>\n    \\<forall>j k.\n       k < length ns \\<longrightarrow>\n       i \\<le> j \\<longrightarrow>\n       j < k \\<longrightarrow>\n       0 < offs_num (length ns) xs index key mi ma j \\<longrightarrow>\n       0 < offs_num (length ns) xs index key mi ma k \\<longrightarrow>\n       ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ns ! k", "proof (erule strict_inc_induct, simp, (rule allI)+, (rule impI)+, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "assume\n    B: \"k < length ns\" and\n    C: \"j < k\""], ["proof (state)\nthis:\n  k < length ns\n  j < k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "hence \"j < length ns\""], ["proof (prove)\nusing this:\n  k < length ns\n  j < k\n\ngoal (1 subgoal):\n 1. j < length ns", "by simp"], ["proof (state)\nthis:\n  j < length ns\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "hence \"offs_num (length ns) xs index key mi ma j \\<le>\n    offs_next ns ub xs index key mi ma j - ns ! j\""], ["proof (prove)\nusing this:\n  j < length ns\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j\n    \\<le> offs_next ns ub xs index key mi ma j - ns ! j", "using A"], ["proof (prove)\nusing this:\n  j < length ns\n  offs_pred ns ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j\n    \\<le> offs_next ns ub xs index key mi ma j - ns ! j", "by (simp add: offs_pred_def)"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub xs index key mi ma j - ns ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub xs index key mi ma j - ns ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "assume\n    D: \"\\<forall>j k. k < length ns \\<longrightarrow> Suc i \\<le> j \\<longrightarrow> j < k \\<longrightarrow>\n      0 < offs_num (length ns) xs index key mi ma j \\<longrightarrow>\n      0 < offs_num (length ns) xs index key mi ma k \\<longrightarrow>\n      ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ns ! k\" and\n    E: \"i \\<le> j\" and\n    F: \"0 < offs_num (length ns) xs index key mi ma k\""], ["proof (state)\nthis:\n  \\<forall>j k.\n     k < length ns \\<longrightarrow>\n     Suc i \\<le> j \\<longrightarrow>\n     j < k \\<longrightarrow>\n     0 < offs_num (length ns) xs index key mi ma j \\<longrightarrow>\n     0 < offs_num (length ns) xs index key mi ma k \\<longrightarrow>\n     ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ns ! k\n  i \\<le> j\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "have \"offs_next ns ub xs index key mi ma j \\<le> ns ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub xs index key mi ma j \\<le> ns ! k", "proof (simp only: offs_next_def split: if_split, rule conjI, rule_tac [!] impI,\n   rule ccontr, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x>j.\n                x < length ns \\<longrightarrow>\n                offs_num (length ns) xs index key mi ma x = 0;\n     \\<not> ub \\<le> ns ! k\\<rbrakk>\n    \\<Longrightarrow> False\n 2. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "assume \"\\<forall>n > j. n < length ns \\<longrightarrow>\n      offs_num (length ns) xs index key mi ma n = 0\""], ["proof (state)\nthis:\n  \\<forall>n>j.\n     n < length ns \\<longrightarrow>\n     offs_num (length ns) xs index key mi ma n = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x>j.\n                x < length ns \\<longrightarrow>\n                offs_num (length ns) xs index key mi ma x = 0;\n     \\<not> ub \\<le> ns ! k\\<rbrakk>\n    \\<Longrightarrow> False\n 2. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "hence \"offs_num (length ns) xs index key mi ma k = 0\""], ["proof (prove)\nusing this:\n  \\<forall>n>j.\n     n < length ns \\<longrightarrow>\n     offs_num (length ns) xs index key mi ma n = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma k = 0", "using B and C"], ["proof (prove)\nusing this:\n  \\<forall>n>j.\n     n < length ns \\<longrightarrow>\n     offs_num (length ns) xs index key mi ma n = 0\n  k < length ns\n  j < k\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma k = 0", "by simp"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma k = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x>j.\n                x < length ns \\<longrightarrow>\n                offs_num (length ns) xs index key mi ma x = 0;\n     \\<not> ub \\<le> ns ! k\\<rbrakk>\n    \\<Longrightarrow> False\n 2. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "thus False"], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma k = 0\n\ngoal (1 subgoal):\n 1. False", "using F"], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma k = 0\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "let ?A = \"offs_set_next ns xs index key mi ma j\""], ["proof (state)\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "have G: \"k \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> offs_set_next ns xs index key mi ma j", "using B and C and F"], ["proof (prove)\nusing this:\n  k < length ns\n  j < k\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (1 subgoal):\n 1. k \\<in> offs_set_next ns xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  k \\<in> offs_set_next ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "hence \"Min ?A \\<le> k\""], ["proof (prove)\nusing this:\n  k \\<in> offs_set_next ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma j) \\<le> k", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) \\<le> k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "hence \"Min ?A < k \\<or> Min ?A = k\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma j) \\<le> k\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma j) < k \\<or>\n    Min (offs_set_next ns xs index key mi ma j) = k", "by (simp add: le_less)"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) < k \\<or>\n  Min (offs_set_next ns xs index key mi ma j) = k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) < k \\<or>\n  Min (offs_set_next ns xs index key mi ma j) = k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "{"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) < k \\<or>\n  Min (offs_set_next ns xs index key mi ma j) = k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "have \"Suc i \\<le> Min ?A \\<longrightarrow> Min ?A < k \\<longrightarrow>\n        0 < offs_num (length ns) xs index key mi ma (Min ?A) \\<longrightarrow>\n        ns ! Min ?A + offs_num (length ns) xs index key mi ma (Min ?A) \\<le> ns ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Min (offs_set_next ns xs index key mi ma j) \\<longrightarrow>\n    Min (offs_set_next ns xs index key mi ma j) < k \\<longrightarrow>\n    0 < offs_num (length ns) xs index key mi ma\n         (Min (offs_set_next ns xs index key mi ma j)) \\<longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Min (offs_set_next ns xs index key mi ma j))\n    \\<le> ns ! k", "using B and D and F"], ["proof (prove)\nusing this:\n  k < length ns\n  \\<forall>j k.\n     k < length ns \\<longrightarrow>\n     Suc i \\<le> j \\<longrightarrow>\n     j < k \\<longrightarrow>\n     0 < offs_num (length ns) xs index key mi ma j \\<longrightarrow>\n     0 < offs_num (length ns) xs index key mi ma k \\<longrightarrow>\n     ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ns ! k\n  0 < offs_num (length ns) xs index key mi ma k\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Min (offs_set_next ns xs index key mi ma j) \\<longrightarrow>\n    Min (offs_set_next ns xs index key mi ma j) < k \\<longrightarrow>\n    0 < offs_num (length ns) xs index key mi ma\n         (Min (offs_set_next ns xs index key mi ma j)) \\<longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Min (offs_set_next ns xs index key mi ma j))\n    \\<le> ns ! k", "by simp"], ["proof (state)\nthis:\n  Suc i \\<le> Min (offs_set_next ns xs index key mi ma j) \\<longrightarrow>\n  Min (offs_set_next ns xs index key mi ma j) < k \\<longrightarrow>\n  0 < offs_num (length ns) xs index key mi ma\n       (Min (offs_set_next ns xs index key mi ma j)) \\<longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Min (offs_set_next ns xs index key mi ma j))\n  \\<le> ns ! k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "moreover"], ["proof (state)\nthis:\n  Suc i \\<le> Min (offs_set_next ns xs index key mi ma j) \\<longrightarrow>\n  Min (offs_set_next ns xs index key mi ma j) < k \\<longrightarrow>\n  0 < offs_num (length ns) xs index key mi ma\n       (Min (offs_set_next ns xs index key mi ma j)) \\<longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Min (offs_set_next ns xs index key mi ma j))\n  \\<le> ns ! k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "assume \"Min ?A < k\""], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) < k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) < k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "have \"Min ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma j)\n    \\<in> offs_set_next ns xs index key mi ma j", "using G"], ["proof (prove)\nusing this:\n  k \\<in> offs_set_next ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma j)\n    \\<in> offs_set_next ns xs index key mi ma j", "by (rule_tac Min_in, simp, blast)"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j)\n  \\<in> offs_set_next ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "ultimately"], ["proof (chain)\npicking this:\n  Suc i \\<le> Min (offs_set_next ns xs index key mi ma j) \\<longrightarrow>\n  Min (offs_set_next ns xs index key mi ma j) < k \\<longrightarrow>\n  0 < offs_num (length ns) xs index key mi ma\n       (Min (offs_set_next ns xs index key mi ma j)) \\<longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Min (offs_set_next ns xs index key mi ma j))\n  \\<le> ns ! k\n  Min (offs_set_next ns xs index key mi ma j) < k\n  Min (offs_set_next ns xs index key mi ma j)\n  \\<in> offs_set_next ns xs index key mi ma j", "have \"ns ! Min ?A < ns ! k\""], ["proof (prove)\nusing this:\n  Suc i \\<le> Min (offs_set_next ns xs index key mi ma j) \\<longrightarrow>\n  Min (offs_set_next ns xs index key mi ma j) < k \\<longrightarrow>\n  0 < offs_num (length ns) xs index key mi ma\n       (Min (offs_set_next ns xs index key mi ma j)) \\<longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Min (offs_set_next ns xs index key mi ma j))\n  \\<le> ns ! k\n  Min (offs_set_next ns xs index key mi ma j) < k\n  Min (offs_set_next ns xs index key mi ma j)\n  \\<in> offs_set_next ns xs index key mi ma j\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns xs index key mi ma j) < ns ! k", "using E"], ["proof (prove)\nusing this:\n  Suc i \\<le> Min (offs_set_next ns xs index key mi ma j) \\<longrightarrow>\n  Min (offs_set_next ns xs index key mi ma j) < k \\<longrightarrow>\n  0 < offs_num (length ns) xs index key mi ma\n       (Min (offs_set_next ns xs index key mi ma j)) \\<longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Min (offs_set_next ns xs index key mi ma j))\n  \\<le> ns ! k\n  Min (offs_set_next ns xs index key mi ma j) < k\n  Min (offs_set_next ns xs index key mi ma j)\n  \\<in> offs_set_next ns xs index key mi ma j\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns xs index key mi ma j) < ns ! k", "by simp"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns xs index key mi ma j) < ns ! k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "}"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) < k \\<Longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) < ns ! k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) < k \\<Longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) < ns ! k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "{"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) < k \\<Longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) < ns ! k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "assume \"Min ?A = k\""], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) = k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "hence \"ns ! Min ?A = ns ! k\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma j) = k\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns xs index key mi ma j) = ns ! k", "by simp"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns xs index key mi ma j) = ns ! k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "}"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma j) = k \\<Longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) = ns ! k\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma j \\<noteq> {} \\<Longrightarrow>\n    ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next ns xs index key mi ma j) < k \\<or>\n  Min (offs_set_next ns xs index key mi ma j) = k\n  Min (offs_set_next ns xs index key mi ma j) < k \\<Longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) < ns ! k\n  Min (offs_set_next ns xs index key mi ma j) = k \\<Longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) = ns ! k", "show \"ns ! Min ?A \\<le> ns ! k\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma j) < k \\<or>\n  Min (offs_set_next ns xs index key mi ma j) = k\n  Min (offs_set_next ns xs index key mi ma j) < k \\<Longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) < ns ! k\n  Min (offs_set_next ns xs index key mi ma j) = k \\<Longrightarrow>\n  ns ! Min (offs_set_next ns xs index key mi ma j) = ns ! k\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k", "by (simp add: le_less, blast)"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns xs index key mi ma j) \\<le> ns ! k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_next ns ub xs index key mi ma j \\<le> ns ! k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub xs index key mi ma j - ns ! j\n  offs_next ns ub xs index key mi ma j \\<le> ns ! k", "have \"offs_num (length ns) xs index key mi ma j \\<le> ns ! k - ns ! j\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub xs index key mi ma j - ns ! j\n  offs_next ns ub xs index key mi ma j \\<le> ns ! k\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j \\<le> ns ! k - ns ! j", "by simp"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j \\<le> ns ! k - ns ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j \\<le> ns ! k - ns ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "assume \"0 < offs_num (length ns) xs index key mi ma j\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<forall>j k.\n                   k < length ns \\<longrightarrow>\n                   Suc i \\<le> j \\<longrightarrow>\n                   j < k \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        j \\<longrightarrow>\n                   0 < offs_num (length ns) xs index key mi ma\n                        k \\<longrightarrow>\n                   ns ! j + offs_num (length ns) xs index key mi ma j\n                   \\<le> ns ! k;\n        k < length ns; i \\<le> j; j < k;\n        0 < offs_num (length ns) xs index key mi ma j;\n        0 < offs_num (length ns) xs index key mi ma k\\<rbrakk>\n       \\<Longrightarrow> ns ! j + offs_num (length ns) xs index key mi ma j\n                         \\<le> ns ! k", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma j \\<le> ns ! k - ns ! j\n  0 < offs_num (length ns) xs index key mi ma j", "show \"ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ns ! k\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma j \\<le> ns ! k - ns ! j\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ns ! k", "by simp"], ["proof (state)\nthis:\n  ns ! j + offs_num (length ns) xs index key mi ma j \\<le> ns ! k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_pred_asc:\n \"\\<lbrakk>offs_pred ns ub xs index key mi ma; i < j; j < length ns;\n   0 < offs_num (length ns) xs index key mi ma i;\n   0 < offs_num (length ns) xs index key mi ma j\\<rbrakk> \\<Longrightarrow>\n     ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ns ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_pred ns ub xs index key mi ma; i < j; j < length ns;\n     0 < offs_num (length ns) xs index key mi ma i;\n     0 < offs_num (length ns) xs index key mi ma j\\<rbrakk>\n    \\<Longrightarrow> ns ! i + offs_num (length ns) xs index key mi ma i\n                      \\<le> ns ! j", "by (drule offs_pred_asc_aux, erule less_trans, assumption+, rule order_refl)"], ["", "lemma offs_pred_next:\n  assumes\n    A: \"offs_pred ns ub xs index key mi ma\" and\n    B: \"i < length ns\" and\n    C: \"0 < offs_num (length ns) xs index key mi ma i\"\n  shows \"ns ! i < offs_next ns ub xs index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! i < offs_next ns ub xs index key mi ma i", "proof (simp only: offs_next_def split: if_split, rule conjI, rule_tac [!] impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. offs_set_next ns xs index key mi ma i = {} \\<Longrightarrow> ns ! i < ub\n 2. offs_set_next ns xs index key mi ma i \\<noteq> {} \\<Longrightarrow>\n    ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)", "have \"ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ub", "using A and B and C"], ["proof (prove)\nusing this:\n  offs_pred ns ub xs index key mi ma\n  i < length ns\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (1 subgoal):\n 1. ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ub", "by (rule offs_pred_ub)"], ["proof (state)\nthis:\n  ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ub\n\ngoal (2 subgoals):\n 1. offs_set_next ns xs index key mi ma i = {} \\<Longrightarrow> ns ! i < ub\n 2. offs_set_next ns xs index key mi ma i \\<noteq> {} \\<Longrightarrow>\n    ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)", "thus \"ns ! i < ub\""], ["proof (prove)\nusing this:\n  ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ub\n\ngoal (1 subgoal):\n 1. ns ! i < ub", "using C"], ["proof (prove)\nusing this:\n  ns ! i + offs_num (length ns) xs index key mi ma i \\<le> ub\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (1 subgoal):\n 1. ns ! i < ub", "by simp"], ["proof (state)\nthis:\n  ns ! i < ub\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma i \\<noteq> {} \\<Longrightarrow>\n    ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma i \\<noteq> {} \\<Longrightarrow>\n    ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)", "assume \"offs_set_next ns xs index key mi ma i \\<noteq> {}\""], ["proof (state)\nthis:\n  offs_set_next ns xs index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma i \\<noteq> {} \\<Longrightarrow>\n    ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)", "hence \"Min (offs_set_next ns xs index key mi ma i)\n    \\<in> offs_set_next ns xs index key mi ma i\""], ["proof (prove)\nusing this:\n  offs_set_next ns xs index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns xs index key mi ma i)\n    \\<in> offs_set_next ns xs index key mi ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns xs index key mi ma i)\n  \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma i \\<noteq> {} \\<Longrightarrow>\n    ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)", "hence \"ns ! i + offs_num (length ns) xs index key mi ma i \\<le>\n    ns ! Min (offs_set_next ns xs index key mi ma i)\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma i)\n  \\<in> offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. ns ! i + offs_num (length ns) xs index key mi ma i\n    \\<le> ns ! Min (offs_set_next ns xs index key mi ma i)", "using C"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns xs index key mi ma i)\n  \\<in> offs_set_next ns xs index key mi ma i\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (1 subgoal):\n 1. ns ! i + offs_num (length ns) xs index key mi ma i\n    \\<le> ns ! Min (offs_set_next ns xs index key mi ma i)", "by (rule_tac offs_pred_asc [OF A], simp_all)"], ["proof (state)\nthis:\n  ns ! i + offs_num (length ns) xs index key mi ma i\n  \\<le> ns ! Min (offs_set_next ns xs index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma i \\<noteq> {} \\<Longrightarrow>\n    ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)", "thus \"ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)\""], ["proof (prove)\nusing this:\n  ns ! i + offs_num (length ns) xs index key mi ma i\n  \\<le> ns ! Min (offs_set_next ns xs index key mi ma i)\n\ngoal (1 subgoal):\n 1. ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)", "using C"], ["proof (prove)\nusing this:\n  ns ! i + offs_num (length ns) xs index key mi ma i\n  \\<le> ns ! Min (offs_set_next ns xs index key mi ma i)\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (1 subgoal):\n 1. ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)", "by simp"], ["proof (state)\nthis:\n  ns ! i < ns ! Min (offs_set_next ns xs index key mi ma i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_pred_next_cons_less:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\" and\n    D: \"Max (offs_set_prev ns (x # xs) index key mi ma i) = j\"\n  shows \"offs_next ns ub (x # xs) index key mi ma j <\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\"\n  (is \"?M < ?N\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "have E: \"0 < offs_num (length ns) (x # xs) index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma i", "using B"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma i", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "hence \"0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n    offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n    Min (offs_set_next ns (x # xs) index key mi ma j) = i\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n    offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n    Min (offs_set_next ns (x # xs) index key mi ma j) = i", "using C and D"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma i\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n    offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n    Min (offs_set_next ns (x # xs) index key mi ma j) = i", "by (subst offs_next_prev, simp)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n  offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n  Min (offs_set_next ns (x # xs) index key mi ma j) = i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "hence F: \"?M = ns ! i\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma j \\<and>\n  offs_set_next ns (x # xs) index key mi ma j \\<noteq> {} \\<and>\n  Min (offs_set_next ns (x # xs) index key mi ma j) = i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j = ns ! i", "by (simp only: offs_next_def, simp)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j = ns ! i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "have \"?N = (if 0 < offs_num (length ns) xs index key mi ma i\n    then Suc (ns ! i)\n    else offs_next ns ub (x # xs) index key mi ma i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)", "using B and C and D"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)", "by (rule offs_next_cons_neq)"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n   else offs_next ns ub (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "thus ?thesis"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n   else offs_next ns ub (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "proof (split if_split_asm)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n     Suc (ns ! i)\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma j\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma j\n 2. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma j\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma j", "assume \"?N = Suc (ns ! i)\""], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n     Suc (ns ! i)\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma j\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma j\n 2. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma j\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma j", "thus ?thesis"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "using F"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j = Suc (ns ! i)\n  offs_next ns ub (x # xs) index key mi ma j = ns ! i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma j\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma j\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma j", "assume \"?N = offs_next ns ub (x # xs) index key mi ma i\""], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma j\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma j", "moreover"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma j\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma j", "have \"ns ! i < offs_next ns ub (x # xs) index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! i < offs_next ns ub (x # xs) index key mi ma i", "using C"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ns ! i < offs_next ns ub (x # xs) index key mi ma i", "by (rule_tac offs_pred_next [OF A _ E], blast)"], ["proof (state)\nthis:\n  ns ! i < offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma j\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma j", "ultimately"], ["proof (chain)\npicking this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma i\n  ns ! i < offs_next ns ub (x # xs) index key mi ma i", "show ?thesis"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma i\n  ns ! i < offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "using F"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma i\n  ns ! i < offs_next ns ub (x # xs) index key mi ma i\n  offs_next ns ub (x # xs) index key mi ma j = ns ! i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_pred_next_cons:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"i < length ns\" and\n    D: \"0 < offs_num (length ns) (x # xs) index key mi ma j\"\n  shows \"offs_next ns ub (x # xs) index key mi ma j \\<le>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\"\n  (is \"?M \\<le> ?N\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "let ?P = \"offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n    Max (offs_set_prev ns (x # xs) index key mi ma i) = j\""], ["proof (state)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "have \"?P \\<or> \\<not> ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n    Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<or>\n    \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n            Max (offs_set_prev ns (x # xs) index key mi ma i) = j)", "by blast"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<or>\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) = j)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "moreover"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<or>\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) = j)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "{"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<or>\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) = j)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "assume ?P"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "hence \"?M < ?N\""], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "using B"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "by (rule_tac offs_pred_next_cons_less [OF A], simp_all)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "hence ?thesis"], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma j\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "}"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<Longrightarrow>\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "moreover"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<Longrightarrow>\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "{"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<Longrightarrow>\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "assume \"\\<not> ?P\""], ["proof (state)\nthis:\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) = j)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "hence \"?N = ?M\""], ["proof (prove)\nusing this:\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) = j)\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma j", "by (rule_tac offs_next_cons_eq [OF B C D], blast)"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "hence ?thesis"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "}"], ["proof (state)\nthis:\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) =\n          j) \\<Longrightarrow>\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "ultimately"], ["proof (chain)\npicking this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<or>\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) = j)\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<Longrightarrow>\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) =\n          j) \\<Longrightarrow>\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "show ?thesis"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<or>\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) = j)\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma i) = j \\<Longrightarrow>\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n  \\<not> (offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {} \\<and>\n          Max (offs_set_prev ns (x # xs) index key mi ma i) =\n          j) \\<Longrightarrow>\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", ".."], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_pred_cons:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"i < length ns\"\n  shows \"offs_pred (ns[i := Suc (ns ! i)]) ub xs index key mi ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_pred (ns[i := Suc (ns ! i)]) ub xs index key mi ma", "using A"], ["proof (prove)\nusing this:\n  offs_pred ns ub (x # xs) index key mi ma\n\ngoal (1 subgoal):\n 1. offs_pred (ns[i := Suc (ns ! i)]) ub xs index key mi ma", "proof (simp add: offs_pred_def, rule_tac allI, rule_tac impI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>\\<forall>i<length ns.\n                   offs_num (length ns) (x # xs) index key mi ma i\n                   \\<le> offs_next ns ub (x # xs) index key mi ma i -\n                         ns ! i;\n        ia < length ns; offs_pred ns ub (x # xs) index key mi ma\\<rbrakk>\n       \\<Longrightarrow> offs_num (length ns) xs index key mi ma ia\n                         \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                                key mi ma ia -\n                               ns[i := Suc (ns ! i)] ! ia", "let ?ns' = \"ns[i := Suc (ns ! i)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>\\<forall>i<length ns.\n                   offs_num (length ns) (x # xs) index key mi ma i\n                   \\<le> offs_next ns ub (x # xs) index key mi ma i -\n                         ns ! i;\n        ia < length ns; offs_pred ns ub (x # xs) index key mi ma\\<rbrakk>\n       \\<Longrightarrow> offs_num (length ns) xs index key mi ma ia\n                         \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                                key mi ma ia -\n                               ns[i := Suc (ns ! i)] ! ia", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>\\<forall>i<length ns.\n                   offs_num (length ns) (x # xs) index key mi ma i\n                   \\<le> offs_next ns ub (x # xs) index key mi ma i -\n                         ns ! i;\n        ia < length ns; offs_pred ns ub (x # xs) index key mi ma\\<rbrakk>\n       \\<Longrightarrow> offs_num (length ns) xs index key mi ma ia\n                         \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                                key mi ma ia -\n                               ns[i := Suc (ns ! i)] ! ia", "assume\n   \"\\<forall>j < length ns. offs_num (length ns) (x # xs) index key mi ma j \\<le>\n      offs_next ns ub (x # xs) index key mi ma j - ns ! j\" and\n   \"j < length ns\""], ["proof (state)\nthis:\n  \\<forall>j<length ns.\n     offs_num (length ns) (x # xs) index key mi ma j\n     \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j\n  j < length ns\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>\\<forall>i<length ns.\n                   offs_num (length ns) (x # xs) index key mi ma i\n                   \\<le> offs_next ns ub (x # xs) index key mi ma i -\n                         ns ! i;\n        ia < length ns; offs_pred ns ub (x # xs) index key mi ma\\<rbrakk>\n       \\<Longrightarrow> offs_num (length ns) xs index key mi ma ia\n                         \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                                key mi ma ia -\n                               ns[i := Suc (ns ! i)] ! ia", "hence D: \"offs_num (length ns) (x # xs) index key mi ma j \\<le>\n    offs_next ns ub (x # xs) index key mi ma j - ns ! j\""], ["proof (prove)\nusing this:\n  \\<forall>j<length ns.\n     offs_num (length ns) (x # xs) index key mi ma j\n     \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j\n  j < length ns\n\ngoal (1 subgoal):\n 1. offs_num (length ns) (x # xs) index key mi ma j\n    \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j", "by simp"], ["proof (state)\nthis:\n  offs_num (length ns) (x # xs) index key mi ma j\n  \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>\\<forall>i<length ns.\n                   offs_num (length ns) (x # xs) index key mi ma i\n                   \\<le> offs_next ns ub (x # xs) index key mi ma i -\n                         ns ! i;\n        ia < length ns; offs_pred ns ub (x # xs) index key mi ma\\<rbrakk>\n       \\<Longrightarrow> offs_num (length ns) xs index key mi ma ia\n                         \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                                key mi ma ia -\n                               ns[i := Suc (ns ! i)] ! ia", "from B and C"], ["proof (chain)\npicking this:\n  index key x (length ns) mi ma = i\n  i < length ns", "show \"offs_num (length ns) xs index key mi ma j \\<le>\n    offs_next ?ns' ub xs index key mi ma j - ?ns' ! j\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  i < length ns\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j -\n          ns[i := Suc (ns ! i)] ! j", "proof (cases \"j = i\", case_tac [2] \"0 < offs_num (length ns) xs index key mi ma j\",\n   simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j = i; index key x (length ns) mi ma = i;\n     i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma i\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma i -\n                            Suc (ns ! i)\n 2. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "assume \"j = i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = i; index key x (length ns) mi ma = i;\n     i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma i\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma i -\n                            Suc (ns ! i)\n 2. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "hence \"offs_num (length ns) xs index key mi ma i \\<le>\n      offs_next ns ub (x # xs) index key mi ma i - Suc (ns ! i)\""], ["proof (prove)\nusing this:\n  j = i\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i\n    \\<le> offs_next ns ub (x # xs) index key mi ma i - Suc (ns ! i)", "using B and D"], ["proof (prove)\nusing this:\n  j = i\n  index key x (length ns) mi ma = i\n  offs_num (length ns) (x # xs) index key mi ma j\n  \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i\n    \\<le> offs_next ns ub (x # xs) index key mi ma i - Suc (ns ! i)", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma i\n  \\<le> offs_next ns ub (x # xs) index key mi ma i - Suc (ns ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = i; index key x (length ns) mi ma = i;\n     i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma i\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma i -\n                            Suc (ns ! i)\n 2. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma i\n  \\<le> offs_next ns ub (x # xs) index key mi ma i - Suc (ns ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = i; index key x (length ns) mi ma = i;\n     i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma i\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma i -\n                            Suc (ns ! i)\n 2. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "have \"offs_next ns ub (x # xs) index key mi ma i \\<le>\n      offs_next ?ns' ub xs index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma i\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i", "using B"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma i\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i", "by (rule_tac offs_pred_next_cons [OF A _ C], simp_all add:\n       offs_num_cons)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma i\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = i; index key x (length ns) mi ma = i;\n     i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma i\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma i -\n                            Suc (ns ! i)\n 2. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma i\n  \\<le> offs_next ns ub (x # xs) index key mi ma i - Suc (ns ! i)\n  offs_next ns ub (x # xs) index key mi ma i\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i", "show \"offs_num (length ns) xs index key mi ma i \\<le>\n      offs_next ?ns' ub xs index key mi ma i - Suc (ns ! i)\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma i\n  \\<le> offs_next ns ub (x # xs) index key mi ma i - Suc (ns ! i)\n  offs_next ns ub (x # xs) index key mi ma i\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i -\n          Suc (ns ! i)", "by simp"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma i\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i -\n        Suc (ns ! i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "assume \"j \\<noteq> i\""], ["proof (state)\nthis:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "hence \"offs_num (length ns) xs index key mi ma j \\<le>\n      offs_next ns ub (x # xs) index key mi ma j - ns ! j\""], ["proof (prove)\nusing this:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j\n    \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j", "using B and D"], ["proof (prove)\nusing this:\n  j \\<noteq> i\n  index key x (length ns) mi ma = i\n  offs_num (length ns) (x # xs) index key mi ma j\n  \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j\n    \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "assume \"0 < offs_num (length ns) xs index key mi ma j\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "hence \"offs_next ns ub (x # xs) index key mi ma j \\<le>\n      offs_next ?ns' ub xs index key mi ma j\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "using B"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma j\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "by (rule_tac offs_pred_next_cons [OF A _ C], simp_all add:\n       offs_num_cons)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> i; 0 < offs_num (length ns) xs index key mi ma j;\n     index key x (length ns) mi ma = i; i < length ns\\<rbrakk>\n    \\<Longrightarrow> offs_num (length ns) xs index key mi ma j\n                      \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index\n                             key mi ma j -\n                            ns ! j", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j", "show \"offs_num (length ns) xs index key mi ma j \\<le>\n      offs_next ?ns' ub xs index key mi ma j - ns ! j\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next ns ub (x # xs) index key mi ma j - ns ! j\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma j\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j - ns ! j", "by simp"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j - ns ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma j -\n        ns[i := Suc (ns ! i)] ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nThe next step consists of proving, as done in lemma @{text fill_count_item} in what follows, that if\ncertain conditions hold, particularly if offsets' list $ns$ and objects' list $xs$ satisfy predicate\n@{const offs_pred}, then function @{const fill} conserves objects if called using $xs$ and $ns$ as\nits input arguments.\n\nThis lemma is proven by induction on $xs$. Hence, lemma @{thm [source] offs_pred_cons}, proven in\nthe previous step, is used to remove the antecedent containing predicate @{const offs_pred} from the\ninduction hypothesis, which has the form of an implication.\n\n\\null\n\\<close>"], ["", "lemma offs_next_zero:\n  assumes\n    A: \"i < length ns\" and\n    B: \"offs_num (length ns) xs index key mi ma i = 0\" and\n    C: \"offs_set_prev ns xs index key mi ma i = {}\"\n  shows \"offs_next ns ub xs index key mi ma 0 =\n    offs_next ns ub xs index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub xs index key mi ma 0 =\n    offs_next ns ub xs index key mi ma i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_next ns ub xs index key mi ma 0 =\n    offs_next ns ub xs index key mi ma i", "have \"offs_set_next ns xs index key mi ma 0 =\n    offs_set_next ns xs index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_set_next ns xs index key mi ma 0 =\n    offs_set_next ns xs index key mi ma i", "proof (rule set_eqI, rule iffI, simp_all, (erule conjE)+, rule ccontr, simp add:\n   not_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "assume D: \"0 < offs_num (length ns) xs index key mi ma j\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j \\<le> i\""], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"j < i \\<or> j = i\""], ["proof (prove)\nusing this:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. j < i \\<or> j = i", "by (simp add: le_less)"], ["proof (state)\nthis:\n  j < i \\<or> j = i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j < i \\<or> j = i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  j < i \\<or> j = i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"j \\<in> offs_set_prev ns xs index key mi ma i\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns xs index key mi ma i", "using A and D"], ["proof (prove)\nusing this:\n  j < i\n  i < length ns\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns xs index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_prev ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "hence False"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns xs index key mi ma i\n  offs_set_prev ns xs index key mi ma i = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j = i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "hence False"], ["proof (prove)\nusing this:\n  j = i\n\ngoal (1 subgoal):\n 1. False", "using B and D"], ["proof (prove)\nusing this:\n  j = i\n  offs_num (length ns) xs index key mi ma i = 0\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  j = i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length ns; 0 < x;\n        0 < offs_num (length ns) xs index key mi ma x; x \\<le> i\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  j < i \\<or> j = i\n  j < i \\<Longrightarrow> False\n  j = i \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  j < i \\<or> j = i\n  j < i \\<Longrightarrow> False\n  j = i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_set_next ns xs index key mi ma 0 =\n  offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_next ns ub xs index key mi ma 0 =\n    offs_next ns ub xs index key mi ma i", "thus ?thesis"], ["proof (prove)\nusing this:\n  offs_set_next ns xs index key mi ma 0 =\n  offs_set_next ns xs index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_next ns ub xs index key mi ma 0 =\n    offs_next ns ub xs index key mi ma i", "by (simp only: offs_next_def)"], ["proof (state)\nthis:\n  offs_next ns ub xs index key mi ma 0 =\n  offs_next ns ub xs index key mi ma i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_next_zero_cons_eq:\n  assumes\n    A: \"index key x (length ns) mi ma = i\" and\n    B: \"offs_num (length ns) (x # xs) index key mi ma 0 = 0\" and\n    C: \"offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\"\n      (is \"?A \\<noteq> _\")\n  shows \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "have D: \"Min ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_prev ns (x # xs) index key mi ma i", "using C"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_prev ns (x # xs) index key mi ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "have E: \"0 < Min ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Min (offs_set_prev ns (x # xs) index key mi ma i)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) = 0 \\<Longrightarrow>\n    False", "assume \"Min ?A = 0\""], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) = 0\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) = 0 \\<Longrightarrow>\n    False", "hence \"offs_num (length ns) (x # xs) index key mi ma (Min ?A) = 0\""], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) (x # xs) index key mi ma\n     (Min (offs_set_prev ns (x # xs) index key mi ma i)) =\n    0", "using B"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) = 0\n  offs_num (length ns) (x # xs) index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) (x # xs) index key mi ma\n     (Min (offs_set_prev ns (x # xs) index key mi ma i)) =\n    0", "by simp"], ["proof (state)\nthis:\n  offs_num (length ns) (x # xs) index key mi ma\n   (Min (offs_set_prev ns (x # xs) index key mi ma i)) =\n  0\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) = 0 \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) (x # xs) index key mi ma\n   (Min (offs_set_prev ns (x # xs) index key mi ma i)) =\n  0\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) = 0 \\<Longrightarrow>\n    False", "have \"0 < offs_num (length ns) (x # xs) index key mi ma (Min ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma\n         (Min (offs_set_prev ns (x # xs) index key mi ma i))", "using D"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma\n         (Min (offs_set_prev ns (x # xs) index key mi ma i))", "by auto"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_prev ns (x # xs) index key mi ma i))\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) = 0 \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) (x # xs) index key mi ma\n   (Min (offs_set_prev ns (x # xs) index key mi ma i)) =\n  0\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_prev ns (x # xs) index key mi ma i))", "show False"], ["proof (prove)\nusing this:\n  offs_num (length ns) (x # xs) index key mi ma\n   (Min (offs_set_prev ns (x # xs) index key mi ma i)) =\n  0\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_prev ns (x # xs) index key mi ma i))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n  0 < Min (offs_set_prev ns (x # xs) index key mi ma i)", "have \"Min ?A \\<in> offs_set_next ns (x # xs) index key mi ma 0\"\n    (is \"_ \\<in> ?B\")"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n  0 < Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_next ns (x # xs) index key mi ma 0", "by auto"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "from this"], ["proof (chain)\npicking this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0", "have \"Min ?B = Min ?A\""], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0) =\n    Min (offs_set_prev ns (x # xs) index key mi ma i)", "proof (subst Min_eq_iff, simp, blast, simp, rule_tac allI, rule_tac impI,\n   (erule_tac conjE)+, rule_tac ccontr, simp add: not_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "assume F: \"j < Min ?A\""], ["proof (state)\nthis:\n  j < Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ns", "using D"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. i < length ns", "by simp"], ["proof (state)\nthis:\n  i < length ns\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i < length ns\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"Min ?A < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) < i", "using D"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) < i", "by auto"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"j < i\""], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (1 subgoal):\n 1. j < i", "using F"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) < i\n  j < Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. j < i", "by simp"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"0 < offs_num (length ns) (x # xs) index key mi ma j\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  i < length ns\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j", "have \"j \\<in> ?A\""], ["proof (prove)\nusing this:\n  i < length ns\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"Min ?A \\<le> j\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) \\<le> j", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) \\<le> j\n\ngoal (1 subgoal):\n 1. False", "using F"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) \\<le> j\n  j < Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma 0) =\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma 0) =\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "have \"Min ?A \\<in> offs_set_next (ns[i := Suc (ns ! i)])\n    xs index key mi ma 0\"\n    (is \"_ \\<in> ?C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0", "using D and E"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n  0 < Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i)\n    \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0", "by (auto, simp add: offs_num_cons A [symmetric])"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "from this"], ["proof (chain)\npicking this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0", "have \"Min ?C = Min ?A\""], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0) =\n    Min (offs_set_prev ns (x # xs) index key mi ma i)", "proof (subst Min_eq_iff, simp, blast, simp, rule_tac allI, rule_tac impI,\n   (erule_tac conjE)+, rule_tac ccontr, simp add: not_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "assume F: \"j < Min ?A\""], ["proof (state)\nthis:\n  j < Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ns", "using D"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. i < length ns", "by simp"], ["proof (state)\nthis:\n  i < length ns\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i < length ns\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"Min ?A < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) < i", "using D"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) < i", "by auto"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"j < i\""], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (1 subgoal):\n 1. j < i", "using F"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) < i\n  j < Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. j < i", "by simp"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"0 < offs_num (length ns) xs index key mi ma j\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"0 < offs_num (length ns) (x # xs) index key mi ma j\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma j", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  i < length ns\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j", "have \"j \\<in> ?A\""], ["proof (prove)\nusing this:\n  i < length ns\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"Min ?A \\<le> j\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) \\<le> j", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_prev ns (x # xs) index key mi ma i)\n                < length ns;\n        0 < offs_num (length ns) xs index key mi ma\n             (Min (offs_set_prev ns (x # xs) index key mi ma i));\n        0 < xa; 0 < offs_num (length ns) xs index key mi ma xa;\n        xa < Min (offs_set_prev ns (x # xs) index key mi ma i)\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) \\<le> j\n\ngoal (1 subgoal):\n 1. False", "using F"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) \\<le> j\n  j < Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0) =\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0) =\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "have \"Min ?A < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) < i", "using D"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_prev ns (x # xs) index key mi ma i) < i", "by auto"], ["proof (state)\nthis:\n  Min (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n  Min (offs_set_next ns (x # xs) index key mi ma 0) =\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0) =\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  Min (offs_set_prev ns (x # xs) index key mi ma i) < i", "show ?thesis"], ["proof (prove)\nusing this:\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n  Min (offs_set_next ns (x # xs) index key mi ma 0) =\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  \\<in> offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0\n  Min (offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0) =\n  Min (offs_set_prev ns (x # xs) index key mi ma i)\n  Min (offs_set_prev ns (x # xs) index key mi ma i) < i\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "by (simp only: offs_next_def split: if_split,\n     (rule_tac conjI, blast, rule_tac impI)+, simp)"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_next_zero_cons_neq:\n  assumes\n    A: \"index key x (length ns) mi ma = i\" and\n    B: \"i < length ns\" and\n    C: \"0 < i\" and\n    D: \"offs_set_prev ns (x # xs) index key mi ma i = {}\"\n  shows \"offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    (if 0 < offs_num (length ns) xs index key mi ma i\n     then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)", "proof (simp, rule conjI, rule_tac [!] impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "let ?ns' = \"ns[i := Suc (ns ! i)]\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "assume \"0 < offs_num (length ns) xs index key mi ma i\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "with A"], ["proof (chain)\npicking this:\n  index key x (length ns) mi ma = i\n  0 < offs_num (length ns) xs index key mi ma i", "have \"offs_set_next ?ns' xs index key mi ma 0 =\n    offs_set_next ns (x # xs) index key mi ma 0\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  0 < offs_num (length ns) xs index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0 =\n    offs_set_next ns (x # xs) index key mi ma 0", "by (rule_tac set_eqI, rule_tac iffI, simp_all add: offs_num_cons split:\n     if_split_asm)"], ["proof (state)\nthis:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0 =\n  offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "moreover"], ["proof (state)\nthis:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0 =\n  offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "have \"i \\<in> offs_set_next ns (x # xs) index key mi ma 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> offs_set_next ns (x # xs) index key mi ma 0", "using A and B and C"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  i < length ns\n  0 < i\n\ngoal (1 subgoal):\n 1. i \\<in> offs_set_next ns (x # xs) index key mi ma 0", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "moreover"], ["proof (state)\nthis:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "from this"], ["proof (chain)\npicking this:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0", "have\n   \"Min (offs_set_next ns (x # xs) index key mi ma 0) = i\""], ["proof (prove)\nusing this:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0) = i", "proof (subst Min_eq_iff, simp, blast, simp, rule_tac allI, rule_tac impI,\n   (erule_tac conjE)+, rule_tac ccontr, simp add: not_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>i < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma i; 0 < xa;\n        0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < i\\<rbrakk>\n       \\<Longrightarrow> False", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>i < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma i; 0 < xa;\n        0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < i\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j < i\" and \"0 < offs_num (length ns) (x # xs) index key mi ma j\""], ["proof (state)\nthis:\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>i < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma i; 0 < xa;\n        0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < i\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"j \\<in> offs_set_prev ns (x # xs) index key mi ma i\""], ["proof (prove)\nusing this:\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns (x # xs) index key mi ma i", "using B"], ["proof (prove)\nusing this:\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n  i < length ns\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>i < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma i; 0 < xa;\n        0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < i\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. False", "using D"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n  offs_set_prev ns (x # xs) index key mi ma i = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma 0) = i\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma i \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n 2. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "ultimately"], ["proof (chain)\npicking this:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0 =\n  offs_set_next ns (x # xs) index key mi ma 0\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n  Min (offs_set_next ns (x # xs) index key mi ma 0) = i", "show \"offs_next ?ns' ub xs index key mi ma 0 = Suc (ns ! i)\""], ["proof (prove)\nusing this:\n  offs_set_next (ns[i := Suc (ns ! i)]) xs index key mi ma 0 =\n  offs_set_next ns (x # xs) index key mi ma 0\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n  Min (offs_set_next ns (x # xs) index key mi ma 0) = i\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)", "by (simp only: offs_next_def split: if_split, rule_tac conjI, rule_tac [!] impI,\n     simp_all)"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "let ?ns' = \"ns[i := Suc (ns ! i)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "assume \"offs_num (length ns) xs index key mi ma i = 0\""], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "have \"offs_set_prev ?ns' xs index key mi ma i = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_set_prev (ns[i := Suc (ns ! i)]) xs index key mi ma i = {}", "using D"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i = {}\n\ngoal (1 subgoal):\n 1. offs_set_prev (ns[i := Suc (ns ! i)]) xs index key mi ma i = {}", "by (simp add: offs_num_cons split: if_split_asm, blast)"], ["proof (state)\nthis:\n  offs_set_prev (ns[i := Suc (ns ! i)]) xs index key mi ma i = {}\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma i = 0\n  offs_set_prev (ns[i := Suc (ns ! i)]) xs index key mi ma i = {}", "have \"offs_next ?ns' ub xs index key mi ma 0 =\n    offs_next ?ns' ub xs index key mi ma i\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma i = 0\n  offs_set_prev (ns[i := Suc (ns ! i)]) xs index key mi ma i = {}\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i", "using B"], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma i = 0\n  offs_set_prev (ns[i := Suc (ns ! i)]) xs index key mi ma i = {}\n  i < length ns\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i", "by (rule_tac offs_next_zero, simp_all)"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "moreover"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "have \"offs_next ?ns' ub xs index key mi ma i =\n    offs_next ns ub (x # xs) index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i =\n    offs_next ns ub (x # xs) index key mi ma i", "using A and B and D"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  i < length ns\n  offs_set_prev ns (x # xs) index key mi ma i = {}\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i =\n    offs_next ns ub (x # xs) index key mi ma i", "by (rule_tac offs_next_cons_eq, simp_all add:\n     offs_num_cons)"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i =\n  offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma i = 0 \\<Longrightarrow>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "ultimately"], ["proof (chain)\npicking this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i =\n  offs_next ns ub (x # xs) index key mi ma i", "show \"offs_next ?ns' ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i\""], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma i =\n  offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_pred_zero_cons_less:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"i < length ns\" and\n    D: \"0 < i\" and\n    E: \"offs_set_prev ns (x # xs) index key mi ma i = {}\"\n  shows \"offs_next ns ub (x # xs) index key mi ma 0 <\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\"\n  (is \"?M < ?N\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "have \"i \\<in> offs_set_next ns (x # xs) index key mi ma 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> offs_set_next ns (x # xs) index key mi ma 0", "using B and C and D"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  i < length ns\n  0 < i\n\ngoal (1 subgoal):\n 1. i \\<in> offs_set_next ns (x # xs) index key mi ma 0", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "moreover"], ["proof (state)\nthis:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "from this"], ["proof (chain)\npicking this:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0", "have\n   \"Min (offs_set_next ns (x # xs) index key mi ma 0) = i\""], ["proof (prove)\nusing this:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0) = i", "proof (subst Min_eq_iff, simp, blast, simp, rule_tac allI, rule_tac impI,\n   (erule_tac conjE)+, rule_tac ccontr, simp add: not_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>i < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma i; 0 < xa;\n        0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < i\\<rbrakk>\n       \\<Longrightarrow> False", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>i < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma i; 0 < xa;\n        0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < i\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j < i\" and \"0 < offs_num (length ns) (x # xs) index key mi ma j\""], ["proof (state)\nthis:\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>i < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma i; 0 < xa;\n        0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < i\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"j \\<in> offs_set_prev ns (x # xs) index key mi ma i\""], ["proof (prove)\nusing this:\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns (x # xs) index key mi ma i", "using C"], ["proof (prove)\nusing this:\n  j < i\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n  i < length ns\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_prev ns (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>i < length ns;\n        0 < offs_num (length ns) (x # xs) index key mi ma i; 0 < xa;\n        0 < offs_num (length ns) (x # xs) index key mi ma xa;\n        xa < i\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. False", "using E"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_prev ns (x # xs) index key mi ma i\n  offs_set_prev ns (x # xs) index key mi ma i = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma 0) = i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "ultimately"], ["proof (chain)\npicking this:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n  Min (offs_set_next ns (x # xs) index key mi ma 0) = i", "have F: \"?M = ns ! i\""], ["proof (prove)\nusing this:\n  i \\<in> offs_set_next ns (x # xs) index key mi ma 0\n  Min (offs_set_next ns (x # xs) index key mi ma 0) = i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0 = ns ! i", "by (simp only: offs_next_def split: if_split, blast)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0 = ns ! i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "have \"?N = (if 0 < offs_num (length ns) xs index key mi ma i\n    then Suc (ns ! i)\n    else offs_next ns ub (x # xs) index key mi ma i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)", "using B and C and D and E"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  i < length ns\n  0 < i\n  offs_set_prev ns (x # xs) index key mi ma i = {}\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n     else offs_next ns ub (x # xs) index key mi ma i)", "by (rule offs_next_zero_cons_neq)"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n   else offs_next ns ub (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  (if 0 < offs_num (length ns) xs index key mi ma i then Suc (ns ! i)\n   else offs_next ns ub (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "proof (split if_split_asm)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n     Suc (ns ! i)\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma 0\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma 0\n 2. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma 0\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma 0", "assume \"?N = Suc (ns ! i)\""], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n     Suc (ns ! i)\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma 0\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma 0\n 2. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma 0\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "using F"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 = Suc (ns ! i)\n  offs_next ns ub (x # xs) index key mi ma 0 = ns ! i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "by simp"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma 0\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma 0\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma 0", "assume \"?N = offs_next ns ub (x # xs) index key mi ma i\""], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma 0\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma 0", "moreover"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma 0\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma 0", "have \"ns ! i < offs_next ns ub (x # xs) index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! i < offs_next ns ub (x # xs) index key mi ma i", "using B"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. ns ! i < offs_next ns ub (x # xs) index key mi ma i", "by (rule_tac offs_pred_next [OF A C], simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! i < offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < offs_num (length ns) xs index key mi ma i;\n     offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n     offs_next ns ub (x # xs) index key mi ma i\\<rbrakk>\n    \\<Longrightarrow> offs_next ns ub (x # xs) index key mi ma 0\n                      < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi\n                         ma 0", "ultimately"], ["proof (chain)\npicking this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma i\n  ns ! i < offs_next ns ub (x # xs) index key mi ma i", "show ?thesis"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma i\n  ns ! i < offs_next ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "using F"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma i\n  ns ! i < offs_next ns ub (x # xs) index key mi ma i\n  offs_next ns ub (x # xs) index key mi ma 0 = ns ! i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "by simp"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_pred_zero_cons:\n  assumes\n    A: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    B: \"index key x (length ns) mi ma = i\" and\n    C: \"i < length ns\" and\n    D: \"offs_num (length ns) (x # xs) index key mi ma 0 = 0\"\n  shows \"offs_next ns ub (x # xs) index key mi ma 0 \\<le>\n    offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\"\n  (is \"?M \\<le> ?N\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "proof (cases \"offs_set_prev ns (x # xs) index key mi ma i = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. offs_set_prev ns (x # xs) index key mi ma i = {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n 2. offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n    {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "case True"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i = {}\n\ngoal (2 subgoals):\n 1. offs_set_prev ns (x # xs) index key mi ma i = {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n 2. offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n    {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "have \"0 < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i", "using B and D"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = i\n  offs_num (length ns) (x # xs) index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. 0 < i", "by (rule_tac ccontr, simp add: offs_num_cons)"], ["proof (state)\nthis:\n  0 < i\n\ngoal (2 subgoals):\n 1. offs_set_prev ns (x # xs) index key mi ma i = {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n 2. offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n    {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "hence \"?M < ?N\""], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "using True and B"], ["proof (prove)\nusing this:\n  0 < i\n  offs_set_prev ns (x # xs) index key mi ma i = {}\n  index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "by (rule_tac offs_pred_zero_cons_less [OF A _ C])"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n\ngoal (2 subgoals):\n 1. offs_set_prev ns (x # xs) index key mi ma i = {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n 2. offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n    {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma 0\n  < offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "by simp"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n    {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n    {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "case False"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n    {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "hence \"?N = ?M\""], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "by (rule offs_next_zero_cons_eq [OF B D])"], ["proof (state)\nthis:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_set_prev ns (x # xs) index key mi ma i \\<noteq>\n    {} \\<Longrightarrow>\n    offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0", "by simp"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> offs_next (ns[i := Suc (ns ! i)]) ub xs index key mi ma 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replicate_count:\n \"count (mset (replicate n x)) x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (mset (replicate n x)) x = n", "by (induction n, simp_all)"], ["", "lemma fill_none [rule_format]:\n  assumes A: \"index_less index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    offs_none ns ub xs index key mi ma i \\<longrightarrow>\n      fill xs ns index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    offs_none ns ub xs index key mi ma i \\<longrightarrow>\n    fill xs ns index key ub mi ma ! i = None", "proof (induction xs arbitrary: ns, simp add: offs_none_def offs_num_def offs_next_def,\n (rule impI)+, simp add: Let_def, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "fix x xs and ns :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "let ?i' = \"index key x (length ns) mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "let ?ns' = \"ns[?i' := Suc (ns ! ?i')]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "assume\n    B: \"offs_pred ns ub (x # xs) index key mi ma\" and\n    C: \"offs_none ns ub (x # xs) index key mi ma i\""], ["proof (state)\nthis:\n  offs_pred ns ub (x # xs) index key mi ma\n  offs_none ns ub (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "assume\n    D: \"ns \\<noteq> []\" and \"mi \\<le> key x\" and \"key x \\<le> ma\""], ["proof (state)\nthis:\n  ns \\<noteq> []\n  mi \\<le> key x\n  key x \\<le> ma\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "moreover"], ["proof (state)\nthis:\n  ns \\<noteq> []\n  mi \\<le> key x\n  key x \\<le> ma\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "from this"], ["proof (chain)\npicking this:\n  ns \\<noteq> []\n  mi \\<le> key x\n  key x \\<le> ma", "have\n    E: \"?i' < length ns\""], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  mi \\<le> key x\n  key x \\<le> ma\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "using A"], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  mi \\<le> key x\n  key x \\<le> ma\n  index_less index key\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "hence \"offs_pred ?ns' ub xs index key mi ma\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma", "by (rule_tac offs_pred_cons [OF B], simp)"], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "moreover"], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "assume \"\\<And>ns. ns \\<noteq> [] \\<longrightarrow> offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    offs_none ns ub xs index key mi ma i \\<longrightarrow>\n    fill xs ns index key ub mi ma ! i = None\""], ["proof (state)\nthis:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  offs_none ?ns ub xs index key mi ma i \\<longrightarrow>\n  fill xs ?ns index key ub mi ma ! i = None\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "ultimately"], ["proof (chain)\npicking this:\n  ns \\<noteq> []\n  mi \\<le> key x\n  key x \\<le> ma\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  offs_none ?ns ub xs index key mi ma i \\<longrightarrow>\n  fill xs ?ns index key ub mi ma ! i = None", "have\n    F: \"offs_none ?ns' ub xs index key mi ma i \\<longrightarrow>\n      fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  mi \\<le> key x\n  key x \\<le> ma\n  offs_pred\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  offs_none ?ns ub xs index key mi ma i \\<longrightarrow>\n  fill xs ?ns index key ub mi ma ! i = None\n\ngoal (1 subgoal):\n 1. offs_none\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma i \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by simp"], ["proof (state)\nthis:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   offs_none ns ub xs index key mi ma i \\<longrightarrow>\n                   fill xs ns index key ub mi ma ! i = None;\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        offs_none ns ub (a # xs) index key mi ma i; mi \\<le> key a;\n        key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key a (length ns) mi ma :=\n                                 Suc (ns ! index key a (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key a (length ns) mi ma := Some a] !\n                         i =\n                         None", "show \"(fill xs ?ns' index key ub mi ma)[ns ! ?i' := Some x] ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! i =\n    None", "proof (insert C, simp add: offs_none_def, erule disjE, erule_tac [2] disjE, simp_all del: subst_all\n   add: offs_num_cons split: if_split_asm, erule conjE, rule case_split, drule mp,\n   assumption, simp_all del: subst_all, (erule conjE)+, (erule_tac [2] conjE)+,\n   erule_tac [3] conjE, erule_tac [5] conjE)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma = j;\n        Suc (ns ! j + offs_num (length ns) xs index key mi ma j) \\<le> i;\n        j < length ns;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi\n                          ma !\n                         i =\n                         None\n 2. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma \\<noteq> j;\n        ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i;\n        j < length ns; 0 < offs_num (length ns) xs index key mi ma j;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key x (length ns) mi ma :=\n                                 Suc (ns ! index key x (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key x (length ns) mi ma := Some x] !\n                         i =\n                         None\n 3. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 4. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 5. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "fix j"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma = j;\n        Suc (ns ! j + offs_num (length ns) xs index key mi ma j) \\<le> i;\n        j < length ns;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi\n                          ma !\n                         i =\n                         None\n 2. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma \\<noteq> j;\n        ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i;\n        j < length ns; 0 < offs_num (length ns) xs index key mi ma j;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key x (length ns) mi ma :=\n                                 Suc (ns ! index key x (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key x (length ns) mi ma := Some x] !\n                         i =\n                         None\n 3. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 4. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 5. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "assume\n      G: \"?i' = j\" and\n      H: \"j < length ns\" and\n      I: \"Suc (ns ! j + offs_num (length ns) xs index key mi ma j) \\<le> i\" and\n      J: \"i < offs_next ns ub (x # xs) index key mi ma j\""], ["proof (state)\nthis:\n  index key x (length ns) mi ma = j\n  j < length ns\n  Suc (ns ! j + offs_num (length ns) xs index key mi ma j) \\<le> i\n  i < offs_next ns ub (x # xs) index key mi ma j\n\ngoal (5 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma = j;\n        Suc (ns ! j + offs_num (length ns) xs index key mi ma j) \\<le> i;\n        j < length ns;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi\n                          ma !\n                         i =\n                         None\n 2. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma \\<noteq> j;\n        ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i;\n        j < length ns; 0 < offs_num (length ns) xs index key mi ma j;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key x (length ns) mi ma :=\n                                 Suc (ns ! index key x (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key x (length ns) mi ma := Some x] !\n                         i =\n                         None\n 3. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 4. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 5. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "show \"fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None", "proof (cases \"0 < offs_num (length ns) xs index key mi ma j\",\n     case_tac [2] \"offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\",\n     simp_all only: not_not not_gr0)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have \"j < length ns \\<and> 0 < offs_num (length ns) xs index key mi ma j \\<and>\n        ?ns' ! j + offs_num (length ns) xs index key mi ma j \\<le> i \\<and>\n        i < offs_next ?ns' ub xs index key mi ma j \\<longrightarrow>\n          fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length ns \\<and>\n    0 < offs_num (length ns) xs index key mi ma j \\<and>\n    ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    j +\n    offs_num (length ns) xs index key mi ma j\n    \\<le> i \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using F"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. j < length ns \\<and>\n    0 < offs_num (length ns) xs index key mi ma j \\<and>\n    ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    j +\n    offs_num (length ns) xs index key mi ma j\n    \\<le> i \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by (simp add: offs_none_def, blast)"], ["proof (state)\nthis:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "moreover"], ["proof (state)\nthis:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "assume \"0 < offs_num (length ns) xs index key mi ma j\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "moreover"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have \"?ns' ! j + offs_num (length ns) xs index key mi ma j \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    j +\n    offs_num (length ns) xs index key mi ma j\n    \\<le> i", "using G and H and I"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = j\n  j < length ns\n  Suc (ns ! j + offs_num (length ns) xs index key mi ma j) \\<le> i\n\ngoal (1 subgoal):\n 1. ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    j +\n    offs_num (length ns) xs index key mi ma j\n    \\<le> i", "by simp"], ["proof (state)\nthis:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "moreover"], ["proof (state)\nthis:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have \"0 < offs_num (length ns) (x # xs) index key mi ma j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma j", "using G"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = j\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma j", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence \"offs_next ns ub (x # xs) index key mi ma j \\<le>\n        offs_next ?ns' ub xs index key mi ma j\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           ub xs index key mi ma j", "using G and H"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma j\n  index key x (length ns) mi ma = j\n  j < length ns\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           ub xs index key mi ma j", "by (rule_tac offs_pred_next_cons [OF B], simp_all)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence \"i < offs_next ?ns' ub xs index key mi ma j\""], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j", "using J"], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j\n  i < offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "ultimately"], ["proof (chain)\npicking this:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  0 < offs_num (length ns) xs index key mi ma j\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j", "have \"fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\nusing this:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  0 < offs_num (length ns) xs index key mi ma j\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using H"], ["proof (prove)\nusing this:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  0 < offs_num (length ns) xs index key mi ma j\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j\n  j < length ns\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by blast"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (3 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma j \\<Longrightarrow>\n    fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "thus ?thesis"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None", "using G"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  index key x (length ns) mi ma = j\n\ngoal (1 subgoal):\n 1. fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None", "by simp"], ["proof (state)\nthis:\n  fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "let ?j' = \"Max (offs_set_prev ns (x # xs) index key mi ma j)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have \"?j' < length ns \\<and> 0 < offs_num (length ns) xs index key mi ma ?j' \\<and>\n        ?ns' ! ?j' + offs_num (length ns) xs index key mi ma ?j' \\<le> i \\<and>\n        i < offs_next ?ns' ub xs index key mi ma ?j' \\<longrightarrow>\n          fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n    0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<and>\n    ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    Max (offs_set_prev ns (x # xs) index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j))\n    \\<le> i \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma\n                j)) \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using F"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n    0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<and>\n    ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    Max (offs_set_prev ns (x # xs) index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j))\n    \\<le> i \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma\n                j)) \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by (simp add: offs_none_def, blast)"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "moreover"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "assume K: \"offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\""], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence \"?j' \\<in> offs_set_prev ns (x # xs) index key mi ma j\""], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma j)\n    \\<in> offs_set_prev ns (x # xs) index key mi ma j", "by (rule_tac Max_in, simp)"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma j)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence L: \"?j' < length ns \\<and> ?j' < j \\<and>\n        0 < offs_num (length ns) xs index key mi ma ?j'\""], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma j)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n    Max (offs_set_prev ns (x # xs) index key mi ma j) < j \\<and>\n    0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma j))", "using G"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma j)\n  \\<in> offs_set_prev ns (x # xs) index key mi ma j\n  index key x (length ns) mi ma = j\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n    Max (offs_set_prev ns (x # xs) index key mi ma j) < j \\<and>\n    0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma j))", "by (auto, subst (asm) (2) offs_num_cons, simp)"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < j \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "moreover"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < j \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have \"ns ! ?j' + offs_num (length ns) (x # xs)\n        index key mi ma ?j' \\<le> ns ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! Max (offs_set_prev ns (x # xs) index key mi ma j) +\n    offs_num (length ns) (x # xs) index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j))\n    \\<le> ns ! j", "using G and H and L"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = j\n  j < length ns\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < j \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j))\n\ngoal (1 subgoal):\n 1. ns ! Max (offs_set_prev ns (x # xs) index key mi ma j) +\n    offs_num (length ns) (x # xs) index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j))\n    \\<le> ns ! j", "by (rule_tac offs_pred_asc [OF B], simp_all add:\n         offs_num_cons)"], ["proof (state)\nthis:\n  ns ! Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> ns ! j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence \"?ns' ! ?j' + offs_num (length ns) xs index key mi ma ?j' \\<le> ns ! j\""], ["proof (prove)\nusing this:\n  ns ! Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> ns ! j\n\ngoal (1 subgoal):\n 1. ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    Max (offs_set_prev ns (x # xs) index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j))\n    \\<le> ns ! j", "using G and H and L"], ["proof (prove)\nusing this:\n  ns ! Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> ns ! j\n  index key x (length ns) mi ma = j\n  j < length ns\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < j \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j))\n\ngoal (1 subgoal):\n 1. ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    Max (offs_set_prev ns (x # xs) index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j))\n    \\<le> ns ! j", "by (subst nth_list_update, simp_all add: offs_num_cons)"], ["proof (state)\nthis:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> ns ! j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence \"?ns' ! ?j' + offs_num (length ns) xs index key mi ma ?j' \\<le> i\""], ["proof (prove)\nusing this:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> ns ! j\n\ngoal (1 subgoal):\n 1. ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    Max (offs_set_prev ns (x # xs) index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j))\n    \\<le> i", "using I"], ["proof (prove)\nusing this:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> ns ! j\n  Suc (ns ! j + offs_num (length ns) xs index key mi ma j) \\<le> i\n\ngoal (1 subgoal):\n 1. ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    Max (offs_set_prev ns (x # xs) index key mi ma j) +\n    offs_num (length ns) xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j))\n    \\<le> i", "by simp"], ["proof (state)\nthis:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "moreover"], ["proof (state)\nthis:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "assume M: \"offs_num (length ns) xs index key mi ma j = 0\""], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma j = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have \"offs_next (ns[j := Suc (ns ! j)]) ub xs index key mi ma ?j' =\n       (if 0 < offs_num (length ns) xs index key mi ma j\n        then Suc (ns ! j)\n        else offs_next ns ub (x # xs) index key mi ma j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next (ns[j := Suc (ns ! j)]) ub xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n    (if 0 < offs_num (length ns) xs index key mi ma j then Suc (ns ! j)\n     else offs_next ns ub (x # xs) index key mi ma j)", "using G and K"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = j\n  offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. offs_next (ns[j := Suc (ns ! j)]) ub xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n    (if 0 < offs_num (length ns) xs index key mi ma j then Suc (ns ! j)\n     else offs_next ns ub (x # xs) index key mi ma j)", "by (rule_tac offs_next_cons_neq, simp_all)"], ["proof (state)\nthis:\n  offs_next (ns[j := Suc (ns ! j)]) ub xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n  (if 0 < offs_num (length ns) xs index key mi ma j then Suc (ns ! j)\n   else offs_next ns ub (x # xs) index key mi ma j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence \"offs_next ?ns' ub xs index key mi ma ?j' =\n        offs_next ns ub (x # xs) index key mi ma j\""], ["proof (prove)\nusing this:\n  offs_next (ns[j := Suc (ns ! j)]) ub xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n  (if 0 < offs_num (length ns) xs index key mi ma j then Suc (ns ! j)\n   else offs_next ns ub (x # xs) index key mi ma j)\n\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n    offs_next ns ub (x # xs) index key mi ma j", "using G and M"], ["proof (prove)\nusing this:\n  offs_next (ns[j := Suc (ns ! j)]) ub xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n  (if 0 < offs_num (length ns) xs index key mi ma j then Suc (ns ! j)\n   else offs_next ns ub (x # xs) index key mi ma j)\n  index key x (length ns) mi ma = j\n  offs_num (length ns) xs index key mi ma j = 0\n\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n    offs_next ns ub (x # xs) index key mi ma j", "by simp"], ["proof (state)\nthis:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n  offs_next ns ub (x # xs) index key mi ma j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence \"i < offs_next ?ns' ub xs index key mi ma ?j'\""], ["proof (prove)\nusing this:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n  offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma j))", "using J"], ["proof (prove)\nusing this:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j)) =\n  offs_next ns ub (x # xs) index key mi ma j\n  i < offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma j))", "by simp"], ["proof (state)\nthis:\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "ultimately"], ["proof (chain)\npicking this:\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < j \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> i\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j))", "have \"fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j)) \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < length ns \\<and>\n  Max (offs_set_prev ns (x # xs) index key mi ma j) < j \\<and>\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma j) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma j))\n  \\<le> i\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma j))\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by blast"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "thus ?thesis"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None", "using G"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  index key x (length ns) mi ma = j\n\ngoal (1 subgoal):\n 1. fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None", "by simp"], ["proof (state)\nthis:\n  fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have \"offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n        i < offs_next ?ns' ub xs index key mi ma 0 \\<longrightarrow>\n          fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using F"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "assume\n        K: \"offs_set_prev ns (x # xs) index key mi ma j = {}\" and\n        L: \"offs_num (length ns) xs index key mi ma j = 0\""], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma j = {}\n  offs_num (length ns) xs index key mi ma j = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have \"offs_set_prev ns (x # xs) index key mi ma j =\n        offs_set_prev ?ns' xs index key mi ma j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_set_prev ns (x # xs) index key mi ma j =\n    offs_set_prev\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     xs index key mi ma j", "using G"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = j\n\ngoal (1 subgoal):\n 1. offs_set_prev ns (x # xs) index key mi ma j =\n    offs_set_prev\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     xs index key mi ma j", "by (rule_tac set_eqI, rule_tac iffI,\n         simp_all add: offs_num_cons split: if_split_asm)"], ["proof (state)\nthis:\n  offs_set_prev ns (x # xs) index key mi ma j =\n  offs_set_prev\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence M: \"offs_set_prev ?ns' xs index key mi ma j = {}\""], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma j =\n  offs_set_prev\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_set_prev\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     xs index key mi ma j =\n    {}", "using K"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma j =\n  offs_set_prev\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma j\n  offs_set_prev ns (x # xs) index key mi ma j = {}\n\ngoal (1 subgoal):\n 1. offs_set_prev\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     xs index key mi ma j =\n    {}", "by simp"], ["proof (state)\nthis:\n  offs_set_prev\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma j =\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence \"offs_num (length ns) xs index key mi ma 0 = 0\""], ["proof (prove)\nusing this:\n  offs_set_prev\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma j =\n  {}\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0", "using H and L"], ["proof (prove)\nusing this:\n  offs_set_prev\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma j =\n  {}\n  j < length ns\n  offs_num (length ns) xs index key mi ma j = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0", "by (cases j, simp_all)"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have N: \"offs_next ?ns' ub xs index key mi ma 0 =\n        offs_next ?ns' ub xs index key mi ma j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0 =\n    offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma j", "using H and L and M"], ["proof (prove)\nusing this:\n  j < length ns\n  offs_num (length ns) xs index key mi ma j = 0\n  offs_set_prev\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   xs index key mi ma j =\n  {}\n\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0 =\n    offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma j", "by (rule_tac offs_next_zero, simp_all)"], ["proof (state)\nthis:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma 0 =\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "have \"offs_next ?ns' ub xs index key mi ma j =\n        offs_next ns ub (x # xs) index key mi ma j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma j", "using G and H and K"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma = j\n  j < length ns\n  offs_set_prev ns (x # xs) index key mi ma j = {}\n\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma j =\n    offs_next ns ub (x # xs) index key mi ma j", "by (subst offs_next_cons_eq, simp_all add:\n         offs_num_cons)"], ["proof (state)\nthis:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "hence \"i < offs_next ?ns' ub xs index key mi ma 0\""], ["proof (prove)\nusing this:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0", "using J and N"], ["proof (prove)\nusing this:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma j =\n  offs_next ns ub (x # xs) index key mi ma j\n  i < offs_next ns ub (x # xs) index key mi ma j\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma 0 =\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0", "by simp"], ["proof (state)\nthis:\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  offs_num (length ns) xs index key mi ma 0 = 0\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0", "have \"fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  offs_num (length ns) xs index key mi ma 0 = 0\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by blast"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_num (length ns) xs index key mi ma j = 0;\n     offs_set_prev ns (x # xs) index key mi ma j = {}\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma !\n                      i =\n                      None", "thus ?thesis"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None", "using G"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  index key x (length ns) mi ma = j\n\ngoal (1 subgoal):\n 1. fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None", "by simp"], ["proof (state)\nthis:\n  fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fill xs (ns[j := Suc (ns ! j)]) index key ub mi ma ! i = None\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma \\<noteq> j;\n        ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i;\n        j < length ns; 0 < offs_num (length ns) xs index key mi ma j;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key x (length ns) mi ma :=\n                                 Suc (ns ! index key x (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key x (length ns) mi ma := Some x] !\n                         i =\n                         None\n 2. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 3. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 4. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma \\<noteq> j;\n        ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i;\n        j < length ns; 0 < offs_num (length ns) xs index key mi ma j;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key x (length ns) mi ma :=\n                                 Suc (ns ! index key x (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key x (length ns) mi ma := Some x] !\n                         i =\n                         None\n 2. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 3. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 4. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "fix j"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma \\<noteq> j;\n        ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i;\n        j < length ns; 0 < offs_num (length ns) xs index key mi ma j;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key x (length ns) mi ma :=\n                                 Suc (ns ! index key x (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key x (length ns) mi ma := Some x] !\n                         i =\n                         None\n 2. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 3. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 4. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "assume\n      G: \"?i' \\<noteq> j\" and\n      H: \"j < length ns\" and\n      I: \"ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i\" and\n      J: \"i < offs_next ns ub (x # xs) index key mi ma j\" and\n      K: \"0 < offs_num (length ns) xs index key mi ma j\""], ["proof (state)\nthis:\n  index key x (length ns) mi ma \\<noteq> j\n  j < length ns\n  ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i\n  i < offs_next ns ub (x # xs) index key mi ma j\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma \\<noteq> j;\n        ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i;\n        j < length ns; 0 < offs_num (length ns) xs index key mi ma j;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key x (length ns) mi ma :=\n                                 Suc (ns ! index key x (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key x (length ns) mi ma := Some x] !\n                         i =\n                         None\n 2. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 3. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 4. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "from G"], ["proof (chain)\npicking this:\n  index key x (length ns) mi ma \\<noteq> j", "have \"ns ! ?i' \\<noteq> i\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma \\<noteq> j\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i", "proof (rule_tac notI, cases \"?i' < j\", simp_all add: not_less le_less)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     index key x (length ns) mi ma < j\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"?i' < j\""], ["proof (state)\nthis:\n  index key x (length ns) mi ma < j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     index key x (length ns) mi ma < j\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"ns ! ?i' + offs_num (length ns) (x # xs) index key mi ma ?i' \\<le> ns ! j\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < j\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma +\n    offs_num (length ns) (x # xs) index key mi ma\n     (index key x (length ns) mi ma)\n    \\<le> ns ! j", "using H and K"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < j\n  j < length ns\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma +\n    offs_num (length ns) (x # xs) index key mi ma\n     (index key x (length ns) mi ma)\n    \\<le> ns ! j", "by (rule_tac offs_pred_asc [OF B], simp_all add:\n         offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (x # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ns ! j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     index key x (length ns) mi ma < j\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (x # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ns ! j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     index key x (length ns) mi ma < j\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"ns ! ?i' = i\""], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     index key x (length ns) mi ma < j\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (x # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ns ! j\n  ns ! index key x (length ns) mi ma = i", "have \"i < ns ! j\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma +\n  offs_num (length ns) (x # xs) index key mi ma\n   (index key x (length ns) mi ma)\n  \\<le> ns ! j\n  ns ! index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. i < ns ! j", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  i < ns ! j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     index key x (length ns) mi ma < j\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  i < ns ! j\n\ngoal (1 subgoal):\n 1. False", "using I"], ["proof (prove)\nusing this:\n  i < ns ! j\n  ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"j < ?i'\""], ["proof (state)\nthis:\n  j < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "hence L: \"?i' \\<in> offs_set_next ns (x # xs) index key mi ma j\"\n        (is \"_ \\<in> ?A\")"], ["proof (prove)\nusing this:\n  j < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma\n    \\<in> offs_set_next ns (x # xs) index key mi ma j", "using E"], ["proof (prove)\nusing this:\n  j < index key x (length ns) mi ma\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma\n    \\<in> offs_set_next ns (x # xs) index key mi ma j", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"Min ?A \\<le> ?i'\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> index key x (length ns) mi ma", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<le> index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"Min ?A < ?i' \\<or> Min ?A = ?i'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<le> index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    < index key x (length ns) mi ma \\<or>\n    Min (offs_set_next ns (x # xs) index key mi ma j) =\n    index key x (length ns) mi ma", "by (simp add: le_less)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  < index key x (length ns) mi ma \\<or>\n  Min (offs_set_next ns (x # xs) index key mi ma j) =\n  index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"ns ! Min ?A \\<le> ns ! ?i'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  < index key x (length ns) mi ma \\<or>\n  Min (offs_set_next ns (x # xs) index key mi ma j) =\n  index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> ns ! index key x (length ns) mi ma", "proof (rule disjE, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> ns ! index key x (length ns) mi ma", "assume \"Min ?A < ?i'\""], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> ns ! index key x (length ns) mi ma", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> ns ! index key x (length ns) mi ma", "have \"Min ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<in> offs_set_next ns (x # xs) index key mi ma j", "using L"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<in> offs_set_next ns (x # xs) index key mi ma j", "by (rule_tac Min_in, simp, blast)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> ns ! index key x (length ns) mi ma", "hence \"0 < offs_num (length ns) (x # xs) index key mi ma (Min ?A)\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma\n         (Min (offs_set_next ns (x # xs) index key mi ma j))", "by simp"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_next ns (x # xs) index key mi ma j))\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> ns ! index key x (length ns) mi ma", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  < index key x (length ns) mi ma\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_next ns (x # xs) index key mi ma j))", "have \"ns ! Min ?A + offs_num (length ns) (x # xs)\n          index key mi ma (Min ?A) \\<le> ns ! ?i'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  < index key x (length ns) mi ma\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_next ns (x # xs) index key mi ma j))\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (x # xs) index key mi ma j) +\n    offs_num (length ns) (x # xs) index key mi ma\n     (Min (offs_set_next ns (x # xs) index key mi ma j))\n    \\<le> ns ! index key x (length ns) mi ma", "using E"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma j)\n  < index key x (length ns) mi ma\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_next ns (x # xs) index key mi ma j))\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (x # xs) index key mi ma j) +\n    offs_num (length ns) (x # xs) index key mi ma\n     (Min (offs_set_next ns (x # xs) index key mi ma j))\n    \\<le> ns ! index key x (length ns) mi ma", "by (rule_tac offs_pred_asc [OF B], simp_all add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Min (offs_set_next ns (x # xs) index key mi ma j))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma j)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> ns ! index key x (length ns) mi ma", "thus ?thesis"], ["proof (prove)\nusing this:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Min (offs_set_next ns (x # xs) index key mi ma j))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n    \\<le> ns ! index key x (length ns) mi ma", "by simp"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"offs_next ns ub (x # xs) index key mi ma j \\<le> ns ! ?i'\""], ["proof (prove)\nusing this:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> ns ! index key x (length ns) mi ma", "using L"], ["proof (prove)\nusing this:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma j)\n  \\<le> ns ! index key x (length ns) mi ma\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> ns ! index key x (length ns) mi ma", "by (simp only: offs_next_def split: if_split, blast)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"ns ! ?i' = i\""], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ns ! index key x (length ns) mi ma = i;\n     j < index key x (length ns) mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> ns ! index key x (length ns) mi ma\n  ns ! index key x (length ns) mi ma = i", "show False"], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> ns ! index key x (length ns) mi ma\n  ns ! index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. False", "using J"], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> ns ! index key x (length ns) mi ma\n  ns ! index key x (length ns) mi ma = i\n  i < offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma \\<noteq> i\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>index key x (length ns) mi ma \\<noteq> j;\n        ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i;\n        j < length ns; 0 < offs_num (length ns) xs index key mi ma j;\n        i < offs_next ns ub (x # xs) index key mi ma j\\<rbrakk>\n       \\<Longrightarrow> (fill xs\n                           (ns[index key x (length ns) mi ma :=\n                                 Suc (ns ! index key x (length ns) mi ma)])\n                           index key ub mi ma)\n                         [ns ! index key x (length ns) mi ma := Some x] !\n                         i =\n                         None\n 2. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 3. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 4. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "thus \"(fill xs ?ns' index key ub mi ma)[ns ! ?i' := Some x] ! i = None\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma \\<noteq> i\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! i =\n    None", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "have \"j < length ns \\<and> 0 < offs_num (length ns) xs index key mi ma j \\<and>\n        ?ns' ! j + offs_num (length ns) xs index key mi ma j \\<le> i \\<and>\n        i < offs_next ?ns' ub xs index key mi ma j \\<longrightarrow>\n          fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length ns \\<and>\n    0 < offs_num (length ns) xs index key mi ma j \\<and>\n    ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    j +\n    offs_num (length ns) xs index key mi ma j\n    \\<le> i \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using F"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. j < length ns \\<and>\n    0 < offs_num (length ns) xs index key mi ma j \\<and>\n    ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    j +\n    offs_num (length ns) xs index key mi ma j\n    \\<le> i \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by (simp add: offs_none_def, blast)"], ["proof (state)\nthis:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "moreover"], ["proof (state)\nthis:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "have \"offs_next ns ub (x # xs) index key mi ma j \\<le>\n        offs_next ?ns' ub xs index key mi ma j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           ub xs index key mi ma j", "using E and K"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < length ns\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma j\n    \\<le> offs_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           ub xs index key mi ma j", "by (rule_tac offs_pred_next_cons [OF B], simp_all add:\n         offs_num_cons)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "hence \"i < offs_next ?ns' ub xs index key mi ma j\""], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j", "using J"], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma j\n  \\<le> offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j\n  i < offs_next ns ub (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma j", "by simp"], ["proof (state)\nthis:\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "ultimately"], ["proof (chain)\npicking this:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j", "show \"fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\nusing this:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using G and H and I and K"], ["proof (prove)\nusing this:\n  j < length ns \\<and>\n  0 < offs_num (length ns) xs index key mi ma j \\<and>\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  j +\n  offs_num (length ns) xs index key mi ma j\n  \\<le> i \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma j\n  index key x (length ns) mi ma \\<noteq> j\n  j < length ns\n  ns ! j + offs_num (length ns) xs index key mi ma j \\<le> i\n  0 < offs_num (length ns) xs index key mi ma j\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by simp"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! i =\n  None\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 2. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 2. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "assume\n      G: \"0 < ?i'\" and\n      H: \"offs_num (length ns) xs index key mi ma 0 = 0\" and\n      I: \"i < offs_next ns ub (x # xs) index key mi ma 0\""], ["proof (state)\nthis:\n  0 < index key x (length ns) mi ma\n  offs_num (length ns) xs index key mi ma 0 = 0\n  i < offs_next ns ub (x # xs) index key mi ma 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 2. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "have \"ns ! ?i' \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma = i \\<Longrightarrow> False", "have \"0 < offs_num (length ns) (x # xs) index key mi ma ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma\n         (index key x (length ns) mi ma)", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma = i \\<Longrightarrow> False", "hence L: \"?i' \\<in> offs_set_next ns (x # xs) index key mi ma 0\"\n        (is \"_ \\<in> ?A\")"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma\n    \\<in> offs_set_next ns (x # xs) index key mi ma 0", "using E and G"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (index key x (length ns) mi ma)\n  index key x (length ns) mi ma < length ns\n  0 < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma\n    \\<in> offs_set_next ns (x # xs) index key mi ma 0", "by simp"], ["proof (state)\nthis:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma = i \\<Longrightarrow> False", "hence \"Min ?A \\<le> ?i'\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<le> index key x (length ns) mi ma", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  \\<le> index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma = i \\<Longrightarrow> False", "hence \"Min ?A < ?i' \\<or> Min ?A = ?i'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  \\<le> index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    < index key x (length ns) mi ma \\<or>\n    Min (offs_set_next ns (x # xs) index key mi ma 0) =\n    index key x (length ns) mi ma", "by (simp add: le_less)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  < index key x (length ns) mi ma \\<or>\n  Min (offs_set_next ns (x # xs) index key mi ma 0) =\n  index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma = i \\<Longrightarrow> False", "hence \"ns ! Min ?A \\<le> ns ! ?i'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  < index key x (length ns) mi ma \\<or>\n  Min (offs_set_next ns (x # xs) index key mi ma 0) =\n  index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<le> ns ! index key x (length ns) mi ma", "proof (rule disjE, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<le> ns ! index key x (length ns) mi ma", "assume \"Min ?A < ?i'\""], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<le> ns ! index key x (length ns) mi ma", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<le> ns ! index key x (length ns) mi ma", "have \"Min ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<in> offs_set_next ns (x # xs) index key mi ma 0", "using L"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<in> offs_set_next ns (x # xs) index key mi ma 0", "by (rule_tac Min_in, simp, blast)"], ["proof (state)\nthis:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<le> ns ! index key x (length ns) mi ma", "hence \"0 < offs_num (length ns) (x # xs) index key mi ma (Min ?A)\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma\n         (Min (offs_set_next ns (x # xs) index key mi ma 0))", "by simp"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_next ns (x # xs) index key mi ma 0))\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<le> ns ! index key x (length ns) mi ma", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  < index key x (length ns) mi ma\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_next ns (x # xs) index key mi ma 0))", "have \"ns ! Min ?A + offs_num (length ns) (x # xs)\n          index key mi ma (Min ?A) \\<le> ns ! ?i'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  < index key x (length ns) mi ma\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_next ns (x # xs) index key mi ma 0))\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (x # xs) index key mi ma 0) +\n    offs_num (length ns) (x # xs) index key mi ma\n     (Min (offs_set_next ns (x # xs) index key mi ma 0))\n    \\<le> ns ! index key x (length ns) mi ma", "using E"], ["proof (prove)\nusing this:\n  Min (offs_set_next ns (x # xs) index key mi ma 0)\n  < index key x (length ns) mi ma\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Min (offs_set_next ns (x # xs) index key mi ma 0))\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (x # xs) index key mi ma 0) +\n    offs_num (length ns) (x # xs) index key mi ma\n     (Min (offs_set_next ns (x # xs) index key mi ma 0))\n    \\<le> ns ! index key x (length ns) mi ma", "by (rule_tac offs_pred_asc [OF B], simp_all add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma 0) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Min (offs_set_next ns (x # xs) index key mi ma 0))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. Min (offs_set_next ns (x # xs) index key mi ma 0)\n    < index key x (length ns) mi ma \\<Longrightarrow>\n    ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<le> ns ! index key x (length ns) mi ma", "thus ?thesis"], ["proof (prove)\nusing this:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma 0) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Min (offs_set_next ns (x # xs) index key mi ma 0))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n    \\<le> ns ! index key x (length ns) mi ma", "by simp"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma = i \\<Longrightarrow> False", "hence \"offs_next ns ub (x # xs) index key mi ma 0 \\<le> ns ! ?i'\""], ["proof (prove)\nusing this:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> ns ! index key x (length ns) mi ma", "using L"], ["proof (prove)\nusing this:\n  ns ! Min (offs_set_next ns (x # xs) index key mi ma 0)\n  \\<le> ns ! index key x (length ns) mi ma\n  index key x (length ns) mi ma\n  \\<in> offs_set_next ns (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> ns ! index key x (length ns) mi ma", "by (simp only: offs_next_def split: if_split, blast)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma = i \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma = i \\<Longrightarrow> False", "assume \"ns ! ?i' = i\""], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma = i \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n  ns ! index key x (length ns) mi ma = i", "show False"], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n  ns ! index key x (length ns) mi ma = i\n\ngoal (1 subgoal):\n 1. False", "using I"], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n  ns ! index key x (length ns) mi ma = i\n  i < offs_next ns ub (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma \\<noteq> i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < index key x (length ns) mi ma;\n     offs_num (length ns) xs index key mi ma 0 = 0;\n     i < offs_next ns ub (x # xs) index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None\n 2. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 3. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "thus \"(fill xs ?ns' index key ub mi ma)[ns ! ?i' := Some x] ! i = None\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma \\<noteq> i\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! i =\n    None", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "have \"offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n        i < offs_next ?ns' ub xs index key mi ma 0 \\<longrightarrow>\n          fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using F"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "have \"offs_next ns ub (x # xs) index key mi ma 0 \\<le>\n        offs_next ?ns' ub xs index key mi ma 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           ub xs index key mi ma 0", "using E and G and H"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < length ns\n  0 < index key x (length ns) mi ma\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. offs_next ns ub (x # xs) index key mi ma 0\n    \\<le> offs_next\n           (ns[index key x (length ns) mi ma :=\n                 Suc (ns ! index key x (length ns) mi ma)])\n           ub xs index key mi ma 0", "by (rule_tac offs_pred_zero_cons [OF B],\n         simp_all add: offs_num_cons)"], ["proof (state)\nthis:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "hence \"i < offs_next ?ns' ub xs index key mi ma 0\""], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0", "using I"], ["proof (prove)\nusing this:\n  offs_next ns ub (x # xs) index key mi ma 0\n  \\<le> offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0\n  i < offs_next ns ub (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0", "by simp"], ["proof (state)\nthis:\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0", "show \"fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using H"], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by simp"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! i =\n  None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "assume\n      G: \"?i' = 0\" and\n      H: \"i < ns ! 0\""], ["proof (state)\nthis:\n  index key x (length ns) mi ma = 0\n  i < ns ! 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>index key x (length ns) mi ma = 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma !\n                      i =\n                      None\n 2. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "show \"fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "proof (cases \"0 < offs_num (length ns) xs index key mi ma 0\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\n 2. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "have \"0 < offs_num (length ns) xs index key mi ma 0 \\<and> i < ?ns' ! 0 \\<longrightarrow>\n        fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n    i < ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)] !\n        0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using F"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n    i < ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)] !\n        0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\n 2. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "moreover"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\n 2. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "assume \"0 < offs_num (length ns) xs index key mi ma 0\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma 0\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\n 2. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "moreover"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma 0\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\n 2. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "have \"i < ?ns' ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)] !\n        0", "using D and G and H"], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  index key x (length ns) mi ma = 0\n  i < ns ! 0\n\ngoal (1 subgoal):\n 1. i < ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)] !\n        0", "by simp"], ["proof (state)\nthis:\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0\n\ngoal (2 subgoals):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\n 2. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "ultimately"], ["proof (chain)\npicking this:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  0 < offs_num (length ns) xs index key mi ma 0\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  0 < offs_num (length ns) xs index key mi ma 0\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0\n\ngoal (1 subgoal):\n 1. fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "using G"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  0 < offs_num (length ns) xs index key mi ma 0\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0\n  index key x (length ns) mi ma = 0\n\ngoal (1 subgoal):\n 1. fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "by simp"], ["proof (state)\nthis:\n  fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "have \"offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n        i < offs_next ?ns' ub xs index key mi ma 0 \\<longrightarrow>\n          fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using F"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n    i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "assume \"offs_num (length ns) xs index key mi ma 0 = 0\""], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "have I: \"offs_next ?ns' ub xs index key mi ma 0 =\n        offs_next ns ub (x # xs) index key mi ma 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "using D and G"], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  index key x (length ns) mi ma = 0\n\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0 =\n    offs_next ns ub (x # xs) index key mi ma 0", "by (rule_tac offs_next_cons_eq, simp_all add:\n         offs_num_cons)"], ["proof (state)\nthis:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "have \"ns ! 0 < offs_next ns ub (x # xs) index key mi ma 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! 0 < offs_next ns ub (x # xs) index key mi ma 0", "using D and G"], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  index key x (length ns) mi ma = 0\n\ngoal (1 subgoal):\n 1. ns ! 0 < offs_next ns ub (x # xs) index key mi ma 0", "by (rule_tac offs_pred_next [OF B], simp_all add:\n         offs_num_cons)"], ["proof (state)\nthis:\n  ns ! 0 < offs_next ns ub (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "hence \"i < offs_next ?ns' ub xs index key mi ma 0\""], ["proof (prove)\nusing this:\n  ns ! 0 < offs_next ns ub (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0", "using H and I"], ["proof (prove)\nusing this:\n  ns ! 0 < offs_next ns ub (x # xs) index key mi ma 0\n  i < ns ! 0\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma 0 =\n  offs_next ns ub (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. i < offs_next\n         (ns[index key x (length ns) mi ma :=\n               Suc (ns ! index key x (length ns) mi ma)])\n         ub xs index key mi ma 0", "by simp"], ["proof (state)\nthis:\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0 \\<Longrightarrow>\n    fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  offs_num (length ns) xs index key mi ma 0 = 0\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0", "show ?thesis"], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  offs_num (length ns) xs index key mi ma 0 = 0\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "using G"], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma 0 = 0 \\<and>\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  offs_num (length ns) xs index key mi ma 0 = 0\n  i < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0\n  index key x (length ns) mi ma = 0\n\ngoal (1 subgoal):\n 1. fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None", "by simp"], ["proof (state)\nthis:\n  fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fill xs (ns[0 := Suc (ns ! 0)]) index key ub mi ma ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "assume\n      G: \"0 < ?i'\" and\n      H: \"0 < offs_num (length ns) xs index key mi ma 0\" and\n      I: \"i < ns ! 0\""], ["proof (state)\nthis:\n  0 < index key x (length ns) mi ma\n  0 < offs_num (length ns) xs index key mi ma 0\n  i < ns ! 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "have \"ns ! ?i' \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i", "have \"ns ! 0 + offs_num (length ns) (x # xs) index key mi ma 0 \\<le> ns ! ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! 0 + offs_num (length ns) (x # xs) index key mi ma 0\n    \\<le> ns ! index key x (length ns) mi ma", "using H"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. ns ! 0 + offs_num (length ns) (x # xs) index key mi ma 0\n    \\<le> ns ! index key x (length ns) mi ma", "by (rule_tac offs_pred_asc [OF B G E], simp_all add:\n         offs_num_cons)"], ["proof (state)\nthis:\n  ns ! 0 + offs_num (length ns) (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i", "moreover"], ["proof (state)\nthis:\n  ns ! 0 + offs_num (length ns) (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i", "have \"0 < offs_num (length ns) (x # xs) index key mi ma 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma 0", "using H"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma 0", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i", "ultimately"], ["proof (chain)\npicking this:\n  ns ! 0 + offs_num (length ns) (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n  0 < offs_num (length ns) (x # xs) index key mi ma 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ns ! 0 + offs_num (length ns) (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n  0 < offs_num (length ns) (x # xs) index key mi ma 0\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i", "using I"], ["proof (prove)\nusing this:\n  ns ! 0 + offs_num (length ns) (x # xs) index key mi ma 0\n  \\<le> ns ! index key x (length ns) mi ma\n  0 < offs_num (length ns) (x # xs) index key mi ma 0\n  i < ns ! 0\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i", "by simp"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma \\<noteq> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < index key x (length ns) mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0; i < ns ! 0\\<rbrakk>\n    \\<Longrightarrow> (fill xs\n                        (ns[index key x (length ns) mi ma :=\n                              Suc (ns ! index key x (length ns) mi ma)])\n                        index key ub mi ma)\n                      [ns ! index key x (length ns) mi ma := Some x] ! i =\n                      None", "thus \"(fill xs ?ns' index key ub mi ma)[ns ! ?i' := Some x] ! i = None\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma \\<noteq> i\n\ngoal (1 subgoal):\n 1. (fill xs\n      (ns[index key x (length ns) mi ma :=\n            Suc (ns ! index key x (length ns) mi ma)])\n      index key ub mi ma)\n    [ns ! index key x (length ns) mi ma := Some x] ! i =\n    None", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "have \"0 < offs_num (length ns) xs index key mi ma 0 \\<and> i < ?ns' ! 0 \\<longrightarrow>\n        fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n    i < ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)] !\n        0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using F"], ["proof (prove)\nusing this:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma i \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n    i < ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)] !\n        0 \\<longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "moreover"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "have \"i < ?ns' ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)] !\n        0", "using G and I"], ["proof (prove)\nusing this:\n  0 < index key x (length ns) mi ma\n  i < ns ! 0\n\ngoal (1 subgoal):\n 1. i < ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)] !\n        0", "by simp"], ["proof (state)\nthis:\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma \\<noteq> i \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "ultimately"], ["proof (chain)\npicking this:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0", "show \"fill xs ?ns' index key ub mi ma ! i = None\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "using H"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma 0 \\<and>\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0 \\<longrightarrow>\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n  i < ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)] !\n      0\n  0 < offs_num (length ns) xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    i =\n    None", "by simp"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   index key ub mi ma !\n  i =\n  None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! i =\n  None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fill xs\n    (ns[index key x (length ns) mi ma :=\n          Suc (ns ! index key x (length ns) mi ma)])\n    index key ub mi ma)\n  [ns ! index key x (length ns) mi ma := Some x] ! i =\n  None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fill_index_none [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"key x \\<in> {mi..ma}\" and\n    C: \"ns \\<noteq> []\" and\n    D: \"offs_pred ns ub (x # xs) index key mi ma\"\n  shows \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n    fill xs (ns[(index key x (length ns) mi ma) :=\n      Suc (ns ! index key x (length ns) mi ma)]) index key ub mi ma !\n        (ns ! index key x (length ns) mi ma) = None\"\n  (is \"_ \\<Longrightarrow> fill _ ?ns' _ _ _ _ _ ! (_ ! ?i) = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) =\n    None", "using A and B and C and D"], ["proof (prove)\nusing this:\n  index_less index key\n  key x \\<in> {mi..ma}\n  ns \\<noteq> []\n  offs_pred ns ub (x # xs) index key mi ma\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n    fill xs\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key x (length ns) mi ma) =\n    None", "proof (rule_tac fill_none, simp_all, rule_tac offs_pred_cons,\n simp_all, simp add: index_less_def, cases \"0 < ?i\",\n cases \"offs_set_prev ns (x # xs) index key mi ma ?i = {}\",\n case_tac [3] \"0 < offs_num (length ns) xs index key mi ma 0\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 4. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "assume\n    E: \"0 < ?i\" and\n    F: \"offs_set_prev ns (x # xs) index key mi ma ?i = {}\""], ["proof (state)\nthis:\n  0 < index key x (length ns) mi ma\n  offs_set_prev ns (x # xs) index key mi ma\n   (index key x (length ns) mi ma) =\n  {}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 4. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have G: \"?i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "using A and B and C"], ["proof (prove)\nusing this:\n  index_less index key\n  key x \\<in> {mi..ma}\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key x (length ns) mi ma < length ns\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 4. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "hence \"offs_num (length ns) (x # xs) index key mi ma 0 = 0\""], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_num (length ns) (x # xs) index key mi ma 0 = 0", "using E and F"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < length ns\n  0 < index key x (length ns) mi ma\n  offs_set_prev ns (x # xs) index key mi ma\n   (index key x (length ns) mi ma) =\n  {}\n\ngoal (1 subgoal):\n 1. offs_num (length ns) (x # xs) index key mi ma 0 = 0", "by (rule_tac ccontr, simp)"], ["proof (state)\nthis:\n  offs_num (length ns) (x # xs) index key mi ma 0 = 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 4. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "hence \"offs_num (length ns) xs index key mi ma 0 = 0\""], ["proof (prove)\nusing this:\n  offs_num (length ns) (x # xs) index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0", "by (simp add: offs_num_cons split: if_split_asm)"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 4. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 4. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have \"offs_next ?ns' ub xs index key mi ma 0 =\n   (if 0 < offs_num (length ns) xs index key mi ma ?i\n    then Suc (ns ! ?i)\n    else offs_next ns ub (x # xs) index key mi ma ?i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0 =\n    (if 0 < offs_num (length ns) xs index key mi ma\n             (index key x (length ns) mi ma)\n     then Suc (ns ! index key x (length ns) mi ma)\n     else offs_next ns ub (x # xs) index key mi ma\n           (index key x (length ns) mi ma))", "using E and F and G"], ["proof (prove)\nusing this:\n  0 < index key x (length ns) mi ma\n  offs_set_prev ns (x # xs) index key mi ma\n   (index key x (length ns) mi ma) =\n  {}\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0 =\n    (if 0 < offs_num (length ns) xs index key mi ma\n             (index key x (length ns) mi ma)\n     then Suc (ns ! index key x (length ns) mi ma)\n     else offs_next ns ub (x # xs) index key mi ma\n           (index key x (length ns) mi ma))", "by (rule_tac offs_next_zero_cons_neq, simp_all)"], ["proof (state)\nthis:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma 0 =\n  (if 0 < offs_num (length ns) xs index key mi ma\n           (index key x (length ns) mi ma)\n   then Suc (ns ! index key x (length ns) mi ma)\n   else offs_next ns ub (x # xs) index key mi ma\n         (index key x (length ns) mi ma))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 4. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "hence \"ns ! ?i < offs_next ?ns' ub xs index key mi ma 0\""], ["proof (prove)\nusing this:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma 0 =\n  (if 0 < offs_num (length ns) xs index key mi ma\n           (index key x (length ns) mi ma)\n   then Suc (ns ! index key x (length ns) mi ma)\n   else offs_next ns ub (x # xs) index key mi ma\n         (index key x (length ns) mi ma))\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma\n    < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0", "by (simp split: if_split_asm, rule_tac offs_pred_next [OF D G], simp add:\n     offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 4. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma 0 = 0\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0", "show \"offs_none ?ns' ub xs index key mi ma (ns ! ?i)\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma 0 = 0\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_none\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (ns ! index key x (length ns) mi ma)", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (ns ! index key x (length ns) mi ma)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "assume\n    E: \"0 < ?i\" and\n    F: \"offs_set_prev ns (x # xs) index key mi ma ?i \\<noteq> {}\"\n      (is \"?A \\<noteq> _\")"], ["proof (state)\nthis:\n  0 < index key x (length ns) mi ma\n  offs_set_prev ns (x # xs) index key mi ma\n   (index key x (length ns) mi ma) \\<noteq>\n  {}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have G: \"?i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "using A and B and C"], ["proof (prove)\nusing this:\n  index_less index key\n  key x \\<in> {mi..ma}\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key x (length ns) mi ma < length ns\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have H: \"Max ?A \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma))\n    \\<in> offs_set_prev ns (x # xs) index key mi ma\n           (index key x (length ns) mi ma)", "using F"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma\n   (index key x (length ns) mi ma) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma))\n    \\<in> offs_set_prev ns (x # xs) index key mi ma\n           (index key x (length ns) mi ma)", "by (rule_tac Max_in, simp)"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  \\<in> offs_set_prev ns (x # xs) index key mi ma\n         (index key x (length ns) mi ma)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "hence I: \"Max ?A < ?i\""], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  \\<in> offs_set_prev ns (x # xs) index key mi ma\n         (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma))\n    < index key x (length ns) mi ma", "by blast"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  < index key x (length ns) mi ma\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have \"Max ?A < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma))\n    < length ns", "using H"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  \\<in> offs_set_prev ns (x # xs) index key mi ma\n         (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma))\n    < length ns", "by auto"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  < length ns\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "moreover"], ["proof (state)\nthis:\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  < length ns\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have \"0 < offs_num (length ns) (x # xs) index key mi ma (Max ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma\n                (index key x (length ns) mi ma)))", "using H"], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  \\<in> offs_set_prev ns (x # xs) index key mi ma\n         (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) (x # xs) index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma\n                (index key x (length ns) mi ma)))", "by auto"], ["proof (state)\nthis:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma\n              (index key x (length ns) mi ma)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "hence \"0 < offs_num (length ns) xs index key mi ma (Max ?A)\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma\n              (index key x (length ns) mi ma)))\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma\n                (index key x (length ns) mi ma)))", "using I"], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) (x # xs) index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma\n              (index key x (length ns) mi ma)))\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length ns) xs index key mi ma\n         (Max (offs_set_prev ns (x # xs) index key mi ma\n                (index key x (length ns) mi ma)))", "by (subst (asm) offs_num_cons, split if_split_asm, simp_all)"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma\n              (index key x (length ns) mi ma)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "moreover"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma\n              (index key x (length ns) mi ma)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have \"ns ! Max ?A + offs_num (length ns) (x # xs)\n    index key mi ma (Max ?A) \\<le> ns ! ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns !\n    Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)) +\n    offs_num (length ns) (x # xs) index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma\n            (index key x (length ns) mi ma)))\n    \\<le> ns ! index key x (length ns) mi ma", "using G and H"], ["proof (prove)\nusing this:\n  index key x (length ns) mi ma < length ns\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  \\<in> offs_set_prev ns (x # xs) index key mi ma\n         (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. ns !\n    Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)) +\n    offs_num (length ns) (x # xs) index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma\n            (index key x (length ns) mi ma)))\n    \\<le> ns ! index key x (length ns) mi ma", "by (rule_tac offs_pred_asc [OF D], simp_all add: offs_num_cons)"], ["proof (state)\nthis:\n  ns !\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma)) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "hence \"?ns' ! Max ?A + offs_num (length ns) xs\n    index key mi ma (Max ?A) \\<le> ns ! ?i\""], ["proof (prove)\nusing this:\n  ns !\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma)) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)) +\n    offs_num (length ns) xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma\n            (index key x (length ns) mi ma)))\n    \\<le> ns ! index key x (length ns) mi ma", "using I"], ["proof (prove)\nusing this:\n  ns !\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma)) +\n  offs_num (length ns) (x # xs) index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)))\n  \\<le> ns ! index key x (length ns) mi ma\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)] !\n    Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)) +\n    offs_num (length ns) xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma\n            (index key x (length ns) mi ma)))\n    \\<le> ns ! index key x (length ns) mi ma", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma)) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "moreover"], ["proof (state)\nthis:\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma)) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)))\n  \\<le> ns ! index key x (length ns) mi ma\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have \"offs_next ?ns' ub xs index key mi ma (Max ?A) =\n   (if 0 < offs_num (length ns) xs index key mi ma ?i\n    then Suc (ns ! ?i)\n    else offs_next ns ub (x # xs) index key mi ma ?i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma\n            (index key x (length ns) mi ma))) =\n    (if 0 < offs_num (length ns) xs index key mi ma\n             (index key x (length ns) mi ma)\n     then Suc (ns ! index key x (length ns) mi ma)\n     else offs_next ns ub (x # xs) index key mi ma\n           (index key x (length ns) mi ma))", "using F and I"], ["proof (prove)\nusing this:\n  offs_set_prev ns (x # xs) index key mi ma\n   (index key x (length ns) mi ma) \\<noteq>\n  {}\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma\n            (index key x (length ns) mi ma))) =\n    (if 0 < offs_num (length ns) xs index key mi ma\n             (index key x (length ns) mi ma)\n     then Suc (ns ! index key x (length ns) mi ma)\n     else offs_next ns ub (x # xs) index key mi ma\n           (index key x (length ns) mi ma))", "by (rule_tac offs_next_cons_neq, simp_all)"], ["proof (state)\nthis:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma))) =\n  (if 0 < offs_num (length ns) xs index key mi ma\n           (index key x (length ns) mi ma)\n   then Suc (ns ! index key x (length ns) mi ma)\n   else offs_next ns ub (x # xs) index key mi ma\n         (index key x (length ns) mi ma))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "hence \"ns ! ?i < offs_next ?ns' ub xs index key mi ma (Max ?A)\""], ["proof (prove)\nusing this:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma))) =\n  (if 0 < offs_num (length ns) xs index key mi ma\n           (index key x (length ns) mi ma)\n   then Suc (ns ! index key x (length ns) mi ma)\n   else offs_next ns ub (x # xs) index key mi ma\n         (index key x (length ns) mi ma))\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma\n    < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma\n              (index key x (length ns) mi ma)))", "by (simp split: if_split_asm, rule_tac offs_pred_next [OF D G], simp add:\n     offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma\n            (index key x (length ns) mi ma)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     offs_set_prev ns (x # xs) index key mi ma\n      (index key x (length ns) mi ma) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 3. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "ultimately"], ["proof (chain)\npicking this:\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  < length ns\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma\n              (index key x (length ns) mi ma)))\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma)) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)))\n  \\<le> ns ! index key x (length ns) mi ma\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma\n            (index key x (length ns) mi ma)))", "show \"offs_none ?ns' ub xs index key mi ma (ns ! ?i)\""], ["proof (prove)\nusing this:\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma))\n  < length ns\n  0 < offs_num (length ns) xs index key mi ma\n       (Max (offs_set_prev ns (x # xs) index key mi ma\n              (index key x (length ns) mi ma)))\n  ns[index key x (length ns) mi ma :=\n       Suc (ns ! index key x (length ns) mi ma)] !\n  Max (offs_set_prev ns (x # xs) index key mi ma\n        (index key x (length ns) mi ma)) +\n  offs_num (length ns) xs index key mi ma\n   (Max (offs_set_prev ns (x # xs) index key mi ma\n          (index key x (length ns) mi ma)))\n  \\<le> ns ! index key x (length ns) mi ma\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma\n     (Max (offs_set_prev ns (x # xs) index key mi ma\n            (index key x (length ns) mi ma)))\n\ngoal (1 subgoal):\n 1. offs_none\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (ns ! index key x (length ns) mi ma)", "by (simp add: offs_none_def, blast)"], ["proof (state)\nthis:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (ns ! index key x (length ns) mi ma)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "assume \"0 < offs_num (length ns) xs index key mi ma 0\" and \"\\<not> 0 < ?i\""], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma 0\n  \\<not> 0 < index key x (length ns) mi ma\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "moreover"], ["proof (state)\nthis:\n  0 < offs_num (length ns) xs index key mi ma 0\n  \\<not> 0 < index key x (length ns) mi ma\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have \"?i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "using A and B and C"], ["proof (prove)\nusing this:\n  index_less index key\n  key x \\<in> {mi..ma}\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key x (length ns) mi ma < length ns\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)\n 2. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "ultimately"], ["proof (chain)\npicking this:\n  0 < offs_num (length ns) xs index key mi ma 0\n  \\<not> 0 < index key x (length ns) mi ma\n  index key x (length ns) mi ma < length ns", "show \"offs_none ?ns' ub xs index key mi ma (ns ! ?i)\""], ["proof (prove)\nusing this:\n  0 < offs_num (length ns) xs index key mi ma 0\n  \\<not> 0 < index key x (length ns) mi ma\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_none\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (ns ! index key x (length ns) mi ma)", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (ns ! index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "assume\n    E: \"\\<not> 0 < ?i\" and\n    F: \"\\<not> 0 < offs_num (length ns) xs index key mi ma 0\""], ["proof (state)\nthis:\n  \\<not> 0 < index key x (length ns) mi ma\n  \\<not> 0 < offs_num (length ns) xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have G: \"?i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "using A and B and C"], ["proof (prove)\nusing this:\n  index_less index key\n  key x \\<in> {mi..ma}\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. index key x (length ns) mi ma < length ns", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have \"offs_num (length ns) xs index key mi ma 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0", "using F"], ["proof (prove)\nusing this:\n  \\<not> 0 < offs_num (length ns) xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_num (length ns) xs index key mi ma 0 = 0", "by simp"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "moreover"], ["proof (state)\nthis:\n  offs_num (length ns) xs index key mi ma 0 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "have \"offs_next ?ns' ub xs index key mi ma ?i =\n    offs_next ns ub (x # xs) index key mi ma ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (index key x (length ns) mi ma) =\n    offs_next ns ub (x # xs) index key mi ma (index key x (length ns) mi ma)", "using E and G"], ["proof (prove)\nusing this:\n  \\<not> 0 < index key x (length ns) mi ma\n  index key x (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (index key x (length ns) mi ma) =\n    offs_next ns ub (x # xs) index key mi ma (index key x (length ns) mi ma)", "by (rule_tac offs_next_cons_eq, simp_all add: offs_num_cons)"], ["proof (state)\nthis:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (index key x (length ns) mi ma) =\n  offs_next ns ub (x # xs) index key mi ma (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "hence \"ns ! ?i < offs_next ?ns' ub xs index key mi ma ?i\""], ["proof (prove)\nusing this:\n  offs_next\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (index key x (length ns) mi ma) =\n  offs_next ns ub (x # xs) index key mi ma (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma\n    < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma (index key x (length ns) mi ma)", "by (simp, rule_tac offs_pred_next [OF D G], simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "hence \"ns ! ?i < offs_next ?ns' ub xs index key mi ma 0\""], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (index key x (length ns) mi ma)\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma\n    < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0", "using E"], ["proof (prove)\nusing this:\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (index key x (length ns) mi ma)\n  \\<not> 0 < index key x (length ns) mi ma\n\ngoal (1 subgoal):\n 1. ns ! index key x (length ns) mi ma\n    < offs_next\n       (ns[index key x (length ns) mi ma :=\n             Suc (ns ! index key x (length ns) mi ma)])\n       ub xs index key mi ma 0", "by simp"], ["proof (state)\nthis:\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     mi \\<le> key x \\<and> key x \\<le> ma; index_less index key;\n     ns \\<noteq> []; offs_pred ns ub (x # xs) index key mi ma;\n     index_less index key; key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < index key x (length ns) mi ma; index_less index key;\n     key x \\<in> {mi..ma}; ns \\<noteq> [];\n     offs_pred ns ub (x # xs) index key mi ma;\n     \\<not> 0 < offs_num (length ns) xs index key mi ma 0\\<rbrakk>\n    \\<Longrightarrow> offs_none\n                       (ns[index key x (length ns) mi ma :=\n                             Suc (ns ! index key x (length ns) mi ma)])\n                       ub xs index key mi ma\n                       (ns ! index key x (length ns) mi ma)", "ultimately"], ["proof (chain)\npicking this:\n  offs_num (length ns) xs index key mi ma 0 = 0\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0", "show \"offs_none ?ns' ub xs index key mi ma (ns ! ?i)\""], ["proof (prove)\nusing this:\n  offs_num (length ns) xs index key mi ma 0 = 0\n  ns ! index key x (length ns) mi ma\n  < offs_next\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma 0\n\ngoal (1 subgoal):\n 1. offs_none\n     (ns[index key x (length ns) mi ma :=\n           Suc (ns ! index key x (length ns) mi ma)])\n     ub xs index key mi ma (ns ! index key x (length ns) mi ma)", "by (simp add: offs_none_def)"], ["proof (state)\nthis:\n  offs_none\n   (ns[index key x (length ns) mi ma :=\n         Suc (ns ! index key x (length ns) mi ma)])\n   ub xs index key mi ma (ns ! index key x (length ns) mi ma)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fill_count_item [rule_format]:\n  assumes A: \"index_less index key\"\n  shows\n   \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    length xs \\<le> ub \\<longrightarrow>\n      count (mset (map the (fill xs ns index key ub mi ma))) x =\n      count (mset xs) x + (if the None = x then ub - length xs else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    ns \\<noteq> [] \\<longrightarrow>\n    offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    length xs \\<le> ub \\<longrightarrow>\n    count (mset (map the (fill xs ns index key ub mi ma))) x =\n    count (mset xs) x + (if the None = x then ub - length xs else 0)", "proof (induction xs arbitrary: ns, simp add: replicate_count, (rule impI)+,\n simp add: Let_def map_update del: count_add_mset mset_map split del: if_split,\n (erule conjE)+, subst add_mset_add_single, simp only: count_single count_union)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "fix y xs and ns :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "let ?i = \"index key y (length ns) mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "let ?ns' = \"ns[?i := Suc (ns ! ?i)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "assume\n    B: \"\\<forall>x \\<in> set xs. mi \\<le> key x \\<and> key x \\<le> ma\" and\n    C: \"mi \\<le> key y\" and\n    D: \"key y \\<le> ma\" and\n    E: \"ns \\<noteq> []\" and\n    F: \"offs_pred ns ub (y # xs) index key mi ma\" and\n    G: \"Suc (length xs) \\<le> ub\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  mi \\<le> key y\n  key y \\<le> ma\n  ns \\<noteq> []\n  offs_pred ns ub (y # xs) index key mi ma\n  Suc (length xs) \\<le> ub\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "have H: \"?i < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index key y (length ns) mi ma < length ns", "using A and C and D and E"], ["proof (prove)\nusing this:\n  index_less index key\n  mi \\<le> key y\n  key y \\<le> ma\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. index key y (length ns) mi ma < length ns", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key y (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "assume \"\\<And>ns. ns \\<noteq> [] \\<longrightarrow> offs_pred ns ub xs index key mi ma \\<longrightarrow>\n    count (mset (map the (fill xs ns index key ub mi ma))) x =\n    count (mset xs) x + (if the None = x then ub - length xs else 0)\""], ["proof (state)\nthis:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  count (mset (map the (fill xs ?ns index key ub mi ma))) x =\n  count (mset xs) x + (if the None = x then ub - length xs else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "moreover"], ["proof (state)\nthis:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  count (mset (map the (fill xs ?ns index key ub mi ma))) x =\n  count (mset xs) x + (if the None = x then ub - length xs else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "have \"offs_pred ?ns' ub xs index key mi ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     ub xs index key mi ma", "using F and H"], ["proof (prove)\nusing this:\n  offs_pred ns ub (y # xs) index key mi ma\n  index key y (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. offs_pred\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     ub xs index key mi ma", "by (rule_tac offs_pred_cons, simp_all)"], ["proof (state)\nthis:\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "ultimately"], ["proof (chain)\npicking this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  count (mset (map the (fill xs ?ns index key ub mi ma))) x =\n  count (mset xs) x + (if the None = x then ub - length xs else 0)\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma", "have \"count (mset (map the (fill xs ?ns' index key ub mi ma))) x =\n    count (mset xs) x + (if the None = x then ub - length xs else 0)\""], ["proof (prove)\nusing this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  count (mset (map the (fill xs ?ns index key ub mi ma))) x =\n  count (mset xs) x + (if the None = x then ub - length xs else 0)\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill xs\n           (ns[index key y (length ns) mi ma :=\n                 Suc (ns ! index key y (length ns) mi ma)])\n           index key ub mi ma)))\n     x =\n    count (mset xs) x + (if the None = x then ub - length xs else 0)", "using E"], ["proof (prove)\nusing this:\n  ?ns \\<noteq> [] \\<longrightarrow>\n  offs_pred ?ns ub xs index key mi ma \\<longrightarrow>\n  count (mset (map the (fill xs ?ns index key ub mi ma))) x =\n  count (mset xs) x + (if the None = x then ub - length xs else 0)\n  offs_pred\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   ub xs index key mi ma\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill xs\n           (ns[index key y (length ns) mi ma :=\n                 Suc (ns ! index key y (length ns) mi ma)])\n           index key ub mi ma)))\n     x =\n    count (mset xs) x + (if the None = x then ub - length xs else 0)", "by simp"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill xs\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         index key ub mi ma)))\n   x =\n  count (mset xs) x + (if the None = x then ub - length xs else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "moreover"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill xs\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         index key ub mi ma)))\n   x =\n  count (mset xs) x + (if the None = x then ub - length xs else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "have \"ns ! ?i + offs_num (length ns) (y # xs)\n    index key mi ma ?i \\<le> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! index key y (length ns) mi ma +\n    offs_num (length ns) (y # xs) index key mi ma\n     (index key y (length ns) mi ma)\n    \\<le> ub", "using F and H"], ["proof (prove)\nusing this:\n  offs_pred ns ub (y # xs) index key mi ma\n  index key y (length ns) mi ma < length ns\n\ngoal (1 subgoal):\n 1. ns ! index key y (length ns) mi ma +\n    offs_num (length ns) (y # xs) index key mi ma\n     (index key y (length ns) mi ma)\n    \\<le> ub", "by (rule offs_pred_ub, simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key y (length ns) mi ma +\n  offs_num (length ns) (y # xs) index key mi ma\n   (index key y (length ns) mi ma)\n  \\<le> ub\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "hence \"ns ! ?i < ub\""], ["proof (prove)\nusing this:\n  ns ! index key y (length ns) mi ma +\n  offs_num (length ns) (y # xs) index key mi ma\n   (index key y (length ns) mi ma)\n  \\<le> ub\n\ngoal (1 subgoal):\n 1. ns ! index key y (length ns) mi ma < ub", "by (simp add: offs_num_cons)"], ["proof (state)\nthis:\n  ns ! index key y (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. \\<And>a xs ns.\n       \\<lbrakk>\\<And>ns.\n                   ns \\<noteq> [] \\<longrightarrow>\n                   offs_pred ns ub xs index key mi ma \\<longrightarrow>\n                   count (mset (map the (fill xs ns index key ub mi ma)))\n                    x =\n                   count (mset xs) x +\n                   (if the None = x then ub - length xs else 0);\n        ns \\<noteq> []; offs_pred ns ub (a # xs) index key mi ma;\n        Suc (length xs) \\<le> ub; mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> count\n                          (mset\n                            ((map the\n                               (fill xs\n                                 (ns[index key a (length ns) mi ma :=\n Suc (ns ! index key a (length ns) mi ma)])\n                                 index key ub mi ma))\n                             [ns ! index key a (length ns) mi ma := a]))\n                          x =\n                         count (mset xs) x + (if a = x then 1 else 0) +\n                         (if the None = x then ub - length (a # xs) else 0)", "ultimately"], ["proof (chain)\npicking this:\n  count\n   (mset\n     (map the\n       (fill xs\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         index key ub mi ma)))\n   x =\n  count (mset xs) x + (if the None = x then ub - length xs else 0)\n  ns ! index key y (length ns) mi ma < ub", "show \"count (mset ((map the (fill xs ?ns' index key ub mi ma))\n    [ns ! ?i := y])) x = count (mset xs) x + (if y = x then 1 else 0) +\n    (if the None = x then ub - length (y # xs) else 0)\""], ["proof (prove)\nusing this:\n  count\n   (mset\n     (map the\n       (fill xs\n         (ns[index key y (length ns) mi ma :=\n               Suc (ns ! index key y (length ns) mi ma)])\n         index key ub mi ma)))\n   x =\n  count (mset xs) x + (if the None = x then ub - length xs else 0)\n  ns ! index key y (length ns) mi ma < ub\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       ((map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma))\n        [ns ! index key y (length ns) mi ma := y]))\n     x =\n    count (mset xs) x + (if y = x then 1 else 0) +\n    (if the None = x then ub - length (y # xs) else 0)", "proof (subst mset_update, simp add: fill_length, subst add_mset_add_single, simp\n   only: count_diff count_single count_union, subst nth_map, simp add: fill_length,\n   subst add.assoc, subst (3) add.commute, subst add.assoc [symmetric],\n   subst add_right_cancel)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset xs) x +\n             (if the None = x then ub - length xs else 0) =\n             count (mset xs) x +\n             (if the None = x then ub - length xs else 0);\n     True; True; True;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> count (mset xs) x +\n                      (if the None = x then ub - length xs else 0) -\n                      (if the (fill xs\n                                (ns[index key y (length ns) mi ma :=\nSuc (ns ! index key y (length ns) mi ma)])\n                                index key ub mi ma !\n                               (ns ! index key y (length ns) mi ma)) =\n                          x\n                       then 1 else 0) =\n                      count (mset xs) x +\n                      (if the None = x then ub - length (y # xs) else 0)", "have \"fill xs ?ns' index key ub mi ma ! (ns ! ?i) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key y (length ns) mi ma) =\n    None", "using B and C and D and E"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  mi \\<le> key y\n  key y \\<le> ma\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. fill xs\n     (ns[index key y (length ns) mi ma :=\n           Suc (ns ! index key y (length ns) mi ma)])\n     index key ub mi ma !\n    (ns ! index key y (length ns) mi ma) =\n    None", "by (rule_tac fill_index_none [OF A _ _ F],\n       simp_all)"], ["proof (state)\nthis:\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key y (length ns) mi ma) =\n  None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset xs) x +\n             (if the None = x then ub - length xs else 0) =\n             count (mset xs) x +\n             (if the None = x then ub - length xs else 0);\n     True; True; True;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub;\n     count\n      (mset\n        (map the\n          (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma)))\n      x =\n     count (mset xs) x + (if the None = x then ub - length xs else 0);\n     ns ! index key y (length ns) mi ma < ub\\<rbrakk>\n    \\<Longrightarrow> count (mset xs) x +\n                      (if the None = x then ub - length xs else 0) -\n                      (if the (fill xs\n                                (ns[index key y (length ns) mi ma :=\nSuc (ns ! index key y (length ns) mi ma)])\n                                index key ub mi ma !\n                               (ns ! index key y (length ns) mi ma)) =\n                          x\n                       then 1 else 0) =\n                      count (mset xs) x +\n                      (if the None = x then ub - length (y # xs) else 0)", "thus \"count (mset xs) x + (if the None = x then ub - length xs else 0) -\n      (if the (fill xs ?ns' index key ub mi ma ! (ns ! ?i)) = x then 1 else 0) =\n      count (mset xs) x + (if the None = x then ub - length (y # xs) else 0)\""], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key y (length ns) mi ma) =\n  None\n\ngoal (1 subgoal):\n 1. count (mset xs) x + (if the None = x then ub - length xs else 0) -\n    (if the (fill xs\n              (ns[index key y (length ns) mi ma :=\n                    Suc (ns ! index key y (length ns) mi ma)])\n              index key ub mi ma !\n             (ns ! index key y (length ns) mi ma)) =\n        x\n     then 1 else 0) =\n    count (mset xs) x + (if the None = x then ub - length (y # xs) else 0)", "using G"], ["proof (prove)\nusing this:\n  fill xs\n   (ns[index key y (length ns) mi ma :=\n         Suc (ns ! index key y (length ns) mi ma)])\n   index key ub mi ma !\n  (ns ! index key y (length ns) mi ma) =\n  None\n  Suc (length xs) \\<le> ub\n\ngoal (1 subgoal):\n 1. count (mset xs) x + (if the None = x then ub - length xs else 0) -\n    (if the (fill xs\n              (ns[index key y (length ns) mi ma :=\n                    Suc (ns ! index key y (length ns) mi ma)])\n              index key ub mi ma !\n             (ns ! index key y (length ns) mi ma)) =\n        x\n     then 1 else 0) =\n    count (mset xs) x + (if the None = x then ub - length (y # xs) else 0)", "by simp"], ["proof (state)\nthis:\n  count (mset xs) x + (if the None = x then ub - length xs else 0) -\n  (if the (fill xs\n            (ns[index key y (length ns) mi ma :=\n                  Suc (ns ! index key y (length ns) mi ma)])\n            index key ub mi ma !\n           (ns ! index key y (length ns) mi ma)) =\n      x\n   then 1 else 0) =\n  count (mset xs) x + (if the None = x then ub - length (y # xs) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count\n   (mset\n     ((map the\n        (fill xs\n          (ns[index key y (length ns) mi ma :=\n                Suc (ns ! index key y (length ns) mi ma)])\n          index key ub mi ma))\n      [ns ! index key y (length ns) mi ma := y]))\n   x =\n  count (mset xs) x + (if y = x then 1 else 0) +\n  (if the None = x then ub - length (y # xs) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nFinally, lemma @{text offs_enum_pred} here below proves that, if $ns$ is the offsets' list obtained\nby applying the composition of functions @{const offs} and @{const enum} to objects' list $xs$, then\npredicate @{const offs_pred} is satisfied by $ns$ and $xs$.\n\nThis result is in turn used, together with lemma @{thm [source] fill_count_item}, to prove lemma\n@{text fill_offs_enum_count_item}, which states that function @{const fill} conserves objects if its\ninput offsets' list is computed via the composition of functions @{const offs} and @{const enum}.\n\n\\null\n\\<close>"], ["", "lemma enum_offs_num:\n \"i < n \\<Longrightarrow> enum xs index key n mi ma ! i = offs_num n xs index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    enum xs index key n mi ma ! i = offs_num n xs index key mi ma i", "by (induction xs, simp add: offs_num_def, simp add: Let_def offs_num_cons,\n subst nth_list_update_eq, simp_all add: enum_length)"], ["", "lemma offs_length:\n \"length (offs ns i) = length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (offs ns i) = length ns", "by (induction ns arbitrary: i, simp_all)"], ["", "lemma offs_add [rule_format]:\n \"i < length ns \\<longrightarrow> offs ns k ! i = foldl (+) k (take i ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ns \\<longrightarrow> offs ns k ! i = foldl (+) k (take i ns)", "by (induction ns arbitrary: i k, simp, simp add: nth_Cons split: nat.split)"], ["", "lemma offs_mono_aux:\n \"i \\<le> j \\<Longrightarrow> j < length ns \\<Longrightarrow> offs ns k ! i \\<le> offs ns k ! (i + (j - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j < length ns\\<rbrakk>\n    \\<Longrightarrow> offs ns k ! i \\<le> offs ns k ! (i + (j - i))", "by (simp only: offs_add take_add, simp add: add_le)"], ["", "lemma offs_mono:\n \"i \\<le> j \\<Longrightarrow> j < length ns \\<Longrightarrow> offs ns k ! i \\<le> offs ns k ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j < length ns\\<rbrakk>\n    \\<Longrightarrow> offs ns k ! i \\<le> offs ns k ! j", "by (frule offs_mono_aux, simp_all)"], ["", "lemma offs_update:\n \"j < length ns \\<Longrightarrow>\n    offs (ns[i := Suc (ns ! i)]) k ! j = (if j \\<le> i then id else Suc) (offs ns k ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length ns \\<Longrightarrow>\n    offs (ns[i := Suc (ns ! i)]) k ! j =\n    (if j \\<le> i then id else Suc) (offs ns k ! j)", "by (simp add: offs_add not_le take_update_swap, rule impI, subst nth_take [symmetric],\n assumption, subst add_update, simp_all)"], ["", "lemma offs_equal_suc:\n  assumes\n    A: \"Suc i < length ns\" and\n    B: \"ns ! i = 0\"\n  shows \"offs ns m ! i = offs ns m ! Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "have \"offs ns m ! i = foldl (+) m (take i ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs ns m ! i = foldl (+) m (take i ns)", "using A"], ["proof (prove)\nusing this:\n  Suc i < length ns\n\ngoal (1 subgoal):\n 1. offs ns m ! i = foldl (+) m (take i ns)", "by (subst offs_add, simp_all)"], ["proof (state)\nthis:\n  offs ns m ! i = foldl (+) m (take i ns)\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "also"], ["proof (state)\nthis:\n  offs ns m ! i = foldl (+) m (take i ns)\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "have \"\\<dots> = foldl (+) m (take i ns @ [ns ! i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) m (take i ns) = foldl (+) m (take i ns @ [ns ! i])", "using B"], ["proof (prove)\nusing this:\n  ns ! i = 0\n\ngoal (1 subgoal):\n 1. foldl (+) m (take i ns) = foldl (+) m (take i ns @ [ns ! i])", "by simp"], ["proof (state)\nthis:\n  foldl (+) m (take i ns) = foldl (+) m (take i ns @ [ns ! i])\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "also"], ["proof (state)\nthis:\n  foldl (+) m (take i ns) = foldl (+) m (take i ns @ [ns ! i])\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "have \"\\<dots> = foldl (+) m (take (Suc i) ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) m (take i ns @ [ns ! i]) = foldl (+) m (take (Suc i) ns)", "using A"], ["proof (prove)\nusing this:\n  Suc i < length ns\n\ngoal (1 subgoal):\n 1. foldl (+) m (take i ns @ [ns ! i]) = foldl (+) m (take (Suc i) ns)", "by (subst take_Suc_conv_app_nth, simp_all)"], ["proof (state)\nthis:\n  foldl (+) m (take i ns @ [ns ! i]) = foldl (+) m (take (Suc i) ns)\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "also"], ["proof (state)\nthis:\n  foldl (+) m (take i ns @ [ns ! i]) = foldl (+) m (take (Suc i) ns)\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "have \"\\<dots> = offs ns m ! Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) m (take (Suc i) ns) = offs ns m ! Suc i", "using A"], ["proof (prove)\nusing this:\n  Suc i < length ns\n\ngoal (1 subgoal):\n 1. foldl (+) m (take (Suc i) ns) = offs ns m ! Suc i", "by (subst offs_add, simp_all)"], ["proof (state)\nthis:\n  foldl (+) m (take (Suc i) ns) = offs ns m ! Suc i\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "finally"], ["proof (chain)\npicking this:\n  offs ns m ! i = offs ns m ! Suc i", "show ?thesis"], ["proof (prove)\nusing this:\n  offs ns m ! i = offs ns m ! Suc i\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "."], ["proof (state)\nthis:\n  offs ns m ! i = offs ns m ! Suc i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_equal [rule_format]:\n \"i < j \\<Longrightarrow> j < length ns \\<Longrightarrow>\n    (\\<forall>k \\<in> {i..<j}. ns ! k = 0) \\<longrightarrow> offs ns m ! i = offs ns m ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < length ns\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>k\\<in>{i..<j}. ns ! k = 0) \\<longrightarrow>\n                      offs ns m ! i = offs ns m ! j", "proof (erule strict_inc_induct, rule_tac [!] impI, simp_all, erule offs_equal_suc, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "assume A: \"i < j\" and \"j < length ns\""], ["proof (state)\nthis:\n  i < j\n  j < length ns\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "hence \"Suc i < length ns\""], ["proof (prove)\nusing this:\n  i < j\n  j < length ns\n\ngoal (1 subgoal):\n 1. Suc i < length ns", "by simp"], ["proof (state)\nthis:\n  Suc i < length ns\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "moreover"], ["proof (state)\nthis:\n  Suc i < length ns\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "assume \"\\<forall>k \\<in> {i..<j}. ns ! k = 0\""], ["proof (state)\nthis:\n  \\<forall>k\\<in>{i..<j}. ns ! k = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "hence \"ns ! i = 0\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{i..<j}. ns ! k = 0\n\ngoal (1 subgoal):\n 1. ns ! i = 0", "using A"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{i..<j}. ns ! k = 0\n  i < j\n\ngoal (1 subgoal):\n 1. ns ! i = 0", "by simp"], ["proof (state)\nthis:\n  ns ! i = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "ultimately"], ["proof (chain)\npicking this:\n  Suc i < length ns\n  ns ! i = 0", "have \"offs ns m ! i = offs ns m ! Suc i\""], ["proof (prove)\nusing this:\n  Suc i < length ns\n  ns ! i = 0\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! Suc i", "by (rule offs_equal_suc)"], ["proof (state)\nthis:\n  offs ns m ! i = offs ns m ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "also"], ["proof (state)\nthis:\n  offs ns m ! i = offs ns m ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "assume \"\\<dots> = offs ns m ! j\""], ["proof (state)\nthis:\n  offs ns m ! Suc i = offs ns m ! j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>j < length ns; i < j; offs ns m ! Suc i = offs ns m ! j;\n        \\<forall>k\\<in>{i..<j}. ns ! k = 0\\<rbrakk>\n       \\<Longrightarrow> offs ns m ! i = offs ns m ! j", "finally"], ["proof (chain)\npicking this:\n  offs ns m ! i = offs ns m ! j", "show \"offs ns m ! i = offs ns m ! j\""], ["proof (prove)\nusing this:\n  offs ns m ! i = offs ns m ! j\n\ngoal (1 subgoal):\n 1. offs ns m ! i = offs ns m ! j", "."], ["proof (state)\nthis:\n  offs ns m ! i = offs ns m ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_enum_last [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"0 < n\" and\n    C: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) = length xs + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "let ?ns = \"enum xs index key n mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "from B"], ["proof (chain)\npicking this:\n  0 < n", "have D: \"last ?ns = offs_num n xs index key mi ma (n - Suc 0)\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. last (enum xs index key n mi ma) =\n    offs_num n xs index key mi ma (n - Suc 0)", "by (subst last_conv_nth, subst length_0_conv [symmetric], simp_all add:\n     enum_length, subst enum_offs_num, simp_all)"], ["proof (state)\nthis:\n  last (enum xs index key n mi ma) =\n  offs_num n xs index key mi ma (n - Suc 0)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "have \"offs ?ns k ! (n - Suc 0) = foldl (+) k (take (n - Suc 0) ?ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n    foldl (+) k (take (n - Suc 0) (enum xs index key n mi ma))", "using B"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n    foldl (+) k (take (n - Suc 0) (enum xs index key n mi ma))", "by (rule_tac offs_add, simp add: enum_length)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n  foldl (+) k (take (n - Suc 0) (enum xs index key n mi ma))\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "also"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n  foldl (+) k (take (n - Suc 0) (enum xs index key n mi ma))\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "have \"\\<dots> = foldl (+) k (butlast ?ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) k (take (n - Suc 0) (enum xs index key n mi ma)) =\n    foldl (+) k (butlast (enum xs index key n mi ma))", "by (simp add: butlast_conv_take enum_length)"], ["proof (state)\nthis:\n  foldl (+) k (take (n - Suc 0) (enum xs index key n mi ma)) =\n  foldl (+) k (butlast (enum xs index key n mi ma))\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "finally"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n  foldl (+) k (butlast (enum xs index key n mi ma))", "have \"offs ?ns k ! (n - Suc 0) + offs_num n xs index key mi ma\n    (n - Suc 0) = foldl (+) k (butlast ?ns @ [last ?ns])\""], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n  foldl (+) k (butlast (enum xs index key n mi ma))\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    foldl (+) k\n     (butlast (enum xs index key n mi ma) @\n      [last (enum xs index key n mi ma)])", "using D"], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n  foldl (+) k (butlast (enum xs index key n mi ma))\n  last (enum xs index key n mi ma) =\n  offs_num n xs index key mi ma (n - Suc 0)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    foldl (+) k\n     (butlast (enum xs index key n mi ma) @\n      [last (enum xs index key n mi ma)])", "by simp"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n  offs_num n xs index key mi ma (n - Suc 0) =\n  foldl (+) k\n   (butlast (enum xs index key n mi ma) @\n    [last (enum xs index key n mi ma)])\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "also"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n  offs_num n xs index key mi ma (n - Suc 0) =\n  foldl (+) k\n   (butlast (enum xs index key n mi ma) @\n    [last (enum xs index key n mi ma)])\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "have \"\\<dots> = foldl (+) k ?ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) k\n     (butlast (enum xs index key n mi ma) @\n      [last (enum xs index key n mi ma)]) =\n    foldl (+) k (enum xs index key n mi ma)", "using B"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. foldl (+) k\n     (butlast (enum xs index key n mi ma) @\n      [last (enum xs index key n mi ma)]) =\n    foldl (+) k (enum xs index key n mi ma)", "by (subst append_butlast_last_id, subst length_0_conv [symmetric],\n     simp_all add: enum_length)"], ["proof (state)\nthis:\n  foldl (+) k\n   (butlast (enum xs index key n mi ma) @\n    [last (enum xs index key n mi ma)]) =\n  foldl (+) k (enum xs index key n mi ma)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "also"], ["proof (state)\nthis:\n  foldl (+) k\n   (butlast (enum xs index key n mi ma) @\n    [last (enum xs index key n mi ma)]) =\n  foldl (+) k (enum xs index key n mi ma)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "have \"\\<dots> = foldl (+) 0 ?ns + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) k (enum xs index key n mi ma) =\n    foldl (+) 0 (enum xs index key n mi ma) + k", "by (rule add_base_zero)"], ["proof (state)\nthis:\n  foldl (+) k (enum xs index key n mi ma) =\n  foldl (+) 0 (enum xs index key n mi ma) + k\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "also"], ["proof (state)\nthis:\n  foldl (+) k (enum xs index key n mi ma) =\n  foldl (+) 0 (enum xs index key n mi ma) + k\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "have \"\\<dots> = length xs + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) 0 (enum xs index key n mi ma) + k = length xs + k", "using A and B and C"], ["proof (prove)\nusing this:\n  index_less index key\n  0 < n\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n\ngoal (1 subgoal):\n 1. foldl (+) 0 (enum xs index key n mi ma) + k = length xs + k", "by (subst enum_add, simp_all)"], ["proof (state)\nthis:\n  foldl (+) 0 (enum xs index key n mi ma) + k = length xs + k\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "finally"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n  offs_num n xs index key mi ma (n - Suc 0) =\n  length xs + k", "show ?thesis"], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n  offs_num n xs index key mi ma (n - Suc 0) =\n  length xs + k\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "."], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n  offs_num n xs index key mi ma (n - Suc 0) =\n  length xs + k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_enum_ub [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"i < n\" and\n    C: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"offs (enum xs index key n mi ma) k ! i \\<le> length xs + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "let ?ns = \"enum xs index key n mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "have \"offs ?ns k ! i \\<le> offs ?ns k ! (n - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i\n    \\<le> offs (enum xs index key n mi ma) k ! (n - Suc 0)", "using B"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i\n    \\<le> offs (enum xs index key n mi ma) k ! (n - Suc 0)", "by (rule_tac offs_mono, simp_all add: enum_length)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! i\n  \\<le> offs (enum xs index key n mi ma) k ! (n - Suc 0)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "also"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! i\n  \\<le> offs (enum xs index key n mi ma) k ! (n - Suc 0)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "have \"\\<dots> \\<le> offs ?ns k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0)\n    \\<le> offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n          offs_num n xs index key mi ma (n - Suc 0)", "by simp"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0)\n  \\<le> offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n        offs_num n xs index key mi ma (n - Suc 0)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "also"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0)\n  \\<le> offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n        offs_num n xs index key mi ma (n - Suc 0)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "have \"\\<dots> = length xs + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "using A and B and C"], ["proof (prove)\nusing this:\n  index_less index key\n  i < n\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n    offs_num n xs index key mi ma (n - Suc 0) =\n    length xs + k", "by (rule_tac offs_enum_last, simp_all)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) +\n  offs_num n xs index key mi ma (n - Suc 0) =\n  length xs + k\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "finally"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "show ?thesis"], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k ! i \\<le> length xs + k\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i \\<le> length xs + k", "."], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! i \\<le> length xs + k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_enum_next_ge [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"i < n\"\n  shows \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i \\<le>\n      offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n        xs index key mi ma i\"\n  (is \"_ \\<Longrightarrow> offs ?ns _ ! _ \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. key x \\<in> {mi..ma} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i\n    \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n           index key mi ma i", "proof (simp only: offs_next_def split: if_split, rule conjI, rule_tac [!] impI,\n rule offs_enum_ub [OF A B], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      i \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma i)", "assume \"offs_set_next (offs ?ns k) xs index key mi ma i \\<noteq> {}\"\n    (is \"?A \\<noteq> _\")"], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      i \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma i)", "hence C: \"Min ?A \\<in> ?A\""], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      i \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma i)", "hence \"i \\<le> Min ?A\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. i \\<le> Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i)", "by simp"], ["proof (state)\nthis:\n  i \\<le> Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      i \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma i)", "moreover"], ["proof (state)\nthis:\n  i \\<le> Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      i \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma i)", "have \"Min ?A < length ?ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    < length (enum xs index key n mi ma)", "using C"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    < length (enum xs index key n mi ma)", "by (simp add: offs_length)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < length (enum xs index key n mi ma)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      i \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma i)", "ultimately"], ["proof (chain)\npicking this:\n  i \\<le> Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                key mi ma i)\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < length (enum xs index key n mi ma)", "show \"offs ?ns k ! i \\<le> offs ?ns k ! Min ?A\""], ["proof (prove)\nusing this:\n  i \\<le> Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                key mi ma i)\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < length (enum xs index key n mi ma)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                key mi ma i)", "by (rule offs_mono)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! i\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_enum_zero_aux [rule_format]:\n \"\\<lbrakk>index_less index key; 0 < n; \\<forall>x \\<in> set xs. key x \\<in> {mi..ma};\n   offs_num n xs index key mi ma (n - Suc 0) = 0\\<rbrakk> \\<Longrightarrow>\n     offs (enum xs index key n mi ma) k ! (n - Suc 0) = length xs + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key; 0 < n;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     offs_num n xs index key mi ma (n - Suc 0) = 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n                      length xs + k", "by (subst offs_enum_last [where key = key and mi = mi and ma = ma,\n symmetric], simp+)"], ["", "lemma offs_enum_zero [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"i < n\" and\n    C: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\" and\n    D: \"offs_num n xs index key mi ma i = 0\"\n  shows \"offs (enum xs index key n mi ma) k ! i =\n    offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n      xs index key mi ma i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i =\n    offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i", "proof (simp only: offs_next_def split: if_split, rule conjI, rule_tac [!] impI,\n cases \"i = n - Suc 0\", simp)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x>n - Suc 0.\n                x < length\n                     (offs (enum xs index key n mi ma) k) \\<longrightarrow>\n                offs_num (length (offs (enum xs index key n mi ma) k)) xs\n                 index key mi ma x =\n                0;\n     i = n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n                      length xs + k\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 3. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "assume \"i = n - Suc 0\""], ["proof (state)\nthis:\n  i = n - Suc 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x>n - Suc 0.\n                x < length\n                     (offs (enum xs index key n mi ma) k) \\<longrightarrow>\n                offs_num (length (offs (enum xs index key n mi ma) k)) xs\n                 index key mi ma x =\n                0;\n     i = n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! (n - Suc 0) =\n                      length xs + k\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 3. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "thus \"offs (enum xs index key n mi ma) k ! (n - Suc 0) = length xs + k\""], ["proof (prove)\nusing this:\n  i = n - Suc 0\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) = length xs + k", "using A and B and C and D"], ["proof (prove)\nusing this:\n  i = n - Suc 0\n  index_less index key\n  i < n\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  offs_num n xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) = length xs + k", "by (rule_tac offs_enum_zero_aux, simp_all)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) = length xs + k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 2. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 2. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "let ?ns = \"enum xs index key n mi ma\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 2. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "assume E: \"offs_set_next (offs ?ns k) xs index key mi ma i = {}\"\n    (is \"?A = _\")"], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 2. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "assume \"i \\<noteq> n - Suc 0\""], ["proof (state)\nthis:\n  i \\<noteq> n - Suc 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 2. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "hence F: \"i < n - Suc 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> n - Suc 0\n\ngoal (1 subgoal):\n 1. i < n - Suc 0", "using B"], ["proof (prove)\nusing this:\n  i \\<noteq> n - Suc 0\n  i < n\n\ngoal (1 subgoal):\n 1. i < n - Suc 0", "by simp"], ["proof (state)\nthis:\n  i < n - Suc 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 2. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "hence \"offs ?ns k ! i = offs ?ns k ! (n - Suc 0)\""], ["proof (prove)\nusing this:\n  i < n - Suc 0\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k ! (n - Suc 0)", "proof (rule offs_equal, simp_all add: enum_length le_less,\n   erule_tac conjE, erule_tac disjE, rule_tac ccontr, drule_tac [2] sym, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "assume G: \"j < n - Suc 0\""], ["proof (state)\nthis:\n  j < n - Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "hence \"j < length (offs ?ns k)\""], ["proof (prove)\nusing this:\n  j < n - Suc 0\n\ngoal (1 subgoal):\n 1. j < length (offs (enum xs index key n mi ma) k)", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  j < length (offs (enum xs index key n mi ma) k)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "moreover"], ["proof (state)\nthis:\n  j < length (offs (enum xs index key n mi ma) k)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "moreover"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "assume \"0 < ?ns ! j\""], ["proof (state)\nthis:\n  0 < enum xs index key n mi ma ! j\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "hence \"0 < offs_num (length (offs ?ns k)) xs index key mi ma j\""], ["proof (prove)\nusing this:\n  0 < enum xs index key n mi ma ! j\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key\n         mi ma j", "using G"], ["proof (prove)\nusing this:\n  0 < enum xs index key n mi ma ! j\n  j < n - Suc 0\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key\n         mi ma j", "by (subst (asm) enum_offs_num, simp_all add:\n       offs_length enum_length)"], ["proof (state)\nthis:\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "ultimately"], ["proof (chain)\npicking this:\n  j < length (offs (enum xs index key n mi ma) k)\n  i < j\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j", "have \"j \\<in> ?A\""], ["proof (prove)\nusing this:\n  j < length (offs (enum xs index key n mi ma) k)\n  i < j\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n             mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < n - Suc 0; i < k;\n        0 < enum xs index key n mi ma ! k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "thus False"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. False", "using E"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < n - Suc 0 \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "show \"?ns ! i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum xs index key n mi ma ! i = 0", "using B and D"], ["proof (prove)\nusing this:\n  i < n\n  offs_num n xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. enum xs index key n mi ma ! i = 0", "by (subst enum_offs_num, simp_all)"], ["proof (state)\nthis:\n  enum xs index key n mi ma ! i = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! i =\n  offs (enum xs index key n mi ma) k ! (n - Suc 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 2. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "also"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! i =\n  offs (enum xs index key n mi ma) k ! (n - Suc 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 2. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "from A and B and C"], ["proof (chain)\npicking this:\n  index_less index key\n  i < n\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}", "have \"\\<dots> = length xs + k\""], ["proof (prove)\nusing this:\n  index_less index key\n  i < n\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! (n - Suc 0) = length xs + k", "proof (rule_tac offs_enum_zero_aux, simp_all, rule_tac ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < offs_num n xs index key mi ma (n - Suc 0); index_less index key;\n     i < n\\<rbrakk>\n    \\<Longrightarrow> False", "have \"n - Suc 0 < length (offs ?ns k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc 0 < length (offs (enum xs index key n mi ma) k)", "using B"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. n - Suc 0 < length (offs (enum xs index key n mi ma) k)", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  n - Suc 0 < length (offs (enum xs index key n mi ma) k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < offs_num n xs index key mi ma (n - Suc 0); index_less index key;\n     i < n\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n - Suc 0 < length (offs (enum xs index key n mi ma) k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < offs_num n xs index key mi ma (n - Suc 0); index_less index key;\n     i < n\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"0 < offs_num n xs index key mi ma (n - Suc 0)\""], ["proof (state)\nthis:\n  0 < offs_num n xs index key mi ma (n - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < offs_num n xs index key mi ma (n - Suc 0); index_less index key;\n     i < n\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"0 < offs_num (length (offs ?ns k)) xs index key mi ma (n - Suc 0)\""], ["proof (prove)\nusing this:\n  0 < offs_num n xs index key mi ma (n - Suc 0)\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key\n         mi ma (n - Suc 0)", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma (n - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < offs_num n xs index key mi ma (n - Suc 0); index_less index key;\n     i < n\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  n - Suc 0 < length (offs (enum xs index key n mi ma) k)\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma (n - Suc 0)", "have \"n - Suc 0 \\<in> ?A\""], ["proof (prove)\nusing this:\n  n - Suc 0 < length (offs (enum xs index key n mi ma) k)\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma (n - Suc 0)\n\ngoal (1 subgoal):\n 1. n - Suc 0\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "using F"], ["proof (prove)\nusing this:\n  n - Suc 0 < length (offs (enum xs index key n mi ma) k)\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma (n - Suc 0)\n  i < n - Suc 0\n\ngoal (1 subgoal):\n 1. n - Suc 0\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "by simp"], ["proof (state)\nthis:\n  n - Suc 0\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < offs_num n xs index key mi ma (n - Suc 0); index_less index key;\n     i < n\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  n - Suc 0\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. False", "using E"], ["proof (prove)\nusing this:\n  n - Suc 0\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! (n - Suc 0) = length xs + k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     i \\<noteq> n - Suc 0\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k ! i = length xs + k\n 2. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "finally"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) k ! i = length xs + k", "show \"offs (enum xs index key n mi ma) k ! i = length xs + k\""], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k ! i = length xs + k\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i = length xs + k", "."], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! i = length xs + k\n\ngoal (1 subgoal):\n 1. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "let ?ns = \"enum xs index key n mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "assume \"offs_set_next (offs ?ns k) xs index key mi ma i \\<noteq> {}\"\n    (is \"?A \\<noteq> _\")"], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "hence \"Min ?A \\<in> ?A\""], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n     i \\<noteq>\n    {} \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "thus \"offs ?ns k ! i = offs ?ns k ! Min ?A\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k ! i =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)", "proof (rule_tac offs_equal, simp_all add: le_less, simp add: offs_length,\n   (erule_tac conjE)+, erule_tac disjE, rule_tac ccontr, drule_tac [2] sym, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "assume E: \"j < Min ?A\" and \"Min ?A < length (offs ?ns k)\""], ["proof (state)\nthis:\n  j < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n            mi ma i)\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < length (offs (enum xs index key n mi ma) k)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "hence F: \"j < length (offs ?ns k)\""], ["proof (prove)\nusing this:\n  j < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n            mi ma i)\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < length (offs (enum xs index key n mi ma) k)\n\ngoal (1 subgoal):\n 1. j < length (offs (enum xs index key n mi ma) k)", "by simp"], ["proof (state)\nthis:\n  j < length (offs (enum xs index key n mi ma) k)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "moreover"], ["proof (state)\nthis:\n  j < length (offs (enum xs index key n mi ma) k)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "moreover"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "assume \"0 < ?ns ! j\""], ["proof (state)\nthis:\n  0 < enum xs index key n mi ma ! j\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "hence \"0 < offs_num (length (offs ?ns k)) xs index key mi ma j\""], ["proof (prove)\nusing this:\n  0 < enum xs index key n mi ma ! j\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key\n         mi ma j", "using F"], ["proof (prove)\nusing this:\n  0 < enum xs index key n mi ma ! j\n  j < length (offs (enum xs index key n mi ma) k)\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key\n         mi ma j", "by (subst (asm) enum_offs_num, simp_all add:\n       offs_length enum_length)"], ["proof (state)\nthis:\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "ultimately"], ["proof (chain)\npicking this:\n  j < length (offs (enum xs index key n mi ma) k)\n  i < j\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j", "have \"j \\<in> ?A\""], ["proof (prove)\nusing this:\n  j < length (offs (enum xs index key n mi ma) k)\n  i < j\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n             mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "hence \"Min ?A \\<le> j\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> j", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        ka < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                   index key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        i < ka; 0 < enum xs index key n mi ma ! ka\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "thus False"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> j\n\ngoal (1 subgoal):\n 1. False", "using E"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> j\n  j < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n            mi ma i)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                      index key mi ma i)\n                < length (offs (enum xs index key n mi ma) k);\n        i < Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                  key mi ma i);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma\n             (Min (offs_set_next (offs (enum xs index key n mi ma) k) xs\n                    index key mi ma i));\n        ka = i\\<rbrakk>\n       \\<Longrightarrow> enum xs index key n mi ma ! i = 0", "show \"?ns ! i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum xs index key n mi ma ! i = 0", "using B and D"], ["proof (prove)\nusing this:\n  i < n\n  offs_num n xs index key mi ma i = 0\n\ngoal (1 subgoal):\n 1. enum xs index key n mi ma ! i = 0", "by (subst enum_offs_num, simp_all)"], ["proof (state)\nthis:\n  enum xs index key n mi ma ! i = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k ! i =\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_enum_next_cons [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}\"\n  shows \"(if i < index key x n mi ma then (\\<le>) else (<))\n    (offs_next (offs (enum xs index key n mi ma) k)\n      (length xs + k) xs index key mi ma i)\n    (offs_next (offs ((enum xs index key n mi ma) [index key x n mi ma :=\n      Suc (enum xs index key n mi ma ! index key x n mi ma)]) k)\n      (Suc (length xs + k)) (x # xs) index key mi ma i)\"\n  (is \"(if i < ?i' then _ else _)\n    (offs_next (offs ?ns _) _ _ _ _ _ _ _)\n    (offs_next (offs ?ns' _) _ _ _ _ _ _ _)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < index key x n mi ma then (\\<le>) else (<))\n     (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i)\n     (offs_next\n       (offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k)\n       (Suc (length xs + k)) (x # xs) index key mi ma i)", "proof (simp_all only: offs_next_def not_less split: if_split, (rule conjI, rule impI)+,\n simp, simp, (rule_tac [!] impI, (rule_tac [!] conjI)?)+, rule_tac [2-3] FalseE,\n rule_tac [4] conjI, rule_tac [4-5] impI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "assume\n    C: \"offs_set_next (offs ?ns k) xs index key mi ma i = {}\"\n      (is \"?A = _\") and\n    D: \"offs_set_next (offs ?ns' k) (x # xs) index key mi ma i \\<noteq> {}\"\n      (is \"?A' \\<noteq> _\") and\n    E: \"i < ?i'\""], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}\n  i < index key x n mi ma\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "from C"], ["proof (chain)\npicking this:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}", "have F: \"\\<forall>j \\<noteq> ?i'. j \\<notin> ?A'\""], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j \\<noteq> index key x n mi ma \\<longrightarrow>\n       j \\<notin> offs_set_next\n                   (offs\n                     ((enum xs index key n mi ma)\n                      [index key x n mi ma :=\n                         Suc (enum xs index key n mi ma !\n                              index key x n mi ma)])\n                     k)\n                   (x # xs) index key mi ma i", "by (rule_tac allI, rule_tac impI, rule_tac notI, simp add: enum_length\n     offs_length offs_num_cons split: if_split_asm, (erule_tac conjE)+, simp)"], ["proof (state)\nthis:\n  \\<forall>j.\n     j \\<noteq> index key x n mi ma \\<longrightarrow>\n     j \\<notin> offs_set_next\n                 (offs\n                   ((enum xs index key n mi ma)\n                    [index key x n mi ma :=\n                       Suc (enum xs index key n mi ma !\n                            index key x n mi ma)])\n                   k)\n                 (x # xs) index key mi ma i\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "from D"], ["proof (chain)\npicking this:\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}", "have \"Min ?A' \\<in> ?A'\""], ["proof (prove)\nusing this:\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence G: \"Min ?A' < n\""], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    < n", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < n\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have H: \"Min ?A' = ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i) =\n    index key x n mi ma", "proof (rule Min_eqI, simp, rule eq_refl, erule contrapos_pp, insert F, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j \\<noteq> index key x n mi ma \\<longrightarrow>\n       j \\<notin> offs_set_next\n                   (offs\n                     ((enum xs index key n mi ma)\n                      [index key x n mi ma :=\n                         Suc (enum xs index key n mi ma !\n                              index key x n mi ma)])\n                     k)\n                   (x # xs) index key mi ma i \\<Longrightarrow>\n    index key x n mi ma\n    \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "have \"\\<exists>j. j \\<in> ?A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j \\<in> offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i", "using D"], ["proof (prove)\nusing this:\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j \\<in> offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i", "by blast"], ["proof (state)\nthis:\n  \\<exists>j.\n     j \\<in> offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j \\<noteq> index key x n mi ma \\<longrightarrow>\n       j \\<notin> offs_set_next\n                   (offs\n                     ((enum xs index key n mi ma)\n                      [index key x n mi ma :=\n                         Suc (enum xs index key n mi ma !\n                              index key x n mi ma)])\n                     k)\n                   (x # xs) index key mi ma i \\<Longrightarrow>\n    index key x n mi ma\n    \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "then"], ["proof (chain)\npicking this:\n  \\<exists>j.\n     j \\<in> offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i", "obtain j where \"j \\<in> ?A'\""], ["proof (prove)\nusing this:\n  \\<exists>j.\n     j \\<in> offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j \\<in> offs_set_next\n                 (offs\n                   ((enum xs index key n mi ma)\n                    [index key x n mi ma :=\n                       Suc (enum xs index key n mi ma !\n                            index key x n mi ma)])\n                   k)\n                 (x # xs) index key mi ma i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j \\<noteq> index key x n mi ma \\<longrightarrow>\n       j \\<notin> offs_set_next\n                   (offs\n                     ((enum xs index key n mi ma)\n                      [index key x n mi ma :=\n                         Suc (enum xs index key n mi ma !\n                              index key x n mi ma)])\n                     k)\n                   (x # xs) index key mi ma i \\<Longrightarrow>\n    index key x n mi ma\n    \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "moreover"], ["proof (state)\nthis:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j \\<noteq> index key x n mi ma \\<longrightarrow>\n       j \\<notin> offs_set_next\n                   (offs\n                     ((enum xs index key n mi ma)\n                      [index key x n mi ma :=\n                         Suc (enum xs index key n mi ma !\n                              index key x n mi ma)])\n                     k)\n                   (x # xs) index key mi ma i \\<Longrightarrow>\n    index key x n mi ma\n    \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "from this"], ["proof (chain)\npicking this:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "have \"j = ?i'\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. j = index key x n mi ma", "by (erule_tac contrapos_pp, insert F, simp)"], ["proof (state)\nthis:\n  j = index key x n mi ma\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j \\<noteq> index key x n mi ma \\<longrightarrow>\n       j \\<notin> offs_set_next\n                   (offs\n                     ((enum xs index key n mi ma)\n                      [index key x n mi ma :=\n                         Suc (enum xs index key n mi ma !\n                              index key x n mi ma)])\n                     k)\n                   (x # xs) index key mi ma i \\<Longrightarrow>\n    index key x n mi ma\n    \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "ultimately"], ["proof (chain)\npicking this:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n  j = index key x n mi ma", "show \"?i' \\<in> ?A'\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n  j = index key x n mi ma\n\ngoal (1 subgoal):\n 1. index key x n mi ma\n    \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  index key x n mi ma\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  index key x n mi ma\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "with G"], ["proof (chain)\npicking this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < n\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  index key x n mi ma", "have \"offs ?ns' k ! Min ?A' = offs ?ns k ! Min ?A'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < n\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  index key x n mi ma\n\ngoal (1 subgoal):\n 1. offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i) =\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)", "by (subst offs_update, simp_all add: enum_length)"], ["proof (state)\nthis:\n  offs\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)])\n   k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "also"], ["proof (state)\nthis:\n  offs\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)])\n   k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "from A and B and G and H"], ["proof (chain)\npicking this:\n  index_less index key\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < n\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  index key x n mi ma", "have\n   \"\\<dots> = offs_next (offs ?ns k) (length xs + k) xs index key mi ma (Min ?A')\""], ["proof (prove)\nusing this:\n  index_less index key\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < n\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  index key x n mi ma\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i) =\n    offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i))", "proof (rule_tac offs_enum_zero, simp_all, rule_tac ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < offs_num n xs index key mi ma (index key x n mi ma);\n     index_less index key; index key x n mi ma < n;\n     Min (offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i) =\n     index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"?i' < n\" and \"0 < offs_num n xs index key mi ma ?i'\""], ["proof (state)\nthis:\n  index key x n mi ma < n\n  0 < offs_num n xs index key mi ma (index key x n mi ma)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < offs_num n xs index key mi ma (index key x n mi ma);\n     index_less index key; index key x n mi ma < n;\n     Min (offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i) =\n     index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"?i' \\<in> ?A\""], ["proof (prove)\nusing this:\n  index key x n mi ma < n\n  0 < offs_num n xs index key mi ma (index key x n mi ma)\n\ngoal (1 subgoal):\n 1. index key x n mi ma\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "using E"], ["proof (prove)\nusing this:\n  index key x n mi ma < n\n  0 < offs_num n xs index key mi ma (index key x n mi ma)\n  i < index key x n mi ma\n\ngoal (1 subgoal):\n 1. index key x n mi ma\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  index key x n mi ma\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma;\n     0 < offs_num n xs index key mi ma (index key x n mi ma);\n     index_less index key; index key x n mi ma < n;\n     Min (offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i) =\n     index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  index key x n mi ma\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  index key x n mi ma\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "also"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have \"\\<dots> = length xs + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) =\n    length xs + k", "proof (simp only: offs_next_def split: if_split, rule conjI, simp, rule impI,\n   rule FalseE, simp, erule exE, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_next\n                      (offs\n                        ((enum xs index key n mi ma)\n                         [index key x n mi ma :=\n                            Suc (enum xs index key n mi ma !\n                                 index key x n mi ma)])\n                        k)\n                      (x # xs) index key mi ma i)\n                < xa;\n        xa < length (offs (enum xs index key n mi ma) k);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma xa\\<rbrakk>\n       \\<Longrightarrow> False", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_next\n                      (offs\n                        ((enum xs index key n mi ma)\n                         [index key x n mi ma :=\n                            Suc (enum xs index key n mi ma !\n                                 index key x n mi ma)])\n                        k)\n                      (x # xs) index key mi ma i)\n                < xa;\n        xa < length (offs (enum xs index key n mi ma) k);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma xa\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j < length (offs ?ns k)\""], ["proof (state)\nthis:\n  j < length (offs (enum xs index key n mi ma) k)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_next\n                      (offs\n                        ((enum xs index key n mi ma)\n                         [index key x n mi ma :=\n                            Suc (enum xs index key n mi ma !\n                                 index key x n mi ma)])\n                        k)\n                      (x # xs) index key mi ma i)\n                < xa;\n        xa < length (offs (enum xs index key n mi ma) k);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma xa\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j < length (offs (enum xs index key n mi ma) k)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_next\n                      (offs\n                        ((enum xs index key n mi ma)\n                         [index key x n mi ma :=\n                            Suc (enum xs index key n mi ma !\n                                 index key x n mi ma)])\n                        k)\n                      (x # xs) index key mi ma i)\n                < xa;\n        xa < length (offs (enum xs index key n mi ma) k);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma xa\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"Min ?A' < j\""], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_next\n                      (offs\n                        ((enum xs index key n mi ma)\n                         [index key x n mi ma :=\n                            Suc (enum xs index key n mi ma !\n                                 index key x n mi ma)])\n                        k)\n                      (x # xs) index key mi ma i)\n                < xa;\n        xa < length (offs (enum xs index key n mi ma) k);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma xa\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"i < j\""], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < j\n\ngoal (1 subgoal):\n 1. i < j", "using E and H"], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < j\n  i < index key x n mi ma\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  index key x n mi ma\n\ngoal (1 subgoal):\n 1. i < j", "by simp"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_next\n                      (offs\n                        ((enum xs index key n mi ma)\n                         [index key x n mi ma :=\n                            Suc (enum xs index key n mi ma !\n                                 index key x n mi ma)])\n                        k)\n                      (x # xs) index key mi ma i)\n                < xa;\n        xa < length (offs (enum xs index key n mi ma) k);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma xa\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_next\n                      (offs\n                        ((enum xs index key n mi ma)\n                         [index key x n mi ma :=\n                            Suc (enum xs index key n mi ma !\n                                 index key x n mi ma)])\n                        k)\n                      (x # xs) index key mi ma i)\n                < xa;\n        xa < length (offs (enum xs index key n mi ma) k);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma xa\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"0 < offs_num (length (offs ?ns k)) xs index key mi ma j\""], ["proof (state)\nthis:\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_next\n                      (offs\n                        ((enum xs index key n mi ma)\n                         [index key x n mi ma :=\n                            Suc (enum xs index key n mi ma !\n                                 index key x n mi ma)])\n                        k)\n                      (x # xs) index key mi ma i)\n                < xa;\n        xa < length (offs (enum xs index key n mi ma) k);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma xa\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  j < length (offs (enum xs index key n mi ma) k)\n  i < j\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j", "have \"j \\<in> ?A\""], ["proof (prove)\nusing this:\n  j < length (offs (enum xs index key n mi ma) k)\n  i < j\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n             mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Min (offs_set_next\n                      (offs\n                        ((enum xs index key n mi ma)\n                         [index key x n mi ma :=\n                            Suc (enum xs index key n mi ma !\n                                 index key x n mi ma)])\n                        k)\n                      (x # xs) index key mi ma i)\n                < xa;\n        xa < length (offs (enum xs index key n mi ma) k);\n        0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index\n             key mi ma xa\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)) =\n  length xs + k\n\ngoal (5 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> length xs + k\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 5. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "finally"], ["proof (chain)\npicking this:\n  offs\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)])\n   k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  length xs + k", "show \"length xs + k \\<le> offs ?ns' k ! Min ?A'\""], ["proof (prove)\nusing this:\n  offs\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)])\n   k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  length xs + k\n\ngoal (1 subgoal):\n 1. length xs + k\n    \\<le> offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "by simp"], ["proof (state)\nthis:\n  length xs + k\n  \\<le> offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "assume\n    C: \"offs_set_next (offs ?ns k) xs index key mi ma i = {}\"\n      (is \"?A = _\") and\n    D: \"offs_set_next (offs ?ns' k) (x # xs) index key mi ma i \\<noteq> {}\"\n      (is \"?A' \\<noteq> _\") and\n    E: \"?i' \\<le> i\""], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}\n  index key x n mi ma \\<le> i\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have \"\\<exists>j. j \\<in> ?A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j \\<in> offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i", "using D"], ["proof (prove)\nusing this:\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j \\<in> offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i", "by blast"], ["proof (state)\nthis:\n  \\<exists>j.\n     j \\<in> offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>j.\n     j \\<in> offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i", "obtain j where F: \"j \\<in> ?A'\""], ["proof (prove)\nusing this:\n  \\<exists>j.\n     j \\<in> offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j \\<in> offs_set_next\n                 (offs\n                   ((enum xs index key n mi ma)\n                    [index key x n mi ma :=\n                       Suc (enum xs index key n mi ma !\n                            index key x n mi ma)])\n                   k)\n                 (x # xs) index key mi ma i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence \"j < length (offs ?ns k)\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. j < length (offs (enum xs index key n mi ma) k)", "by (simp add: offs_length)"], ["proof (state)\nthis:\n  j < length (offs (enum xs index key n mi ma) k)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "moreover"], ["proof (state)\nthis:\n  j < length (offs (enum xs index key n mi ma) k)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "using F"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. i < j", "by simp"], ["proof (state)\nthis:\n  i < j\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "moreover"], ["proof (state)\nthis:\n  i < j\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "from this"], ["proof (chain)\npicking this:\n  i < j", "have\n   \"0 < offs_num (length (offs ?ns k)) xs index key mi ma j\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key\n         mi ma j", "using E and F"], ["proof (prove)\nusing this:\n  i < j\n  index key x n mi ma \\<le> i\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key\n         mi ma j", "by (simp add: offs_length enum_length offs_num_cons)"], ["proof (state)\nthis:\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "ultimately"], ["proof (chain)\npicking this:\n  j < length (offs (enum xs index key n mi ma) k)\n  i < j\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j", "have \"j \\<in> ?A\""], ["proof (prove)\nusing this:\n  j < length (offs (enum xs index key n mi ma) k)\n  i < j\n  0 < offs_num (length (offs (enum xs index key n mi ma) k)) xs index key mi\n       ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n             mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (4 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i =\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 4. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "thus False"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma i =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "assume\n    C: \"offs_set_next (offs ?ns k) xs index key mi ma i \\<noteq> {}\"\n      (is \"?A \\<noteq> _\") and\n    D: \"offs_set_next (offs ?ns' k) (x # xs) index key mi ma i = {}\"\n      (is \"?A' = _\")"], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   i \\<noteq>\n  {}\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i =\n  {}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have \"\\<exists>j. j \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                key mi ma i", "using C"], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                key mi ma i", "by blast"], ["proof (state)\nthis:\n  \\<exists>j.\n     j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>j.\n     j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i", "obtain j where E: \"j \\<in> ?A\""], ["proof (prove)\nusing this:\n  \\<exists>j.\n     j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                 key mi ma i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence \"j < length (offs ?ns' k)\""], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. j < length\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)", "by (simp add: offs_length)"], ["proof (state)\nthis:\n  j < length\n       (offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "moreover"], ["proof (state)\nthis:\n  j < length\n       (offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "using E"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. i < j", "by simp"], ["proof (state)\nthis:\n  i < j\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "moreover"], ["proof (state)\nthis:\n  i < j\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have \"0 < offs_num (length (offs ?ns' k)) (x # xs) index key mi ma j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < offs_num\n         (length\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k))\n         (x # xs) index key mi ma j", "using E"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num\n         (length\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k))\n         (x # xs) index key mi ma j", "by (simp add: offs_length enum_length offs_num_cons)"], ["proof (state)\nthis:\n  0 < offs_num\n       (length\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k))\n       (x # xs) index key mi ma j\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "ultimately"], ["proof (chain)\npicking this:\n  j < length\n       (offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k)\n  i < j\n  0 < offs_num\n       (length\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k))\n       (x # xs) index key mi ma j", "have \"j \\<in> ?A'\""], ["proof (prove)\nusing this:\n  j < length\n       (offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k)\n  i < j\n  0 < offs_num\n       (length\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k))\n       (x # xs) index key mi ma j\n\ngoal (1 subgoal):\n 1. j \\<in> offs_set_next\n             (offs\n               ((enum xs index key n mi ma)\n                [index key x n mi ma :=\n                   Suc (enum xs index key n mi ma ! index key x n mi ma)])\n               k)\n             (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 3. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "thus False"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. False", "using D"], ["proof (prove)\nusing this:\n  j \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "assume \"offs_set_next (offs ?ns k) xs index key mi ma i \\<noteq> {}\"\n    (is \"?A \\<noteq> _\")"], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   i \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence \"Min ?A \\<in> ?A\""], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence C: \"Min ?A < n\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    < n", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "assume \"offs_set_next (offs ?ns' k) (x # xs) index key mi ma i \\<noteq> {}\"\n    (is \"?A' \\<noteq> _\")"], ["proof (state)\nthis:\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence D: \"Min ?A' \\<in> ?A'\""], ["proof (prove)\nusing this:\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence E: \"Min ?A' < n\""], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    < n", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have \"offs ?ns k ! Min ?A \\<le> offs ?ns k ! Min ?A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "proof (cases \"offs_num n xs index key mi ma (Min ?A') = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) =\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)\n 2. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "case True"], ["proof (state)\nthis:\n  offs_num n xs index key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)) =\n  0\n\ngoal (2 subgoals):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) =\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)\n 2. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "have \"offs ?ns k ! Min ?A' =\n      offs_next (offs ?ns k) (length xs + k) xs index key mi ma (Min ?A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i) =\n    offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i))", "using A and B and E and True"], ["proof (prove)\nusing this:\n  index_less index key\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < n\n  offs_num n xs index key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)) =\n  0\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i) =\n    offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i))", "by (rule_tac offs_enum_zero, simp_all)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i))\n\ngoal (2 subgoals):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) =\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)\n 2. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "also"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i) =\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i))\n\ngoal (2 subgoals):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) =\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)\n 2. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "from A and B and C"], ["proof (chain)\npicking this:\n  index_less index key\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < n", "have \"\\<dots> \\<ge> offs ?ns k ! Min ?A\""], ["proof (prove)\nusing this:\n  index_less index key\n  \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < n\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n           index key mi ma\n           (Min (offs_set_next\n                  (offs\n                    ((enum xs index key n mi ma)\n                     [index key x n mi ma :=\n                        Suc (enum xs index key n mi ma !\n                             index key x n mi ma)])\n                    k)\n                  (x # xs) index key mi ma i))", "proof (simp only: offs_next_def split: if_split, rule_tac conjI, rule_tac [!] impI,\n     rule_tac offs_enum_ub, simp, simp, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      (Min (offs_set_next\n             (offs\n               ((enum xs index key n mi ma)\n                [index key x n mi ma :=\n                   Suc (enum xs index key n mi ma ! index key x n mi ma)])\n               k)\n             (x # xs) index key mi ma i)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma\n                                  (Min (offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i)))", "assume \"offs_set_next (offs ?ns k) xs index key mi ma (Min ?A') \\<noteq> {}\"\n        (is \"?B \\<noteq> _\")"], ["proof (state)\nthis:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      (Min (offs_set_next\n             (offs\n               ((enum xs index key n mi ma)\n                [index key x n mi ma :=\n                   Suc (enum xs index key n mi ma ! index key x n mi ma)])\n               k)\n             (x # xs) index key mi ma i)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma\n                                  (Min (offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i)))", "hence \"Min ?B \\<in> ?B\""], ["proof (prove)\nusing this:\n  offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma (Min (offs_set_next\n                    (offs\n                      ((enum xs index key n mi ma)\n                       [index key x n mi ma :=\n                          Suc (enum xs index key n mi ma !\n                               index key x n mi ma)])\n                      k)\n                    (x # xs) index key mi ma i)))\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma (Min (offs_set_next\n                     (offs\n                       ((enum xs index key n mi ma)\n                        [index key x n mi ma :=\n                           Suc (enum xs index key n mi ma !\n                                index key x n mi ma)])\n                       k)\n                     (x # xs) index key mi ma i))", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        (Min (offs_set_next\n               (offs\n                 ((enum xs index key n mi ma)\n                  [index key x n mi ma :=\n                     Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                 k)\n               (x # xs) index key mi ma i)))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma (Min (offs_set_next\n                   (offs\n                     ((enum xs index key n mi ma)\n                      [index key x n mi ma :=\n                         Suc (enum xs index key n mi ma !\n                              index key x n mi ma)])\n                     k)\n                   (x # xs) index key mi ma i))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      (Min (offs_set_next\n             (offs\n               ((enum xs index key n mi ma)\n                [index key x n mi ma :=\n                   Suc (enum xs index key n mi ma ! index key x n mi ma)])\n               k)\n             (x # xs) index key mi ma i)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma\n                                  (Min (offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i)))", "hence \"Min ?B \\<in> ?A\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        (Min (offs_set_next\n               (offs\n                 ((enum xs index key n mi ma)\n                  [index key x n mi ma :=\n                     Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                 k)\n               (x # xs) index key mi ma i)))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma (Min (offs_set_next\n                   (offs\n                     ((enum xs index key n mi ma)\n                      [index key x n mi ma :=\n                         Suc (enum xs index key n mi ma !\n                              index key x n mi ma)])\n                     k)\n                   (x # xs) index key mi ma i))\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma (Min (offs_set_next\n                    (offs\n                      ((enum xs index key n mi ma)\n                       [index key x n mi ma :=\n                          Suc (enum xs index key n mi ma !\n                               index key x n mi ma)])\n                      k)\n                    (x # xs) index key mi ma i)))\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "using D"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        (Min (offs_set_next\n               (offs\n                 ((enum xs index key n mi ma)\n                  [index key x n mi ma :=\n                     Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                 k)\n               (x # xs) index key mi ma i)))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma (Min (offs_set_next\n                   (offs\n                     ((enum xs index key n mi ma)\n                      [index key x n mi ma :=\n                         Suc (enum xs index key n mi ma !\n                              index key x n mi ma)])\n                     k)\n                   (x # xs) index key mi ma i))\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma (Min (offs_set_next\n                    (offs\n                      ((enum xs index key n mi ma)\n                       [index key x n mi ma :=\n                          Suc (enum xs index key n mi ma !\n                               index key x n mi ma)])\n                      k)\n                    (x # xs) index key mi ma i)))\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "by simp"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        (Min (offs_set_next\n               (offs\n                 ((enum xs index key n mi ma)\n                  [index key x n mi ma :=\n                     Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                 k)\n               (x # xs) index key mi ma i)))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      (Min (offs_set_next\n             (offs\n               ((enum xs index key n mi ma)\n                [index key x n mi ma :=\n                   Suc (enum xs index key n mi ma ! index key x n mi ma)])\n               k)\n             (x # xs) index key mi ma i)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma\n                                  (Min (offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i)))", "moreover"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        (Min (offs_set_next\n               (offs\n                 ((enum xs index key n mi ma)\n                  [index key x n mi ma :=\n                     Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                 k)\n               (x # xs) index key mi ma i)))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      (Min (offs_set_next\n             (offs\n               ((enum xs index key n mi ma)\n                [index key x n mi ma :=\n                   Suc (enum xs index key n mi ma ! index key x n mi ma)])\n               k)\n             (x # xs) index key mi ma i)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma\n                                  (Min (offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i)))", "from this"], ["proof (chain)\npicking this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        (Min (offs_set_next\n               (offs\n                 ((enum xs index key n mi ma)\n                  [index key x n mi ma :=\n                     Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                 k)\n               (x # xs) index key mi ma i)))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i", "have \"Min ?A \\<le> Min ?B\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        (Min (offs_set_next\n               (offs\n                 ((enum xs index key n mi ma)\n                  [index key x n mi ma :=\n                     Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                 k)\n               (x # xs) index key mi ma i)))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                key mi ma\n                (Min (offs_set_next\n                       (offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k)\n                       (x # xs) index key mi ma i)))", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma\n              (Min (offs_set_next\n                     (offs\n                       ((enum xs index key n mi ma)\n                        [index key x n mi ma :=\n                           Suc (enum xs index key n mi ma !\n                                index key x n mi ma)])\n                       k)\n                     (x # xs) index key mi ma i)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     index_less index key; \\<forall>x\\<in>set xs. key x \\<in> {mi..ma};\n     Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i)\n     < n;\n     offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n      (Min (offs_set_next\n             (offs\n               ((enum xs index key n mi ma)\n                [index key x n mi ma :=\n                   Suc (enum xs index key n mi ma ! index key x n mi ma)])\n               k)\n             (x # xs) index key mi ma i)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs (enum xs index key n mi ma) k !\n                            Min (offs_set_next\n                                  (offs (enum xs index key n mi ma) k) xs\n                                  index key mi ma\n                                  (Min (offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i)))", "ultimately"], ["proof (chain)\npicking this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        (Min (offs_set_next\n               (offs\n                 ((enum xs index key n mi ma)\n                  [index key x n mi ma :=\n                     Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                 k)\n               (x # xs) index key mi ma i)))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma\n              (Min (offs_set_next\n                     (offs\n                       ((enum xs index key n mi ma)\n                        [index key x n mi ma :=\n                           Suc (enum xs index key n mi ma !\n                                index key x n mi ma)])\n                       k)\n                     (x # xs) index key mi ma i)))", "show \"offs ?ns k ! Min ?A \\<le> offs ?ns k ! Min ?B\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        (Min (offs_set_next\n               (offs\n                 ((enum xs index key n mi ma)\n                  [index key x n mi ma :=\n                     Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                 k)\n               (x # xs) index key mi ma i)))\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma\n              (Min (offs_set_next\n                     (offs\n                       ((enum xs index key n mi ma)\n                        [index key x n mi ma :=\n                           Suc (enum xs index key n mi ma !\n                                index key x n mi ma)])\n                       k)\n                     (x # xs) index key mi ma i)))\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index\n                key mi ma\n                (Min (offs_set_next\n                       (offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k)\n                       (x # xs) index key mi ma i)))", "by (rule_tac offs_mono, simp_all add: offs_length)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma\n              (Min (offs_set_next\n                     (offs\n                       ((enum xs index key n mi ma)\n                        [index key x n mi ma :=\n                           Suc (enum xs index key n mi ma !\n                                index key x n mi ma)])\n                       k)\n                     (x # xs) index key mi ma i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n         index key mi ma\n         (Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i))\n\ngoal (2 subgoals):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) =\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)\n 2. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "finally"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)", "show ?thesis"], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "."], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "case False"], ["proof (state)\nthis:\n  offs_num n xs index key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "hence \"Min ?A' \\<in> ?A\""], ["proof (prove)\nusing this:\n  offs_num n xs index key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "using D"], ["proof (prove)\nusing this:\n  offs_num n xs index key mi ma\n   (Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)) \\<noteq>\n  0\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "hence \"Min ?A \\<le> Min ?A'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma\n     (Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)) \\<noteq>\n    0 \\<Longrightarrow>\n    offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "by (rule offs_mono, simp_all add: enum_length E)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "also"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have \"\\<dots> \\<le> offs ?ns' k ! Min ?A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    \\<le> offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "using E"], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < n\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    \\<le> offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "by (subst offs_update, simp_all add: enum_length)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<le> offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     i < index key x n mi ma\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      \\<le> offs\n                             ((enum xs index key n mi ma)\n                              [index key x n mi ma :=\n                                 Suc (enum xs index key n mi ma !\nindex key x n mi ma)])\n                             k !\n                            Min (offs_set_next\n                                  (offs\n                                    ((enum xs index key n mi ma)\n                                     [index key x n mi ma :=\n  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                                    k)\n                                  (x # xs) index key mi ma i)\n 2. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "finally"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)", "show \"offs ?ns k ! Min ?A \\<le> offs ?ns' k ! Min ?A'\""], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "."], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "let ?A = \"offs_set_next (offs ?ns k) xs index key mi ma i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "assume \"offs_set_next (offs ?ns' k) (x # xs) index key mi ma i \\<noteq> {}\"\n    (is \"?A' \\<noteq> _\")"], ["proof (state)\nthis:\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence C: \"Min ?A' \\<in> ?A'\""], ["proof (prove)\nusing this:\n  offs_set_next\n   (offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k)\n   (x # xs) index key mi ma i \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    \\<in> offs_set_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (x # xs) index key mi ma i", "by (rule_tac Min_in, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence D: \"Min ?A' < n\""], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    < n", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "assume \"?i' \\<le> i\""], ["proof (state)\nthis:\n  index key x n mi ma \\<le> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence E: \"?i' < Min ?A'\""], ["proof (prove)\nusing this:\n  index key x n mi ma \\<le> i\n\ngoal (1 subgoal):\n 1. index key x n mi ma\n    < Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)", "using C"], ["proof (prove)\nusing this:\n  index key x n mi ma \\<le> i\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. index key x n mi ma\n    < Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)", "by simp"], ["proof (state)\nthis:\n  index key x n mi ma\n  < Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence \"0 < offs_num n xs index key mi ma (Min ?A')\""], ["proof (prove)\nusing this:\n  index key x n mi ma\n  < Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. 0 < offs_num n xs index key mi ma\n         (Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i))", "using C"], ["proof (prove)\nusing this:\n  index key x n mi ma\n  < Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. 0 < offs_num n xs index key mi ma\n         (Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i))", "by (simp add: offs_length enum_length offs_num_cons)"], ["proof (state)\nthis:\n  0 < offs_num n xs index key mi ma\n       (Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence \"Min ?A' \\<in> ?A\""], ["proof (prove)\nusing this:\n  0 < offs_num n xs index key mi ma\n       (Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i))\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "using C"], ["proof (prove)\nusing this:\n  0 < offs_num n xs index key mi ma\n       (Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i))\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n           ma i", "by (simp add: offs_length enum_length)"], ["proof (state)\nthis:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence \"Min ?A \\<le> Min ?A'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  \\<in> offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n         ma i\n\ngoal (1 subgoal):\n 1. Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "by (rule_tac Min_le, simp)"], ["proof (state)\nthis:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "hence \"offs ?ns k ! Min ?A \\<le> offs ?ns k ! Min ?A'\""], ["proof (prove)\nusing this:\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    \\<le> offs (enum xs index key n mi ma) k !\n          Min (offs_set_next\n                (offs\n                  ((enum xs index key n mi ma)\n                   [index key x n mi ma :=\n                      Suc (enum xs index key n mi ma !\n                           index key x n mi ma)])\n                  k)\n                (x # xs) index key mi ma i)", "by (rule offs_mono, simp_all add: enum_length D)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "also"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  \\<le> offs (enum xs index key n mi ma) k !\n        Min (offs_set_next\n              (offs\n                ((enum xs index key n mi ma)\n                 [index key x n mi ma :=\n                    Suc (enum xs index key n mi ma ! index key x n mi ma)])\n                k)\n              (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "have \"\\<dots> < offs ?ns' k ! Min ?A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    < offs\n       ((enum xs index key n mi ma)\n        [index key x n mi ma :=\n           Suc (enum xs index key n mi ma ! index key x n mi ma)])\n       k !\n      Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)", "using E"], ["proof (prove)\nusing this:\n  index key x n mi ma\n  < Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n    < offs\n       ((enum xs index key n mi ma)\n        [index key x n mi ma :=\n           Suc (enum xs index key n mi ma ! index key x n mi ma)])\n       k !\n      Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)", "by (subst offs_update, simp_all add: enum_length D)"], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next\n        (offs\n          ((enum xs index key n mi ma)\n           [index key x n mi ma :=\n              Suc (enum xs index key n mi ma ! index key x n mi ma)])\n          k)\n        (x # xs) index key mi ma i)\n  < offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>offs_set_next (offs (enum xs index key n mi ma) k) xs index key\n              mi ma i \\<noteq>\n             {};\n     offs_set_next\n      (offs\n        ((enum xs index key n mi ma)\n         [index key x n mi ma :=\n            Suc (enum xs index key n mi ma ! index key x n mi ma)])\n        k)\n      (x # xs) index key mi ma i \\<noteq>\n     {};\n     index key x n mi ma \\<le> i\\<rbrakk>\n    \\<Longrightarrow> offs (enum xs index key n mi ma) k !\n                      Min (offs_set_next\n                            (offs (enum xs index key n mi ma) k) xs index\n                            key mi ma i)\n                      < offs\n                         ((enum xs index key n mi ma)\n                          [index key x n mi ma :=\n                             Suc (enum xs index key n mi ma !\n                                  index key x n mi ma)])\n                         k !\n                        Min (offs_set_next\n                              (offs\n                                ((enum xs index key n mi ma)\n                                 [index key x n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key x n mi ma)])\n                                k)\n                              (x # xs) index key mi ma i)", "finally"], ["proof (chain)\npicking this:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)", "show \"offs ?ns k ! Min ?A < offs ?ns' k ! Min ?A'\""], ["proof (prove)\nusing this:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs (enum xs index key n mi ma) k !\n    Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi\n          ma i)\n    < offs\n       ((enum xs index key n mi ma)\n        [index key x n mi ma :=\n           Suc (enum xs index key n mi ma ! index key x n mi ma)])\n       k !\n      Min (offs_set_next\n            (offs\n              ((enum xs index key n mi ma)\n               [index key x n mi ma :=\n                  Suc (enum xs index key n mi ma ! index key x n mi ma)])\n              k)\n            (x # xs) index key mi ma i)", "."], ["proof (state)\nthis:\n  offs (enum xs index key n mi ma) k !\n  Min (offs_set_next (offs (enum xs index key n mi ma) k) xs index key mi ma\n        i)\n  < offs\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n     k !\n    Min (offs_set_next\n          (offs\n            ((enum xs index key n mi ma)\n             [index key x n mi ma :=\n                Suc (enum xs index key n mi ma ! index key x n mi ma)])\n            k)\n          (x # xs) index key mi ma i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offs_enum_pred [rule_format]:\n  assumes A: \"index_less index key\"\n  shows \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    offs_pred (offs (enum xs index key n mi ma) k) (length xs + k)\n      xs index key mi ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    offs_pred (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma", "proof (induction xs, simp add: offs_pred_def offs_num_def,\n simp add: Let_def offs_pred_def offs_length enum_length, rule impI, (erule conjE)+,\n simp, rule allI, rule impI, erule allE, drule mp, assumption)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; i < n;\n        offs_num n xs index key mi ma i\n        \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n               xs index key mi ma i -\n              offs (enum xs index key n mi ma) k ! i\\<rbrakk>\n       \\<Longrightarrow> offs_num n (a # xs) index key mi ma i\n                         \\<le> offs_next\n                                (offs\n                                  ((enum xs index key n mi ma)\n                                   [index key a n mi ma :=\nSuc (enum xs index key n mi ma ! index key a n mi ma)])\n                                  k)\n                                (Suc (length xs + k)) (a # xs) index key mi\n                                ma i -\n                               offs\n                                ((enum xs index key n mi ma)\n                                 [index key a n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key a n mi ma)])\n                                k !\n                               i", "fix x xs i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; i < n;\n        offs_num n xs index key mi ma i\n        \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n               xs index key mi ma i -\n              offs (enum xs index key n mi ma) k ! i\\<rbrakk>\n       \\<Longrightarrow> offs_num n (a # xs) index key mi ma i\n                         \\<le> offs_next\n                                (offs\n                                  ((enum xs index key n mi ma)\n                                   [index key a n mi ma :=\nSuc (enum xs index key n mi ma ! index key a n mi ma)])\n                                  k)\n                                (Suc (length xs + k)) (a # xs) index key mi\n                                ma i -\n                               offs\n                                ((enum xs index key n mi ma)\n                                 [index key a n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key a n mi ma)])\n                                k !\n                               i", "let ?i' = \"index key x n mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; i < n;\n        offs_num n xs index key mi ma i\n        \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n               xs index key mi ma i -\n              offs (enum xs index key n mi ma) k ! i\\<rbrakk>\n       \\<Longrightarrow> offs_num n (a # xs) index key mi ma i\n                         \\<le> offs_next\n                                (offs\n                                  ((enum xs index key n mi ma)\n                                   [index key a n mi ma :=\nSuc (enum xs index key n mi ma ! index key a n mi ma)])\n                                  k)\n                                (Suc (length xs + k)) (a # xs) index key mi\n                                ma i -\n                               offs\n                                ((enum xs index key n mi ma)\n                                 [index key a n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key a n mi ma)])\n                                k !\n                               i", "let ?ns = \"enum xs index key n mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; i < n;\n        offs_num n xs index key mi ma i\n        \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n               xs index key mi ma i -\n              offs (enum xs index key n mi ma) k ! i\\<rbrakk>\n       \\<Longrightarrow> offs_num n (a # xs) index key mi ma i\n                         \\<le> offs_next\n                                (offs\n                                  ((enum xs index key n mi ma)\n                                   [index key a n mi ma :=\nSuc (enum xs index key n mi ma ! index key a n mi ma)])\n                                  k)\n                                (Suc (length xs + k)) (a # xs) index key mi\n                                ma i -\n                               offs\n                                ((enum xs index key n mi ma)\n                                 [index key a n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key a n mi ma)])\n                                k !\n                               i", "let ?ns' = \"?ns[?i' := Suc (?ns ! ?i')]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; i < n;\n        offs_num n xs index key mi ma i\n        \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n               xs index key mi ma i -\n              offs (enum xs index key n mi ma) k ! i\\<rbrakk>\n       \\<Longrightarrow> offs_num n (a # xs) index key mi ma i\n                         \\<le> offs_next\n                                (offs\n                                  ((enum xs index key n mi ma)\n                                   [index key a n mi ma :=\nSuc (enum xs index key n mi ma ! index key a n mi ma)])\n                                  k)\n                                (Suc (length xs + k)) (a # xs) index key mi\n                                ma i -\n                               offs\n                                ((enum xs index key n mi ma)\n                                 [index key a n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key a n mi ma)])\n                                k !\n                               i", "assume\n    B: \"\\<forall>x \\<in> set xs. mi \\<le> key x \\<and> key x \\<le> ma\" and\n    C: \"i < n\" and\n    D: \"offs_num n xs index key mi ma i \\<le>\n      offs_next (offs ?ns k) (length xs + k) xs index key mi ma i - offs ?ns k ! i\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  i < n\n  offs_num n xs index key mi ma i\n  \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n         index key mi ma i -\n        offs (enum xs index key n mi ma) k ! i\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; i < n;\n        offs_num n xs index key mi ma i\n        \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n               xs index key mi ma i -\n              offs (enum xs index key n mi ma) k ! i\\<rbrakk>\n       \\<Longrightarrow> offs_num n (a # xs) index key mi ma i\n                         \\<le> offs_next\n                                (offs\n                                  ((enum xs index key n mi ma)\n                                   [index key a n mi ma :=\nSuc (enum xs index key n mi ma ! index key a n mi ma)])\n                                  k)\n                                (Suc (length xs + k)) (a # xs) index key mi\n                                ma i -\n                               offs\n                                ((enum xs index key n mi ma)\n                                 [index key a n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key a n mi ma)])\n                                k !\n                               i", "have E: \"(if i < ?i' then (\\<le>) else (<))\n    (offs_next (offs ?ns k) (length xs + k) xs index key mi ma i)\n    (offs_next (offs ?ns' k) (Suc (length xs + k)) (x # xs) index key mi ma i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < index key x n mi ma then (\\<le>) else (<))\n     (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i)\n     (offs_next\n       (offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k)\n       (Suc (length xs + k)) (x # xs) index key mi ma i)", "using A and B"], ["proof (prove)\nusing this:\n  index_less index key\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n\ngoal (1 subgoal):\n 1. (if i < index key x n mi ma then (\\<le>) else (<))\n     (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n       index key mi ma i)\n     (offs_next\n       (offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k)\n       (Suc (length xs + k)) (x # xs) index key mi ma i)", "by (subst offs_enum_next_cons, simp_all)"], ["proof (state)\nthis:\n  (if i < index key x n mi ma then (\\<le>) else (<))\n   (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i)\n   (offs_next\n     (offs\n       ((enum xs index key n mi ma)\n        [index key x n mi ma :=\n           Suc (enum xs index key n mi ma ! index key x n mi ma)])\n       k)\n     (Suc (length xs + k)) (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma; i < n;\n        offs_num n xs index key mi ma i\n        \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n               xs index key mi ma i -\n              offs (enum xs index key n mi ma) k ! i\\<rbrakk>\n       \\<Longrightarrow> offs_num n (a # xs) index key mi ma i\n                         \\<le> offs_next\n                                (offs\n                                  ((enum xs index key n mi ma)\n                                   [index key a n mi ma :=\nSuc (enum xs index key n mi ma ! index key a n mi ma)])\n                                  k)\n                                (Suc (length xs + k)) (a # xs) index key mi\n                                ma i -\n                               offs\n                                ((enum xs index key n mi ma)\n                                 [index key a n mi ma :=\n                                    Suc (enum xs index key n mi ma !\n   index key a n mi ma)])\n                                k !\n                               i", "show \"offs_num n (x # xs) index key mi ma i \\<le>\n    offs_next (offs ?ns' k) (Suc (length xs + k)) (x # xs) index key mi ma i -\n      offs ?ns' k ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offs_num n (x # xs) index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k !\n          i", "proof (subst offs_update, simp add: enum_length C, rule linorder_cases [of i ?i'],\n   simp_all add: offs_num_cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. i < index key x n mi ma \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          offs (enum xs index key n mi ma) k ! i\n 2. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 3. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "assume \"i < ?i'\""], ["proof (state)\nthis:\n  i < index key x n mi ma\n\ngoal (3 subgoals):\n 1. i < index key x n mi ma \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          offs (enum xs index key n mi ma) k ! i\n 2. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 3. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "hence \"offs_next (offs ?ns k) (length xs + k) xs index key mi ma i \\<le>\n      offs_next (offs ?ns' k) (Suc (length xs + k)) (x # xs) index key mi ma i\""], ["proof (prove)\nusing this:\n  i < index key x n mi ma\n\ngoal (1 subgoal):\n 1. offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i", "using E"], ["proof (prove)\nusing this:\n  i < index key x n mi ma\n  (if i < index key x n mi ma then (\\<le>) else (<))\n   (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i)\n   (offs_next\n     (offs\n       ((enum xs index key n mi ma)\n        [index key x n mi ma :=\n           Suc (enum xs index key n mi ma ! index key x n mi ma)])\n       k)\n     (Suc (length xs + k)) (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma i\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma i\n\ngoal (3 subgoals):\n 1. i < index key x n mi ma \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          offs (enum xs index key n mi ma) k ! i\n 2. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 3. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "thus \"offs_num n xs index key mi ma i \\<le>\n      offs_next (offs ?ns' k) (Suc (length xs + k)) (x # xs) index key mi ma i -\n        offs ?ns k ! i\""], ["proof (prove)\nusing this:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma i\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          offs (enum xs index key n mi ma) k ! i", "using D"], ["proof (prove)\nusing this:\n  offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n   key mi ma i\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma i\n  offs_num n xs index key mi ma i\n  \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n         index key mi ma i -\n        offs (enum xs index key n mi ma) k ! i\n\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          offs (enum xs index key n mi ma) k ! i", "by arith"], ["proof (state)\nthis:\n  offs_num n xs index key mi ma i\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma i -\n        offs (enum xs index key n mi ma) k ! i\n\ngoal (2 subgoals):\n 1. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 2. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 2. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "assume F: \"i = ?i'\""], ["proof (state)\nthis:\n  i = index key x n mi ma\n\ngoal (2 subgoals):\n 1. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 2. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "hence \"Suc (offs_num n xs index key mi ma ?i') \\<le>\n      Suc (offs_next (offs ?ns k) (length xs + k) xs index key mi ma ?i' -\n        offs ?ns k ! ?i')\""], ["proof (prove)\nusing this:\n  i = index key x n mi ma\n\ngoal (1 subgoal):\n 1. Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k)\n                (length xs + k) xs index key mi ma (index key x n mi ma) -\n               offs (enum xs index key n mi ma) k ! index key x n mi ma)", "using D"], ["proof (prove)\nusing this:\n  i = index key x n mi ma\n  offs_num n xs index key mi ma i\n  \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n         index key mi ma i -\n        offs (enum xs index key n mi ma) k ! i\n\ngoal (1 subgoal):\n 1. Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k)\n                (length xs + k) xs index key mi ma (index key x n mi ma) -\n               offs (enum xs index key n mi ma) k ! index key x n mi ma)", "by simp"], ["proof (state)\nthis:\n  Suc (offs_num n xs index key mi ma (index key x n mi ma))\n  \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n              xs index key mi ma (index key x n mi ma) -\n             offs (enum xs index key n mi ma) k ! index key x n mi ma)\n\ngoal (2 subgoals):\n 1. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 2. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "also"], ["proof (state)\nthis:\n  Suc (offs_num n xs index key mi ma (index key x n mi ma))\n  \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n              xs index key mi ma (index key x n mi ma) -\n             offs (enum xs index key n mi ma) k ! index key x n mi ma)\n\ngoal (2 subgoals):\n 1. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 2. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "from A and B and C and F"], ["proof (chain)\npicking this:\n  index_less index key\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  i < n\n  i = index key x n mi ma", "have \"\\<dots> =\n      Suc (offs_next (offs ?ns k) (length xs + k) xs index key mi ma ?i') -\n        offs ?ns k ! ?i'\""], ["proof (prove)\nusing this:\n  index_less index key\n  \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\n  i < n\n  i = index key x n mi ma\n\ngoal (1 subgoal):\n 1. Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n          index key mi ma (index key x n mi ma) -\n         offs (enum xs index key n mi ma) k ! index key x n mi ma) =\n    Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n          index key mi ma (index key x n mi ma)) -\n    offs (enum xs index key n mi ma) k ! index key x n mi ma", "by (rule_tac Suc_diff_le [symmetric], rule_tac offs_enum_next_ge, simp_all)"], ["proof (state)\nthis:\n  Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n        index key mi ma (index key x n mi ma) -\n       offs (enum xs index key n mi ma) k ! index key x n mi ma) =\n  Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n        index key mi ma (index key x n mi ma)) -\n  offs (enum xs index key n mi ma) k ! index key x n mi ma\n\ngoal (2 subgoals):\n 1. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 2. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "finally"], ["proof (chain)\npicking this:\n  Suc (offs_num n xs index key mi ma (index key x n mi ma))\n  \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n              xs index key mi ma (index key x n mi ma)) -\n        offs (enum xs index key n mi ma) k ! index key x n mi ma", "have \"Suc (offs_num n xs index key mi ma ?i') \\<le>\n      Suc (offs_next (offs ?ns k) (length xs + k) xs index key mi ma ?i') -\n        offs ?ns k ! ?i'\""], ["proof (prove)\nusing this:\n  Suc (offs_num n xs index key mi ma (index key x n mi ma))\n  \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n              xs index key mi ma (index key x n mi ma)) -\n        offs (enum xs index key n mi ma) k ! index key x n mi ma\n\ngoal (1 subgoal):\n 1. Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k)\n                (length xs + k) xs index key mi ma (index key x n mi ma)) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma", "."], ["proof (state)\nthis:\n  Suc (offs_num n xs index key mi ma (index key x n mi ma))\n  \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n              xs index key mi ma (index key x n mi ma)) -\n        offs (enum xs index key n mi ma) k ! index key x n mi ma\n\ngoal (2 subgoals):\n 1. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 2. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "moreover"], ["proof (state)\nthis:\n  Suc (offs_num n xs index key mi ma (index key x n mi ma))\n  \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n              xs index key mi ma (index key x n mi ma)) -\n        offs (enum xs index key n mi ma) k ! index key x n mi ma\n\ngoal (2 subgoals):\n 1. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 2. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "have\n     \"Suc (offs_next (offs ?ns k) (length xs + k) xs index key mi ma ?i') \\<le>\n      offs_next (offs ?ns' k) (Suc (length xs + k)) (x # xs) index key mi ma ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n          index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma)", "using E and F"], ["proof (prove)\nusing this:\n  (if i < index key x n mi ma then (\\<le>) else (<))\n   (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i)\n   (offs_next\n     (offs\n       ((enum xs index key n mi ma)\n        [index key x n mi ma :=\n           Suc (enum xs index key n mi ma ! index key x n mi ma)])\n       k)\n     (Suc (length xs + k)) (x # xs) index key mi ma i)\n  i = index key x n mi ma\n\ngoal (1 subgoal):\n 1. Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n          index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma)", "by simp"], ["proof (state)\nthis:\n  Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n        index key mi ma (index key x n mi ma))\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma\n         (index key x n mi ma)\n\ngoal (2 subgoals):\n 1. i = index key x n mi ma \\<Longrightarrow>\n    Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma\n 2. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "ultimately"], ["proof (chain)\npicking this:\n  Suc (offs_num n xs index key mi ma (index key x n mi ma))\n  \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n              xs index key mi ma (index key x n mi ma)) -\n        offs (enum xs index key n mi ma) k ! index key x n mi ma\n  Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n        index key mi ma (index key x n mi ma))\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma\n         (index key x n mi ma)", "show \"Suc (offs_num n xs index key mi ma ?i') \\<le>\n      offs_next (offs ?ns' k) (Suc (length xs + k)) (x # xs) index key mi ma ?i' -\n        offs ?ns k ! ?i'\""], ["proof (prove)\nusing this:\n  Suc (offs_num n xs index key mi ma (index key x n mi ma))\n  \\<le> Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k)\n              xs index key mi ma (index key x n mi ma)) -\n        offs (enum xs index key n mi ma) k ! index key x n mi ma\n  Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n        index key mi ma (index key x n mi ma))\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma\n         (index key x n mi ma)\n\ngoal (1 subgoal):\n 1. Suc (offs_num n xs index key mi ma (index key x n mi ma))\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma\n           (index key x n mi ma) -\n          offs (enum xs index key n mi ma) k ! index key x n mi ma", "by arith"], ["proof (state)\nthis:\n  Suc (offs_num n xs index key mi ma (index key x n mi ma))\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma\n         (index key x n mi ma) -\n        offs (enum xs index key n mi ma) k ! index key x n mi ma\n\ngoal (1 subgoal):\n 1. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "assume \"?i' < i\""], ["proof (state)\nthis:\n  index key x n mi ma < i\n\ngoal (1 subgoal):\n 1. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "hence \"Suc (offs_next (offs ?ns k) (length xs + k) xs index key mi ma i) \\<le>\n      offs_next (offs ?ns' k) (Suc (length xs + k)) (x # xs) index key mi ma i\""], ["proof (prove)\nusing this:\n  index key x n mi ma < i\n\ngoal (1 subgoal):\n 1. Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n          index key mi ma i)\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i", "using E"], ["proof (prove)\nusing this:\n  index key x n mi ma < i\n  (if i < index key x n mi ma then (\\<le>) else (<))\n   (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs index\n     key mi ma i)\n   (offs_next\n     (offs\n       ((enum xs index key n mi ma)\n        [index key x n mi ma :=\n           Suc (enum xs index key n mi ma ! index key x n mi ma)])\n       k)\n     (Suc (length xs + k)) (x # xs) index key mi ma i)\n\ngoal (1 subgoal):\n 1. Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n          index key mi ma i)\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i", "by simp"], ["proof (state)\nthis:\n  Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n        index key mi ma i)\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. index key x n mi ma < i \\<Longrightarrow>\n    offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "thus \"offs_num n xs index key mi ma i \\<le>\n      offs_next (offs ?ns' k) (Suc (length xs + k)) (x # xs) index key mi ma i -\n        Suc (offs ?ns k ! i)\""], ["proof (prove)\nusing this:\n  Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n        index key mi ma i)\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma i\n\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "using D"], ["proof (prove)\nusing this:\n  Suc (offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n        index key mi ma i)\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma i\n  offs_num n xs index key mi ma i\n  \\<le> offs_next (offs (enum xs index key n mi ma) k) (length xs + k) xs\n         index key mi ma i -\n        offs (enum xs index key n mi ma) k ! i\n\ngoal (1 subgoal):\n 1. offs_num n xs index key mi ma i\n    \\<le> offs_next\n           (offs\n             ((enum xs index key n mi ma)\n              [index key x n mi ma :=\n                 Suc (enum xs index key n mi ma ! index key x n mi ma)])\n             k)\n           (Suc (length xs + k)) (x # xs) index key mi ma i -\n          Suc (offs (enum xs index key n mi ma) k ! i)", "by arith"], ["proof (state)\nthis:\n  offs_num n xs index key mi ma i\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma i -\n        Suc (offs (enum xs index key n mi ma) k ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offs_num n (x # xs) index key mi ma i\n  \\<le> offs_next\n         (offs\n           ((enum xs index key n mi ma)\n            [index key x n mi ma :=\n               Suc (enum xs index key n mi ma ! index key x n mi ma)])\n           k)\n         (Suc (length xs + k)) (x # xs) index key mi ma i -\n        offs\n         ((enum xs index key n mi ma)\n          [index key x n mi ma :=\n             Suc (enum xs index key n mi ma ! index key x n mi ma)])\n         k !\n        i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fill_offs_enum_count_item [rule_format]:\n \"\\<lbrakk>index_less index key; \\<forall>x \\<in> set xs. key x \\<in> {mi..ma}; 0 < n\\<rbrakk> \\<Longrightarrow>\n    count (mset (map the (fill xs (offs (enum xs index key n mi ma) 0)\n      index key (length xs) mi ma))) x =\n    count (mset xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_less index key;\n     \\<forall>x\\<in>set xs. key x \\<in> {mi..ma}; 0 < n\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill xs (offs (enum xs index key n mi ma) 0)\n                             index key (length xs) mi ma)))\n                       x =\n                      count (mset xs) x", "by (subst fill_count_item, simp_all, simp only: length_greater_0_conv [symmetric]\n offs_length enum_length, insert offs_enum_pred [of index key xs mi ma n 0], simp)"], ["", "text \\<open>\n\\null\n\nUsing lemma @{thm [source] fill_offs_enum_count_item}, step 9 of the proof method can now be dealt\nwith. It is accomplished by proving lemma @{text gcsort_count_inv}, which states that the number of\nthe occurrences of whatever object in the objects' list is still the same after any recursive round.\n\n\\null\n\\<close>"], ["", "lemma nths_count:\n \"count (mset (nths xs A)) x =\n    count (mset xs) x - card {i. i < length xs \\<and> i \\<notin> A \\<and> xs ! i = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (mset (nths xs A)) x =\n    count (mset xs) x -\n    card {i. i < length xs \\<and> i \\<notin> A \\<and> xs ! i = x}", "proof (induction xs arbitrary: A, simp_all add: nths_Cons)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       (\\<And>A.\n           count (mset (nths xs A)) x =\n           count (mset xs) x -\n           card\n            {i. i < length xs \\<and>\n                i \\<notin> A \\<and> xs ! i = x}) \\<Longrightarrow>\n       (0 \\<in> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         Suc (count (mset xs) x -\n              card\n               {i. i < length xs \\<and>\n                   Suc i \\<notin> A \\<and> xs ! i = x}) =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x})) \\<and>\n       (0 \\<notin> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x}))", "fix v xs A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       (\\<And>A.\n           count (mset (nths xs A)) x =\n           count (mset xs) x -\n           card\n            {i. i < length xs \\<and>\n                i \\<notin> A \\<and> xs ! i = x}) \\<Longrightarrow>\n       (0 \\<in> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         Suc (count (mset xs) x -\n              card\n               {i. i < length xs \\<and>\n                   Suc i \\<notin> A \\<and> xs ! i = x}) =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x})) \\<and>\n       (0 \\<notin> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x}))", "let ?B = \"{i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       (\\<And>A.\n           count (mset (nths xs A)) x =\n           count (mset xs) x -\n           card\n            {i. i < length xs \\<and>\n                i \\<notin> A \\<and> xs ! i = x}) \\<Longrightarrow>\n       (0 \\<in> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         Suc (count (mset xs) x -\n              card\n               {i. i < length xs \\<and>\n                   Suc i \\<notin> A \\<and> xs ! i = x}) =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x})) \\<and>\n       (0 \\<notin> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x}))", "let ?C = \"\\<lambda>v. {i. i < Suc (length xs) \\<and> i \\<notin> A \\<and> (v # xs) ! i = x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       (\\<And>A.\n           count (mset (nths xs A)) x =\n           count (mset xs) x -\n           card\n            {i. i < length xs \\<and>\n                i \\<notin> A \\<and> xs ! i = x}) \\<Longrightarrow>\n       (0 \\<in> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         Suc (count (mset xs) x -\n              card\n               {i. i < length xs \\<and>\n                   Suc i \\<notin> A \\<and> xs ! i = x}) =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x})) \\<and>\n       (0 \\<notin> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x}))", "have A: \"\\<And>v. ?C v = ?C v \\<inter> {0} \\<union> ?C v \\<inter> {i. \\<exists>j. i = Suc j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       {i. i < Suc (length xs) \\<and>\n           i \\<notin> A \\<and> (v # xs) ! i = x} =\n       {i. i < Suc (length xs) \\<and>\n           i \\<notin> A \\<and> (v # xs) ! i = x} \\<inter>\n       {0} \\<union>\n       {i. i < Suc (length xs) \\<and>\n           i \\<notin> A \\<and> (v # xs) ! i = x} \\<inter>\n       {i. \\<exists>j. i = Suc j}", "by (subst Int_Un_distrib [symmetric], auto, arith)"], ["proof (state)\nthis:\n  {i. i < Suc (length xs) \\<and> i \\<notin> A \\<and> (?v # xs) ! i = x} =\n  {i. i < Suc (length xs) \\<and>\n      i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n  {0} \\<union>\n  {i. i < Suc (length xs) \\<and>\n      i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n  {i. \\<exists>j. i = Suc j}\n\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       (\\<And>A.\n           count (mset (nths xs A)) x =\n           count (mset xs) x -\n           card\n            {i. i < length xs \\<and>\n                i \\<notin> A \\<and> xs ! i = x}) \\<Longrightarrow>\n       (0 \\<in> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         Suc (count (mset xs) x -\n              card\n               {i. i < length xs \\<and>\n                   Suc i \\<notin> A \\<and> xs ! i = x}) =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x})) \\<and>\n       (0 \\<notin> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x}))", "have \"\\<And>v. card (?C v) = card (?C v \\<inter> {0}) + card (?C v \\<inter> {i. \\<exists>j. i = Suc j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       card\n        {i. i < Suc (length xs) \\<and>\n            i \\<notin> A \\<and> (v # xs) ! i = x} =\n       card\n        ({i. i < Suc (length xs) \\<and>\n             i \\<notin> A \\<and> (v # xs) ! i = x} \\<inter>\n         {0}) +\n       card\n        ({i. i < Suc (length xs) \\<and>\n             i \\<notin> A \\<and> (v # xs) ! i = x} \\<inter>\n         {i. \\<exists>j. i = Suc j})", "by (subst A, rule card_Un_disjoint, simp_all, blast)"], ["proof (state)\nthis:\n  card\n   {i. i < Suc (length xs) \\<and> i \\<notin> A \\<and> (?v # xs) ! i = x} =\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {0}) +\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {i. \\<exists>j. i = Suc j})\n\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       (\\<And>A.\n           count (mset (nths xs A)) x =\n           count (mset xs) x -\n           card\n            {i. i < length xs \\<and>\n                i \\<notin> A \\<and> xs ! i = x}) \\<Longrightarrow>\n       (0 \\<in> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         Suc (count (mset xs) x -\n              card\n               {i. i < length xs \\<and>\n                   Suc i \\<notin> A \\<and> xs ! i = x}) =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x})) \\<and>\n       (0 \\<notin> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x}))", "moreover"], ["proof (state)\nthis:\n  card\n   {i. i < Suc (length xs) \\<and> i \\<notin> A \\<and> (?v # xs) ! i = x} =\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {0}) +\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {i. \\<exists>j. i = Suc j})\n\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       (\\<And>A.\n           count (mset (nths xs A)) x =\n           count (mset xs) x -\n           card\n            {i. i < length xs \\<and>\n                i \\<notin> A \\<and> xs ! i = x}) \\<Longrightarrow>\n       (0 \\<in> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         Suc (count (mset xs) x -\n              card\n               {i. i < length xs \\<and>\n                   Suc i \\<notin> A \\<and> xs ! i = x}) =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x})) \\<and>\n       (0 \\<notin> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x}))", "have \"\\<And>v. card ?B = card (?C v \\<inter> {i. \\<exists>j. i = Suc j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n       card\n        ({i. i < Suc (length xs) \\<and>\n             i \\<notin> A \\<and> (v # xs) ! i = x} \\<inter>\n         {i. \\<exists>j. i = Suc j})", "by (rule bij_betw_same_card [of Suc], auto)"], ["proof (state)\nthis:\n  card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {i. \\<exists>j. i = Suc j})\n\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       (\\<And>A.\n           count (mset (nths xs A)) x =\n           count (mset xs) x -\n           card\n            {i. i < length xs \\<and>\n                i \\<notin> A \\<and> xs ! i = x}) \\<Longrightarrow>\n       (0 \\<in> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         Suc (count (mset xs) x -\n              card\n               {i. i < length xs \\<and>\n                   Suc i \\<notin> A \\<and> xs ! i = x}) =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x})) \\<and>\n       (0 \\<notin> A \\<longrightarrow>\n        (a = x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         Suc (count (mset xs) x) -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         count (mset xs) x -\n         card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n         count (mset xs) x -\n         card\n          {i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (a # xs) ! i = x}))", "ultimately"], ["proof (chain)\npicking this:\n  card\n   {i. i < Suc (length xs) \\<and> i \\<notin> A \\<and> (?v # xs) ! i = x} =\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {0}) +\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {i. \\<exists>j. i = Suc j})\n  card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {i. \\<exists>j. i = Suc j})", "show\n   \"(0 \\<in> A \\<longrightarrow>\n      (v = x \\<longrightarrow> Suc (count (mset xs) x - card ?B) =\n        Suc (count (mset xs) x) - card (?C x)) \\<and>\n      (v \\<noteq> x \\<longrightarrow> count (mset xs) x - card ?B =\n        count (mset xs) x - card (?C v))) \\<and>\n    (0 \\<notin> A \\<longrightarrow>\n      (v = x \\<longrightarrow> count (mset xs) x - card ?B =\n        Suc (count (mset xs) x) - card (?C x)) \\<and>\n      (v \\<noteq> x \\<longrightarrow> count (mset xs) x - card ?B =\n        count (mset xs) x - card (?C v)))\""], ["proof (prove)\nusing this:\n  card\n   {i. i < Suc (length xs) \\<and> i \\<notin> A \\<and> (?v # xs) ! i = x} =\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {0}) +\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {i. \\<exists>j. i = Suc j})\n  card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n  card\n   ({i. i < Suc (length xs) \\<and>\n        i \\<notin> A \\<and> (?v # xs) ! i = x} \\<inter>\n    {i. \\<exists>j. i = Suc j})\n\ngoal (1 subgoal):\n 1. (0 \\<in> A \\<longrightarrow>\n     (v = x \\<longrightarrow>\n      Suc (count (mset xs) x -\n           card\n            {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}) =\n      Suc (count (mset xs) x) -\n      card\n       {i. i < Suc (length xs) \\<and>\n           i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n     (v \\<noteq> x \\<longrightarrow>\n      count (mset xs) x -\n      card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n      count (mset xs) x -\n      card\n       {i. i < Suc (length xs) \\<and>\n           i \\<notin> A \\<and> (v # xs) ! i = x})) \\<and>\n    (0 \\<notin> A \\<longrightarrow>\n     (v = x \\<longrightarrow>\n      count (mset xs) x -\n      card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n      Suc (count (mset xs) x) -\n      card\n       {i. i < Suc (length xs) \\<and>\n           i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n     (v \\<noteq> x \\<longrightarrow>\n      count (mset xs) x -\n      card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n      count (mset xs) x -\n      card\n       {i. i < Suc (length xs) \\<and>\n           i \\<notin> A \\<and> (v # xs) ! i = x}))", "proof ((rule_tac [!] conjI, rule_tac [!] impI)+, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> A; v = x;\n     \\<And>v.\n        card\n         {i. i < Suc (length xs) \\<and>\n             i \\<notin> A \\<and> (v # xs) ! i = x} =\n        card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x};\n     \\<And>v.\n        card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n        card\n         ({i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (v # xs) ! i = x} \\<inter>\n          {i. \\<exists>j. i = Suc j})\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset xs) x -\n                           card\n                            {i. i < length xs \\<and>\n                                Suc i \\<notin> A \\<and> xs ! i = x}) =\n                      Suc (count (mset xs) x) -\n                      card\n                       {i. i < length xs \\<and>\n                           Suc i \\<notin> A \\<and> xs ! i = x}", "have \"card ?B \\<le> count (mset xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}\n    \\<le> count (mset xs) x", "by (simp add: count_mset length_filter_conv_card, rule card_mono,\n       simp, blast)"], ["proof (state)\nthis:\n  card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}\n  \\<le> count (mset xs) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> A; v = x;\n     \\<And>v.\n        card\n         {i. i < Suc (length xs) \\<and>\n             i \\<notin> A \\<and> (v # xs) ! i = x} =\n        card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x};\n     \\<And>v.\n        card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n        card\n         ({i. i < Suc (length xs) \\<and>\n              i \\<notin> A \\<and> (v # xs) ! i = x} \\<inter>\n          {i. \\<exists>j. i = Suc j})\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset xs) x -\n                           card\n                            {i. i < length xs \\<and>\n                                Suc i \\<notin> A \\<and> xs ! i = x}) =\n                      Suc (count (mset xs) x) -\n                      card\n                       {i. i < length xs \\<and>\n                           Suc i \\<notin> A \\<and> xs ! i = x}", "thus \"Suc (count (mset xs) x - card ?B) = Suc (count (mset xs) x) - card ?B\""], ["proof (prove)\nusing this:\n  card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}\n  \\<le> count (mset xs) x\n\ngoal (1 subgoal):\n 1. Suc (count (mset xs) x -\n         card\n          {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}) =\n    Suc (count (mset xs) x) -\n    card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}", "by (rule Suc_diff_le [symmetric])"], ["proof (state)\nthis:\n  Suc (count (mset xs) x -\n       card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}) =\n  Suc (count (mset xs) x) -\n  card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0 \\<in> A \\<longrightarrow>\n   (v = x \\<longrightarrow>\n    Suc (count (mset xs) x -\n         card\n          {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x}) =\n    Suc (count (mset xs) x) -\n    card\n     {i. i < Suc (length xs) \\<and>\n         i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n   (v \\<noteq> x \\<longrightarrow>\n    count (mset xs) x -\n    card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n    count (mset xs) x -\n    card\n     {i. i < Suc (length xs) \\<and>\n         i \\<notin> A \\<and> (v # xs) ! i = x})) \\<and>\n  (0 \\<notin> A \\<longrightarrow>\n   (v = x \\<longrightarrow>\n    count (mset xs) x -\n    card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n    Suc (count (mset xs) x) -\n    card\n     {i. i < Suc (length xs) \\<and>\n         i \\<notin> A \\<and> (x # xs) ! i = x}) \\<and>\n   (v \\<noteq> x \\<longrightarrow>\n    count (mset xs) x -\n    card {i. i < length xs \\<and> Suc i \\<notin> A \\<and> xs ! i = x} =\n    count (mset xs) x -\n    card\n     {i. i < Suc (length xs) \\<and> i \\<notin> A \\<and> (v # xs) ! i = x}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_count_inv [rule_format]:\n \"index_less index key \\<longrightarrow> bn_inv p q t \\<longrightarrow> add_inv n t \\<longrightarrow> count_inv f t \\<longrightarrow>\n    count_inv f (round index key p q r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_less index key \\<longrightarrow>\n    bn_inv p q t \\<longrightarrow>\n    add_inv n t \\<longrightarrow>\n    count_inv f t \\<longrightarrow> count_inv f (round index key p q r t)", "proof (induction index key p q r t arbitrary: n f rule: round.induct,\n (rule_tac [!] impI)+, simp, simp, simp_all only: simp_thms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n f.\n       \\<lbrakk>\\<And>n f.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   count_inv f (u, ns, tl xs) \\<longrightarrow>\n                   count_inv f (round index key p q r (u, ns, tl xs));\n        index_less index key; bn_inv p q (u, Suc 0 # ns, xs);\n        add_inv n (u, Suc 0 # ns, xs);\n        count_inv f (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "fix index p q r u ns xs n f and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n f.\n       \\<lbrakk>\\<And>n f.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   count_inv f (u, ns, tl xs) \\<longrightarrow>\n                   count_inv f (round index key p q r (u, ns, tl xs));\n        index_less index key; bn_inv p q (u, Suc 0 # ns, xs);\n        add_inv n (u, Suc 0 # ns, xs);\n        count_inv f (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?t = \"round index key p q r (u, ns, tl xs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n f.\n       \\<lbrakk>\\<And>n f.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   count_inv f (u, ns, tl xs) \\<longrightarrow>\n                   count_inv f (round index key p q r (u, ns, tl xs));\n        index_less index key; bn_inv p q (u, Suc 0 # ns, xs);\n        add_inv n (u, Suc 0 # ns, xs);\n        count_inv f (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n   \"\\<And>n f. bn_inv p q (u, ns, tl xs) \\<longrightarrow> add_inv n (u, ns, tl xs) \\<longrightarrow>\n      count_inv f (u, ns, tl xs) \\<longrightarrow> count_inv f ?t\" and\n   \"bn_inv p q (u, Suc 0 # ns, xs)\" and\n   \"add_inv n (u, Suc 0 # ns, xs)\" and\n   \"count_inv f (u, Suc 0 # ns, xs)\""], ["proof (state)\nthis:\n  bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n  add_inv ?n (u, ns, tl xs) \\<longrightarrow>\n  count_inv ?f (u, ns, tl xs) \\<longrightarrow>\n  count_inv ?f (round index key p q r (u, ns, tl xs))\n  bn_inv p q (u, Suc 0 # ns, xs)\n  add_inv n (u, Suc 0 # ns, xs)\n  count_inv f (u, Suc 0 # ns, xs)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n f.\n       \\<lbrakk>\\<And>n f.\n                   bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n                   add_inv n (u, ns, tl xs) \\<longrightarrow>\n                   count_inv f (u, ns, tl xs) \\<longrightarrow>\n                   count_inv f (round index key p q r (u, ns, tl xs));\n        index_less index key; bn_inv p q (u, Suc 0 # ns, xs);\n        add_inv n (u, Suc 0 # ns, xs);\n        count_inv f (u, Suc 0 # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc 0 # ns, xs))\n 2. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "thus \"count_inv f (round index key p q r (u, Suc 0 # ns, xs))\""], ["proof (prove)\nusing this:\n  bn_inv p q (u, ns, tl xs) \\<longrightarrow>\n  add_inv ?n (u, ns, tl xs) \\<longrightarrow>\n  count_inv ?f (u, ns, tl xs) \\<longrightarrow>\n  count_inv ?f (round index key p q r (u, ns, tl xs))\n  bn_inv p q (u, Suc 0 # ns, xs)\n  add_inv n (u, Suc 0 # ns, xs)\n  count_inv f (u, Suc 0 # ns, xs)\n\ngoal (1 subgoal):\n 1. count_inv f (round index key p q r (u, Suc 0 # ns, xs))", "proof (cases ?t, simp add: add_suc, rule_tac allI, cases xs,\n   simp_all add: disj_imp split: if_split_asm)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "fix y ys x and xs' :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "assume \"\\<And>n f. foldl (+) 0 ns = n \\<and> length ys = n \\<longrightarrow>\n      (\\<forall>x. count (mset ys) x = f x) \\<longrightarrow> (\\<forall>x. count (mset xs') x = f x)\""], ["proof (state)\nthis:\n  foldl (+) 0 ns = ?n \\<and> length ys = ?n \\<longrightarrow>\n  (\\<forall>x. count (mset ys) x = ?f x) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = ?f x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "moreover"], ["proof (state)\nthis:\n  foldl (+) 0 ns = ?n \\<and> length ys = ?n \\<longrightarrow>\n  (\\<forall>x. count (mset ys) x = ?f x) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = ?f x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "assume \"Suc (foldl (+) 0 ns) = n\" and \"Suc (length ys) = n\""], ["proof (state)\nthis:\n  Suc (foldl (+) 0 ns) = n\n  Suc (length ys) = n\n\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "ultimately"], ["proof (chain)\npicking this:\n  foldl (+) 0 ns = ?n \\<and> length ys = ?n \\<longrightarrow>\n  (\\<forall>x. count (mset ys) x = ?f x) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = ?f x)\n  Suc (foldl (+) 0 ns) = n\n  Suc (length ys) = n", "have \"\\<And>n f. (\\<forall>x. count (mset ys) x = f x) \\<longrightarrow>\n      (\\<forall>x. count (mset xs') x = f x)\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = ?n \\<and> length ys = ?n \\<longrightarrow>\n  (\\<forall>x. count (mset ys) x = ?f x) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = ?f x)\n  Suc (foldl (+) 0 ns) = n\n  Suc (length ys) = n\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<forall>x. count (mset ys) x = f x) \\<longrightarrow>\n       (\\<forall>x. count (mset xs') x = f x)", "by blast"], ["proof (state)\nthis:\n  (\\<forall>x. count (mset ys) x = ?f x) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = ?f x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x. count (mset ys) x = ?f x) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = ?f x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "assume A: \"\\<forall>x. (y = x \\<longrightarrow> Suc (count (mset ys) x) = f x) \\<and>\n      (y \\<noteq> x \\<longrightarrow> count (mset ys) x = f x)\""], ["proof (state)\nthis:\n  \\<forall>x.\n     (y = x \\<longrightarrow> Suc (count (mset ys) x) = f x) \\<and>\n     (y \\<noteq> x \\<longrightarrow> count (mset ys) x = f x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "have \"\\<forall>x. count (mset ys) x = (f(y := f y - Suc 0)) x\"\n      (is \"\\<forall>x. _ = ?f' x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. count (mset ys) x = (f(y := f y - Suc 0)) x", "by (simp add: A, insert spec [OF A, where x = y], simp)"], ["proof (state)\nthis:\n  \\<forall>x. count (mset ys) x = (f(y := f y - Suc 0)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x. count (mset ys) x = ?f x) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = ?f x)\n  \\<forall>x. count (mset ys) x = (f(y := f y - Suc 0)) x", "have \"\\<forall>x. count (mset xs') x = ?f' x\""], ["proof (prove)\nusing this:\n  (\\<forall>x. count (mset ys) x = ?f x) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = ?f x)\n  \\<forall>x. count (mset ys) x = (f(y := f y - Suc 0)) x\n\ngoal (1 subgoal):\n 1. \\<forall>x. count (mset xs') x = (f(y := f y - Suc 0)) x", ".."], ["proof (state)\nthis:\n  \\<forall>x. count (mset xs') x = (f(y := f y - Suc 0)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c x aa list.\n       \\<lbrakk>\\<forall>x.\n                   (aa = x \\<longrightarrow>\n                    Suc (count (mset list) x) = f x) \\<and>\n                   (aa \\<noteq> x \\<longrightarrow>\n                    count (mset list) x = f x);\n        round index key p q r (u, ns, list) = (a, b, c);\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> length list = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        foldl (+) (Suc 0) ns = n; xs = aa # list;\n        \\<And>n f.\n           foldl (+) 0 ns = n \\<and> n - Suc 0 = n \\<longrightarrow>\n           (\\<forall>x. count (mset list) x = f x) \\<longrightarrow>\n           (\\<forall>x. count (mset c) x = f x);\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; Suc (length list) = n\\<rbrakk>\n       \\<Longrightarrow> (aa = x \\<longrightarrow>\n                          Suc (count (mset c) x) = f x) \\<and>\n                         (aa \\<noteq> x \\<longrightarrow>\n                          count (mset c) x = f x)", "thus \"(y = x \\<longrightarrow> Suc (count (mset xs') x) = f x) \\<and>\n      (y \\<noteq> x \\<longrightarrow> count (mset xs') x = f x)\""], ["proof (prove)\nusing this:\n  \\<forall>x. count (mset xs') x = (f(y := f y - Suc 0)) x\n\ngoal (1 subgoal):\n 1. (y = x \\<longrightarrow> Suc (count (mset xs') x) = f x) \\<and>\n    (y \\<noteq> x \\<longrightarrow> count (mset xs') x = f x)", "by (simp, insert spec [OF A, where x = y], rule_tac impI, simp)"], ["proof (state)\nthis:\n  (y = x \\<longrightarrow> Suc (count (mset xs') x) = f x) \\<and>\n  (y \\<noteq> x \\<longrightarrow> count (mset xs') x = f x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count_inv f (round index key p q r (u, Suc 0 # ns, xs))\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "fix index p q r u m ns n f and key :: \"'a \\<Rightarrow> 'b\" and xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?ws = \"take (Suc (Suc m)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?ys = \"drop (Suc (Suc m)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?r = \"\\<lambda>m'. round_suc_suc index key ?ws m m' u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "let ?t = \"\\<lambda>r' v. round index key p q r' (v, ns, ?ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume A: \"index_less index key\""], ["proof (state)\nthis:\n  index_less index key\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "assume\n   \"\\<And>ws a b c d e g h i n f.\n      ws = ?ws \\<Longrightarrow> a = bn_comp m p q r \\<Longrightarrow> (b, c) = bn_comp m p q r \\<Longrightarrow>\n      d = ?r b \\<Longrightarrow> (e, g) = ?r b \\<Longrightarrow> (h, i) = g \\<Longrightarrow>\n        bn_inv p q (e, ns, ?ys) \\<longrightarrow> add_inv n (e, ns, ?ys) \\<longrightarrow>\n          count_inv f (e, ns, ?ys) \\<longrightarrow> count_inv f (?t c e)\" and\n   \"bn_inv p q (u, Suc (Suc m) # ns, xs)\" and\n   \"add_inv n (u, Suc (Suc m) # ns, xs)\" and\n   \"count_inv f (u, Suc (Suc m) # ns, xs)\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?g) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?h, ?i) = ?g\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    count_inv ?f\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    count_inv ?f\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  count_inv f (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na f.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb na f.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> bn_inv p q\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     add_inv na\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(xc, ns, drop (Suc (Suc n)) xs) \\<longrightarrow>\n                                     count_inv f\n(round index key p q y (xc, ns, drop (Suc (Suc n)) xs));\n        index_less index key; bn_inv p q (u, Suc (Suc n) # ns, xs);\n        add_inv na (u, Suc (Suc n) # ns, xs);\n        count_inv f (u, Suc (Suc n) # ns, xs)\\<rbrakk>\n       \\<Longrightarrow> count_inv f\n                          (round index key p q r (u, Suc (Suc n) # ns, xs))", "thus \"count_inv f (round index key p q r (u, Suc (Suc m) # ns, xs))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?g) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?h, ?i) = ?g\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    count_inv ?f\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    count_inv ?f\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  count_inv f (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. count_inv f (round index key p q r (u, Suc (Suc m) # ns, xs))", "using [[simproc del: defined_all]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = bn_comp m p q r;\n   (?b, ?c) = bn_comp m p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?e, ?g) = round_suc_suc index key (take (Suc (Suc m)) xs) m ?b u;\n   (?h, ?i) = ?g\\<rbrakk>\n  \\<Longrightarrow> bn_inv p q\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    add_inv ?n\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    count_inv ?f\n                     (?e, ns, drop (Suc (Suc m)) xs) \\<longrightarrow>\n                    count_inv ?f\n                     (round index key p q ?c\n                       (?e, ns, drop (Suc (Suc m)) xs))\n  bn_inv p q (u, Suc (Suc m) # ns, xs)\n  add_inv n (u, Suc (Suc m) # ns, xs)\n  count_inv f (u, Suc (Suc m) # ns, xs)\n\ngoal (1 subgoal):\n 1. count_inv f (round index key p q r (u, Suc (Suc m) # ns, xs))", "proof (simp split: prod.split, ((rule_tac allI)+, ((rule_tac impI)+)?)+,\n   (erule_tac conjE)+, subst (asm) (2) add_base_zero, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba x.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>x.\n   count (mset (drop (Suc (Suc m)) xs)) x = f x) \\<longrightarrow>\n                                     (\\<forall>x. count (mset ba) x = f x);\n        \\<forall>x. count (mset xs) x = f x; foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> count (mset b) x + count (mset ba) x = f x", "fix m' r' v ms' ws' xs' x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba x.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>x.\n   count (mset (drop (Suc (Suc m)) xs)) x = f x) \\<longrightarrow>\n                                     (\\<forall>x. count (mset ba) x = f x);\n        \\<forall>x. count (mset xs) x = f x; foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> count (mset b) x + count (mset ba) x = f x", "assume\n      B: \"?r m' = (v, ms', ws')\" and\n      C: \"bn_comp m p q r = (m', r')\" and\n      D: \"bn_valid m p q\" and\n      E: \"Suc (Suc (foldl (+) 0 ns + m)) = n\" and\n      F: \"length xs = n\""], ["proof (state)\nthis:\n  round_suc_suc index key (take (Suc (Suc m)) xs) m m' u = (v, ms', ws')\n  bn_comp m p q r = (m', r')\n  bn_valid m p q\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba x.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>x.\n   count (mset (drop (Suc (Suc m)) xs)) x = f x) \\<longrightarrow>\n                                     (\\<forall>x. count (mset ba) x = f x);\n        \\<forall>x. count (mset xs) x = f x; foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> count (mset b) x + count (mset ba) x = f x", "assume \"\\<And>ws a b c d e g h i n' f.\n      ws = ?ws \\<Longrightarrow> a = (m', r') \\<Longrightarrow> b = m' \\<and> c = r' \\<Longrightarrow>\n      d = (v, ms', ws') \\<Longrightarrow> e = v \\<and> g = (ms', ws') \\<Longrightarrow> h = ms' \\<and> i = ws' \\<Longrightarrow>\n        foldl (+) 0 ns = n' \\<and> n - Suc (Suc m) = n' \\<longrightarrow>\n          (\\<forall>x. count (mset ?ys) x = f x) \\<longrightarrow> (\\<forall>x. count (mset xs') x = f x)\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?g = (ms', ws'); ?h = ms' \\<and> ?i = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    (\\<forall>x.\n                        count (mset (drop (Suc (Suc m)) xs)) x =\n                        ?f x) \\<longrightarrow>\n                    (\\<forall>x. count (mset xs') x = ?f x)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba x.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>x.\n   count (mset (drop (Suc (Suc m)) xs)) x = f x) \\<longrightarrow>\n                                     (\\<forall>x. count (mset ba) x = f x);\n        \\<forall>x. count (mset xs) x = f x; foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> count (mset b) x + count (mset ba) x = f x", "hence \"foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow>\n      (\\<forall>x. count (mset xs') x = count (mset ?ys) x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?g = (ms', ws'); ?h = ms' \\<and> ?i = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    (\\<forall>x.\n                        count (mset (drop (Suc (Suc m)) xs)) x =\n                        ?f x) \\<longrightarrow>\n                    (\\<forall>x. count (mset xs') x = ?f x)\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow>\n    (\\<forall>x.\n        count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x)", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba x.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>x.\n   count (mset (drop (Suc (Suc m)) xs)) x = f x) \\<longrightarrow>\n                                     (\\<forall>x. count (mset ba) x = f x);\n        \\<forall>x. count (mset xs) x = f x; foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> count (mset b) x + count (mset ba) x = f x", "hence \"count (mset xs') x = count (mset ?ys) x\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x)\n\ngoal (1 subgoal):\n 1. count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x", "using E"], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = n - Suc (Suc m) \\<longrightarrow>\n  (\\<forall>x. count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x)\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n\ngoal (1 subgoal):\n 1. count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x", "by simp"], ["proof (state)\nthis:\n  count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba x.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>x.\n   count (mset (drop (Suc (Suc m)) xs)) x = f x) \\<longrightarrow>\n                                     (\\<forall>x. count (mset ba) x = f x);\n        \\<forall>x. count (mset xs) x = f x; foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> count (mset b) x + count (mset ba) x = f x", "moreover"], ["proof (state)\nthis:\n  count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba x.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>x.\n   count (mset (drop (Suc (Suc m)) xs)) x = f x) \\<longrightarrow>\n                                     (\\<forall>x. count (mset ba) x = f x);\n        \\<forall>x. count (mset xs) x = f x; foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> count (mset b) x + count (mset ba) x = f x", "assume \"\\<forall>x. count (mset xs) x = f x\""], ["proof (state)\nthis:\n  \\<forall>x. count (mset xs) x = f x\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba x.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>x.\n   count (mset (drop (Suc (Suc m)) xs)) x = f x) \\<longrightarrow>\n                                     (\\<forall>x. count (mset ba) x = f x);\n        \\<forall>x. count (mset xs) x = f x; foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> count (mset b) x + count (mset ba) x = f x", "ultimately"], ["proof (chain)\npicking this:\n  count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x\n  \\<forall>x. count (mset xs) x = f x", "have \"f x = count (mset ?ws) x + count (mset xs') x\""], ["proof (prove)\nusing this:\n  count (mset xs') x = count (mset (drop (Suc (Suc m)) xs)) x\n  \\<forall>x. count (mset xs) x = f x\n\ngoal (1 subgoal):\n 1. f x = count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x", "by (subst (asm) append_take_drop_id [of \"Suc (Suc m)\", symmetric],\n       subst (asm) mset_append, simp)"], ["proof (state)\nthis:\n  f x = count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a a b x1b aa ba x.\n       \\<lbrakk>\\<And>ws aa baa c d e g h i n f.\n                   \\<lbrakk>ws = take (Suc (Suc m)) xs; aa = (x1, x2);\n                    baa = x1 \\<and> c = x2; d = (x1a, a, b);\n                    e = x1a \\<and> g = (a, b); h = a \\<and> i = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = n \\<and>\n                                     n - Suc (Suc m) = n \\<longrightarrow>\n                                     (\\<forall>x.\n   count (mset (drop (Suc (Suc m)) xs)) x = f x) \\<longrightarrow>\n                                     (\\<forall>x. count (mset ba) x = f x);\n        \\<forall>x. count (mset xs) x = f x; foldl (+) (Suc (Suc m)) ns = n;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc m)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc m)) xs) m x1 u =\n        (x1a, a, b);\n        bn_comp m p q r = (x1, x2); bn_valid m p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) 0 ns + m)) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> count (mset b) x + count (mset ba) x = f x", "with B [symmetric]"], ["proof (chain)\npicking this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\n  f x = count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x", "show \"count (mset ws') x + count (mset xs') x = f x\""], ["proof (prove)\nusing this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc m)) xs) m m' u\n  f x = count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\n\ngoal (1 subgoal):\n 1. count (mset ws') x + count (mset xs') x = f x", "proof (simp add: round_suc_suc_def Let_def del: count_add_mset mset_map\n     split: if_split_asm, subst (1 2) add_mset_add_single, simp\n     only: count_single count_union)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?nmi = \"mini ?ws key\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?nma = \"maxi ?ws key\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?xmi = \"?ws ! ?nmi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?xma = \"?ws ! ?nma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?mi = \"key ?xmi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?ma = \"key ?xma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?k = \"case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m | Suc (Suc i) \\<Rightarrow> u + m'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?zs = \"nths ?ws (- {?nmi, ?nma})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?ms = \"enum ?zs index key ?k ?mi ?ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "let ?A = \"{i. i < Suc (Suc m) \\<and> (i = ?nmi \\<or> i = ?nma) \\<and> ?ws ! i = x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "have G: \"length ?ws = Suc (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc (Suc m)) xs) = Suc (Suc m)", "using E and F"], ["proof (prove)\nusing this:\n  Suc (Suc (foldl (+) 0 ns + m)) = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. length (take (Suc (Suc m)) xs) = Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "hence H: \"card ?A \\<le> count (mset ?ws) x\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. card\n     {i. i < Suc (Suc m) \\<and>\n         (i = mini (take (Suc (Suc m)) xs) key \\<or>\n          i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n         take (Suc (Suc m)) xs ! i = x}\n    \\<le> count (mset (take (Suc (Suc m)) xs)) x", "by (simp add: count_mset length_filter_conv_card, rule_tac card_mono,\n         simp, blast)"], ["proof (state)\nthis:\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n  \\<le> count (mset (take (Suc (Suc m)) xs)) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x =\n             count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x;\n     key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key) \\<noteq>\n     key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     v =\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') \\<and>\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] \\<and>\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     (u + m' -\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m'),\n      Suc 0 #\n      enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n      [Suc 0],\n      take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n      map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n      [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]) =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     True;\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u;\n     f x =\n     count (mset (take (Suc (Suc m)) xs)) x + count (mset xs') x\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset\n                         (map the\n                           (fill\n                             (nths (take (Suc (Suc m)) xs)\n                               (- {mini (take (Suc (Suc m)) xs) key,\n                                   maxi (take (Suc (Suc m)) xs) key}))\n                             (offs\n                               (enum\n                                 (nths (take (Suc (Suc m)) xs)\n                                   (- {mini (take (Suc (Suc m)) xs) key,\n maxi (take (Suc (Suc m)) xs) key}))\n                                 index key\n                                 (case m of 0 \\<Rightarrow> m\n                                  | Suc 0 \\<Rightarrow> m\n                                  | Suc (Suc i) \\<Rightarrow> u + m')\n                                 (key (take (Suc (Suc m)) xs !\n mini (take (Suc (Suc m)) xs) key))\n                                 (key (take (Suc (Suc m)) xs !\n maxi (take (Suc (Suc m)) xs) key)))\n                               0)\n                             index key m\n                             (key (take (Suc (Suc m)) xs !\n                                   mini (take (Suc (Suc m)) xs) key))\n                             (key (take (Suc (Suc m)) xs !\n                                   maxi (take (Suc (Suc m)) xs) key)))))\n                       x +\n                      (if take (Suc (Suc m)) xs !\n                          maxi (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) +\n                      (if take (Suc (Suc m)) xs !\n                          mini (take (Suc (Suc m)) xs) key =\n                          x\n                       then 1 else 0) =\n                      count (mset (take (Suc (Suc m)) xs)) x", "show \"count (mset (map the (fill ?zs (offs ?ms 0) index key m ?mi ?ma))) x\n        + (if ?xma = x then 1 else 0) + (if ?xmi = x then 1 else 0) =\n        count (mset ?ws) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "proof (cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "case True"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "hence I: \"length ?zs = 0\""], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. length\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})) =\n    0", "using G"], ["proof (prove)\nusing this:\n  m = 0\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. length\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})) =\n    0", "by (simp add: mini_maxi_nths)"], ["proof (state)\nthis:\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "have \"count (mset ?zs) x = count (mset ?ws) x - card ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count\n     (mset\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key})))\n     x =\n    count (mset (take (Suc (Suc m)) xs)) x -\n    card\n     {i. i < Suc (Suc m) \\<and>\n         (i = mini (take (Suc (Suc m)) xs) key \\<or>\n          i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n         take (Suc (Suc m)) xs ! i = x}", "using G"], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key})))\n     x =\n    count (mset (take (Suc (Suc m)) xs)) x -\n    card\n     {i. i < Suc (Suc m) \\<and>\n         (i = mini (take (Suc (Suc m)) xs) key \\<or>\n          i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n         take (Suc (Suc m)) xs ! i = x}", "by (subst nths_count, simp)"], ["proof (state)\nthis:\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   x =\n  count (mset (take (Suc (Suc m)) xs)) x -\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "hence J: \"count (mset ?ws) x = card ?A\""], ["proof (prove)\nusing this:\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   x =\n  count (mset (take (Suc (Suc m)) xs)) x -\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n\ngoal (1 subgoal):\n 1. count (mset (take (Suc (Suc m)) xs)) x =\n    card\n     {i. i < Suc (Suc m) \\<and>\n         (i = mini (take (Suc (Suc m)) xs) key \\<or>\n          i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n         take (Suc (Suc m)) xs ! i = x}", "using H and I"], ["proof (prove)\nusing this:\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   x =\n  count (mset (take (Suc (Suc m)) xs)) x -\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n  \\<le> count (mset (take (Suc (Suc m)) xs)) x\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  0\n\ngoal (1 subgoal):\n 1. count (mset (take (Suc (Suc m)) xs)) x =\n    card\n     {i. i < Suc (Suc m) \\<and>\n         (i = mini (take (Suc (Suc m)) xs) key \\<or>\n          i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n         take (Suc (Suc m)) xs ! i = x}", "by simp"], ["proof (state)\nthis:\n  count (mset (take (Suc (Suc m)) xs)) x =\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "from I"], ["proof (chain)\npicking this:\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  0\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "proof (simp, (rule_tac [!] conjI, rule_tac [!] impI)+,\n         simp_all (no_asm_simp) add: True)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc 0) = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 3. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 4. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "assume \"?xmi = x\" and \"?xma = x\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x\n\ngoal (4 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc 0) = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 3. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 4. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "with G"], ["proof (chain)\npicking this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x", "have \"?A = {?nmi, ?nma}\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x\n\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc m) \\<and>\n        (i = mini (take (Suc (Suc m)) xs) key \\<or>\n         i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n        take (Suc (Suc m)) xs ! i = x} =\n    {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}", "by (rule_tac set_eqI, rule_tac iffI, simp_all, erule_tac disjE,\n             insert mini_less [of ?ws key], insert maxi_less [of ?ws key],\n             simp_all)"], ["proof (state)\nthis:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc 0) = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 3. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 4. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "with G"], ["proof (chain)\npicking this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}", "have \"card ?A = Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}\n\ngoal (1 subgoal):\n 1. card\n     {i. i < Suc (Suc m) \\<and>\n         (i = mini (take (Suc (Suc m)) xs) key \\<or>\n          i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n         take (Suc (Suc m)) xs ! i = x} =\n    Suc (Suc 0)", "by (simp, subst card_insert_disjoint, simp_all,\n             rule_tac mini_maxi_neq, simp)"], ["proof (state)\nthis:\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x} =\n  Suc (Suc 0)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc 0) = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 3. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 4. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "thus \"Suc (Suc 0) = count (mset (take (Suc (Suc 0)) xs)) x\""], ["proof (prove)\nusing this:\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x} =\n  Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. Suc (Suc 0) = count (mset (take (Suc (Suc 0)) xs)) x", "using True and J"], ["proof (prove)\nusing this:\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x} =\n  Suc (Suc 0)\n  m = 0\n  count (mset (take (Suc (Suc m)) xs)) x =\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n\ngoal (1 subgoal):\n 1. Suc (Suc 0) = count (mset (take (Suc (Suc 0)) xs)) x", "by simp"], ["proof (state)\nthis:\n  Suc (Suc 0) = count (mset (take (Suc (Suc 0)) xs)) x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 3. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 3. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "assume \"?xmi \\<noteq> x\" and \"?xma = x\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 3. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "with G"], ["proof (chain)\npicking this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x", "have \"?A = {?nma}\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x\n\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc m) \\<and>\n        (i = mini (take (Suc (Suc m)) xs) key \\<or>\n         i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n        take (Suc (Suc m)) xs ! i = x} =\n    {maxi (take (Suc (Suc m)) xs) key}", "by (rule_tac set_eqI, rule_tac iffI, simp_all, (erule_tac conjE)+,\n             erule_tac disjE, insert maxi_less [of ?ws key], simp_all)"], ["proof (state)\nthis:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {maxi (take (Suc (Suc m)) xs) key}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 3. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "thus \"Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\""], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {maxi (take (Suc (Suc m)) xs) key}\n\ngoal (1 subgoal):\n 1. Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x", "using True and J"], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {maxi (take (Suc (Suc m)) xs) key}\n  m = 0\n  count (mset (take (Suc (Suc m)) xs)) x =\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n\ngoal (1 subgoal):\n 1. Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x", "by simp"], ["proof (state)\nthis:\n  Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "assume \"?xmi = x\" and \"?xma \\<noteq> x\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "with G"], ["proof (chain)\npicking this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x", "have \"?A = {?nmi}\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x\n\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc m) \\<and>\n        (i = mini (take (Suc (Suc m)) xs) key \\<or>\n         i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n        take (Suc (Suc m)) xs ! i = x} =\n    {mini (take (Suc (Suc m)) xs) key}", "by (rule_tac set_eqI, rule_tac iffI, simp_all, (erule_tac conjE)+,\n             erule_tac disjE, insert mini_less [of ?ws key], simp_all)"], ["proof (state)\nthis:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n 2. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "thus \"Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\""], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key}\n\ngoal (1 subgoal):\n 1. Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x", "using True and J"], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key}\n  m = 0\n  count (mset (take (Suc (Suc m)) xs)) x =\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n\ngoal (1 subgoal):\n 1. Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x", "by simp"], ["proof (state)\nthis:\n  Suc 0 = count (mset (take (Suc (Suc 0)) xs)) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "assume \"?xmi \\<noteq> x\" and \"?xma \\<noteq> x\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "hence \"?A = {}\""], ["proof (prove)\nusing this:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x\n\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc m) \\<and>\n        (i = mini (take (Suc (Suc m)) xs) key \\<or>\n         i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n        take (Suc (Suc m)) xs ! i = x} =\n    {}", "by (rule_tac set_eqI, rule_tac iffI, simp_all, (erule_tac conjE)+,\n             erule_tac disjE, simp_all)"], ["proof (state)\nthis:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "hence \"count (mset ?ws) x = 0\""], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {}\n\ngoal (1 subgoal):\n 1. count (mset (take (Suc (Suc m)) xs)) x = 0", "using J"], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {}\n  count (mset (take (Suc (Suc m)) xs)) x =\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n\ngoal (1 subgoal):\n 1. count (mset (take (Suc (Suc m)) xs)) x = 0", "by simp"], ["proof (state)\nthis:\n  count (mset (take (Suc (Suc m)) xs)) x = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}) =\n             [];\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x;\n     length\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key})) =\n     0\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take (Suc (Suc 0)) xs)", "thus \"x \\<notin> set (take (Suc (Suc 0)) xs)\""], ["proof (prove)\nusing this:\n  count (mset (take (Suc (Suc m)) xs)) x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> set (take (Suc (Suc 0)) xs)", "using True"], ["proof (prove)\nusing this:\n  count (mset (take (Suc (Suc m)) xs)) x = 0\n  m = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> set (take (Suc (Suc 0)) xs)", "by simp"], ["proof (state)\nthis:\n  x \\<notin> set (take (Suc (Suc 0)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   x +\n  (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n   else 0) +\n  (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n   else 0) =\n  count (mset (take (Suc (Suc m)) xs)) x\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "case False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "hence \"0 < ?k\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')", "by (simp, drule_tac bn_comp_fst_nonzero [OF D], subst (asm) C,\n           simp split: nat.split)"], ["proof (state)\nthis:\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "hence \"count (mset (map the (fill ?zs (offs ?ms 0) index key\n          (length ?zs) ?mi ?ma))) x = count (mset ?zs) x\""], ["proof (prove)\nusing this:\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key\n           (length\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key})))\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x =\n    count\n     (mset\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key})))\n     x", "by (rule_tac fill_offs_enum_count_item [OF A], simp, rule_tac conjI,\n           ((rule_tac mini_lb | rule_tac maxi_ub), erule_tac in_set_nthsD)+)"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key\n         (length\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key})))\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   x =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   x\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "with G"], ["proof (chain)\npicking this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key\n         (length\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key})))\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   x =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   x", "show ?thesis"], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key\n         (length\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key})))\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   x =\n  count\n   (mset\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})))\n   x\n\ngoal (1 subgoal):\n 1. count\n     (mset\n       (map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key)))))\n     x +\n    (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n     else 0) +\n    (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n     else 0) =\n    count (mset (take (Suc (Suc m)) xs)) x", "proof (simp, (rule_tac [!] conjI, rule_tac [!] impI)+,\n         simp_all add: mini_maxi_nths nths_count)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x) (key x))\n              0)\n            index key m (key x) (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                                card\n                                 {i. i < Suc (Suc m) \\<and>\n                                     (i =\nmini (take (Suc (Suc m)) xs) key \\<or>\ni = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                     take (Suc (Suc m)) xs ! i = x})) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key x))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 3. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 4. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "assume \"?xmi = x\" and \"?xma = x\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x\n\ngoal (4 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x) (key x))\n              0)\n            index key m (key x) (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                                card\n                                 {i. i < Suc (Suc m) \\<and>\n                                     (i =\nmini (take (Suc (Suc m)) xs) key \\<or>\ni = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                     take (Suc (Suc m)) xs ! i = x})) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key x))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 3. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 4. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "with G"], ["proof (chain)\npicking this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x", "have \"?A = {?nmi, ?nma}\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x\n\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc m) \\<and>\n        (i = mini (take (Suc (Suc m)) xs) key \\<or>\n         i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n        take (Suc (Suc m)) xs ! i = x} =\n    {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}", "by (rule_tac set_eqI, rule_tac iffI, simp_all, erule_tac disjE,\n             insert mini_less [of ?ws key], insert maxi_less [of ?ws key],\n             simp_all)"], ["proof (state)\nthis:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x) (key x))\n              0)\n            index key m (key x) (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                                card\n                                 {i. i < Suc (Suc m) \\<and>\n                                     (i =\nmini (take (Suc (Suc m)) xs) key \\<or>\ni = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                     take (Suc (Suc m)) xs ! i = x})) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key x))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 3. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 4. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "with G"], ["proof (chain)\npicking this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}", "have \"card ?A = Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}\n\ngoal (1 subgoal):\n 1. card\n     {i. i < Suc (Suc m) \\<and>\n         (i = mini (take (Suc (Suc m)) xs) key \\<or>\n          i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n         take (Suc (Suc m)) xs ! i = x} =\n    Suc (Suc 0)", "by (simp, subst card_insert_disjoint, simp_all,\n             rule_tac mini_maxi_neq, simp)"], ["proof (state)\nthis:\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x} =\n  Suc (Suc 0)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x) (key x))\n              0)\n            index key m (key x) (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                                card\n                                 {i. i < Suc (Suc m) \\<and>\n                                     (i =\nmini (take (Suc (Suc m)) xs) key \\<or>\ni = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                     take (Suc (Suc m)) xs ! i = x})) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key x))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 3. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 4. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "thus \"Suc (Suc (count (mset ?ws) x - card ?A)) = count (mset ?ws) x\""], ["proof (prove)\nusing this:\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x} =\n  Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. Suc (Suc (count (mset (take (Suc (Suc m)) xs)) x -\n              card\n               {i. i < Suc (Suc m) \\<and>\n                   (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                    i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                   take (Suc (Suc m)) xs ! i = x})) =\n    count (mset (take (Suc (Suc m)) xs)) x", "using H"], ["proof (prove)\nusing this:\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x} =\n  Suc (Suc 0)\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n  \\<le> count (mset (take (Suc (Suc m)) xs)) x\n\ngoal (1 subgoal):\n 1. Suc (Suc (count (mset (take (Suc (Suc m)) xs)) x -\n              card\n               {i. i < Suc (Suc m) \\<and>\n                   (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                    i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                   take (Suc (Suc m)) xs ! i = x})) =\n    count (mset (take (Suc (Suc m)) xs)) x", "by simp"], ["proof (state)\nthis:\n  Suc (Suc (count (mset (take (Suc (Suc m)) xs)) x -\n            card\n             {i. i < Suc (Suc m) \\<and>\n                 (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                  i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                 take (Suc (Suc m)) xs ! i = x})) =\n  count (mset (take (Suc (Suc m)) xs)) x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key x))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 3. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key x))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 3. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "assume \"?xmi \\<noteq> x\" and \"?xma = x\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key x))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 3. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "with G"], ["proof (chain)\npicking this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x", "have \"?A = {?nma}\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x\n\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc m) \\<and>\n        (i = mini (take (Suc (Suc m)) xs) key \\<or>\n         i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n        take (Suc (Suc m)) xs ! i = x} =\n    {maxi (take (Suc (Suc m)) xs) key}", "by (rule_tac set_eqI, rule_tac iffI, simp_all, (erule_tac conjE)+,\n             erule_tac disjE, insert maxi_less [of ?ws key], simp_all)"], ["proof (state)\nthis:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {maxi (take (Suc (Suc m)) xs) key}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key x))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key x))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 3. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "thus \"Suc (count (mset ?ws) x - card ?A) = count (mset ?ws) x\""], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {maxi (take (Suc (Suc m)) xs) key}\n\ngoal (1 subgoal):\n 1. Suc (count (mset (take (Suc (Suc m)) xs)) x -\n         card\n          {i. i < Suc (Suc m) \\<and>\n              (i = mini (take (Suc (Suc m)) xs) key \\<or>\n               i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n              take (Suc (Suc m)) xs ! i = x}) =\n    count (mset (take (Suc (Suc m)) xs)) x", "using H"], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {maxi (take (Suc (Suc m)) xs) key}\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n  \\<le> count (mset (take (Suc (Suc m)) xs)) x\n\ngoal (1 subgoal):\n 1. Suc (count (mset (take (Suc (Suc m)) xs)) x -\n         card\n          {i. i < Suc (Suc m) \\<and>\n              (i = mini (take (Suc (Suc m)) xs) key \\<or>\n               i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n              take (Suc (Suc m)) xs ! i = x}) =\n    count (mset (take (Suc (Suc m)) xs)) x", "by simp"], ["proof (state)\nthis:\n  Suc (count (mset (take (Suc (Suc m)) xs)) x -\n       card\n        {i. i < Suc (Suc m) \\<and>\n            (i = mini (take (Suc (Suc m)) xs) key \\<or>\n             i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n            take (Suc (Suc m)) xs ! i = x}) =\n  count (mset (take (Suc (Suc m)) xs)) x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "assume \"?xmi = x\" and \"?xma \\<noteq> x\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "with G"], ["proof (chain)\npicking this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x", "have \"?A = {?nmi}\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x\n\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc m) \\<and>\n        (i = mini (take (Suc (Suc m)) xs) key \\<or>\n         i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n        take (Suc (Suc m)) xs ! i = x} =\n    {mini (take (Suc (Suc m)) xs) key}", "by (rule_tac set_eqI, rule_tac iffI, simp_all, (erule_tac conjE)+,\n             erule_tac disjE, insert mini_less [of ?ws key], simp_all)"], ["proof (state)\nthis:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key x)\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m (key x)\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x\\<rbrakk>\n    \\<Longrightarrow> Suc (count (mset (take (Suc (Suc m)) xs)) x -\n                           card\n                            {i. i < Suc (Suc m) \\<and>\n                                (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                                 i =\n                                 maxi (take (Suc (Suc m)) xs) key) \\<and>\n                                take (Suc (Suc m)) xs ! i = x}) =\n                      count (mset (take (Suc (Suc m)) xs)) x\n 2. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "thus \"Suc (count (mset ?ws) x - card ?A) = count (mset ?ws) x\""], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key}\n\ngoal (1 subgoal):\n 1. Suc (count (mset (take (Suc (Suc m)) xs)) x -\n         card\n          {i. i < Suc (Suc m) \\<and>\n              (i = mini (take (Suc (Suc m)) xs) key \\<or>\n               i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n              take (Suc (Suc m)) xs ! i = x}) =\n    count (mset (take (Suc (Suc m)) xs)) x", "using H"], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {mini (take (Suc (Suc m)) xs) key}\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x}\n  \\<le> count (mset (take (Suc (Suc m)) xs)) x\n\ngoal (1 subgoal):\n 1. Suc (count (mset (take (Suc (Suc m)) xs)) x -\n         card\n          {i. i < Suc (Suc m) \\<and>\n              (i = mini (take (Suc (Suc m)) xs) key \\<or>\n               i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n              take (Suc (Suc m)) xs ! i = x}) =\n    count (mset (take (Suc (Suc m)) xs)) x", "by simp"], ["proof (state)\nthis:\n  Suc (count (mset (take (Suc (Suc m)) xs)) x -\n       card\n        {i. i < Suc (Suc m) \\<and>\n            (i = mini (take (Suc (Suc m)) xs) key \\<or>\n             i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n            take (Suc (Suc m)) xs ! i = x}) =\n  count (mset (take (Suc (Suc m)) xs)) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "assume \"?xmi \\<noteq> x\" and \"?xma \\<noteq> x\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "hence \"?A = {}\""], ["proof (prove)\nusing this:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq> x\n  take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x\n\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc m) \\<and>\n        (i = mini (take (Suc (Suc m)) xs) key \\<or>\n         i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n        take (Suc (Suc m)) xs ! i = x} =\n    {}", "by (rule_tac set_eqI, rule_tac iffI, simp_all, (erule_tac conjE)+,\n             erule_tac disjE, simp_all)"], ["proof (state)\nthis:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>min (length xs) (Suc (Suc m)) = Suc (Suc m);\n     count\n      (image_mset the\n        (mset\n          (fill\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc m)) xs)\n                  (- {mini (take (Suc (Suc m)) xs) key,\n                      maxi (take (Suc (Suc m)) xs) key}))\n                index key\n                (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                 | Suc (Suc i) \\<Rightarrow> u + m')\n                (key (take (Suc (Suc m)) xs !\n                      mini (take (Suc (Suc m)) xs) key))\n                (key (take (Suc (Suc m)) xs !\n                      maxi (take (Suc (Suc m)) xs) key)))\n              0)\n            index key m\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))))\n      x =\n     count (mset (take (Suc (Suc m)) xs)) x -\n     card\n      {i. i < Suc (Suc m) \\<and>\n          (i = mini (take (Suc (Suc m)) xs) key \\<or>\n           i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n          take (Suc (Suc m)) xs ! i = x};\n     take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key \\<noteq> x;\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key \\<noteq>\n     x\\<rbrakk>\n    \\<Longrightarrow> count (mset (take (Suc (Suc m)) xs)) x -\n                      card\n                       {i. i < Suc (Suc m) \\<and>\n                           (i = mini (take (Suc (Suc m)) xs) key \\<or>\n                            i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n                           take (Suc (Suc m)) xs ! i = x} =\n                      count (mset (take (Suc (Suc m)) xs)) x", "thus \"count (mset ?ws) x - card ?A = count (mset ?ws) x\""], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc m) \\<and>\n      (i = mini (take (Suc (Suc m)) xs) key \\<or>\n       i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n      take (Suc (Suc m)) xs ! i = x} =\n  {}\n\ngoal (1 subgoal):\n 1. count (mset (take (Suc (Suc m)) xs)) x -\n    card\n     {i. i < Suc (Suc m) \\<and>\n         (i = mini (take (Suc (Suc m)) xs) key \\<or>\n          i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n         take (Suc (Suc m)) xs ! i = x} =\n    count (mset (take (Suc (Suc m)) xs)) x", "by (simp (no_asm_simp))"], ["proof (state)\nthis:\n  count (mset (take (Suc (Suc m)) xs)) x -\n  card\n   {i. i < Suc (Suc m) \\<and>\n       (i = mini (take (Suc (Suc m)) xs) key \\<or>\n        i = maxi (take (Suc (Suc m)) xs) key) \\<and>\n       take (Suc (Suc m)) xs ! i = x} =\n  count (mset (take (Suc (Suc m)) xs)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   x +\n  (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n   else 0) +\n  (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n   else 0) =\n  count (mset (take (Suc (Suc m)) xs)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count\n   (mset\n     (map the\n       (fill\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         (offs\n           (enum\n             (nths (take (Suc (Suc m)) xs)\n               (- {mini (take (Suc (Suc m)) xs) key,\n                   maxi (take (Suc (Suc m)) xs) key}))\n             index key\n             (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n              | Suc (Suc i) \\<Rightarrow> u + m')\n             (key (take (Suc (Suc m)) xs !\n                   mini (take (Suc (Suc m)) xs) key))\n             (key (take (Suc (Suc m)) xs !\n                   maxi (take (Suc (Suc m)) xs) key)))\n           0)\n         index key m\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))))\n   x +\n  (if take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key = x then 1\n   else 0) +\n  (if take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key = x then 1\n   else 0) =\n  count (mset (take (Suc (Suc m)) xs)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count (mset ws') x + count (mset xs') x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count_inv f (round index key p q r (u, Suc (Suc m) # ns, xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcsort_count_inv:\n  assumes\n    A: \"index_less index key\" and\n    B: \"add_inv n t\" and\n    C: \"n \\<le> p\"\n  shows \"\\<lbrakk>t' \\<in> gcsort_set index key p t; count_inv f t\\<rbrakk> \\<Longrightarrow>\n    count_inv f t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in> gcsort_set index key p t; count_inv f t\\<rbrakk>\n    \\<Longrightarrow> count_inv f t'", "by (erule gcsort_set.induct, simp, drule gcsort_add_inv [OF A _ B C],\n rule round_count_inv [OF A], simp_all del: bn_inv.simps, erule conjE,\n frule sym, erule subst, rule bn_inv_intro, insert C, simp)"], ["", "text \\<open>\n\\null\n\nThe only remaining task is to address step 10 of the proof method, which is done by proving theorem\n@{text gcsort_count}. It holds under the conditions that the objects' number is not larger than the\ncounters' upper bound and function @{text index} satisfies predicate @{const index_less}, and states\nthat for any object, function @{const gcsort} leaves unchanged the number of its occurrences within\nthe input objects' list.\n\n\\null\n\\<close>"], ["", "theorem gcsort_count:\n  assumes\n    A: \"index_less index key\" and\n    B: \"length xs \\<le> p\"\n  shows \"count (mset (gcsort index key p xs)) x = count (mset xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (mset (gcsort index key p xs)) x = count (mset xs) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. count (mset (gcsort index key p xs)) x = count (mset xs) x", "let ?t = \"(0, [length xs], xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. count (mset (gcsort index key p xs)) x = count (mset xs) x", "have \"count_inv (count (mset xs)) (gcsort_aux index key p ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_inv (count (mset xs))\n     (gcsort_aux index key p (0, [length xs], xs))", "by (rule gcsort_count_inv [OF A _ B], rule gcsort_add_input,\n     rule gcsort_aux_set, rule gcsort_count_input)"], ["proof (state)\nthis:\n  count_inv (count (mset xs)) (gcsort_aux index key p (0, [length xs], xs))\n\ngoal (1 subgoal):\n 1. count (mset (gcsort index key p xs)) x = count (mset xs) x", "hence \"count (mset (gcsort_out (gcsort_aux index key p ?t))) x =\n    (count (mset xs)) x\""], ["proof (prove)\nusing this:\n  count_inv (count (mset xs)) (gcsort_aux index key p (0, [length xs], xs))\n\ngoal (1 subgoal):\n 1. count (mset (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))\n     x =\n    count (mset xs) x", "by (rule gcsort_count_intro)"], ["proof (state)\nthis:\n  count (mset (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))\n   x =\n  count (mset xs) x\n\ngoal (1 subgoal):\n 1. count (mset (gcsort index key p xs)) x = count (mset xs) x", "moreover"], ["proof (state)\nthis:\n  count (mset (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))\n   x =\n  count (mset xs) x\n\ngoal (1 subgoal):\n 1. count (mset (gcsort index key p xs)) x = count (mset xs) x", "have \"?t = gcsort_in xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0, [length xs], xs) = gcsort_in xs", "by (simp add: gcsort_in_def)"], ["proof (state)\nthis:\n  (0, [length xs], xs) = gcsort_in xs\n\ngoal (1 subgoal):\n 1. count (mset (gcsort index key p xs)) x = count (mset xs) x", "ultimately"], ["proof (chain)\npicking this:\n  count (mset (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))\n   x =\n  count (mset xs) x\n  (0, [length xs], xs) = gcsort_in xs", "show ?thesis"], ["proof (prove)\nusing this:\n  count (mset (gcsort_out (gcsort_aux index key p (0, [length xs], xs))))\n   x =\n  count (mset xs) x\n  (0, [length xs], xs) = gcsort_in xs\n\ngoal (1 subgoal):\n 1. count (mset (gcsort index key p xs)) x = count (mset xs) x", "by (simp add: gcsort_def)"], ["proof (state)\nthis:\n  count (mset (gcsort index key p xs)) x = count (mset xs) x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}