{"file_name": "/home/qj213/afp-2021-10-22/thys/Generalized_Counting_Sort/Algorithm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Generalized_Counting_Sort", "problem_names": ["lemma add_zeros:\n \"foldl (+) (m :: nat) (replicate n 0) = m\"", "lemma add_suc:\n \"foldl (+) (Suc m) ns = Suc (foldl (+) m ns)\"", "lemma add_update:\n \"i < length ns \\<Longrightarrow> foldl (+) m (ns[i := Suc (ns ! i)]) = Suc (foldl (+) m ns)\"", "lemma add_le:\n \"(m :: nat) \\<le> foldl (+) m ns\"", "lemma add_mono:\n \"(m :: nat) \\<le> n \\<Longrightarrow> foldl (+) m ns \\<le> foldl (+) n ns\"", "lemma add_max [rule_format]:\n \"ns \\<noteq> [] \\<longrightarrow> Max (set ns) \\<le> foldl (+) (0 :: nat) ns\"", "lemma enum_length:\n \"length (enum xs index key n mi ma) = n\"", "lemma enum_add_le:\n \"foldl (+) 0 (enum xs index key n mi ma) \\<le> length xs\"", "lemma enum_max_le:\n \"0 < n \\<Longrightarrow> Max (set (enum xs index key n mi ma)) \\<le> length xs\"\n  (is \"_ \\<Longrightarrow> Max (set ?ns) \\<le> _\")", "lemma mini_less:\n \"0 < length xs \\<Longrightarrow> mini xs key < length xs\"", "lemma maxi_less:\n \"0 < length xs \\<Longrightarrow> maxi xs key < length xs\"", "lemma mini_lb:\n \"x \\<in> set xs \\<Longrightarrow> key (xs ! mini xs key) \\<le> key x\"", "lemma maxi_ub:\n \"x \\<in> set xs \\<Longrightarrow> key x \\<le> key (xs ! maxi xs key)\"", "lemma mini_maxi_neq [rule_format]:\n \"Suc 0 < length xs \\<longrightarrow> mini xs key \\<noteq> maxi xs key\"", "lemma mini_maxi_nths:\n \"length (nths xs (- {mini xs key, maxi xs key})) =\n    (case length xs of 0 \\<Rightarrow> 0 | Suc 0 \\<Rightarrow> 0 | Suc (Suc n) \\<Rightarrow> n)\"", "lemma mini_maxi_nths_le:\n \"length xs \\<le> Suc (Suc n) \\<Longrightarrow> length (nths xs (- {mini xs key, maxi xs key})) \\<le> n\"", "lemma round_nil:\n \"(fst (snd (round index key p q r t)) \\<noteq> []) = (\\<exists>n \\<in> set (fst (snd t)). 0 < n)\"", "lemma round_max_eq [rule_format]:\n \"fst (snd t) \\<noteq> [] \\<longrightarrow> Max (set (fst (snd t))) = Suc 0 \\<longrightarrow>\n    Max (set (fst (snd (round index key p q r t)))) = Suc 0\"", "lemma round_max_less [rule_format]:\n \"fst (snd t) \\<noteq> [] \\<longrightarrow> Suc 0 < Max (set (fst (snd t))) \\<longrightarrow>\n    Max (set (fst (snd (round index key p q r t)))) < Max (set (fst (snd t)))\"", "lemma gcsort_subset:\n  assumes A: \"t' \\<in> gcsort_set index key p t\"\n  shows \"gcsort_set index key p t' \\<subseteq> gcsort_set index key p t\"", "lemma gcsort_aux_set:\n \"gcsort_aux index key p t \\<in> gcsort_set index key p t\"", "lemma gcsort_add_input:\n \"add_inv (length xs) (0, [length xs], xs)\"", "lemma add_base:\n \"foldl (+) (k + m) ns = foldl (+) m ns + (k :: nat)\"", "lemma add_base_zero:\n \"foldl (+) k ns = foldl (+) 0 ns + (k :: nat)\"", "lemma bn_count_le:\n \"bn_count ns \\<le> foldl (+) 0 ns\"", "lemma bn_inv_intro [rule_format]:\n \"foldl (+) 0 ns \\<le> p \\<longrightarrow>\n    bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (u, ns, xs)\"", "lemma bn_comp_fst_ge [rule_format]:\n \"bn_valid n p q \\<longrightarrow> n \\<le> fst (bn_comp n p q r)\"", "lemma bn_comp_fst_nonzero:\n \"bn_valid n p q \\<Longrightarrow> 0 < n \\<Longrightarrow> 0 < fst (bn_comp n p q r)\"", "lemma bn_comp_snd_less:\n \"r < q \\<Longrightarrow> snd (bn_comp n p q r) < q\"", "lemma add_replicate:\n \"foldl (+) k (replicate m n) = k + m * n\"", "lemma fill_length:\n \"length (fill xs ns index key n mi ma) = n\"", "lemma enum_add [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"0 < n\"\n  shows \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    foldl (+) 0 (enum xs index key n mi ma) = length xs\"", "lemma round_add_inv [rule_format]:\n \"index_less index key \\<longrightarrow> bn_inv p q t \\<longrightarrow> add_inv n t \\<longrightarrow>\n    add_inv n (round index key p q r t)\"", "lemma gcsort_add_inv:\n  assumes A: \"index_less index key\"\n  shows \"\\<lbrakk>t' \\<in> gcsort_set index key p t; add_inv n t; n \\<le> p\\<rbrakk> \\<Longrightarrow>\n    add_inv n t'\"", "lemma round_len_less [rule_format]:\n \"bn_inv p q t \\<longrightarrow> r < q \\<longrightarrow>\n  (r + (foldl (+) 0 (fst (snd t)) - bn_count (fst (snd t))) * p) mod q = 0 \\<longrightarrow>\n    (fst (round index key p q r t) +\n      length (fst (snd (round index key p q r t)))) * q =\n    (fst t + bn_count (fst (snd t))) * q +\n      (foldl (+) 0 (fst (snd t)) - bn_count (fst (snd t))) * p + r\"", "lemma round_len_eq [rule_format]:\n \"bn_count (fst (snd t)) = foldl (+) 0 (fst (snd t)) \\<longrightarrow>\n    length (fst (snd (round index key p q r t))) = foldl (+) 0 (fst (snd t))\"", "theorem round_len:\n  assumes\n    A: \"length xs = foldl (+) 0 ns\" and\n    B: \"length xs \\<le> p\"\n  shows \"if bn_count ns < length xs\n    then fst (gcsort_round index key p ns xs) +\n      length (fst (snd (gcsort_round index key p ns xs))) = p\n    else length (fst (snd (gcsort_round index key p ns xs))) = length xs\"\n  (is \"if _ then fst ?t + _ = _ else _\")"], "translations": [["", "lemma add_zeros:\n \"foldl (+) (m :: nat) (replicate n 0) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) m (replicate n 0) = m", "by (induction n, simp_all)"], ["", "lemma add_suc:\n \"foldl (+) (Suc m) ns = Suc (foldl (+) m ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) (Suc m) ns = Suc (foldl (+) m ns)", "by (induction ns arbitrary: m, simp_all)"], ["", "lemma add_update:\n \"i < length ns \\<Longrightarrow> foldl (+) m (ns[i := Suc (ns ! i)]) = Suc (foldl (+) m ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ns \\<Longrightarrow>\n    foldl (+) m (ns[i := Suc (ns ! i)]) = Suc (foldl (+) m ns)", "by (induction ns arbitrary: i m, simp_all add: add_suc split: nat.split)"], ["", "lemma add_le:\n \"(m :: nat) \\<le> foldl (+) m ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> foldl (+) m ns", "by (induction ns arbitrary: m, simp_all, rule order_trans, rule le_add1)"], ["", "lemma add_mono:\n \"(m :: nat) \\<le> n \\<Longrightarrow> foldl (+) m ns \\<le> foldl (+) n ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> foldl (+) m ns \\<le> foldl (+) n ns", "by (induction ns arbitrary: m n, simp_all)"], ["", "lemma add_max [rule_format]:\n \"ns \\<noteq> [] \\<longrightarrow> Max (set ns) \\<le> foldl (+) (0 :: nat) ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<longrightarrow> Max (set ns) \\<le> foldl (+) 0 ns", "by (induction ns, simp_all add: add_le, erule impCE, simp, rule ballI, drule bspec,\n assumption, rule order_trans, assumption, rule add_mono, simp)"], ["", "lemma enum_length:\n \"length (enum xs index key n mi ma) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (enum xs index key n mi ma) = n", "by (induction xs, simp_all add: Let_def)"], ["", "lemma enum_add_le:\n \"foldl (+) 0 (enum xs index key n mi ma) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) 0 (enum xs index key n mi ma) \\<le> length xs", "proof (induction xs, simp_all add: Let_def add_zeros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) 0 (enum xs index key n mi ma)\n       \\<le> length xs \\<Longrightarrow>\n       foldl (+) 0\n        ((enum xs index key n mi ma)\n         [index key a n mi ma :=\n            Suc (enum xs index key n mi ma ! index key a n mi ma)])\n       \\<le> Suc (length xs)", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) 0 (enum xs index key n mi ma)\n       \\<le> length xs \\<Longrightarrow>\n       foldl (+) 0\n        ((enum xs index key n mi ma)\n         [index key a n mi ma :=\n            Suc (enum xs index key n mi ma ! index key a n mi ma)])\n       \\<le> Suc (length xs)", "let ?i = \"index key x n mi ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) 0 (enum xs index key n mi ma)\n       \\<le> length xs \\<Longrightarrow>\n       foldl (+) 0\n        ((enum xs index key n mi ma)\n         [index key a n mi ma :=\n            Suc (enum xs index key n mi ma ! index key a n mi ma)])\n       \\<le> Suc (length xs)", "assume \"foldl (+) 0 (enum xs index key n mi ma) \\<le> length xs\"\n    (is \"foldl _ _ ?ns \\<le> _\")"], ["proof (state)\nthis:\n  foldl (+) 0 (enum xs index key n mi ma) \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) 0 (enum xs index key n mi ma)\n       \\<le> length xs \\<Longrightarrow>\n       foldl (+) 0\n        ((enum xs index key n mi ma)\n         [index key a n mi ma :=\n            Suc (enum xs index key n mi ma ! index key a n mi ma)])\n       \\<le> Suc (length xs)", "thus \"foldl (+) 0 (?ns[?i := Suc (?ns ! ?i)]) \\<le> Suc (length xs)\""], ["proof (prove)\nusing this:\n  foldl (+) 0 (enum xs index key n mi ma) \\<le> length xs\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)])\n    \\<le> Suc (length xs)", "by (cases \"?i < length ?ns\", simp_all add: add_update)"], ["proof (state)\nthis:\n  foldl (+) 0\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)])\n  \\<le> Suc (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enum_max_le:\n \"0 < n \\<Longrightarrow> Max (set (enum xs index key n mi ma)) \\<le> length xs\"\n  (is \"_ \\<Longrightarrow> Max (set ?ns) \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    Max (set (enum xs index key n mi ma)) \\<le> length xs", "by (insert add_max [of ?ns], insert enum_add_le [of xs index key n mi ma],\n simp only: length_greater_0_conv [symmetric] enum_length, simp)"], ["", "lemma mini_less:\n \"0 < length xs \\<Longrightarrow> mini xs key < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs \\<Longrightarrow> mini xs key < length xs", "by (induction xs, simp_all add: Let_def)"], ["", "lemma maxi_less:\n \"0 < length xs \\<Longrightarrow> maxi xs key < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs \\<Longrightarrow> maxi xs key < length xs", "by (induction xs, simp_all add: Let_def)"], ["", "lemma mini_lb:\n \"x \\<in> set xs \\<Longrightarrow> key (xs ! mini xs key) \\<le> key x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> key (xs ! mini xs key) \\<le> key x", "by (induction xs, simp_all add: Let_def, auto)"], ["", "lemma maxi_ub:\n \"x \\<in> set xs \\<Longrightarrow> key x \\<le> key (xs ! maxi xs key)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> key x \\<le> key (xs ! maxi xs key)", "by (induction xs, simp_all add: Let_def, auto)"], ["", "lemma mini_maxi_neq [rule_format]:\n \"Suc 0 < length xs \\<longrightarrow> mini xs key \\<noteq> maxi xs key\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < length xs \\<longrightarrow> mini xs key \\<noteq> maxi xs key", "proof (induction xs, simp_all add: Let_def, rule conjI, (rule impI)+,\n (rule_tac [2] impI)+, rule_tac [2] notI, simp_all, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"key (xs ! maxi xs key) < key x\" and \"key x \\<le> key (xs ! mini xs key)\""], ["proof (state)\nthis:\n  key (xs ! maxi xs key) < key x\n  key x \\<le> key (xs ! mini xs key)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"key (xs ! maxi xs key) < key (xs ! mini xs key)\""], ["proof (prove)\nusing this:\n  key (xs ! maxi xs key) < key x\n  key x \\<le> key (xs ! mini xs key)\n\ngoal (1 subgoal):\n 1. key (xs ! maxi xs key) < key (xs ! mini xs key)", "by simp"], ["proof (state)\nthis:\n  key (xs ! maxi xs key) < key (xs ! mini xs key)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  key (xs ! maxi xs key) < key (xs ! mini xs key)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"0 < length xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by simp"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"mini xs key < length xs\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. mini xs key < length xs", "by (rule mini_less)"], ["proof (state)\nthis:\n  mini xs key < length xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"xs ! mini xs key \\<in> set xs\""], ["proof (prove)\nusing this:\n  mini xs key < length xs\n\ngoal (1 subgoal):\n 1. xs ! mini xs key \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  xs ! mini xs key \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"key (xs ! mini xs key) \\<le> key (xs ! maxi xs key)\""], ["proof (prove)\nusing this:\n  xs ! mini xs key \\<in> set xs\n\ngoal (1 subgoal):\n 1. key (xs ! mini xs key) \\<le> key (xs ! maxi xs key)", "by (rule maxi_ub)"], ["proof (state)\nthis:\n  key (xs ! mini xs key) \\<le> key (xs ! maxi xs key)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>Suc 0 < length xs \\<longrightarrow>\n                mini xs key \\<noteq> maxi xs key;\n        key a \\<le> key (xs ! mini xs key); key (xs ! maxi xs key) < key a;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  key (xs ! maxi xs key) < key (xs ! mini xs key)\n  key (xs ! mini xs key) \\<le> key (xs ! maxi xs key)", "show False"], ["proof (prove)\nusing this:\n  key (xs ! maxi xs key) < key (xs ! mini xs key)\n  key (xs ! mini xs key) \\<le> key (xs ! maxi xs key)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mini_maxi_nths:\n \"length (nths xs (- {mini xs key, maxi xs key})) =\n    (case length xs of 0 \\<Rightarrow> 0 | Suc 0 \\<Rightarrow> 0 | Suc (Suc n) \\<Rightarrow> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nths xs (- {mini xs key, maxi xs key})) =\n    (case length xs of 0 \\<Rightarrow> 0 | Suc 0 \\<Rightarrow> 0\n     | Suc (Suc n) \\<Rightarrow> n)", "proof (simp add: length_nths split: nat.split, rule allI, rule conjI, rule_tac [2] allI,\n (rule_tac [!] impI)+, simp add: length_Suc_conv, erule exE, simp, blast)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>x2 = Suc x2a; length xs = Suc (Suc x2a)\\<rbrakk>\n       \\<Longrightarrow> card\n                          {i. i < Suc (Suc x2a) \\<and>\n                              i \\<noteq> mini xs key \\<and>\n                              i \\<noteq> maxi xs key} =\n                         x2a", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>x2 = Suc x2a; length xs = Suc (Suc x2a)\\<rbrakk>\n       \\<Longrightarrow> card\n                          {i. i < Suc (Suc x2a) \\<and>\n                              i \\<noteq> mini xs key \\<and>\n                              i \\<noteq> maxi xs key} =\n                         x2a", "assume A: \"length xs = Suc (Suc n)\""], ["proof (state)\nthis:\n  length xs = Suc (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>x2 = Suc x2a; length xs = Suc (Suc x2a)\\<rbrakk>\n       \\<Longrightarrow> card\n                          {i. i < Suc (Suc x2a) \\<and>\n                              i \\<noteq> mini xs key \\<and>\n                              i \\<noteq> maxi xs key} =\n                         x2a", "hence B: \"Suc 0 < length xs\""], ["proof (prove)\nusing this:\n  length xs = Suc (Suc n)\n\ngoal (1 subgoal):\n 1. Suc 0 < length xs", "by simp"], ["proof (state)\nthis:\n  Suc 0 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>x2 = Suc x2a; length xs = Suc (Suc x2a)\\<rbrakk>\n       \\<Longrightarrow> card\n                          {i. i < Suc (Suc x2a) \\<and>\n                              i \\<noteq> mini xs key \\<and>\n                              i \\<noteq> maxi xs key} =\n                         x2a", "hence C: \"0 < length xs\""], ["proof (prove)\nusing this:\n  Suc 0 < length xs\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by arith"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>x2 = Suc x2a; length xs = Suc (Suc x2a)\\<rbrakk>\n       \\<Longrightarrow> card\n                          {i. i < Suc (Suc x2a) \\<and>\n                              i \\<noteq> mini xs key \\<and>\n                              i \\<noteq> maxi xs key} =\n                         x2a", "have \"{i. i < Suc (Suc n) \\<and> i \\<noteq> mini xs key \\<and> i \\<noteq> maxi xs key} =\n    {..<Suc (Suc n)} - {mini xs key} - {maxi xs key}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc n) \\<and>\n        i \\<noteq> mini xs key \\<and> i \\<noteq> maxi xs key} =\n    {..<Suc (Suc n)} - {mini xs key} - {maxi xs key}", "by blast"], ["proof (state)\nthis:\n  {i. i < Suc (Suc n) \\<and>\n      i \\<noteq> mini xs key \\<and> i \\<noteq> maxi xs key} =\n  {..<Suc (Suc n)} - {mini xs key} - {maxi xs key}\n\ngoal (1 subgoal):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>x2 = Suc x2a; length xs = Suc (Suc x2a)\\<rbrakk>\n       \\<Longrightarrow> card\n                          {i. i < Suc (Suc x2a) \\<and>\n                              i \\<noteq> mini xs key \\<and>\n                              i \\<noteq> maxi xs key} =\n                         x2a", "thus \"card {i. i < Suc (Suc n) \\<and> i \\<noteq> mini xs key \\<and> i \\<noteq> maxi xs key} = n\""], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc n) \\<and>\n      i \\<noteq> mini xs key \\<and> i \\<noteq> maxi xs key} =\n  {..<Suc (Suc n)} - {mini xs key} - {maxi xs key}\n\ngoal (1 subgoal):\n 1. card\n     {i. i < Suc (Suc n) \\<and>\n         i \\<noteq> mini xs key \\<and> i \\<noteq> maxi xs key} =\n    n", "by (simp add: card_Diff_singleton_if, insert mini_maxi_neq [OF B, of key],\n     simp add: mini_less [OF C] maxi_less [OF C] A [symmetric])"], ["proof (state)\nthis:\n  card\n   {i. i < Suc (Suc n) \\<and>\n       i \\<noteq> mini xs key \\<and> i \\<noteq> maxi xs key} =\n  n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mini_maxi_nths_le:\n \"length xs \\<le> Suc (Suc n) \\<Longrightarrow> length (nths xs (- {mini xs key, maxi xs key})) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> Suc (Suc n) \\<Longrightarrow>\n    length (nths xs (- {mini xs key, maxi xs key})) \\<le> n", "by (simp add: mini_maxi_nths split: nat.split)"], ["", "lemma round_nil:\n \"(fst (snd (round index key p q r t)) \\<noteq> []) = (\\<exists>n \\<in> set (fst (snd t)). 0 < n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (snd (round index key p q r t)) \\<noteq> []) =\n    (\\<exists>n\\<in>set (fst (snd t)). 0 < n)", "by (induction index key p q r t rule: round.induct,\n simp_all add: round_suc_suc_def Let_def split: prod.split)"], ["", "lemma round_max_eq [rule_format]:\n \"fst (snd t) \\<noteq> [] \\<longrightarrow> Max (set (fst (snd t))) = Suc 0 \\<longrightarrow>\n    Max (set (fst (snd (round index key p q r t)))) = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd t) \\<noteq> [] \\<longrightarrow>\n    Max (set (fst (snd t))) = Suc 0 \\<longrightarrow>\n    Max (set (fst (snd (round index key p q r t)))) = Suc 0", "proof (induction index key p q r t rule: round.induct, simp_all add: Let_def split:\n prod.split del: all_simps, rule impI, (rule_tac [2] allI)+, (rule_tac [2] impI)+,\n (rule_tac [3] allI)+, (rule_tac [3] impI)+, rule_tac [3] FalseE)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs))))) =\n                Suc 0;\n        Max (insert 0 (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs))))) =\n                         Suc 0\n 2. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix index p q r u ns xs and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs))))) =\n                Suc 0;\n        Max (insert 0 (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs))))) =\n                         Suc 0\n 2. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "let ?t = \"round index key p q r (u, ns, xs)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs))))) =\n                Suc 0;\n        Max (insert 0 (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs))))) =\n                         Suc 0\n 2. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"ns \\<noteq> [] \\<longrightarrow> Max (set ns) = Suc 0 \\<longrightarrow>\n    Max (set (fst (snd ?t))) = Suc 0\""], ["proof (state)\nthis:\n  ns \\<noteq> [] \\<longrightarrow>\n  Max (set ns) = Suc 0 \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, xs))))) = Suc 0\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs))))) =\n                Suc 0;\n        Max (insert 0 (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs))))) =\n                         Suc 0\n 2. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ns \\<noteq> [] \\<longrightarrow>\n  Max (set ns) = Suc 0 \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, xs))))) = Suc 0\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs))))) =\n                Suc 0;\n        Max (insert 0 (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs))))) =\n                         Suc 0\n 2. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume A: \"Max (insert 0 (set ns)) = Suc 0\""], ["proof (state)\nthis:\n  Max (insert 0 (set ns)) = Suc 0\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs))))) =\n                Suc 0;\n        Max (insert 0 (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs))))) =\n                         Suc 0\n 2. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"ns \\<noteq> []\""], ["proof (prove)\nusing this:\n  Max (insert 0 (set ns)) = Suc 0\n\ngoal (1 subgoal):\n 1. ns \\<noteq> []", "by (cases ns, simp_all)"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs))))) =\n                Suc 0;\n        Max (insert 0 (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs))))) =\n                         Suc 0\n 2. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs))))) =\n                Suc 0;\n        Max (insert 0 (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs))))) =\n                         Suc 0\n 2. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  ns \\<noteq> []", "have \"Max (set ns) = Suc 0\""], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. Max (set ns) = Suc 0", "using A"], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  Max (insert 0 (set ns)) = Suc 0\n\ngoal (1 subgoal):\n 1. Max (set ns) = Suc 0", "by simp"], ["proof (state)\nthis:\n  Max (set ns) = Suc 0\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs))))) =\n                Suc 0;\n        Max (insert 0 (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs))))) =\n                         Suc 0\n 2. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ns \\<noteq> [] \\<longrightarrow>\n  Max (set ns) = Suc 0 \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, xs))))) = Suc 0\n  ns \\<noteq> []\n  Max (set ns) = Suc 0", "show \"Max (set (fst (snd ?t))) = Suc 0\""], ["proof (prove)\nusing this:\n  ns \\<noteq> [] \\<longrightarrow>\n  Max (set ns) = Suc 0 \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, xs))))) = Suc 0\n  ns \\<noteq> []\n  Max (set ns) = Suc 0\n\ngoal (1 subgoal):\n 1. Max (set (fst (snd (round index key p q r (u, ns, xs))))) = Suc 0", "by simp"], ["proof (state)\nthis:\n  Max (set (fst (snd (round index key p q r (u, ns, xs))))) = Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix index p q r u ns xs u' ns' xs' and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "let ?t = \"round index key p q r (u, ns, tl xs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume A: \"?t = (u', ns', xs')\" and\n   \"ns \\<noteq> [] \\<longrightarrow> Max (set ns) = Suc 0 \\<longrightarrow> Max (set (fst (snd ?t))) = Suc 0\""], ["proof (state)\nthis:\n  round index key p q r (u, ns, tl xs) = (u', ns', xs')\n  ns \\<noteq> [] \\<longrightarrow>\n  Max (set ns) = Suc 0 \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, tl xs))))) = Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "hence B: \"ns \\<noteq> [] \\<longrightarrow> Max (set ns) = Suc 0 \\<longrightarrow> Max (set ns') = Suc 0\""], ["proof (prove)\nusing this:\n  round index key p q r (u, ns, tl xs) = (u', ns', xs')\n  ns \\<noteq> [] \\<longrightarrow>\n  Max (set ns) = Suc 0 \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, tl xs))))) = Suc 0\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<longrightarrow>\n    Max (set ns) = Suc 0 \\<longrightarrow> Max (set ns') = Suc 0", "by simp"], ["proof (state)\nthis:\n  ns \\<noteq> [] \\<longrightarrow>\n  Max (set ns) = Suc 0 \\<longrightarrow> Max (set ns') = Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume C: \"Max (insert (Suc 0) (set ns)) = Suc 0\""], ["proof (state)\nthis:\n  Max (insert (Suc 0) (set ns)) = Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Max (set ns) = Suc 0 \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r\n                                     (u, ns, tl xs))))) =\n                Suc 0;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Max (insert (Suc 0) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> Max (insert (Suc 0) (set a)) = Suc 0\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "show \"Max (insert (Suc 0) (set ns')) = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (insert (Suc 0) (set ns')) = Suc 0", "proof (cases \"ns' = []\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "assume D: \"ns' \\<noteq> []\""], ["proof (state)\nthis:\n  ns' \\<noteq> []\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "hence \"fst (snd ?t) \\<noteq> []\""], ["proof (prove)\nusing this:\n  ns' \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst (snd (round index key p q r (u, ns, tl xs))) \\<noteq> []", "using A"], ["proof (prove)\nusing this:\n  ns' \\<noteq> []\n  round index key p q r (u, ns, tl xs) = (u', ns', xs')\n\ngoal (1 subgoal):\n 1. fst (snd (round index key p q r (u, ns, tl xs))) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  fst (snd (round index key p q r (u, ns, tl xs))) \\<noteq> []\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "hence \"\\<exists>n \\<in> set ns. 0 < n\""], ["proof (prove)\nusing this:\n  fst (snd (round index key p q r (u, ns, tl xs))) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<in>set ns. 0 < n", "by (simp add: round_nil)"], ["proof (state)\nthis:\n  \\<exists>n\\<in>set ns. 0 < n\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>n\\<in>set ns. 0 < n", "obtain n where E: \"n \\<in> set ns\" and F: \"0 < n\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<in>set ns. 0 < n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<in> set ns; 0 < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  n \\<in> set ns\n  0 < n\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "hence G: \"ns \\<noteq> []\""], ["proof (prove)\nusing this:\n  n \\<in> set ns\n  0 < n\n\ngoal (1 subgoal):\n 1. ns \\<noteq> []", "by (cases ns, simp_all)"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "moreover"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "have \"n \\<le> Max (set ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> Max (set ns)", "using E"], ["proof (prove)\nusing this:\n  n \\<in> set ns\n\ngoal (1 subgoal):\n 1. n \\<le> Max (set ns)", "by (rule_tac Max_ge, simp_all)"], ["proof (state)\nthis:\n  n \\<le> Max (set ns)\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "hence \"0 < Max (set ns)\""], ["proof (prove)\nusing this:\n  n \\<le> Max (set ns)\n\ngoal (1 subgoal):\n 1. 0 < Max (set ns)", "using F"], ["proof (prove)\nusing this:\n  n \\<le> Max (set ns)\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 < Max (set ns)", "by simp"], ["proof (state)\nthis:\n  0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "hence \"Max (set ns) = Suc 0\""], ["proof (prove)\nusing this:\n  0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. Max (set ns) = Suc 0", "using C and G"], ["proof (prove)\nusing this:\n  0 < Max (set ns)\n  Max (insert (Suc 0) (set ns)) = Suc 0\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. Max (set ns) = Suc 0", "by simp"], ["proof (state)\nthis:\n  Max (set ns) = Suc 0\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "ultimately"], ["proof (chain)\npicking this:\n  ns \\<noteq> []\n  Max (set ns) = Suc 0", "have \"Max (set ns') = Suc 0\""], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  Max (set ns) = Suc 0\n\ngoal (1 subgoal):\n 1. Max (set ns') = Suc 0", "using B"], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  Max (set ns) = Suc 0\n  ns \\<noteq> [] \\<longrightarrow>\n  Max (set ns) = Suc 0 \\<longrightarrow> Max (set ns') = Suc 0\n\ngoal (1 subgoal):\n 1. Max (set ns') = Suc 0", "by simp"], ["proof (state)\nthis:\n  Max (set ns') = Suc 0\n\ngoal (1 subgoal):\n 1. ns' \\<noteq> [] \\<Longrightarrow> Max (insert (Suc 0) (set ns')) = Suc 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  Max (set ns') = Suc 0\n\ngoal (1 subgoal):\n 1. Max (insert (Suc 0) (set ns')) = Suc 0", "using D"], ["proof (prove)\nusing this:\n  Max (set ns') = Suc 0\n  ns' \\<noteq> []\n\ngoal (1 subgoal):\n 1. Max (insert (Suc 0) (set ns')) = Suc 0", "by simp"], ["proof (state)\nthis:\n  Max (insert (Suc 0) (set ns')) = Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (insert (Suc 0) (set ns')) = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix n ns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"Max (insert (Suc (Suc n)) (set ns)) = Suc 0\""], ["proof (state)\nthis:\n  Max (insert (Suc (Suc n)) (set ns)) = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Max (set ns) = Suc 0 \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs))))) =\n                                     Suc 0;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Max (insert (Suc (Suc n)) (set ns)) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Max (insert (Suc (Suc n)) (set ns)) = Suc 0\n\ngoal (1 subgoal):\n 1. False", "by (cases ns, simp_all)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_max_less [rule_format]:\n \"fst (snd t) \\<noteq> [] \\<longrightarrow> Suc 0 < Max (set (fst (snd t))) \\<longrightarrow>\n    Max (set (fst (snd (round index key p q r t)))) < Max (set (fst (snd t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd t) \\<noteq> [] \\<longrightarrow>\n    Suc 0 < Max (set (fst (snd t))) \\<longrightarrow>\n    Max (set (fst (snd (round index key p q r t))))\n    < Max (set (fst (snd t)))", "proof (induction index key p q r t rule: round.induct, simp_all add: Let_def split:\n prod.split del: all_simps, rule impI, (rule_tac [2] allI)+, (rule_tac [2] impI)+,\n (rule_tac [3] allI)+, (rule_tac [3] impI)+, rule_tac [2] ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n                < Max (set ns);\n        Suc 0 < Max (insert 0 (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs)))))\n                         < Max (insert 0 (set ns))\n 2. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "fix index p q r u ns xs and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n                < Max (set ns);\n        Suc 0 < Max (insert 0 (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs)))))\n                         < Max (insert 0 (set ns))\n 2. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "let ?t = \"round index key p q r (u, ns, xs)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n                < Max (set ns);\n        Suc 0 < Max (insert 0 (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs)))))\n                         < Max (insert 0 (set ns))\n 2. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "assume \"ns \\<noteq> [] \\<longrightarrow> Suc 0 < Max (set ns) \\<longrightarrow>\n    Max (set (fst (snd ?t))) < Max (set ns)\""], ["proof (state)\nthis:\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, xs))))) < Max (set ns)\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n                < Max (set ns);\n        Suc 0 < Max (insert 0 (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs)))))\n                         < Max (insert 0 (set ns))\n 2. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, xs))))) < Max (set ns)\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n                < Max (set ns);\n        Suc 0 < Max (insert 0 (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs)))))\n                         < Max (insert 0 (set ns))\n 2. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "assume A: \"Suc 0 < Max (insert 0 (set ns))\""], ["proof (state)\nthis:\n  Suc 0 < Max (insert 0 (set ns))\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n                < Max (set ns);\n        Suc 0 < Max (insert 0 (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs)))))\n                         < Max (insert 0 (set ns))\n 2. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "hence \"ns \\<noteq> []\""], ["proof (prove)\nusing this:\n  Suc 0 < Max (insert 0 (set ns))\n\ngoal (1 subgoal):\n 1. ns \\<noteq> []", "by (cases ns, simp_all)"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n                < Max (set ns);\n        Suc 0 < Max (insert 0 (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs)))))\n                         < Max (insert 0 (set ns))\n 2. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n                < Max (set ns);\n        Suc 0 < Max (insert 0 (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs)))))\n                         < Max (insert 0 (set ns))\n 2. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "from this"], ["proof (chain)\npicking this:\n  ns \\<noteq> []", "have \"Suc 0 < Max (set ns)\""], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. Suc 0 < Max (set ns)", "using A"], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  Suc 0 < Max (insert 0 (set ns))\n\ngoal (1 subgoal):\n 1. Suc 0 < Max (set ns)", "by simp"], ["proof (state)\nthis:\n  Suc 0 < Max (set ns)\n\ngoal (3 subgoals):\n 1. \\<And>index key p q r u ns xs.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n                < Max (set ns);\n        Suc 0 < Max (insert 0 (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (round index key p q r (u, ns, xs)))))\n                         < Max (insert 0 (set ns))\n 2. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 3. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, xs))))) < Max (set ns)\n  ns \\<noteq> []\n  Suc 0 < Max (set ns)", "show \"Max (set (fst (snd ?t))) < Max (insert 0 (set ns))\""], ["proof (prove)\nusing this:\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, xs))))) < Max (set ns)\n  ns \\<noteq> []\n  Suc 0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n    < Max (insert 0 (set ns))", "by simp"], ["proof (state)\nthis:\n  Max (set (fst (snd (round index key p q r (u, ns, xs)))))\n  < Max (insert 0 (set ns))\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "fix index p q r u ns xs u' ns' xs' i and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "let ?t = \"round index key p q r (u, ns, tl xs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "assume\n   \"?t = (u', ns', xs')\" and\n   \"ns \\<noteq> [] \\<longrightarrow> Suc 0 < Max (set ns) \\<longrightarrow>\n      Max (set (fst (snd ?t))) < Max (set ns)\""], ["proof (state)\nthis:\n  round index key p q r (u, ns, tl xs) = (u', ns', xs')\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n  < Max (set ns)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "hence \"ns \\<noteq> [] \\<longrightarrow> Suc 0 < Max (set ns) \\<longrightarrow>\n    Max (set ns') < Max (set ns)\""], ["proof (prove)\nusing this:\n  round index key p q r (u, ns, tl xs) = (u', ns', xs')\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow>\n  Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n  < Max (set ns)\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<longrightarrow>\n    Suc 0 < Max (set ns) \\<longrightarrow> Max (set ns') < Max (set ns)", "by simp"], ["proof (state)\nthis:\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow> Max (set ns') < Max (set ns)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow> Max (set ns') < Max (set ns)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "assume A: \"Suc 0 < Max (insert (Suc 0) (set ns))\""], ["proof (state)\nthis:\n  Suc 0 < Max (insert (Suc 0) (set ns))\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "hence B: \"ns \\<noteq> []\""], ["proof (prove)\nusing this:\n  Suc 0 < Max (insert (Suc 0) (set ns))\n\ngoal (1 subgoal):\n 1. ns \\<noteq> []", "by (cases ns, simp_all)"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "from this"], ["proof (chain)\npicking this:\n  ns \\<noteq> []", "have \"Suc 0 < Max (set ns)\""], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. Suc 0 < Max (set ns)", "using A"], ["proof (prove)\nusing this:\n  ns \\<noteq> []\n  Suc 0 < Max (insert (Suc 0) (set ns))\n\ngoal (1 subgoal):\n 1. Suc 0 < Max (set ns)", "by simp"], ["proof (state)\nthis:\n  Suc 0 < Max (set ns)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow> Max (set ns') < Max (set ns)\n  ns \\<noteq> []\n  Suc 0 < Max (set ns)", "have \"Max (set ns') < Max (set ns)\""], ["proof (prove)\nusing this:\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow> Max (set ns') < Max (set ns)\n  ns \\<noteq> []\n  Suc 0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. Max (set ns') < Max (set ns)", "by simp"], ["proof (state)\nthis:\n  Max (set ns') < Max (set ns)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  Max (set ns') < Max (set ns)\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "assume \"i \\<in> set ns'\""], ["proof (state)\nthis:\n  i \\<in> set ns'\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "hence \"i \\<le> Max (set ns')\""], ["proof (prove)\nusing this:\n  i \\<in> set ns'\n\ngoal (1 subgoal):\n 1. i \\<le> Max (set ns')", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  i \\<le> Max (set ns')\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs x1 a b aa.\n       \\<lbrakk>ns \\<noteq> [] \\<longrightarrow>\n                Suc 0 < Max (set ns) \\<longrightarrow>\n                Max (set (fst (snd (round index key p q r (u, ns, tl xs)))))\n                < Max (set ns);\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        Suc 0 < Max (insert (Suc 0) (set ns)); aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aa < Max (insert (Suc 0) (set ns))\n 2. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  Max (set ns') < Max (set ns)\n  i \\<le> Max (set ns')", "show \"i < Max (insert (Suc 0) (set ns))\""], ["proof (prove)\nusing this:\n  Max (set ns') < Max (set ns)\n  i \\<le> Max (set ns')\n\ngoal (1 subgoal):\n 1. i < Max (insert (Suc 0) (set ns))", "using B"], ["proof (prove)\nusing this:\n  Max (set ns') < Max (set ns)\n  i \\<le> Max (set ns')\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. i < Max (insert (Suc 0) (set ns))", "by simp"], ["proof (state)\nthis:\n  i < Max (insert (Suc 0) (set ns))\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "fix index p q r u n ns n' r' v ms' ws' u' ns' xs'\n    and key :: \"'a \\<Rightarrow> 'b\" and xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "let ?ws = \"take (Suc (Suc n)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "let ?ys = \"drop (Suc (Suc n)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "let ?r = \"\\<lambda>n'. round_suc_suc index key ?ws n n' u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "let ?t = \"\\<lambda>r' v. round index key p q r' (v, ns, ?ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "assume\n    A: \"?r n' = (v, ms', ws')\" and\n    B: \"?t r' v = (u', ns', xs')\""], ["proof (state)\nthis:\n  round_suc_suc index key (take (Suc (Suc n)) xs) n n' u = (v, ms', ws')\n  round index key p q r' (v, ns, drop (Suc (Suc n)) xs) = (u', ns', xs')\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  round_suc_suc index key (take (Suc (Suc n)) xs) n n' u = (v, ms', ws')\n  round index key p q r' (v, ns, drop (Suc (Suc n)) xs) = (u', ns', xs')\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "assume \"\\<And>ws a b c d e f g h.\n    ws = ?ws \\<Longrightarrow> a = bn_comp n p q r \\<Longrightarrow> (b, c) = bn_comp n p q r \\<Longrightarrow>\n    d = ?r b \\<Longrightarrow> (e, f) = ?r b \\<Longrightarrow> (g, h) = f \\<Longrightarrow>\n      ns \\<noteq> [] \\<longrightarrow> Suc 0 < Max (set ns) \\<longrightarrow>\n        Max (set (fst (snd (?t c e)))) < Max (set ns)\" and\n   \"bn_comp n p q r = (n', r')\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = bn_comp n p q r;\n   (?b, ?c) = bn_comp n p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc n)) xs) n ?b u;\n   (?e, ?f) = round_suc_suc index key (take (Suc (Suc n)) xs) n ?b u;\n   (?g, ?h) = ?f\\<rbrakk>\n  \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                    Suc 0 < Max (set ns) \\<longrightarrow>\n                    Max (set (fst (snd (round index key p q ?c\n   (?e, ns, drop (Suc (Suc n)) xs)))))\n                    < Max (set ns)\n  bn_comp n p q r = (n', r')\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  round_suc_suc index key (take (Suc (Suc n)) xs) n n' u = (v, ms', ws')\n  round index key p q r' (v, ns, drop (Suc (Suc n)) xs) = (u', ns', xs')\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = bn_comp n p q r;\n   (?b, ?c) = bn_comp n p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc n)) xs) n ?b u;\n   (?e, ?f) = round_suc_suc index key (take (Suc (Suc n)) xs) n ?b u;\n   (?g, ?h) = ?f\\<rbrakk>\n  \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                    Suc 0 < Max (set ns) \\<longrightarrow>\n                    Max (set (fst (snd (round index key p q ?c\n   (?e, ns, drop (Suc (Suc n)) xs)))))\n                    < Max (set ns)\n  bn_comp n p q r = (n', r')", "have C: \"ns \\<noteq> [] \\<longrightarrow> Suc 0 < Max (set ns) \\<longrightarrow>\n    Max (set ns') < Max (set ns)\""], ["proof (prove)\nusing this:\n  round_suc_suc index key (take (Suc (Suc n)) xs) n n' u = (v, ms', ws')\n  round index key p q r' (v, ns, drop (Suc (Suc n)) xs) = (u', ns', xs')\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = bn_comp n p q r;\n   (?b, ?c) = bn_comp n p q r;\n   ?d = round_suc_suc index key (take (Suc (Suc n)) xs) n ?b u;\n   (?e, ?f) = round_suc_suc index key (take (Suc (Suc n)) xs) n ?b u;\n   (?g, ?h) = ?f\\<rbrakk>\n  \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                    Suc 0 < Max (set ns) \\<longrightarrow>\n                    Max (set (fst (snd (round index key p q ?c\n   (?e, ns, drop (Suc (Suc n)) xs)))))\n                    < Max (set ns)\n  bn_comp n p q r = (n', r')\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<longrightarrow>\n    Suc 0 < Max (set ns) \\<longrightarrow> Max (set ns') < Max (set ns)", "by simp"], ["proof (state)\nthis:\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow> Max (set ns') < Max (set ns)\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = bn_comp n p q r;\n                    (xb, y) = bn_comp n p q r;\n                    xaa =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xc, ya) =\n                    round_suc_suc index key (take (Suc (Suc n)) xs) n xb u;\n                    (xd, yb) = ya\\<rbrakk>\n                   \\<Longrightarrow> ns \\<noteq> [] \\<longrightarrow>\n                                     Suc 0 < Max (set ns) \\<longrightarrow>\n                                     Max\n(set (fst (snd (round index key p q y (xc, ns, drop (Suc (Suc n)) xs)))))\n                                     < Max (set ns);\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        Suc 0 < Max (insert (Suc (Suc n)) (set ns))\\<rbrakk>\n       \\<Longrightarrow> Max (set a \\<union> set aa)\n                         < Max (insert (Suc (Suc n)) (set ns))", "from A [symmetric]"], ["proof (chain)\npicking this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc n)) xs) n n' u", "show \"Max (set ms' \\<union> set ns') <\n    Max (insert (Suc (Suc n)) (set ns))\""], ["proof (prove)\nusing this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc n)) xs) n n' u\n\ngoal (1 subgoal):\n 1. Max (set ms' \\<union> set ns') < Max (insert (Suc (Suc n)) (set ns))", "proof (simp add: round_suc_suc_def Let_def, subst Max_less_iff, simp_all,\n   rule_tac impI, simp add: Let_def split: if_split_asm, rule_tac ballI,\n   erule_tac UnE, simp add: Let_def split: if_split_asm, (erule_tac [1-2] conjE)+)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or> a = Suc 0 \\<and> 0 < n;\n        key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' - n, Suc 0 # Suc 0 # replicate n (Suc 0),\n         take (Suc (Suc n)) xs);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v = u + n' - n;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' = Suc 0 # Suc 0 # replicate n (Suc 0);\n        ws' = take (Suc (Suc n)) xs\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 3. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or> a = Suc 0 \\<and> 0 < n;\n        key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' - n, Suc 0 # Suc 0 # replicate n (Suc 0),\n         take (Suc (Suc n)) xs);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v = u + n' - n;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' = Suc 0 # Suc 0 # replicate n (Suc 0);\n        ws' = take (Suc (Suc n)) xs\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 3. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "assume \"i = Suc 0 \\<or> i = Suc 0 \\<and> 0 < n\""], ["proof (state)\nthis:\n  i = Suc 0 \\<or> i = Suc 0 \\<and> 0 < n\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or> a = Suc 0 \\<and> 0 < n;\n        key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' - n, Suc 0 # Suc 0 # replicate n (Suc 0),\n         take (Suc (Suc n)) xs);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v = u + n' - n;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' = Suc 0 # Suc 0 # replicate n (Suc 0);\n        ws' = take (Suc (Suc n)) xs\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 3. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence \"i = Suc 0\""], ["proof (prove)\nusing this:\n  i = Suc 0 \\<or> i = Suc 0 \\<and> 0 < n\n\ngoal (1 subgoal):\n 1. i = Suc 0", "by blast"], ["proof (state)\nthis:\n  i = Suc 0\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or> a = Suc 0 \\<and> 0 < n;\n        key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' - n, Suc 0 # Suc 0 # replicate n (Suc 0),\n         take (Suc (Suc n)) xs);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v = u + n' - n;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' = Suc 0 # Suc 0 # replicate n (Suc 0);\n        ws' = take (Suc (Suc n)) xs\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 3. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence \"i < Suc (Suc n)\""], ["proof (prove)\nusing this:\n  i = Suc 0\n\ngoal (1 subgoal):\n 1. i < Suc (Suc n)", "by simp"], ["proof (state)\nthis:\n  i < Suc (Suc n)\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or> a = Suc 0 \\<and> 0 < n;\n        key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' - n, Suc 0 # Suc 0 # replicate n (Suc 0),\n         take (Suc (Suc n)) xs);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v = u + n' - n;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' = Suc 0 # Suc 0 # replicate n (Suc 0);\n        ws' = take (Suc (Suc n)) xs\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 3. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "also"], ["proof (state)\nthis:\n  i < Suc (Suc n)\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or> a = Suc 0 \\<and> 0 < n;\n        key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' - n, Suc 0 # Suc 0 # replicate n (Suc 0),\n         take (Suc (Suc n)) xs);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v = u + n' - n;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' = Suc 0 # Suc 0 # replicate n (Suc 0);\n        ws' = take (Suc (Suc n)) xs\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 3. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "have \"\\<dots> \\<le> Max (insert (Suc (Suc n)) (set ns))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc n) \\<le> Max (insert (Suc (Suc n)) (set ns))", "by (rule Max_ge, simp_all)"], ["proof (state)\nthis:\n  Suc (Suc n) \\<le> Max (insert (Suc (Suc n)) (set ns))\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or> a = Suc 0 \\<and> 0 < n;\n        key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' - n, Suc 0 # Suc 0 # replicate n (Suc 0),\n         take (Suc (Suc n)) xs);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v = u + n' - n;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' = Suc 0 # Suc 0 # replicate n (Suc 0);\n        ws' = take (Suc (Suc n)) xs\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 3. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "finally"], ["proof (chain)\npicking this:\n  i < Max (insert (Suc (Suc n)) (set ns))", "show \"i < Max (insert (Suc (Suc n)) (set ns))\""], ["proof (prove)\nusing this:\n  i < Max (insert (Suc (Suc n)) (set ns))\n\ngoal (1 subgoal):\n 1. i < Max (insert (Suc (Suc n)) (set ns))", "."], ["proof (state)\nthis:\n  i < Max (insert (Suc (Suc n)) (set ns))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "let ?nmi = \"mini ?ws key\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "let ?nma = \"maxi ?ws key\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "let ?xmi = \"?ws ! ?nmi\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "let ?xma = \"?ws ! ?nma\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "let ?mi = \"key ?xmi\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "let ?ma = \"key ?xma\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "let ?k = \"case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n | Suc (Suc i) \\<Rightarrow> u + n'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "let ?zs = \"nths ?ws (- {?nmi, ?nma})\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "let ?ms = \"enum ?zs index key ?k ?mi ?ma\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "assume \"i = Suc 0 \\<or> i \\<in> set ?ms\""], ["proof (state)\nthis:\n  i = Suc 0 \\<or>\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  i = Suc 0 \\<or>\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "{"], ["proof (state)\nthis:\n  i = Suc 0 \\<or>\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "assume \"i = Suc 0\""], ["proof (state)\nthis:\n  i = Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence \"i < Suc (Suc n)\""], ["proof (prove)\nusing this:\n  i = Suc 0\n\ngoal (1 subgoal):\n 1. i < Suc (Suc n)", "by simp"], ["proof (state)\nthis:\n  i < Suc (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "}"], ["proof (state)\nthis:\n  i = Suc 0 \\<Longrightarrow> i < Suc (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  i = Suc 0 \\<Longrightarrow> i < Suc (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "{"], ["proof (state)\nthis:\n  i = Suc 0 \\<Longrightarrow> i < Suc (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "assume D: \"i \\<in> set ?ms\""], ["proof (state)\nthis:\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence \"i \\<le> Max (set ?ms)\""], ["proof (prove)\nusing this:\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n\ngoal (1 subgoal):\n 1. i \\<le> Max (set (enum\n                       (nths (take (Suc (Suc n)) xs)\n                         (- {mini (take (Suc (Suc n)) xs) key,\n                             maxi (take (Suc (Suc n)) xs) key}))\n                       index key\n                       (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                        | Suc (Suc i) \\<Rightarrow> u + n')\n                       (key (take (Suc (Suc n)) xs !\n                             mini (take (Suc (Suc n)) xs) key))\n                       (key (take (Suc (Suc n)) xs !\n                             maxi (take (Suc (Suc n)) xs) key))))", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  i \\<le> Max (set (enum\n                     (nths (take (Suc (Suc n)) xs)\n                       (- {mini (take (Suc (Suc n)) xs) key,\n                           maxi (take (Suc (Suc n)) xs) key}))\n                     index key\n                     (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n')\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  i \\<le> Max (set (enum\n                     (nths (take (Suc (Suc n)) xs)\n                       (- {mini (take (Suc (Suc n)) xs) key,\n                           maxi (take (Suc (Suc n)) xs) key}))\n                     index key\n                     (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n')\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "have \"0 < length ?ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length\n         (enum\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           index key\n           (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n            | Suc (Suc i) \\<Rightarrow> u + n')\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)))", "using D"], ["proof (prove)\nusing this:\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (enum\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           index key\n           (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n            | Suc (Suc i) \\<Rightarrow> u + n')\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)))", "by (rule length_pos_if_in_set)"], ["proof (state)\nthis:\n  0 < length\n       (enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence \"0 < ?k\""], ["proof (prove)\nusing this:\n  0 < length\n       (enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)))\n\ngoal (1 subgoal):\n 1. 0 < (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n')", "by (simp add: enum_length)"], ["proof (state)\nthis:\n  0 < (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n       | Suc (Suc i) \\<Rightarrow> u + n')\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence \"Max (set ?ms) \\<le> length ?zs\""], ["proof (prove)\nusing this:\n  0 < (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n       | Suc (Suc i) \\<Rightarrow> u + n')\n\ngoal (1 subgoal):\n 1. Max (set (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key))))\n    \\<le> length\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))", "by (rule enum_max_le)"], ["proof (state)\nthis:\n  Max (set (enum\n             (nths (take (Suc (Suc n)) xs)\n               (- {mini (take (Suc (Suc n)) xs) key,\n                   maxi (take (Suc (Suc n)) xs) key}))\n             index key\n             (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n              | Suc (Suc i) \\<Rightarrow> u + n')\n             (key (take (Suc (Suc n)) xs !\n                   mini (take (Suc (Suc n)) xs) key))\n             (key (take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key))))\n  \\<le> length\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  i \\<le> Max (set (enum\n                     (nths (take (Suc (Suc n)) xs)\n                       (- {mini (take (Suc (Suc n)) xs) key,\n                           maxi (take (Suc (Suc n)) xs) key}))\n                     index key\n                     (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n')\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))))\n  Max (set (enum\n             (nths (take (Suc (Suc n)) xs)\n               (- {mini (take (Suc (Suc n)) xs) key,\n                   maxi (take (Suc (Suc n)) xs) key}))\n             index key\n             (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n              | Suc (Suc i) \\<Rightarrow> u + n')\n             (key (take (Suc (Suc n)) xs !\n                   mini (take (Suc (Suc n)) xs) key))\n             (key (take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key))))\n  \\<le> length\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))", "have \"i \\<le> length ?zs\""], ["proof (prove)\nusing this:\n  i \\<le> Max (set (enum\n                     (nths (take (Suc (Suc n)) xs)\n                       (- {mini (take (Suc (Suc n)) xs) key,\n                           maxi (take (Suc (Suc n)) xs) key}))\n                     index key\n                     (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n')\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))))\n  Max (set (enum\n             (nths (take (Suc (Suc n)) xs)\n               (- {mini (take (Suc (Suc n)) xs) key,\n                   maxi (take (Suc (Suc n)) xs) key}))\n             index key\n             (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n              | Suc (Suc i) \\<Rightarrow> u + n')\n             (key (take (Suc (Suc n)) xs !\n                   mini (take (Suc (Suc n)) xs) key))\n             (key (take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key))))\n  \\<le> length\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n\ngoal (1 subgoal):\n 1. i \\<le> length\n             (nths (take (Suc (Suc n)) xs)\n               (- {mini (take (Suc (Suc n)) xs) key,\n                   maxi (take (Suc (Suc n)) xs) key}))", "by simp"], ["proof (state)\nthis:\n  i \\<le> length\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  i \\<le> length\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "have \"length ?zs \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (nths (take (Suc (Suc n)) xs)\n       (- {mini (take (Suc (Suc n)) xs) key,\n           maxi (take (Suc (Suc n)) xs) key}))\n    \\<le> n", "by (rule mini_maxi_nths_le, simp)"], ["proof (state)\nthis:\n  length\n   (nths (take (Suc (Suc n)) xs)\n     (- {mini (take (Suc (Suc n)) xs) key,\n         maxi (take (Suc (Suc n)) xs) key}))\n  \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  i \\<le> length\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n  length\n   (nths (take (Suc (Suc n)) xs)\n     (- {mini (take (Suc (Suc n)) xs) key,\n         maxi (take (Suc (Suc n)) xs) key}))\n  \\<le> n", "have \"i < Suc (Suc n)\""], ["proof (prove)\nusing this:\n  i \\<le> length\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n  length\n   (nths (take (Suc (Suc n)) xs)\n     (- {mini (take (Suc (Suc n)) xs) key,\n         maxi (take (Suc (Suc n)) xs) key}))\n  \\<le> n\n\ngoal (1 subgoal):\n 1. i < Suc (Suc n)", "by simp"], ["proof (state)\nthis:\n  i < Suc (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "}"], ["proof (state)\nthis:\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key))) \\<Longrightarrow>\n  i < Suc (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  i = Suc 0 \\<or>\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n  i = Suc 0 \\<Longrightarrow> i < Suc (Suc n)\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key))) \\<Longrightarrow>\n  i < Suc (Suc n)", "have \"i < Suc (Suc n)\""], ["proof (prove)\nusing this:\n  i = Suc 0 \\<or>\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n  i = Suc 0 \\<Longrightarrow> i < Suc (Suc n)\n  i \\<in> set (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key))) \\<Longrightarrow>\n  i < Suc (Suc n)\n\ngoal (1 subgoal):\n 1. i < Suc (Suc n)", ".."], ["proof (state)\nthis:\n  i < Suc (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "also"], ["proof (state)\nthis:\n  i < Suc (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "have \"\\<dots> \\<le> Max (insert (Suc (Suc n)) (set ns))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc n) \\<le> Max (insert (Suc (Suc n)) (set ns))", "by (rule Max_ge, simp_all)"], ["proof (state)\nthis:\n  Suc (Suc n) \\<le> Max (insert (Suc (Suc n)) (set ns))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = Suc 0 \\<or>\n                a \\<in> set (enum\n                              (nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key}))\n                              index key\n                              (case n of 0 \\<Rightarrow> n\n                               | Suc 0 \\<Rightarrow> n\n                               | Suc (Suc i) \\<Rightarrow> u + n')\n                              (key (take (Suc (Suc n)) xs !\n                                    mini (take (Suc (Suc n)) xs) key))\n                              (key (take (Suc (Suc n)) xs !\n                                    maxi (take (Suc (Suc n)) xs) key)));\n        key (take (Suc (Suc n)) xs !\n             mini (take (Suc (Suc n)) xs) key) \\<noteq>\n        key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n        (u + n' -\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n'),\n         Suc 0 #\n         enum\n          (nths (take (Suc (Suc n)) xs)\n            (- {mini (take (Suc (Suc n)) xs) key,\n                maxi (take (Suc (Suc n)) xs) key}))\n          index key\n          (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n           | Suc (Suc i) \\<Rightarrow> u + n')\n          (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n          (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n         [Suc 0],\n         take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n         map the\n          (fill\n            (nths (take (Suc (Suc n)) xs)\n              (- {mini (take (Suc (Suc n)) xs) key,\n                  maxi (take (Suc (Suc n)) xs) key}))\n            (offs\n              (enum\n                (nths (take (Suc (Suc n)) xs)\n                  (- {mini (take (Suc (Suc n)) xs) key,\n                      maxi (take (Suc (Suc n)) xs) key}))\n                index key\n                (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                 | Suc (Suc i) \\<Rightarrow> u + n')\n                (key (take (Suc (Suc n)) xs !\n                      mini (take (Suc (Suc n)) xs) key))\n                (key (take (Suc (Suc n)) xs !\n                      maxi (take (Suc (Suc n)) xs) key)))\n              0)\n            index key n\n            (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n            (key (take (Suc (Suc n)) xs !\n                  maxi (take (Suc (Suc n)) xs) key))) @\n         [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]);\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        v =\n        u + n' -\n        (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n         | Suc (Suc i) \\<Rightarrow> u + n');\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc n)) xs)\n           (- {mini (take (Suc (Suc n)) xs) key,\n               maxi (take (Suc (Suc n)) xs) key}))\n         index key\n         (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n          | Suc (Suc i) \\<Rightarrow> u + n')\n         (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n         (key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc n)) xs)\n             (- {mini (take (Suc (Suc n)) xs) key,\n                 maxi (take (Suc (Suc n)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc n)) xs)\n                 (- {mini (take (Suc (Suc n)) xs) key,\n                     maxi (take (Suc (Suc n)) xs) key}))\n               index key\n               (case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                | Suc (Suc i) \\<Rightarrow> u + n')\n               (key (take (Suc (Suc n)) xs !\n                     mini (take (Suc (Suc n)) xs) key))\n               (key (take (Suc (Suc n)) xs !\n                     maxi (take (Suc (Suc n)) xs) key)))\n             0)\n           index key n\n           (key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key))\n           (key (take (Suc (Suc n)) xs !\n                 maxi (take (Suc (Suc n)) xs) key))) @\n        [take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key]\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "finally"], ["proof (chain)\npicking this:\n  i < Max (insert (Suc (Suc n)) (set ns))", "show \"i < Max (insert (Suc (Suc n)) (set ns))\""], ["proof (prove)\nusing this:\n  i < Max (insert (Suc (Suc n)) (set ns))\n\ngoal (1 subgoal):\n 1. i < Max (insert (Suc (Suc n)) (set ns))", "."], ["proof (state)\nthis:\n  i < Max (insert (Suc (Suc n)) (set ns))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "assume D: \"i \\<in> set ns'\""], ["proof (state)\nthis:\n  i \\<in> set ns'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence \"0 < length ns'\""], ["proof (prove)\nusing this:\n  i \\<in> set ns'\n\ngoal (1 subgoal):\n 1. 0 < length ns'", "by (rule length_pos_if_in_set)"], ["proof (state)\nthis:\n  0 < length ns'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence \"fst (snd (?t r' v)) \\<noteq> []\""], ["proof (prove)\nusing this:\n  0 < length ns'\n\ngoal (1 subgoal):\n 1. fst (snd (round index key p q r'\n               (v, ns, drop (Suc (Suc n)) xs))) \\<noteq>\n    []", "using B"], ["proof (prove)\nusing this:\n  0 < length ns'\n  round index key p q r' (v, ns, drop (Suc (Suc n)) xs) = (u', ns', xs')\n\ngoal (1 subgoal):\n 1. fst (snd (round index key p q r'\n               (v, ns, drop (Suc (Suc n)) xs))) \\<noteq>\n    []", "by simp"], ["proof (state)\nthis:\n  fst (snd (round index key p q r' (v, ns, drop (Suc (Suc n)) xs))) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence E: \"\\<exists>n \\<in> set ns. 0 < n\""], ["proof (prove)\nusing this:\n  fst (snd (round index key p q r' (v, ns, drop (Suc (Suc n)) xs))) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<in>set ns. 0 < n", "by (simp add: round_nil)"], ["proof (state)\nthis:\n  \\<exists>n\\<in>set ns. 0 < n\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "hence F: \"ns \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<in>set ns. 0 < n\n\ngoal (1 subgoal):\n 1. ns \\<noteq> []", "by (cases ns, simp_all)"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>round_suc_suc index key (take (Suc (Suc n)) xs) n n' u =\n                (if key (take (Suc (Suc n)) xs !\n                         mini (take (Suc (Suc n)) xs) key) =\n                    key (take (Suc (Suc n)) xs !\n                         maxi (take (Suc (Suc n)) xs) key)\n                 then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n                       take (Suc (Suc n)) xs)\n                 else let k = case n of 0 \\<Rightarrow> n\n                              | Suc 0 \\<Rightarrow> n\n                              | Suc (Suc i) \\<Rightarrow> u + n';\n                          zs = nths (take (Suc (Suc n)) xs)\n                                (- {mini (take (Suc (Suc n)) xs) key,\n                                    maxi (take (Suc (Suc n)) xs) key});\n                          ms = enum zs index key k\n                                (key (take (Suc (Suc n)) xs !\nmini (take (Suc (Suc n)) xs) key))\n                                (key (take (Suc (Suc n)) xs !\nmaxi (take (Suc (Suc n)) xs) key))\n                      in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                          take (Suc (Suc n)) xs !\n                          mini (take (Suc (Suc n)) xs) key #\n                          map the\n                           (fill zs (offs ms 0) index key n\n                             (key (take (Suc (Suc n)) xs !\n                                   mini (take (Suc (Suc n)) xs) key))\n                             (key (take (Suc (Suc n)) xs !\n                                   maxi (take (Suc (Suc n)) xs) key))) @\n                          [take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        (if key (take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key) =\n            key (take (Suc (Suc n)) xs ! maxi (take (Suc (Suc n)) xs) key)\n         then (u + n' - n, replicate (Suc (Suc n)) (Suc 0),\n               take (Suc (Suc n)) xs)\n         else let k = case n of 0 \\<Rightarrow> n | Suc 0 \\<Rightarrow> n\n                      | Suc (Suc i) \\<Rightarrow> u + n';\n                  zs = nths (take (Suc (Suc n)) xs)\n                        (- {mini (take (Suc (Suc n)) xs) key,\n                            maxi (take (Suc (Suc n)) xs) key});\n                  ms = enum zs index key k\n                        (key (take (Suc (Suc n)) xs !\n                              mini (take (Suc (Suc n)) xs) key))\n                        (key (take (Suc (Suc n)) xs !\n                              maxi (take (Suc (Suc n)) xs) key))\n              in (u + n' - k, Suc 0 # ms @ [Suc 0],\n                  take (Suc (Suc n)) xs ! mini (take (Suc (Suc n)) xs) key #\n                  map the\n                   (fill zs (offs ms 0) index key n\n                     (key (take (Suc (Suc n)) xs !\n                           mini (take (Suc (Suc n)) xs) key))\n                     (key (take (Suc (Suc n)) xs !\n                           maxi (take (Suc (Suc n)) xs) key))) @\n                  [take (Suc (Suc n)) xs !\n                   maxi (take (Suc (Suc n)) xs) key]));\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        (v, ms', ws') =\n        round_suc_suc index key (take (Suc (Suc n)) xs) n n' u;\n        a \\<in> set ns'\\<rbrakk>\n       \\<Longrightarrow> a < Max (insert (Suc (Suc n)) (set ns))", "show \"i < Max (insert (Suc (Suc n)) (set ns))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Max (insert (Suc (Suc n)) (set ns))", "proof (cases \"Suc 0 < Max (set ns)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "case True"], ["proof (state)\nthis:\n  Suc 0 < Max (set ns)\n\ngoal (2 subgoals):\n 1. Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "hence \"Max (set ns') < Max (set ns)\""], ["proof (prove)\nusing this:\n  Suc 0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. Max (set ns') < Max (set ns)", "using C and F"], ["proof (prove)\nusing this:\n  Suc 0 < Max (set ns)\n  ns \\<noteq> [] \\<longrightarrow>\n  Suc 0 < Max (set ns) \\<longrightarrow> Max (set ns') < Max (set ns)\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. Max (set ns') < Max (set ns)", "by simp"], ["proof (state)\nthis:\n  Max (set ns') < Max (set ns)\n\ngoal (2 subgoals):\n 1. Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  Max (set ns') < Max (set ns)\n\ngoal (2 subgoals):\n 1. Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "have \"i \\<le> Max (set ns')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> Max (set ns')", "using D"], ["proof (prove)\nusing this:\n  i \\<in> set ns'\n\ngoal (1 subgoal):\n 1. i \\<le> Max (set ns')", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  i \\<le> Max (set ns')\n\ngoal (2 subgoals):\n 1. Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))\n 2. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  Max (set ns') < Max (set ns)\n  i \\<le> Max (set ns')", "show ?thesis"], ["proof (prove)\nusing this:\n  Max (set ns') < Max (set ns)\n  i \\<le> Max (set ns')\n\ngoal (1 subgoal):\n 1. i < Max (insert (Suc (Suc n)) (set ns))", "using F"], ["proof (prove)\nusing this:\n  Max (set ns') < Max (set ns)\n  i \\<le> Max (set ns')\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. i < Max (insert (Suc (Suc n)) (set ns))", "by simp"], ["proof (state)\nthis:\n  i < Max (insert (Suc (Suc n)) (set ns))\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "case False"], ["proof (state)\nthis:\n  \\<not> Suc 0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  \\<not> Suc 0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "from E"], ["proof (chain)\npicking this:\n  \\<exists>n\\<in>set ns. 0 < n", "obtain j where G: \"j \\<in> set ns\" and H: \"0 < j\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<in>set ns. 0 < n\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> set ns; 0 < j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  j \\<in> set ns\n  0 < j\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "have \"j \\<le> Max (set ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> Max (set ns)", "using G"], ["proof (prove)\nusing this:\n  j \\<in> set ns\n\ngoal (1 subgoal):\n 1. j \\<le> Max (set ns)", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  j \\<le> Max (set ns)\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "hence \"0 < Max (set ns)\""], ["proof (prove)\nusing this:\n  j \\<le> Max (set ns)\n\ngoal (1 subgoal):\n 1. 0 < Max (set ns)", "using H"], ["proof (prove)\nusing this:\n  j \\<le> Max (set ns)\n  0 < j\n\ngoal (1 subgoal):\n 1. 0 < Max (set ns)", "by simp"], ["proof (state)\nthis:\n  0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> Suc 0 < Max (set ns)\n  0 < Max (set ns)", "have \"Max (set ns) = Suc 0\""], ["proof (prove)\nusing this:\n  \\<not> Suc 0 < Max (set ns)\n  0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. Max (set ns) = Suc 0", "by simp"], ["proof (state)\nthis:\n  Max (set ns) = Suc 0\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "hence \"Max (set (fst (snd (?t r' v)))) = Suc 0\""], ["proof (prove)\nusing this:\n  Max (set ns) = Suc 0\n\ngoal (1 subgoal):\n 1. Max (set (fst (snd (round index key p q r'\n                         (v, ns, drop (Suc (Suc n)) xs))))) =\n    Suc 0", "using F"], ["proof (prove)\nusing this:\n  Max (set ns) = Suc 0\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. Max (set (fst (snd (round index key p q r'\n                         (v, ns, drop (Suc (Suc n)) xs))))) =\n    Suc 0", "by (rule_tac round_max_eq, simp_all)"], ["proof (state)\nthis:\n  Max (set (fst (snd (round index key p q r'\n                       (v, ns, drop (Suc (Suc n)) xs))))) =\n  Suc 0\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "hence \"Max (set ns') = Suc 0\""], ["proof (prove)\nusing this:\n  Max (set (fst (snd (round index key p q r'\n                       (v, ns, drop (Suc (Suc n)) xs))))) =\n  Suc 0\n\ngoal (1 subgoal):\n 1. Max (set ns') = Suc 0", "using B"], ["proof (prove)\nusing this:\n  Max (set (fst (snd (round index key p q r'\n                       (v, ns, drop (Suc (Suc n)) xs))))) =\n  Suc 0\n  round index key p q r' (v, ns, drop (Suc (Suc n)) xs) = (u', ns', xs')\n\ngoal (1 subgoal):\n 1. Max (set ns') = Suc 0", "by simp"], ["proof (state)\nthis:\n  Max (set ns') = Suc 0\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "moreover"], ["proof (state)\nthis:\n  Max (set ns') = Suc 0\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "have \"i \\<le> Max (set ns')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> Max (set ns')", "using D"], ["proof (prove)\nusing this:\n  i \\<in> set ns'\n\ngoal (1 subgoal):\n 1. i \\<le> Max (set ns')", "by (rule_tac Max_ge, simp)"], ["proof (state)\nthis:\n  i \\<le> Max (set ns')\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "ultimately"], ["proof (chain)\npicking this:\n  Max (set ns') = Suc 0\n  i \\<le> Max (set ns')", "have \"i < Suc (Suc n)\""], ["proof (prove)\nusing this:\n  Max (set ns') = Suc 0\n  i \\<le> Max (set ns')\n\ngoal (1 subgoal):\n 1. i < Suc (Suc n)", "by simp"], ["proof (state)\nthis:\n  i < Suc (Suc n)\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "also"], ["proof (state)\nthis:\n  i < Suc (Suc n)\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "have \"\\<dots> \\<le> Max (insert (Suc (Suc n)) (set ns))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc n) \\<le> Max (insert (Suc (Suc n)) (set ns))", "by (rule Max_ge, simp_all)"], ["proof (state)\nthis:\n  Suc (Suc n) \\<le> Max (insert (Suc (Suc n)) (set ns))\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < Max (set ns) \\<Longrightarrow>\n    i < Max (insert (Suc (Suc n)) (set ns))", "finally"], ["proof (chain)\npicking this:\n  i < Max (insert (Suc (Suc n)) (set ns))", "show ?thesis"], ["proof (prove)\nusing this:\n  i < Max (insert (Suc (Suc n)) (set ns))\n\ngoal (1 subgoal):\n 1. i < Max (insert (Suc (Suc n)) (set ns))", "."], ["proof (state)\nthis:\n  i < Max (insert (Suc (Suc n)) (set ns))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < Max (insert (Suc (Suc n)) (set ns))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (set ms' \\<union> set ns') < Max (insert (Suc (Suc n)) (set ns))\n\ngoal:\nNo subgoals!", "qed"], ["", "termination gcsort_aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. All gcsort_aux_dom", "proof (relation \"measure (\\<lambda>(index, key, p, t). Max (set (fst (snd t))))\",\n simp_all add: find_None_iff, erule exE, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p ns xs x.\n       \\<lbrakk>x \\<in> set ns; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (gcsort_round index key p ns xs))))\n                         < Max (set ns)", "fix index p ns xs i and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p ns xs x.\n       \\<lbrakk>x \\<in> set ns; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (gcsort_round index key p ns xs))))\n                         < Max (set ns)", "let ?t = \"gcsort_round index key p ns xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p ns xs x.\n       \\<lbrakk>x \\<in> set ns; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (gcsort_round index key p ns xs))))\n                         < Max (set ns)", "assume A: \"Suc 0 < i\" and B: \"i \\<in> set ns\""], ["proof (state)\nthis:\n  Suc 0 < i\n  i \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<And>index key p ns xs x.\n       \\<lbrakk>x \\<in> set ns; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (gcsort_round index key p ns xs))))\n                         < Max (set ns)", "have C: \"0 < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length ns", "using B"], ["proof (prove)\nusing this:\n  i \\<in> set ns\n\ngoal (1 subgoal):\n 1. 0 < length ns", "by (rule length_pos_if_in_set)"], ["proof (state)\nthis:\n  0 < length ns\n\ngoal (1 subgoal):\n 1. \\<And>index key p ns xs x.\n       \\<lbrakk>x \\<in> set ns; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (gcsort_round index key p ns xs))))\n                         < Max (set ns)", "moreover"], ["proof (state)\nthis:\n  0 < length ns\n\ngoal (1 subgoal):\n 1. \\<And>index key p ns xs x.\n       \\<lbrakk>x \\<in> set ns; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (gcsort_round index key p ns xs))))\n                         < Max (set ns)", "have \"\\<exists>i \\<in> set ns. Suc 0 < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>set ns. Suc 0 < i", "using A and B"], ["proof (prove)\nusing this:\n  Suc 0 < i\n  i \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>set ns. Suc 0 < i", ".."], ["proof (state)\nthis:\n  \\<exists>i\\<in>set ns. Suc 0 < i\n\ngoal (1 subgoal):\n 1. \\<And>index key p ns xs x.\n       \\<lbrakk>x \\<in> set ns; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (gcsort_round index key p ns xs))))\n                         < Max (set ns)", "hence \"Suc 0 < Max (set ns)\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>set ns. Suc 0 < i\n\ngoal (1 subgoal):\n 1. Suc 0 < Max (set ns)", "using C"], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>set ns. Suc 0 < i\n  0 < length ns\n\ngoal (1 subgoal):\n 1. Suc 0 < Max (set ns)", "by (subst Max_gr_iff, simp_all)"], ["proof (state)\nthis:\n  Suc 0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. \\<And>index key p ns xs x.\n       \\<lbrakk>x \\<in> set ns; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (gcsort_round index key p ns xs))))\n                         < Max (set ns)", "ultimately"], ["proof (chain)\npicking this:\n  0 < length ns\n  Suc 0 < Max (set ns)", "have \"Max (set (fst (snd ?t))) < Max (set (fst (snd (0, ns, xs))))\""], ["proof (prove)\nusing this:\n  0 < length ns\n  Suc 0 < Max (set ns)\n\ngoal (1 subgoal):\n 1. Max (set (fst (snd (gcsort_round index key p ns xs))))\n    < Max (set (fst (snd (0::'c, ns, xs))))", "by (insert round_max_less [of \"(0, ns, xs)\"], simp)"], ["proof (state)\nthis:\n  Max (set (fst (snd (gcsort_round index key p ns xs))))\n  < Max (set (fst (snd (0::?'c1, ns, xs))))\n\ngoal (1 subgoal):\n 1. \\<And>index key p ns xs x.\n       \\<lbrakk>x \\<in> set ns; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> Max (set (fst (snd\n   (gcsort_round index key p ns xs))))\n                         < Max (set ns)", "thus \"Max (set (fst (snd ?t))) < Max (set ns)\""], ["proof (prove)\nusing this:\n  Max (set (fst (snd (gcsort_round index key p ns xs))))\n  < Max (set (fst (snd (0::?'c1, ns, xs))))\n\ngoal (1 subgoal):\n 1. Max (set (fst (snd (gcsort_round index key p ns xs)))) < Max (set ns)", "by simp"], ["proof (state)\nthis:\n  Max (set (fst (snd (gcsort_round index key p ns xs)))) < Max (set ns)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nNow steps 2, 3, and 4 of the proof method, which are independent of the properties to be proven, can\nbe accomplished. Particularly, function @{text gcsort} constitutes the complete formal definition of\nGCsort, as it puts the algorithm's inputs and outputs into their expected form.\n\nObserve that the conditional expression contained in the definition of function @{const gcsort_aux}\nneed not be reflected in the definition of inductive set @{text gcsort_set} as just one alternative\ngives rise to a recursive call, viz. as its only purpose is to ensure the function's termination.\n\n\\null\n\\<close>"], ["", "definition gcsort_in :: \"'a list \\<Rightarrow> nat \\<times> nat list \\<times> 'a list\" where\n\"gcsort_in xs \\<equiv> (0, [length xs], xs)\""], ["", "definition gcsort_out :: \"nat \\<times> nat list \\<times> 'a list \\<Rightarrow> 'a list\" where\n\"gcsort_out \\<equiv> snd \\<circ> snd\""], ["", "definition gcsort :: \"('a, 'b::linorder) index_sign \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> nat \\<Rightarrow>\n  'a list \\<Rightarrow> 'a list\" where\n\"gcsort index key p xs \\<equiv> gcsort_out (gcsort_aux index key p (gcsort_in xs))\""], ["", "inductive_set gcsort_set :: \"('a, 'b::linorder) index_sign \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> nat \\<Rightarrow>\n  nat \\<times> nat list \\<times> 'a list \\<Rightarrow> (nat \\<times> nat list \\<times> 'a list) set\"\nfor index key p t where\nR0: \"t \\<in> gcsort_set index key p t\" |\nR1: \"(u, ns, xs) \\<in> gcsort_set index key p t \\<Longrightarrow>\n  gcsort_round index key p ns xs \\<in> gcsort_set index key p t\""], ["", "lemma gcsort_subset:\n  assumes A: \"t' \\<in> gcsort_set index key p t\"\n  shows \"gcsort_set index key p t' \\<subseteq> gcsort_set index key p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcsort_set index key p t' \\<subseteq> gcsort_set index key p t", "by (rule subsetI, erule gcsort_set.induct, rule A, rule R1)"], ["", "lemma gcsort_aux_set:\n \"gcsort_aux index key p t \\<in> gcsort_set index key p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcsort_aux index key p t \\<in> gcsort_set index key p t", "proof (induction index key p t rule: gcsort_aux.induct, simp, rule conjI,\n rule_tac [!] impI, rule R0, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p u ns xs.\n       \\<lbrakk>gcsort_aux index key p (gcsort_round index key p ns xs)\n                \\<in> gcsort_set index key p\n                       (gcsort_round index key p ns xs);\n        \\<exists>y. find ((<) (Suc 0)) ns = Some y\\<rbrakk>\n       \\<Longrightarrow> gcsort_aux index key p\n                          (gcsort_round index key p ns xs)\n                         \\<in> gcsort_set index key p (u, ns, xs)", "fix index p u ns xs and key :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p u ns xs.\n       \\<lbrakk>gcsort_aux index key p (gcsort_round index key p ns xs)\n                \\<in> gcsort_set index key p\n                       (gcsort_round index key p ns xs);\n        \\<exists>y. find ((<) (Suc 0)) ns = Some y\\<rbrakk>\n       \\<Longrightarrow> gcsort_aux index key p\n                          (gcsort_round index key p ns xs)\n                         \\<in> gcsort_set index key p (u, ns, xs)", "let ?t = \"gcsort_round index key p ns xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p u ns xs.\n       \\<lbrakk>gcsort_aux index key p (gcsort_round index key p ns xs)\n                \\<in> gcsort_set index key p\n                       (gcsort_round index key p ns xs);\n        \\<exists>y. find ((<) (Suc 0)) ns = Some y\\<rbrakk>\n       \\<Longrightarrow> gcsort_aux index key p\n                          (gcsort_round index key p ns xs)\n                         \\<in> gcsort_set index key p (u, ns, xs)", "assume \"gcsort_aux index key p ?t \\<in> gcsort_set index key p ?t\""], ["proof (state)\nthis:\n  gcsort_aux index key p (gcsort_round index key p ns xs)\n  \\<in> gcsort_set index key p (gcsort_round index key p ns xs)\n\ngoal (1 subgoal):\n 1. \\<And>index key p u ns xs.\n       \\<lbrakk>gcsort_aux index key p (gcsort_round index key p ns xs)\n                \\<in> gcsort_set index key p\n                       (gcsort_round index key p ns xs);\n        \\<exists>y. find ((<) (Suc 0)) ns = Some y\\<rbrakk>\n       \\<Longrightarrow> gcsort_aux index key p\n                          (gcsort_round index key p ns xs)\n                         \\<in> gcsort_set index key p (u, ns, xs)", "moreover"], ["proof (state)\nthis:\n  gcsort_aux index key p (gcsort_round index key p ns xs)\n  \\<in> gcsort_set index key p (gcsort_round index key p ns xs)\n\ngoal (1 subgoal):\n 1. \\<And>index key p u ns xs.\n       \\<lbrakk>gcsort_aux index key p (gcsort_round index key p ns xs)\n                \\<in> gcsort_set index key p\n                       (gcsort_round index key p ns xs);\n        \\<exists>y. find ((<) (Suc 0)) ns = Some y\\<rbrakk>\n       \\<Longrightarrow> gcsort_aux index key p\n                          (gcsort_round index key p ns xs)\n                         \\<in> gcsort_set index key p (u, ns, xs)", "have \"(u, ns, xs) \\<in> gcsort_set index key p (u, ns, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, ns, xs) \\<in> gcsort_set index key p (u, ns, xs)", "by (rule R0)"], ["proof (state)\nthis:\n  (u, ns, xs) \\<in> gcsort_set index key p (u, ns, xs)\n\ngoal (1 subgoal):\n 1. \\<And>index key p u ns xs.\n       \\<lbrakk>gcsort_aux index key p (gcsort_round index key p ns xs)\n                \\<in> gcsort_set index key p\n                       (gcsort_round index key p ns xs);\n        \\<exists>y. find ((<) (Suc 0)) ns = Some y\\<rbrakk>\n       \\<Longrightarrow> gcsort_aux index key p\n                          (gcsort_round index key p ns xs)\n                         \\<in> gcsort_set index key p (u, ns, xs)", "hence \"?t \\<in> gcsort_set index key p (u, ns, xs)\""], ["proof (prove)\nusing this:\n  (u, ns, xs) \\<in> gcsort_set index key p (u, ns, xs)\n\ngoal (1 subgoal):\n 1. gcsort_round index key p ns xs \\<in> gcsort_set index key p (u, ns, xs)", "by (rule R1)"], ["proof (state)\nthis:\n  gcsort_round index key p ns xs \\<in> gcsort_set index key p (u, ns, xs)\n\ngoal (1 subgoal):\n 1. \\<And>index key p u ns xs.\n       \\<lbrakk>gcsort_aux index key p (gcsort_round index key p ns xs)\n                \\<in> gcsort_set index key p\n                       (gcsort_round index key p ns xs);\n        \\<exists>y. find ((<) (Suc 0)) ns = Some y\\<rbrakk>\n       \\<Longrightarrow> gcsort_aux index key p\n                          (gcsort_round index key p ns xs)\n                         \\<in> gcsort_set index key p (u, ns, xs)", "hence \"gcsort_set index key p ?t \\<subseteq> gcsort_set index key p (u, ns, xs)\""], ["proof (prove)\nusing this:\n  gcsort_round index key p ns xs \\<in> gcsort_set index key p (u, ns, xs)\n\ngoal (1 subgoal):\n 1. gcsort_set index key p (gcsort_round index key p ns xs)\n    \\<subseteq> gcsort_set index key p (u, ns, xs)", "by (rule gcsort_subset)"], ["proof (state)\nthis:\n  gcsort_set index key p (gcsort_round index key p ns xs)\n  \\<subseteq> gcsort_set index key p (u, ns, xs)\n\ngoal (1 subgoal):\n 1. \\<And>index key p u ns xs.\n       \\<lbrakk>gcsort_aux index key p (gcsort_round index key p ns xs)\n                \\<in> gcsort_set index key p\n                       (gcsort_round index key p ns xs);\n        \\<exists>y. find ((<) (Suc 0)) ns = Some y\\<rbrakk>\n       \\<Longrightarrow> gcsort_aux index key p\n                          (gcsort_round index key p ns xs)\n                         \\<in> gcsort_set index key p (u, ns, xs)", "ultimately"], ["proof (chain)\npicking this:\n  gcsort_aux index key p (gcsort_round index key p ns xs)\n  \\<in> gcsort_set index key p (gcsort_round index key p ns xs)\n  gcsort_set index key p (gcsort_round index key p ns xs)\n  \\<subseteq> gcsort_set index key p (u, ns, xs)", "show \"gcsort_aux index key p ?t\n    \\<in> gcsort_set index key p (u, ns, xs)\""], ["proof (prove)\nusing this:\n  gcsort_aux index key p (gcsort_round index key p ns xs)\n  \\<in> gcsort_set index key p (gcsort_round index key p ns xs)\n  gcsort_set index key p (gcsort_round index key p ns xs)\n  \\<subseteq> gcsort_set index key p (u, ns, xs)\n\ngoal (1 subgoal):\n 1. gcsort_aux index key p (gcsort_round index key p ns xs)\n    \\<in> gcsort_set index key p (u, ns, xs)", ".."], ["proof (state)\nthis:\n  gcsort_aux index key p (gcsort_round index key p ns xs)\n  \\<in> gcsort_set index key p (u, ns, xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Proof of a preliminary invariant\""], ["", "text \\<open>\nThis section is dedicated to the proof of the invariance of predicate @{text add_inv}, defined here\nbelow, over inductive set @{const gcsort_set}. This invariant will later be used to prove GCsort's\ncorrectness properties.\n\nAnother predicate, @{text bn_inv}, is also defined, using predicate @{const bn_valid} defined above.\n\n\\null\n\\<close>"], ["", "fun bn_inv :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<times> nat list \\<times> 'a list \\<Rightarrow> bool\" where\n\"bn_inv p q (u, ns, xs) =\n  (\\<forall>n \\<in> set ns. case n of Suc (Suc m) \\<Rightarrow> bn_valid m p q | _ \\<Rightarrow> True)\""], ["", "fun add_inv :: \"nat \\<Rightarrow> nat \\<times> nat list \\<times> 'a list \\<Rightarrow> bool\" where\n\"add_inv n (u, ns, xs) =\n  (foldl (+) 0 ns = n \\<and> length xs = n)\""], ["", "lemma gcsort_add_input:\n \"add_inv (length xs) (0, [length xs], xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_inv (length xs) (0, [length xs], xs)", "by simp"], ["", "lemma add_base:\n \"foldl (+) (k + m) ns = foldl (+) m ns + (k :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) (k + m) ns = foldl (+) m ns + k", "by (induction ns arbitrary: m, simp_all, subst add.assoc, simp)"], ["", "lemma add_base_zero:\n \"foldl (+) k ns = foldl (+) 0 ns + (k :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) k ns = foldl (+) 0 ns + k", "by (insert add_base [of k 0 ns], simp)"], ["", "lemma bn_count_le:\n \"bn_count ns \\<le> foldl (+) 0 ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count ns \\<le> foldl (+) 0 ns", "by (induction ns rule: bn_count.induct, simp_all add: add_suc, subst add_base_zero,\n simp)"], ["", "text \\<open>\n\\null\n\nHere below is the proof of the main property of predicate @{const bn_inv}, which states that if the\nobjects' number is not larger than the counters' upper bound, then, as long as there are buckets to\nbe split, the arguments $p$ and $q$ passed by function @{const round} to function @{const bn_comp}\nare such that $0 < q \\leq p$.\n\n\\null\n\\<close>"], ["", "lemma bn_inv_intro [rule_format]:\n \"foldl (+) 0 ns \\<le> p \\<longrightarrow>\n    bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (u, ns, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) 0 ns \\<le> p \\<longrightarrow>\n    bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (u, ns, xs)", "proof (induction ns, simp_all, (rule impI)+, subst (asm) (3) add_base_zero,\n subst (1 2) add_base_zero, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ns.\n       \\<lbrakk>Ball (set ns)\n                 (case_nat True\n                   (case_nat True\n                     (\\<lambda>m.\n                         bn_valid m (p - bn_count ns)\n                          (foldl (+) 0 ns - bn_count ns))));\n        foldl (+) 0 ns + a \\<le> p\\<rbrakk>\n       \\<Longrightarrow> (case a of 0 \\<Rightarrow> True\n                          | Suc 0 \\<Rightarrow> True\n                          | Suc (Suc m) \\<Rightarrow>\n                              bn_valid m (p - bn_count (a # ns))\n                               (foldl (+) 0 ns + a -\n                                bn_count (a # ns))) \\<and>\n                         (\\<forall>x\\<in>set ns.\n                             case x of 0 \\<Rightarrow> True\n                             | Suc 0 \\<Rightarrow> True\n                             | Suc (Suc m) \\<Rightarrow>\n                                 bn_valid m (p - bn_count (a # ns))\n                                  (foldl (+) 0 ns + a - bn_count (a # ns)))", "fix n ns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ns.\n       \\<lbrakk>Ball (set ns)\n                 (case_nat True\n                   (case_nat True\n                     (\\<lambda>m.\n                         bn_valid m (p - bn_count ns)\n                          (foldl (+) 0 ns - bn_count ns))));\n        foldl (+) 0 ns + a \\<le> p\\<rbrakk>\n       \\<Longrightarrow> (case a of 0 \\<Rightarrow> True\n                          | Suc 0 \\<Rightarrow> True\n                          | Suc (Suc m) \\<Rightarrow>\n                              bn_valid m (p - bn_count (a # ns))\n                               (foldl (+) 0 ns + a -\n                                bn_count (a # ns))) \\<and>\n                         (\\<forall>x\\<in>set ns.\n                             case x of 0 \\<Rightarrow> True\n                             | Suc 0 \\<Rightarrow> True\n                             | Suc (Suc m) \\<Rightarrow>\n                                 bn_valid m (p - bn_count (a # ns))\n                                  (foldl (+) 0 ns + a - bn_count (a # ns)))", "assume\n    A: \"\\<forall>x \\<in> set ns. case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True | Suc (Suc m) \\<Rightarrow>\n      bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\" and\n    B: \"foldl (+) 0 ns + n \\<le> p\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ns.\n     case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n     | Suc (Suc m) \\<Rightarrow>\n         bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\n  foldl (+) 0 ns + n \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>a ns.\n       \\<lbrakk>Ball (set ns)\n                 (case_nat True\n                   (case_nat True\n                     (\\<lambda>m.\n                         bn_valid m (p - bn_count ns)\n                          (foldl (+) 0 ns - bn_count ns))));\n        foldl (+) 0 ns + a \\<le> p\\<rbrakk>\n       \\<Longrightarrow> (case a of 0 \\<Rightarrow> True\n                          | Suc 0 \\<Rightarrow> True\n                          | Suc (Suc m) \\<Rightarrow>\n                              bn_valid m (p - bn_count (a # ns))\n                               (foldl (+) 0 ns + a -\n                                bn_count (a # ns))) \\<and>\n                         (\\<forall>x\\<in>set ns.\n                             case x of 0 \\<Rightarrow> True\n                             | Suc 0 \\<Rightarrow> True\n                             | Suc (Suc m) \\<Rightarrow>\n                                 bn_valid m (p - bn_count (a # ns))\n                                  (foldl (+) 0 ns + a - bn_count (a # ns)))", "show\n   \"(case n of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True | Suc (Suc m) \\<Rightarrow>\n      bn_valid m (p - bn_count (n # ns))\n        (foldl (+) 0 ns + n - bn_count (n # ns))) \\<and>\n    (\\<forall>x \\<in> set ns. case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True | Suc (Suc m) \\<Rightarrow>\n      bn_valid m (p - bn_count (n # ns))\n        (foldl (+) 0 ns + n - bn_count (n # ns)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case n of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n     | Suc (Suc m) \\<Rightarrow>\n         bn_valid m (p - bn_count (n # ns))\n          (foldl (+) 0 ns + n - bn_count (n # ns))) \\<and>\n    (\\<forall>x\\<in>set ns.\n        case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n        | Suc (Suc m) \\<Rightarrow>\n            bn_valid m (p - bn_count (n # ns))\n             (foldl (+) 0 ns + n - bn_count (n # ns)))", "using [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case n of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n     | Suc (Suc m) \\<Rightarrow>\n         bn_valid m (p - bn_count (n # ns))\n          (foldl (+) 0 ns + n - bn_count (n # ns))) \\<and>\n    (\\<forall>x\\<in>set ns.\n        case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n        | Suc (Suc m) \\<Rightarrow>\n            bn_valid m (p - bn_count (n # ns))\n             (foldl (+) 0 ns + n - bn_count (n # ns)))", "proof (rule conjI, rule_tac [2] ballI, simp_all split: nat.split, rule_tac [!] allI,\n   rule_tac [!] impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       n = Suc (Suc x2) \\<Longrightarrow>\n       bn_valid x2 (p - bn_count (Suc (Suc x2) # ns))\n        (Suc (Suc (foldl (+) 0 ns + x2)) - bn_count (Suc (Suc x2) # ns))\n 2. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       n = Suc (Suc x2) \\<Longrightarrow>\n       bn_valid x2 (p - bn_count (Suc (Suc x2) # ns))\n        (Suc (Suc (foldl (+) 0 ns + x2)) - bn_count (Suc (Suc x2) # ns))\n 2. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "assume C: \"n = Suc (Suc m)\""], ["proof (state)\nthis:\n  n = Suc (Suc m)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       n = Suc (Suc x2) \\<Longrightarrow>\n       bn_valid x2 (p - bn_count (Suc (Suc x2) # ns))\n        (Suc (Suc (foldl (+) 0 ns + x2)) - bn_count (Suc (Suc x2) # ns))\n 2. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "show \"bn_valid m (p - bn_count (Suc (Suc m) # ns))\n      (Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns))\"\n      (is \"bn_valid _ ?p ?q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_valid m (p - bn_count (Suc (Suc m) # ns))\n     (Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns))", "proof (rule bn_valid.cases [of \"(m, ?p, ?q)\"], simp_all, erule conjE, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> bn_count ns < Suc (Suc (foldl (+) 0 ns + n))\n 2. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> bn_count ns < Suc (Suc (foldl (+) 0 ns + n))\n 2. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "have \"bn_count ns \\<le> foldl (+) 0 ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count ns \\<le> foldl (+) 0 ns", "by (rule bn_count_le)"], ["proof (state)\nthis:\n  bn_count ns \\<le> foldl (+) 0 ns\n\ngoal (2 subgoals):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> bn_count ns < Suc (Suc (foldl (+) 0 ns + n))\n 2. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "thus \"bn_count ns < Suc (Suc (foldl (+) 0 ns + k))\""], ["proof (prove)\nusing this:\n  bn_count ns \\<le> foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. bn_count ns < Suc (Suc (foldl (+) 0 ns + k))", "by simp"], ["proof (state)\nthis:\n  bn_count ns < Suc (Suc (foldl (+) 0 ns + k))\n\ngoal (1 subgoal):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "assume \"m = Suc (Suc k)\""], ["proof (state)\nthis:\n  m = Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "hence \"Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns =\n        foldl (+) 0 ns + n - Suc (Suc (bn_count ns))\""], ["proof (prove)\nusing this:\n  m = Suc (Suc k)\n\ngoal (1 subgoal):\n 1. Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns =\n    foldl (+) 0 ns + n - Suc (Suc (bn_count ns))", "using C"], ["proof (prove)\nusing this:\n  m = Suc (Suc k)\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns =\n    foldl (+) 0 ns + n - Suc (Suc (bn_count ns))", "by simp"], ["proof (state)\nthis:\n  Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns =\n  foldl (+) 0 ns + n - Suc (Suc (bn_count ns))\n\ngoal (1 subgoal):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "also"], ["proof (state)\nthis:\n  Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns =\n  foldl (+) 0 ns + n - Suc (Suc (bn_count ns))\n\ngoal (1 subgoal):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "have \"\\<dots> \\<le> p - Suc (Suc (bn_count ns))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) 0 ns + n - Suc (Suc (bn_count ns))\n    \\<le> p - Suc (Suc (bn_count ns))", "using B"], ["proof (prove)\nusing this:\n  foldl (+) 0 ns + n \\<le> p\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns + n - Suc (Suc (bn_count ns))\n    \\<le> p - Suc (Suc (bn_count ns))", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0 ns + n - Suc (Suc (bn_count ns))\n  \\<le> p - Suc (Suc (bn_count ns))\n\ngoal (1 subgoal):\n 1. \\<And>n pa q.\n       \\<lbrakk>m = Suc (Suc n);\n        p - bn_count (Suc (Suc m) # ns) = pa \\<and>\n        Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns) =\n        q\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns + n)) - bn_count ns\n                         \\<le> p - Suc (Suc (bn_count ns))", "finally"], ["proof (chain)\npicking this:\n  Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns\n  \\<le> p - Suc (Suc (bn_count ns))", "show \"Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns \\<le>\n        p - Suc (Suc (bn_count ns))\""], ["proof (prove)\nusing this:\n  Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns\n  \\<le> p - Suc (Suc (bn_count ns))\n\ngoal (1 subgoal):\n 1. Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns\n    \\<le> p - Suc (Suc (bn_count ns))", "."], ["proof (state)\nthis:\n  Suc (Suc (foldl (+) 0 ns + k)) - bn_count ns\n  \\<le> p - Suc (Suc (bn_count ns))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bn_valid m (p - bn_count (Suc (Suc m) # ns))\n   (Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns))\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "fix n' m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "assume \"n' \\<in> set ns\""], ["proof (state)\nthis:\n  n' \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "with A"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set ns.\n     case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n     | Suc (Suc m) \\<Rightarrow>\n         bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\n  n' \\<in> set ns", "have \"case n' of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True | Suc (Suc m) \\<Rightarrow>\n      bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ns.\n     case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n     | Suc (Suc m) \\<Rightarrow>\n         bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\n  n' \\<in> set ns\n\ngoal (1 subgoal):\n 1. case n' of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n    | Suc (Suc m) \\<Rightarrow>\n        bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)", ".."], ["proof (state)\nthis:\n  case n' of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n  | Suc (Suc m) \\<Rightarrow>\n      bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "moreover"], ["proof (state)\nthis:\n  case n' of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n  | Suc (Suc m) \\<Rightarrow>\n      bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "assume \"n' = Suc (Suc m)\""], ["proof (state)\nthis:\n  n' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "ultimately"], ["proof (chain)\npicking this:\n  case n' of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n  | Suc (Suc m) \\<Rightarrow>\n      bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\n  n' = Suc (Suc m)", "have \"bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\""], ["proof (prove)\nusing this:\n  case n' of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n  | Suc (Suc m) \\<Rightarrow>\n      bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\n  n' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)", "by simp"], ["proof (state)\nthis:\n  bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>x \\<in> set ns; x = Suc (Suc x2)\\<rbrakk>\n       \\<Longrightarrow> bn_valid x2 (p - bn_count (n # ns))\n                          (foldl (+) 0 ns + n - bn_count (n # ns))", "thus \"bn_valid m (p - bn_count (n # ns))\n      (foldl (+) 0 ns + n - bn_count (n # ns))\"\n      (is \"bn_valid _ ?p ?q\")"], ["proof (prove)\nusing this:\n  bn_valid m (p - bn_count ns) (foldl (+) 0 ns - bn_count ns)\n\ngoal (1 subgoal):\n 1. bn_valid m (p - bn_count (n # ns))\n     (foldl (+) 0 ns + n - bn_count (n # ns))", "proof (rule_tac bn_valid.cases [of \"(m, ?p, ?q)\"], simp_all, (erule_tac conjE)+,\n     simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na pa q.\n       \\<lbrakk>m = Suc (Suc na); bn_count ns < foldl (+) 0 ns;\n        foldl (+) 0 ns - bn_count ns \\<le> p - bn_count ns;\n        p - bn_count (n # ns) = pa;\n        foldl (+) 0 ns + n - bn_count (n # ns) = q\\<rbrakk>\n       \\<Longrightarrow> 0 < q \\<and> q \\<le> pa", "fix p' q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na pa q.\n       \\<lbrakk>m = Suc (Suc na); bn_count ns < foldl (+) 0 ns;\n        foldl (+) 0 ns - bn_count ns \\<le> p - bn_count ns;\n        p - bn_count (n # ns) = pa;\n        foldl (+) 0 ns + n - bn_count (n # ns) = q\\<rbrakk>\n       \\<Longrightarrow> 0 < q \\<and> q \\<le> pa", "assume \"bn_count ns < foldl (+) 0 ns\""], ["proof (state)\nthis:\n  bn_count ns < foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. \\<And>na pa q.\n       \\<lbrakk>m = Suc (Suc na); bn_count ns < foldl (+) 0 ns;\n        foldl (+) 0 ns - bn_count ns \\<le> p - bn_count ns;\n        p - bn_count (n # ns) = pa;\n        foldl (+) 0 ns + n - bn_count (n # ns) = q\\<rbrakk>\n       \\<Longrightarrow> 0 < q \\<and> q \\<le> pa", "moreover"], ["proof (state)\nthis:\n  bn_count ns < foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. \\<And>na pa q.\n       \\<lbrakk>m = Suc (Suc na); bn_count ns < foldl (+) 0 ns;\n        foldl (+) 0 ns - bn_count ns \\<le> p - bn_count ns;\n        p - bn_count (n # ns) = pa;\n        foldl (+) 0 ns + n - bn_count (n # ns) = q\\<rbrakk>\n       \\<Longrightarrow> 0 < q \\<and> q \\<le> pa", "assume \"p - bn_count (n # ns) = p'\""], ["proof (state)\nthis:\n  p - bn_count (n # ns) = p'\n\ngoal (1 subgoal):\n 1. \\<And>na pa q.\n       \\<lbrakk>m = Suc (Suc na); bn_count ns < foldl (+) 0 ns;\n        foldl (+) 0 ns - bn_count ns \\<le> p - bn_count ns;\n        p - bn_count (n # ns) = pa;\n        foldl (+) 0 ns + n - bn_count (n # ns) = q\\<rbrakk>\n       \\<Longrightarrow> 0 < q \\<and> q \\<le> pa", "hence \"p' = p - bn_count (n # ns)\""], ["proof (prove)\nusing this:\n  p - bn_count (n # ns) = p'\n\ngoal (1 subgoal):\n 1. p' = p - bn_count (n # ns)", ".."], ["proof (state)\nthis:\n  p' = p - bn_count (n # ns)\n\ngoal (1 subgoal):\n 1. \\<And>na pa q.\n       \\<lbrakk>m = Suc (Suc na); bn_count ns < foldl (+) 0 ns;\n        foldl (+) 0 ns - bn_count ns \\<le> p - bn_count ns;\n        p - bn_count (n # ns) = pa;\n        foldl (+) 0 ns + n - bn_count (n # ns) = q\\<rbrakk>\n       \\<Longrightarrow> 0 < q \\<and> q \\<le> pa", "moreover"], ["proof (state)\nthis:\n  p' = p - bn_count (n # ns)\n\ngoal (1 subgoal):\n 1. \\<And>na pa q.\n       \\<lbrakk>m = Suc (Suc na); bn_count ns < foldl (+) 0 ns;\n        foldl (+) 0 ns - bn_count ns \\<le> p - bn_count ns;\n        p - bn_count (n # ns) = pa;\n        foldl (+) 0 ns + n - bn_count (n # ns) = q\\<rbrakk>\n       \\<Longrightarrow> 0 < q \\<and> q \\<le> pa", "assume \"foldl (+) 0 ns + n - bn_count (n # ns) = q'\""], ["proof (state)\nthis:\n  foldl (+) 0 ns + n - bn_count (n # ns) = q'\n\ngoal (1 subgoal):\n 1. \\<And>na pa q.\n       \\<lbrakk>m = Suc (Suc na); bn_count ns < foldl (+) 0 ns;\n        foldl (+) 0 ns - bn_count ns \\<le> p - bn_count ns;\n        p - bn_count (n # ns) = pa;\n        foldl (+) 0 ns + n - bn_count (n # ns) = q\\<rbrakk>\n       \\<Longrightarrow> 0 < q \\<and> q \\<le> pa", "hence \"q' = foldl (+) 0 ns + n - bn_count (n # ns)\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns + n - bn_count (n # ns) = q'\n\ngoal (1 subgoal):\n 1. q' = foldl (+) 0 ns + n - bn_count (n # ns)", ".."], ["proof (state)\nthis:\n  q' = foldl (+) 0 ns + n - bn_count (n # ns)\n\ngoal (1 subgoal):\n 1. \\<And>na pa q.\n       \\<lbrakk>m = Suc (Suc na); bn_count ns < foldl (+) 0 ns;\n        foldl (+) 0 ns - bn_count ns \\<le> p - bn_count ns;\n        p - bn_count (n # ns) = pa;\n        foldl (+) 0 ns + n - bn_count (n # ns) = q\\<rbrakk>\n       \\<Longrightarrow> 0 < q \\<and> q \\<le> pa", "ultimately"], ["proof (chain)\npicking this:\n  bn_count ns < foldl (+) 0 ns\n  p' = p - bn_count (n # ns)\n  q' = foldl (+) 0 ns + n - bn_count (n # ns)", "show \"0 < q' \\<and> q' \\<le> p'\""], ["proof (prove)\nusing this:\n  bn_count ns < foldl (+) 0 ns\n  p' = p - bn_count (n # ns)\n  q' = foldl (+) 0 ns + n - bn_count (n # ns)\n\ngoal (1 subgoal):\n 1. 0 < q' \\<and> q' \\<le> p'", "using B"], ["proof (prove)\nusing this:\n  bn_count ns < foldl (+) 0 ns\n  p' = p - bn_count (n # ns)\n  q' = foldl (+) 0 ns + n - bn_count (n # ns)\n  foldl (+) 0 ns + n \\<le> p\n\ngoal (1 subgoal):\n 1. 0 < q' \\<and> q' \\<le> p'", "by (rule_tac bn_count.cases [of \"n # ns\"], simp_all)"], ["proof (state)\nthis:\n  0 < q' \\<and> q' \\<le> p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bn_valid m (p - bn_count (n # ns))\n   (foldl (+) 0 ns + n - bn_count (n # ns))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case n of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n   | Suc (Suc m) \\<Rightarrow>\n       bn_valid m (p - bn_count (n # ns))\n        (foldl (+) 0 ns + n - bn_count (n # ns))) \\<and>\n  (\\<forall>x\\<in>set ns.\n      case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n      | Suc (Suc m) \\<Rightarrow>\n          bn_valid m (p - bn_count (n # ns))\n           (foldl (+) 0 ns + n - bn_count (n # ns)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nIn what follows, the invariance of predicate @{const add_inv} over inductive set @{const gcsort_set}\nis then proven as lemma @{text gcsort_add_inv}. It holds under the conditions that the objects'\nnumber is not larger than the counters' upper bound and function @{text index} satisfies predicate\n@{const index_less}, and states that, if the counters' sum initially matches the objects' number,\nthis is still true after any recursive round.\n\n\\null\n\\<close>"], ["", "lemma bn_comp_fst_ge [rule_format]:\n \"bn_valid n p q \\<longrightarrow> n \\<le> fst (bn_comp n p q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_valid n p q \\<longrightarrow> n \\<le> fst (bn_comp n p q r)", "proof (induction n p q r rule: bn_comp.induct, simp_all del: mult_Suc,\n rule impI, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p q r.\n       \\<lbrakk>0 < q; q \\<le> p\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "fix n p r and q :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p q r.\n       \\<lbrakk>0 < q; q \\<le> p\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "assume \"0 < q\""], ["proof (state)\nthis:\n  0 < q\n\ngoal (1 subgoal):\n 1. \\<And>n p q r.\n       \\<lbrakk>0 < q; q \\<le> p\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "hence \"Suc (Suc n) = Suc (Suc n) * q div q\""], ["proof (prove)\nusing this:\n  0 < q\n\ngoal (1 subgoal):\n 1. Suc (Suc n) = Suc (Suc n) * q div q", "by simp"], ["proof (state)\nthis:\n  Suc (Suc n) = Suc (Suc n) * q div q\n\ngoal (1 subgoal):\n 1. \\<And>n p q r.\n       \\<lbrakk>0 < q; q \\<le> p\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "also"], ["proof (state)\nthis:\n  Suc (Suc n) = Suc (Suc n) * q div q\n\ngoal (1 subgoal):\n 1. \\<And>n p q r.\n       \\<lbrakk>0 < q; q \\<le> p\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "assume \"q \\<le> p\""], ["proof (state)\nthis:\n  q \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>n p q r.\n       \\<lbrakk>0 < q; q \\<le> p\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "hence \"Suc (Suc n) * q \\<le> Suc (Suc n) * p\""], ["proof (prove)\nusing this:\n  q \\<le> p\n\ngoal (1 subgoal):\n 1. Suc (Suc n) * q \\<le> Suc (Suc n) * p", "by (rule mult_le_mono2)"], ["proof (state)\nthis:\n  Suc (Suc n) * q \\<le> Suc (Suc n) * p\n\ngoal (1 subgoal):\n 1. \\<And>n p q r.\n       \\<lbrakk>0 < q; q \\<le> p\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "hence \"Suc (Suc n) * q div q \\<le> (Suc (Suc n) * p + r) div q\""], ["proof (prove)\nusing this:\n  Suc (Suc n) * q \\<le> Suc (Suc n) * p\n\ngoal (1 subgoal):\n 1. Suc (Suc n) * q div q \\<le> (Suc (Suc n) * p + r) div q", "by (rule_tac div_le_mono, simp)"], ["proof (state)\nthis:\n  Suc (Suc n) * q div q \\<le> (Suc (Suc n) * p + r) div q\n\ngoal (1 subgoal):\n 1. \\<And>n p q r.\n       \\<lbrakk>0 < q; q \\<le> p\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "finally"], ["proof (chain)\npicking this:\n  Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "show \"Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q\""], ["proof (prove)\nusing this:\n  Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q\n\ngoal (1 subgoal):\n 1. Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q", "."], ["proof (state)\nthis:\n  Suc (Suc n) \\<le> (Suc (Suc n) * p + r) div q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bn_comp_fst_nonzero:\n \"bn_valid n p q \\<Longrightarrow> 0 < n \\<Longrightarrow> 0 < fst (bn_comp n p q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bn_valid n p q; 0 < n\\<rbrakk>\n    \\<Longrightarrow> 0 < fst (bn_comp n p q r)", "by (drule bn_comp_fst_ge [where r = r], simp)"], ["", "lemma bn_comp_snd_less:\n \"r < q \\<Longrightarrow> snd (bn_comp n p q r) < q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < q \\<Longrightarrow> snd (bn_comp n p q r) < q", "by (induction n p q r rule: bn_comp.induct, simp_all)"], ["", "lemma add_replicate:\n \"foldl (+) k (replicate m n) = k + m * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) k (replicate m n) = k + m * n", "by (induction m arbitrary: k, simp_all)"], ["", "lemma fill_length:\n \"length (fill xs ns index key n mi ma) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fill xs ns index key n mi ma) = n", "by (induction xs arbitrary: ns, simp_all add: Let_def)"], ["", "lemma enum_add [rule_format]:\n  assumes\n    A: \"index_less index key\" and\n    B: \"0 < n\"\n  shows \"(\\<forall>x \\<in> set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    foldl (+) 0 (enum xs index key n mi ma) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set xs. key x \\<in> {mi..ma}) \\<longrightarrow>\n    foldl (+) 0 (enum xs index key n mi ma) = length xs", "proof (induction xs, simp_all add: Let_def add_zeros, rule impI, (erule conjE)+,\n simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>foldl (+) 0 (enum xs index key n mi ma) = length xs;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0\n                          ((enum xs index key n mi ma)\n                           [index key a n mi ma :=\n                              Suc (enum xs index key n mi ma !\n                                   index key a n mi ma)]) =\n                         Suc (length xs)", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>foldl (+) 0 (enum xs index key n mi ma) = length xs;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0\n                          ((enum xs index key n mi ma)\n                           [index key a n mi ma :=\n                              Suc (enum xs index key n mi ma !\n                                   index key a n mi ma)]) =\n                         Suc (length xs)", "assume \"mi \\<le> key x\" and \"key x \\<le> ma\""], ["proof (state)\nthis:\n  mi \\<le> key x\n  key x \\<le> ma\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>foldl (+) 0 (enum xs index key n mi ma) = length xs;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0\n                          ((enum xs index key n mi ma)\n                           [index key a n mi ma :=\n                              Suc (enum xs index key n mi ma !\n                                   index key a n mi ma)]) =\n                         Suc (length xs)", "hence \"index key x n mi ma < n\"\n    (is \"?i < _\")"], ["proof (prove)\nusing this:\n  mi \\<le> key x\n  key x \\<le> ma\n\ngoal (1 subgoal):\n 1. index key x n mi ma < n", "using A and B"], ["proof (prove)\nusing this:\n  mi \\<le> key x\n  key x \\<le> ma\n  index_less index key\n  0 < n\n\ngoal (1 subgoal):\n 1. index key x n mi ma < n", "by (simp add: index_less_def)"], ["proof (state)\nthis:\n  index key x n mi ma < n\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>foldl (+) 0 (enum xs index key n mi ma) = length xs;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0\n                          ((enum xs index key n mi ma)\n                           [index key a n mi ma :=\n                              Suc (enum xs index key n mi ma !\n                                   index key a n mi ma)]) =\n                         Suc (length xs)", "hence \"?i < length (enum xs index key n mi ma)\"\n    (is \"_ < length ?ns\")"], ["proof (prove)\nusing this:\n  index key x n mi ma < n\n\ngoal (1 subgoal):\n 1. index key x n mi ma < length (enum xs index key n mi ma)", "by (simp add: enum_length)"], ["proof (state)\nthis:\n  index key x n mi ma < length (enum xs index key n mi ma)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>foldl (+) 0 (enum xs index key n mi ma) = length xs;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0\n                          ((enum xs index key n mi ma)\n                           [index key a n mi ma :=\n                              Suc (enum xs index key n mi ma !\n                                   index key a n mi ma)]) =\n                         Suc (length xs)", "hence \"foldl (+) 0 (?ns[?i := Suc (?ns ! ?i)]) = Suc (foldl (+) 0 ?ns)\""], ["proof (prove)\nusing this:\n  index key x n mi ma < length (enum xs index key n mi ma)\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)]) =\n    Suc (foldl (+) 0 (enum xs index key n mi ma))", "by (rule add_update)"], ["proof (state)\nthis:\n  foldl (+) 0\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)]) =\n  Suc (foldl (+) 0 (enum xs index key n mi ma))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>foldl (+) 0 (enum xs index key n mi ma) = length xs;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0\n                          ((enum xs index key n mi ma)\n                           [index key a n mi ma :=\n                              Suc (enum xs index key n mi ma !\n                                   index key a n mi ma)]) =\n                         Suc (length xs)", "moreover"], ["proof (state)\nthis:\n  foldl (+) 0\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)]) =\n  Suc (foldl (+) 0 (enum xs index key n mi ma))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>foldl (+) 0 (enum xs index key n mi ma) = length xs;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0\n                          ((enum xs index key n mi ma)\n                           [index key a n mi ma :=\n                              Suc (enum xs index key n mi ma !\n                                   index key a n mi ma)]) =\n                         Suc (length xs)", "assume \"foldl (+) 0 ?ns = length xs\""], ["proof (state)\nthis:\n  foldl (+) 0 (enum xs index key n mi ma) = length xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>foldl (+) 0 (enum xs index key n mi ma) = length xs;\n        mi \\<le> key a; key a \\<le> ma;\n        \\<forall>x\\<in>set xs. mi \\<le> key x \\<and> key x \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0\n                          ((enum xs index key n mi ma)\n                           [index key a n mi ma :=\n                              Suc (enum xs index key n mi ma !\n                                   index key a n mi ma)]) =\n                         Suc (length xs)", "ultimately"], ["proof (chain)\npicking this:\n  foldl (+) 0\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)]) =\n  Suc (foldl (+) 0 (enum xs index key n mi ma))\n  foldl (+) 0 (enum xs index key n mi ma) = length xs", "show \"foldl (+) 0 (?ns[?i := Suc (?ns ! ?i)]) = Suc (length xs)\""], ["proof (prove)\nusing this:\n  foldl (+) 0\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)]) =\n  Suc (foldl (+) 0 (enum xs index key n mi ma))\n  foldl (+) 0 (enum xs index key n mi ma) = length xs\n\ngoal (1 subgoal):\n 1. foldl (+) 0\n     ((enum xs index key n mi ma)\n      [index key x n mi ma :=\n         Suc (enum xs index key n mi ma ! index key x n mi ma)]) =\n    Suc (length xs)", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0\n   ((enum xs index key n mi ma)\n    [index key x n mi ma :=\n       Suc (enum xs index key n mi ma ! index key x n mi ma)]) =\n  Suc (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_add_inv [rule_format]:\n \"index_less index key \\<longrightarrow> bn_inv p q t \\<longrightarrow> add_inv n t \\<longrightarrow>\n    add_inv n (round index key p q r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_less index key \\<longrightarrow>\n    bn_inv p q t \\<longrightarrow>\n    add_inv n t \\<longrightarrow> add_inv n (round index key p q r t)", "using [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_less index key \\<longrightarrow>\n    bn_inv p q t \\<longrightarrow>\n    add_inv n t \\<longrightarrow> add_inv n (round index key p q r t)", "proof (induction index key p q r t arbitrary: n rule: round.induct, simp_all\n add: Let_def split: prod.split, (rule allI)+, (rule impI)+, erule conjE,\n (rule_tac [2] allI)+, (rule_tac [2] impI)+, (erule_tac [2] conjE)+,\n rule_tac [2] ssubst [OF add_base_zero], simp_all add: add_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n x1 a b.\n       \\<lbrakk>\\<And>na.\n                   foldl (+) 0 ns = na \\<and>\n                   n - Suc 0 = na \\<longrightarrow>\n                   foldl (+) 0 a = na \\<and> length b = na;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        index_less index key;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> Suc (foldl (+) 0 a) = n \\<and> Suc (length b) = n\n 2. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "fix n ns ns' and xs' :: \"'a list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n x1 a b.\n       \\<lbrakk>\\<And>na.\n                   foldl (+) 0 ns = na \\<and>\n                   n - Suc 0 = na \\<longrightarrow>\n                   foldl (+) 0 a = na \\<and> length b = na;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        index_less index key;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> Suc (foldl (+) 0 a) = n \\<and> Suc (length b) = n\n 2. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "assume \"\\<And>n'. foldl (+) 0 ns = n' \\<and> n - Suc 0 = n' \\<longrightarrow>\n    foldl (+) 0 ns' = n' \\<and> length xs' = n'\""], ["proof (state)\nthis:\n  foldl (+) 0 ns = ?n' \\<and> n - Suc 0 = ?n' \\<longrightarrow>\n  foldl (+) 0 ns' = ?n' \\<and> length xs' = ?n'\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n x1 a b.\n       \\<lbrakk>\\<And>na.\n                   foldl (+) 0 ns = na \\<and>\n                   n - Suc 0 = na \\<longrightarrow>\n                   foldl (+) 0 a = na \\<and> length b = na;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        index_less index key;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> Suc (foldl (+) 0 a) = n \\<and> Suc (length b) = n\n 2. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "hence \"foldl (+) 0 ns = n - Suc 0 \\<longrightarrow>\n    foldl (+) 0 ns' = n - Suc 0 \\<and> length xs' = n - Suc 0\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = ?n' \\<and> n - Suc 0 = ?n' \\<longrightarrow>\n  foldl (+) 0 ns' = ?n' \\<and> length xs' = ?n'\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns = n - Suc 0 \\<longrightarrow>\n    foldl (+) 0 ns' = n - Suc 0 \\<and> length xs' = n - Suc 0", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0 ns = n - Suc 0 \\<longrightarrow>\n  foldl (+) 0 ns' = n - Suc 0 \\<and> length xs' = n - Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n x1 a b.\n       \\<lbrakk>\\<And>na.\n                   foldl (+) 0 ns = na \\<and>\n                   n - Suc 0 = na \\<longrightarrow>\n                   foldl (+) 0 a = na \\<and> length b = na;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        index_less index key;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> Suc (foldl (+) 0 a) = n \\<and> Suc (length b) = n\n 2. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "moreover"], ["proof (state)\nthis:\n  foldl (+) 0 ns = n - Suc 0 \\<longrightarrow>\n  foldl (+) 0 ns' = n - Suc 0 \\<and> length xs' = n - Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n x1 a b.\n       \\<lbrakk>\\<And>na.\n                   foldl (+) 0 ns = na \\<and>\n                   n - Suc 0 = na \\<longrightarrow>\n                   foldl (+) 0 a = na \\<and> length b = na;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        index_less index key;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> Suc (foldl (+) 0 a) = n \\<and> Suc (length b) = n\n 2. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "assume \"Suc (foldl (+) 0 ns) = n\""], ["proof (state)\nthis:\n  Suc (foldl (+) 0 ns) = n\n\ngoal (2 subgoals):\n 1. \\<And>index key p q r u ns xs n x1 a b.\n       \\<lbrakk>\\<And>na.\n                   foldl (+) 0 ns = na \\<and>\n                   n - Suc 0 = na \\<longrightarrow>\n                   foldl (+) 0 a = na \\<and> length b = na;\n        round index key p q r (u, ns, tl xs) = (x1, a, b);\n        index_less index key;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (foldl (+) 0 ns) = n; length xs = n\\<rbrakk>\n       \\<Longrightarrow> Suc (foldl (+) 0 a) = n \\<and> Suc (length b) = n\n 2. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "ultimately"], ["proof (chain)\npicking this:\n  foldl (+) 0 ns = n - Suc 0 \\<longrightarrow>\n  foldl (+) 0 ns' = n - Suc 0 \\<and> length xs' = n - Suc 0\n  Suc (foldl (+) 0 ns) = n", "show \"Suc (foldl (+) 0 ns') = n \\<and> Suc (length xs') = n\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ns = n - Suc 0 \\<longrightarrow>\n  foldl (+) 0 ns' = n - Suc 0 \\<and> length xs' = n - Suc 0\n  Suc (foldl (+) 0 ns) = n\n\ngoal (1 subgoal):\n 1. Suc (foldl (+) 0 ns') = n \\<and> Suc (length xs') = n", "by simp"], ["proof (state)\nthis:\n  Suc (foldl (+) 0 ns') = n \\<and> Suc (length xs') = n\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "fix index p q r u m m' ns v ms' ws' ns' n\n    and key :: \"'a \\<Rightarrow> 'b\" and xs :: \"'a list\" and xs' :: \"'a list\" and r' :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "let ?ws = \"take (Suc (Suc m)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "assume\n    A: \"round_suc_suc index key ?ws m m' u = (v, ms', ws')\" and\n    B: \"bn_comp m p q r = (m', r')\" and\n    C: \"index_less index key\" and\n    D: \"bn_valid m p q\" and\n    E: \"length xs = n\""], ["proof (state)\nthis:\n  round_suc_suc index key (take (Suc (Suc m)) xs) m m' u = (v, ms', ws')\n  bn_comp m p q r = (m', r')\n  index_less index key\n  bn_valid m p q\n  length xs = n\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "assume \"\\<And>ws a b c d e f g h n'.\n    ws = ?ws \\<Longrightarrow> a = (m', r') \\<Longrightarrow> b = m' \\<and> c = r' \\<Longrightarrow>\n    d = (v, ms', ws') \\<Longrightarrow> e = v \\<and> f = (ms', ws') \\<Longrightarrow> g = ms' \\<and> h = ws' \\<Longrightarrow>\n      foldl (+) 0 ns = n' \\<and> n - Suc (Suc m) = n' \\<longrightarrow>\n        foldl (+) 0 ns' = n' \\<and> length xs' = n'\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    foldl (+) 0 ns' = ?n' \\<and> length xs' = ?n'\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    foldl (+) 0 ns' = ?n' \\<and> length xs' = ?n'\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "assume \"Suc (Suc (foldl (+) m ns)) = n\""], ["proof (state)\nthis:\n  Suc (Suc (foldl (+) m ns)) = n\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "hence F: \"foldl (+) 0 ns + Suc (Suc m) = n\""], ["proof (prove)\nusing this:\n  Suc (Suc (foldl (+) m ns)) = n\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns + Suc (Suc m) = n", "by (subst (asm) add_base_zero, simp)"], ["proof (state)\nthis:\n  foldl (+) 0 ns + Suc (Suc m) = n\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    foldl (+) 0 ns' = ?n' \\<and> length xs' = ?n'\n  foldl (+) 0 ns + Suc (Suc m) = n", "have\n    G: \"foldl (+) 0 ns' = n - Suc (Suc m) \\<and> length xs' = n - Suc (Suc m)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc m)) xs; ?a = (m', r');\n   ?b = m' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> foldl (+) 0 ns = ?n' \\<and>\n                    n - Suc (Suc m) = ?n' \\<longrightarrow>\n                    foldl (+) 0 ns' = ?n' \\<and> length xs' = ?n'\n  foldl (+) 0 ns + Suc (Suc m) = n\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns' = n - Suc (Suc m) \\<and> length xs' = n - Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0 ns' = n - Suc (Suc m) \\<and> length xs' = n - Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs na x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb naa.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> foldl (+) 0 ns = naa \\<and>\n                                     na - Suc (Suc n) =\n                                     naa \\<longrightarrow>\n                                     foldl (+) 0 aa = naa \\<and>\n                                     length ba = naa;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); index_less index key; bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q;\n        Suc (Suc (foldl (+) n ns)) = na; length xs = na\\<rbrakk>\n       \\<Longrightarrow> foldl (+) 0 aa + foldl (+) 0 a = na \\<and>\n                         length b + length ba = na", "from A"], ["proof (chain)\npicking this:\n  round_suc_suc index key (take (Suc (Suc m)) xs) m m' u = (v, ms', ws')", "show \"foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n    length ws' + length xs' = n\""], ["proof (prove)\nusing this:\n  round_suc_suc index key (take (Suc (Suc m)) xs) m m' u = (v, ms', ws')\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and> length ws' + length xs' = n", "proof (subst (2) add_base_zero, simp add: round_suc_suc_def Let_def split:\n   if_split_asm, (erule_tac [!] conjE)+, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "assume \"Suc 0 # Suc 0 # replicate m (Suc 0) = ms'\""], ["proof (state)\nthis:\n  Suc 0 # Suc 0 # replicate m (Suc 0) = ms'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "hence \"ms' = Suc 0 # Suc 0 # replicate m (Suc 0)\""], ["proof (prove)\nusing this:\n  Suc 0 # Suc 0 # replicate m (Suc 0) = ms'\n\ngoal (1 subgoal):\n 1. ms' = Suc 0 # Suc 0 # replicate m (Suc 0)", ".."], ["proof (state)\nthis:\n  ms' = Suc 0 # Suc 0 # replicate m (Suc 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "hence \"foldl (+) 0 ms' = Suc (Suc m)\""], ["proof (prove)\nusing this:\n  ms' = Suc 0 # Suc 0 # replicate m (Suc 0)\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ms' = Suc (Suc m)", "by (simp add: add_replicate)"], ["proof (state)\nthis:\n  foldl (+) 0 ms' = Suc (Suc m)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "hence \"foldl (+) 0 ns' + foldl (+) 0 ms' = n\""], ["proof (prove)\nusing this:\n  foldl (+) 0 ms' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns' + foldl (+) 0 ms' = n", "using F and G"], ["proof (prove)\nusing this:\n  foldl (+) 0 ms' = Suc (Suc m)\n  foldl (+) 0 ns + Suc (Suc m) = n\n  foldl (+) 0 ns' = n - Suc (Suc m) \\<and> length xs' = n - Suc (Suc m)\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns' + foldl (+) 0 ms' = n", "by simp"], ["proof (state)\nthis:\n  foldl (+) 0 ns' + foldl (+) 0 ms' = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "moreover"], ["proof (state)\nthis:\n  foldl (+) 0 ns' + foldl (+) 0 ms' = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "assume \"?ws = ws'\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs = ws'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "hence \"ws' = ?ws\""], ["proof (prove)\nusing this:\n  take (Suc (Suc m)) xs = ws'\n\ngoal (1 subgoal):\n 1. ws' = take (Suc (Suc m)) xs", ".."], ["proof (state)\nthis:\n  ws' = take (Suc (Suc m)) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "hence \"length ws' = Suc (Suc m)\""], ["proof (prove)\nusing this:\n  ws' = take (Suc (Suc m)) xs\n\ngoal (1 subgoal):\n 1. length ws' = Suc (Suc m)", "using F and E"], ["proof (prove)\nusing this:\n  ws' = take (Suc (Suc m)) xs\n  foldl (+) 0 ns + Suc (Suc m) = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. length ws' = Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  length ws' = Suc (Suc m)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "hence \"length ws' + length xs' = n\""], ["proof (prove)\nusing this:\n  length ws' = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. length ws' + length xs' = n", "using F and G"], ["proof (prove)\nusing this:\n  length ws' = Suc (Suc m)\n  foldl (+) 0 ns + Suc (Suc m) = n\n  foldl (+) 0 ns' = n - Suc (Suc m) \\<and> length xs' = n - Suc (Suc m)\n\ngoal (1 subgoal):\n 1. length ws' + length xs' = n", "by simp"], ["proof (state)\nthis:\n  length ws' + length xs' = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>key (ws' ! mini ws' key) = key (ws' ! maxi ws' key);\n     round_suc_suc index key ws' m m' u = (v, ms', ws'); u + m' - m = v;\n     Suc 0 # Suc 0 # replicate m (Suc 0) = ms';\n     take (Suc (Suc m)) xs = ws'\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n\n 2. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "ultimately"], ["proof (chain)\npicking this:\n  foldl (+) 0 ns' + foldl (+) 0 ms' = n\n  length ws' + length xs' = n", "show ?thesis"], ["proof (prove)\nusing this:\n  foldl (+) 0 ns' + foldl (+) 0 ms' = n\n  length ws' + length xs' = n\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and> length ws' + length xs' = n", ".."], ["proof (state)\nthis:\n  foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and> length ws' + length xs' = n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "let ?nmi = \"mini ?ws key\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "let ?nma = \"maxi ?ws key\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "let ?xmi = \"?ws ! ?nmi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "let ?xma = \"?ws ! ?nma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "let ?mi = \"key ?xmi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "let ?ma = \"key ?xma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "let ?k = \"case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m | Suc (Suc i) \\<Rightarrow> u + m'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "let ?zs = \"nths ?ws (- {?nmi, ?nma})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "let ?ms = \"enum ?zs index key ?k ?mi ?ma\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "assume \"Suc 0 # ?ms @ [Suc 0] = ms'\""], ["proof (state)\nthis:\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0] =\n  ms'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "hence \"ms' = Suc 0 # ?ms @ [Suc 0]\""], ["proof (prove)\nusing this:\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0] =\n  ms'\n\ngoal (1 subgoal):\n 1. ms' =\n    Suc 0 #\n    enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n    [Suc 0]", ".."], ["proof (state)\nthis:\n  ms' =\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "moreover"], ["proof (state)\nthis:\n  ms' =\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "assume\n     \"?xmi # map the (fill ?zs (offs ?ms 0) index key m ?mi ?ma) @ [?xma] = ws'\""], ["proof (state)\nthis:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n  map the\n   (fill\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     (offs\n       (enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n       0)\n     index key m\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n  [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n  ws'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "hence \"ws' = ?xmi # map the (fill ?zs (offs ?ms 0) index key m ?mi ?ma)\n      @ [?xma]\""], ["proof (prove)\nusing this:\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n  map the\n   (fill\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     (offs\n       (enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n       0)\n     index key m\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n  [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n  ws'\n\ngoal (1 subgoal):\n 1. ws' =\n    take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n    map the\n     (fill\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       (offs\n         (enum\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           index key\n           (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n            | Suc (Suc i) \\<Rightarrow> u + m')\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n         0)\n       index key m\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n    [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]", ".."], ["proof (state)\nthis:\n  ws' =\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n  map the\n   (fill\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     (offs\n       (enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n       0)\n     index key m\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n  [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>key (take (Suc (Suc m)) xs !\n                  mini (take (Suc (Suc m)) xs) key) \\<noteq>\n             key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key);\n     u + m' -\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m') =\n     v;\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0] =\n     ms';\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key] =\n     ws';\n     round_suc_suc index key (take (Suc (Suc m)) xs) m m' u =\n     (v, ms', ws')\\<rbrakk>\n    \\<Longrightarrow> foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and>\n                      length ws' + length xs' = n", "ultimately"], ["proof (chain)\npicking this:\n  ms' =\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0]\n  ws' =\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n  map the\n   (fill\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     (offs\n       (enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n       0)\n     index key m\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n  [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]", "show ?thesis"], ["proof (prove)\nusing this:\n  ms' =\n  Suc 0 #\n  enum\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n   index key\n   (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n    | Suc (Suc i) \\<Rightarrow> u + m')\n   (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n   (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n  [Suc 0]\n  ws' =\n  take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n  map the\n   (fill\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     (offs\n       (enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)))\n       0)\n     index key m\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n  [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key]\n\ngoal (1 subgoal):\n 1. foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and> length ws' + length xs' = n", "proof (simp add: fill_length, subst (2) add_base_zero, simp, cases m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ms' =\n             Suc 0 #\n             enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) @\n             [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     m = 0\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                foldl (+) 0\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key))))) =\n                      n \\<and>\n                      Suc (Suc (m + length xs')) = n\n 2. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "case 0"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ms' =\n             Suc 0 #\n             enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) @\n             [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     m = 0\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                foldl (+) 0\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key))))) =\n                      n \\<and>\n                      Suc (Suc (m + length xs')) = n\n 2. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "moreover"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ms' =\n             Suc 0 #\n             enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) @\n             [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     m = 0\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                foldl (+) 0\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key))))) =\n                      n \\<and>\n                      Suc (Suc (m + length xs')) = n\n 2. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "from this"], ["proof (chain)\npicking this:\n  m = 0", "have \"length ?ms = 0\""], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. length\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    0", "by (simp add: enum_length)"], ["proof (state)\nthis:\n  length\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ms' =\n             Suc 0 #\n             enum\n              (nths (take (Suc (Suc m)) xs)\n                (- {mini (take (Suc (Suc m)) xs) key,\n                    maxi (take (Suc (Suc m)) xs) key}))\n              index key\n              (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n               | Suc (Suc i) \\<Rightarrow> u + m')\n              (key (take (Suc (Suc m)) xs !\n                    mini (take (Suc (Suc m)) xs) key))\n              (key (take (Suc (Suc m)) xs !\n                    maxi (take (Suc (Suc m)) xs) key)) @\n             [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     ms' =\n     Suc 0 #\n     enum\n      (nths (take (Suc (Suc m)) xs)\n        (- {mini (take (Suc (Suc m)) xs) key,\n            maxi (take (Suc (Suc m)) xs) key}))\n      index key\n      (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n      (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n      (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n     [Suc 0];\n     ws' =\n     take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n     map the\n      (fill\n        (nths (take (Suc (Suc m)) xs)\n          (- {mini (take (Suc (Suc m)) xs) key,\n              maxi (take (Suc (Suc m)) xs) key}))\n        (offs\n          (enum\n            (nths (take (Suc (Suc m)) xs)\n              (- {mini (take (Suc (Suc m)) xs) key,\n                  maxi (take (Suc (Suc m)) xs) key}))\n            index key\n            (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n             | Suc (Suc i) \\<Rightarrow> u + m')\n            (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n            (key (take (Suc (Suc m)) xs !\n                  maxi (take (Suc (Suc m)) xs) key)))\n          0)\n        index key m\n        (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n        (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) @\n     [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n     m = 0\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                foldl (+) 0\n                                 (enum\n                                   (nths (take (Suc (Suc m)) xs)\n                                     (- {mini (take (Suc (Suc m)) xs) key,\n   maxi (take (Suc (Suc m)) xs) key}))\n                                   index key\n                                   (case m of 0 \\<Rightarrow> m\n                                    | Suc 0 \\<Rightarrow> m\n                                    | Suc (Suc i) \\<Rightarrow> u + m')\n                                   (key (take (Suc (Suc m)) xs !\n   mini (take (Suc (Suc m)) xs) key))\n                                   (key (take (Suc (Suc m)) xs !\n   maxi (take (Suc (Suc m)) xs) key))))) =\n                      n \\<and>\n                      Suc (Suc (m + length xs')) = n\n 2. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "ultimately"], ["proof (chain)\npicking this:\n  m = 0\n  length\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  0", "show \"Suc (Suc (foldl (+) 0 ns' + foldl (+) 0 ?ms)) = n \\<and>\n        Suc (Suc (m + length xs')) = n\""], ["proof (prove)\nusing this:\n  m = 0\n  length\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  0\n\ngoal (1 subgoal):\n 1. Suc (Suc (foldl (+) 0 ns' +\n              foldl (+) 0\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key))))) =\n    n \\<and>\n    Suc (Suc (m + length xs')) = n", "using F and G"], ["proof (prove)\nusing this:\n  m = 0\n  length\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  0\n  foldl (+) 0 ns + Suc (Suc m) = n\n  foldl (+) 0 ns' = n - Suc (Suc m) \\<and> length xs' = n - Suc (Suc m)\n\ngoal (1 subgoal):\n 1. Suc (Suc (foldl (+) 0 ns' +\n              foldl (+) 0\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key))))) =\n    n \\<and>\n    Suc (Suc (m + length xs')) = n", "by simp"], ["proof (state)\nthis:\n  Suc (Suc (foldl (+) 0 ns' +\n            foldl (+) 0\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key))))) =\n  n \\<and>\n  Suc (Suc (m + length xs')) = n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "case Suc"], ["proof (state)\nthis:\n  m = Suc nat_\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "moreover"], ["proof (state)\nthis:\n  m = Suc nat_\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "from this"], ["proof (chain)\npicking this:\n  m = Suc nat_", "have \"0 < fst (bn_comp m p q r)\""], ["proof (prove)\nusing this:\n  m = Suc nat_\n\ngoal (1 subgoal):\n 1. 0 < fst (bn_comp m p q r)", "by (rule_tac bn_comp_fst_nonzero [OF D], simp)"], ["proof (state)\nthis:\n  0 < fst (bn_comp m p q r)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "hence \"0 < m'\""], ["proof (prove)\nusing this:\n  0 < fst (bn_comp m p q r)\n\ngoal (1 subgoal):\n 1. 0 < m'", "using B"], ["proof (prove)\nusing this:\n  0 < fst (bn_comp m p q r)\n  bn_comp m p q r = (m', r')\n\ngoal (1 subgoal):\n 1. 0 < m'", "by simp"], ["proof (state)\nthis:\n  0 < m'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "ultimately"], ["proof (chain)\npicking this:\n  m = Suc nat_\n  0 < m'", "have H: \"0 < ?k\""], ["proof (prove)\nusing this:\n  m = Suc nat_\n  0 < m'\n\ngoal (1 subgoal):\n 1. 0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n         | Suc (Suc i) \\<Rightarrow> u + m')", "by (simp split: nat.split)"], ["proof (state)\nthis:\n  0 < (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n       | Suc (Suc i) \\<Rightarrow> u + m')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "have \"foldl (+) 0 ?ms = length ?zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) 0\n     (enum\n       (nths (take (Suc (Suc m)) xs)\n         (- {mini (take (Suc (Suc m)) xs) key,\n             maxi (take (Suc (Suc m)) xs) key}))\n       index key\n       (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n        | Suc (Suc i) \\<Rightarrow> u + m')\n       (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n       (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n    length\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))", "by (rule enum_add [OF C H], simp, rule conjI,\n         ((rule mini_lb | rule maxi_ub), erule in_set_nthsD)+)"], ["proof (state)\nthis:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "moreover"], ["proof (state)\nthis:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "have \"length ?ws = Suc (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc (Suc m)) xs) = Suc (Suc m)", "using F and E"], ["proof (prove)\nusing this:\n  foldl (+) 0 ns + Suc (Suc m) = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. length (take (Suc (Suc m)) xs) = Suc (Suc m)", "by simp"], ["proof (state)\nthis:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "hence \"length ?zs = m\""], ["proof (prove)\nusing this:\n  length (take (Suc (Suc m)) xs) = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. length\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key})) =\n    m", "by (simp add: mini_maxi_nths)"], ["proof (state)\nthis:\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ms' =\n                Suc 0 #\n                enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key)) @\n                [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc m)) xs)\n           (- {mini (take (Suc (Suc m)) xs) key,\n               maxi (take (Suc (Suc m)) xs) key}))\n         index key\n         (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n          | Suc (Suc i) \\<Rightarrow> u + m')\n         (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n         (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key)) @\n        [Suc 0];\n        ws' =\n        take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc m)) xs)\n             (- {mini (take (Suc (Suc m)) xs) key,\n                 maxi (take (Suc (Suc m)) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key)))\n             0)\n           index key m\n           (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n           (key (take (Suc (Suc m)) xs !\n                 maxi (take (Suc (Suc m)) xs) key))) @\n        [take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key];\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (foldl (+) 0 ns' +\n                                   foldl (+) 0\n                                    (enum\n(nths (take (Suc (Suc m)) xs)\n  (- {mini (take (Suc (Suc m)) xs) key, maxi (take (Suc (Suc m)) xs) key}))\nindex key\n(case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n | Suc (Suc i) \\<Rightarrow> u + m')\n(key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n(key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))))) =\n                         n \\<and>\n                         Suc (Suc (m + length xs')) = n", "ultimately"], ["proof (chain)\npicking this:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  m", "show \"Suc (Suc (foldl (+) 0 ns' + foldl (+) 0 ?ms)) = n \\<and>\n        Suc (Suc (m + length xs')) = n\""], ["proof (prove)\nusing this:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  m\n\ngoal (1 subgoal):\n 1. Suc (Suc (foldl (+) 0 ns' +\n              foldl (+) 0\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key))))) =\n    n \\<and>\n    Suc (Suc (m + length xs')) = n", "using F and G"], ["proof (prove)\nusing this:\n  foldl (+) 0\n   (enum\n     (nths (take (Suc (Suc m)) xs)\n       (- {mini (take (Suc (Suc m)) xs) key,\n           maxi (take (Suc (Suc m)) xs) key}))\n     index key\n     (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n      | Suc (Suc i) \\<Rightarrow> u + m')\n     (key (take (Suc (Suc m)) xs ! mini (take (Suc (Suc m)) xs) key))\n     (key (take (Suc (Suc m)) xs ! maxi (take (Suc (Suc m)) xs) key))) =\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key}))\n  length\n   (nths (take (Suc (Suc m)) xs)\n     (- {mini (take (Suc (Suc m)) xs) key,\n         maxi (take (Suc (Suc m)) xs) key})) =\n  m\n  foldl (+) 0 ns + Suc (Suc m) = n\n  foldl (+) 0 ns' = n - Suc (Suc m) \\<and> length xs' = n - Suc (Suc m)\n\ngoal (1 subgoal):\n 1. Suc (Suc (foldl (+) 0 ns' +\n              foldl (+) 0\n               (enum\n                 (nths (take (Suc (Suc m)) xs)\n                   (- {mini (take (Suc (Suc m)) xs) key,\n                       maxi (take (Suc (Suc m)) xs) key}))\n                 index key\n                 (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                  | Suc (Suc i) \\<Rightarrow> u + m')\n                 (key (take (Suc (Suc m)) xs !\n                       mini (take (Suc (Suc m)) xs) key))\n                 (key (take (Suc (Suc m)) xs !\n                       maxi (take (Suc (Suc m)) xs) key))))) =\n    n \\<and>\n    Suc (Suc (m + length xs')) = n", "by simp"], ["proof (state)\nthis:\n  Suc (Suc (foldl (+) 0 ns' +\n            foldl (+) 0\n             (enum\n               (nths (take (Suc (Suc m)) xs)\n                 (- {mini (take (Suc (Suc m)) xs) key,\n                     maxi (take (Suc (Suc m)) xs) key}))\n               index key\n               (case m of 0 \\<Rightarrow> m | Suc 0 \\<Rightarrow> m\n                | Suc (Suc i) \\<Rightarrow> u + m')\n               (key (take (Suc (Suc m)) xs !\n                     mini (take (Suc (Suc m)) xs) key))\n               (key (take (Suc (Suc m)) xs !\n                     maxi (take (Suc (Suc m)) xs) key))))) =\n  n \\<and>\n  Suc (Suc (m + length xs')) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and> length ws' + length xs' = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl (+) 0 ns' + foldl (+) 0 ms' = n \\<and> length ws' + length xs' = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcsort_add_inv:\n  assumes A: \"index_less index key\"\n  shows \"\\<lbrakk>t' \\<in> gcsort_set index key p t; add_inv n t; n \\<le> p\\<rbrakk> \\<Longrightarrow>\n    add_inv n t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in> gcsort_set index key p t; add_inv n t;\n     n \\<le> p\\<rbrakk>\n    \\<Longrightarrow> add_inv n t'", "by (erule gcsort_set.induct, simp, rule round_add_inv [OF A], simp_all del:\n bn_inv.simps, erule conjE, frule sym, erule subst, rule bn_inv_intro, simp)"], ["", "subsection \"Proof of counters' optimization\""], ["", "text \\<open>\nIn this section, it is formally proven that the number of the counters (and then of the buckets as\nwell) used in each recursive round is maximized never exceeding the fixed upper bound.\n\nThis property is formalized by theorem @{text round_len}, which holds under the condition that the\nobjects' number is not larger than the counters' upper bound and states what follows:\n\n\\begin{itemize}\n\n\\item\nWhile there is some bucket with size larger than two, the sum of the number of the used counters and\nthe number of the unused ones -- viz. those, if any, left unused due to the presence of some bucket\nwith size larger than two and equal minimum and maximum keys (cf. section \\ref{SEC4}) -- matches the\ncounters' upper bound.\n\\\\In addition to ensuring the upper bound's enforcement, this implies that the number of the used\ncounters matches the upper bound unless there is some aforesaid bucket not followed by any other\nbucket with size larger than two and distinct minimum and maximum keys.\n\n\\item\nOnce there is no bucket with size larger than two -- in which case a round is executed just in case\nthere is some bucket with size two --, the number of the used counters matches the objects' number.\n\\\\In fact, the algorithm immediately terminates after such a round since every resulting bucket has\nsize one, so that increasing the number of the used counters does not matter in this case.\n\n\\end{itemize}\n\n\\null\n\\<close>"], ["", "lemma round_len_less [rule_format]:\n \"bn_inv p q t \\<longrightarrow> r < q \\<longrightarrow>\n  (r + (foldl (+) 0 (fst (snd t)) - bn_count (fst (snd t))) * p) mod q = 0 \\<longrightarrow>\n    (fst (round index key p q r t) +\n      length (fst (snd (round index key p q r t)))) * q =\n    (fst t + bn_count (fst (snd t))) * q +\n      (foldl (+) 0 (fst (snd t)) - bn_count (fst (snd t))) * p + r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_inv p q t \\<longrightarrow>\n    r < q \\<longrightarrow>\n    (r + (foldl (+) 0 (fst (snd t)) - bn_count (fst (snd t))) * p) mod q =\n    0 \\<longrightarrow>\n    (fst (round index key p q r t) +\n     length (fst (snd (round index key p q r t)))) *\n    q =\n    (fst t + bn_count (fst (snd t))) * q +\n    (foldl (+) 0 (fst (snd t)) - bn_count (fst (snd t))) * p +\n    r", "using [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_inv p q t \\<longrightarrow>\n    r < q \\<longrightarrow>\n    (r + (foldl (+) 0 (fst (snd t)) - bn_count (fst (snd t))) * p) mod q =\n    0 \\<longrightarrow>\n    (fst (round index key p q r t) +\n     length (fst (snd (round index key p q r t)))) *\n    q =\n    (fst t + bn_count (fst (snd t))) * q +\n    (foldl (+) 0 (fst (snd t)) - bn_count (fst (snd t))) * p +\n    r", "proof (induction index key p q r t rule: round.induct, simp_all add: Let_def\n split: prod.split del: all_simps, ((rule allI)+, (rule impI)+, simp add:\n add_suc)+, subst (asm) (3) add_base_zero, subst add_base_zero, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "fix index p q r u n ns n' r' v ms' ws' u'\n    and key :: \"'a \\<Rightarrow> 'b\" and xs :: \"'a list\" and ns' :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "let ?ws = \"take (Suc (Suc n)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "assume\n    A: \"round_suc_suc index key ?ws n n' u = (v, ms', ws')\" and\n    B: \"bn_comp n p q r = (n', r')\" and\n    C: \"bn_valid n p q\""], ["proof (state)\nthis:\n  round_suc_suc index key (take (Suc (Suc n)) xs) n n' u = (v, ms', ws')\n  bn_comp n p q r = (n', r')\n  bn_valid n p q\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "have D: \"bn_count ns \\<le> foldl (+) 0 ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count ns \\<le> foldl (+) 0 ns", "by (rule bn_count_le)"], ["proof (state)\nthis:\n  bn_count ns \\<le> foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "assume \"\\<And>ws a b c d e f g h.\n    ws = ?ws \\<Longrightarrow> a = (n', r') \\<Longrightarrow> b = n' \\<and> c = r' \\<Longrightarrow>\n    d = (v, ms', ws') \\<Longrightarrow> e = v \\<and> f = (ms', ws') \\<Longrightarrow> g = ms' \\<and> h = ws' \\<Longrightarrow>\n      r' < q \\<longrightarrow> (r' + (foldl (+) 0 ns - bn_count ns) * p) mod q = 0 \\<longrightarrow>\n        (u' + length ns') * q =\n        (v + bn_count ns) * q + (foldl (+) 0 ns - bn_count ns) * p + r'\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = (n', r');\n   ?b = n' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> r' < q \\<longrightarrow>\n                    (r' + (foldl (+) 0 ns - bn_count ns) * p) mod q =\n                    0 \\<longrightarrow>\n                    (u' + length ns') * q =\n                    (v + bn_count ns) * q +\n                    (foldl (+) 0 ns - bn_count ns) * p +\n                    r'\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = (n', r');\n   ?b = n' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> r' < q \\<longrightarrow>\n                    (r' + (foldl (+) 0 ns - bn_count ns) * p) mod q =\n                    0 \\<longrightarrow>\n                    (u' + length ns') * q =\n                    (v + bn_count ns) * q +\n                    (foldl (+) 0 ns - bn_count ns) * p +\n                    r'\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "assume \"r < q\""], ["proof (state)\nthis:\n  r < q\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "hence \"snd (bn_comp n p q r) < q\""], ["proof (prove)\nusing this:\n  r < q\n\ngoal (1 subgoal):\n 1. snd (bn_comp n p q r) < q", "by (rule bn_comp_snd_less)"], ["proof (state)\nthis:\n  snd (bn_comp n p q r) < q\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "hence \"r' < q\""], ["proof (prove)\nusing this:\n  snd (bn_comp n p q r) < q\n\ngoal (1 subgoal):\n 1. r' < q", "using B"], ["proof (prove)\nusing this:\n  snd (bn_comp n p q r) < q\n  bn_comp n p q r = (n', r')\n\ngoal (1 subgoal):\n 1. r' < q", "by simp"], ["proof (state)\nthis:\n  r' < q\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "moreover"], ["proof (state)\nthis:\n  r' < q\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "assume E: \"(r + (Suc (Suc (foldl (+) 0 ns + n)) -\n    bn_count (Suc (Suc n) # ns)) * p) mod q = 0\""], ["proof (state)\nthis:\n  (r +\n   (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) * p) mod\n  q =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "from B [symmetric]"], ["proof (chain)\npicking this:\n  (n', r') = bn_comp n p q r", "have \"(r' + (foldl (+) 0 ns - bn_count ns) * p) mod q = 0\""], ["proof (prove)\nusing this:\n  (n', r') = bn_comp n p q r\n\ngoal (1 subgoal):\n 1. (r' + (foldl (+) 0 ns - bn_count ns) * p) mod q = 0", "proof (rule_tac trans [OF _ E], rule_tac bn_comp.cases [of \"(n, p, q, r)\"],\n   simp_all add: add_mult_distrib diff_mult_distrib mod_add_left_eq,\n   rule_tac arg_cong2 [where f = \"(mod)\"], simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>n = Suc (Suc na) \\<and> p = p \\<and> q = q \\<and> r = r;\n        n' = (p + (p + na * p) + r) div q \\<and>\n        r' = (p + (p + na * p) + r) mod q\\<rbrakk>\n       \\<Longrightarrow> p +\n                         (p +\n                          (na * p +\n                           (foldl (+) 0 ns * p - bn_count ns * p))) =\n                         p + (p + (foldl (+) 0 ns * p + na * p)) -\n                         bn_count ns * p", "fix n p q r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>n__ = Suc (Suc na) \\<and>\n                pa__ = p \\<and> qa__ = q \\<and> ra__ = r;\n        n' = (p + (p + na * p) + r) div q \\<and>\n        r' = (p + (p + na * p) + r) mod q\\<rbrakk>\n       \\<Longrightarrow> p +\n                         (p +\n                          (na * p +\n                           (foldl (+) 0 ns * p - bn_count ns * p))) =\n                         p + (p + (foldl (+) 0 ns * p + na * p)) -\n                         bn_count ns * p", "have \"bn_count ns * p \\<le> foldl (+) 0 ns * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count ns * p \\<le> foldl (+) 0 ns * p", "using D"], ["proof (prove)\nusing this:\n  bn_count ns \\<le> foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. bn_count ns * p \\<le> foldl (+) 0 ns * p", "by (rule mult_le_mono1)"], ["proof (state)\nthis:\n  bn_count ns * p \\<le> foldl (+) 0 ns * p\n\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>n__ = Suc (Suc na) \\<and>\n                pa__ = p \\<and> qa__ = q \\<and> ra__ = r;\n        n' = (p + (p + na * p) + r) div q \\<and>\n        r' = (p + (p + na * p) + r) mod q\\<rbrakk>\n       \\<Longrightarrow> p +\n                         (p +\n                          (na * p +\n                           (foldl (+) 0 ns * p - bn_count ns * p))) =\n                         p + (p + (foldl (+) 0 ns * p + na * p)) -\n                         bn_count ns * p", "thus \"p + (p + (n * p + (foldl (+) 0 ns * p - bn_count ns * p))) =\n      p + (p + (foldl (+) 0 ns * p + n * p)) - bn_count ns * p\""], ["proof (prove)\nusing this:\n  bn_count ns * p \\<le> foldl (+) 0 ns * p\n\ngoal (1 subgoal):\n 1. p + (p + (n * p + (foldl (+) 0 ns * p - bn_count ns * p))) =\n    p + (p + (foldl (+) 0 ns * p + n * p)) - bn_count ns * p", "by arith"], ["proof (state)\nthis:\n  p + (p + (n * p + (foldl (+) 0 ns * p - bn_count ns * p))) =\n  p + (p + (foldl (+) 0 ns * p + n * p)) - bn_count ns * p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (r' + (foldl (+) 0 ns - bn_count ns) * p) mod q = 0\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = (n', r');\n   ?b = n' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> r' < q \\<longrightarrow>\n                    (r' + (foldl (+) 0 ns - bn_count ns) * p) mod q =\n                    0 \\<longrightarrow>\n                    (u' + length ns') * q =\n                    (v + bn_count ns) * q +\n                    (foldl (+) 0 ns - bn_count ns) * p +\n                    r'\n  r' < q\n  (r' + (foldl (+) 0 ns - bn_count ns) * p) mod q = 0", "have \"(u' + length ns') * q =\n    (v + bn_count ns) * q + (foldl (+) 0 ns - bn_count ns) * p + r'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = (n', r');\n   ?b = n' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> r' < q \\<longrightarrow>\n                    (r' + (foldl (+) 0 ns - bn_count ns) * p) mod q =\n                    0 \\<longrightarrow>\n                    (u' + length ns') * q =\n                    (v + bn_count ns) * q +\n                    (foldl (+) 0 ns - bn_count ns) * p +\n                    r'\n  r' < q\n  (r' + (foldl (+) 0 ns - bn_count ns) * p) mod q = 0\n\ngoal (1 subgoal):\n 1. (u' + length ns') * q =\n    (v + bn_count ns) * q + (foldl (+) 0 ns - bn_count ns) * p + r'", "by simp"], ["proof (state)\nthis:\n  (u' + length ns') * q =\n  (v + bn_count ns) * q + (foldl (+) 0 ns - bn_count ns) * p + r'\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> x2 < q \\<longrightarrow>\n                                     (x2 +\n(foldl (+) 0 ns - bn_count ns) * p) mod\n                                     q =\n                                     0 \\<longrightarrow>\n                                     (x1b + length aa) * q =\n                                     (x1a + bn_count ns) * q +\n                                     (foldl (+) 0 ns - bn_count ns) * p +\n                                     x2;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2); r < q;\n        (r +\n         (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) *\n         p) mod\n        q =\n        0;\n        bn_valid n p q;\n        \\<forall>x\\<in>set ns.\n           case x of 0 \\<Rightarrow> True | Suc 0 \\<Rightarrow> True\n           | Suc (Suc m) \\<Rightarrow> bn_valid m p q\\<rbrakk>\n       \\<Longrightarrow> (x1b + (length a + length aa)) * q =\n                         (u + bn_count (Suc (Suc n) # ns)) * q +\n                         (Suc (Suc (foldl (+) 0 ns + n)) -\n                          bn_count (Suc (Suc n) # ns)) *\n                         p +\n                         r", "with A [symmetric] and B [symmetric]"], ["proof (chain)\npicking this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc n)) xs) n n' u\n  (n', r') = bn_comp n p q r\n  (u' + length ns') * q =\n  (v + bn_count ns) * q + (foldl (+) 0 ns - bn_count ns) * p + r'", "show\n   \"(u' + (length ms' + length ns')) * q =\n    (u + bn_count (Suc (Suc n) # ns)) * q +\n      (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) * p + r\""], ["proof (prove)\nusing this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc n)) xs) n n' u\n  (n', r') = bn_comp n p q r\n  (u' + length ns') * q =\n  (v + bn_count ns) * q + (foldl (+) 0 ns - bn_count ns) * p + r'\n\ngoal (1 subgoal):\n 1. (u' + (length ms' + length ns')) * q =\n    (u + bn_count (Suc (Suc n) # ns)) * q +\n    (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) * p +\n    r", "proof (rule_tac bn_comp.cases [of \"(n, p, q, r)\"],\n   simp_all add: round_suc_suc_def Let_def enum_length split: if_split_asm)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r' = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r' = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "fix m p' q' r'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "assume\n     \"n = Suc (Suc m)\" and\n     \"p = p'\" and\n     \"q = q'\" and\n     \"r = r'\""], ["proof (state)\nthis:\n  n = Suc (Suc m)\n  p = p'\n  q = q'\n  r = r'\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "moreover"], ["proof (state)\nthis:\n  n = Suc (Suc m)\n  p = p'\n  q = q'\n  r = r'\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "have \"n \\<le> fst (bn_comp n p q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> fst (bn_comp n p q r)", "using C"], ["proof (prove)\nusing this:\n  bn_valid n p q\n\ngoal (1 subgoal):\n 1. n \\<le> fst (bn_comp n p q r)", "by (rule bn_comp_fst_ge)"], ["proof (state)\nthis:\n  n \\<le> fst (bn_comp n p q r)\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "ultimately"], ["proof (chain)\npicking this:\n  n = Suc (Suc m)\n  p = p'\n  q = q'\n  r = r'\n  n \\<le> fst (bn_comp n p q r)", "have \"Suc (Suc m) \\<le> (p' + (p' + m * p') + r') div q'\"\n      (is \"_ \\<le> ?a div _\")"], ["proof (prove)\nusing this:\n  n = Suc (Suc m)\n  p = p'\n  q = q'\n  r = r'\n  n \\<le> fst (bn_comp n p q r)\n\ngoal (1 subgoal):\n 1. Suc (Suc m) \\<le> (p' + (p' + m * p') + r') div q'", "by simp"], ["proof (state)\nthis:\n  Suc (Suc m) \\<le> (p' + (p' + m * p') + r') div q'\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "hence F: \"Suc (Suc m) * q' \\<le> ?a div q' * q'\""], ["proof (prove)\nusing this:\n  Suc (Suc m) \\<le> (p' + (p' + m * p') + r') div q'\n\ngoal (1 subgoal):\n 1. Suc (Suc m) * q' \\<le> (p' + (p' + m * p') + r') div q' * q'", "by (rule mult_le_mono1)"], ["proof (state)\nthis:\n  Suc (Suc m) * q' \\<le> (p' + (p' + m * p') + r') div q' * q'\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "moreover"], ["proof (state)\nthis:\n  Suc (Suc m) * q' \\<le> (p' + (p' + m * p') + r') div q' * q'\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "assume \"(u' + length ns') * q' =\n      (u + ?a div q' - Suc (Suc m) + bn_count ns) * q' +\n        (foldl (+) 0 ns - bn_count ns) * p' + ?a mod q'\""], ["proof (state)\nthis:\n  (u' + length ns') * q' =\n  (u + (p' + (p' + m * p') + r') div q' - Suc (Suc m) + bn_count ns) * q' +\n  (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') mod q'\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "ultimately"], ["proof (chain)\npicking this:\n  Suc (Suc m) * q' \\<le> (p' + (p' + m * p') + r') div q' * q'\n  (u' + length ns') * q' =\n  (u + (p' + (p' + m * p') + r') div q' - Suc (Suc m) + bn_count ns) * q' +\n  (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') mod q'", "have \"(u' + length ns') * q' + Suc (Suc m) * q' =\n      (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n        ?a div q' * q' + ?a mod q'\"\n      (is \"?c = ?d\")"], ["proof (prove)\nusing this:\n  Suc (Suc m) * q' \\<le> (p' + (p' + m * p') + r') div q' * q'\n  (u' + length ns') * q' =\n  (u + (p' + (p' + m * p') + r') div q' - Suc (Suc m) + bn_count ns) * q' +\n  (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') mod q'\n\ngoal (1 subgoal):\n 1. (u' + length ns') * q' + Suc (Suc m) * q' =\n    (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n    (p' + (p' + m * p') + r') div q' * q' +\n    (p' + (p' + m * p') + r') mod q'", "proof (simp add: add_mult_distrib diff_mult_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' + (q' + m * q') \\<le> (p' + (p' + m * p') + r') div q' * q';\n     u' * q' + length ns' * q' =\n     p' + (p' + m * p') + r' +\n     (u * q' +\n      (bn_count ns * q' + (foldl (+) 0 ns * p' - bn_count ns * p'))) -\n     (q' + (q' + m * q'))\\<rbrakk>\n    \\<Longrightarrow> p' + (p' + m * p') + r' +\n                      (u * q' +\n                       (bn_count ns * q' +\n                        (foldl (+) 0 ns * p' - bn_count ns * p'))) -\n                      (q' + (q' + m * q')) +\n                      (q' + (q' + m * q')) =\n                      p' + (p' + m * p') + r' +\n                      (u * q' +\n                       (bn_count ns * q' +\n                        (foldl (+) 0 ns * p' - bn_count ns * p')))", "have \"Suc (Suc m) * q' \\<le> ?a div q' * q' + ?a mod q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc m) * q'\n    \\<le> (p' + (p' + m * p') + r') div q' * q' +\n          (p' + (p' + m * p') + r') mod q'", "using F"], ["proof (prove)\nusing this:\n  Suc (Suc m) * q' \\<le> (p' + (p' + m * p') + r') div q' * q'\n\ngoal (1 subgoal):\n 1. Suc (Suc m) * q'\n    \\<le> (p' + (p' + m * p') + r') div q' * q' +\n          (p' + (p' + m * p') + r') mod q'", "by arith"], ["proof (state)\nthis:\n  Suc (Suc m) * q'\n  \\<le> (p' + (p' + m * p') + r') div q' * q' +\n        (p' + (p' + m * p') + r') mod q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q' + (q' + m * q') \\<le> (p' + (p' + m * p') + r') div q' * q';\n     u' * q' + length ns' * q' =\n     p' + (p' + m * p') + r' +\n     (u * q' +\n      (bn_count ns * q' + (foldl (+) 0 ns * p' - bn_count ns * p'))) -\n     (q' + (q' + m * q'))\\<rbrakk>\n    \\<Longrightarrow> p' + (p' + m * p') + r' +\n                      (u * q' +\n                       (bn_count ns * q' +\n                        (foldl (+) 0 ns * p' - bn_count ns * p'))) -\n                      (q' + (q' + m * q')) +\n                      (q' + (q' + m * q')) =\n                      p' + (p' + m * p') + r' +\n                      (u * q' +\n                       (bn_count ns * q' +\n                        (foldl (+) 0 ns * p' - bn_count ns * p')))", "hence \"q' + (q' + m * q') \\<le> ?a\"\n        (is \"?b \\<le> _\")"], ["proof (prove)\nusing this:\n  Suc (Suc m) * q'\n  \\<le> (p' + (p' + m * p') + r') div q' * q' +\n        (p' + (p' + m * p') + r') mod q'\n\ngoal (1 subgoal):\n 1. q' + (q' + m * q') \\<le> p' + (p' + m * p') + r'", "by simp"], ["proof (state)\nthis:\n  q' + (q' + m * q') \\<le> p' + (p' + m * p') + r'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q' + (q' + m * q') \\<le> (p' + (p' + m * p') + r') div q' * q';\n     u' * q' + length ns' * q' =\n     p' + (p' + m * p') + r' +\n     (u * q' +\n      (bn_count ns * q' + (foldl (+) 0 ns * p' - bn_count ns * p'))) -\n     (q' + (q' + m * q'))\\<rbrakk>\n    \\<Longrightarrow> p' + (p' + m * p') + r' +\n                      (u * q' +\n                       (bn_count ns * q' +\n                        (foldl (+) 0 ns * p' - bn_count ns * p'))) -\n                      (q' + (q' + m * q')) +\n                      (q' + (q' + m * q')) =\n                      p' + (p' + m * p') + r' +\n                      (u * q' +\n                       (bn_count ns * q' +\n                        (foldl (+) 0 ns * p' - bn_count ns * p')))", "thus\n       \"?a + (u * q' + (bn_count ns * q' +\n          (foldl (+) 0 ns * p' - bn_count ns * p'))) - ?b + ?b =\n        ?a + (u * q' + (bn_count ns * q' +\n          (foldl (+) 0 ns * p' - bn_count ns * p')))\""], ["proof (prove)\nusing this:\n  q' + (q' + m * q') \\<le> p' + (p' + m * p') + r'\n\ngoal (1 subgoal):\n 1. p' + (p' + m * p') + r' +\n    (u * q' +\n     (bn_count ns * q' + (foldl (+) 0 ns * p' - bn_count ns * p'))) -\n    (q' + (q' + m * q')) +\n    (q' + (q' + m * q')) =\n    p' + (p' + m * p') + r' +\n    (u * q' + (bn_count ns * q' + (foldl (+) 0 ns * p' - bn_count ns * p')))", "by simp"], ["proof (state)\nthis:\n  p' + (p' + m * p') + r' +\n  (u * q' + (bn_count ns * q' + (foldl (+) 0 ns * p' - bn_count ns * p'))) -\n  (q' + (q' + m * q')) +\n  (q' + (q' + m * q')) =\n  p' + (p' + m * p') + r' +\n  (u * q' + (bn_count ns * q' + (foldl (+) 0 ns * p' - bn_count ns * p')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u' + length ns') * q' + Suc (Suc m) * q' =\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') div q' * q' +\n  (p' + (p' + m * p') + r') mod q'\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "moreover"], ["proof (state)\nthis:\n  (u' + length ns') * q' + Suc (Suc m) * q' =\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') div q' * q' +\n  (p' + (p' + m * p') + r') mod q'\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "have \"?c = q' + (q' + (u' + (m + length ns')) * q')\"\n      (is \"_ = ?e\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u' + length ns') * q' + Suc (Suc m) * q' =\n    q' + (q' + (u' + (m + length ns')) * q')", "by (simp add: add_mult_distrib)"], ["proof (state)\nthis:\n  (u' + length ns') * q' + Suc (Suc m) * q' =\n  q' + (q' + (u' + (m + length ns')) * q')\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "moreover"], ["proof (state)\nthis:\n  (u' + length ns') * q' + Suc (Suc m) * q' =\n  q' + (q' + (u' + (m + length ns')) * q')\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "have \"bn_count ns * p' \\<le> foldl (+) 0 ns * p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count ns * p' \\<le> foldl (+) 0 ns * p'", "using D"], ["proof (prove)\nusing this:\n  bn_count ns \\<le> foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. bn_count ns * p' \\<le> foldl (+) 0 ns * p'", "by (rule mult_le_mono1)"], ["proof (state)\nthis:\n  bn_count ns * p' \\<le> foldl (+) 0 ns * p'\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "hence \"?d = (u + bn_count ns) * q' +\n      ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')\"\n      (is \"_ = ?f\")"], ["proof (prove)\nusing this:\n  bn_count ns * p' \\<le> foldl (+) 0 ns * p'\n\ngoal (1 subgoal):\n 1. (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n    (p' + (p' + m * p') + r') div q' * q' +\n    (p' + (p' + m * p') + r') mod q' =\n    (u + bn_count ns) * q' +\n    ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')", "by (simp (no_asm_simp) add: add_mult_distrib diff_mult_distrib)"], ["proof (state)\nthis:\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') div q' * q' +\n  (p' + (p' + m * p') + r') mod q' =\n  (u + bn_count ns) * q' +\n  ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')\n\ngoal (2 subgoals):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                (u + (p + (p + na * p) + r) div q - Suc (Suc na) +\n                 bn_count ns) *\n                q +\n                (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) =\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = u + (p + (p + na * p) + r) div q - Suc (Suc na) \\<and>\n        ms' = Suc 0 # Suc 0 # Suc 0 # Suc 0 # replicate na (Suc 0) \\<and>\n        ws' = take (Suc (Suc (Suc (Suc na)))) xs\\<rbrakk>\n       \\<Longrightarrow> q + (q + (u' + (na + length ns')) * q) =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)\n 2. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "ultimately"], ["proof (chain)\npicking this:\n  (u' + length ns') * q' + Suc (Suc m) * q' =\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') div q' * q' +\n  (p' + (p' + m * p') + r') mod q'\n  (u' + length ns') * q' + Suc (Suc m) * q' =\n  q' + (q' + (u' + (m + length ns')) * q')\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') div q' * q' +\n  (p' + (p' + m * p') + r') mod q' =\n  (u + bn_count ns) * q' +\n  ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')", "show \"?e = ?f\""], ["proof (prove)\nusing this:\n  (u' + length ns') * q' + Suc (Suc m) * q' =\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') div q' * q' +\n  (p' + (p' + m * p') + r') mod q'\n  (u' + length ns') * q' + Suc (Suc m) * q' =\n  q' + (q' + (u' + (m + length ns')) * q')\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') div q' * q' +\n  (p' + (p' + m * p') + r') mod q' =\n  (u + bn_count ns) * q' +\n  ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')\n\ngoal (1 subgoal):\n 1. q' + (q' + (u' + (m + length ns')) * q') =\n    (u + bn_count ns) * q' +\n    ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')", "by simp"], ["proof (state)\nthis:\n  q' + (q' + (u' + (m + length ns')) * q') =\n  (u + bn_count ns) * q' +\n  ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')\n\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r' = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "fix m p' q' r'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "assume \"(u' + length ns') * q' = bn_count ns * q' +\n      (foldl (+) 0 ns - bn_count ns) * p' + (p' + (p' + m * p') + r') mod q'\"\n      (is \"_ = _ + _ + ?a mod _\")"], ["proof (state)\nthis:\n  (u' + length ns') * q' =\n  bn_count ns * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') mod q'\n\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "hence \"(u' + length ns') * q' + (u + ?a div q') * q' =\n      (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' + ?a\"\n      (is \"?c = ?d\")"], ["proof (prove)\nusing this:\n  (u' + length ns') * q' =\n  bn_count ns * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') mod q'\n\ngoal (1 subgoal):\n 1. (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n    (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n    (p' + (p' + m * p') + r')", "by (simp add: add_mult_distrib)"], ["proof (state)\nthis:\n  (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r')\n\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "moreover"], ["proof (state)\nthis:\n  (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r')\n\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "have \"?c = (u' + (u + ?a div q' + length ns')) * q'\"\n      (is \"_ = ?e\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n    (u' + (u + (p' + (p' + m * p') + r') div q' + length ns')) * q'", "by (simp add: add_mult_distrib)"], ["proof (state)\nthis:\n  (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n  (u' + (u + (p' + (p' + m * p') + r') div q' + length ns')) * q'\n\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "moreover"], ["proof (state)\nthis:\n  (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n  (u' + (u + (p' + (p' + m * p') + r') div q' + length ns')) * q'\n\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "have \"bn_count ns * p' \\<le> foldl (+) 0 ns * p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count ns * p' \\<le> foldl (+) 0 ns * p'", "using D"], ["proof (prove)\nusing this:\n  bn_count ns \\<le> foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. bn_count ns * p' \\<le> foldl (+) 0 ns * p'", "by (rule mult_le_mono1)"], ["proof (state)\nthis:\n  bn_count ns * p' \\<le> foldl (+) 0 ns * p'\n\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "hence \"?d = (u + bn_count ns) * q' +\n      ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')\"\n      (is \"_ = ?f\")"], ["proof (prove)\nusing this:\n  bn_count ns * p' \\<le> foldl (+) 0 ns * p'\n\ngoal (1 subgoal):\n 1. (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n    (p' + (p' + m * p') + r') =\n    (u + bn_count ns) * q' +\n    ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')", "by (simp (no_asm_simp) add: add_mult_distrib diff_mult_distrib)"], ["proof (state)\nthis:\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') =\n  (u + bn_count ns) * q' +\n  ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')\n\ngoal (1 subgoal):\n 1. \\<And>na p q r.\n       \\<lbrakk>(u' + length ns') * q =\n                bn_count ns * q + (foldl (+) 0 ns - bn_count ns) * p +\n                (p + (p + na * p) + r) mod q;\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             mini (take (Suc (Suc (Suc (Suc na)))) xs) key) \\<noteq>\n        key (take (Suc (Suc (Suc (Suc na)))) xs !\n             maxi (take (Suc (Suc (Suc (Suc na)))) xs) key);\n        n' = (p + (p + na * p) + r) div q;\n        r'__ = (p + (p + na * p) + r) mod q; n = Suc (Suc na); p = p; q = q;\n        r = r;\n        v = 0 \\<and>\n        ms' =\n        Suc 0 #\n        enum\n         (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n           (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n         index key (u + (p + (p + na * p) + r) div q)\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n         (key (take (Suc (Suc (Suc (Suc na)))) xs !\n               maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)) @\n        [Suc 0] \\<and>\n        ws' =\n        take (Suc (Suc (Suc (Suc na)))) xs !\n        mini (take (Suc (Suc (Suc (Suc na)))) xs) key #\n        map the\n         (fill\n           (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n             (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n           (offs\n             (enum\n               (nths (take (Suc (Suc (Suc (Suc na)))) xs)\n                 (- {mini (take (Suc (Suc (Suc (Suc na)))) xs) key,\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key}))\n               index key (u + (p + (p + na * p) + r) div q)\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n               (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                     maxi (take (Suc (Suc (Suc (Suc na)))) xs) key)))\n             0)\n           index key (Suc (Suc na))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 mini (take (Suc (Suc (Suc (Suc na)))) xs) key))\n           (key (take (Suc (Suc (Suc (Suc na)))) xs !\n                 maxi (take (Suc (Suc (Suc (Suc na)))) xs) key))) @\n        [take (Suc (Suc (Suc (Suc na)))) xs !\n         maxi (take (Suc (Suc (Suc (Suc na)))) xs) key]\\<rbrakk>\n       \\<Longrightarrow> (u' +\n                          (u + (p + (p + na * p) + r) div q + length ns')) *\n                         q =\n                         (u + bn_count ns) * q +\n                         ((Suc (Suc (foldl (+) 0 ns + na)) - bn_count ns) *\n                          p +\n                          r)", "ultimately"], ["proof (chain)\npicking this:\n  (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r')\n  (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n  (u' + (u + (p' + (p' + m * p') + r') div q' + length ns')) * q'\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') =\n  (u + bn_count ns) * q' +\n  ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')", "show \"?e = ?f\""], ["proof (prove)\nusing this:\n  (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r')\n  (u' + length ns') * q' + (u + (p' + (p' + m * p') + r') div q') * q' =\n  (u' + (u + (p' + (p' + m * p') + r') div q' + length ns')) * q'\n  (u + bn_count ns) * q' + (foldl (+) 0 ns - bn_count ns) * p' +\n  (p' + (p' + m * p') + r') =\n  (u + bn_count ns) * q' +\n  ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')\n\ngoal (1 subgoal):\n 1. (u' + (u + (p' + (p' + m * p') + r') div q' + length ns')) * q' =\n    (u + bn_count ns) * q' +\n    ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')", "by simp"], ["proof (state)\nthis:\n  (u' + (u + (p' + (p' + m * p') + r') div q' + length ns')) * q' =\n  (u + bn_count ns) * q' +\n  ((Suc (Suc (foldl (+) 0 ns + m)) - bn_count ns) * p' + r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u' + (length ms' + length ns')) * q =\n  (u + bn_count (Suc (Suc n) # ns)) * q +\n  (Suc (Suc (foldl (+) 0 ns + n)) - bn_count (Suc (Suc n) # ns)) * p +\n  r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_len_eq [rule_format]:\n \"bn_count (fst (snd t)) = foldl (+) 0 (fst (snd t)) \\<longrightarrow>\n    length (fst (snd (round index key p q r t))) = foldl (+) 0 (fst (snd t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count (fst (snd t)) = foldl (+) 0 (fst (snd t)) \\<longrightarrow>\n    length (fst (snd (round index key p q r t))) = foldl (+) 0 (fst (snd t))", "using [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count (fst (snd t)) = foldl (+) 0 (fst (snd t)) \\<longrightarrow>\n    length (fst (snd (round index key p q r t))) = foldl (+) 0 (fst (snd t))", "proof (induction index key p q r t rule: round.induct, simp_all add: Let_def\n split: prod.split del: all_simps, ((rule allI)+, (rule impI)+, simp add:\n add_suc)+, subst (asm) (3) add_base_zero, subst add_base_zero)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> bn_count ns =\n                                     foldl (+) 0 ns \\<longrightarrow>\n                                     length aa = foldl (+) 0 ns;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        bn_count (Suc (Suc n) # ns) =\n        Suc (Suc (foldl (+) 0 ns + n))\\<rbrakk>\n       \\<Longrightarrow> length a + length aa =\n                         Suc (Suc (foldl (+) 0 ns + n))", "fix index p q r u n ns n' v ms' ws'\n    and key :: \"'a \\<Rightarrow> 'b\" and xs :: \"'a list\" and ns' :: \"nat list\" and r' :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> bn_count ns =\n                                     foldl (+) 0 ns \\<longrightarrow>\n                                     length aa = foldl (+) 0 ns;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        bn_count (Suc (Suc n) # ns) =\n        Suc (Suc (foldl (+) 0 ns + n))\\<rbrakk>\n       \\<Longrightarrow> length a + length aa =\n                         Suc (Suc (foldl (+) 0 ns + n))", "let ?ws = \"take (Suc (Suc n)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> bn_count ns =\n                                     foldl (+) 0 ns \\<longrightarrow>\n                                     length aa = foldl (+) 0 ns;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        bn_count (Suc (Suc n) # ns) =\n        Suc (Suc (foldl (+) 0 ns + n))\\<rbrakk>\n       \\<Longrightarrow> length a + length aa =\n                         Suc (Suc (foldl (+) 0 ns + n))", "assume\n    A: \"round_suc_suc index key ?ws n n' u = (v, ms', ws')\" and\n    B: \"bn_count (Suc (Suc n) # ns) = Suc (Suc (foldl (+) 0 ns + n))\""], ["proof (state)\nthis:\n  round_suc_suc index key (take (Suc (Suc n)) xs) n n' u = (v, ms', ws')\n  bn_count (Suc (Suc n) # ns) = Suc (Suc (foldl (+) 0 ns + n))\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> bn_count ns =\n                                     foldl (+) 0 ns \\<longrightarrow>\n                                     length aa = foldl (+) 0 ns;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        bn_count (Suc (Suc n) # ns) =\n        Suc (Suc (foldl (+) 0 ns + n))\\<rbrakk>\n       \\<Longrightarrow> length a + length aa =\n                         Suc (Suc (foldl (+) 0 ns + n))", "assume \"\\<And>ws a b c d e f g h.\n    ws = ?ws \\<Longrightarrow> a = (n', r') \\<Longrightarrow> b = n' \\<and> c = r' \\<Longrightarrow>\n    d = (v, ms', ws') \\<Longrightarrow> e = v \\<and> f = (ms', ws') \\<Longrightarrow> g = ms' \\<and> h = ws' \\<Longrightarrow>\n      bn_count ns = foldl (+) 0 ns \\<longrightarrow> length ns' = foldl (+) 0 ns\""], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = (n', r');\n   ?b = n' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> bn_count ns = foldl (+) 0 ns \\<longrightarrow>\n                    length ns' = foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> bn_count ns =\n                                     foldl (+) 0 ns \\<longrightarrow>\n                                     length aa = foldl (+) 0 ns;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        bn_count (Suc (Suc n) # ns) =\n        Suc (Suc (foldl (+) 0 ns + n))\\<rbrakk>\n       \\<Longrightarrow> length a + length aa =\n                         Suc (Suc (foldl (+) 0 ns + n))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = (n', r');\n   ?b = n' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> bn_count ns = foldl (+) 0 ns \\<longrightarrow>\n                    length ns' = foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> bn_count ns =\n                                     foldl (+) 0 ns \\<longrightarrow>\n                                     length aa = foldl (+) 0 ns;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        bn_count (Suc (Suc n) # ns) =\n        Suc (Suc (foldl (+) 0 ns + n))\\<rbrakk>\n       \\<Longrightarrow> length a + length aa =\n                         Suc (Suc (foldl (+) 0 ns + n))", "have C: \"n = 0 \\<or> n = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<or> n = Suc 0", "using B"], ["proof (prove)\nusing this:\n  bn_count (Suc (Suc n) # ns) = Suc (Suc (foldl (+) 0 ns + n))\n\ngoal (1 subgoal):\n 1. n = 0 \\<or> n = Suc 0", "by (rule_tac bn_comp.cases [of \"(n, p, q, r)\"],\n     insert bn_count_le [of ns], simp_all)"], ["proof (state)\nthis:\n  n = 0 \\<or> n = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> bn_count ns =\n                                     foldl (+) 0 ns \\<longrightarrow>\n                                     length aa = foldl (+) 0 ns;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        bn_count (Suc (Suc n) # ns) =\n        Suc (Suc (foldl (+) 0 ns + n))\\<rbrakk>\n       \\<Longrightarrow> length a + length aa =\n                         Suc (Suc (foldl (+) 0 ns + n))", "hence \"bn_count ns = foldl (+) 0 ns\""], ["proof (prove)\nusing this:\n  n = 0 \\<or> n = Suc 0\n\ngoal (1 subgoal):\n 1. bn_count ns = foldl (+) 0 ns", "using B"], ["proof (prove)\nusing this:\n  n = 0 \\<or> n = Suc 0\n  bn_count (Suc (Suc n) # ns) = Suc (Suc (foldl (+) 0 ns + n))\n\ngoal (1 subgoal):\n 1. bn_count ns = foldl (+) 0 ns", "by (erule_tac disjE, simp_all)"], ["proof (state)\nthis:\n  bn_count ns = foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> bn_count ns =\n                                     foldl (+) 0 ns \\<longrightarrow>\n                                     length aa = foldl (+) 0 ns;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        bn_count (Suc (Suc n) # ns) =\n        Suc (Suc (foldl (+) 0 ns + n))\\<rbrakk>\n       \\<Longrightarrow> length a + length aa =\n                         Suc (Suc (foldl (+) 0 ns + n))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = (n', r');\n   ?b = n' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> bn_count ns = foldl (+) 0 ns \\<longrightarrow>\n                    length ns' = foldl (+) 0 ns\n  bn_count ns = foldl (+) 0 ns", "have \"length ns' = foldl (+) 0 ns\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ws = take (Suc (Suc n)) xs; ?a = (n', r');\n   ?b = n' \\<and> ?c = r'; ?d = (v, ms', ws');\n   ?e = v \\<and> ?f = (ms', ws'); ?g = ms' \\<and> ?h = ws'\\<rbrakk>\n  \\<Longrightarrow> bn_count ns = foldl (+) 0 ns \\<longrightarrow>\n                    length ns' = foldl (+) 0 ns\n  bn_count ns = foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. length ns' = foldl (+) 0 ns", "by simp"], ["proof (state)\nthis:\n  length ns' = foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. \\<And>index key p q r u n ns xs x1 x2 x1a a b x1b aa ba.\n       \\<lbrakk>\\<And>x xa xb y xaa xc ya xd yb.\n                   \\<lbrakk>x = take (Suc (Suc n)) xs; xa = (x1, x2);\n                    xb = x1 \\<and> y = x2; xaa = (x1a, a, b);\n                    xc = x1a \\<and> ya = (a, b);\n                    xd = a \\<and> yb = b\\<rbrakk>\n                   \\<Longrightarrow> bn_count ns =\n                                     foldl (+) 0 ns \\<longrightarrow>\n                                     length aa = foldl (+) 0 ns;\n        round index key p q x2 (x1a, ns, drop (Suc (Suc n)) xs) =\n        (x1b, aa, ba);\n        round_suc_suc index key (take (Suc (Suc n)) xs) n x1 u =\n        (x1a, a, b);\n        bn_comp n p q r = (x1, x2);\n        bn_count (Suc (Suc n) # ns) =\n        Suc (Suc (foldl (+) 0 ns + n))\\<rbrakk>\n       \\<Longrightarrow> length a + length aa =\n                         Suc (Suc (foldl (+) 0 ns + n))", "with A [symmetric]"], ["proof (chain)\npicking this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc n)) xs) n n' u\n  length ns' = foldl (+) 0 ns", "show \"length ms' + length ns' =\n    Suc (Suc (foldl (+) 0 ns + n))\""], ["proof (prove)\nusing this:\n  (v, ms', ws') = round_suc_suc index key (take (Suc (Suc n)) xs) n n' u\n  length ns' = foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. length ms' + length ns' = Suc (Suc (foldl (+) 0 ns + n))", "by (rule_tac disjE [OF C], simp_all\n     add: round_suc_suc_def Let_def enum_length split: if_split_asm)"], ["proof (state)\nthis:\n  length ms' + length ns' = Suc (Suc (foldl (+) 0 ns + n))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem round_len:\n  assumes\n    A: \"length xs = foldl (+) 0 ns\" and\n    B: \"length xs \\<le> p\"\n  shows \"if bn_count ns < length xs\n    then fst (gcsort_round index key p ns xs) +\n      length (fst (snd (gcsort_round index key p ns xs))) = p\n    else length (fst (snd (gcsort_round index key p ns xs))) = length xs\"\n  (is \"if _ then fst ?t + _ = _ else _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. if bn_count ns < length xs\n    then fst (gcsort_round index key p ns xs) +\n         length (fst (snd (gcsort_round index key p ns xs))) =\n         p\n    else length (fst (snd (gcsort_round index key p ns xs))) = length xs", "proof (split if_split, rule conjI, rule_tac [!] impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "assume C: \"bn_count ns < length xs\""], ["proof (state)\nthis:\n  bn_count ns < length xs\n\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "moreover"], ["proof (state)\nthis:\n  bn_count ns < length xs\n\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "have\n   \"bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (0, ns, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (0, ns, xs)", "using A and B"], ["proof (prove)\nusing this:\n  length xs = foldl (+) 0 ns\n  length xs \\<le> p\n\ngoal (1 subgoal):\n 1. bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (0, ns, xs)", "by (rule_tac bn_inv_intro, simp)"], ["proof (state)\nthis:\n  bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (0, ns, xs)\n\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "ultimately"], ["proof (chain)\npicking this:\n  bn_count ns < length xs\n  bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (0, ns, xs)", "have\n   \"(fst ?t + length (fst (snd ?t))) * (length xs - bn_count ns) =\n    bn_count ns * (length xs - bn_count ns) +\n      (p - bn_count ns) * (length xs - bn_count ns)\"\n    (is \"?a * ?b = ?c\")"], ["proof (prove)\nusing this:\n  bn_count ns < length xs\n  bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (0, ns, xs)\n\ngoal (1 subgoal):\n 1. (fst (gcsort_round index key p ns xs) +\n     length (fst (snd (gcsort_round index key p ns xs)))) *\n    (length xs - bn_count ns) =\n    bn_count ns * (length xs - bn_count ns) +\n    (p - bn_count ns) * (length xs - bn_count ns)", "using A"], ["proof (prove)\nusing this:\n  bn_count ns < length xs\n  bn_inv (p - bn_count ns) (foldl (+) 0 ns - bn_count ns) (0, ns, xs)\n  length xs = foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. (fst (gcsort_round index key p ns xs) +\n     length (fst (snd (gcsort_round index key p ns xs)))) *\n    (length xs - bn_count ns) =\n    bn_count ns * (length xs - bn_count ns) +\n    (p - bn_count ns) * (length xs - bn_count ns)", "by (subst round_len_less, simp_all)"], ["proof (state)\nthis:\n  (fst (gcsort_round index key p ns xs) +\n   length (fst (snd (gcsort_round index key p ns xs)))) *\n  (length xs - bn_count ns) =\n  bn_count ns * (length xs - bn_count ns) +\n  (p - bn_count ns) * (length xs - bn_count ns)\n\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "also"], ["proof (state)\nthis:\n  (fst (gcsort_round index key p ns xs) +\n   length (fst (snd (gcsort_round index key p ns xs)))) *\n  (length xs - bn_count ns) =\n  bn_count ns * (length xs - bn_count ns) +\n  (p - bn_count ns) * (length xs - bn_count ns)\n\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "have \"bn_count ns \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count ns \\<le> p", "using B and C"], ["proof (prove)\nusing this:\n  length xs \\<le> p\n  bn_count ns < length xs\n\ngoal (1 subgoal):\n 1. bn_count ns \\<le> p", "by simp"], ["proof (state)\nthis:\n  bn_count ns \\<le> p\n\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "hence \"bn_count ns * ?b \\<le> p * ?b\""], ["proof (prove)\nusing this:\n  bn_count ns \\<le> p\n\ngoal (1 subgoal):\n 1. bn_count ns * (length xs - bn_count ns)\n    \\<le> p * (length xs - bn_count ns)", "by (rule mult_le_mono1)"], ["proof (state)\nthis:\n  bn_count ns * (length xs - bn_count ns)\n  \\<le> p * (length xs - bn_count ns)\n\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "hence \"?c = p * ?b\""], ["proof (prove)\nusing this:\n  bn_count ns * (length xs - bn_count ns)\n  \\<le> p * (length xs - bn_count ns)\n\ngoal (1 subgoal):\n 1. bn_count ns * (length xs - bn_count ns) +\n    (p - bn_count ns) * (length xs - bn_count ns) =\n    p * (length xs - bn_count ns)", "by (simp (no_asm_simp) add: diff_mult_distrib)"], ["proof (state)\nthis:\n  bn_count ns * (length xs - bn_count ns) +\n  (p - bn_count ns) * (length xs - bn_count ns) =\n  p * (length xs - bn_count ns)\n\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "finally"], ["proof (chain)\npicking this:\n  (fst (gcsort_round index key p ns xs) +\n   length (fst (snd (gcsort_round index key p ns xs)))) *\n  (length xs - bn_count ns) =\n  p * (length xs - bn_count ns)", "have \"?a * ?b = p * ?b\""], ["proof (prove)\nusing this:\n  (fst (gcsort_round index key p ns xs) +\n   length (fst (snd (gcsort_round index key p ns xs)))) *\n  (length xs - bn_count ns) =\n  p * (length xs - bn_count ns)\n\ngoal (1 subgoal):\n 1. (fst (gcsort_round index key p ns xs) +\n     length (fst (snd (gcsort_round index key p ns xs)))) *\n    (length xs - bn_count ns) =\n    p * (length xs - bn_count ns)", "."], ["proof (state)\nthis:\n  (fst (gcsort_round index key p ns xs) +\n   length (fst (snd (gcsort_round index key p ns xs)))) *\n  (length xs - bn_count ns) =\n  p * (length xs - bn_count ns)\n\ngoal (2 subgoals):\n 1. bn_count ns < length xs \\<Longrightarrow>\n    fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p\n 2. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "thus \"?a = p\""], ["proof (prove)\nusing this:\n  (fst (gcsort_round index key p ns xs) +\n   length (fst (snd (gcsort_round index key p ns xs)))) *\n  (length xs - bn_count ns) =\n  p * (length xs - bn_count ns)\n\ngoal (1 subgoal):\n 1. fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p", "using C"], ["proof (prove)\nusing this:\n  (fst (gcsort_round index key p ns xs) +\n   length (fst (snd (gcsort_round index key p ns xs)))) *\n  (length xs - bn_count ns) =\n  p * (length xs - bn_count ns)\n  bn_count ns < length xs\n\ngoal (1 subgoal):\n 1. fst (gcsort_round index key p ns xs) +\n    length (fst (snd (gcsort_round index key p ns xs))) =\n    p", "by simp"], ["proof (state)\nthis:\n  fst (gcsort_round index key p ns xs) +\n  length (fst (snd (gcsort_round index key p ns xs))) =\n  p\n\ngoal (1 subgoal):\n 1. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "assume \"\\<not> bn_count ns < length xs\""], ["proof (state)\nthis:\n  \\<not> bn_count ns < length xs\n\ngoal (1 subgoal):\n 1. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "moreover"], ["proof (state)\nthis:\n  \\<not> bn_count ns < length xs\n\ngoal (1 subgoal):\n 1. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "have \"bn_count ns \\<le> foldl (+) 0 ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn_count ns \\<le> foldl (+) 0 ns", "by (rule bn_count_le)"], ["proof (state)\nthis:\n  bn_count ns \\<le> foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. \\<not> bn_count ns < length xs \\<Longrightarrow>\n    length (fst (snd (gcsort_round index key p ns xs))) = length xs", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> bn_count ns < length xs\n  bn_count ns \\<le> foldl (+) 0 ns", "show \"length (fst (snd ?t)) = length xs\""], ["proof (prove)\nusing this:\n  \\<not> bn_count ns < length xs\n  bn_count ns \\<le> foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. length (fst (snd (gcsort_round index key p ns xs))) = length xs", "using A"], ["proof (prove)\nusing this:\n  \\<not> bn_count ns < length xs\n  bn_count ns \\<le> foldl (+) 0 ns\n  length xs = foldl (+) 0 ns\n\ngoal (1 subgoal):\n 1. length (fst (snd (gcsort_round index key p ns xs))) = length xs", "by (subst round_len_eq, simp_all)"], ["proof (state)\nthis:\n  length (fst (snd (gcsort_round index key p ns xs))) = length xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}