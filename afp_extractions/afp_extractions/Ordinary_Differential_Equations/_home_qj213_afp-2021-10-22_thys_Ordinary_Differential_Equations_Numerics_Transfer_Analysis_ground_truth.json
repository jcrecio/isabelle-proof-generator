{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordinary_Differential_Equations/Numerics/Transfer_Analysis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordinary_Differential_Equations", "problem_names": ["lemma Sigma_transfer[transfer_rule]:\n  \"(rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B)) Sigma Sigma\"", "lemma less_transfer[transfer_rule]:\n  \"(A ===> A ===> (=)) less less\"\n  if [transfer_rule]: \"bi_unique A\" \"(A ===> A ===> (=)) less_eq less_eq\"\n  for A::\"'c::order \\<Rightarrow> 'd::order \\<Rightarrow> bool\"", "lemma norm_transfer[transfer_rule]:\n  \"(A ===> (=)) norm norm\"\n  if [transfer_rule]: \"(A ===> A ===> (=)) inner inner\"", "lemma dist_transfer[transfer_rule]:\n  \"(A ===> A ===> (=)) dist dist\"\n  if [transfer_rule]: \"(A ===> (=)) norm norm\" \"(A ===> A ===> A) (-) (-)\"", "lemma open_transfer[transfer_rule]:\n  \"(rel_set A ===> (=)) open open\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(A ===> A ===> (=)) dist dist\"", "lemma closed_transfer[transfer_rule]:\n  \"(rel_set A ===> (=)) closed closed\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"", "lemma sgn_transfer[transfer_rule]:\n  \"(A ===> A) sgn sgn\"\n  if [transfer_rule]: \"(A ===> (=)) norm norm\" \"((=) ===> A ===> A) scaleR scaleR\"", "lemma uniformity_transfer[transfer_rule]:\n  \"(rel_filter (rel_prod A A)) uniformity uniformity\"\n  if [transfer_rule]: \"bi_total A\"  \"bi_unique A\" \"(A ===> A ===> (=)) dist dist\"", "lemma lipschitz_on_transfer[transfer_rule]:\n  \"((=) ===> (rel_set A) ===> (A ===> B) ===> (=)) lipschitz_on lipschitz_on\"\n  if [transfer_rule]: \"(B ===> B ===> (=)) dist dist\" \"(A ===> A ===> (=)) dist dist\"", "lemma cball_transfer[transfer_rule]:\n  \"(A ===> (=) ===> rel_set A) cball cball\"\n  if [transfer_rule]: \"bi_total A\" \"(A ===> A ===> (=)) dist dist\"", "lemma ball_transfer[transfer_rule]:\n  \"(A ===> (=) ===> rel_set A) ball ball\"\n  if [transfer_rule]: \"bi_total A\" \"(A ===> A ===> (=)) dist dist\"", "lemma local_lipschitz_transfer[transfer_rule]:\n  \"(rel_set A ===> rel_set B ===> (A ===> B ===> C) ===> (=)) local_lipschitz local_lipschitz\"\n  if [transfer_rule]: \"bi_total A\" \"bi_unique A\" \"bi_total B\" \"bi_unique B\"\n    \"(A ===> A ===> (=)) dist dist\"\n    \"(B ===> B ===> (=)) dist dist\"\n    \"(C ===> C ===> (=)) dist dist\"", "lemma filterlim_transfer[transfer_rule]:\n  \"((A ===> B) ===> rel_filter B ===> rel_filter A ===> (=)) filterlim filterlim\"\n  if [transfer_rule]: \"bi_unique B\"", "lemma nhds_transfer[transfer_rule]:\n  \"(A ===> rel_filter A) nhds nhds\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"", "lemma at_within_transfer[transfer_rule]:\n  \"(A ===> rel_set A ===> rel_filter A) at_within at_within\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"", "lemma continuous_on_transfer[transfer_rule]:\n  \"(rel_set A ===> (A ===> B) ===> (=)) continuous_on continuous_on\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"\n    \"bi_unique B\" \"bi_total B\" \"(rel_set B ===> (=)) open open\"", "lemma is_interval_transfer[transfer_rule]: \"(rel_set A ===> (=)) is_interval is_interval\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(A ===> A ===> (=)) inner inner\" \"(rel_set A) Basis Basis\"", "lemma additive_transfer[transfer_rule]:\n  \"((B ===> A) ===> (=)) Modules.additive Modules.additive\"\n  if [transfer_rule]:\n    \"bi_unique A\"\n    \"bi_total B\"\n    \"(A ===> A ===> A) (+) (+)\"\n    \"(B ===> B ===> B) (+) (+)\"", "lemma linear_transfer[transfer_rule]: \"((B ===> A) ===> (=)) linear linear\"\n  if [transfer_rule]:\n    \"bi_unique A\"\n    \"bi_total B\"\n    \"(A ===> A ===> A) (+) (+)\"\n    \"((=) ===> A ===> A) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(B ===> B ===> B) (+) (+)\"\n    \"((=) ===> B ===> B) (*\\<^sub>R) (*\\<^sub>R)\"", "lemma bounded_linear_transfer[transfer_rule]: \"((B ===> A) ===> (=)) bounded_linear bounded_linear\"\n  if [transfer_rule]:\n    \"bi_unique A\"\n    \"bi_total B\"\n    \"(A ===> A ===> A) (+) (+)\"\n    \"((=) ===> A ===> A) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(B ===> B ===> B) (+) (+)\"\n    \"((=) ===> B ===> B) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(A ===> (=)) norm norm\"\n    \"(B ===> (=)) norm norm\"", "lemma Pi_transfer[transfer_rule]: \"(rel_set B ===> (B ===> rel_set A) ===> rel_set (B ===> A)) FuncSet.Pi FuncSet.Pi\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"bi_unique B\" \"bi_total B\"", "lemma bi_unique_rel_blinfun[transfer_rule]:\n  \"bi_total A \\<Longrightarrow> bi_unique B \\<Longrightarrow> bi_unique (rel_blinfun A B)\"", "lemma bi_total_rel_blinfun[transfer_rule]:\n  \"bi_total (rel_blinfun A B)\"\n  if\n    \"bi_unique A\" \"bi_total B\" (* really? *)\n    \"bi_unique B\" \"bi_total A\"\n    \"(B ===> B ===> B) (+) (+)\"\n    \"((=) ===> B ===> B) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(A ===> A ===> A) (+) (+)\"\n    \"((=) ===> A ===> A) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(B ===> (=)) norm norm\"\n    \"(A ===> (=)) norm norm\"", "lemma blinfun_apply_transfer[transfer_rule]:\n  \"(rel_blinfun A B ===> A ===> B) blinfun_apply blinfun_apply\"", "lemma norm_blinfun_transfer[transfer_rule]: \"(rel_blinfun A A ===> (=)) norm norm\"\n  if [transfer_rule]: \"(A ===> (=)) norm norm\" \"(rel_set A) UNIV UNIV\"", "lemma minus_blinfun_transfer[transfer_rule]:\n  \"(rel_blinfun A B ===> rel_blinfun A B ===> rel_blinfun A B) (-) (-)\"\n  if \"(B ===> B ===> B) (-) (-)\"", "lemma compose_blinfun_transfer[transfer_rule]:\"(rel_blinfun A B ===> rel_blinfun C A ===> rel_blinfun C B) (o\\<^sub>L) (o\\<^sub>L)\""], "translations": [["", "lemma Sigma_transfer[transfer_rule]:\n  \"(rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B)) Sigma Sigma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B)) Sigma\n     Sigma", "unfolding Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B))\n     (\\<lambda>A B. \\<Union>x\\<in>A. \\<Union>y\\<in>B x. {(x, y)})\n     (\\<lambda>A B. \\<Union>x\\<in>A. \\<Union>y\\<in>B x. {(x, y)})", "by transfer_prover"], ["", "end"], ["", "subsection \\<open>Parametricity rules for analysis constants\\<close>"], ["", "context includes lifting_syntax begin"], ["", "lemma less_transfer[transfer_rule]:\n  \"(A ===> A ===> (=)) less less\"\n  if [transfer_rule]: \"bi_unique A\" \"(A ===> A ===> (=)) less_eq less_eq\"\n  for A::\"'c::order \\<Rightarrow> 'd::order \\<Rightarrow> bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) (<) (<)", "unfolding order.strict_iff_order[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) (\\<lambda>a b. a \\<le> b \\<and> a \\<noteq> b)\n     (\\<lambda>a b. a \\<le> b \\<and> a \\<noteq> b)", "by transfer_prover"], ["", "lemma norm_transfer[transfer_rule]:\n  \"(A ===> (=)) norm norm\"\n  if [transfer_rule]: \"(A ===> A ===> (=)) inner inner\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) norm norm", "unfolding norm_eq_sqrt_inner"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) (\\<lambda>x. sqrt (x \\<bullet> x))\n     (\\<lambda>x. sqrt (x \\<bullet> x))", "by transfer_prover"], ["", "lemma dist_transfer[transfer_rule]:\n  \"(A ===> A ===> (=)) dist dist\"\n  if [transfer_rule]: \"(A ===> (=)) norm norm\" \"(A ===> A ===> A) (-) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) dist dist", "unfolding dist_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) (\\<lambda>x y. norm (x - y))\n     (\\<lambda>x y. norm (x - y))", "by transfer_prover"], ["", "lemma open_transfer[transfer_rule]:\n  \"(rel_set A ===> (=)) open open\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(A ===> A ===> (=)) dist dist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (=)) open open", "unfolding open_dist"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (=))\n     (\\<lambda>S.\n         \\<forall>x\\<in>S.\n            \\<exists>e>0.\n               \\<forall>y. dist y x < e \\<longrightarrow> y \\<in> S)\n     (\\<lambda>S.\n         \\<forall>x\\<in>S.\n            \\<exists>e>0.\n               \\<forall>y. dist y x < e \\<longrightarrow> y \\<in> S)", "by transfer_prover"], ["", "lemma closed_transfer[transfer_rule]:\n  \"(rel_set A ===> (=)) closed closed\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (=)) closed closed", "unfolding closed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (=)) (\\<lambda>S. open (- S)) (\\<lambda>S. open (- S))", "by transfer_prover"], ["", "lemma sgn_transfer[transfer_rule]:\n  \"(A ===> A) sgn sgn\"\n  if [transfer_rule]: \"(A ===> (=)) norm norm\" \"((=) ===> A ===> A) scaleR scaleR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> A) sgn sgn", "unfolding sgn_div_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> A) (\\<lambda>x. x /\\<^sub>R norm x)\n     (\\<lambda>x. x /\\<^sub>R norm x)", "by transfer_prover"], ["", "lemma uniformity_transfer[transfer_rule]:\n  \"(rel_filter (rel_prod A A)) uniformity uniformity\"\n  if [transfer_rule]: \"bi_total A\"  \"bi_unique A\" \"(A ===> A ===> (=)) dist dist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_filter (rel_prod A A) uniformity uniformity", "unfolding uniformity_dist"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_filter (rel_prod A A)\n     (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n     (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})", "by transfer_prover"], ["", "lemma lipschitz_on_transfer[transfer_rule]:\n  \"((=) ===> (rel_set A) ===> (A ===> B) ===> (=)) lipschitz_on lipschitz_on\"\n  if [transfer_rule]: \"(B ===> B ===> (=)) dist dist\" \"(A ===> A ===> (=)) dist dist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_set A ===> (A ===> B) ===> (=)) lipschitz_on lipschitz_on", "unfolding lipschitz_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_set A ===> (A ===> B) ===> (=))\n     (\\<lambda>C U f.\n         0 \\<le> C \\<and>\n         (\\<forall>x\\<in>U.\n             \\<forall>y\\<in>U. dist (f x) (f y) \\<le> C * dist x y))\n     (\\<lambda>C U f.\n         0 \\<le> C \\<and>\n         (\\<forall>x\\<in>U.\n             \\<forall>y\\<in>U. dist (f x) (f y) \\<le> C * dist x y))", "by transfer_prover"], ["", "lemma cball_transfer[transfer_rule]:\n  \"(A ===> (=) ===> rel_set A) cball cball\"\n  if [transfer_rule]: \"bi_total A\" \"(A ===> A ===> (=)) dist dist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=) ===> rel_set A) cball cball", "unfolding cball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=) ===> rel_set A) (\\<lambda>x e. {y. dist x y \\<le> e})\n     (\\<lambda>x e. {y. dist x y \\<le> e})", "by transfer_prover"], ["", "lemma ball_transfer[transfer_rule]:\n  \"(A ===> (=) ===> rel_set A) ball ball\"\n  if [transfer_rule]: \"bi_total A\" \"(A ===> A ===> (=)) dist dist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=) ===> rel_set A) ball ball", "unfolding ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=) ===> rel_set A) (\\<lambda>x e. {y. dist x y < e})\n     (\\<lambda>x e. {y. dist x y < e})", "by transfer_prover"], ["", "lemma local_lipschitz_transfer[transfer_rule]:\n  \"(rel_set A ===> rel_set B ===> (A ===> B ===> C) ===> (=)) local_lipschitz local_lipschitz\"\n  if [transfer_rule]: \"bi_total A\" \"bi_unique A\" \"bi_total B\" \"bi_unique B\"\n    \"(A ===> A ===> (=)) dist dist\"\n    \"(B ===> B ===> (=)) dist dist\"\n    \"(C ===> C ===> (=)) dist dist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> rel_set B ===> (A ===> B ===> C) ===> (=))\n     local_lipschitz local_lipschitz", "unfolding local_lipschitz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> rel_set B ===> (A ===> B ===> C) ===> (=))\n     (\\<lambda>T X f.\n         \\<forall>x\\<in>X.\n            \\<forall>t\\<in>T.\n               \\<exists>u>0.\n                  \\<exists>L.\n                     \\<forall>t\\<in>cball t u \\<inter> T.\n                        L-lipschitz_on (cball x u \\<inter> X) (f t))\n     (\\<lambda>T X f.\n         \\<forall>x\\<in>X.\n            \\<forall>t\\<in>T.\n               \\<exists>u>0.\n                  \\<exists>L.\n                     \\<forall>t\\<in>cball t u \\<inter> T.\n                        L-lipschitz_on (cball x u \\<inter> X) (f t))", "by transfer_prover"], ["", "lemma filterlim_transfer[transfer_rule]:\n  \"((A ===> B) ===> rel_filter B ===> rel_filter A ===> (=)) filterlim filterlim\"\n  if [transfer_rule]: \"bi_unique B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> rel_filter B ===> rel_filter A ===> (=)) filterlim\n     filterlim", "unfolding filterlim_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> rel_filter B ===> rel_filter A ===> (=))\n     (\\<lambda>f F2 F1.\n         \\<forall>P.\n            eventually P F2 \\<longrightarrow>\n            (\\<forall>\\<^sub>F x in F1. P (f x)))\n     (\\<lambda>f F2 F1.\n         \\<forall>P.\n            eventually P F2 \\<longrightarrow>\n            (\\<forall>\\<^sub>F x in F1. P (f x)))", "by transfer_prover"], ["", "lemma nhds_transfer[transfer_rule]:\n  \"(A ===> rel_filter A) nhds nhds\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> rel_filter A) nhds nhds", "unfolding nhds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> rel_filter A)\n     (\\<lambda>a. Inf (principal ` {S. open S \\<and> a \\<in> S}))\n     (\\<lambda>a. Inf (principal ` {S. open S \\<and> a \\<in> S}))", "by transfer_prover"], ["", "lemma at_within_transfer[transfer_rule]:\n  \"(A ===> rel_set A ===> rel_filter A) at_within at_within\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> rel_set A ===> rel_filter A) at_within at_within", "unfolding at_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> rel_set A ===> rel_filter A)\n     (\\<lambda>a s. inf (nhds a) (principal (s - {a})))\n     (\\<lambda>a s. inf (nhds a) (principal (s - {a})))", "by transfer_prover"], ["", "lemma continuous_on_transfer[transfer_rule]:\n  \"(rel_set A ===> (A ===> B) ===> (=)) continuous_on continuous_on\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"\n    \"bi_unique B\" \"bi_total B\" \"(rel_set B ===> (=)) open open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> B) ===> (=)) continuous_on continuous_on", "unfolding continuous_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> B) ===> (=))\n     (\\<lambda>s f.\n         \\<forall>x\\<in>s. (f \\<longlongrightarrow> f x) (at x within s))\n     (\\<lambda>s f.\n         \\<forall>x\\<in>s. (f \\<longlongrightarrow> f x) (at x within s))", "by transfer_prover"], ["", "lemma is_interval_transfer[transfer_rule]: \"(rel_set A ===> (=)) is_interval is_interval\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(A ===> A ===> (=)) inner inner\" \"(rel_set A) Basis Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (=)) is_interval is_interval", "unfolding is_interval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (=))\n     (\\<lambda>s.\n         \\<forall>a\\<in>s.\n            \\<forall>b\\<in>s.\n               \\<forall>x.\n                  (\\<forall>i\\<in>Basis.\n                      a \\<bullet> i \\<le> x \\<bullet> i \\<and>\n                      x \\<bullet> i \\<le> b \\<bullet> i \\<or>\n                      b \\<bullet> i \\<le> x \\<bullet> i \\<and>\n                      x \\<bullet> i \\<le> a \\<bullet> i) \\<longrightarrow>\n                  x \\<in> s)\n     (\\<lambda>s.\n         \\<forall>a\\<in>s.\n            \\<forall>b\\<in>s.\n               \\<forall>x.\n                  (\\<forall>i\\<in>Basis.\n                      a \\<bullet> i \\<le> x \\<bullet> i \\<and>\n                      x \\<bullet> i \\<le> b \\<bullet> i \\<or>\n                      b \\<bullet> i \\<le> x \\<bullet> i \\<and>\n                      x \\<bullet> i \\<le> a \\<bullet> i) \\<longrightarrow>\n                  x \\<in> s)", "by transfer_prover"], ["", "lemma additive_transfer[transfer_rule]:\n  \"((B ===> A) ===> (=)) Modules.additive Modules.additive\"\n  if [transfer_rule]:\n    \"bi_unique A\"\n    \"bi_total B\"\n    \"(A ===> A ===> A) (+) (+)\"\n    \"(B ===> B ===> B) (+) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> A) ===> (=)) Modules.additive Modules.additive", "unfolding Modules.additive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> A) ===> (=)) (\\<lambda>f. \\<forall>x y. f (x + y) = f x + f y)\n     (\\<lambda>f. \\<forall>x y. f (x + y) = f x + f y)", "by transfer_prover"], ["", "lemma linear_transfer[transfer_rule]: \"((B ===> A) ===> (=)) linear linear\"\n  if [transfer_rule]:\n    \"bi_unique A\"\n    \"bi_total B\"\n    \"(A ===> A ===> A) (+) (+)\"\n    \"((=) ===> A ===> A) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(B ===> B ===> B) (+) (+)\"\n    \"((=) ===> B ===> B) (*\\<^sub>R) (*\\<^sub>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> A) ===> (=)) linear linear", "unfolding linear_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> A) ===> (=))\n     (\\<lambda>f.\n         (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n         (\\<forall>c x. f (c *\\<^sub>R x) = c *\\<^sub>R f x))\n     (\\<lambda>f.\n         (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n         (\\<forall>c x. f (c *\\<^sub>R x) = c *\\<^sub>R f x))", "by transfer_prover"], ["", "lemma bounded_linear_transfer[transfer_rule]: \"((B ===> A) ===> (=)) bounded_linear bounded_linear\"\n  if [transfer_rule]:\n    \"bi_unique A\"\n    \"bi_total B\"\n    \"(A ===> A ===> A) (+) (+)\"\n    \"((=) ===> A ===> A) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(B ===> B ===> B) (+) (+)\"\n    \"((=) ===> B ===> B) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(A ===> (=)) norm norm\"\n    \"(B ===> (=)) norm norm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> A) ===> (=)) bounded_linear bounded_linear", "unfolding bounded_linear_def bounded_linear_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> A) ===> (=))\n     (\\<lambda>f.\n         linear f \\<and>\n         (\\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K))\n     (\\<lambda>f.\n         linear f \\<and>\n         (\\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K))", "by transfer_prover"], ["", "lemma Pi_transfer[transfer_rule]: \"(rel_set B ===> (B ===> rel_set A) ===> rel_set (B ===> A)) FuncSet.Pi FuncSet.Pi\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"bi_unique B\" \"bi_total B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set B ===> (B ===> rel_set A) ===> rel_set (B ===> A)) Pi Pi", "unfolding FuncSet.Pi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set B ===> (B ===> rel_set A) ===> rel_set (B ===> A))\n     (\\<lambda>A B.\n         {f. \\<forall>x. x \\<in> A \\<longrightarrow> f x \\<in> B x})\n     (\\<lambda>A B.\n         {f. \\<forall>x. x \\<in> A \\<longrightarrow> f x \\<in> B x})", "by transfer_prover"], ["", "lift_definition rel_blinfun:: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('c \\<Rightarrow> 'd \\<Rightarrow> bool) \\<Rightarrow>\n  ('a::real_normed_vector \\<Rightarrow>\\<^sub>L 'c::real_normed_vector) \\<Rightarrow> ('b::real_normed_vector \\<Rightarrow>\\<^sub>L 'd::real_normed_vector) \\<Rightarrow> bool\" is rel_fun"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma bi_unique_rel_blinfun[transfer_rule]:\n  \"bi_total A \\<Longrightarrow> bi_unique B \\<Longrightarrow> bi_unique (rel_blinfun A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_total A; bi_unique B\\<rbrakk>\n    \\<Longrightarrow> bi_unique (rel_blinfun A B)", "using bi_unique_fun[of A B]"], ["proof (prove)\nusing this:\n  \\<lbrakk>bi_total A; bi_unique B\\<rbrakk>\n  \\<Longrightarrow> bi_unique (A ===> B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_total A; bi_unique B\\<rbrakk>\n    \\<Longrightarrow> bi_unique (rel_blinfun A B)", "unfolding bi_unique_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>bi_total A;\n   (\\<forall>x y z.\n       B x y \\<longrightarrow> B x z \\<longrightarrow> y = z) \\<and>\n   (\\<forall>x y z.\n       B x z \\<longrightarrow> B y z \\<longrightarrow> x = y)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x y z.\n                        (A ===> B) x y \\<longrightarrow>\n                        (A ===> B) x z \\<longrightarrow> y = z) \\<and>\n                    (\\<forall>x y z.\n                        (A ===> B) x z \\<longrightarrow>\n                        (A ===> B) y z \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_total A;\n     (\\<forall>x y z.\n         B x y \\<longrightarrow> B x z \\<longrightarrow> y = z) \\<and>\n     (\\<forall>x y z.\n         B x z \\<longrightarrow> B y z \\<longrightarrow> x = y)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x y z.\n                          rel_blinfun A B x y \\<longrightarrow>\n                          rel_blinfun A B x z \\<longrightarrow>\n                          y = z) \\<and>\n                      (\\<forall>x y z.\n                          rel_blinfun A B x z \\<longrightarrow>\n                          rel_blinfun A B y z \\<longrightarrow> x = y)", "by transfer auto"], ["", "lemma bi_total_rel_blinfun[transfer_rule]:\n  \"bi_total (rel_blinfun A B)\"\n  if\n    \"bi_unique A\" \"bi_total B\" (* really? *)\n    \"bi_unique B\" \"bi_total A\"\n    \"(B ===> B ===> B) (+) (+)\"\n    \"((=) ===> B ===> B) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(A ===> A ===> A) (+) (+)\"\n    \"((=) ===> A ===> A) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"(B ===> (=)) norm norm\"\n    \"(A ===> (=)) norm norm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_total (rel_blinfun A B)", "using bounded_linear_transfer[OF that(3-)]"], ["proof (prove)\nusing this:\n  ((A ===> B) ===> (=)) bounded_linear bounded_linear\n\ngoal (1 subgoal):\n 1. bi_total (rel_blinfun A B)", "using bi_total_fun[OF that(1,2)]"], ["proof (prove)\nusing this:\n  ((A ===> B) ===> (=)) bounded_linear bounded_linear\n  bi_total (A ===> B)\n\ngoal (1 subgoal):\n 1. bi_total (rel_blinfun A B)", "unfolding bi_total_def"], ["proof (prove)\nusing this:\n  ((A ===> B) ===> (=)) bounded_linear bounded_linear\n  (\\<forall>x. Ex ((A ===> B) x)) \\<and>\n  (\\<forall>y. \\<exists>x. (A ===> B) x y)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. Ex (rel_blinfun A B x)) \\<and>\n    (\\<forall>y. \\<exists>x. rel_blinfun A B x y)", "apply (transfer fixing: A B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n     (\\<forall>x. Ex ((A ===> B) x)) \\<and>\n     (\\<forall>y. \\<exists>x. (A ===> B) x y)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>Collect bounded_linear.\n                          Bex (Collect bounded_linear)\n                           ((A ===> B) x)) \\<and>\n                      (\\<forall>y\\<in>Collect bounded_linear.\n                          \\<exists>x\\<in>Collect bounded_linear.\n                             (A ===> B) x y)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n        \\<forall>x. Ex ((A ===> B) x);\n        \\<forall>y. \\<exists>x. (A ===> B) x y; bounded_linear x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            bounded_linear xa \\<and> (A ===> B) x xa\n 2. \\<And>y.\n       \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n        \\<forall>x. Ex ((A ===> B) x);\n        \\<forall>y. \\<exists>x. (A ===> B) x y; bounded_linear y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. bounded_linear x \\<and> (A ===> B) x y", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n     \\<forall>x. Ex ((A ===> B) x); \\<forall>y. \\<exists>x. (A ===> B) x y;\n     bounded_linear x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa. bounded_linear xa \\<and> (A ===> B) x xa", "apply (drule spec[where x=x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n     \\<forall>y. \\<exists>x. (A ===> B) x y; bounded_linear x;\n     Ex ((A ===> B) x)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa. bounded_linear xa \\<and> (A ===> B) x xa", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n        \\<forall>y. \\<exists>x. (A ===> B) x y; bounded_linear x;\n        (A ===> B) x xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            bounded_linear xa \\<and> (A ===> B) x xa", "apply (drule rel_funD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>y. \\<exists>x. (A ===> B) x y; bounded_linear x;\n        (A ===> B) x xa; bounded_linear x = bounded_linear xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            bounded_linear xa \\<and> (A ===> B) x xa", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n        \\<forall>x. Ex ((A ===> B) x);\n        \\<forall>y. \\<exists>x. (A ===> B) x y; bounded_linear y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. bounded_linear x \\<and> (A ===> B) x y", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n     \\<forall>x. Ex ((A ===> B) x); \\<forall>y. \\<exists>x. (A ===> B) x y;\n     bounded_linear x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa. bounded_linear xa \\<and> (A ===> B) xa x", "apply (drule spec[where x=x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n     \\<forall>x. Ex ((A ===> B) x); bounded_linear x;\n     \\<exists>xa. (A ===> B) xa x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa. bounded_linear xa \\<and> (A ===> B) xa x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>((A ===> B) ===> (=)) bounded_linear bounded_linear;\n        \\<forall>x. Ex ((A ===> B) x); bounded_linear x;\n        (A ===> B) xa x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            bounded_linear xa \\<and> (A ===> B) xa x", "apply (drule rel_funD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>x. Ex ((A ===> B) x); bounded_linear x;\n        (A ===> B) xa x; bounded_linear xa = bounded_linear x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            bounded_linear xa \\<and> (A ===> B) xa x", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma blinfun_apply_transfer[transfer_rule]:\n  \"(rel_blinfun A B ===> A ===> B) blinfun_apply blinfun_apply\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_blinfun A B ===> A ===> B) blinfun_apply blinfun_apply", "by (auto simp: rel_blinfun_def)"], ["", "lemma norm_blinfun_transfer[transfer_rule]: \"(rel_blinfun A A ===> (=)) norm norm\"\n  if [transfer_rule]: \"(A ===> (=)) norm norm\" \"(rel_set A) UNIV UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_blinfun A A ===> (=)) norm norm", "unfolding norm_blinfun.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_blinfun A A ===> (=)) (\\<lambda>x. onorm (blinfun_apply x))\n     (\\<lambda>x. onorm (blinfun_apply x))", "unfolding onorm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_blinfun A A ===> (=))\n     (\\<lambda>x. SUP xa. norm (blinfun_apply x xa) / norm xa)\n     (\\<lambda>x. SUP xa. norm (blinfun_apply x xa) / norm xa)", "by transfer_prover"], ["", "lemma minus_blinfun_transfer[transfer_rule]:\n  \"(rel_blinfun A B ===> rel_blinfun A B ===> rel_blinfun A B) (-) (-)\"\n  if \"(B ===> B ===> B) (-) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_blinfun A B ===> rel_blinfun A B ===> rel_blinfun A B) (-) (-)", "using that"], ["proof (prove)\nusing this:\n  (B ===> B ===> B) (-) (-)\n\ngoal (1 subgoal):\n 1. (rel_blinfun A B ===> rel_blinfun A B ===> rel_blinfun A B) (-) (-)", "apply (auto simp: rel_blinfun_def blinfun.bilinear_simps\n      intro!: rel_funI dest: rel_funD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(B ===> B ===> B) (-) (-);\n        (A ===> B) (blinfun_apply x) (blinfun_apply y);\n        (A ===> B) (blinfun_apply xa) (blinfun_apply ya); A xb yb\\<rbrakk>\n       \\<Longrightarrow> B (blinfun_apply x xb - blinfun_apply xa xb)\n                          (blinfun_apply y yb - blinfun_apply ya yb)", "by (metis rel_funD)"], ["", "lemma compose_blinfun_transfer[transfer_rule]:\"(rel_blinfun A B ===> rel_blinfun C A ===> rel_blinfun C B) (o\\<^sub>L) (o\\<^sub>L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_blinfun A B ===> rel_blinfun C A ===> rel_blinfun C B) (o\\<^sub>L)\n     (o\\<^sub>L)", "apply (auto simp: rel_blinfun_def blinfun.bilinear_simps\n      intro!: rel_funI dest: rel_funD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> B) (blinfun_apply x) (blinfun_apply y);\n        (C ===> A) (blinfun_apply xa) (blinfun_apply ya); C xb yb\\<rbrakk>\n       \\<Longrightarrow> B (blinfun_apply x (blinfun_apply xa xb))\n                          (blinfun_apply y (blinfun_apply ya yb))", "by (metis rel_funD)"], ["", "end"], ["", "end"]]}