{"file_name": "/home/qj213/afp-2021-10-22/thys/Slicing/While/AdditionalLemmas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Slicing", "problem_names": ["lemma path_SeqFirst:\n  \"prog \\<turnstile> n -as\\<rightarrow>* (_ l _) \\<Longrightarrow> prog;;c\\<^sub>2 \\<turnstile> n -as\\<rightarrow>* (_ l _)\"", "lemma path_SeqSecond:\n  \"\\<lbrakk>prog \\<turnstile> n -as\\<rightarrow>* n'; n \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk> \n  \\<Longrightarrow> c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -as \\<oplus>s #:c\\<^sub>1\\<rightarrow>* n' \\<oplus> #:c\\<^sub>1\"", "lemma path_CondTrue:\n  \"prog \\<turnstile> (_ l _) -as\\<rightarrow>* n' \n  \\<Longrightarrow> if (b) prog else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -as \\<oplus>s 1\\<rightarrow>* n' \\<oplus> 1\"", "lemma path_CondFalse:\n  \"prog \\<turnstile> (_ l _) -as\\<rightarrow>* n'\n  \\<Longrightarrow> if (b) c\\<^sub>1 else prog \\<turnstile> (_ l _) \\<oplus> (#:c\\<^sub>1 + 1) -as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* n' \\<oplus> (#:c\\<^sub>1 + 1)\"", "lemma path_While:\n  \"prog \\<turnstile> (_ l _) -as\\<rightarrow>* (_ l' _) \n  \\<Longrightarrow> while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -as \\<oplus>s 2\\<rightarrow>* (_ l' _) \\<oplus> 2\"", "lemma inner_node_Entry_Exit_path: \n  \"l < #:prog \\<Longrightarrow> (\\<exists>as. prog \\<turnstile> (_ l _) -as\\<rightarrow>* (_Exit_)) \\<and>\n                 (\\<exists>as. prog \\<turnstile> (_Entry_) -as\\<rightarrow>* (_ l _))\"", "lemma valid_node_Exit_path:\n  assumes \"valid_node prog n\" shows \"\\<exists>as. prog \\<turnstile> n -as\\<rightarrow>* (_Exit_)\"", "lemma valid_node_Entry_path:\n  assumes \"valid_node prog n\" shows \"\\<exists>as. prog \\<turnstile> (_Entry_) -as\\<rightarrow>* n\"", "lemma finite_labels:\"finite {l. \\<exists>c. labels prog l c}\"", "lemma finite_valid_nodes:\"finite {n. valid_node prog n}\"", "lemma finite_successors:\n  \"finite {n'. \\<exists>a'. valid_edge prog a' \\<and> sourcenode a' = n \\<and> \n                    targetnode a' = n'}\""], "translations": [["", "lemma path_SeqFirst:\n  \"prog \\<turnstile> n -as\\<rightarrow>* (_ l _) \\<Longrightarrow> prog;;c\\<^sub>2 \\<turnstile> n -as\\<rightarrow>* (_ l _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.path prog n as (_ l _) \\<Longrightarrow>\n    While_CFG.path (prog;; c\\<^sub>2) n as (_ l _)", "proof(induct n as \"(_ l _)\" arbitrary:l rule:While_CFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (prog;; c\\<^sub>2) (_ l _) [] (_ l _)\n 2. \\<And>n'' as a n l.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l _);\n        While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _); valid_edge prog a;\n        sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (prog;; c\\<^sub>2) n (a # as)\n                          (_ l _)", "case empty_path"], ["proof (state)\nthis:\n  While_CFG.valid_node prog (_ l _)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (prog;; c\\<^sub>2) (_ l _) [] (_ l _)\n 2. \\<And>n'' as a n l.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l _);\n        While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _); valid_edge prog a;\n        sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (prog;; c\\<^sub>2) n (a # as)\n                          (_ l _)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge prog) (_ l _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.valid_node prog (_ l _)", "show ?case"], ["proof (prove)\nusing this:\n  While_CFG.valid_node prog (_ l _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog;; c\\<^sub>2) (_ l _) [] (_ l _)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n    While_CFG.path (prog;; c\\<^sub>2) (_ l _) [] (_ l _)", "apply(rule While_CFG.empty_path)"], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n    While_CFG.valid_node (prog;; c\\<^sub>2) (_ l _)", "apply(auto simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       prog \\<turnstile> (_ l _) -aa\\<rightarrow> b \\<Longrightarrow>\n       \\<exists>a aa b.\n          prog;; c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> b \\<and>\n          ((_ l _) = a \\<or> (_ l _) = b)\n 2. \\<And>a aa.\n       prog \\<turnstile> a -aa\\<rightarrow> (_ l _) \\<Longrightarrow>\n       \\<exists>a aa b.\n          prog;; c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> b \\<and>\n          ((_ l _) = a \\<or> (_ l _) = b)", "by(case_tac b,auto dest:WCFG_SeqFirst WCFG_SeqConnect)"], ["proof (state)\nthis:\n  While_CFG.path (prog;; c\\<^sub>2) (_ l _) [] (_ l _)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n l.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l _);\n        While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _); valid_edge prog a;\n        sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (prog;; c\\<^sub>2) n (a # as)\n                          (_ l _)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as a n l.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l _);\n        While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _); valid_edge prog a;\n        sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (prog;; c\\<^sub>2) n (a # as)\n                          (_ l _)", "case (Cons_path n'' as a n)"], ["proof (state)\nthis:\n  While_CFG.path prog n'' as (_ l _)\n  While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _)\n  valid_edge prog a\n  sourcenode a = n\n  targetnode a = n''\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n l.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l _);\n        While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _); valid_edge prog a;\n        sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (prog;; c\\<^sub>2) n (a # as)\n                          (_ l _)", "note IH = \\<open>prog;; c\\<^sub>2 \\<turnstile> n'' -as\\<rightarrow>* (_ l _)\\<close>"], ["proof (state)\nthis:\n  While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n l.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l _);\n        While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _); valid_edge prog a;\n        sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (prog;; c\\<^sub>2) n (a # as)\n                          (_ l _)", "from \\<open>prog \\<turnstile> n'' -as\\<rightarrow>* (_ l _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog n'' as (_ l _)", "have \"n'' \\<noteq> (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog n'' as (_ l _)\n\ngoal (1 subgoal):\n 1. n'' \\<noteq> (_Exit_)", "by fastforce"], ["proof (state)\nthis:\n  n'' \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n l.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l _);\n        While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _); valid_edge prog a;\n        sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (prog;; c\\<^sub>2) n (a # as)\n                          (_ l _)", "with \\<open>valid_edge prog a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  sourcenode a = n\n  targetnode a = n''\n  n'' \\<noteq> (_Exit_)", "have \"prog;;c\\<^sub>2 \\<turnstile> n -kind a\\<rightarrow> n''\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  sourcenode a = n\n  targetnode a = n''\n  n'' \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. prog;; c\\<^sub>2 \\<turnstile> n -kind a\\<rightarrow> n''", "by(simp add:valid_edge_def WCFG_SeqFirst)"], ["proof (state)\nthis:\n  prog;; c\\<^sub>2 \\<turnstile> n -kind a\\<rightarrow> n''\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n l.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l _);\n        While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _); valid_edge prog a;\n        sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (prog;; c\\<^sub>2) n (a # as)\n                          (_ l _)", "with IH \\<open>prog;;c\\<^sub>2 \\<turnstile> n -kind a\\<rightarrow> n''\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _)\n  prog;; c\\<^sub>2 \\<turnstile> n -kind a\\<rightarrow> n''\n  sourcenode a = n\n  targetnode a = n''\n  prog;; c\\<^sub>2 \\<turnstile> n -kind a\\<rightarrow> n''", "show ?case"], ["proof (prove)\nusing this:\n  While_CFG.path (prog;; c\\<^sub>2) n'' as (_ l _)\n  prog;; c\\<^sub>2 \\<turnstile> n -kind a\\<rightarrow> n''\n  sourcenode a = n\n  targetnode a = n''\n  prog;; c\\<^sub>2 \\<turnstile> n -kind a\\<rightarrow> n''\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog;; c\\<^sub>2) n (a # as) (_ l _)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (prog;; c\\<^sub>2) n (a # as) (_ l _)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_SeqSecond:\n  \"\\<lbrakk>prog \\<turnstile> n -as\\<rightarrow>* n'; n \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk> \n  \\<Longrightarrow> c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -as \\<oplus>s #:c\\<^sub>1\\<rightarrow>* n' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>While_CFG.path prog n as n'; n \\<noteq> (_Entry_);\n     as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                       (n \\<oplus> #:c\\<^sub>1) (as \\<oplus>s #:c\\<^sub>1)\n                       (n' \\<oplus> #:c\\<^sub>1)", "proof(induct rule:While_CFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>While_CFG.valid_node prog n; n \\<noteq> (_Entry_);\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          ([] \\<oplus>s #:c\\<^sub>1)\n                          (n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<lbrakk>n'' \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                           (n'' \\<oplus> #:c\\<^sub>1)\n                           (as \\<oplus>s #:c\\<^sub>1)\n                           (n' \\<oplus> #:c\\<^sub>1);\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        n \\<noteq> (_Entry_); a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (n' \\<oplus> #:c\\<^sub>1)", "case (Cons_path n'' as n' a n)"], ["proof (state)\nthis:\n  While_CFG.path prog n'' as n'\n  \\<lbrakk>n'' \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                     (n'' \\<oplus> #:c\\<^sub>1) (as \\<oplus>s #:c\\<^sub>1)\n                     (n' \\<oplus> #:c\\<^sub>1)\n  valid_edge prog a\n  sourcenode a = n\n  targetnode a = n''\n  n \\<noteq> (_Entry_)\n  a # as \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>While_CFG.valid_node prog n; n \\<noteq> (_Entry_);\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          ([] \\<oplus>s #:c\\<^sub>1)\n                          (n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<lbrakk>n'' \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                           (n'' \\<oplus> #:c\\<^sub>1)\n                           (as \\<oplus>s #:c\\<^sub>1)\n                           (n' \\<oplus> #:c\\<^sub>1);\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        n \\<noteq> (_Entry_); a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (n' \\<oplus> #:c\\<^sub>1)", "note IH = \\<open> \\<lbrakk>n'' \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk> \n    \\<Longrightarrow> c\\<^sub>1;;prog \\<turnstile> n'' \\<oplus> #:c\\<^sub>1 -as \\<oplus>s #:c\\<^sub>1\\<rightarrow>* n' \\<oplus> #:c\\<^sub>1\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n'' \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                     (n'' \\<oplus> #:c\\<^sub>1) (as \\<oplus>s #:c\\<^sub>1)\n                     (n' \\<oplus> #:c\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>While_CFG.valid_node prog n; n \\<noteq> (_Entry_);\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          ([] \\<oplus>s #:c\\<^sub>1)\n                          (n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<lbrakk>n'' \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                           (n'' \\<oplus> #:c\\<^sub>1)\n                           (as \\<oplus>s #:c\\<^sub>1)\n                           (n' \\<oplus> #:c\\<^sub>1);\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        n \\<noteq> (_Entry_); a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (n' \\<oplus> #:c\\<^sub>1)", "from \\<open>valid_edge prog a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close> \\<open>n \\<noteq> (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  sourcenode a = n\n  targetnode a = n''\n  n \\<noteq> (_Entry_)", "have \"c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  sourcenode a = n\n  targetnode a = n''\n  n \\<noteq> (_Entry_)\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind\n         a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1", "by(simp add:valid_edge_def WCFG_SeqSecond)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind\n       a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>While_CFG.valid_node prog n; n \\<noteq> (_Entry_);\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          ([] \\<oplus>s #:c\\<^sub>1)\n                          (n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<lbrakk>n'' \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                           (n'' \\<oplus> #:c\\<^sub>1)\n                           (as \\<oplus>s #:c\\<^sub>1)\n                           (n' \\<oplus> #:c\\<^sub>1);\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        n \\<noteq> (_Entry_); a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (n' \\<oplus> #:c\\<^sub>1)", "from \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close> \\<open>valid_edge prog a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = n\n  targetnode a = n''\n  valid_edge prog a", "have \"[(n,kind a,n'')] \\<oplus>s #:c\\<^sub>1 = [a] \\<oplus>s #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  sourcenode a = n\n  targetnode a = n''\n  valid_edge prog a\n\ngoal (1 subgoal):\n 1. [(n, kind a, n'')] \\<oplus>s #:c\\<^sub>1 = [a] \\<oplus>s #:c\\<^sub>1", "by(cases a,simp add:label_incrs_def valid_edge_def)"], ["proof (state)\nthis:\n  [(n, kind a, n'')] \\<oplus>s #:c\\<^sub>1 = [a] \\<oplus>s #:c\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>While_CFG.valid_node prog n; n \\<noteq> (_Entry_);\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          ([] \\<oplus>s #:c\\<^sub>1)\n                          (n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<lbrakk>n'' \\<noteq> (_Entry_); as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                           (n'' \\<oplus> #:c\\<^sub>1)\n                           (as \\<oplus>s #:c\\<^sub>1)\n                           (n' \\<oplus> #:c\\<^sub>1);\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        n \\<noteq> (_Entry_); a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (n' \\<oplus> #:c\\<^sub>1)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "with \\<open>prog \\<turnstile> n'' -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog n'' as n'\n  as = []", "have [simp]:\"n'' = n'\""], ["proof (prove)\nusing this:\n  While_CFG.path prog n'' as n'\n  as = []\n\ngoal (1 subgoal):\n 1. n'' = n'", "by(auto elim:While_CFG.cases)"], ["proof (state)\nthis:\n  n'' = n'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "with \\<open>c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind\n       a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1\n  n'' = n'", "have \"c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -[(n,kind a,n')] \\<oplus>s #:c\\<^sub>1\\<rightarrow>* n' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind\n       a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1\n  n'' = n'\n\ngoal (1 subgoal):\n 1. While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     ([(n, kind a, n')] \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                  simp:label_incrs_def While_CFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n   ([(n, kind a, n')] \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "with True \\<open>[(n,kind a,n'')] \\<oplus>s #:c\\<^sub>1 = [a] \\<oplus>s #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  as = []\n  [(n, kind a, n'')] \\<oplus>s #:c\\<^sub>1 = [a] \\<oplus>s #:c\\<^sub>1\n  While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n   ([(n, kind a, n')] \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n  [(n, kind a, n'')] \\<oplus>s #:c\\<^sub>1 = [a] \\<oplus>s #:c\\<^sub>1\n  While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n   ([(n, kind a, n')] \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n   (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "from \\<open>valid_edge prog a\\<close> \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  targetnode a = n''", "have \"n'' \\<noteq> (_Entry_)\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  targetnode a = n''\n\ngoal (1 subgoal):\n 1. n'' \\<noteq> (_Entry_)", "by(cases n'',auto simp:valid_edge_def)"], ["proof (state)\nthis:\n  n'' \\<noteq> (_Entry_)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "from IH[OF this False]"], ["proof (chain)\npicking this:\n  While_CFG.path (c\\<^sub>1;; prog) (n'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "have \"c\\<^sub>1;;prog \\<turnstile> n'' \\<oplus> #:c\\<^sub>1 -as \\<oplus>s #:c\\<^sub>1\\<rightarrow>* n' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  While_CFG.path (c\\<^sub>1;; prog) (n'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (c\\<^sub>1;; prog) (n'' \\<oplus> #:c\\<^sub>1)\n     (as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "."], ["proof (state)\nthis:\n  While_CFG.path (c\\<^sub>1;; prog) (n'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "with \\<open>c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1\\<close> \\<open>sourcenode a = n\\<close>\n      \\<open>targetnode a = n''\\<close> \\<open>[(n,kind a,n'')] \\<oplus>s #:c\\<^sub>1 = [a] \\<oplus>s #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind\n       a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1\n  sourcenode a = n\n  targetnode a = n''\n  [(n, kind a, n'')] \\<oplus>s #:c\\<^sub>1 = [a] \\<oplus>s #:c\\<^sub>1\n  While_CFG.path (c\\<^sub>1;; prog) (n'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "show ?thesis"], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind\n       a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1\n  sourcenode a = n\n  targetnode a = n''\n  [(n, kind a, n'')] \\<oplus>s #:c\\<^sub>1 = [a] \\<oplus>s #:c\\<^sub>1\n  While_CFG.path (c\\<^sub>1;; prog) (n'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>c\\<^sub>1;;\n                prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -kind\n                     a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1;\n        sourcenode a = n; targetnode a = n'';\n        [(n, kind a, n'')] \\<oplus>s #:c\\<^sub>1 =\n        [a] \\<oplus>s #:c\\<^sub>1;\n        While_CFG.path (c\\<^sub>1;; prog) (n'' \\<oplus> #:c\\<^sub>1)\n         (as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1);\n        a = (aa, b, c)\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (n' \\<oplus> #:c\\<^sub>1)", "apply(simp add:label_incrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>c\\<^sub>1;;\n                prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -b\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1;\n        aa = n; c = n'';\n        While_CFG.path (c\\<^sub>1;; prog) (n'' \\<oplus> #:c\\<^sub>1)\n         (map (\\<lambda>(n, et, n').\n                  (n \\<oplus> #:c\\<^sub>1, et, n' \\<oplus> #:c\\<^sub>1))\n           as)\n         (n' \\<oplus> #:c\\<^sub>1);\n        a = (n, b, n'')\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          ((n \\<oplus> #:c\\<^sub>1, b,\n                            n'' \\<oplus> #:c\\<^sub>1) #\n                           map (\\<lambda>(n, et, n').\n                                   (n \\<oplus> #:c\\<^sub>1, et,\n                                    n' \\<oplus> #:c\\<^sub>1))\n                            as)\n                          (n' \\<oplus> #:c\\<^sub>1)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n   (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  While_CFG.path (c\\<^sub>1;; prog) (n \\<oplus> #:c\\<^sub>1)\n   (a # as \\<oplus>s #:c\\<^sub>1) (n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>While_CFG.valid_node prog n; n \\<noteq> (_Entry_);\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (c\\<^sub>1;; prog)\n                          (n \\<oplus> #:c\\<^sub>1)\n                          ([] \\<oplus>s #:c\\<^sub>1)\n                          (n \\<oplus> #:c\\<^sub>1)", "qed simp"], ["", "lemma path_CondTrue:\n  \"prog \\<turnstile> (_ l _) -as\\<rightarrow>* n' \n  \\<Longrightarrow> if (b) prog else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -as \\<oplus>s 1\\<rightarrow>* n' \\<oplus> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.path prog (_ l _) as n' \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (as \\<oplus>s 1) (n' \\<oplus> 1)", "proof(induct \"(_ l _)\" as n' arbitrary:l rule:While_CFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n        ([] \\<oplus>s 1) ((_ l _) \\<oplus> 1)\n 2. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n            (as \\<oplus>s 1) (n' \\<oplus> 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) prog else c\\<^sub>2)\n                          ((_ l _) \\<oplus> 1) (a # as \\<oplus>s 1)\n                          (n' \\<oplus> 1)", "case empty_path"], ["proof (state)\nthis:\n  While_CFG.valid_node prog (_ l _)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n        ([] \\<oplus>s 1) ((_ l _) \\<oplus> 1)\n 2. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n            (as \\<oplus>s 1) (n' \\<oplus> 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) prog else c\\<^sub>2)\n                          ((_ l _) \\<oplus> 1) (a # as \\<oplus>s 1)\n                          (n' \\<oplus> 1)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge prog) (_ l _)\\<close> \n    WCFG_CondTrue[of b prog c\\<^sub>2]"], ["proof (chain)\npicking this:\n  While_CFG.valid_node prog (_ l _)\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n     interpret b s =\n     Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 1", "have \"CFG.valid_node sourcenode targetnode (valid_edge (if (b) prog else c\\<^sub>2)) \n    ((_ l _) \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  While_CFG.valid_node prog (_ l _)\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n     interpret b s =\n     Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 1\n\ngoal (1 subgoal):\n 1. While_CFG.valid_node (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)", "apply(auto simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>if (b) prog\n                else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ Suc 0 _);\n        prog \\<turnstile> (_ l _) -aa\\<rightarrow> ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) prog\n                            else c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc l _) = a \\<or> (_ Suc l _) = ba)\n 2. \\<And>a aa.\n       \\<lbrakk>if (b) prog\n                else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ Suc 0 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) prog\n                            else c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc l _) = a \\<or> (_ Suc l _) = ba)", "apply(rotate_tac 1,drule WCFG_CondThen,simp,fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>if (b) prog\n                else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ Suc 0 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) prog\n                            else c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc l _) = a \\<or> (_ Suc l _) = ba)", "apply(case_tac a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa x1.\n       \\<lbrakk>if (b) prog\n                else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ Suc 0 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _); a = (_ x1 _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) prog\n                            else c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc l _) = a \\<or> (_ Suc l _) = ba)\n 2. \\<And>a aa.\n       \\<lbrakk>if (b) prog\n                else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ Suc 0 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _); a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) prog\n                            else c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc l _) = a \\<or> (_ Suc l _) = ba)\n 3. \\<And>a aa.\n       \\<lbrakk>if (b) prog\n                else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ Suc 0 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _); a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) prog\n                            else c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc l _) = a \\<or> (_ Suc l _) = ba)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa x1.\n       \\<lbrakk>if (b) prog\n                else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ Suc 0 _);\n        prog \\<turnstile> (_ x1 _) -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) prog\n                            else c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc l _) = a \\<or> (_ Suc l _) = ba)\n 2. \\<And>aa.\n       \\<lbrakk>if (b) prog\n                else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ Suc 0 _);\n        prog \\<turnstile> (_Entry_) -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) prog\n                            else c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc l _) = a \\<or> (_ Suc l _) = ba)", "apply(rotate_tac 1,drule WCFG_CondThen,simp,fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>if (b) prog\n                else c\\<^sub>2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ Suc 0 _);\n        prog \\<turnstile> (_Entry_) -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) prog\n                            else c\\<^sub>2 \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc l _) = a \\<or> (_ Suc l _) = ba)", "by(rotate_tac 1,drule WCFG_EntryD,auto)"], ["proof (state)\nthis:\n  While_CFG.valid_node (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n        ([] \\<oplus>s 1) ((_ l _) \\<oplus> 1)\n 2. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n            (as \\<oplus>s 1) (n' \\<oplus> 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) prog else c\\<^sub>2)\n                          ((_ l _) \\<oplus> 1) (a # as \\<oplus>s 1)\n                          (n' \\<oplus> 1)", "then"], ["proof (chain)\npicking this:\n  While_CFG.valid_node (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)", "show ?case"], ["proof (prove)\nusing this:\n  While_CFG.valid_node (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     ([] \\<oplus>s 1) ((_ l _) \\<oplus> 1)", "by(fastforce intro:While_CFG.empty_path simp:label_incrs_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   ([] \\<oplus>s 1) ((_ l _) \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n            (as \\<oplus>s 1) (n' \\<oplus> 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) prog else c\\<^sub>2)\n                          ((_ l _) \\<oplus> 1) (a # as \\<oplus>s 1)\n                          (n' \\<oplus> 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n            (as \\<oplus>s 1) (n' \\<oplus> 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) prog else c\\<^sub>2)\n                          ((_ l _) \\<oplus> 1) (a # as \\<oplus>s 1)\n                          (n' \\<oplus> 1)", "case (Cons_path n'' as n' a)"], ["proof (state)\nthis:\n  While_CFG.path prog n'' as n'\n  n'' = (_ ?l _) \\<Longrightarrow>\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ ?l _) \\<oplus> 1)\n   (as \\<oplus>s 1) (n' \\<oplus> 1)\n  valid_edge prog a\n  sourcenode a = (_ l _)\n  targetnode a = n''\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n            (as \\<oplus>s 1) (n' \\<oplus> 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) prog else c\\<^sub>2)\n                          ((_ l _) \\<oplus> 1) (a # as \\<oplus>s 1)\n                          (n' \\<oplus> 1)", "note IH = \\<open>\\<And>l. n'' = (_ l _) \n    \\<Longrightarrow> if (b) prog else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -as \\<oplus>s 1\\<rightarrow>* n' \\<oplus> 1\\<close>"], ["proof (state)\nthis:\n  n'' = (_ ?l _) \\<Longrightarrow>\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ ?l _) \\<oplus> 1)\n   (as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n            (as \\<oplus>s 1) (n' \\<oplus> 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) prog else c\\<^sub>2)\n                          ((_ l _) \\<oplus> 1) (a # as \\<oplus>s 1)\n                          (n' \\<oplus> 1)", "from \\<open>valid_edge prog a\\<close> \\<open>sourcenode a = (_ l _)\\<close>  \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  sourcenode a = (_ l _)\n  targetnode a = n''", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -kind a\\<rightarrow> n'' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  sourcenode a = (_ l _)\n  targetnode a = n''\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -kind\n               a\\<rightarrow> n'' \\<oplus> 1", "by -(rule WCFG_CondThen,simp_all add:valid_edge_def)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -kind\n             a\\<rightarrow> n'' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n            (as \\<oplus>s 1) (n' \\<oplus> 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) prog else c\\<^sub>2)\n                          ((_ l _) \\<oplus> 1) (a # as \\<oplus>s 1)\n                          (n' \\<oplus> 1)", "from \\<open>sourcenode a = (_ l _)\\<close> \\<open>targetnode a = n''\\<close> \\<open>valid_edge prog a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (_ l _)\n  targetnode a = n''\n  valid_edge prog a", "have \"[((_ l _),kind a,n'')] \\<oplus>s 1 = [a] \\<oplus>s 1\""], ["proof (prove)\nusing this:\n  sourcenode a = (_ l _)\n  targetnode a = n''\n  valid_edge prog a\n\ngoal (1 subgoal):\n 1. [((_ l _), kind a, n'')] \\<oplus>s 1 = [a] \\<oplus>s 1", "by(cases a,simp add:label_incrs_def valid_edge_def)"], ["proof (state)\nthis:\n  [((_ l _), kind a, n'')] \\<oplus>s 1 = [a] \\<oplus>s 1\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n            (as \\<oplus>s 1) (n' \\<oplus> 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) prog else c\\<^sub>2)\n                          ((_ l _) \\<oplus> 1) (a # as \\<oplus>s 1)\n                          (n' \\<oplus> 1)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "proof(cases n'')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n        (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "case (Node l')"], ["proof (state)\nthis:\n  n'' = (_ l' _)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n        (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "from IH[OF this]"], ["proof (chain)\npicking this:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l' _) \\<oplus> 1)\n   (as \\<oplus>s 1) (n' \\<oplus> 1)", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> (_ l' _) \\<oplus> 1 -as \\<oplus>s 1\\<rightarrow>* n' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l' _) \\<oplus> 1)\n   (as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l' _) \\<oplus> 1)\n     (as \\<oplus>s 1) (n' \\<oplus> 1)", "."], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l' _) \\<oplus> 1)\n   (as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n        (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "with \\<open>if (b) prog else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -kind a\\<rightarrow> n'' \\<oplus> 1\\<close> Node"], ["proof (chain)\npicking this:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -kind\n             a\\<rightarrow> n'' \\<oplus> 1\n  n'' = (_ l' _)\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l' _) \\<oplus> 1)\n   (as \\<oplus>s 1) (n' \\<oplus> 1)", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -((_ l _) \\<oplus> 1,kind a,n'' \\<oplus> 1)#(as \\<oplus>s 1)\\<rightarrow>* n' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -kind\n             a\\<rightarrow> n'' \\<oplus> 1\n  n'' = (_ l' _)\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l' _) \\<oplus> 1)\n   (as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (((_ l _) \\<oplus> 1, kind a, n'' \\<oplus> 1) # (as \\<oplus>s 1))\n     (n' \\<oplus> 1)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def valid_node_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   (((_ l _) \\<oplus> 1, kind a, n'' \\<oplus> 1) # (as \\<oplus>s 1))\n   (n' \\<oplus> 1)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n        (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "with \\<open>[((_ l _),kind a,n'')] \\<oplus>s 1 = [a] \\<oplus>s 1\\<close>"], ["proof (chain)\npicking this:\n  [((_ l _), kind a, n'')] \\<oplus>s 1 = [a] \\<oplus>s 1\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   (((_ l _) \\<oplus> 1, kind a, n'' \\<oplus> 1) # (as \\<oplus>s 1))\n   (n' \\<oplus> 1)", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -a#as \\<oplus>s 1\\<rightarrow>* n' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  [((_ l _), kind a, n'')] \\<oplus>s 1 = [a] \\<oplus>s 1\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   (((_ l _) \\<oplus> 1, kind a, n'' \\<oplus> 1) # (as \\<oplus>s 1))\n   (n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "by(simp add:label_incrs_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n        (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "case Entry"], ["proof (state)\nthis:\n  n'' = (_Entry_)\n\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "with \\<open>valid_edge prog a\\<close> \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  targetnode a = n''\n  n'' = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge prog a\n  targetnode a = n''\n  n'' = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "case Exit"], ["proof (state)\nthis:\n  n'' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "with \\<open>prog \\<turnstile> n'' -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog n'' as n'\n  n'' = (_Exit_)", "have \"n' = (_Exit_)\" and \"as = []\""], ["proof (prove)\nusing this:\n  While_CFG.path prog n'' as n'\n  n'' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n' = (_Exit_) &&& as = []", "by(auto dest:While_CFGExit.path_Exit_source)"], ["proof (state)\nthis:\n  n' = (_Exit_)\n  as = []\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "from \\<open>if (b) prog else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -kind a\\<rightarrow> n'' \\<oplus> 1\\<close>"], ["proof (chain)\npicking this:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -kind\n             a\\<rightarrow> n'' \\<oplus> 1", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -[((_ l _) \\<oplus> 1,kind a,n'' \\<oplus> 1)]\\<rightarrow>* n'' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> (_ l _) \\<oplus> 1 -kind\n             a\\<rightarrow> n'' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     [((_ l _) \\<oplus> 1, kind a, n'' \\<oplus> 1)] (n'' \\<oplus> 1)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path \n                  simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   [((_ l _) \\<oplus> 1, kind a, n'' \\<oplus> 1)] (n'' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "with Exit \\<open>[((_ l _),kind a,n'')] \\<oplus>s 1 = [a] \\<oplus>s 1\\<close>  \\<open>n' = (_Exit_)\\<close> \\<open>as = []\\<close>"], ["proof (chain)\npicking this:\n  n'' = (_Exit_)\n  [((_ l _), kind a, n'')] \\<oplus>s 1 = [a] \\<oplus>s 1\n  n' = (_Exit_)\n  as = []\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   [((_ l _) \\<oplus> 1, kind a, n'' \\<oplus> 1)] (n'' \\<oplus> 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  n'' = (_Exit_)\n  [((_ l _), kind a, n'')] \\<oplus>s 1 = [a] \\<oplus>s 1\n  n' = (_Exit_)\n  as = []\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   [((_ l _) \\<oplus> 1, kind a, n'' \\<oplus> 1)] (n'' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n     (a # as \\<oplus>s 1) (n' \\<oplus> 1)", "by(fastforce simp:label_incrs_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog else c\\<^sub>2) ((_ l _) \\<oplus> 1)\n   (a # as \\<oplus>s 1) (n' \\<oplus> 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_CondFalse:\n  \"prog \\<turnstile> (_ l _) -as\\<rightarrow>* n'\n  \\<Longrightarrow> if (b) c\\<^sub>1 else prog \\<turnstile> (_ l _) \\<oplus> (#:c\\<^sub>1 + 1) -as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* n' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.path prog (_ l _) as n' \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "proof(induct \"(_ l _)\" as n' arbitrary:l rule:While_CFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (if (b) c\\<^sub>1 else prog)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) ([] \\<oplus>s #:c\\<^sub>1 + 1)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) c\\<^sub>1 else prog)\n            ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n            (as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) c\\<^sub>1 else prog)\n                          ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (n' \\<oplus> #:c\\<^sub>1 + 1)", "case empty_path"], ["proof (state)\nthis:\n  While_CFG.valid_node prog (_ l _)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (if (b) c\\<^sub>1 else prog)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) ([] \\<oplus>s #:c\\<^sub>1 + 1)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) c\\<^sub>1 else prog)\n            ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n            (as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) c\\<^sub>1 else prog)\n                          ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge prog) (_ l _)\\<close>\n    WCFG_CondFalse[of b c\\<^sub>1 prog]"], ["proof (chain)\npicking this:\n  While_CFG.valid_node prog (_ l _)\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\ninterpret b s =\nSome false)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> #:c\\<^sub>1 + 1", "have \"CFG.valid_node sourcenode targetnode (valid_edge (if (b) c\\<^sub>1 else prog))\n    ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  While_CFG.valid_node prog (_ l _)\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\ninterpret b s =\nSome false)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. While_CFG.valid_node (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)", "apply(auto simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n              interpret b s =\n              Some false)\\<^sub>\\<surd>\\<rightarrow> (_ Suc #:c\\<^sub>1 _);\n        prog \\<turnstile> (_ l _) -aa\\<rightarrow> ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) c\\<^sub>1\n                            else prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc (l + #:c\\<^sub>1) _) = a \\<or>\n                             (_ Suc (l + #:c\\<^sub>1) _) = ba)\n 2. \\<And>a aa.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n              interpret b s =\n              Some false)\\<^sub>\\<surd>\\<rightarrow> (_ Suc #:c\\<^sub>1 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) c\\<^sub>1\n                            else prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc (l + #:c\\<^sub>1) _) = a \\<or>\n                             (_ Suc (l + #:c\\<^sub>1) _) = ba)", "apply(rotate_tac 1,drule WCFG_CondElse,simp,fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n              interpret b s =\n              Some false)\\<^sub>\\<surd>\\<rightarrow> (_ Suc #:c\\<^sub>1 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) c\\<^sub>1\n                            else prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc (l + #:c\\<^sub>1) _) = a \\<or>\n                             (_ Suc (l + #:c\\<^sub>1) _) = ba)", "apply(case_tac a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa x1.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n              interpret b s =\n              Some false)\\<^sub>\\<surd>\\<rightarrow> (_ Suc #:c\\<^sub>1 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _); a = (_ x1 _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) c\\<^sub>1\n                            else prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc (l + #:c\\<^sub>1) _) = a \\<or>\n                             (_ Suc (l + #:c\\<^sub>1) _) = ba)\n 2. \\<And>a aa.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n              interpret b s =\n              Some false)\\<^sub>\\<surd>\\<rightarrow> (_ Suc #:c\\<^sub>1 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _); a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) c\\<^sub>1\n                            else prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc (l + #:c\\<^sub>1) _) = a \\<or>\n                             (_ Suc (l + #:c\\<^sub>1) _) = ba)\n 3. \\<And>a aa.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n              interpret b s =\n              Some false)\\<^sub>\\<surd>\\<rightarrow> (_ Suc #:c\\<^sub>1 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _); a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) c\\<^sub>1\n                            else prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc (l + #:c\\<^sub>1) _) = a \\<or>\n                             (_ Suc (l + #:c\\<^sub>1) _) = ba)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa x1.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n              interpret b s =\n              Some false)\\<^sub>\\<surd>\\<rightarrow> (_ Suc #:c\\<^sub>1 _);\n        prog \\<turnstile> (_ x1 _) -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) c\\<^sub>1\n                            else prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc (l + #:c\\<^sub>1) _) = a \\<or>\n                             (_ Suc (l + #:c\\<^sub>1) _) = ba)\n 2. \\<And>aa.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n              interpret b s =\n              Some false)\\<^sub>\\<surd>\\<rightarrow> (_ Suc #:c\\<^sub>1 _);\n        prog \\<turnstile> (_Entry_) -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) c\\<^sub>1\n                            else prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc (l + #:c\\<^sub>1) _) = a \\<or>\n                             (_ Suc (l + #:c\\<^sub>1) _) = ba)", "apply(rotate_tac 1,drule WCFG_CondElse,simp,fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n              interpret b s =\n              Some false)\\<^sub>\\<surd>\\<rightarrow> (_ Suc #:c\\<^sub>1 _);\n        prog \\<turnstile> (_Entry_) -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            if (b) c\\<^sub>1\n                            else prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ Suc (l + #:c\\<^sub>1) _) = a \\<or>\n                             (_ Suc (l + #:c\\<^sub>1) _) = ba)", "by(rotate_tac 1,drule WCFG_EntryD,auto)"], ["proof (state)\nthis:\n  While_CFG.valid_node (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (if (b) c\\<^sub>1 else prog)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) ([] \\<oplus>s #:c\\<^sub>1 + 1)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) c\\<^sub>1 else prog)\n            ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n            (as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) c\\<^sub>1 else prog)\n                          ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (n' \\<oplus> #:c\\<^sub>1 + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  While_CFG.valid_node (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) ([] \\<oplus>s #:c\\<^sub>1 + 1)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce intro:While_CFG.empty_path simp:label_incrs_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) ([] \\<oplus>s #:c\\<^sub>1 + 1)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) c\\<^sub>1 else prog)\n            ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n            (as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) c\\<^sub>1 else prog)\n                          ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (n' \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) c\\<^sub>1 else prog)\n            ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n            (as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) c\\<^sub>1 else prog)\n                          ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (n' \\<oplus> #:c\\<^sub>1 + 1)", "case (Cons_path n'' as n' a)"], ["proof (state)\nthis:\n  While_CFG.path prog n'' as n'\n  n'' = (_ ?l _) \\<Longrightarrow>\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ ?l _) \\<oplus> #:c\\<^sub>1 + 1) (as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n  valid_edge prog a\n  sourcenode a = (_ l _)\n  targetnode a = n''\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) c\\<^sub>1 else prog)\n            ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n            (as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) c\\<^sub>1 else prog)\n                          ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (n' \\<oplus> #:c\\<^sub>1 + 1)", "note IH = \\<open>\\<And>l. n'' = (_ l _) \\<Longrightarrow> if (b) c\\<^sub>1 else prog \\<turnstile> (_ l _) \\<oplus> (#:c\\<^sub>1 + 1) \n                                               -as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* n' \\<oplus> (#:c\\<^sub>1 + 1)\\<close>"], ["proof (state)\nthis:\n  n'' = (_ ?l _) \\<Longrightarrow>\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ ?l _) \\<oplus> #:c\\<^sub>1 + 1) (as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) c\\<^sub>1 else prog)\n            ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n            (as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) c\\<^sub>1 else prog)\n                          ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>valid_edge prog a\\<close> \\<open>sourcenode a = (_ l _)\\<close>  \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  sourcenode a = (_ l _)\n  targetnode a = n''", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> (_ l _) \\<oplus> (#:c\\<^sub>1 + 1) -kind a\\<rightarrow> n'' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  sourcenode a = (_ l _)\n  targetnode a = n''\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog \\<turnstile> (_ l _) \\<oplus> #:c\\<^sub>1 +\n      1 -kind a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1 + 1", "by -(rule WCFG_CondElse,simp_all add:valid_edge_def)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> (_ l _) \\<oplus> #:c\\<^sub>1 +\n    1 -kind a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) c\\<^sub>1 else prog)\n            ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n            (as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) c\\<^sub>1 else prog)\n                          ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>sourcenode a = (_ l _)\\<close> \\<open>targetnode a = n''\\<close> \\<open>valid_edge prog a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (_ l _)\n  targetnode a = n''\n  valid_edge prog a", "have \"[((_ l _),kind a,n'')] \\<oplus>s (#:c\\<^sub>1 + 1) = [a] \\<oplus>s (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  sourcenode a = (_ l _)\n  targetnode a = n''\n  valid_edge prog a\n\ngoal (1 subgoal):\n 1. [((_ l _), kind a, n'')] \\<oplus>s #:c\\<^sub>1 + 1 =\n    [a] \\<oplus>s #:c\\<^sub>1 + 1", "by(cases a,simp add:label_incrs_def valid_edge_def)"], ["proof (state)\nthis:\n  [((_ l _), kind a, n'')] \\<oplus>s #:c\\<^sub>1 + 1 =\n  [a] \\<oplus>s #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a l.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (if (b) c\\<^sub>1 else prog)\n            ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n            (as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (if (b) c\\<^sub>1 else prog)\n                          ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (n' \\<oplus> #:c\\<^sub>1 + 1)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "proof(cases n'')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) c\\<^sub>1 else prog)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n        (a # as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "case (Node l')"], ["proof (state)\nthis:\n  n'' = (_ l' _)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) c\\<^sub>1 else prog)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n        (a # as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "from IH[OF this]"], ["proof (chain)\npicking this:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l' _) \\<oplus> #:c\\<^sub>1 + 1) (as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> (_ l' _) \\<oplus> (#:c\\<^sub>1 + 1) \n                                             -as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* n' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l' _) \\<oplus> #:c\\<^sub>1 + 1) (as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l' _) \\<oplus> #:c\\<^sub>1 + 1) (as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "."], ["proof (state)\nthis:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l' _) \\<oplus> #:c\\<^sub>1 + 1) (as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) c\\<^sub>1 else prog)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n        (a # as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>if (b) c\\<^sub>1 else prog \\<turnstile> (_ l _) \\<oplus> (#:c\\<^sub>1 + 1) -kind a\\<rightarrow> n'' \\<oplus> (#:c\\<^sub>1 + 1)\\<close> Node"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> (_ l _) \\<oplus> #:c\\<^sub>1 +\n    1 -kind a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1 + 1\n  n'' = (_ l' _)\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l' _) \\<oplus> #:c\\<^sub>1 + 1) (as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> (_ l _) \\<oplus> (#:c\\<^sub>1 + 1) \n      -((_ l _) \\<oplus> (#:c\\<^sub>1 + 1),kind a,n'' \\<oplus> (#:c\\<^sub>1 + 1))#(as \\<oplus>s (#:c\\<^sub>1 + 1))\\<rightarrow>* \n      n' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> (_ l _) \\<oplus> #:c\\<^sub>1 +\n    1 -kind a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1 + 1\n  n'' = (_ l' _)\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l' _) \\<oplus> #:c\\<^sub>1 + 1) (as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n     (((_ l _) \\<oplus> #:c\\<^sub>1 + 1, kind a,\n       n'' \\<oplus> #:c\\<^sub>1 + 1) #\n      (as \\<oplus>s #:c\\<^sub>1 + 1))\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def valid_node_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n   (((_ l _) \\<oplus> #:c\\<^sub>1 + 1, kind a,\n     n'' \\<oplus> #:c\\<^sub>1 + 1) #\n    (as \\<oplus>s #:c\\<^sub>1 + 1))\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) c\\<^sub>1 else prog)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n        (a # as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>[((_ l _),kind a,n'')] \\<oplus>s (#:c\\<^sub>1 + 1) = [a] \\<oplus>s (#:c\\<^sub>1 + 1)\\<close> Node"], ["proof (chain)\npicking this:\n  [((_ l _), kind a, n'')] \\<oplus>s #:c\\<^sub>1 + 1 =\n  [a] \\<oplus>s #:c\\<^sub>1 + 1\n  n'' = (_ l' _)\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n   (((_ l _) \\<oplus> #:c\\<^sub>1 + 1, kind a,\n     n'' \\<oplus> #:c\\<^sub>1 + 1) #\n    (as \\<oplus>s #:c\\<^sub>1 + 1))\n   (n' \\<oplus> #:c\\<^sub>1 + 1)", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> (_ l _) \\<oplus> (#:c\\<^sub>1 + 1) -a#as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* \n                                n' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  [((_ l _), kind a, n'')] \\<oplus>s #:c\\<^sub>1 + 1 =\n  [a] \\<oplus>s #:c\\<^sub>1 + 1\n  n'' = (_ l' _)\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n   (((_ l _) \\<oplus> #:c\\<^sub>1 + 1, kind a,\n     n'' \\<oplus> #:c\\<^sub>1 + 1) #\n    (as \\<oplus>s #:c\\<^sub>1 + 1))\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "by(simp add:label_incrs_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (if (b) c\\<^sub>1 else prog)\n        ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n        (a # as \\<oplus>s #:c\\<^sub>1 + 1) (n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "case Entry"], ["proof (state)\nthis:\n  n'' = (_Entry_)\n\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>valid_edge prog a\\<close> \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  targetnode a = n''\n  n'' = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge prog a\n  targetnode a = n''\n  n'' = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "case Exit"], ["proof (state)\nthis:\n  n'' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>prog \\<turnstile> n'' -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog n'' as n'\n  n'' = (_Exit_)", "have \"n' = (_Exit_)\" and \"as = []\""], ["proof (prove)\nusing this:\n  While_CFG.path prog n'' as n'\n  n'' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n' = (_Exit_) &&& as = []", "by(auto dest:While_CFGExit.path_Exit_source)"], ["proof (state)\nthis:\n  n' = (_Exit_)\n  as = []\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>if (b) c\\<^sub>1 else prog \\<turnstile> (_ l _) \\<oplus> (#:c\\<^sub>1 + 1) -kind a\\<rightarrow> n'' \\<oplus> (#:c\\<^sub>1 + 1)\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> (_ l _) \\<oplus> #:c\\<^sub>1 +\n    1 -kind a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1 + 1", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> (_ l _) \\<oplus> (#:c\\<^sub>1 + 1) \n          -[((_ l _) \\<oplus> (#:c\\<^sub>1 + 1),kind a,n'' \\<oplus> (#:c\\<^sub>1 + 1))]\\<rightarrow>* n'' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> (_ l _) \\<oplus> #:c\\<^sub>1 +\n    1 -kind a\\<rightarrow> n'' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n     [((_ l _) \\<oplus> #:c\\<^sub>1 + 1, kind a,\n       n'' \\<oplus> #:c\\<^sub>1 + 1)]\n     (n'' \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path \n                  simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n   [((_ l _) \\<oplus> #:c\\<^sub>1 + 1, kind a,\n     n'' \\<oplus> #:c\\<^sub>1 + 1)]\n   (n'' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "with Exit \\<open>[((_ l _),kind a,n'')] \\<oplus>s (#:c\\<^sub>1 + 1) = [a] \\<oplus>s (#:c\\<^sub>1 + 1)\\<close> \\<open>n' = (_Exit_)\\<close>\n      \\<open>as = []\\<close>"], ["proof (chain)\npicking this:\n  n'' = (_Exit_)\n  [((_ l _), kind a, n'')] \\<oplus>s #:c\\<^sub>1 + 1 =\n  [a] \\<oplus>s #:c\\<^sub>1 + 1\n  n' = (_Exit_)\n  as = []\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n   [((_ l _) \\<oplus> #:c\\<^sub>1 + 1, kind a,\n     n'' \\<oplus> #:c\\<^sub>1 + 1)]\n   (n'' \\<oplus> #:c\\<^sub>1 + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  n'' = (_Exit_)\n  [((_ l _), kind a, n'')] \\<oplus>s #:c\\<^sub>1 + 1 =\n  [a] \\<oplus>s #:c\\<^sub>1 + 1\n  n' = (_Exit_)\n  as = []\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1)\n   [((_ l _) \\<oplus> #:c\\<^sub>1 + 1, kind a,\n     n'' \\<oplus> #:c\\<^sub>1 + 1)]\n   (n'' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) c\\<^sub>1 else prog)\n     ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n     (n' \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce simp:label_incrs_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  While_CFG.path (if (b) c\\<^sub>1 else prog)\n   ((_ l _) \\<oplus> #:c\\<^sub>1 + 1) (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n   (n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "declare add_2_eq_Suc' [simp del] One_nat_def [simp del]"], ["", "(*>*)"], ["", "lemma path_While:\n  \"prog \\<turnstile> (_ l _) -as\\<rightarrow>* (_ l' _) \n  \\<Longrightarrow> while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -as \\<oplus>s 2\\<rightarrow>* (_ l' _) \\<oplus> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.path prog (_ l _) as (_ l' _) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) (as \\<oplus>s 2)\n     ((_ l' _) \\<oplus> 2)", "proof(induct \"(_ l _)\" as \"(_ l' _)\" arbitrary:l l' rule:While_CFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) ([] \\<oplus>s 2)\n        ((_ l _) \\<oplus> 2)\n 2. \\<And>n'' as a l l'.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l' _);\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n            (as \\<oplus>s 2) ((_ l' _) \\<oplus> 2);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (while (b) prog)\n                          ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n                          ((_ l' _) \\<oplus> 2)", "case empty_path"], ["proof (state)\nthis:\n  While_CFG.valid_node prog (_ l _)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) ([] \\<oplus>s 2)\n        ((_ l _) \\<oplus> 2)\n 2. \\<And>n'' as a l l'.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l' _);\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n            (as \\<oplus>s 2) ((_ l' _) \\<oplus> 2);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (while (b) prog)\n                          ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n                          ((_ l' _) \\<oplus> 2)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge prog) (_ l _)\\<close>\n    WCFG_WhileTrue[of b prog]"], ["proof (chain)\npicking this:\n  While_CFG.valid_node prog (_ l _)\n  while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n     interpret b s =\n     Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 2", "have \"CFG.valid_node sourcenode targetnode (valid_edge (while (b) prog)) ((_ l _) \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  While_CFG.valid_node prog (_ l _)\n  while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n     interpret b s =\n     Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 2\n\ngoal (1 subgoal):\n 1. While_CFG.valid_node (while (b) prog) ((_ l _) \\<oplus> 2)", "apply(auto simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_ l _) -aa\\<rightarrow> ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 2. \\<And>a aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)", "apply(case_tac ba)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba x1.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_ l _) -aa\\<rightarrow> ba;\n        ba = (_ x1 _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 2. \\<And>aa ba.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_ l _) -aa\\<rightarrow> ba;\n        ba = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 3. \\<And>aa ba.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_ l _) -aa\\<rightarrow> ba;\n        ba = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 4. \\<And>a aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa x1.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_ l _) -aa\\<rightarrow> (_ x1 _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 2. \\<And>aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_ l _) -aa\\<rightarrow> (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 3. \\<And>a aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)", "apply(rotate_tac 1,drule WCFG_WhileBody,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_ l _) -aa\\<rightarrow> (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 2. \\<And>a aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)", "apply(rotate_tac 1,drule WCFG_WhileBodyExit,auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)", "apply(case_tac a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa x1.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _); a = (_ x1 _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 2. \\<And>a aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _); a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 3. \\<And>a aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> a -aa\\<rightarrow> (_ l _); a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa x1.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_ x1 _) -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)\n 2. \\<And>aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_Entry_) -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)", "apply(rotate_tac 1,drule WCFG_WhileBody,auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>while (b) prog \\<turnstile> (_ 0 _) -(\\<lambda>s.\n                   interpret b s =\n                   Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 2 _);\n        prog \\<turnstile> (_Entry_) -aa\\<rightarrow> (_ l _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ba.\n                            while (b) prog \\<turnstile> a -aa\\<rightarrow> ba \\<and>\n                            ((_ l + 2 _) = a \\<or> (_ l + 2 _) = ba)", "by(rotate_tac 1,drule WCFG_EntryD,auto)"], ["proof (state)\nthis:\n  While_CFG.valid_node (while (b) prog) ((_ l _) \\<oplus> 2)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       While_CFG.valid_node prog (_ l _) \\<Longrightarrow>\n       While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) ([] \\<oplus>s 2)\n        ((_ l _) \\<oplus> 2)\n 2. \\<And>n'' as a l l'.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l' _);\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n            (as \\<oplus>s 2) ((_ l' _) \\<oplus> 2);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (while (b) prog)\n                          ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n                          ((_ l' _) \\<oplus> 2)", "thus ?case"], ["proof (prove)\nusing this:\n  While_CFG.valid_node (while (b) prog) ((_ l _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) ([] \\<oplus>s 2)\n     ((_ l _) \\<oplus> 2)", "by(fastforce intro:While_CFG.empty_path simp:label_incrs_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) ([] \\<oplus>s 2)\n   ((_ l _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a l l'.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l' _);\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n            (as \\<oplus>s 2) ((_ l' _) \\<oplus> 2);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (while (b) prog)\n                          ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n                          ((_ l' _) \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as a l l'.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l' _);\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n            (as \\<oplus>s 2) ((_ l' _) \\<oplus> 2);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (while (b) prog)\n                          ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n                          ((_ l' _) \\<oplus> 2)", "case (Cons_path n'' as a)"], ["proof (state)\nthis:\n  While_CFG.path prog n'' as (_ l' _)\n  n'' = (_ ?l _) \\<Longrightarrow>\n  While_CFG.path (while (b) prog) ((_ ?l _) \\<oplus> 2) (as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n  valid_edge prog a\n  sourcenode a = (_ l _)\n  targetnode a = n''\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a l l'.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l' _);\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n            (as \\<oplus>s 2) ((_ l' _) \\<oplus> 2);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (while (b) prog)\n                          ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n                          ((_ l' _) \\<oplus> 2)", "note IH = \\<open>\\<And>l. n'' = (_ l _)\n    \\<Longrightarrow> while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -as \\<oplus>s 2\\<rightarrow>* (_ l' _) \\<oplus> 2\\<close>"], ["proof (state)\nthis:\n  n'' = (_ ?l _) \\<Longrightarrow>\n  While_CFG.path (while (b) prog) ((_ ?l _) \\<oplus> 2) (as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a l l'.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l' _);\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n            (as \\<oplus>s 2) ((_ l' _) \\<oplus> 2);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (while (b) prog)\n                          ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n                          ((_ l' _) \\<oplus> 2)", "from \\<open>sourcenode a = (_ l _)\\<close> \\<open>targetnode a = n''\\<close> \\<open>valid_edge prog a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (_ l _)\n  targetnode a = n''\n  valid_edge prog a", "have \"[((_ l _),kind a,n'')] \\<oplus>s 2 = [a] \\<oplus>s 2\""], ["proof (prove)\nusing this:\n  sourcenode a = (_ l _)\n  targetnode a = n''\n  valid_edge prog a\n\ngoal (1 subgoal):\n 1. [((_ l _), kind a, n'')] \\<oplus>s 2 = [a] \\<oplus>s 2", "by(cases a,simp add:label_incrs_def valid_edge_def)"], ["proof (state)\nthis:\n  [((_ l _), kind a, n'')] \\<oplus>s 2 = [a] \\<oplus>s 2\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a l l'.\n       \\<lbrakk>While_CFG.path prog n'' as (_ l' _);\n        \\<And>l.\n           n'' = (_ l _) \\<Longrightarrow>\n           While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n            (as \\<oplus>s 2) ((_ l' _) \\<oplus> 2);\n        valid_edge prog a; sourcenode a = (_ l _);\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> While_CFG.path (while (b) prog)\n                          ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n                          ((_ l' _) \\<oplus> 2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "proof(cases n'')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n        (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "case (Node l'')"], ["proof (state)\nthis:\n  n'' = (_ l'' _)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n        (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "with \\<open>valid_edge prog a\\<close> \\<open>sourcenode a = (_ l _)\\<close>  \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  sourcenode a = (_ l _)\n  targetnode a = n''\n  n'' = (_ l'' _)", "have \"while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -kind a\\<rightarrow> n'' \\<oplus> 2\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  sourcenode a = (_ l _)\n  targetnode a = n''\n  n'' = (_ l'' _)\n\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -kind\n               a\\<rightarrow> n'' \\<oplus> 2", "by -(rule WCFG_WhileBody,simp_all add:valid_edge_def)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -kind\n             a\\<rightarrow> n'' \\<oplus> 2\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n        (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "from IH[OF Node]"], ["proof (chain)\npicking this:\n  While_CFG.path (while (b) prog) ((_ l'' _) \\<oplus> 2) (as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)", "have \"while (b) prog \\<turnstile> (_ l'' _) \\<oplus> 2 -as \\<oplus>s 2\\<rightarrow>* (_ l' _) \\<oplus> 2\""], ["proof (prove)\nusing this:\n  While_CFG.path (while (b) prog) ((_ l'' _) \\<oplus> 2) (as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog) ((_ l'' _) \\<oplus> 2) (as \\<oplus>s 2)\n     ((_ l' _) \\<oplus> 2)", "."], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog) ((_ l'' _) \\<oplus> 2) (as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n        (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "with \\<open>while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -kind a\\<rightarrow> n'' \\<oplus> 2\\<close> Node"], ["proof (chain)\npicking this:\n  while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -kind\n             a\\<rightarrow> n'' \\<oplus> 2\n  n'' = (_ l'' _)\n  While_CFG.path (while (b) prog) ((_ l'' _) \\<oplus> 2) (as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)", "have \"while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -((_ l _) \\<oplus> 2,kind a,n'' \\<oplus> 2)#(as \\<oplus>s 2)\\<rightarrow>* (_ l' _) \\<oplus> 2\""], ["proof (prove)\nusing this:\n  while (b) prog \\<turnstile> (_ l _) \\<oplus> 2 -kind\n             a\\<rightarrow> n'' \\<oplus> 2\n  n'' = (_ l'' _)\n  While_CFG.path (while (b) prog) ((_ l'' _) \\<oplus> 2) (as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (((_ l _) \\<oplus> 2, kind a, n'' \\<oplus> 2) # (as \\<oplus>s 2))\n     ((_ l' _) \\<oplus> 2)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n   (((_ l _) \\<oplus> 2, kind a, n'' \\<oplus> 2) # (as \\<oplus>s 2))\n   ((_ l' _) \\<oplus> 2)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n'' = (_ x1 _) \\<Longrightarrow>\n       While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n        (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 2. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 3. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "with \\<open>[((_ l _),kind a,n'')] \\<oplus>s 2 = [a] \\<oplus>s 2\\<close>"], ["proof (chain)\npicking this:\n  [((_ l _), kind a, n'')] \\<oplus>s 2 = [a] \\<oplus>s 2\n  While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n   (((_ l _) \\<oplus> 2, kind a, n'' \\<oplus> 2) # (as \\<oplus>s 2))\n   ((_ l' _) \\<oplus> 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  [((_ l _), kind a, n'')] \\<oplus>s 2 = [a] \\<oplus>s 2\n  While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n   (((_ l _) \\<oplus> 2, kind a, n'' \\<oplus> 2) # (as \\<oplus>s 2))\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "by(simp add:label_incrs_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "case Entry"], ["proof (state)\nthis:\n  n'' = (_Entry_)\n\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "with \\<open>valid_edge prog a\\<close> \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  targetnode a = n''\n  n'' = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge prog a\n  targetnode a = n''\n  n'' = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. n'' = (_Entry_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)\n 2. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "case Exit"], ["proof (state)\nthis:\n  n'' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "with \\<open>prog \\<turnstile> n'' -as\\<rightarrow>* (_ l' _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog n'' as (_ l' _)\n  n'' = (_Exit_)", "have \"(_ l' _) = (_Exit_)\" and \"as = []\""], ["proof (prove)\nusing this:\n  While_CFG.path prog n'' as (_ l' _)\n  n'' = (_Exit_)\n\ngoal (1 subgoal):\n 1. (_ l' _) = (_Exit_) &&& as = []", "by(auto dest:While_CFGExit.path_Exit_source)"], ["proof (state)\nthis:\n  (_ l' _) = (_Exit_)\n  as = []\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "then"], ["proof (chain)\npicking this:\n  (_ l' _) = (_Exit_)\n  as = []", "have False"], ["proof (prove)\nusing this:\n  (_ l' _) = (_Exit_)\n  as = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n'' = (_Exit_) \\<Longrightarrow>\n    While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2)\n     (a # as \\<oplus>s 2) ((_ l' _) \\<oplus> 2)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog) ((_ l _) \\<oplus> 2) (a # as \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inner_node_Entry_Exit_path: \n  \"l < #:prog \\<Longrightarrow> (\\<exists>as. prog \\<turnstile> (_ l _) -as\\<rightarrow>* (_Exit_)) \\<and>\n                 (\\<exists>as. prog \\<turnstile> (_Entry_) -as\\<rightarrow>* (_ l _))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < #:prog \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _))", "proof(induct prog arbitrary:l)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>l.\n       l < #:Skip \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path Skip (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path Skip (_Entry_) as (_ l _))\n 2. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 3. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 4. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 5. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "case Skip"], ["proof (state)\nthis:\n  l < #:Skip\n\ngoal (5 subgoals):\n 1. \\<And>l.\n       l < #:Skip \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path Skip (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path Skip (_Entry_) as (_ l _))\n 2. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 3. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 4. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 5. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "from \\<open>l < #:Skip\\<close>"], ["proof (chain)\npicking this:\n  l < #:Skip", "have [simp]:\"l = 0\""], ["proof (prove)\nusing this:\n  l < #:Skip\n\ngoal (1 subgoal):\n 1. l = 0", "by simp"], ["proof (state)\nthis:\n  l = 0\n\ngoal (5 subgoals):\n 1. \\<And>l.\n       l < #:Skip \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path Skip (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path Skip (_Entry_) as (_ l _))\n 2. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 3. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 4. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 5. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "hence \"Skip \\<turnstile> (_ l _) -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\nusing this:\n  l = 0\n\ngoal (1 subgoal):\n 1. Skip \\<turnstile> (_ l _) -\\<Up>id\\<rightarrow> (_Exit_)", "by(simp add:WCFG_Skip)"], ["proof (state)\nthis:\n  Skip \\<turnstile> (_ l _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (5 subgoals):\n 1. \\<And>l.\n       l < #:Skip \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path Skip (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path Skip (_Entry_) as (_ l _))\n 2. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 3. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 4. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 5. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "hence \"Skip \\<turnstile> (_ l _) -[((_ l _),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  Skip \\<turnstile> (_ l _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path Skip (_ l _) [((_ l _), \\<Up>id, (_Exit_))] (_Exit_)", "by (fastforce intro: While_CFG.path.intros simp: valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path Skip (_ l _) [((_ l _), \\<Up>id, (_Exit_))] (_Exit_)\n\ngoal (5 subgoals):\n 1. \\<And>l.\n       l < #:Skip \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path Skip (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path Skip (_Entry_) as (_ l _))\n 2. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 3. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 4. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 5. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "have \"Skip \\<turnstile> (_Entry_) -(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow> (_ l _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Skip \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                     True)\\<^sub>\\<surd>\\<rightarrow> (_ l _)", "by(simp add:WCFG_Entry)"], ["proof (state)\nthis:\n  Skip \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   True)\\<^sub>\\<surd>\\<rightarrow> (_ l _)\n\ngoal (5 subgoals):\n 1. \\<And>l.\n       l < #:Skip \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path Skip (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path Skip (_Entry_) as (_ l _))\n 2. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 3. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 4. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 5. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "hence \"Skip \\<turnstile> (_Entry_) -[((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_ l _))]\\<rightarrow>* (_ l _)\""], ["proof (prove)\nusing this:\n  Skip \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   True)\\<^sub>\\<surd>\\<rightarrow> (_ l _)\n\ngoal (1 subgoal):\n 1. While_CFG.path Skip (_Entry_)\n     [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ l _))] (_ l _)", "by(fastforce intro:While_CFG.path.intros simp:valid_edge_def While_CFG.valid_node_def)"], ["proof (state)\nthis:\n  While_CFG.path Skip (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ l _))] (_ l _)\n\ngoal (5 subgoals):\n 1. \\<And>l.\n       l < #:Skip \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path Skip (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path Skip (_Entry_) as (_ l _))\n 2. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 3. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 4. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 5. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "with \\<open>Skip \\<turnstile> (_ l _) -[((_ l _),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path Skip (_ l _) [((_ l _), \\<Up>id, (_Exit_))] (_Exit_)\n  While_CFG.path Skip (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ l _))] (_ l _)", "show ?case"], ["proof (prove)\nusing this:\n  While_CFG.path Skip (_ l _) [((_ l _), \\<Up>id, (_Exit_))] (_Exit_)\n  While_CFG.path Skip (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ l _))] (_ l _)\n\ngoal (1 subgoal):\n 1. (\\<exists>as. While_CFG.path Skip (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path Skip (_Entry_) as (_ l _))", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path Skip (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path Skip (_Entry_) as (_ l _))\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 2. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 3. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 4. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 2. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 3. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 4. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "case (LAss V e)"], ["proof (state)\nthis:\n  l < #:V:=e\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 2. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 3. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 4. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "from \\<open>l < #:V:=e\\<close>"], ["proof (chain)\npicking this:\n  l < #:V:=e", "have \"l = 0 \\<or> l = 1\""], ["proof (prove)\nusing this:\n  l < #:V:=e\n\ngoal (1 subgoal):\n 1. l = 0 \\<or> l = 1", "by auto"], ["proof (state)\nthis:\n  l = 0 \\<or> l = 1\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 l.\n       l < #:x1:=x2 \\<Longrightarrow>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_ l _) as (_Exit_)) \\<and>\n       (\\<exists>as. While_CFG.path (x1:=x2) (_Entry_) as (_ l _))\n 2. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 3. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 4. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "thus ?case"], ["proof (prove)\nusing this:\n  l = 0 \\<or> l = 1\n\ngoal (1 subgoal):\n 1. (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n 2. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "assume [simp]:\"l = 0\""], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n 2. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "hence \"V:=e \\<turnstile> (_Entry_) -(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow> (_ l _)\""], ["proof (prove)\nusing this:\n  l = 0\n\ngoal (1 subgoal):\n 1. V:=e \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                     True)\\<^sub>\\<surd>\\<rightarrow> (_ l _)", "by(simp add:WCFG_Entry)"], ["proof (state)\nthis:\n  V:=e \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   True)\\<^sub>\\<surd>\\<rightarrow> (_ l _)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n 2. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "hence \"V:=e \\<turnstile> (_Entry_) -[((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_ l _))]\\<rightarrow>* (_ l _)\""], ["proof (prove)\nusing this:\n  V:=e \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   True)\\<^sub>\\<surd>\\<rightarrow> (_ l _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (V:=e) (_Entry_)\n     [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ l _))] (_ l _)", "by(fastforce intro:While_CFG.path.intros simp:valid_edge_def While_CFG.valid_node_def)"], ["proof (state)\nthis:\n  While_CFG.path (V:=e) (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ l _))] (_ l _)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n 2. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "have \"V:=e \\<turnstile> (_1_) -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V:=e \\<turnstile> (_ 1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "by(rule WCFG_LAssSkip)"], ["proof (state)\nthis:\n  V:=e \\<turnstile> (_ 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n 2. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "hence \"V:=e \\<turnstile> (_1_) -[((_1_),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  V:=e \\<turnstile> (_ 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (V:=e) (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))] (_Exit_)", "by(fastforce intro:While_CFG.path.intros simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (V:=e) (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))] (_Exit_)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n 2. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "with WCFG_LAss"], ["proof (chain)\npicking this:\n  ?V:=?e \\<turnstile> (_ 0 _) -\\<Up>\\<lambda>s. s\n (?V := interpret ?e s)\\<rightarrow> (_ 1 _)\n  While_CFG.path (V:=e) (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))] (_Exit_)", "have \"V:=e \\<turnstile> (_ l _) -\n      [((_ l _),\\<Up>(\\<lambda>s. s(V:=(interpret e s))),(_1_)),((_1_),\\<Up>id,(_Exit_))]\\<rightarrow>*\n      (_Exit_)\""], ["proof (prove)\nusing this:\n  ?V:=?e \\<turnstile> (_ 0 _) -\\<Up>\\<lambda>s. s\n (?V := interpret ?e s)\\<rightarrow> (_ 1 _)\n  While_CFG.path (V:=e) (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))] (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (V:=e) (_ l _)\n     [((_ l _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ 1 _)),\n      ((_ 1 _), \\<Up>id, (_Exit_))]\n     (_Exit_)", "by(fastforce intro:While_CFG.path.intros simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (V:=e) (_ l _)\n   [((_ l _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n 2. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "with \\<open>V:=e \\<turnstile> (_Entry_) -[((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_ l _))]\\<rightarrow>* (_ l _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (V:=e) (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ l _))] (_ l _)\n  While_CFG.path (V:=e) (_ l _)\n   [((_ l _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)", "show ?case"], ["proof (prove)\nusing this:\n  While_CFG.path (V:=e) (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ l _))] (_ l _)\n  While_CFG.path (V:=e) (_ l _)\n   [((_ l _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "assume [simp]:\"l = 1\""], ["proof (state)\nthis:\n  l = 1\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "hence \"V:=e \\<turnstile> (_ l _) -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\nusing this:\n  l = 1\n\ngoal (1 subgoal):\n 1. V:=e \\<turnstile> (_ l _) -\\<Up>id\\<rightarrow> (_Exit_)", "by(simp add:WCFG_LAssSkip)"], ["proof (state)\nthis:\n  V:=e \\<turnstile> (_ l _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "hence \"V:=e \\<turnstile> (_ l _) -[((_ l _),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  V:=e \\<turnstile> (_ l _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (V:=e) (_ l _) [((_ l _), \\<Up>id, (_Exit_))] (_Exit_)", "by(fastforce intro:While_CFG.path.intros simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (V:=e) (_ l _) [((_ l _), \\<Up>id, (_Exit_))] (_Exit_)\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "have \"V:=e \\<turnstile> (_0_) -\\<Up>(\\<lambda>s. s(V:=(interpret e s)))\\<rightarrow> (_ l _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V:=e \\<turnstile> (_ 0 _) -\\<Up>\\<lambda>s. s\n (V := interpret e s)\\<rightarrow> (_ l _)", "by(simp add:WCFG_LAss)"], ["proof (state)\nthis:\n  V:=e \\<turnstile> (_ 0 _) -\\<Up>\\<lambda>s. s\n                                     (V :=\n  interpret e s)\\<rightarrow> (_ l _)\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "hence \"V:=e \\<turnstile> (_0_) -[((_0_),\\<Up>(\\<lambda>s. s(V:=(interpret e s))),(_ l _))]\\<rightarrow>* (_ l _)\""], ["proof (prove)\nusing this:\n  V:=e \\<turnstile> (_ 0 _) -\\<Up>\\<lambda>s. s\n                                     (V :=\n  interpret e s)\\<rightarrow> (_ l _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (V:=e) (_ 0 _)\n     [((_ 0 _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ l _))] (_ l _)", "by(fastforce intro:While_CFG.path.intros simp:valid_edge_def While_CFG.valid_node_def)"], ["proof (state)\nthis:\n  While_CFG.path (V:=e) (_ 0 _)\n   [((_ 0 _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ l _))] (_ l _)\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "with WCFG_Entry[of \"V:=e\"]"], ["proof (chain)\npicking this:\n  V:=e \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (V:=e) (_ 0 _)\n   [((_ 0 _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ l _))] (_ l _)", "have \"V:=e \\<turnstile> (_Entry_) -[((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))\n      ,((_0_),\\<Up>(\\<lambda>s. s(V:=(interpret e s))),(_ l _))]\\<rightarrow>* (_ l _)\""], ["proof (prove)\nusing this:\n  V:=e \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (V:=e) (_ 0 _)\n   [((_ 0 _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ l _))] (_ l _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (V:=e) (_Entry_)\n     [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)),\n      ((_ 0 _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ l _))]\n     (_ l _)", "by(fastforce intro:While_CFG.path.intros simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (V:=e) (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)),\n    ((_ 0 _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ l _))]\n   (_ l _)\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "with \\<open>V:=e \\<turnstile> (_ l _) -[((_ l _),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (V:=e) (_ l _) [((_ l _), \\<Up>id, (_Exit_))] (_Exit_)\n  While_CFG.path (V:=e) (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)),\n    ((_ 0 _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ l _))]\n   (_ l _)", "show ?case"], ["proof (prove)\nusing this:\n  While_CFG.path (V:=e) (_ l _) [((_ l _), \\<Up>id, (_Exit_))] (_Exit_)\n  While_CFG.path (V:=e) (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)),\n    ((_ 0 _), \\<Up>\\<lambda>s. s(V := interpret e s), (_ l _))]\n   (_ l _)\n\ngoal (1 subgoal):\n 1. (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (V:=e) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (V:=e) (_Entry_) as (_ l _))\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 2. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 3. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 2. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 3. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "case (Seq prog1 prog2)"], ["proof (state)\nthis:\n  ?l < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog1 (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ ?l _))\n  ?l < #:prog2 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog2 (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ ?l _))\n  l < #:prog1;; prog2\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 2. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 3. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "note IH1 = \\<open>\\<And>l. l < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. prog1 \\<turnstile> (_ l _) -as\\<rightarrow>* (_Exit_)) \\<and> (\\<exists>as. prog1 \\<turnstile> (_Entry_) -as\\<rightarrow>* (_ l _))\\<close>"], ["proof (state)\nthis:\n  ?l < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog1 (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ ?l _))\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 2. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 3. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "note IH2 = \\<open>\\<And>l. l < #:prog2 \\<Longrightarrow>\n  (\\<exists>as. prog2 \\<turnstile> (_ l _) -as\\<rightarrow>* (_Exit_)) \\<and> (\\<exists>as. prog2 \\<turnstile> (_Entry_) -as\\<rightarrow>* (_ l _))\\<close>"], ["proof (state)\nthis:\n  ?l < #:prog2 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog2 (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ ?l _))\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:prog1;; prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (prog1;; prog2) (_Entry_) as\n                              (_ l _))\n 2. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 3. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "proof(cases \"l < #:prog1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "case True"], ["proof (state)\nthis:\n  l < #:prog1\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from IH1[OF True]"], ["proof (chain)\npicking this:\n  (\\<exists>as. While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _))", "obtain as as' where \"prog1 \\<turnstile> (_ l _) -as\\<rightarrow>* (_Exit_)\"\n      and \"prog1 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l _)\""], ["proof (prove)\nusing this:\n  (\\<exists>as. While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>While_CFG.path prog1 (_ l _) as (_Exit_);\n         While_CFG.path prog1 (_Entry_) as' (_ l _)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_ l _) as (_Exit_)\n  While_CFG.path prog1 (_Entry_) as' (_ l _)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from \\<open>prog1 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (_Entry_) as' (_ l _)", "have \"prog1;;prog2 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_Entry_) as' (_ l _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (_Entry_) as' (_ l _)", "by(fastforce intro:path_SeqFirst)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (_Entry_) as' (_ l _)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from \\<open>prog1 \\<turnstile> (_ l _) -as\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (_ l _) as (_Exit_)", "obtain asx ax where \"prog1 \\<turnstile> (_ l _) -asx@[ax]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_ l _) as (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax.\n        While_CFG.path prog1 (_ l _) (asx @ [ax]) (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(induct rule:rev_induct,auto elim:While_CFG.path.cases)"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_ l _) (asx @ [ax]) (_Exit_)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "hence \"prog1 \\<turnstile> (_ l _) -asx\\<rightarrow>* sourcenode ax\"\n      and \"valid_edge prog1 ax\" and \"(_Exit_) = targetnode ax\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_ l _) (asx @ [ax]) (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path prog1 (_ l _) asx (sourcenode ax) &&&\n    valid_edge prog1 ax &&& (_Exit_) = targetnode ax", "by(auto intro:While_CFG.path_split_snoc)"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_ l _) asx (sourcenode ax)\n  valid_edge prog1 ax\n  (_Exit_) = targetnode ax\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from \\<open>prog1 \\<turnstile> (_ l _) -asx\\<rightarrow>* sourcenode ax\\<close> \\<open>valid_edge prog1 ax\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (_ l _) asx (sourcenode ax)\n  valid_edge prog1 ax", "obtain lx where [simp]:\"sourcenode ax = (_ lx _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_ l _) asx (sourcenode ax)\n  valid_edge prog1 ax\n\ngoal (1 subgoal):\n 1. (\\<And>lx.\n        sourcenode ax = (_ lx _) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"sourcenode ax\") auto"], ["proof (state)\nthis:\n  sourcenode ax = (_ lx _)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "with \\<open>prog1 \\<turnstile> (_ l _) -asx\\<rightarrow>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (_ l _) asx (sourcenode ax)\n  sourcenode ax = (_ lx _)", "have \"prog1;;prog2 \\<turnstile> (_ l _) -asx\\<rightarrow>* sourcenode ax\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_ l _) asx (sourcenode ax)\n  sourcenode ax = (_ lx _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (_ l _) asx (sourcenode ax)", "by(fastforce intro:path_SeqFirst)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (_ l _) asx (sourcenode ax)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from \\<open>valid_edge prog1 ax\\<close> \\<open>(_Exit_) = targetnode ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog1 ax\n  (_Exit_) = targetnode ax", "have \"prog1;;prog2 \\<turnstile> sourcenode ax -kind ax\\<rightarrow> (_0_) \\<oplus> #:prog1\""], ["proof (prove)\nusing this:\n  valid_edge prog1 ax\n  (_Exit_) = targetnode ax\n\ngoal (1 subgoal):\n 1. prog1;;\n    prog2 \\<turnstile> sourcenode\n                        ax -kind ax\\<rightarrow> (_ 0 _) \\<oplus> #:prog1", "by(fastforce intro:WCFG_SeqConnect simp:valid_edge_def)"], ["proof (state)\nthis:\n  prog1;;\n  prog2 \\<turnstile> sourcenode\n                      ax -kind ax\\<rightarrow> (_ 0 _) \\<oplus> #:prog1\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "hence \"prog1;;prog2 \\<turnstile> sourcenode ax -[(sourcenode ax,kind ax,(_0_) \\<oplus> #:prog1)]\\<rightarrow>*\n                          (_0_) \\<oplus> #:prog1\""], ["proof (prove)\nusing this:\n  prog1;;\n  prog2 \\<turnstile> sourcenode\n                      ax -kind ax\\<rightarrow> (_ 0 _) \\<oplus> #:prog1\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (sourcenode ax)\n     [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)]\n     ((_ 0 _) \\<oplus> #:prog1)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path \n                  simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (sourcenode ax)\n   [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)]\n   ((_ 0 _) \\<oplus> #:prog1)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "with \\<open>prog1;;prog2 \\<turnstile> (_ l _) -asx\\<rightarrow>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (prog1;; prog2) (_ l _) asx (sourcenode ax)\n  While_CFG.path (prog1;; prog2) (sourcenode ax)\n   [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)]\n   ((_ 0 _) \\<oplus> #:prog1)", "have \"prog1;;prog2 \\<turnstile> (_ l _) -asx@[(sourcenode ax,kind ax,(_0_) \\<oplus> #:prog1)]\\<rightarrow>*\n                         (_0_) \\<oplus> #:prog1\""], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) (_ l _) asx (sourcenode ax)\n  While_CFG.path (prog1;; prog2) (sourcenode ax)\n   [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)]\n   ((_ 0 _) \\<oplus> #:prog1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (_ l _)\n     (asx @ [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)])\n     ((_ 0 _) \\<oplus> #:prog1)", "by(fastforce intro:While_CFG.path_Append)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (_ l _)\n   (asx @ [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)])\n   ((_ 0 _) \\<oplus> #:prog1)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from IH2[of \"0\"]"], ["proof (chain)\npicking this:\n  0 < #:prog2 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog2 (_ 0 _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ 0 _))", "obtain as'' where \"prog2 \\<turnstile> (_ 0 _) -as''\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  0 < #:prog2 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog2 (_ 0 _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ 0 _))\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        While_CFG.path prog2 (_ 0 _) as'' (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFG.path prog2 (_ 0 _) as'' (_Exit_)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "hence \"prog1;;prog2 \\<turnstile> (_0_) \\<oplus> #:prog1 -as'' \\<oplus>s #:prog1\\<rightarrow>* (_Exit_) \\<oplus> #:prog1\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (_ 0 _) as'' (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n     (as'' \\<oplus>s #:prog1) ((_Exit_) \\<oplus> #:prog1)", "by(fastforce intro!:path_SeqSecond elim:While_CFG.path.cases)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (as'' \\<oplus>s #:prog1) ((_Exit_) \\<oplus> #:prog1)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "hence \"prog1;;prog2 \\<turnstile> (_0_) \\<oplus> #:prog1 -as'' \\<oplus>s #:prog1\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (as'' \\<oplus>s #:prog1) ((_Exit_) \\<oplus> #:prog1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n     (as'' \\<oplus>s #:prog1) (_Exit_)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (as'' \\<oplus>s #:prog1) (_Exit_)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "with \\<open>prog1;;prog2 \\<turnstile> (_ l _) -asx@[(sourcenode ax,kind ax,(_0_) \\<oplus> #:prog1)]\\<rightarrow>*\n                         (_0_) \\<oplus> #:prog1\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (prog1;; prog2) (_ l _)\n   (asx @ [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)])\n   ((_ 0 _) \\<oplus> #:prog1)\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (as'' \\<oplus>s #:prog1) (_Exit_)", "have \"prog1;;prog2 \\<turnstile> (_ l _) -(asx@[(sourcenode ax,kind ax,(_0_) \\<oplus> #:prog1)])@\n                                  (as'' \\<oplus>s #:prog1)\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) (_ l _)\n   (asx @ [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)])\n   ((_ 0 _) \\<oplus> #:prog1)\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (as'' \\<oplus>s #:prog1) (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (_ l _)\n     ((asx @ [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)]) @\n      (as'' \\<oplus>s #:prog1))\n     (_Exit_)", "by(fastforce intro:While_CFG.path_Append)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (_ l _)\n   ((asx @ [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)]) @\n    (as'' \\<oplus>s #:prog1))\n   (_Exit_)\n\ngoal (2 subgoals):\n 1. l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n 2. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "with \\<open>prog1;;prog2 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (prog1;; prog2) (_Entry_) as' (_ l _)\n  While_CFG.path (prog1;; prog2) (_ l _)\n   ((asx @ [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)]) @\n    (as'' \\<oplus>s #:prog1))\n   (_Exit_)", "show ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) (_Entry_) as' (_ l _)\n  While_CFG.path (prog1;; prog2) (_ l _)\n   ((asx @ [(sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1)]) @\n    (as'' \\<oplus>s #:prog1))\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "case False"], ["proof (state)\nthis:\n  \\<not> l < #:prog1\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "hence \"#:prog1 \\<le> l\""], ["proof (prove)\nusing this:\n  \\<not> l < #:prog1\n\ngoal (1 subgoal):\n 1. #:prog1 \\<le> l", "by simp"], ["proof (state)\nthis:\n  #:prog1 \\<le> l\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "then"], ["proof (chain)\npicking this:\n  #:prog1 \\<le> l", "obtain l' where [simp]:\"l = l' + #:prog1\" and \"l' = l - #:prog1\""], ["proof (prove)\nusing this:\n  #:prog1 \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l = l' + #:prog1; l' = l - #:prog1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  l = l' + #:prog1\n  l' = l - #:prog1\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from \\<open>l < #:prog1;; prog2\\<close>"], ["proof (chain)\npicking this:\n  l < #:prog1;; prog2", "have \"l' < #:prog2\""], ["proof (prove)\nusing this:\n  l < #:prog1;; prog2\n\ngoal (1 subgoal):\n 1. l' < #:prog2", "by simp"], ["proof (state)\nthis:\n  l' < #:prog2\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  (\\<exists>as. While_CFG.path prog2 (_ l' _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l' _))", "obtain as as' where \"prog2 \\<turnstile> (_ l' _) -as\\<rightarrow>* (_Exit_)\"\n      and \"prog2 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l' _)\""], ["proof (prove)\nusing this:\n  (\\<exists>as. While_CFG.path prog2 (_ l' _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l' _))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>While_CFG.path prog2 (_ l' _) as (_Exit_);\n         While_CFG.path prog2 (_Entry_) as' (_ l' _)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFG.path prog2 (_ l' _) as (_Exit_)\n  While_CFG.path prog2 (_Entry_) as' (_ l' _)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from \\<open>prog2 \\<turnstile> (_ l' _) -as\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog2 (_ l' _) as (_Exit_)", "have \"prog1;;prog2 \\<turnstile> (_ l' _) \\<oplus> #:prog1 -as \\<oplus>s #:prog1\\<rightarrow>* (_Exit_) \\<oplus> #:prog1\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (_ l' _) as (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) ((_ l' _) \\<oplus> #:prog1)\n     (as \\<oplus>s #:prog1) ((_Exit_) \\<oplus> #:prog1)", "by(fastforce intro!:path_SeqSecond elim:While_CFG.path.cases)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) ((_ l' _) \\<oplus> #:prog1)\n   (as \\<oplus>s #:prog1) ((_Exit_) \\<oplus> #:prog1)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "hence \"prog1;;prog2 \\<turnstile> (_ l _) -as \\<oplus>s #:prog1\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) ((_ l' _) \\<oplus> #:prog1)\n   (as \\<oplus>s #:prog1) ((_Exit_) \\<oplus> #:prog1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (_ l _) (as \\<oplus>s #:prog1) (_Exit_)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (_ l _) (as \\<oplus>s #:prog1) (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from IH1[of 0]"], ["proof (chain)\npicking this:\n  0 < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog1 (_ 0 _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ 0 _))", "obtain as'' where \"prog1 \\<turnstile> (_0_) -as''\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  0 < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog1 (_ 0 _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ 0 _))\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        While_CFG.path prog1 (_ 0 _) as'' (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_ 0 _) as'' (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "then"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (_ 0 _) as'' (_Exit_)", "obtain ax asx where \"prog1 \\<turnstile> (_0_) -asx@[ax]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_ 0 _) as'' (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax.\n        While_CFG.path prog1 (_ 0 _) (asx @ [ax]) (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(induct rule:rev_induct,auto elim:While_CFG.path.cases)"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_ 0 _) (asx @ [ax]) (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "hence \"prog1 \\<turnstile> (_0_) -asx\\<rightarrow>* sourcenode ax\" and \"valid_edge prog1 ax\"\n      and \"(_Exit_) = targetnode ax\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_ 0 _) (asx @ [ax]) (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path prog1 (_ 0 _) asx (sourcenode ax) &&&\n    valid_edge prog1 ax &&& (_Exit_) = targetnode ax", "by(auto intro:While_CFG.path_split_snoc)"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_ 0 _) asx (sourcenode ax)\n  valid_edge prog1 ax\n  (_Exit_) = targetnode ax\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from WCFG_Entry \\<open>prog1 \\<turnstile> (_0_) -asx\\<rightarrow>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  ?prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                    True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path prog1 (_ 0 _) asx (sourcenode ax)", "have \"prog1 \\<turnstile> (_Entry_) -((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))#asx\\<rightarrow>* sourcenode ax\""], ["proof (prove)\nusing this:\n  ?prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                    True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path prog1 (_ 0 _) asx (sourcenode ax)\n\ngoal (1 subgoal):\n 1. While_CFG.path prog1 (_Entry_)\n     (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx)\n     (sourcenode ax)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def valid_node_def)"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx)\n   (sourcenode ax)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from \\<open>prog1 \\<turnstile> (_0_) -asx\\<rightarrow>* sourcenode ax\\<close> \\<open>valid_edge prog1 ax\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (_ 0 _) asx (sourcenode ax)\n  valid_edge prog1 ax", "obtain lx where [simp]:\"sourcenode ax = (_ lx _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_ 0 _) asx (sourcenode ax)\n  valid_edge prog1 ax\n\ngoal (1 subgoal):\n 1. (\\<And>lx.\n        sourcenode ax = (_ lx _) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"sourcenode ax\") auto"], ["proof (state)\nthis:\n  sourcenode ax = (_ lx _)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "with \\<open>prog1 \\<turnstile> (_Entry_) -((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))#asx\\<rightarrow>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx)\n   (sourcenode ax)\n  sourcenode ax = (_ lx _)", "have \"prog1;;prog2 \\<turnstile> (_Entry_) -((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))#asx\\<rightarrow>* \n                         sourcenode ax\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx)\n   (sourcenode ax)\n  sourcenode ax = (_ lx _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (_Entry_)\n     (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx)\n     (sourcenode ax)", "by(fastforce intro:path_SeqFirst)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx)\n   (sourcenode ax)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from \\<open>prog2 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l' _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog2 (_Entry_) as' (_ l' _)", "obtain ax' asx' \n      where \"prog2 \\<turnstile> (_Entry_) -ax'#asx'\\<rightarrow>* (_ l' _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (_Entry_) as' (_ l' _)\n\ngoal (1 subgoal):\n 1. (\\<And>ax' asx'.\n        While_CFG.path prog2 (_Entry_) (ax' # asx')\n         (_ l' _) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases as',auto elim:While_CFG.path.cases)"], ["proof (state)\nthis:\n  While_CFG.path prog2 (_Entry_) (ax' # asx') (_ l' _)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "hence \"(_Entry_) = sourcenode ax'\" and \"valid_edge prog2 ax'\"\n      and \"prog2 \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (_ l' _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (_Entry_) (ax' # asx') (_ l' _)\n\ngoal (1 subgoal):\n 1. (_Entry_) = sourcenode ax' &&&\n    valid_edge prog2 ax' &&&\n    While_CFG.path prog2 (targetnode ax') asx' (_ l' _)", "by(auto intro:While_CFG.path_split_Cons)"], ["proof (state)\nthis:\n  (_Entry_) = sourcenode ax'\n  valid_edge prog2 ax'\n  While_CFG.path prog2 (targetnode ax') asx' (_ l' _)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "hence \"targetnode ax' = (_0_)\""], ["proof (prove)\nusing this:\n  (_Entry_) = sourcenode ax'\n  valid_edge prog2 ax'\n  While_CFG.path prog2 (targetnode ax') asx' (_ l' _)\n\ngoal (1 subgoal):\n 1. targetnode ax' = (_ 0 _)", "by(fastforce dest:WCFG_EntryD simp:valid_edge_def)"], ["proof (state)\nthis:\n  targetnode ax' = (_ 0 _)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "from \\<open>valid_edge prog1 ax\\<close> \\<open>(_Exit_) = targetnode ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog1 ax\n  (_Exit_) = targetnode ax", "have \"prog1;;prog2 \\<turnstile> sourcenode ax -kind ax\\<rightarrow> (_0_) \\<oplus> #:prog1\""], ["proof (prove)\nusing this:\n  valid_edge prog1 ax\n  (_Exit_) = targetnode ax\n\ngoal (1 subgoal):\n 1. prog1;;\n    prog2 \\<turnstile> sourcenode\n                        ax -kind ax\\<rightarrow> (_ 0 _) \\<oplus> #:prog1", "by(fastforce intro:WCFG_SeqConnect simp:valid_edge_def)"], ["proof (state)\nthis:\n  prog1;;\n  prog2 \\<turnstile> sourcenode\n                      ax -kind ax\\<rightarrow> (_ 0 _) \\<oplus> #:prog1\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "have \"\\<exists>as. prog1;;prog2 \\<turnstile> sourcenode ax -as\\<rightarrow>* (_ l _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "proof(cases \"asx' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)\n 2. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "case True"], ["proof (state)\nthis:\n  asx' = []\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)\n 2. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "with \\<open>prog2 \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (_ l' _)\\<close> \\<open>targetnode ax' = (_0_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog2 (targetnode ax') asx' (_ l' _)\n  targetnode ax' = (_ 0 _)\n  asx' = []", "have \"l' = 0\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (targetnode ax') asx' (_ l' _)\n  targetnode ax' = (_ 0 _)\n  asx' = []\n\ngoal (1 subgoal):\n 1. l' = 0", "by(auto elim:While_CFG.path.cases)"], ["proof (state)\nthis:\n  l' = 0\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)\n 2. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "with \\<open>prog1;;prog2 \\<turnstile> sourcenode ax -kind ax\\<rightarrow> (_0_) \\<oplus> #:prog1\\<close>"], ["proof (chain)\npicking this:\n  prog1;;\n  prog2 \\<turnstile> sourcenode\n                      ax -kind ax\\<rightarrow> (_ 0 _) \\<oplus> #:prog1\n  l' = 0", "have \"prog1;;prog2 \\<turnstile> sourcenode ax -[(sourcenode ax,kind ax,(_ l _))]\\<rightarrow>* \n                           (_ l _)\""], ["proof (prove)\nusing this:\n  prog1;;\n  prog2 \\<turnstile> sourcenode\n                      ax -kind ax\\<rightarrow> (_ 0 _) \\<oplus> #:prog1\n  l' = 0\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (sourcenode ax)\n     [(sourcenode ax, kind ax, (_ l _))] (_ l _)", "by(auto intro!:While_CFG.path.intros \n                    simp:While_CFG.valid_node_def valid_edge_def,blast)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (sourcenode ax)\n   [(sourcenode ax, kind ax, (_ l _))] (_ l _)\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)\n 2. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "thus ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) (sourcenode ax)\n   [(sourcenode ax, kind ax, (_ l _))] (_ l _)\n\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)\n\ngoal (1 subgoal):\n 1. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "case False"], ["proof (state)\nthis:\n  asx' \\<noteq> []\n\ngoal (1 subgoal):\n 1. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "with \\<open>prog2 \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (_ l' _)\\<close> \\<open>targetnode ax' = (_0_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog2 (targetnode ax') asx' (_ l' _)\n  targetnode ax' = (_ 0 _)\n  asx' \\<noteq> []", "have \"prog1;;prog2 \\<turnstile> (_0_) \\<oplus> #:prog1 -asx' \\<oplus>s #:prog1\\<rightarrow>* (_ l' _) \\<oplus> #:prog1\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (targetnode ax') asx' (_ l' _)\n  targetnode ax' = (_ 0 _)\n  asx' \\<noteq> []\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n     (asx' \\<oplus>s #:prog1) ((_ l' _) \\<oplus> #:prog1)", "by(fastforce intro:path_SeqSecond)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (asx' \\<oplus>s #:prog1) ((_ l' _) \\<oplus> #:prog1)\n\ngoal (1 subgoal):\n 1. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "hence \"prog1;;prog2 \\<turnstile> (_0_) \\<oplus> #:prog1 -asx' \\<oplus>s #:prog1\\<rightarrow>* (_ l _)\""], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (asx' \\<oplus>s #:prog1) ((_ l' _) \\<oplus> #:prog1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n     (asx' \\<oplus>s #:prog1) (_ l _)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (asx' \\<oplus>s #:prog1) (_ l _)\n\ngoal (1 subgoal):\n 1. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "with \\<open>prog1;;prog2 \\<turnstile> sourcenode ax -kind ax\\<rightarrow> (_0_) \\<oplus> #:prog1\\<close>"], ["proof (chain)\npicking this:\n  prog1;;\n  prog2 \\<turnstile> sourcenode\n                      ax -kind ax\\<rightarrow> (_ 0 _) \\<oplus> #:prog1\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (asx' \\<oplus>s #:prog1) (_ l _)", "have \"prog1;;prog2 \\<turnstile> sourcenode ax -(sourcenode ax,kind ax,(_0_) \\<oplus> #:prog1)#\n                                          (asx' \\<oplus>s #:prog1)\\<rightarrow>* (_ l _)\""], ["proof (prove)\nusing this:\n  prog1;;\n  prog2 \\<turnstile> sourcenode\n                      ax -kind ax\\<rightarrow> (_ 0 _) \\<oplus> #:prog1\n  While_CFG.path (prog1;; prog2) ((_ 0 _) \\<oplus> #:prog1)\n   (asx' \\<oplus>s #:prog1) (_ l _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (sourcenode ax)\n     ((sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1) #\n      (asx' \\<oplus>s #:prog1))\n     (_ l _)", "by(fastforce intro: While_CFG.Cons_path simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (sourcenode ax)\n   ((sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1) #\n    (asx' \\<oplus>s #:prog1))\n   (_ l _)\n\ngoal (1 subgoal):\n 1. asx' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "thus ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) (sourcenode ax)\n   ((sourcenode ax, kind ax, (_ 0 _) \\<oplus> #:prog1) #\n    (asx' \\<oplus>s #:prog1))\n   (_ l _)\n\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "then"], ["proof (chain)\npicking this:\n  \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)", "obtain asx'' where \"prog1;;prog2 \\<turnstile> sourcenode ax -asx''\\<rightarrow>* (_ l _)\""], ["proof (prove)\nusing this:\n  \\<exists>as. While_CFG.path (prog1;; prog2) (sourcenode ax) as (_ l _)\n\ngoal (1 subgoal):\n 1. (\\<And>asx''.\n        While_CFG.path (prog1;; prog2) (sourcenode ax) asx''\n         (_ l _) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (sourcenode ax) asx'' (_ l _)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "with \\<open>prog1;;prog2 \\<turnstile> (_Entry_) -((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))#asx\\<rightarrow>* \n                         sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (prog1;; prog2) (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx)\n   (sourcenode ax)\n  While_CFG.path (prog1;; prog2) (sourcenode ax) asx'' (_ l _)", "have \"prog1;;prog2 \\<turnstile> (_Entry_) -(((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))#asx)@asx''\\<rightarrow>* \n                         (_ l _)\""], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx)\n   (sourcenode ax)\n  While_CFG.path (prog1;; prog2) (sourcenode ax) asx'' (_ l _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (prog1;; prog2) (_Entry_)\n     ((((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx) @\n      asx'')\n     (_ l _)", "by(rule While_CFG.path_Append)"], ["proof (state)\nthis:\n  While_CFG.path (prog1;; prog2) (_Entry_)\n   ((((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx) @ asx'')\n   (_ l _)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:prog1 \\<Longrightarrow>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "with \\<open>prog1;;prog2 \\<turnstile> (_ l _) -as \\<oplus>s #:prog1\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (prog1;; prog2) (_ l _) (as \\<oplus>s #:prog1) (_Exit_)\n  While_CFG.path (prog1;; prog2) (_Entry_)\n   ((((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx) @ asx'')\n   (_ l _)", "show ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (prog1;; prog2) (_ l _) (as \\<oplus>s #:prog1) (_Exit_)\n  While_CFG.path (prog1;; prog2) (_Entry_)\n   ((((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) # asx) @ asx'')\n   (_ l _)\n\ngoal (1 subgoal):\n 1. (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (prog1;; prog2) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (prog1;; prog2) (_Entry_) as (_ l _))\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 2. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 2. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "case (Cond b prog1 prog2)"], ["proof (state)\nthis:\n  ?l < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog1 (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ ?l _))\n  ?l < #:prog2 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog2 (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ ?l _))\n  l < #:if (b) prog1 else prog2\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 2. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "note IH1 = \\<open>\\<And>l. l < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. prog1 \\<turnstile> (_ l _) -as\\<rightarrow>* (_Exit_)) \\<and> (\\<exists>as. prog1 \\<turnstile> (_Entry_) -as\\<rightarrow>* (_ l _))\\<close>"], ["proof (state)\nthis:\n  ?l < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog1 (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ ?l _))\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 2. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "note IH2 = \\<open>\\<And>l. l < #:prog2 \\<Longrightarrow>\n  (\\<exists>as. prog2 \\<turnstile> (_ l _) -as\\<rightarrow>* (_Exit_)) \\<and> (\\<exists>as. prog2 \\<turnstile> (_Entry_) -as\\<rightarrow>* (_ l _))\\<close>"], ["proof (state)\nthis:\n  ?l < #:prog2 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog2 (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ ?l _))\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog1 \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog1 (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l _));\n        \\<And>l.\n           l < #:prog2 \\<Longrightarrow>\n           (\\<exists>as. While_CFG.path prog2 (_ l _) as (_Exit_)) \\<and>\n           (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l _));\n        l < #:if (x1) prog1 else prog2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_ l _) as (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (if (x1) prog1 else prog2)\n                              (_Entry_) as (_ l _))\n 2. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "proof(cases \"l = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "case True"], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "from IH1[of 0]"], ["proof (chain)\npicking this:\n  0 < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog1 (_ 0 _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ 0 _))", "obtain as where \"prog1 \\<turnstile> (_0_) -as\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  0 < #:prog1 \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog1 (_ 0 _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ 0 _))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        While_CFG.path prog1 (_ 0 _) as (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_ 0 _) as (_Exit_)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "hence \"if (b) prog1 else prog2 \\<turnstile> (_0_) \\<oplus> 1 -as \\<oplus>s 1\\<rightarrow>* (_Exit_) \\<oplus> 1\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_ 0 _) as (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> 1)\n     (as \\<oplus>s 1) ((_Exit_) \\<oplus> 1)", "by(fastforce intro:path_CondTrue)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> 1)\n   (as \\<oplus>s 1) ((_Exit_) \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with WCFG_CondTrue[of b prog1 prog2]"], ["proof (chain)\npicking this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n interpret b s = Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 1\n  While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> 1)\n   (as \\<oplus>s 1) ((_Exit_) \\<oplus> 1)", "have \"if (b) prog1 else prog2 \\<turnstile> \n      (_0_) -((_0_),(\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,(_0_) \\<oplus> 1)#(as \\<oplus>s 1)\\<rightarrow>* \n      (_Exit_) \\<oplus> 1\""], ["proof (prove)\nusing this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n interpret b s = Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 1\n  While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> 1)\n   (as \\<oplus>s 1) ((_Exit_) \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n     (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n       (_ 0 _) \\<oplus> 1) #\n      (as \\<oplus>s 1))\n     ((_Exit_) \\<oplus> 1)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def valid_node_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (as \\<oplus>s 1))\n   ((_Exit_) \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with True"], ["proof (chain)\npicking this:\n  l = 0\n  While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (as \\<oplus>s 1))\n   ((_Exit_) \\<oplus> 1)", "have \"if (b) prog1 else prog2 \\<turnstile> \n      (_ l _) -((_0_),(\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,(_0_) \\<oplus> 1)#(as \\<oplus>s 1)\\<rightarrow>*\n      (_Exit_)\""], ["proof (prove)\nusing this:\n  l = 0\n  While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (as \\<oplus>s 1))\n   ((_Exit_) \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) (_ l _)\n     (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n       (_ 0 _) \\<oplus> 1) #\n      (as \\<oplus>s 1))\n     (_Exit_)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (as \\<oplus>s 1))\n   (_Exit_)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "moreover"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (as \\<oplus>s 1))\n   (_Exit_)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "from WCFG_Entry[of \"if (b) prog1 else prog2\"] True"], ["proof (chain)\npicking this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_Entry_) -(\\<lambda>s.\n   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  l = 0", "have \"if (b) prog1 else prog2 \\<turnstile> (_Entry_) -[((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))]\\<rightarrow>* \n                                    (_ l _)\""], ["proof (prove)\nusing this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_Entry_) -(\\<lambda>s.\n   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  l = 0\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n     [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _))] (_ l _)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                  simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _))] (_ l _)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "ultimately"], ["proof (chain)\npicking this:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (as \\<oplus>s 1))\n   (_Exit_)\n  While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _))] (_ l _)", "show ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (as \\<oplus>s 1))\n   (_Exit_)\n  While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _))] (_ l _)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "case False"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "hence \"0 < l\""], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < l", "by simp"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "then"], ["proof (chain)\npicking this:\n  0 < l", "obtain l' where [simp]:\"l = l' + 1\" and \"l' = l - 1\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l = l' + 1; l' = l - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  l = l' + 1\n  l' = l - 1\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "proof(cases \"l' < #:prog1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "case True"], ["proof (state)\nthis:\n  l' < #:prog1\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "from IH1[OF this]"], ["proof (chain)\npicking this:\n  (\\<exists>as. While_CFG.path prog1 (_ l' _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l' _))", "obtain as as' where \"prog1 \\<turnstile> (_ l' _) -as\\<rightarrow>* (_Exit_)\"\n        and \"prog1 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l' _)\""], ["proof (prove)\nusing this:\n  (\\<exists>as. While_CFG.path prog1 (_ l' _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog1 (_Entry_) as (_ l' _))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>While_CFG.path prog1 (_ l' _) as (_Exit_);\n         While_CFG.path prog1 (_Entry_) as' (_ l' _)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_ l' _) as (_Exit_)\n  While_CFG.path prog1 (_Entry_) as' (_ l' _)\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "from \\<open>prog1 \\<turnstile> (_ l' _) -as\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (_ l' _) as (_Exit_)", "have \"if (b) prog1 else prog2 \\<turnstile> (_ l' _) \\<oplus> 1 -as \\<oplus>s 1\\<rightarrow>* (_Exit_) \\<oplus> 1\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_ l' _) as (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) ((_ l' _) \\<oplus> 1)\n     (as \\<oplus>s 1) ((_Exit_) \\<oplus> 1)", "by(fastforce intro:path_CondTrue)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) ((_ l' _) \\<oplus> 1)\n   (as \\<oplus>s 1) ((_Exit_) \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "hence \"if (b) prog1 else prog2 \\<turnstile> (_ l _) -as \\<oplus>s 1\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path (if (b) prog1 else prog2) ((_ l' _) \\<oplus> 1)\n   (as \\<oplus>s 1) ((_Exit_) \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) (_ l _) (as \\<oplus>s 1)\n     (_Exit_)", "by simp"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _) (as \\<oplus>s 1) (_Exit_)\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "from \\<open>prog1 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l' _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (_Entry_) as' (_ l' _)", "obtain ax asx\n        where \"prog1 \\<turnstile> (_Entry_) -ax#asx\\<rightarrow>* (_ l' _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_Entry_) as' (_ l' _)\n\ngoal (1 subgoal):\n 1. (\\<And>ax asx.\n        While_CFG.path prog1 (_Entry_) (ax # asx) (_ l' _) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases as',auto elim:While_CFG.cases)"], ["proof (state)\nthis:\n  While_CFG.path prog1 (_Entry_) (ax # asx) (_ l' _)\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "hence \"(_Entry_) = sourcenode ax\" and \"valid_edge prog1 ax\"\n        and \"prog1 \\<turnstile> targetnode ax -asx\\<rightarrow>* (_ l' _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (_Entry_) (ax # asx) (_ l' _)\n\ngoal (1 subgoal):\n 1. (_Entry_) = sourcenode ax &&&\n    valid_edge prog1 ax &&&\n    While_CFG.path prog1 (targetnode ax) asx (_ l' _)", "by(auto intro:While_CFG.path_split_Cons)"], ["proof (state)\nthis:\n  (_Entry_) = sourcenode ax\n  valid_edge prog1 ax\n  While_CFG.path prog1 (targetnode ax) asx (_ l' _)\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "hence \"targetnode ax = (_0_)\""], ["proof (prove)\nusing this:\n  (_Entry_) = sourcenode ax\n  valid_edge prog1 ax\n  While_CFG.path prog1 (targetnode ax) asx (_ l' _)\n\ngoal (1 subgoal):\n 1. targetnode ax = (_ 0 _)", "by(fastforce dest:WCFG_EntryD simp:valid_edge_def)"], ["proof (state)\nthis:\n  targetnode ax = (_ 0 _)\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with \\<open>prog1 \\<turnstile> targetnode ax -asx\\<rightarrow>* (_ l' _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog1 (targetnode ax) asx (_ l' _)\n  targetnode ax = (_ 0 _)", "have \"if (b) prog1 else prog2 \\<turnstile> (_0_) \\<oplus> 1 -asx \\<oplus>s 1\\<rightarrow>* (_ l' _) \\<oplus> 1\""], ["proof (prove)\nusing this:\n  While_CFG.path prog1 (targetnode ax) asx (_ l' _)\n  targetnode ax = (_ 0 _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> 1)\n     (asx \\<oplus>s 1) ((_ l' _) \\<oplus> 1)", "by(fastforce intro:path_CondTrue)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> 1)\n   (asx \\<oplus>s 1) ((_ l' _) \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with WCFG_CondTrue[of b prog1 prog2]"], ["proof (chain)\npicking this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n interpret b s = Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 1\n  While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> 1)\n   (asx \\<oplus>s 1) ((_ l' _) \\<oplus> 1)", "have \"if (b) prog1 else prog2 \\<turnstile> (_0_) \n        -((_0_),(\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,(_0_) \\<oplus> 1)#(asx \\<oplus>s 1)\\<rightarrow>* \n         (_ l' _) \\<oplus> 1\""], ["proof (prove)\nusing this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n interpret b s = Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 1\n  While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> 1)\n   (asx \\<oplus>s 1) ((_ l' _) \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n     (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n       (_ 0 _) \\<oplus> 1) #\n      (asx \\<oplus>s 1))\n     ((_ l' _) \\<oplus> 1)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (asx \\<oplus>s 1))\n   ((_ l' _) \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with WCFG_Entry[of \"if (b) prog1 else prog2\"]"], ["proof (chain)\npicking this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_Entry_) -(\\<lambda>s.\n   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (asx \\<oplus>s 1))\n   ((_ l' _) \\<oplus> 1)", "have \"if (b) prog1 else prog2 \\<turnstile> (_Entry_) -((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))#\n        ((_0_),(\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,(_0_) \\<oplus> 1)#(asx \\<oplus>s 1)\\<rightarrow>* \n         (_ l' _) \\<oplus> 1\""], ["proof (prove)\nusing this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_Entry_) -(\\<lambda>s.\n   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (asx \\<oplus>s 1))\n   ((_ l' _) \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n     (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n      ((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n       (_ 0 _) \\<oplus> 1) #\n      (asx \\<oplus>s 1))\n     ((_ l' _) \\<oplus> 1)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (asx \\<oplus>s 1))\n   ((_ l' _) \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n 2. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with \\<open>if (b) prog1 else prog2 \\<turnstile> (_ l _) -as \\<oplus>s 1\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _) (as \\<oplus>s 1) (_Exit_)\n  While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (asx \\<oplus>s 1))\n   ((_ l' _) \\<oplus> 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _) (as \\<oplus>s 1) (_Exit_)\n  While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 1) #\n    (asx \\<oplus>s 1))\n   ((_ l' _) \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "by simp blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "case False"], ["proof (state)\nthis:\n  \\<not> l' < #:prog1\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "hence \"#:prog1 \\<le> l'\""], ["proof (prove)\nusing this:\n  \\<not> l' < #:prog1\n\ngoal (1 subgoal):\n 1. #:prog1 \\<le> l'", "by simp"], ["proof (state)\nthis:\n  #:prog1 \\<le> l'\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "then"], ["proof (chain)\npicking this:\n  #:prog1 \\<le> l'", "obtain l'' where [simp]:\"l' = l'' + #:prog1\" and \"l'' = l' - #:prog1\""], ["proof (prove)\nusing this:\n  #:prog1 \\<le> l'\n\ngoal (1 subgoal):\n 1. (\\<And>l''.\n        \\<lbrakk>l' = l'' + #:prog1; l'' = l' - #:prog1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  l' = l'' + #:prog1\n  l'' = l' - #:prog1\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "from  \\<open>l < #:(if (b) prog1 else prog2)\\<close>"], ["proof (chain)\npicking this:\n  l < #:if (b) prog1 else prog2", "have \"l'' < #:prog2\""], ["proof (prove)\nusing this:\n  l < #:if (b) prog1 else prog2\n\ngoal (1 subgoal):\n 1. l'' < #:prog2", "by simp"], ["proof (state)\nthis:\n  l'' < #:prog2\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  (\\<exists>as. While_CFG.path prog2 (_ l'' _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l'' _))", "obtain as as' where \"prog2 \\<turnstile> (_ l'' _) -as\\<rightarrow>* (_Exit_)\"\n        and \"prog2 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l'' _)\""], ["proof (prove)\nusing this:\n  (\\<exists>as. While_CFG.path prog2 (_ l'' _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog2 (_Entry_) as (_ l'' _))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>While_CFG.path prog2 (_ l'' _) as (_Exit_);\n         While_CFG.path prog2 (_Entry_) as' (_ l'' _)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFG.path prog2 (_ l'' _) as (_Exit_)\n  While_CFG.path prog2 (_Entry_) as' (_ l'' _)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "from \\<open>prog2 \\<turnstile> (_ l'' _) -as\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog2 (_ l'' _) as (_Exit_)", "have \"if (b) prog1 else prog2 \\<turnstile> (_ l'' _) \\<oplus> (#:prog1 + 1) \n        -as \\<oplus>s (#:prog1 + 1)\\<rightarrow>* (_Exit_) \\<oplus> (#:prog1 + 1)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (_ l'' _) as (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2)\n     ((_ l'' _) \\<oplus> #:prog1 + 1) (as \\<oplus>s #:prog1 + 1)\n     ((_Exit_) \\<oplus> #:prog1 + 1)", "by(fastforce intro:path_CondFalse)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) ((_ l'' _) \\<oplus> #:prog1 + 1)\n   (as \\<oplus>s #:prog1 + 1) ((_Exit_) \\<oplus> #:prog1 + 1)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "hence \"if (b) prog1 else prog2 \\<turnstile> (_ l _) -as \\<oplus>s (#:prog1 + 1)\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path (if (b) prog1 else prog2) ((_ l'' _) \\<oplus> #:prog1 + 1)\n   (as \\<oplus>s #:prog1 + 1) ((_Exit_) \\<oplus> #:prog1 + 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) (_ l _)\n     (as \\<oplus>s #:prog1 + 1) (_Exit_)", "by(simp add:add.assoc)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _)\n   (as \\<oplus>s #:prog1 + 1) (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "from \\<open>prog2 \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l'' _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog2 (_Entry_) as' (_ l'' _)", "obtain ax asx\n        where \"prog2 \\<turnstile> (_Entry_) -ax#asx\\<rightarrow>* (_ l'' _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (_Entry_) as' (_ l'' _)\n\ngoal (1 subgoal):\n 1. (\\<And>ax asx.\n        While_CFG.path prog2 (_Entry_) (ax # asx)\n         (_ l'' _) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases as',auto elim:While_CFG.cases)"], ["proof (state)\nthis:\n  While_CFG.path prog2 (_Entry_) (ax # asx) (_ l'' _)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "hence \"(_Entry_) = sourcenode ax\" and \"valid_edge prog2 ax\"\n        and \"prog2 \\<turnstile> targetnode ax -asx\\<rightarrow>* (_ l'' _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (_Entry_) (ax # asx) (_ l'' _)\n\ngoal (1 subgoal):\n 1. (_Entry_) = sourcenode ax &&&\n    valid_edge prog2 ax &&&\n    While_CFG.path prog2 (targetnode ax) asx (_ l'' _)", "by(auto intro:While_CFG.path_split_Cons)"], ["proof (state)\nthis:\n  (_Entry_) = sourcenode ax\n  valid_edge prog2 ax\n  While_CFG.path prog2 (targetnode ax) asx (_ l'' _)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "hence \"targetnode ax = (_0_)\""], ["proof (prove)\nusing this:\n  (_Entry_) = sourcenode ax\n  valid_edge prog2 ax\n  While_CFG.path prog2 (targetnode ax) asx (_ l'' _)\n\ngoal (1 subgoal):\n 1. targetnode ax = (_ 0 _)", "by(fastforce dest:WCFG_EntryD simp:valid_edge_def)"], ["proof (state)\nthis:\n  targetnode ax = (_ 0 _)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with \\<open>prog2 \\<turnstile> targetnode ax -asx\\<rightarrow>* (_ l'' _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog2 (targetnode ax) asx (_ l'' _)\n  targetnode ax = (_ 0 _)", "have \"if (b) prog1 else prog2 \\<turnstile> (_0_) \\<oplus> (#:prog1 + 1) -asx \\<oplus>s (#:prog1 + 1)\\<rightarrow>*\n        (_ l'' _) \\<oplus> (#:prog1 + 1)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog2 (targetnode ax) asx (_ l'' _)\n  targetnode ax = (_ 0 _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> #:prog1 + 1)\n     (asx \\<oplus>s #:prog1 + 1) ((_ l'' _) \\<oplus> #:prog1 + 1)", "by(fastforce intro:path_CondFalse)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> #:prog1 + 1)\n   (asx \\<oplus>s #:prog1 + 1) ((_ l'' _) \\<oplus> #:prog1 + 1)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with WCFG_CondFalse[of b prog1 prog2]"], ["proof (chain)\npicking this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n interpret b s =\n Some false)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> #:prog1 + 1\n  While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> #:prog1 + 1)\n   (asx \\<oplus>s #:prog1 + 1) ((_ l'' _) \\<oplus> #:prog1 + 1)", "have \"if (b) prog1 else prog2 \\<turnstile> (_0_) \n        -((_0_),(\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,(_0_) \\<oplus> (#:prog1 + 1))#\n        (asx \\<oplus>s  (#:prog1 + 1))\\<rightarrow>* (_ l'' _) \\<oplus>  (#:prog1 + 1)\""], ["proof (prove)\nusing this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_ 0 _) -(\\<lambda>s.\n interpret b s =\n Some false)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> #:prog1 + 1\n  While_CFG.path (if (b) prog1 else prog2) ((_ 0 _) \\<oplus> #:prog1 + 1)\n   (asx \\<oplus>s #:prog1 + 1) ((_ l'' _) \\<oplus> #:prog1 + 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n     (((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n       (_ 0 _) \\<oplus> #:prog1 + 1) #\n      (asx \\<oplus>s #:prog1 + 1))\n     ((_ l'' _) \\<oplus> #:prog1 + 1)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> #:prog1 + 1) #\n    (asx \\<oplus>s #:prog1 + 1))\n   ((_ l'' _) \\<oplus> #:prog1 + 1)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with WCFG_Entry[of \"if (b) prog1 else prog2\"]"], ["proof (chain)\npicking this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_Entry_) -(\\<lambda>s.\n   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> #:prog1 + 1) #\n    (asx \\<oplus>s #:prog1 + 1))\n   ((_ l'' _) \\<oplus> #:prog1 + 1)", "have \"if (b) prog1 else prog2 \\<turnstile> (_Entry_) -((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))#\n        ((_0_),(\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,(_0_) \\<oplus> (#:prog1 + 1))#\n        (asx \\<oplus>s (#:prog1 + 1))\\<rightarrow>* (_ l'' _) \\<oplus> (#:prog1 + 1)\""], ["proof (prove)\nusing this:\n  if (b) prog1\n  else prog2 \\<turnstile> (_Entry_) -(\\<lambda>s.\n   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (if (b) prog1 else prog2) (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> #:prog1 + 1) #\n    (asx \\<oplus>s #:prog1 + 1))\n   ((_ l'' _) \\<oplus> #:prog1 + 1)\n\ngoal (1 subgoal):\n 1. While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n     (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n      ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n       (_ 0 _) \\<oplus> #:prog1 + 1) #\n      (asx \\<oplus>s #:prog1 + 1))\n     ((_ l'' _) \\<oplus> #:prog1 + 1)", "by(fastforce intro:While_CFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> #:prog1 + 1) #\n    (asx \\<oplus>s #:prog1 + 1))\n   ((_ l'' _) \\<oplus> #:prog1 + 1)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:prog1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "with \n        \\<open>if (b) prog1 else prog2 \\<turnstile> (_ l _) -as \\<oplus>s (#:prog1 + 1)\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _)\n   (as \\<oplus>s #:prog1 + 1) (_Exit_)\n  While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> #:prog1 + 1) #\n    (asx \\<oplus>s #:prog1 + 1))\n   ((_ l'' _) \\<oplus> #:prog1 + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (if (b) prog1 else prog2) (_ l _)\n   (as \\<oplus>s #:prog1 + 1) (_Exit_)\n  While_CFG.path (if (b) prog1 else prog2) (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> #:prog1 + 1) #\n    (asx \\<oplus>s #:prog1 + 1))\n   ((_ l'' _) \\<oplus> #:prog1 + 1)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as.\n        While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))", "by(simp add:add.assoc,blast)"], ["proof (state)\nthis:\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as.\n      While_CFG.path (if (b) prog1 else prog2) (_Entry_) as (_ l _))\n\ngoal (1 subgoal):\n 1. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "case (While b prog')"], ["proof (state)\nthis:\n  ?l < #:prog' \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog' (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog' (_Entry_) as (_ ?l _))\n  l < #:while (b) prog'\n\ngoal (1 subgoal):\n 1. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "note IH = \\<open>\\<And>l. l < #:prog' \\<Longrightarrow>\n   (\\<exists>as. prog' \\<turnstile> (_ l _) -as\\<rightarrow>* (_Exit_)) \\<and> (\\<exists>as. prog' \\<turnstile> (_Entry_) -as\\<rightarrow>* (_ l _))\\<close>"], ["proof (state)\nthis:\n  ?l < #:prog' \\<Longrightarrow>\n  (\\<exists>as. While_CFG.path prog' (_ ?l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog' (_Entry_) as (_ ?l _))\n\ngoal (1 subgoal):\n 1. \\<And>x1 prog l.\n       \\<lbrakk>\\<And>l.\n                   l < #:prog \\<Longrightarrow>\n                   (\\<exists>as.\n                       While_CFG.path prog (_ l _) as (_Exit_)) \\<and>\n                   (\\<exists>as. While_CFG.path prog (_Entry_) as (_ l _));\n        l < #:while (x1) prog\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_ l _) as\n                              (_Exit_)) \\<and>\n                         (\\<exists>as.\n                             While_CFG.path (while (x1) prog) (_Entry_) as\n                              (_ l _))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "proof(cases \"l < 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n 2. \\<not> l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "case True"], ["proof (state)\nthis:\n  l < 1\n\ngoal (2 subgoals):\n 1. l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n 2. \\<not> l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "from WCFG_Entry[of \"while (b) prog'\"]"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_Entry_) -(\\<lambda>s.\n        True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)", "have \"while (b) prog' \\<turnstile> (_Entry_) -[((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))]\\<rightarrow>* (_0_)\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_Entry_) -(\\<lambda>s.\n        True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_Entry_)\n     [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _))] (_ 0 _)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                  simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _))] (_ 0 _)\n\ngoal (2 subgoals):\n 1. l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n 2. \\<not> l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "from WCFG_WhileFalseSkip[of b prog']"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_ 1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "have \"while (b) prog' \\<turnstile> (_1_) -[((_1_),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_ 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n     (_Exit_)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                  simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (2 subgoals):\n 1. l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n 2. \\<not> l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "with WCFG_WhileFalse[of b prog']"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_ 0 _) -(\\<lambda>s.\n      interpret b s = Some false)\\<^sub>\\<surd>\\<rightarrow> (_ 1 _)\n  While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)", "have \"while (b) prog' \\<turnstile> (_0_) -((_0_),(\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,(_1_))#\n      [((_1_),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_ 0 _) -(\\<lambda>s.\n      interpret b s = Some false)\\<^sub>\\<surd>\\<rightarrow> (_ 1 _)\n  While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_ 0 _)\n     [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n       (_ 1 _)),\n      ((_ 1 _), \\<Up>id, (_Exit_))]\n     (_Exit_)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                  simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_ 0 _)\n   [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (2 subgoals):\n 1. l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n 2. \\<not> l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "with \\<open>while (b) prog' \\<turnstile> (_Entry_) -[((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))]\\<rightarrow>* (_0_)\\<close> True"], ["proof (chain)\npicking this:\n  While_CFG.path (while (b) prog') (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _))] (_ 0 _)\n  l < 1\n  While_CFG.path (while (b) prog') (_ 0 _)\n   [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)", "show ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (while (b) prog') (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _))] (_ 0 _)\n  l < 1\n  While_CFG.path (while (b) prog') (_ 0 _)\n   [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "by simp blast"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n\ngoal (1 subgoal):\n 1. \\<not> l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "case False"], ["proof (state)\nthis:\n  \\<not> l < 1\n\ngoal (1 subgoal):\n 1. \\<not> l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "hence \"1 \\<le> l\""], ["proof (prove)\nusing this:\n  \\<not> l < 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> l", "by simp"], ["proof (state)\nthis:\n  1 \\<le> l\n\ngoal (1 subgoal):\n 1. \\<not> l < 1 \\<Longrightarrow>\n    (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "proof(cases \"l < 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "case True"], ["proof (state)\nthis:\n  l < 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with \\<open>1 \\<le> l\\<close>"], ["proof (chain)\npicking this:\n  1 \\<le> l\n  l < 2", "have [simp]:\"l = 1\""], ["proof (prove)\nusing this:\n  1 \\<le> l\n  l < 2\n\ngoal (1 subgoal):\n 1. l = 1", "by simp"], ["proof (state)\nthis:\n  l = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "from WCFG_WhileFalseSkip[of b prog']"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_ 1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "have \"while (b) prog' \\<turnstile> (_1_) -[((_1_),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_ 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n     (_Exit_)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                    simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "from WCFG_WhileFalse[of b prog']"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_ 0 _) -(\\<lambda>s.\n      interpret b s = Some false)\\<^sub>\\<surd>\\<rightarrow> (_ 1 _)", "have \"while (b) prog' \\<turnstile> (_0_) \n        -[((_0_),(\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,(_1_))]\\<rightarrow>* (_1_)\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_ 0 _) -(\\<lambda>s.\n      interpret b s = Some false)\\<^sub>\\<surd>\\<rightarrow> (_ 1 _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_ 0 _)\n     [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n       (_ 1 _))]\n     (_ 1 _)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                    simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_ 0 _)\n   [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _))]\n   (_ 1 _)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with WCFG_Entry[of \"while (b) prog'\"]"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_Entry_) -(\\<lambda>s.\n        True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (while (b) prog') (_ 0 _)\n   [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _))]\n   (_ 1 _)", "have \"while (b) prog' \\<turnstile> (_Entry_) -((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))#\n        [((_0_),(\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,(_1_))]\\<rightarrow>* (_1_)\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_Entry_) -(\\<lambda>s.\n        True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (while (b) prog') (_ 0 _)\n   [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _))]\n   (_ 1 _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_Entry_)\n     [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)),\n      ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n       (_ 1 _))]\n     (_ 1 _)", "by(fastforce intro:While_CFG.Cons_path simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)),\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _))]\n   (_ 1 _)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with \\<open>while (b) prog' \\<turnstile> (_1_) -[((_1_),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n  While_CFG.path (while (b) prog') (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)),\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _))]\n   (_ 1 _)", "show ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n  While_CFG.path (while (b) prog') (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)),\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _))]\n   (_ 1 _)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "by simp blast"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "case False"], ["proof (state)\nthis:\n  \\<not> l < 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with \\<open>1 \\<le> l\\<close>"], ["proof (chain)\npicking this:\n  1 \\<le> l\n  \\<not> l < 2", "have \"2 \\<le> l\""], ["proof (prove)\nusing this:\n  1 \\<le> l\n  \\<not> l < 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> l", "by simp"], ["proof (state)\nthis:\n  2 \\<le> l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "then"], ["proof (chain)\npicking this:\n  2 \\<le> l", "obtain l' where [simp]:\"l = l' + 2\" and \"l' = l - 2\""], ["proof (prove)\nusing this:\n  2 \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l = l' + 2; l' = l - 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp del:add_2_eq_Suc')"], ["proof (state)\nthis:\n  l = l' + 2\n  l' = l - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "from \\<open>l < #:while (b) prog'\\<close>"], ["proof (chain)\npicking this:\n  l < #:while (b) prog'", "have \"l' < #:prog'\""], ["proof (prove)\nusing this:\n  l < #:while (b) prog'\n\ngoal (1 subgoal):\n 1. l' < #:prog'", "by simp"], ["proof (state)\nthis:\n  l' < #:prog'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "from IH[OF this]"], ["proof (chain)\npicking this:\n  (\\<exists>as. While_CFG.path prog' (_ l' _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog' (_Entry_) as (_ l' _))", "obtain as as' where \"prog' \\<turnstile> (_ l' _) -as\\<rightarrow>* (_Exit_)\"\n        and \"prog' \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l' _)\""], ["proof (prove)\nusing this:\n  (\\<exists>as. While_CFG.path prog' (_ l' _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path prog' (_Entry_) as (_ l' _))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>While_CFG.path prog' (_ l' _) as (_Exit_);\n         While_CFG.path prog' (_Entry_) as' (_ l' _)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFG.path prog' (_ l' _) as (_Exit_)\n  While_CFG.path prog' (_Entry_) as' (_ l' _)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "from \\<open>prog' \\<turnstile> (_ l' _) -as\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog' (_ l' _) as (_Exit_)", "obtain ax asx where\n        \"prog' \\<turnstile> (_ l' _) -asx@[ax]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog' (_ l' _) as (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax.\n        While_CFG.path prog' (_ l' _) (asx @ [ax])\n         (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(induct as rule:rev_induct,auto elim:While_CFG.cases)"], ["proof (state)\nthis:\n  While_CFG.path prog' (_ l' _) (asx @ [ax]) (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "hence \"prog' \\<turnstile> (_ l' _) -asx\\<rightarrow>* sourcenode ax\" and \"valid_edge prog' ax\"\n        and \"(_Exit_) = targetnode ax\""], ["proof (prove)\nusing this:\n  While_CFG.path prog' (_ l' _) (asx @ [ax]) (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path prog' (_ l' _) asx (sourcenode ax) &&&\n    valid_edge prog' ax &&& (_Exit_) = targetnode ax", "by(auto intro:While_CFG.path_split_snoc)"], ["proof (state)\nthis:\n  While_CFG.path prog' (_ l' _) asx (sourcenode ax)\n  valid_edge prog' ax\n  (_Exit_) = targetnode ax\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "then"], ["proof (chain)\npicking this:\n  While_CFG.path prog' (_ l' _) asx (sourcenode ax)\n  valid_edge prog' ax\n  (_Exit_) = targetnode ax", "obtain lx where \"sourcenode ax = (_ lx _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog' (_ l' _) asx (sourcenode ax)\n  valid_edge prog' ax\n  (_Exit_) = targetnode ax\n\ngoal (1 subgoal):\n 1. (\\<And>lx.\n        sourcenode ax = (_ lx _) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"sourcenode ax\") auto"], ["proof (state)\nthis:\n  sourcenode ax = (_ lx _)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with \\<open>prog' \\<turnstile> (_ l' _) -asx\\<rightarrow>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog' (_ l' _) asx (sourcenode ax)\n  sourcenode ax = (_ lx _)", "have \"while (b) prog' \\<turnstile> (_ l' _) \\<oplus> 2 -asx \\<oplus>s 2\\<rightarrow>* sourcenode ax \\<oplus> 2\""], ["proof (prove)\nusing this:\n  While_CFG.path prog' (_ l' _) asx (sourcenode ax)\n  sourcenode ax = (_ lx _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') ((_ l' _) \\<oplus> 2) (asx \\<oplus>s 2)\n     (sourcenode ax \\<oplus> 2)", "by(fastforce intro:path_While simp del:label_incr.simps)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') ((_ l' _) \\<oplus> 2) (asx \\<oplus>s 2)\n   (sourcenode ax \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "from WCFG_WhileFalseSkip[of b prog']"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_ 1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "have \"while (b) prog' \\<turnstile> (_1_) -[((_1_),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_ 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n     (_Exit_)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                    simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with WCFG_WhileFalse[of b prog']"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_ 0 _) -(\\<lambda>s.\n      interpret b s = Some false)\\<^sub>\\<surd>\\<rightarrow> (_ 1 _)\n  While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)", "have \"while (b) prog' \\<turnstile> (_0_) -((_0_),(\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,(_1_))#\n        [((_1_),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_ 0 _) -(\\<lambda>s.\n      interpret b s = Some false)\\<^sub>\\<surd>\\<rightarrow> (_ 1 _)\n  While_CFG.path (while (b) prog') (_ 1 _) [((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_ 0 _)\n     [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n       (_ 1 _)),\n      ((_ 1 _), \\<Up>id, (_Exit_))]\n     (_Exit_)", "by(fastforce intro:While_CFG.Cons_path simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_ 0 _)\n   [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with \\<open>valid_edge prog' ax\\<close> \\<open>(_Exit_) = targetnode ax\\<close> \\<open>sourcenode ax = (_ lx _)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog' ax\n  (_Exit_) = targetnode ax\n  sourcenode ax = (_ lx _)\n  While_CFG.path (while (b) prog') (_ 0 _)\n   [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)", "have \"while (b) prog' \\<turnstile> sourcenode ax \\<oplus> 2 -(sourcenode ax \\<oplus> 2,kind ax,(_0_))#\n        ((_0_),(\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,(_1_))#\n        [((_1_),\\<Up>id,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge prog' ax\n  (_Exit_) = targetnode ax\n  sourcenode ax = (_ lx _)\n  While_CFG.path (while (b) prog') (_ 0 _)\n   [((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (sourcenode ax \\<oplus> 2)\n     [(sourcenode ax \\<oplus> 2, kind ax, (_ 0 _)),\n      ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n       (_ 1 _)),\n      ((_ 1 _), \\<Up>id, (_Exit_))]\n     (_Exit_)", "by(fastforce intro:While_CFG.Cons_path dest:WCFG_WhileBodyExit\n                    simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (sourcenode ax \\<oplus> 2)\n   [(sourcenode ax \\<oplus> 2, kind ax, (_ 0 _)),\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with \\<open>while (b) prog' \\<turnstile> (_ l' _) \\<oplus> 2 -asx \\<oplus>s 2\\<rightarrow>* sourcenode ax \\<oplus> 2\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path (while (b) prog') ((_ l' _) \\<oplus> 2) (asx \\<oplus>s 2)\n   (sourcenode ax \\<oplus> 2)\n  While_CFG.path (while (b) prog') (sourcenode ax \\<oplus> 2)\n   [(sourcenode ax \\<oplus> 2, kind ax, (_ 0 _)),\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)", "have path:\"while (b) prog' \\<turnstile> (_ l' _) \\<oplus> 2 -(asx \\<oplus>s 2)@\n        ((sourcenode ax \\<oplus> 2,kind ax,(_0_))#\n        ((_0_),(\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,(_1_))#\n        [((_1_),\\<Up>id,(_Exit_))])\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path (while (b) prog') ((_ l' _) \\<oplus> 2) (asx \\<oplus>s 2)\n   (sourcenode ax \\<oplus> 2)\n  While_CFG.path (while (b) prog') (sourcenode ax \\<oplus> 2)\n   [(sourcenode ax \\<oplus> 2, kind ax, (_ 0 _)),\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n     (_ 1 _)),\n    ((_ 1 _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') ((_ l' _) \\<oplus> 2)\n     ((asx \\<oplus>s 2) @\n      [(sourcenode ax \\<oplus> 2, kind ax, (_ 0 _)),\n       ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n        (_ 1 _)),\n       ((_ 1 _), \\<Up>id, (_Exit_))])\n     (_Exit_)", "by(rule While_CFG.path_Append)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') ((_ l' _) \\<oplus> 2)\n   ((asx \\<oplus>s 2) @\n    [(sourcenode ax \\<oplus> 2, kind ax, (_ 0 _)),\n     ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n      (_ 1 _)),\n     ((_ 1 _), \\<Up>id, (_Exit_))])\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "from \\<open>prog' \\<turnstile> (_Entry_) -as'\\<rightarrow>* (_ l' _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog' (_Entry_) as' (_ l' _)", "obtain ax' asx'\n        where \"prog' \\<turnstile> (_Entry_) -ax'#asx'\\<rightarrow>* (_ l' _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog' (_Entry_) as' (_ l' _)\n\ngoal (1 subgoal):\n 1. (\\<And>ax' asx'.\n        While_CFG.path prog' (_Entry_) (ax' # asx')\n         (_ l' _) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases as',auto elim:While_CFG.cases)"], ["proof (state)\nthis:\n  While_CFG.path prog' (_Entry_) (ax' # asx') (_ l' _)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "hence \"(_Entry_) = sourcenode ax'\" and \"valid_edge prog' ax'\"\n        and \"prog' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (_ l' _)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog' (_Entry_) (ax' # asx') (_ l' _)\n\ngoal (1 subgoal):\n 1. (_Entry_) = sourcenode ax' &&&\n    valid_edge prog' ax' &&&\n    While_CFG.path prog' (targetnode ax') asx' (_ l' _)", "by(auto intro:While_CFG.path_split_Cons)"], ["proof (state)\nthis:\n  (_Entry_) = sourcenode ax'\n  valid_edge prog' ax'\n  While_CFG.path prog' (targetnode ax') asx' (_ l' _)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "hence \"targetnode ax' = (_0_)\""], ["proof (prove)\nusing this:\n  (_Entry_) = sourcenode ax'\n  valid_edge prog' ax'\n  While_CFG.path prog' (targetnode ax') asx' (_ l' _)\n\ngoal (1 subgoal):\n 1. targetnode ax' = (_ 0 _)", "by(fastforce dest:WCFG_EntryD simp:valid_edge_def)"], ["proof (state)\nthis:\n  targetnode ax' = (_ 0 _)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with \\<open>prog' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (_ l' _)\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog' (targetnode ax') asx' (_ l' _)\n  targetnode ax' = (_ 0 _)", "have \"while (b) prog' \\<turnstile> (_0_) \\<oplus> 2 -asx' \\<oplus>s 2\\<rightarrow>* (_ l' _) \\<oplus> 2\""], ["proof (prove)\nusing this:\n  While_CFG.path prog' (targetnode ax') asx' (_ l' _)\n  targetnode ax' = (_ 0 _)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') ((_ 0 _) \\<oplus> 2) (asx' \\<oplus>s 2)\n     ((_ l' _) \\<oplus> 2)", "by(fastforce intro:path_While)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') ((_ 0 _) \\<oplus> 2) (asx' \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with WCFG_WhileTrue[of b prog']"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_ 0 _) -(\\<lambda>s.\n      interpret b s =\n      Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 2\n  While_CFG.path (while (b) prog') ((_ 0 _) \\<oplus> 2) (asx' \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)", "have \"while (b) prog' \\<turnstile> (_0_) \n        -((_0_),(\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,(_0_) \\<oplus> 2)#(asx' \\<oplus>s 2)\\<rightarrow>* \n        (_ l' _) \\<oplus> 2\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_ 0 _) -(\\<lambda>s.\n      interpret b s =\n      Some true)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _) \\<oplus> 2\n  While_CFG.path (while (b) prog') ((_ 0 _) \\<oplus> 2) (asx' \\<oplus>s 2)\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_ 0 _)\n     (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n       (_ 0 _) \\<oplus> 2) #\n      (asx' \\<oplus>s 2))\n     ((_ l' _) \\<oplus> 2)", "by(fastforce intro:While_CFG.Cons_path simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 2) #\n    (asx' \\<oplus>s 2))\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with WCFG_Entry[of \"while (b) prog'\"]"], ["proof (chain)\npicking this:\n  while (b) prog' \\<turnstile> (_Entry_) -(\\<lambda>s.\n        True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (while (b) prog') (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 2) #\n    (asx' \\<oplus>s 2))\n   ((_ l' _) \\<oplus> 2)", "have \"while (b) prog' \\<turnstile> (_Entry_) -((_Entry_),(\\<lambda>s. True)\\<^sub>\\<surd>,(_0_))#\n        ((_0_),(\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,(_0_) \\<oplus> 2)#(asx' \\<oplus>s 2)\\<rightarrow>* \n        (_ l' _) \\<oplus> 2\""], ["proof (prove)\nusing this:\n  while (b) prog' \\<turnstile> (_Entry_) -(\\<lambda>s.\n        True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n  While_CFG.path (while (b) prog') (_ 0 _)\n   (((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 2) #\n    (asx' \\<oplus>s 2))\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. While_CFG.path (while (b) prog') (_Entry_)\n     (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n      ((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n       (_ 0 _) \\<oplus> 2) #\n      (asx' \\<oplus>s 2))\n     ((_ l' _) \\<oplus> 2)", "by(fastforce intro:While_CFG.Cons_path simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path (while (b) prog') (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 2) #\n    (asx' \\<oplus>s 2))\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_ l _) as\n                           (_Exit_)) \\<and>\n                      (\\<exists>as.\n                          While_CFG.path (while (b) prog') (_Entry_) as\n                           (_ l _))", "with path"], ["proof (chain)\npicking this:\n  While_CFG.path (while (b) prog') ((_ l' _) \\<oplus> 2)\n   ((asx \\<oplus>s 2) @\n    [(sourcenode ax \\<oplus> 2, kind ax, (_ 0 _)),\n     ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n      (_ 1 _)),\n     ((_ 1 _), \\<Up>id, (_Exit_))])\n   (_Exit_)\n  While_CFG.path (while (b) prog') (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 2) #\n    (asx' \\<oplus>s 2))\n   ((_ l' _) \\<oplus> 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path (while (b) prog') ((_ l' _) \\<oplus> 2)\n   ((asx \\<oplus>s 2) @\n    [(sourcenode ax \\<oplus> 2, kind ax, (_ 0 _)),\n     ((_ 0 _), (\\<lambda>s. interpret b s = Some false)\\<^sub>\\<surd>,\n      (_ 1 _)),\n     ((_ 1 _), \\<Up>id, (_Exit_))])\n   (_Exit_)\n  While_CFG.path (while (b) prog') (_Entry_)\n   (((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ 0 _)) #\n    ((_ 0 _), (\\<lambda>s. interpret b s = Some true)\\<^sub>\\<surd>,\n     (_ 0 _) \\<oplus> 2) #\n    (asx' \\<oplus>s 2))\n   ((_ l' _) \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n    (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))", "by simp blast"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as. While_CFG.path (while (b) prog') (_ l _) as (_Exit_)) \\<and>\n  (\\<exists>as. While_CFG.path (while (b) prog') (_Entry_) as (_ l _))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "declare add_2_eq_Suc' [simp] One_nat_def [simp]"], ["", "(*>*)"], ["", "lemma valid_node_Exit_path:\n  assumes \"valid_node prog n\" shows \"\\<exists>as. prog \\<turnstile> n -as\\<rightarrow>* (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path prog n as (_Exit_)", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = (_ x1 _) \\<Longrightarrow>\n       \\<exists>as. While_CFG.path prog n as (_Exit_)\n 2. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)\n 3. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "case (Node l)"], ["proof (state)\nthis:\n  n = (_ l _)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = (_ x1 _) \\<Longrightarrow>\n       \\<exists>as. While_CFG.path prog n as (_Exit_)\n 2. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)\n 3. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "with \\<open>valid_node prog n\\<close>"], ["proof (chain)\npicking this:\n  valid_node prog n\n  n = (_ l _)", "have \"l < #:prog\""], ["proof (prove)\nusing this:\n  valid_node prog n\n  n = (_ l _)\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(fastforce dest:WCFG_sourcelabel_less_num_nodes WCFG_targetlabel_less_num_nodes\n                simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = (_ x1 _) \\<Longrightarrow>\n       \\<exists>as. While_CFG.path prog n as (_Exit_)\n 2. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)\n 3. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "with Node"], ["proof (chain)\npicking this:\n  n = (_ l _)\n  l < #:prog", "show ?thesis"], ["proof (prove)\nusing this:\n  n = (_ l _)\n  l < #:prog\n\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path prog n as (_Exit_)", "by(fastforce dest:inner_node_Entry_Exit_path)"], ["proof (state)\nthis:\n  \\<exists>as. While_CFG.path prog n as (_Exit_)\n\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)\n 2. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)\n 2. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "case Entry"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)\n 2. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "from WCFG_Entry_Exit[of prog]"], ["proof (chain)\npicking this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)", "have \"prog \\<turnstile> (_Entry_) -[((_Entry_),(\\<lambda>s. False)\\<^sub>\\<surd>,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path prog (_Entry_)\n     [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))] (_Exit_)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path prog (_Entry_)\n   [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))] (_Exit_)\n\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)\n 2. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "with Entry"], ["proof (chain)\npicking this:\n  n = (_Entry_)\n  While_CFG.path prog (_Entry_)\n   [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))] (_Exit_)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = (_Entry_)\n  While_CFG.path prog (_Entry_)\n   [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))] (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path prog n as (_Exit_)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. While_CFG.path prog n as (_Exit_)\n\ngoal (1 subgoal):\n 1. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "case Exit"], ["proof (state)\nthis:\n  n = (_Exit_)\n\ngoal (1 subgoal):\n 1. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "with WCFG_Entry_Exit[of prog]"], ["proof (chain)\npicking this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\n  n = (_Exit_)", "have \"prog \\<turnstile> n -[]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\n  n = (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path prog n [] (_Exit_)", "by(fastforce intro:While_CFG.empty_path simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path prog n [] (_Exit_)\n\ngoal (1 subgoal):\n 1. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog n as (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path prog n [] (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path prog n as (_Exit_)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. While_CFG.path prog n as (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_node_Entry_path:\n  assumes \"valid_node prog n\" shows \"\\<exists>as. prog \\<turnstile> (_Entry_) -as\\<rightarrow>* n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path prog (_Entry_) as n", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = (_ x1 _) \\<Longrightarrow>\n       \\<exists>as. While_CFG.path prog (_Entry_) as n\n 2. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n\n 3. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "case (Node l)"], ["proof (state)\nthis:\n  n = (_ l _)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = (_ x1 _) \\<Longrightarrow>\n       \\<exists>as. While_CFG.path prog (_Entry_) as n\n 2. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n\n 3. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "with \\<open>valid_node prog n\\<close>"], ["proof (chain)\npicking this:\n  valid_node prog n\n  n = (_ l _)", "have \"l < #:prog\""], ["proof (prove)\nusing this:\n  valid_node prog n\n  n = (_ l _)\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(fastforce dest:WCFG_sourcelabel_less_num_nodes WCFG_targetlabel_less_num_nodes\n                simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = (_ x1 _) \\<Longrightarrow>\n       \\<exists>as. While_CFG.path prog (_Entry_) as n\n 2. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n\n 3. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "with Node"], ["proof (chain)\npicking this:\n  n = (_ l _)\n  l < #:prog", "show ?thesis"], ["proof (prove)\nusing this:\n  n = (_ l _)\n  l < #:prog\n\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path prog (_Entry_) as n", "by(fastforce dest:inner_node_Entry_Exit_path)"], ["proof (state)\nthis:\n  \\<exists>as. While_CFG.path prog (_Entry_) as n\n\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n\n 2. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n\n 2. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "case Entry"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n\n 2. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "with WCFG_Entry_Exit[of prog]"], ["proof (chain)\npicking this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\n  n = (_Entry_)", "have \"prog \\<turnstile> (_Entry_) -[]\\<rightarrow>* n\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\n  n = (_Entry_)\n\ngoal (1 subgoal):\n 1. While_CFG.path prog (_Entry_) [] n", "by(fastforce intro:While_CFG.empty_path simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path prog (_Entry_) [] n\n\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n\n 2. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "thus ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.path prog (_Entry_) [] n\n\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path prog (_Entry_) as n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. While_CFG.path prog (_Entry_) as n\n\ngoal (1 subgoal):\n 1. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "case Exit"], ["proof (state)\nthis:\n  n = (_Exit_)\n\ngoal (1 subgoal):\n 1. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "from WCFG_Entry_Exit[of prog]"], ["proof (chain)\npicking this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)", "have \"prog \\<turnstile> (_Entry_) -[((_Entry_),(\\<lambda>s. False)\\<^sub>\\<surd>,(_Exit_))]\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. While_CFG.path prog (_Entry_)\n     [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))] (_Exit_)", "by(fastforce intro:While_CFG.Cons_path While_CFG.empty_path\n                simp:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.path prog (_Entry_)\n   [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))] (_Exit_)\n\ngoal (1 subgoal):\n 1. n = (_Exit_) \\<Longrightarrow>\n    \\<exists>as. While_CFG.path prog (_Entry_) as n", "with Exit"], ["proof (chain)\npicking this:\n  n = (_Exit_)\n  While_CFG.path prog (_Entry_)\n   [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))] (_Exit_)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = (_Exit_)\n  While_CFG.path prog (_Entry_)\n   [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))] (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as. While_CFG.path prog (_Entry_) as n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. While_CFG.path prog (_Entry_) as n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Some finiteness considerations\\<close>"], ["", "lemma finite_labels:\"finite {l. \\<exists>c. labels prog l c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l. \\<exists>c. labels prog l c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {l. \\<exists>c. labels prog l c}", "have \"finite {l::nat. l < #:prog}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l. l < #:prog}", "by(fastforce intro:nat_seg_image_imp_finite)"], ["proof (state)\nthis:\n  finite {l. l < #:prog}\n\ngoal (1 subgoal):\n 1. finite {l. \\<exists>c. labels prog l c}", "moreover"], ["proof (state)\nthis:\n  finite {l. l < #:prog}\n\ngoal (1 subgoal):\n 1. finite {l. \\<exists>c. labels prog l c}", "have \"{l. \\<exists>c. labels prog l c} \\<subseteq> {l::nat. l < #:prog}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. \\<exists>c. labels prog l c} \\<subseteq> {l. l < #:prog}", "by(fastforce intro:label_less_num_inner_nodes)"], ["proof (state)\nthis:\n  {l. \\<exists>c. labels prog l c} \\<subseteq> {l. l < #:prog}\n\ngoal (1 subgoal):\n 1. finite {l. \\<exists>c. labels prog l c}", "ultimately"], ["proof (chain)\npicking this:\n  finite {l. l < #:prog}\n  {l. \\<exists>c. labels prog l c} \\<subseteq> {l. l < #:prog}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {l. l < #:prog}\n  {l. \\<exists>c. labels prog l c} \\<subseteq> {l. l < #:prog}\n\ngoal (1 subgoal):\n 1. finite {l. \\<exists>c. labels prog l c}", "by(auto intro:finite_subset)"], ["proof (state)\nthis:\n  finite {l. \\<exists>c. labels prog l c}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_valid_nodes:\"finite {n. valid_node prog n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {n. valid_node prog n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {n. valid_node prog n}", "have \"{n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'} \\<subseteq> \n    insert (_Entry_) ((\\<lambda>l'. (_ l' _)) ` {l. \\<exists>c. labels prog l c})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'}\n    \\<subseteq> insert (_Entry_) (Node ` {l. \\<exists>c. labels prog l c})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n' et.\n       \\<lbrakk>x \\<notin> Node ` {l. \\<exists>c. labels prog l c};\n        prog \\<turnstile> x -et\\<rightarrow> n'\\<rbrakk>\n       \\<Longrightarrow> x = (_Entry_)", "apply(case_tac x,auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' et x1.\n       \\<lbrakk>(_ x1 _) \\<notin> Node ` {l. Ex (labels prog l)};\n        prog \\<turnstile> (_ x1 _) -et\\<rightarrow> n'\\<rbrakk>\n       \\<Longrightarrow> False", "by(fastforce dest:WCFG_sourcelabel_less_num_nodes less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'}\n  \\<subseteq> insert (_Entry_) (Node ` {l. \\<exists>c. labels prog l c})\n\ngoal (1 subgoal):\n 1. finite {n. valid_node prog n}", "hence \"finite {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'}\""], ["proof (prove)\nusing this:\n  {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'}\n  \\<subseteq> insert (_Entry_) (Node ` {l. \\<exists>c. labels prog l c})\n\ngoal (1 subgoal):\n 1. finite {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'}", "by(auto intro:finite_subset finite_imageI finite_labels)"], ["proof (state)\nthis:\n  finite {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'}\n\ngoal (1 subgoal):\n 1. finite {n. valid_node prog n}", "have \"{n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'} \\<subseteq> \n    insert (_Exit_) ((\\<lambda>l'. (_ l' _)) ` {l. \\<exists>c. labels prog l c})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\n    \\<subseteq> insert (_Exit_) (Node ` {l. \\<exists>c. labels prog l c})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n et.\n       \\<lbrakk>x \\<notin> Node ` {l. \\<exists>c. labels prog l c};\n        prog \\<turnstile> n -et\\<rightarrow> x\\<rbrakk>\n       \\<Longrightarrow> x = (_Exit_)", "apply(case_tac x,auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n et x1.\n       \\<lbrakk>(_ x1 _) \\<notin> Node ` {l. Ex (labels prog l)};\n        prog \\<turnstile> n -et\\<rightarrow> (_ x1 _)\\<rbrakk>\n       \\<Longrightarrow> False", "by(fastforce dest:WCFG_targetlabel_less_num_nodes less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\n  \\<subseteq> insert (_Exit_) (Node ` {l. \\<exists>c. labels prog l c})\n\ngoal (1 subgoal):\n 1. finite {n. valid_node prog n}", "hence \"finite {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\""], ["proof (prove)\nusing this:\n  {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\n  \\<subseteq> insert (_Exit_) (Node ` {l. \\<exists>c. labels prog l c})\n\ngoal (1 subgoal):\n 1. finite {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}", "by(auto intro:finite_subset finite_imageI finite_labels)"], ["proof (state)\nthis:\n  finite {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\n\ngoal (1 subgoal):\n 1. finite {n. valid_node prog n}", "have \"{n. \\<exists>nx et nx'. prog \\<turnstile> nx -et\\<rightarrow> nx' \\<and> (n = nx \\<or> n = nx')} =\n    {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'} Un {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. \\<exists>nx et nx'.\n           prog \\<turnstile> nx -et\\<rightarrow> nx' \\<and>\n           (n = nx \\<or> n = nx')} =\n    {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'} \\<union>\n    {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}", "by blast"], ["proof (state)\nthis:\n  {n. \\<exists>nx et nx'.\n         prog \\<turnstile> nx -et\\<rightarrow> nx' \\<and>\n         (n = nx \\<or> n = nx')} =\n  {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'} \\<union>\n  {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\n\ngoal (1 subgoal):\n 1. finite {n. valid_node prog n}", "with \\<open>finite {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'}\\<close> \\<open>finite {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\\<close>"], ["proof (chain)\npicking this:\n  finite {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'}\n  finite {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\n  {n. \\<exists>nx et nx'.\n         prog \\<turnstile> nx -et\\<rightarrow> nx' \\<and>\n         (n = nx \\<or> n = nx')} =\n  {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'} \\<union>\n  {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}", "have \"finite {n. \\<exists>nx et nx'. prog \\<turnstile> nx -et\\<rightarrow> nx' \\<and> (n = nx \\<or> n = nx')}\""], ["proof (prove)\nusing this:\n  finite {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'}\n  finite {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\n  {n. \\<exists>nx et nx'.\n         prog \\<turnstile> nx -et\\<rightarrow> nx' \\<and>\n         (n = nx \\<or> n = nx')} =\n  {n. \\<exists>n' et. prog \\<turnstile> n -et\\<rightarrow> n'} \\<union>\n  {n'. \\<exists>n et. prog \\<turnstile> n -et\\<rightarrow> n'}\n\ngoal (1 subgoal):\n 1. finite\n     {n. \\<exists>nx et nx'.\n            prog \\<turnstile> nx -et\\<rightarrow> nx' \\<and>\n            (n = nx \\<or> n = nx')}", "by fastforce"], ["proof (state)\nthis:\n  finite\n   {n. \\<exists>nx et nx'.\n          prog \\<turnstile> nx -et\\<rightarrow> nx' \\<and>\n          (n = nx \\<or> n = nx')}\n\ngoal (1 subgoal):\n 1. finite {n. valid_node prog n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite\n   {n. \\<exists>nx et nx'.\n          prog \\<turnstile> nx -et\\<rightarrow> nx' \\<and>\n          (n = nx \\<or> n = nx')}\n\ngoal (1 subgoal):\n 1. finite {n. valid_node prog n}", "by(simp add:valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  finite {n. valid_node prog n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_successors:\n  \"finite {n'. \\<exists>a'. valid_edge prog a' \\<and> sourcenode a' = n \\<and> \n                    targetnode a' = n'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "have \"{n'. \\<exists>a'. valid_edge prog a' \\<and> sourcenode a' = n \\<and> \n                  targetnode a' = n'} \\<subseteq> {n. valid_node prog n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n'.\n     \\<exists>a'.\n        valid_edge prog a' \\<and>\n        sourcenode a' = n \\<and> targetnode a' = n'}\n    \\<subseteq> {n. valid_node prog n}", "by(auto simp:valid_edge_def valid_node_def)"], ["proof (state)\nthis:\n  {n'.\n   \\<exists>a'.\n      valid_edge prog a' \\<and> sourcenode a' = n \\<and> targetnode a' = n'}\n  \\<subseteq> {n. valid_node prog n}\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {n'.\n   \\<exists>a'.\n      valid_edge prog a' \\<and> sourcenode a' = n \\<and> targetnode a' = n'}\n  \\<subseteq> {n. valid_node prog n}\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "by(fastforce elim:finite_subset intro:finite_valid_nodes)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}