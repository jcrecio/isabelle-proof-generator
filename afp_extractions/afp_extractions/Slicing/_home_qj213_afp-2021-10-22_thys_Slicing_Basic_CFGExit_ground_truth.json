{"file_name": "/home/qj213/afp-2021-10-22/thys/Slicing/Basic/CFGExit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Slicing", "problem_names": ["lemma Entry_noteq_Exit [dest]:\n  assumes eq:\"(_Entry_) = (_Exit_)\" shows \"False\"", "lemma Exit_noteq_Entry [dest]:\"(_Exit_) = (_Entry_) \\<Longrightarrow> False\"", "lemma [simp]: \"valid_node (_Entry_)\"", "lemma [simp]: \"valid_node (_Exit_)\"", "lemma inner_is_valid:\n  \"inner_node n \\<Longrightarrow> valid_node n\"", "lemma [dest]:\n  \"inner_node (_Entry_) \\<Longrightarrow> False\"", "lemma [dest]:\n  \"inner_node (_Exit_) \\<Longrightarrow> False\"", "lemma [simp]:\"\\<lbrakk>valid_edge a; targetnode a \\<noteq> (_Exit_)\\<rbrakk> \n  \\<Longrightarrow> inner_node (targetnode a)\"", "lemma [simp]:\"\\<lbrakk>valid_edge a; sourcenode a \\<noteq> (_Entry_)\\<rbrakk>\n  \\<Longrightarrow> inner_node (sourcenode a)\"", "lemma valid_node_cases [consumes 1, case_names \"Entry\" \"Exit\" \"inner\"]:\n  \"\\<lbrakk>valid_node n; n = (_Entry_) \\<Longrightarrow> Q; n = (_Exit_) \\<Longrightarrow> Q;\n    inner_node n \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma path_Exit_source [dest]:\n  assumes \"(_Exit_) -as\\<rightarrow>* n'\" shows \"n' = (_Exit_)\" and \"as = []\"", "lemma Exit_no_sourcenode[dest]:\n  assumes isin:\"(_Exit_) \\<in> set (sourcenodes as)\" and path:\"n -as\\<rightarrow>* n'\"\n  shows False"], "translations": [["", "lemma Entry_noteq_Exit [dest]:\n  assumes eq:\"(_Entry_) = (_Exit_)\" shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain a where \"sourcenode a = (_Entry_)\" \n    and \"valid_edge a\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>sourcenode a = (_Entry_); valid_edge a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sourcenode a = (_Entry_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "with eq"], ["proof (chain)\npicking this:\n  (_Entry_) = (_Exit_)\n  sourcenode a = (_Entry_)\n  valid_edge a", "show False"], ["proof (prove)\nusing this:\n  (_Entry_) = (_Exit_)\n  sourcenode a = (_Entry_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "by simp(erule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_noteq_Entry [dest]:\"(_Exit_) = (_Entry_) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (_Exit_) = (_Entry_) \\<Longrightarrow> False", "by(rule Entry_noteq_Exit[OF sym],simp)"], ["", "lemma [simp]: \"valid_node (_Entry_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node (_Entry_)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_node (_Entry_)", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain a where \"sourcenode a = (_Entry_)\" \n    and \"valid_edge a\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>sourcenode a = (_Entry_); valid_edge a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sourcenode a = (_Entry_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = (_Entry_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (_Entry_)", "by(fastforce simp:valid_node_def)"], ["proof (state)\nthis:\n  valid_node (_Entry_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"valid_node (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node (_Exit_)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_node (_Exit_)", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain a where \"targetnode a = (_Exit_)\"\n    and \"valid_edge a\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>targetnode a = (_Exit_); valid_edge a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  targetnode a = (_Exit_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (_Exit_)", "by(fastforce simp:valid_node_def)"], ["proof (state)\nthis:\n  valid_node (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition inner_node :: \"'node \\<Rightarrow> bool\"\n  where inner_node_def: \n  \"inner_node n \\<equiv> valid_node n \\<and> n \\<noteq> (_Entry_) \\<and> n \\<noteq> (_Exit_)\""], ["", "lemma inner_is_valid:\n  \"inner_node n \\<Longrightarrow> valid_node n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_node n \\<Longrightarrow> valid_node n", "by(simp add:inner_node_def valid_node_def)"], ["", "lemma [dest]:\n  \"inner_node (_Entry_) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_node (_Entry_) \\<Longrightarrow> False", "by(simp add:inner_node_def)"], ["", "lemma [dest]:\n  \"inner_node (_Exit_) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_node (_Exit_) \\<Longrightarrow> False", "by(simp add:inner_node_def)"], ["", "lemma [simp]:\"\\<lbrakk>valid_edge a; targetnode a \\<noteq> (_Exit_)\\<rbrakk> \n  \\<Longrightarrow> inner_node (targetnode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_edge a; targetnode a \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> inner_node (targetnode a)", "by(simp add:inner_node_def,rule ccontr,simp,erule Entry_target)"], ["", "lemma [simp]:\"\\<lbrakk>valid_edge a; sourcenode a \\<noteq> (_Entry_)\\<rbrakk>\n  \\<Longrightarrow> inner_node (sourcenode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_edge a; sourcenode a \\<noteq> (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> inner_node (sourcenode a)", "by(simp add:inner_node_def,rule ccontr,simp,erule Exit_source)"], ["", "lemma valid_node_cases [consumes 1, case_names \"Entry\" \"Exit\" \"inner\"]:\n  \"\\<lbrakk>valid_node n; n = (_Entry_) \\<Longrightarrow> Q; n = (_Exit_) \\<Longrightarrow> Q;\n    inner_node n \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node n; n = (_Entry_) \\<Longrightarrow> Q;\n     n = (_Exit_) \\<Longrightarrow> Q;\n     inner_node n \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "apply(auto simp:valid_node_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>sourcenode a = (_Entry_) \\<Longrightarrow> Q;\n        sourcenode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (sourcenode a) \\<Longrightarrow> Q; valid_edge a;\n        n = sourcenode a\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a\\<rbrakk>\n       \\<Longrightarrow> Q", "apply(case_tac \"sourcenode a = (_Entry_)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>sourcenode a = (_Entry_) \\<Longrightarrow> Q;\n        sourcenode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (sourcenode a) \\<Longrightarrow> Q; valid_edge a;\n        n = sourcenode a; sourcenode a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>a.\n       \\<lbrakk>sourcenode a = (_Entry_) \\<Longrightarrow> Q;\n        sourcenode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (sourcenode a) \\<Longrightarrow> Q; valid_edge a;\n        n = sourcenode a; sourcenode a \\<noteq> (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> Q\n 3. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a\\<rbrakk>\n       \\<Longrightarrow> Q", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a\\<rbrakk>\n       \\<Longrightarrow> Q", "apply(case_tac \"targetnode a = (_Exit_)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a; targetnode a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a; targetnode a \\<noteq> (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> Q", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_Exit_source [dest]:\n  assumes \"(_Exit_) -as\\<rightarrow>* n'\" shows \"n' = (_Exit_)\" and \"as = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' = (_Exit_) &&& as = []", "using \\<open>(_Exit_) -as\\<rightarrow>* n'\\<close>"], ["proof (prove)\nusing this:\n  (_Exit_) -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n' = (_Exit_) &&& as = []", "proof(induct n\\<equiv>\"(_Exit_)\" as n' rule:path.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n' = (_Exit_)\n 4. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "case (Cons_path n'' as n' a)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n  n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_)\n  n'' = (_Exit_) \\<Longrightarrow> as = []\n  valid_edge a\n  sourcenode a = (_Exit_)\n  targetnode a = n''\n\ngoal (4 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n' = (_Exit_)\n 4. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "from \\<open>sourcenode a = (_Exit_)\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (_Exit_)\n  valid_edge a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (_Exit_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "by -(rule Exit_source,simp_all)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n' = (_Exit_)\n 4. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "{"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n' = (_Exit_)\n 4. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n' = (_Exit_)\n 4. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "with \\<open>False\\<close>"], ["proof (chain)\npicking this:\n  False", "show ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n' = (_Exit_)", ".."], ["proof (state)\nthis:\n  n' = (_Exit_)\n\ngoal (3 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_);\n        n'' = (_Exit_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Exit_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "with \\<open>False\\<close>"], ["proof (chain)\npicking this:\n  False", "show ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a # as = []", ".."], ["proof (state)\nthis:\n  a # as = []\n\ngoal (2 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []", "}"], ["proof (state)\nthis:\n  a # as = []\n\ngoal (2 subgoals):\n 1. valid_node (_Exit_) \\<Longrightarrow> (_Exit_) = (_Exit_)\n 2. valid_node (_Exit_) \\<Longrightarrow> [] = []", "qed simp_all"], ["", "lemma Exit_no_sourcenode[dest]:\n  assumes isin:\"(_Exit_) \\<in> set (sourcenodes as)\" and path:\"n -as\\<rightarrow>* n'\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from isin"], ["proof (chain)\npicking this:\n  (_Exit_) \\<in> set (sourcenodes as)", "obtain ns' ns'' where \"sourcenodes as = ns'@(_Exit_)#ns''\""], ["proof (prove)\nusing this:\n  (_Exit_) \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        sourcenodes as = ns' @ (_Exit_) # ns'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:split_list simp:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenodes as = ns' @ (_Exit_) # ns''\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  sourcenodes as = ns' @ (_Exit_) # ns''", "obtain as' as'' a where \"as = as'@a#as''\"\n    and source:\"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  sourcenodes as = ns' @ (_Exit_) # ns''\n\ngoal (1 subgoal):\n 1. (\\<And>as' a as''.\n        \\<lbrakk>as = as' @ a # as''; sourcenode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  as = as' @ a # as''\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "with path"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  as = as' @ a # as''\n  sourcenode a = (_Exit_)", "have \"valid_edge a\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  as = as' @ a # as''\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. valid_edge a", "by(fastforce dest:path_split)"], ["proof (state)\nthis:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "with source"], ["proof (chain)\npicking this:\n  sourcenode a = (_Exit_)\n  valid_edge a", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = (_Exit_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "by -(erule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}