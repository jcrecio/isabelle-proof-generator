{"file_name": "/home/qj213/afp-2021-10-22/thys/Slicing/JinjaVM/JVMCFG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Slicing", "problem_names": ["lemma wf_jvmprog_is_wf: \"wf_jvm_prog\\<^bsub>P\\<^bsub>\\<Phi>\\<^esub>\\<^esub> (P\\<^bsub>wf\\<^esub>)\"", "lemma find_handler_decr [simp]: \"find_handler_for P Exc cs \\<noteq> c#cs\"", "lemma stkss_length [simp]: \"length (stkss P cs stk) = length cs\"", "lemma locss_length [simp]: \"length (locss P cs loc) = length cs\"", "lemma nth_stkss: \n  \"\\<lbrakk> a < length cs; b < length (stkss P cs stk ! (length cs - Suc a)) \\<rbrakk>\n  \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) ! \n    (length (stkss P cs stk ! (length cs - Suc a)) - Suc b) = stk (a,b)\"", "lemma nth_locss:\n  \"\\<lbrakk> a < length cs; b < length (locss P cs loc ! (length cs - Suc a)) \\<rbrakk>\n  \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b = loc (a,b)\"", "lemma hd_stks [simp]: \"n \\<noteq> 0 \\<Longrightarrow> hd (stks n stk) = stk(n - 1)\"", "lemma hd_tl_stks: \"n > 1 \\<Longrightarrow> hd (tl (stks n stk)) = stk(n - 2)\"", "lemma stkss_purge:\n  \"length cs \\<le> a \\<Longrightarrow> stkss P cs (stk((a,b) := c)) = stkss P cs stk\"", "lemma stkss_purge':\n  \"length cs \\<le> a \\<Longrightarrow> stkss P cs (\\<lambda>s. if s = (a, b) then c else stk s) = stkss P cs stk\"", "lemma locss_purge:\n  \"length cs \\<le> a \\<Longrightarrow> locss P cs (loc((a,b) := c)) = locss P cs loc\"", "lemma locss_purge':\n  \"length cs \\<le> a \\<Longrightarrow> locss P cs (\\<lambda>s. if s = (a, b) then c else loc s) = locss P cs loc\"", "lemma locs_pullout [simp]:\n  \"locs b (loc(n := e)) = (locs b loc) [n := e]\"", "lemma locs_pullout' [simp]:\n  \"locs b (\\<lambda>a. if a = n then e else loc (c, a)) = (locs b (\\<lambda>a. loc (c, a))) [n := e]\"", "lemma stks_pullout:\n  \"n < b \\<Longrightarrow> stks b (stk(n := e)) = (stks b stk) [b - Suc n := e]\"", "lemma nth_tl : \"xs \\<noteq> [] \\<Longrightarrow> tl xs ! n = xs ! (Suc n)\"", "lemma f2c_Nil [simp]: \"framestack_to_callstack [] = []\"", "lemma f2c_Cons [simp]:\n  \"framestack_to_callstack ((stk,loc,C,M,pc)#frs) = (C,M,pc)#(framestack_to_callstack frs)\"", "lemma f2c_length [simp]:\n  \"length (framestack_to_callstack frs) = length frs\"", "lemma f2c_s2jvm_id [simp]:\n  \"framestack_to_callstack\n    (snd(snd(state_to_jvm_state P cs s))) =\n  cs\"", "lemma f2c_s2jvm_id' [simp]:\n  \"framestack_to_callstack\n  (zip (stkss P cs stk) (zip (locss P cs loc) cs)) = cs\"", "lemma f2c_append [simp]:\n  \"framestack_to_callstack (frs @ frs') =\n  (framestack_to_callstack frs) @ (framestack_to_callstack frs')\"", "lemma JVMCFG_Exit_no_sourcenode [dest]:\n  assumes edge:\"prog \\<turnstile> (_Exit_) -et\\<rightarrow> n'\"\n  shows \"False\"", "lemma JVMCFG_Entry_no_targetnode [dest]:\n  assumes edge:\"prog \\<turnstile> n -et\\<rightarrow> (_Entry_)\"\n  shows \"False\"", "lemma JVMCFG_EntryD:\n  \"\\<lbrakk>(P,C,M) \\<turnstile> n -et\\<rightarrow> n'; n = (_Entry_)\\<rbrakk> \n  \\<Longrightarrow> (n' = (_Exit_) \\<and> et = (\\<lambda>s. False)\\<^sub>\\<surd>) \\<or> (n' = (_ [(C,M,0)],None _) \\<and> et = (\\<lambda>s. True)\\<^sub>\\<surd>)\"", "lemma JVMCFG_edge_det:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> n'; prog \\<turnstile> n -et'\\<rightarrow> n'\\<rbrakk> \\<Longrightarrow> et = et'\""], "translations": [["", "lemma wf_jvmprog_is_wf: \"wf_jvm_prog\\<^bsub>P\\<^bsub>\\<Phi>\\<^esub>\\<^esub> (P\\<^bsub>wf\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>P\\<^bsub>\\<Phi>\\<^esub>\\<^esub> P\\<^bsub>wf\\<^esub>", "using Rep_wf_jvmprog [of P]"], ["proof (prove)\nusing this:\n  Rep_wf_jvmprog P \\<in> wf_jvmprog\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>P\\<^bsub>\\<Phi>\\<^esub>\\<^esub> P\\<^bsub>wf\\<^esub>", "by (auto simp: wf_jvmprog_def split_beta)"], ["", "subsubsection \\<open>Basic Types\\<close>"], ["", "text \\<open>\nWe consider a program to be a well-formed Jinja program,\ntogether with a given base class and a main method\n\\<close>"], ["", "type_synonym jvmprog = \"wf_jvmprog \\<times> cname \\<times> mname\""], ["", "type_synonym callstack = \"(cname \\<times> mname \\<times> pc) list\""], ["", "text \\<open>\nThe state is modeled as $\\textrm{heap} \\times \\textrm{stack-variables} \\times \\textrm{local-variables}$\n\nstack and local variables are modeled as pairs of natural numbers. The first number\ngives the position in the call stack (i.e. the method in which the variable is used),\nthe second the position in the method's stack or array of local variables resp.\n\nThe stack variables are numbered from bottom up (which is the reverse order of the\narray for the stack in Jinja's state representation), whereas local variables are identified\nby their position in the array of local variables of Jinja's state representation.\n\\<close>"], ["", "type_synonym state = \"heap \\<times> ((nat \\<times> nat) \\<Rightarrow> val) \\<times> ((nat \\<times> nat) \\<Rightarrow> val)\""], ["", "abbreviation heap_of :: \"state \\<Rightarrow> heap\"\nwhere\n  \"heap_of s \\<equiv> fst(s)\""], ["", "abbreviation stk_of :: \"state \\<Rightarrow> ((nat \\<times> nat) \\<Rightarrow> val)\"\nwhere\n  \"stk_of s \\<equiv> fst(snd(s))\""], ["", "abbreviation loc_of :: \"state \\<Rightarrow> ((nat \\<times> nat) \\<Rightarrow> val)\"\nwhere\n  \"loc_of s \\<equiv> snd(snd(s))\""], ["", "subsection \\<open>Basic Definitions\\<close>"], ["", "subsubsection \\<open>State update (instruction execution)\\<close>"], ["", "text \\<open>\nThis function models instruction execution for our state representation.\n\nAdditional parameters are the call depth of the current program point,\nthe stack length of the current program point,\nthe length of the stack in the underlying call frame (needed for {\\sc Return}),\nand (for {\\sc Invoke}) the length of the array of local variables of the invoked method.\n\nException handling is not covered by this function.\n\\<close>"], ["", "fun exec_instr :: \"instr \\<Rightarrow> wf_jvmprog \\<Rightarrow> state \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> state\"\nwhere\n  exec_instr_Load:\n  \"exec_instr (Load n) P s calldepth stk_length rs ill =\n  (let (h,stk,loc) = s\n   in (h, stk((calldepth,stk_length):=loc(calldepth,n)), loc))\"\n\n| exec_instr_Store:\n  \"exec_instr (Store n) P s calldepth stk_length rs ill =\n  (let (h,stk,loc) = s\n   in (h, stk, loc((calldepth,n):=stk(calldepth,stk_length - 1))))\"\n\n| exec_instr_Push:\n  \"exec_instr (Push v) P s calldepth stk_length rs ill =\n  (let (h,stk,loc) = s\n   in (h, stk((calldepth,stk_length):=v), loc))\"\n\n| exec_instr_New:\n  \"exec_instr (New C) P s calldepth stk_length rs ill =\n  (let (h,stk,loc) = s;\n    a = the(new_Addr h)\n   in (h(a \\<mapsto> (blank (P\\<^bsub>wf\\<^esub>) C)), stk((calldepth,stk_length):=Addr a), loc))\"\n\n| exec_instr_Getfield:\n  \"exec_instr (Getfield F C) P s calldepth stk_length rs ill =\n  (let (h,stk,loc) = s;\n    a = the_Addr (stk (calldepth,stk_length - 1));\n    (D,fs) = the(h a)\n   in (h, stk((calldepth,stk_length - 1) := the(fs(F,C))), loc))\"\n\n| exec_instr_Putfield:\n  \"exec_instr (Putfield F C) P s calldepth stk_length rs ill =\n  (let (h,stk,loc) = s;\n    v = stk (calldepth,stk_length - 1);\n    a = the_Addr (stk (calldepth,stk_length - 2));\n    (D,fs) = the(h a)\n   in (h(a \\<mapsto> (D,fs((F,C) \\<mapsto> v))), stk, loc))\"\n\n| exec_instr_Checkcast:\n  \"exec_instr (Checkcast C) P s calldepth stk_length rs ill = s\"\n\n| exec_instr_Pop:\n  \"exec_instr (Pop) P s calldepth stk_length rs ill = s\"\n\n| exec_instr_IAdd:\n  \"exec_instr (IAdd) P s calldepth stk_length rs ill =\n  (let (h,stk,loc) = s;\n    i\\<^sub>1 = the_Intg (stk (calldepth, stk_length - 1));\n    i\\<^sub>2 = the_Intg (stk (calldepth, stk_length - 2))\n   in (h, stk((calldepth, stk_length - 2) := Intg (i\\<^sub>1 + i\\<^sub>2)), loc))\"\n\n| exec_instr_IfFalse:\n  \"exec_instr (IfFalse b) P s calldepth stk_length rs ill = s\"\n\n| exec_instr_CmpEq:\n  \"exec_instr (CmpEq) P s calldepth stk_length rs ill =\n  (let (h,stk,loc) = s;\n    v\\<^sub>1 = stk (calldepth, stk_length - 1);\n    v\\<^sub>2 = stk (calldepth, stk_length - 2)\n   in (h, stk((calldepth, stk_length - 2) := Bool (v\\<^sub>1 = v\\<^sub>2)), loc))\"\n\n| exec_instr_Goto:\n  \"exec_instr (Goto i) P s calldepth stk_length rs ill = s\"\n  \n| exec_instr_Throw:\n  \"exec_instr (Throw) P s calldepth stk_length rs ill = s\"\n\n| exec_instr_Invoke:\n  \"exec_instr (Invoke M n) P s calldepth stk_length rs invoke_loc_length =\n  (let (h,stk,loc) = s;\n    loc' = (\\<lambda>(a,b). if (a \\<noteq> Suc calldepth \\<or> b \\<ge> invoke_loc_length) then loc(a,b) else\n                      (if (b \\<le> n) then stk(calldepth, stk_length - (Suc n - b)) else arbitrary))\n   in (h,stk,loc'))\"\n\n| exec_instr_Return:\n  \"exec_instr (Return) P s calldepth stk_length ret_stk_length ill =\n  (if (calldepth = 0)\n    then s\n    else\n    (let (h,stk,loc) = s;\n      v = stk(calldepth, stk_length - 1)\n     in (h,stk((calldepth - 1, ret_stk_length - 1) := v),loc))\n  )\""], ["", "subsubsection \\<open>length of stack and local variables\\<close>"], ["", "text \\<open>The following terms extract the stack length at a given program point\nfrom the well-typing of the given program\\<close>"], ["", "abbreviation stkLength :: \"wf_jvmprog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> pc \\<Rightarrow> nat\"\n  where\n  \"stkLength P C M pc \\<equiv> length (fst(the(((P\\<^bsub>\\<Phi>\\<^esub>) C M)!pc)))\""], ["", "abbreviation locLength :: \"wf_jvmprog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> pc \\<Rightarrow> nat\"\n  where\n  \"locLength P C M pc \\<equiv> length (snd(the(((P\\<^bsub>\\<Phi>\\<^esub>) C M)!pc)))\""], ["", "subsubsection \\<open>Conversion functions\\<close>"], ["", "text \\<open>\nThis function takes a natural number n and a function f with domain \\<open>nat\\<close>\nand creates the array [f 0, f 1, f 2, ..., f (n - 1)].\n\nThis is used for extracting the array of local variables\n\\<close>"], ["", "(*\nfun locs :: \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> 'a list\"\nwhere\n  \"locs 0 loc = []\"\n| \"locs (Suc n) loc = (locs n loc)@[loc n]\"\n*)"], ["", "abbreviation locs :: \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> 'a list\"\nwhere \"locs n loc \\<equiv> map loc [0..<n]\""], ["", "text \\<open>\nThis function takes a natural number n and a function f with domain \\<open>nat\\<close>\nand creates the array [f (n - 1), ..., f 1, f 0].\n\nThis is used for extracting the stack as a list\n\\<close>"], ["", "(*\nfun stks :: \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> 'a list\"\nwhere\n  \"stks 0 stk = []\"\n| \"stks (Suc n) stk = (stk n)#(stks n stk)\"\n*)"], ["", "abbreviation stks :: \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> 'a list\"\nwhere \"stks n stk \\<equiv> map stk (rev [0..<n])\""], ["", "text \\<open>\nThis function creates a list of the arrays for local variables from the given state\ncorresponding to the given callstack\n\\<close>"], ["", "fun locss :: \"wf_jvmprog \\<Rightarrow> callstack \\<Rightarrow> ((nat \\<times> nat) \\<Rightarrow> 'a) \\<Rightarrow> 'a list list\"\nwhere\n  \"locss P [] loc = []\"\n| \"locss P ((C,M,pc)#cs) loc =\n    (locs (locLength P C M pc) (\\<lambda>a. loc (length cs, a)))#(locss P cs loc)\""], ["", "text \\<open>\nThis function creates a list of the (methods') stacks from the given state\ncorresponding to the given callstack\n\\<close>"], ["", "fun stkss :: \"wf_jvmprog \\<Rightarrow> callstack \\<Rightarrow> ((nat \\<times> nat) \\<Rightarrow> 'a) \\<Rightarrow> 'a list list\"\nwhere\n  \"stkss P [] stk = []\"\n| \"stkss P ((C,M,pc)#cs) stk =\n  (stks (stkLength P C M pc) (\\<lambda>a. stk (length cs, a)))#(stkss P cs stk)\""], ["", "text \\<open>Given a callstack and a state, this abbreviation converts the state\nto Jinja's state representation\n\\<close>"], ["", "abbreviation state_to_jvm_state :: \"wf_jvmprog \\<Rightarrow> callstack \\<Rightarrow> state \\<Rightarrow> jvm_state\"\nwhere \"state_to_jvm_state P cs s \\<equiv> \n  (None, heap_of s, zip (stkss P cs (stk_of s)) (zip (locss P cs (loc_of s)) cs))\""], ["", "text \\<open>This function extracts the call stack from a given frame stack (as it is given\nby Jinja's state representation)\n\\<close>"], ["", "definition framestack_to_callstack :: \"frame list \\<Rightarrow> callstack\"\nwhere \"framestack_to_callstack frs \\<equiv> map snd (map snd frs)\""], ["", "subsubsection \\<open>State Conformance\\<close>"], ["", "text \\<open>Now we lift byte code verifier conformance to our state representation\\<close>"], ["", "definition bv_conform :: \"wf_jvmprog \\<Rightarrow> callstack \\<Rightarrow> state \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile>\\<^bsub>BV\\<^esub> _ \\<surd>\")\nwhere \"P,cs \\<turnstile>\\<^bsub>BV\\<^esub> s \\<surd> \\<equiv> correct_state (P\\<^bsub>wf\\<^esub>) (P\\<^bsub>\\<Phi>\\<^esub>) (state_to_jvm_state P cs s)\""], ["", "subsubsection \\<open>Statically determine catch-block\\<close>"], ["", "text \\<open>This function is equivalent to Jinja's \\<open>find_handler\\<close> function\\<close>"], ["", "fun find_handler_for :: \"wf_jvmprog \\<Rightarrow> cname \\<Rightarrow> callstack \\<Rightarrow> callstack\"\nwhere\n  \"find_handler_for P C [] = []\"\n| \"find_handler_for P C (c#cs) = (let (C',M',pc') = c in\n     (case match_ex_table (P\\<^bsub>wf\\<^esub>) C pc' (ex_table_of (P\\<^bsub>wf\\<^esub>) C' M') of\n          None \\<Rightarrow> find_handler_for P C cs\n        | Some pc_d \\<Rightarrow> (C', M', fst pc_d)#cs))\""], ["", "subsection \\<open>Simplification lemmas\\<close>"], ["", "lemma find_handler_decr [simp]: \"find_handler_for P Exc cs \\<noteq> c#cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_handler_for P Exc cs \\<noteq> c # cs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. find_handler_for P Exc cs = c # cs \\<Longrightarrow> False", "assume \"find_handler_for P Exc cs = c#cs\""], ["proof (state)\nthis:\n  find_handler_for P Exc cs = c # cs\n\ngoal (1 subgoal):\n 1. find_handler_for P Exc cs = c # cs \\<Longrightarrow> False", "hence \"length cs < length (find_handler_for P Exc cs)\""], ["proof (prove)\nusing this:\n  find_handler_for P Exc cs = c # cs\n\ngoal (1 subgoal):\n 1. length cs < length (find_handler_for P Exc cs)", "by simp"], ["proof (state)\nthis:\n  length cs < length (find_handler_for P Exc cs)\n\ngoal (1 subgoal):\n 1. find_handler_for P Exc cs = c # cs \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  length cs < length (find_handler_for P Exc cs)\n\ngoal (1 subgoal):\n 1. False", "by (induct cs, auto)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma locs_length [simp]: \"length (locs n loc) = n\"\n  by (induct n) auto\n\nlemma stks_length [simp]: \"length (stks n stk) = n\"\n  by (induct n) auto\n*)"], ["", "lemma stkss_length [simp]: \"length (stkss P cs stk) = length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (stkss P cs stk) = length cs", "by (induct cs) auto"], ["", "lemma locss_length [simp]: \"length (locss P cs loc) = length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (locss P cs loc) = length cs", "by (induct cs) auto"], ["", "(*\nlemma nth_stks: \"b < n \\<Longrightarrow> stks n stk ! b = stk(n - Suc b)\"\n  by (auto simp: rev_nth)\nproof (induct n arbitrary: b)\n  case (0 b)\n  thus ?case by simp\nnext\n  case (Suc n b)\n  thus ?case\n    by (auto simp: nth_Cons' less_Suc_eq)\nqed\n*)"], ["", "lemma nth_stkss: \n  \"\\<lbrakk> a < length cs; b < length (stkss P cs stk ! (length cs - Suc a)) \\<rbrakk>\n  \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) ! \n    (length (stkss P cs stk ! (length cs - Suc a)) - Suc b) = stk (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < length cs;\n     b < length (stkss P cs stk ! (length cs - Suc a))\\<rbrakk>\n    \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) !\n                      (length (stkss P cs stk ! (length cs - Suc a)) -\n                       Suc b) =\n                      stk (a, b)", "proof (induct cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a < length [];\n     b < length (stkss P [] stk ! (length [] - Suc a))\\<rbrakk>\n    \\<Longrightarrow> stkss P [] stk ! (length [] - Suc a) !\n                      (length (stkss P [] stk ! (length [] - Suc a)) -\n                       Suc b) =\n                      stk (a, b)\n 2. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (stkss P cs stk ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) !\n                                  (length\n                                    (stkss P cs stk ! (length cs - Suc a)) -\n                                   Suc b) =\n                                  stk (a, b);\n        a < length (aa # cs);\n        b < length\n             (stkss P (aa # cs) stk ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> stkss P (aa # cs) stk !\n                         (length (aa # cs) - Suc a) !\n                         (length\n                           (stkss P (aa # cs) stk !\n                            (length (aa # cs) - Suc a)) -\n                          Suc b) =\n                         stk (a, b)", "case Nil"], ["proof (state)\nthis:\n  a < length []\n  b < length (stkss P [] stk ! (length [] - Suc a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a < length [];\n     b < length (stkss P [] stk ! (length [] - Suc a))\\<rbrakk>\n    \\<Longrightarrow> stkss P [] stk ! (length [] - Suc a) !\n                      (length (stkss P [] stk ! (length [] - Suc a)) -\n                       Suc b) =\n                      stk (a, b)\n 2. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (stkss P cs stk ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) !\n                                  (length\n                                    (stkss P cs stk ! (length cs - Suc a)) -\n                                   Suc b) =\n                                  stk (a, b);\n        a < length (aa # cs);\n        b < length\n             (stkss P (aa # cs) stk ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> stkss P (aa # cs) stk !\n                         (length (aa # cs) - Suc a) !\n                         (length\n                           (stkss P (aa # cs) stk !\n                            (length (aa # cs) - Suc a)) -\n                          Suc b) =\n                         stk (a, b)", "thus ?case"], ["proof (prove)\nusing this:\n  a < length []\n  b < length (stkss P [] stk ! (length [] - Suc a))\n\ngoal (1 subgoal):\n 1. stkss P [] stk ! (length [] - Suc a) !\n    (length (stkss P [] stk ! (length [] - Suc a)) - Suc b) =\n    stk (a, b)", "by (simp add: nth_Cons')"], ["proof (state)\nthis:\n  stkss P [] stk ! (length [] - Suc a) !\n  (length (stkss P [] stk ! (length [] - Suc a)) - Suc b) =\n  stk (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (stkss P cs stk ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) !\n                                  (length\n                                    (stkss P cs stk ! (length cs - Suc a)) -\n                                   Suc b) =\n                                  stk (a, b);\n        a < length (aa # cs);\n        b < length\n             (stkss P (aa # cs) stk ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> stkss P (aa # cs) stk !\n                         (length (aa # cs) - Suc a) !\n                         (length\n                           (stkss P (aa # cs) stk !\n                            (length (aa # cs) - Suc a)) -\n                          Suc b) =\n                         stk (a, b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (stkss P cs stk ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) !\n                                  (length\n                                    (stkss P cs stk ! (length cs - Suc a)) -\n                                   Suc b) =\n                                  stk (a, b);\n        a < length (aa # cs);\n        b < length\n             (stkss P (aa # cs) stk ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> stkss P (aa # cs) stk !\n                         (length (aa # cs) - Suc a) !\n                         (length\n                           (stkss P (aa # cs) stk !\n                            (length (aa # cs) - Suc a)) -\n                          Suc b) =\n                         stk (a, b)", "case (Cons aa cs)"], ["proof (state)\nthis:\n  \\<lbrakk>a < length cs;\n   b < length (stkss P cs stk ! (length cs - Suc a))\\<rbrakk>\n  \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) !\n                    (length (stkss P cs stk ! (length cs - Suc a)) -\n                     Suc b) =\n                    stk (a, b)\n  a < length (aa # cs)\n  b < length (stkss P (aa # cs) stk ! (length (aa # cs) - Suc a))\n\ngoal (1 subgoal):\n 1. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (stkss P cs stk ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) !\n                                  (length\n                                    (stkss P cs stk ! (length cs - Suc a)) -\n                                   Suc b) =\n                                  stk (a, b);\n        a < length (aa # cs);\n        b < length\n             (stkss P (aa # cs) stk ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> stkss P (aa # cs) stk !\n                         (length (aa # cs) - Suc a) !\n                         (length\n                           (stkss P (aa # cs) stk !\n                            (length (aa # cs) - Suc a)) -\n                          Suc b) =\n                         stk (a, b)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < length cs;\n   b < length (stkss P cs stk ! (length cs - Suc a))\\<rbrakk>\n  \\<Longrightarrow> stkss P cs stk ! (length cs - Suc a) !\n                    (length (stkss P cs stk ! (length cs - Suc a)) -\n                     Suc b) =\n                    stk (a, b)\n  a < length (aa # cs)\n  b < length (stkss P (aa # cs) stk ! (length (aa # cs) - Suc a))\n\ngoal (1 subgoal):\n 1. stkss P (aa # cs) stk ! (length (aa # cs) - Suc a) !\n    (length (stkss P (aa # cs) stk ! (length (aa # cs) - Suc a)) - Suc b) =\n    stk (a, b)", "by (cases aa, auto simp add: nth_Cons' rev_nth less_Suc_eq)"], ["proof (state)\nthis:\n  stkss P (aa # cs) stk ! (length (aa # cs) - Suc a) !\n  (length (stkss P (aa # cs) stk ! (length (aa # cs) - Suc a)) - Suc b) =\n  stk (a, b)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma nth_locs: \"b < n \\<Longrightarrow> locs n loc ! b = loc b\"\nproof (induct n)\n  case 0\n  thus ?case by simp\nnext\n  case (Suc n)\n  thus ?case\n    by (auto simp: nth_append less_Suc_eq)\nqed\n*)"], ["", "lemma nth_locss:\n  \"\\<lbrakk> a < length cs; b < length (locss P cs loc ! (length cs - Suc a)) \\<rbrakk>\n  \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b = loc (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < length cs;\n     b < length (locss P cs loc ! (length cs - Suc a))\\<rbrakk>\n    \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b = loc (a, b)", "proof (induct cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a < length [];\n     b < length (locss P [] loc ! (length [] - Suc a))\\<rbrakk>\n    \\<Longrightarrow> locss P [] loc ! (length [] - Suc a) ! b = loc (a, b)\n 2. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (locss P cs loc ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b =\n                                  loc (a, b);\n        a < length (aa # cs);\n        b < length\n             (locss P (aa # cs) loc ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> locss P (aa # cs) loc !\n                         (length (aa # cs) - Suc a) !\n                         b =\n                         loc (a, b)", "case Nil"], ["proof (state)\nthis:\n  a < length []\n  b < length (locss P [] loc ! (length [] - Suc a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a < length [];\n     b < length (locss P [] loc ! (length [] - Suc a))\\<rbrakk>\n    \\<Longrightarrow> locss P [] loc ! (length [] - Suc a) ! b = loc (a, b)\n 2. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (locss P cs loc ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b =\n                                  loc (a, b);\n        a < length (aa # cs);\n        b < length\n             (locss P (aa # cs) loc ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> locss P (aa # cs) loc !\n                         (length (aa # cs) - Suc a) !\n                         b =\n                         loc (a, b)", "thus ?case"], ["proof (prove)\nusing this:\n  a < length []\n  b < length (locss P [] loc ! (length [] - Suc a))\n\ngoal (1 subgoal):\n 1. locss P [] loc ! (length [] - Suc a) ! b = loc (a, b)", "by (simp add: nth_Cons')"], ["proof (state)\nthis:\n  locss P [] loc ! (length [] - Suc a) ! b = loc (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (locss P cs loc ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b =\n                                  loc (a, b);\n        a < length (aa # cs);\n        b < length\n             (locss P (aa # cs) loc ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> locss P (aa # cs) loc !\n                         (length (aa # cs) - Suc a) !\n                         b =\n                         loc (a, b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (locss P cs loc ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b =\n                                  loc (a, b);\n        a < length (aa # cs);\n        b < length\n             (locss P (aa # cs) loc ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> locss P (aa # cs) loc !\n                         (length (aa # cs) - Suc a) !\n                         b =\n                         loc (a, b)", "case (Cons aa cs)"], ["proof (state)\nthis:\n  \\<lbrakk>a < length cs;\n   b < length (locss P cs loc ! (length cs - Suc a))\\<rbrakk>\n  \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b = loc (a, b)\n  a < length (aa # cs)\n  b < length (locss P (aa # cs) loc ! (length (aa # cs) - Suc a))\n\ngoal (1 subgoal):\n 1. \\<And>aa cs.\n       \\<lbrakk>\\<lbrakk>a < length cs;\n                 b < length (locss P cs loc ! (length cs - Suc a))\\<rbrakk>\n                \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b =\n                                  loc (a, b);\n        a < length (aa # cs);\n        b < length\n             (locss P (aa # cs) loc ! (length (aa # cs) - Suc a))\\<rbrakk>\n       \\<Longrightarrow> locss P (aa # cs) loc !\n                         (length (aa # cs) - Suc a) !\n                         b =\n                         loc (a, b)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < length cs;\n   b < length (locss P cs loc ! (length cs - Suc a))\\<rbrakk>\n  \\<Longrightarrow> locss P cs loc ! (length cs - Suc a) ! b = loc (a, b)\n  a < length (aa # cs)\n  b < length (locss P (aa # cs) loc ! (length (aa # cs) - Suc a))\n\ngoal (1 subgoal):\n 1. locss P (aa # cs) loc ! (length (aa # cs) - Suc a) ! b = loc (a, b)", "by (cases aa, auto simp: nth_Cons' (* nth_locs *) less_Suc_eq)"], ["proof (state)\nthis:\n  locss P (aa # cs) loc ! (length (aa # cs) - Suc a) ! b = loc (a, b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hd_stks [simp]: \"n \\<noteq> 0 \\<Longrightarrow> hd (stks n stk) = stk(n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> hd (stks n stk) = stk (n - 1)", "by (cases n, simp_all)"], ["", "lemma hd_tl_stks: \"n > 1 \\<Longrightarrow> hd (tl (stks n stk)) = stk(n - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> hd (tl (stks n stk)) = stk (n - 2)", "by (cases n, auto)"], ["", "(*\nlemma stks_purge:\n  \"d \\<ge> b \\<Longrightarrow> stks b (stk(d := e)) = stks b stk\"\n  by (induct b, auto)\n\nlemma stks_purge':\n  \"d \\<ge> b \\<Longrightarrow> stks b (\\<lambda>x. if x = d then e else stk x) = stks b stk\"\n  by (fold fun_upd_def, simp only: stks_purge)\n*)"], ["", "lemma stkss_purge:\n  \"length cs \\<le> a \\<Longrightarrow> stkss P cs (stk((a,b) := c)) = stkss P cs stk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cs \\<le> a \\<Longrightarrow>\n    stkss P cs (stk((a, b) := c)) = stkss P cs stk", "by (induct cs, auto (* simp: stks_purge *))"], ["", "lemma stkss_purge':\n  \"length cs \\<le> a \\<Longrightarrow> stkss P cs (\\<lambda>s. if s = (a, b) then c else stk s) = stkss P cs stk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cs \\<le> a \\<Longrightarrow>\n    stkss P cs (\\<lambda>s. if s = (a, b) then c else stk s) =\n    stkss P cs stk", "by (fold fun_upd_def, simp only: stkss_purge)"], ["", "(*\nlemma locs_purge:\n  \"d \\<ge> b \\<Longrightarrow> locs b (loc(d := e)) = locs b loc\"\n  by (induct b, auto)\n\nlemma locs_purge':\n  \"d \\<ge> b \\<Longrightarrow> locs b (\\<lambda>b. if b = d then e else loc b) = locs b loc\"\n  by (fold fun_upd_def, simp only: locs_purge)\n*)"], ["", "lemma locss_purge:\n  \"length cs \\<le> a \\<Longrightarrow> locss P cs (loc((a,b) := c)) = locss P cs loc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cs \\<le> a \\<Longrightarrow>\n    locss P cs (loc((a, b) := c)) = locss P cs loc", "by (induct cs, auto (*simp: locs_purge *))"], ["", "lemma locss_purge':\n  \"length cs \\<le> a \\<Longrightarrow> locss P cs (\\<lambda>s. if s = (a, b) then c else loc s) = locss P cs loc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cs \\<le> a \\<Longrightarrow>\n    locss P cs (\\<lambda>s. if s = (a, b) then c else loc s) =\n    locss P cs loc", "by (fold fun_upd_def, simp only: locss_purge)"], ["", "lemma locs_pullout [simp]:\n  \"locs b (loc(n := e)) = (locs b loc) [n := e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locs b (loc(n := e)) = (locs b loc)[n := e]", "proof (induct b)"], ["proof (state)\ngoal (2 subgoals):\n 1. locs 0 (loc(n := e)) = (locs 0 loc)[n := e]\n 2. \\<And>b.\n       locs b (loc(n := e)) = (locs b loc)[n := e] \\<Longrightarrow>\n       locs (Suc b) (loc(n := e)) = (locs (Suc b) loc)[n := e]", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. locs 0 (loc(n := e)) = (locs 0 loc)[n := e]\n 2. \\<And>b.\n       locs b (loc(n := e)) = (locs b loc)[n := e] \\<Longrightarrow>\n       locs (Suc b) (loc(n := e)) = (locs (Suc b) loc)[n := e]", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. locs 0 (loc(n := e)) = (locs 0 loc)[n := e]", "by simp"], ["proof (state)\nthis:\n  locs 0 (loc(n := e)) = (locs 0 loc)[n := e]\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       locs b (loc(n := e)) = (locs b loc)[n := e] \\<Longrightarrow>\n       locs (Suc b) (loc(n := e)) = (locs (Suc b) loc)[n := e]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       locs b (loc(n := e)) = (locs b loc)[n := e] \\<Longrightarrow>\n       locs (Suc b) (loc(n := e)) = (locs (Suc b) loc)[n := e]", "case (Suc b)"], ["proof (state)\nthis:\n  locs b (loc(n := e)) = (locs b loc)[n := e]\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       locs b (loc(n := e)) = (locs b loc)[n := e] \\<Longrightarrow>\n       locs (Suc b) (loc(n := e)) = (locs (Suc b) loc)[n := e]", "thus ?case"], ["proof (prove)\nusing this:\n  locs b (loc(n := e)) = (locs b loc)[n := e]\n\ngoal (1 subgoal):\n 1. locs (Suc b) (loc(n := e)) = (locs (Suc b) loc)[n := e]", "by (cases \"n - b\", auto simp: list_update_append not_less_eq less_Suc_eq)"], ["proof (state)\nthis:\n  locs (Suc b) (loc(n := e)) = (locs (Suc b) loc)[n := e]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma locs_pullout' [simp]:\n  \"locs b (\\<lambda>a. if a = n then e else loc (c, a)) = (locs b (\\<lambda>a. loc (c, a))) [n := e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locs b (\\<lambda>a. if a = n then e else loc (c, a)) =\n    (locs b (\\<lambda>a. loc (c, a)))[n := e]", "by (fold fun_upd_def) simp"], ["", "lemma stks_pullout:\n  \"n < b \\<Longrightarrow> stks b (stk(n := e)) = (stks b stk) [b - Suc n := e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < b \\<Longrightarrow>\n    stks b (stk(n := e)) = (stks b stk)[b - Suc n := e]", "proof (induct b)"], ["proof (state)\ngoal (2 subgoals):\n 1. n < 0 \\<Longrightarrow>\n    stks 0 (stk(n := e)) = (stks 0 stk)[0 - Suc n := e]\n 2. \\<And>b.\n       \\<lbrakk>n < b \\<Longrightarrow>\n                stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n        n < Suc b\\<rbrakk>\n       \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                         [Suc b - Suc n := e]", "case 0"], ["proof (state)\nthis:\n  n < 0\n\ngoal (2 subgoals):\n 1. n < 0 \\<Longrightarrow>\n    stks 0 (stk(n := e)) = (stks 0 stk)[0 - Suc n := e]\n 2. \\<And>b.\n       \\<lbrakk>n < b \\<Longrightarrow>\n                stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n        n < Suc b\\<rbrakk>\n       \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                         [Suc b - Suc n := e]", "thus ?case"], ["proof (prove)\nusing this:\n  n < 0\n\ngoal (1 subgoal):\n 1. stks 0 (stk(n := e)) = (stks 0 stk)[0 - Suc n := e]", "by simp"], ["proof (state)\nthis:\n  stks 0 (stk(n := e)) = (stks 0 stk)[0 - Suc n := e]\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>n < b \\<Longrightarrow>\n                stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n        n < Suc b\\<rbrakk>\n       \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                         [Suc b - Suc n := e]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>n < b \\<Longrightarrow>\n                stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n        n < Suc b\\<rbrakk>\n       \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                         [Suc b - Suc n := e]", "case (Suc b)"], ["proof (state)\nthis:\n  n < b \\<Longrightarrow>\n  stks b (stk(n := e)) = (stks b stk)[b - Suc n := e]\n  n < Suc b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>n < b \\<Longrightarrow>\n                stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n        n < Suc b\\<rbrakk>\n       \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                         [Suc b - Suc n := e]", "thus ?case"], ["proof (prove)\nusing this:\n  n < b \\<Longrightarrow>\n  stks b (stk(n := e)) = (stks b stk)[b - Suc n := e]\n  n < Suc b\n\ngoal (1 subgoal):\n 1. stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)[Suc b - Suc n := e]", "proof (cases \"b = n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < b \\<Longrightarrow>\n             stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n     n < Suc b; b = n\\<rbrakk>\n    \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                      [Suc b - Suc n := e]\n 2. \\<lbrakk>n < b \\<Longrightarrow>\n             stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n     n < Suc b; b \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                      [Suc b - Suc n := e]", "case True"], ["proof (state)\nthis:\n  b = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < b \\<Longrightarrow>\n             stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n     n < Suc b; b = n\\<rbrakk>\n    \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                      [Suc b - Suc n := e]\n 2. \\<lbrakk>n < b \\<Longrightarrow>\n             stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n     n < Suc b; b \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                      [Suc b - Suc n := e]", "with Suc"], ["proof (chain)\npicking this:\n  n < b \\<Longrightarrow>\n  stks b (stk(n := e)) = (stks b stk)[b - Suc n := e]\n  n < Suc b\n  b = n", "show ?thesis"], ["proof (prove)\nusing this:\n  n < b \\<Longrightarrow>\n  stks b (stk(n := e)) = (stks b stk)[b - Suc n := e]\n  n < Suc b\n  b = n\n\ngoal (1 subgoal):\n 1. stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)[Suc b - Suc n := e]", "by auto"], ["proof (state)\nthis:\n  stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)[Suc b - Suc n := e]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < b \\<Longrightarrow>\n             stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n     n < Suc b; b \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                      [Suc b - Suc n := e]", "(*      by (auto simp: stks_purge') *)"], ["proof (state)\nthis:\n  stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)[Suc b - Suc n := e]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < b \\<Longrightarrow>\n             stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n     n < Suc b; b \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                      [Suc b - Suc n := e]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < b \\<Longrightarrow>\n             stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n     n < Suc b; b \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                      [Suc b - Suc n := e]", "case False"], ["proof (state)\nthis:\n  b \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < b \\<Longrightarrow>\n             stks b (stk(n := e)) = (stks b stk)[b - Suc n := e];\n     n < Suc b; b \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)\n                      [Suc b - Suc n := e]", "with Suc"], ["proof (chain)\npicking this:\n  n < b \\<Longrightarrow>\n  stks b (stk(n := e)) = (stks b stk)[b - Suc n := e]\n  n < Suc b\n  b \\<noteq> n", "show ?thesis"], ["proof (prove)\nusing this:\n  n < b \\<Longrightarrow>\n  stks b (stk(n := e)) = (stks b stk)[b - Suc n := e]\n  n < Suc b\n  b \\<noteq> n\n\ngoal (1 subgoal):\n 1. stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)[Suc b - Suc n := e]", "by (cases \"b - n\") (auto intro!: nth_equalityI simp: nth_list_update)"], ["proof (state)\nthis:\n  stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)[Suc b - Suc n := e]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  stks (Suc b) (stk(n := e)) = (stks (Suc b) stk)[Suc b - Suc n := e]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_tl : \"xs \\<noteq> [] \\<Longrightarrow> tl xs ! n = xs ! (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> tl xs ! n = xs ! Suc n", "by (cases xs, simp_all)"], ["", "lemma f2c_Nil [simp]: \"framestack_to_callstack [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. framestack_to_callstack [] = []", "by (simp add: framestack_to_callstack_def)"], ["", "lemma f2c_Cons [simp]:\n  \"framestack_to_callstack ((stk,loc,C,M,pc)#frs) = (C,M,pc)#(framestack_to_callstack frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. framestack_to_callstack ((stk, loc, C, M, pc) # frs) =\n    (C, M, pc) # framestack_to_callstack frs", "by (simp add: framestack_to_callstack_def)"], ["", "lemma f2c_length [simp]:\n  \"length (framestack_to_callstack frs) = length frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (framestack_to_callstack frs) = length frs", "by (simp add: framestack_to_callstack_def)"], ["", "lemma f2c_s2jvm_id [simp]:\n  \"framestack_to_callstack\n    (snd(snd(state_to_jvm_state P cs s))) =\n  cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. framestack_to_callstack (snd (snd (state_to_jvm_state P cs s))) = cs", "by (cases s, simp add: framestack_to_callstack_def)"], ["", "lemma f2c_s2jvm_id' [simp]:\n  \"framestack_to_callstack\n  (zip (stkss P cs stk) (zip (locss P cs loc) cs)) = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. framestack_to_callstack\n     (zip (stkss P cs stk) (zip (locss P cs loc) cs)) =\n    cs", "by (simp add: framestack_to_callstack_def)"], ["", "lemma f2c_append [simp]:\n  \"framestack_to_callstack (frs @ frs') =\n  (framestack_to_callstack frs) @ (framestack_to_callstack frs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. framestack_to_callstack (frs @ frs') =\n    framestack_to_callstack frs @ framestack_to_callstack frs'", "by (simp add: framestack_to_callstack_def)"], ["", "subsection \\<open>CFG construction\\<close>"], ["", "subsection \\<open>Datatypes\\<close>"], ["", "text \\<open>Nodes are labeled with a callstack and an optional tuple (consisting of\na callstack and a flag).\n\nThe first callstack determines the current program point (i.e. the next statement\nto execute). If the second parameter is not None, we are at an intermediate state,\nwhere the target of the instruction is determined (the second callstack)\nand the flag is set to whether an exception is thrown or not.\n\\<close>"], ["", "datatype j_node =\n   Entry  (\"'('_Entry'_')\")\n | Node \"callstack\" \"(callstack \\<times> bool) option\" (\"'('_ _,_ '_')\")"], ["", "text \\<open>The empty callstack indicates the exit node\\<close>"], ["", "abbreviation j_node_Exit :: \"j_node\" (\"'('_Exit'_')\")\nwhere \"j_node_Exit \\<equiv> (_ [],None _)\""], ["", "text \\<open>An edge is a triple, consisting of two nodes and the edge kind\\<close>"], ["", "type_synonym j_edge = \"(j_node \\<times> state edge_kind \\<times> j_node)\""], ["", "subsection \\<open>CFG\\<close>"], ["", "text \\<open>\nThe CFG is constructed by a case analysis on the instructions and\ntheir different behavior in different states. E.g. the exceptional behavior of\n{\\sc New}, if there is no more space in the heap, vs. the normal behavior.\n\nNote: The set of edges defined by this predicate is a first approximation to the\nreal set of edges in the CFG. We later (theory JVMInterpretation) add some well-formedness\nrequirements to the nodes.\n\\<close>"], ["", "inductive JVM_CFG :: \"jvmprog \\<Rightarrow> j_node \\<Rightarrow> state edge_kind \\<Rightarrow> j_node \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ -_\\<rightarrow> _\")\nwhere\n  JCFG_EntryExit:\n  \"prog \\<turnstile> (_Entry_) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\"\n\n| JCFG_EntryStart:\n  \"prog = (P, C0, Main) \\<Longrightarrow> prog \\<turnstile> (_Entry_) -(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow> (_ [(C0, Main, 0)],None _)\"\n\n| JCFG_ReturnExit:\n  \"\\<lbrakk> prog = (P,C0,Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = Return \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ [(C, M, pc)],None _) -\\<Up>id\\<rightarrow> (_Exit_)\"\n\n| JCFG_Straight_NoExc:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    instrs_of (P\\<^bsub>wf\\<^esub>) C M ! pc \\<in> {Load idx, Store idx, Push val, Pop, IAdd, CmpEq};\n    ek = \\<Up>(\\<lambda>s. exec_instr ((instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc) P s\n                          (length cs) (stkLength P C M pc) arbitrary arbitrary) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, Suc pc)#cs,None _)\"\n\n| JCFG_New_Normal_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (New Cl);\n    ek = (\\<lambda>(h,stk,loc). new_Addr h \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>((C, M, Suc pc)#cs,False)\\<rfloor> _)\"\n\n| JCFG_New_Normal_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (New Cl);\n    ek = \\<Up>(\\<lambda>s. exec_instr (New Cl) P s (length cs) (stkLength P C M pc) arbitrary arbitrary) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((C, M, Suc pc)#cs, False)\\<rfloor> _) -ek\\<rightarrow> (_ (C, M, Suc pc)#cs,None _)\"\n\n| JCFG_New_Exc_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (New Cl);\n    find_handler_for P OutOfMemory ((C, M, pc)#cs) = cs';\n    ek = (\\<lambda>(h,stk,loc). new_Addr h = None)\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>(cs',True)\\<rfloor> _)\"\n\n| JCFG_New_Exc_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (New Cl);\n    find_handler_for P OutOfMemory ((C, M, pc)#cs) = (C', M', pc')#cs';\n    ek = \\<Up>(\\<lambda>(h,stk,loc).\n     (h,\n      stk((length cs',(stkLength P C' M' pc') - 1) := Addr (addr_of_sys_xcpt OutOfMemory)),\n      loc)\n     ) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((C', M', pc')#cs', True)\\<rfloor> _) -ek\\<rightarrow> (_ (C', M', pc')#cs',None _)\"\n\n| JCFG_New_Exc_Exit:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (New Cl);\n    find_handler_for P OutOfMemory ((C, M, pc)#cs) = [] \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>([], True)\\<rfloor> _) -\\<Up>id\\<rightarrow> (_Exit_)\"\n\n| JCFG_Getfield_Normal_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Getfield Fd Cl);\n    ek = (\\<lambda>(h,stk,loc).  stk(length cs, stkLength P C M pc - 1) \\<noteq> Null)\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>((C, M, Suc pc)#cs, False)\\<rfloor> _)\"\n\n| JCFG_Getfield_Normal_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Getfield Fd Cl);\n    ek = \\<Up>(\\<lambda>s. exec_instr (Getfield Fd Cl) P s (length cs) (stkLength P C M pc)\n                          arbitrary arbitrary) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((C, M, Suc pc)#cs, False)\\<rfloor> _) -ek\\<rightarrow> (_ (C, M, Suc pc)#cs,None _)\"\n\n| JCFG_Getfield_Exc_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Getfield Fd Cl);\n    find_handler_for P NullPointer ((C, M, pc)#cs) = cs';\n    ek = (\\<lambda>(h,stk,loc). stk(length cs, stkLength P C M pc - 1) = Null)\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>(cs', True)\\<rfloor> _)\"\n\n| JCFG_Getfield_Exc_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Getfield Fd Cl);\n    find_handler_for P NullPointer ((C, M, pc)#cs) = (C', M', pc')#cs';\n    ek =  \\<Up>(\\<lambda>(h,stk,loc).\n     (h,\n      stk((length cs',(stkLength P C' M' pc') - 1) := Addr (addr_of_sys_xcpt NullPointer)),\n      loc)\n     ) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((C', M', pc')#cs', True)\\<rfloor> _) -ek\\<rightarrow> (_ (C', M', pc')#cs',None _)\"\n\n| JCFG_Getfield_Exc_Exit:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Getfield Fd Cl);\n    find_handler_for P NullPointer ((C, M, pc)#cs) = [] \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>([], True)\\<rfloor> _) -\\<Up>id\\<rightarrow> (_Exit_)\"\n\n| JCFG_Putfield_Normal_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Putfield Fd Cl);\n    ek = (\\<lambda>(h,stk,loc).  stk(length cs, stkLength P C M pc - 2) \\<noteq> Null)\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>((C, M, Suc pc)#cs, False)\\<rfloor> _)\"\n\n| JCFG_Putfield_Normal_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Putfield Fd Cl);\n    ek = \\<Up>(\\<lambda>s. exec_instr (Putfield Fd Cl) P s (length cs) (stkLength P C M pc)\n                          arbitrary arbitrary) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((C, M, Suc pc)#cs, False)\\<rfloor> _) -ek\\<rightarrow> (_ (C, M, Suc pc)#cs,None _)\"\n\n| JCFG_Putfield_Exc_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Putfield Fd Cl);\n    find_handler_for P NullPointer ((C, M, pc)#cs) = cs';\n    ek = (\\<lambda>(h,stk,loc). stk(length cs, stkLength P C M pc - 2) = Null)\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>(cs', True)\\<rfloor> _)\"\n\n| JCFG_Putfield_Exc_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Putfield Fd Cl);\n    find_handler_for P NullPointer ((C, M, pc)#cs) = (C', M', pc')#cs';\n    ek = \\<Up>(\\<lambda>(h,stk,loc).\n     (h,\n      stk((length cs',(stkLength P C' M' pc') - 1) := Addr (addr_of_sys_xcpt NullPointer)),\n      loc)\n     ) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((C', M', pc')#cs', True)\\<rfloor> _) -ek\\<rightarrow> (_ (C', M', pc')#cs',None _)\"\n\n| JCFG_Putfield_Exc_Exit:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Putfield Fd Cl);\n    find_handler_for P NullPointer ((C, M, pc)#cs) = [] \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>([], True)\\<rfloor> _) -\\<Up>id\\<rightarrow> (_Exit_)\"\n\n| JCFG_Checkcast_Normal_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Checkcast Cl);\n    ek = (\\<lambda>(h,stk,loc). cast_ok (P\\<^bsub>wf\\<^esub>) Cl h (stk(length cs, stkLength P C M pc - Suc 0)))\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, Suc pc)#cs,None _)\"\n\n| JCFG_Checkcast_Exc_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Checkcast Cl);\n    find_handler_for P ClassCast ((C, M, pc)#cs) = cs';\n    ek = (\\<lambda>(h,stk,loc). \\<not> cast_ok (P\\<^bsub>wf\\<^esub>) Cl h (stk(length cs, stkLength P C M pc - Suc 0)))\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>(cs', True)\\<rfloor> _)\"\n\n| JCFG_Checkcast_Exc_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Checkcast Cl);\n    find_handler_for P ClassCast ((C, M, pc)#cs) = (C', M', pc')#cs';\n    ek = \\<Up>(\\<lambda>(h,stk,loc).\n     (h,\n      stk((length cs',(stkLength P C' M' pc') - 1) := Addr (addr_of_sys_xcpt ClassCast)),\n      loc)\n     ) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((C', M', pc')#cs', True)\\<rfloor> _) -ek\\<rightarrow> (_ (C', M', pc')#cs',None _)\"\n\n| JCFG_Checkcast_Exc_Exit:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Checkcast Cl);\n    find_handler_for P ClassCast ((C, M, pc)#cs) = [] \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>([], True)\\<rfloor> _) -\\<Up>id\\<rightarrow> (_Exit_)\"\n\n| JCFG_Invoke_Normal_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Invoke M2 n);\n    cd = length cs;\n    stk_length = stkLength P C M pc;\n    ek = (\\<lambda>(h,stk,loc).\n     stk(cd, stk_length - Suc n) \\<noteq> Null \\<and>\n     fst(method (P\\<^bsub>wf\\<^esub>) (cname_of h (the_Addr(stk(cd, stk_length - Suc n)))) M2) = D\n    )\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow>\n      prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>((D, M2, 0)#(C, M, pc)#cs, False)\\<rfloor> _)\"\n\n| JCFG_Invoke_Normal_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Invoke M2 n);\n    stk_length = stkLength P C M pc;\n    loc_length = locLength P D M2 0;\n    ek = \\<Up>(\\<lambda>s. exec_instr (Invoke M2 n) P s (length cs) stk_length arbitrary loc_length)\n   \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((D, M2, 0)#(C, M, pc)#cs, False)\\<rfloor> _) -ek\\<rightarrow>\n               (_ (D, M2, 0)#(C, M, pc)#cs,None _)\"\n\n| JCFG_Invoke_Exc_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Invoke m2 n);\n    find_handler_for P NullPointer ((C, M, pc)#cs) = cs';\n    ek = (\\<lambda>(h,stk,loc). stk(length cs, stkLength P C M pc - Suc n) = Null)\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>(cs', True)\\<rfloor> _)\"\n\n| JCFG_Invoke_Exc_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Invoke M2 n);\n    find_handler_for P NullPointer ((C, M, pc)#cs) = (C', M', pc')#cs';\n    ek = \\<Up>(\\<lambda>(h,stk,loc).\n     (h,\n      stk((length cs',(stkLength P C' M' pc') - 1) := Addr (addr_of_sys_xcpt NullPointer)),\n      loc)\n     )\n   \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((C', M', pc')#cs', True)\\<rfloor> _) -ek\\<rightarrow> (_ (C', M', pc')#cs',None _)\"\n\n| JCFG_Invoke_Exc_Exit:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (Invoke M2 n);\n    find_handler_for P NullPointer ((C, M, pc)#cs) = [] \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>([], True)\\<rfloor> _) -\\<Up>id\\<rightarrow> (_Exit_)\"\n\n| JCFG_Return_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = Return;\n    stk_length = stkLength P C M pc;\n    r_stk_length = stkLength P C' M' (Suc pc');\n    ek = \\<Up>(\\<lambda>s. exec_instr Return P s (Suc (length cs)) stk_length r_stk_length arbitrary) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#(C', M', pc')#cs,None _) -ek\\<rightarrow> (_ (C', M', Suc pc')#cs,None _)\"\n\n| JCFG_Goto_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = Goto idx \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -\\<Up>id\\<rightarrow> (_ (C, M, nat (int pc + idx))#cs,None _)\"\n\n| JCFG_IfFalse_False:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (IfFalse b);\n    b \\<noteq> 1;\n    ek = (\\<lambda>(h,stk,loc). stk(length cs, stkLength P C M pc - 1) = Bool False)\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, nat (int pc + b))#cs,None _)\"\n\n| JCFG_IfFalse_Next:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = (IfFalse b);\n    ek = (\\<lambda>(h,stk,loc). stk(length cs, stkLength P C M pc - 1) \\<noteq> Bool False \\<or> b = 1)\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, Suc pc)#cs,None _)\"\n\n| JCFG_Throw_Pred:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = Throw;\n    cd = length cs;\n    stk_length = stkLength P C M pc;\n    \\<exists>Exc. find_handler_for P Exc ((C, M, pc)#cs) = cs';\n    ek = (\\<lambda>(h,stk,loc).\n      (stk(length cs, stkLength P C M pc - 1) = Null \\<and>\n        find_handler_for P NullPointer ((C, M, pc)#cs) = cs') \\<or>\n      (stk(length cs, stkLength P C M pc - 1) \\<noteq> Null \\<and>\n        find_handler_for P (cname_of h (the_Addr(stk(cd, stk_length - 1)))) ((C, M, pc)#cs) = cs')\n    )\\<^sub>\\<surd> \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,None _) -ek\\<rightarrow> (_ (C, M, pc)#cs,\\<lfloor>(cs', True)\\<rfloor> _)\"\n\n| JCFG_Throw_Update:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = Throw;\n    ek = \\<Up>(\\<lambda>(h,stk,loc).\n      (h,\n       stk((length cs',(stkLength P C' M' pc') - 1) :=\n         if (stk(length cs, stkLength P C M pc - 1) = Null) then\n           Addr (addr_of_sys_xcpt NullPointer)\n         else (stk(length cs, stkLength P C M pc - 1))),\n       loc)\n    ) \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>((C', M', pc')#cs', True)\\<rfloor> _) -ek\\<rightarrow> (_ (C', M', pc')#cs',None _)\"\n\n| JCFG_Throw_Exit:\n  \"\\<lbrakk> prog = (P, C0, Main);\n    (instrs_of (P\\<^bsub>wf\\<^esub>) C M) ! pc = Throw \\<rbrakk>\n    \\<Longrightarrow> prog \\<turnstile> (_ (C, M, pc)#cs,\\<lfloor>([],True)\\<rfloor> _) -\\<Up>id\\<rightarrow> (_Exit_)\""], ["", "subsection \\<open>CFG properties\\<close>"], ["", "lemma JVMCFG_Exit_no_sourcenode [dest]:\n  assumes edge:\"prog \\<turnstile> (_Exit_) -et\\<rightarrow> n'\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> n'; n = (_Exit_)\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> n'; n = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto elim!: JVM_CFG.cases)"], ["proof (state)\nthis:\n  \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> n'; n = (_Exit_)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>prog \\<turnstile> ?n2 -et\\<rightarrow> n';\n   ?n2 = (_Exit_)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "with edge"], ["proof (chain)\npicking this:\n  prog \\<turnstile> (_Exit_) -et\\<rightarrow> n'\n  \\<lbrakk>prog \\<turnstile> ?n2 -et\\<rightarrow> n';\n   ?n2 = (_Exit_)\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  prog \\<turnstile> (_Exit_) -et\\<rightarrow> n'\n  \\<lbrakk>prog \\<turnstile> ?n2 -et\\<rightarrow> n';\n   ?n2 = (_Exit_)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma JVMCFG_Entry_no_targetnode [dest]:\n  assumes edge:\"prog \\<turnstile> n -et\\<rightarrow> (_Entry_)\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "fix n'"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> n'; n' = (_Entry_)\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> n';\n     n' = (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto elim!: JVM_CFG.cases)"], ["proof (state)\nthis:\n  \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> n'; n' = (_Entry_)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> ?n'2;\n   ?n'2 = (_Entry_)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "with edge"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -et\\<rightarrow> (_Entry_)\n  \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> ?n'2;\n   ?n'2 = (_Entry_)\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -et\\<rightarrow> (_Entry_)\n  \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> ?n'2;\n   ?n'2 = (_Entry_)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma JVMCFG_EntryD:\n  \"\\<lbrakk>(P,C,M) \\<turnstile> n -et\\<rightarrow> n'; n = (_Entry_)\\<rbrakk> \n  \\<Longrightarrow> (n' = (_Exit_) \\<and> et = (\\<lambda>s. False)\\<^sub>\\<surd>) \\<or> (n' = (_ [(C,M,0)],None _) \\<and> et = (\\<lambda>s. True)\\<^sub>\\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P, C, M) \\<turnstile> n -et\\<rightarrow> n';\n     n = (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> n' = (_Exit_) \\<and>\n                      et = (\\<lambda>s. False)\\<^sub>\\<surd> \\<or>\n                      n' = (_ [(C, M, 0)],None _) \\<and>\n                      et = (\\<lambda>s. True)\\<^sub>\\<surd>", "by (erule JVM_CFG.cases) simp_all"], ["", "declare split_def [simp add]"], ["", "declare find_handler_for.simps [simp del]"], ["", "(* The following lemma explores many cases, it takes a little to prove *)"], ["", "lemma JVMCFG_edge_det:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> n'; prog \\<turnstile> n -et'\\<rightarrow> n'\\<rbrakk> \\<Longrightarrow> et = et'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow> n';\n     prog \\<turnstile> n -et'\\<rightarrow> n'\\<rbrakk>\n    \\<Longrightarrow> et = et'", "by (erule JVM_CFG.cases, (erule JVM_CFG.cases, fastforce+)+)"], ["", "declare split_def [simp del]"], ["", "declare find_handler_for.simps [simp add]"], ["", "end"]]}