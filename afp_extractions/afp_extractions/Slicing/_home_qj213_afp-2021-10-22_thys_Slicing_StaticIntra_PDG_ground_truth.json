{"file_name": "/home/qj213/afp-2021-10-22/thys/Slicing/StaticIntra/PDG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Slicing", "problem_names": ["lemma PDG_path_cdep:\"n \\<longrightarrow>\\<^sub>c\\<^sub>d n' \\<Longrightarrow> n \\<longrightarrow>\\<^sub>d* n'\"", "lemma PDG_path_ddep:\"n -V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<Longrightarrow> n \\<longrightarrow>\\<^sub>d* n'\"", "lemma PDG_path_Append:\n  \"\\<lbrakk>n'' \\<longrightarrow>\\<^sub>d* n'; n \\<longrightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n \\<longrightarrow>\\<^sub>d* n'\"", "lemma PDG_cdep_edge_CFG_path:\n  assumes \"n \\<longrightarrow>\\<^sub>c\\<^sub>d n'\" obtains as where \"n -as\\<rightarrow>* n'\" and \"as \\<noteq> []\"", "lemma PDG_ddep_edge_CFG_path:\n  assumes \"n -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\" obtains as where \"n -as\\<rightarrow>* n'\" and \"as \\<noteq> []\"", "lemma PDG_path_CFG_path:\n  assumes \"n \\<longrightarrow>\\<^sub>d* n'\" obtains as where \"n -as\\<rightarrow>* n'\"", "lemma PDG_path_Exit:\"\\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'; n' = (_Exit_)\\<rbrakk> \\<Longrightarrow> n = (_Exit_)\"", "lemma PDG_path_not_inner:\n  \"\\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'; \\<not> inner_node n'\\<rbrakk> \\<Longrightarrow> n = n'\"", "lemma PDG_BS_valid_node:\"n \\<in> PDG_BS S \\<Longrightarrow> valid_node n\"", "lemma Exit_PDG_BS:\"n \\<in> PDG_BS {(_Exit_)} \\<Longrightarrow> n = (_Exit_)\"", "lemma PDG_scd:\n  \"PDG sourcenode targetnode kind valid_edge (_Entry_) \n       Def Use state_val (_Exit_) standard_control_dependence\"", "lemmas PDG_cdep_edge = PDG.PDG_cdep_edge[OF PDG_scd]", "lemmas PDG_path_Nil = PDG.PDG_path_Nil[OF PDG_scd]", "lemmas PDG_path_Append = PDG.PDG_path_Append[OF PDG_scd]", "lemmas PDG_path_CFG_path = PDG.PDG_path_CFG_path[OF PDG_scd]", "lemmas PDG_path_cdep = PDG.PDG_path_cdep[OF PDG_scd]", "lemmas PDG_path_ddep = PDG.PDG_path_ddep[OF PDG_scd]", "lemmas PDG_path_not_inner = PDG.PDG_path_not_inner[OF PDG_scd]", "lemmas PDG_path_Exit = PDG.PDG_path_Exit[OF PDG_scd]", "lemma [simp]: \"PDG.PDG_BS sourcenode targetnode valid_edge Def Use \n  standard_control_dependence S = PDG_BS S\"", "lemmas PDG_BS_def = PDG.PDG_BS_def[OF PDG_scd,simplified]", "lemmas PDG_BS_valid_node = PDG.PDG_BS_valid_node[OF PDG_scd,simplified]", "lemmas Exit_PDG_BS = PDG.Exit_PDG_BS[OF PDG_scd,simplified]", "lemma PDG_wcd:\n  \"PDG sourcenode targetnode kind valid_edge (_Entry_) \n       Def Use state_val (_Exit_) weak_control_dependence\"", "lemmas PDG_cdep_edge = PDG.PDG_cdep_edge[OF PDG_wcd]", "lemmas PDG_path_Nil = PDG.PDG_path_Nil[OF PDG_wcd]", "lemmas PDG_path_Append = PDG.PDG_path_Append[OF PDG_wcd]", "lemmas PDG_path_CFG_path = PDG.PDG_path_CFG_path[OF PDG_wcd]", "lemmas PDG_path_cdep = PDG.PDG_path_cdep[OF PDG_wcd]", "lemmas PDG_path_ddep = PDG.PDG_path_ddep[OF PDG_wcd]", "lemmas PDG_path_not_inner = PDG.PDG_path_not_inner[OF PDG_wcd]", "lemmas PDG_path_Exit = PDG.PDG_path_Exit[OF PDG_wcd]", "lemma [simp]: \"PDG.PDG_BS sourcenode targetnode valid_edge Def Use \n  weak_control_dependence S = PDG_BS S\"", "lemmas PDG_BS_def = PDG.PDG_BS_def[OF PDG_wcd,simplified]", "lemmas PDG_BS_valid_node = PDG.PDG_BS_valid_node[OF PDG_wcd,simplified]", "lemmas Exit_PDG_BS = PDG.Exit_PDG_BS[OF PDG_wcd,simplified]"], "translations": [["", "lemma PDG_path_cdep:\"n \\<longrightarrow>\\<^sub>c\\<^sub>d n' \\<Longrightarrow> n \\<longrightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<longrightarrow>\\<^sub>c\\<^sub>d n' \\<Longrightarrow>\n    n \\<longrightarrow>\\<^sub>d* n'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<longrightarrow>\\<^sub>c\\<^sub>d n' \\<Longrightarrow>\n    n \\<longrightarrow>\\<^sub>d* n'", "apply(rule PDG_path_Append_cdep, rule PDG_path_Nil)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<longrightarrow>\\<^sub>c\\<^sub>d n' \\<Longrightarrow> valid_node n\n 2. n \\<longrightarrow>\\<^sub>c\\<^sub>d n' \\<Longrightarrow>\n    n \\<longrightarrow>\\<^sub>c\\<^sub>d n'", "by(auto elim!:PDG_edge.cases dest:control_dependence_path path_valid_node)"], ["", "lemma PDG_path_ddep:\"n -V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<Longrightarrow> n \\<longrightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<Longrightarrow>\n    n \\<longrightarrow>\\<^sub>d* n'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. n -V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<Longrightarrow>\n    n \\<longrightarrow>\\<^sub>d* n'", "apply(rule PDG_path_Append_ddep, rule PDG_path_Nil)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n -V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<Longrightarrow> valid_node n\n 2. n -V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<Longrightarrow>\n    n -?V\\<rightarrow>\\<^sub>d\\<^sub>d n'", "by(auto elim!:PDG_edge.cases dest:path_valid_node simp:data_dependence_def)"], ["", "lemma PDG_path_Append:\n  \"\\<lbrakk>n'' \\<longrightarrow>\\<^sub>d* n'; n \\<longrightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n \\<longrightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' \\<longrightarrow>\\<^sub>d* n';\n     n \\<longrightarrow>\\<^sub>d* n''\\<rbrakk>\n    \\<Longrightarrow> n \\<longrightarrow>\\<^sub>d* n'", "by(induct rule:PDG_path.induct,auto intro:PDG_path.intros)"], ["", "lemma PDG_cdep_edge_CFG_path:\n  assumes \"n \\<longrightarrow>\\<^sub>c\\<^sub>d n'\" obtains as where \"n -as\\<rightarrow>* n'\" and \"as \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>n \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<close>"], ["proof (prove)\nusing this:\n  n \\<longrightarrow>\\<^sub>c\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:PDG_edge.cases dest:control_dependence_path)"], ["", "lemma PDG_ddep_edge_CFG_path:\n  assumes \"n -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\" obtains as where \"n -as\\<rightarrow>* n'\" and \"as \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>n -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close>"], ["proof (prove)\nusing this:\n  n -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:PDG_edge.cases simp:data_dependence_def)"], ["", "lemma PDG_path_CFG_path:\n  assumes \"n \\<longrightarrow>\\<^sub>d* n'\" obtains as where \"n -as\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        n -as\\<rightarrow>* n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>* n'", "from \\<open>n \\<longrightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n \\<longrightarrow>\\<^sub>d* n'", "show \"\\<exists>as. n -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n \\<longrightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>* n'", "proof(induct rule:PDG_path.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       valid_node n \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n\n 2. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'\n 3. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "case (PDG_path_Nil n)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       valid_node n \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n\n 2. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'\n 3. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "hence \"n -[]\\<rightarrow>* n\""], ["proof (prove)\nusing this:\n  valid_node n\n\ngoal (1 subgoal):\n 1. n -[]\\<rightarrow>* n", "by(rule empty_path)"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       valid_node n \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n\n 2. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'\n 3. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>* n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. n -as\\<rightarrow>* n\n\ngoal (2 subgoals):\n 1. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'\n 2. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'\n 2. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "case (PDG_path_Append_cdep n n'' n')"], ["proof (state)\nthis:\n  n \\<longrightarrow>\\<^sub>d* n''\n  \\<exists>as. n -as\\<rightarrow>* n''\n  n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\n\ngoal (2 subgoals):\n 1. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'\n 2. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "from \\<open>n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'", "obtain as where \"n'' -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        n'' -as\\<rightarrow>* n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:PDG_cdep_edge_CFG_path)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'\n 2. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "with \\<open>\\<exists>as. n -as\\<rightarrow>* n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. n -as\\<rightarrow>* n''\n  n'' -as\\<rightarrow>* n'", "obtain as' where \"n -as'@as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  \\<exists>as. n -as\\<rightarrow>* n''\n  n'' -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        n -as' @ as\\<rightarrow>* n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:path_Append)"], ["proof (state)\nthis:\n  n -as' @ as\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'\n 2. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n -as' @ as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>* n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "case (PDG_path_Append_ddep n n'' V n')"], ["proof (state)\nthis:\n  n \\<longrightarrow>\\<^sub>d* n''\n  \\<exists>as. n -as\\<rightarrow>* n''\n  n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "from \\<open>n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close>"], ["proof (chain)\npicking this:\n  n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'", "obtain as where \"n'' -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        n'' -as\\<rightarrow>* n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:PDG_ddep_edge_CFG_path)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "with \\<open>\\<exists>as. n -as\\<rightarrow>* n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. n -as\\<rightarrow>* n''\n  n'' -as\\<rightarrow>* n'", "obtain as' where \"n -as'@as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  \\<exists>as. n -as\\<rightarrow>* n''\n  n'' -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        n -as' @ as\\<rightarrow>* n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:path_Append)"], ["proof (state)\nthis:\n  n -as' @ as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<exists>as. n -as\\<rightarrow>* n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. n -as\\<rightarrow>* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n -as' @ as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>* n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. n -as\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. n -as\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PDG_path_Exit:\"\\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'; n' = (_Exit_)\\<rbrakk> \\<Longrightarrow> n = (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'; n' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = (_Exit_)", "apply(induct rule:PDG_path.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; n = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)\n 2. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        n'' = (_Exit_) \\<Longrightarrow> n = (_Exit_);\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'; n' = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)\n 3. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        n'' = (_Exit_) \\<Longrightarrow> n = (_Exit_);\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n' = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "by(auto elim:PDG_edge.cases dest:Exit_not_control_dependent \n        simp:data_dependence_def)"], ["", "lemma PDG_path_not_inner:\n  \"\\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'; \\<not> inner_node n'\\<rbrakk> \\<Longrightarrow> n = n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'; \\<not> inner_node n'\\<rbrakk>\n    \\<Longrightarrow> n = n'", "proof(induct rule:PDG_path.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; \\<not> inner_node n\\<rbrakk>\n       \\<Longrightarrow> n = n\n 2. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'\n 3. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "case (PDG_path_Nil n)"], ["proof (state)\nthis:\n  valid_node n\n  \\<not> inner_node n\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; \\<not> inner_node n\\<rbrakk>\n       \\<Longrightarrow> n = n\n 2. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'\n 3. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus ?case"], ["proof (prove)\nusing this:\n  valid_node n\n  \\<not> inner_node n\n\ngoal (1 subgoal):\n 1. n = n", "by simp"], ["proof (state)\nthis:\n  n = n\n\ngoal (2 subgoals):\n 1. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'\n 2. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'\n 2. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "case (PDG_path_Append_cdep n n'' n')"], ["proof (state)\nthis:\n  n \\<longrightarrow>\\<^sub>d* n''\n  \\<not> inner_node n'' \\<Longrightarrow> n = n''\n  n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\n  \\<not> inner_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'\n 2. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "from \\<open>n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\\<close> \\<open>\\<not> inner_node n'\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\n  \\<not> inner_node n'", "have False"], ["proof (prove)\nusing this:\n  n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n'\n  \\<not> inner_node n'\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n';\n     \\<not> inner_node n'\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule PDG_edge.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<not> inner_node n'; n'' = n; None = None; n' = n';\n        n controls n' \\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n V n'.\n       \\<lbrakk>\\<not> inner_node n'; n'' = n; None = Some V; n' = n';\n        n influences V in n'\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp:inner_node_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n'' controls n' ; \\<not> valid_node n'\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>n'' controls (_Entry_) ; n' = (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>n'' controls (_Exit_) ; n' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(fastforce dest:control_dependence_path path_valid_node)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n'' controls (_Entry_) ; n' = (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>n'' controls (_Exit_) ; n' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(fastforce dest:control_dependence_path path_valid_node)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' controls (_Exit_) ; n' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> False", "by(fastforce dest:Exit_not_control_dependent)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>n n'' n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' \\<longrightarrow>\\<^sub>c\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'\n 2. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "case (PDG_path_Append_ddep n n'' V n')"], ["proof (state)\nthis:\n  n \\<longrightarrow>\\<^sub>d* n''\n  \\<not> inner_node n'' \\<Longrightarrow> n = n''\n  n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  \\<not> inner_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "from \\<open>n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close> \\<open>\\<not> inner_node n'\\<close>"], ["proof (chain)\npicking this:\n  n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  \\<not> inner_node n'", "have False"], ["proof (prove)\nusing this:\n  n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  \\<not> inner_node n'\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n     \\<not> inner_node n'\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule PDG_edge.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<not> inner_node n'; n'' = n; Some V = None; n' = n';\n        n controls n' \\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n Va n'.\n       \\<lbrakk>\\<not> inner_node n'; n'' = n; Some V = Some Va; n' = n';\n        n influences Va in n'\\<rbrakk>\n       \\<Longrightarrow> False", "by(auto dest:path_valid_node simp:inner_node_def data_dependence_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>n n'' V n'.\n       \\<lbrakk>n \\<longrightarrow>\\<^sub>d* n'';\n        \\<not> inner_node n'' \\<Longrightarrow> n = n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        \\<not> inner_node n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definition of the static backward slice\\<close>"], ["", "text \\<open>Node: instead of a single node, we calculate the backward slice of a set\n  of nodes.\\<close>"], ["", "definition PDG_BS :: \"'node set \\<Rightarrow> 'node set\"\n  where \"PDG_BS S \\<equiv> {n'. \\<exists>n. n' \\<longrightarrow>\\<^sub>d* n \\<and> n \\<in> S \\<and> valid_node n}\""], ["", "lemma PDG_BS_valid_node:\"n \\<in> PDG_BS S \\<Longrightarrow> valid_node n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> PDG_BS S \\<Longrightarrow> valid_node n", "by(auto elim:PDG_path_CFG_path dest:path_valid_node simp:PDG_BS_def \n          split:if_split_asm)"], ["", "lemma Exit_PDG_BS:\"n \\<in> PDG_BS {(_Exit_)} \\<Longrightarrow> n = (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> PDG_BS {(_Exit_)} \\<Longrightarrow> n = (_Exit_)", "by(fastforce dest:PDG_path_Exit simp:PDG_BS_def)"], ["", "end"], ["", "subsection \\<open>Instantiate static PDG\\<close>"], ["", "subsubsection \\<open>Standard control dependence\\<close>"], ["", "locale StandardControlDependencePDG = \n  Postdomination sourcenode targetnode kind valid_edge Entry Exit +\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n  for sourcenode :: \"'edge \\<Rightarrow> 'node\" and targetnode :: \"'edge \\<Rightarrow> 'node\"\n  and kind :: \"'edge \\<Rightarrow> 'state edge_kind\" and valid_edge :: \"'edge \\<Rightarrow> bool\"\n  and Entry :: \"'node\" (\"'('_Entry'_')\") and Def :: \"'node \\<Rightarrow> 'var set\"\n  and Use :: \"'node \\<Rightarrow> 'var set\" and state_val :: \"'state \\<Rightarrow> 'var \\<Rightarrow> 'val\"\n  and Exit :: \"'node\" (\"'('_Exit'_')\")\n\nbegin"], ["", "lemma PDG_scd:\n  \"PDG sourcenode targetnode kind valid_edge (_Entry_) \n       Def Use state_val (_Exit_) standard_control_dependence\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG sourcenode targetnode kind valid_edge (_Entry_) Def Use state_val\n     (_Exit_) standard_control_dependence", "proof(unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'. n controls\\<^sub>s n' \\<Longrightarrow> n' \\<noteq> (_Exit_)\n 2. \\<And>n n'.\n       n controls\\<^sub>s n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "fix n n'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'. n controls\\<^sub>s n' \\<Longrightarrow> n' \\<noteq> (_Exit_)\n 2. \\<And>n n'.\n       n controls\\<^sub>s n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "assume \"n controls\\<^sub>s n'\""], ["proof (state)\nthis:\n  n controls\\<^sub>s n'\n\ngoal (2 subgoals):\n 1. \\<And>n n'. n controls\\<^sub>s n' \\<Longrightarrow> n' \\<noteq> (_Exit_)\n 2. \\<And>n n'.\n       n controls\\<^sub>s n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "show \"n' \\<noteq> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<noteq> (_Exit_)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. n' = (_Exit_) \\<Longrightarrow> False", "assume \"n' = (_Exit_)\""], ["proof (state)\nthis:\n  n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n' = (_Exit_) \\<Longrightarrow> False", "with \\<open>n controls\\<^sub>s n'\\<close>"], ["proof (chain)\npicking this:\n  n controls\\<^sub>s n'\n  n' = (_Exit_)", "show False"], ["proof (prove)\nusing this:\n  n controls\\<^sub>s n'\n  n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Exit_not_standard_control_dependent)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n' \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       n controls\\<^sub>s n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       n controls\\<^sub>s n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       n controls\\<^sub>s n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "assume \"n controls\\<^sub>s n'\""], ["proof (state)\nthis:\n  n controls\\<^sub>s n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       n controls\\<^sub>s n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "thus \"\\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []\""], ["proof (prove)\nusing this:\n  n controls\\<^sub>s n'\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "by(fastforce simp:standard_control_dependence_def)"], ["proof (state)\nthis:\n  \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "lemmas PDG_cdep_edge = PDG.PDG_cdep_edge[OF PDG_scd]"], ["", "lemmas PDG_path_Nil = PDG.PDG_path_Nil[OF PDG_scd]"], ["", "lemmas PDG_path_Append = PDG.PDG_path_Append[OF PDG_scd]"], ["", "lemmas PDG_path_CFG_path = PDG.PDG_path_CFG_path[OF PDG_scd]"], ["", "lemmas PDG_path_cdep = PDG.PDG_path_cdep[OF PDG_scd]"], ["", "lemmas PDG_path_ddep = PDG.PDG_path_ddep[OF PDG_scd]"], ["", "lemmas PDG_path_not_inner = PDG.PDG_path_not_inner[OF PDG_scd]"], ["", "lemmas PDG_path_Exit = PDG.PDG_path_Exit[OF PDG_scd]"], ["", "definition PDG_BS_s :: \"'node set \\<Rightarrow> 'node set\" (\"PDG'_BS\")\n  where \"PDG_BS S \\<equiv> \n  PDG.PDG_BS sourcenode targetnode valid_edge Def Use standard_control_dependence S\""], ["", "lemma [simp]: \"PDG.PDG_BS sourcenode targetnode valid_edge Def Use \n  standard_control_dependence S = PDG_BS S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG.PDG_BS sourcenode targetnode valid_edge Def Use\n     standard_control_dependence S =\n    PDG_BS S", "by(simp add:PDG_BS_s_def)"], ["", "lemmas PDG_BS_def = PDG.PDG_BS_def[OF PDG_scd,simplified]"], ["", "lemmas PDG_BS_valid_node = PDG.PDG_BS_valid_node[OF PDG_scd,simplified]"], ["", "lemmas Exit_PDG_BS = PDG.Exit_PDG_BS[OF PDG_scd,simplified]"], ["", "(*>*)"], ["", "end"], ["", "subsubsection \\<open>Weak control dependence\\<close>"], ["", "locale WeakControlDependencePDG = \n  StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit +\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n  for sourcenode :: \"'edge \\<Rightarrow> 'node\" and targetnode :: \"'edge \\<Rightarrow> 'node\"\n  and kind :: \"'edge \\<Rightarrow> 'state edge_kind\" and valid_edge :: \"'edge \\<Rightarrow> bool\"\n  and Entry :: \"'node\" (\"'('_Entry'_')\") and Def :: \"'node \\<Rightarrow> 'var set\"\n  and Use :: \"'node \\<Rightarrow> 'var set\" and state_val :: \"'state \\<Rightarrow> 'var \\<Rightarrow> 'val\"\n  and Exit :: \"'node\" (\"'('_Exit'_')\")\n\nbegin"], ["", "lemma PDG_wcd:\n  \"PDG sourcenode targetnode kind valid_edge (_Entry_) \n       Def Use state_val (_Exit_) weak_control_dependence\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG sourcenode targetnode kind valid_edge (_Entry_) Def Use state_val\n     (_Exit_) weak_control_dependence", "proof(unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'. n weakly controls n' \\<Longrightarrow> n' \\<noteq> (_Exit_)\n 2. \\<And>n n'.\n       n weakly controls n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "fix n n'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'. n weakly controls n' \\<Longrightarrow> n' \\<noteq> (_Exit_)\n 2. \\<And>n n'.\n       n weakly controls n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "assume \"n weakly controls n'\""], ["proof (state)\nthis:\n  n weakly controls n'\n\ngoal (2 subgoals):\n 1. \\<And>n n'. n weakly controls n' \\<Longrightarrow> n' \\<noteq> (_Exit_)\n 2. \\<And>n n'.\n       n weakly controls n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "show \"n' \\<noteq> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<noteq> (_Exit_)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. n' = (_Exit_) \\<Longrightarrow> False", "assume \"n' = (_Exit_)\""], ["proof (state)\nthis:\n  n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n' = (_Exit_) \\<Longrightarrow> False", "with \\<open>n weakly controls n'\\<close>"], ["proof (chain)\npicking this:\n  n weakly controls n'\n  n' = (_Exit_)", "show False"], ["proof (prove)\nusing this:\n  n weakly controls n'\n  n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Exit_not_weak_control_dependent)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n' \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       n weakly controls n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       n weakly controls n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       n weakly controls n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "assume \"n weakly controls n'\""], ["proof (state)\nthis:\n  n weakly controls n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       n weakly controls n' \\<Longrightarrow>\n       \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "thus \"\\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []\""], ["proof (prove)\nusing this:\n  n weakly controls n'\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []", "by(fastforce simp:weak_control_dependence_def)"], ["proof (state)\nthis:\n  \\<exists>as. n -as\\<rightarrow>* n' \\<and> as \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "lemmas PDG_cdep_edge = PDG.PDG_cdep_edge[OF PDG_wcd]"], ["", "lemmas PDG_path_Nil = PDG.PDG_path_Nil[OF PDG_wcd]"], ["", "lemmas PDG_path_Append = PDG.PDG_path_Append[OF PDG_wcd]"], ["", "lemmas PDG_path_CFG_path = PDG.PDG_path_CFG_path[OF PDG_wcd]"], ["", "lemmas PDG_path_cdep = PDG.PDG_path_cdep[OF PDG_wcd]"], ["", "lemmas PDG_path_ddep = PDG.PDG_path_ddep[OF PDG_wcd]"], ["", "lemmas PDG_path_not_inner = PDG.PDG_path_not_inner[OF PDG_wcd]"], ["", "lemmas PDG_path_Exit = PDG.PDG_path_Exit[OF PDG_wcd]"], ["", "definition PDG_BS_w :: \"'node set \\<Rightarrow> 'node set\" (\"PDG'_BS\")\n  where \"PDG_BS S \\<equiv> \n  PDG.PDG_BS sourcenode targetnode valid_edge Def Use weak_control_dependence S\""], ["", "lemma [simp]: \"PDG.PDG_BS sourcenode targetnode valid_edge Def Use \n  weak_control_dependence S = PDG_BS S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG.PDG_BS sourcenode targetnode valid_edge Def Use\n     weak_control_dependence S =\n    PDG_BS S", "by(simp add:PDG_BS_w_def)"], ["", "lemmas PDG_BS_def = PDG.PDG_BS_def[OF PDG_wcd,simplified]"], ["", "lemmas PDG_BS_valid_node = PDG.PDG_BS_valid_node[OF PDG_wcd,simplified]"], ["", "lemmas Exit_PDG_BS = PDG.Exit_PDG_BS[OF PDG_wcd,simplified]"], ["", "(*>*)"], ["", "end"], ["", "end"]]}